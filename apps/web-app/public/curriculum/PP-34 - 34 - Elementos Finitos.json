{
  "formatVersion": "1.0",
  "exportDate": "2025-12-04T17:33:56.641Z",
  "appVersion": "1.0",
  "curriculumData": {
    "metadata": {
      "baseOn": "Catálogo dos Cursos de Graduação 2025 - PP-34",
      "lastUpdated": "2025-12-04",
      "totalAtomicSkills": 308
    },
    "areas": [
      {
        "id": "10",
        "name": "Engenharia Mecânica",
        "description": "Área de Engenharia Mecânica, abrangendo disciplinas do Departamento de Turbomáquinas (IEM-TM).",
        "disciplines": [
          {
            "id": "10.1",
            "name": "Elementos Finitos",
            "description": "Conceitos fundamentais: histórico, tensão e equilíbrio, deformações, equações constitutivas, efeito termoelástico, energia potencial total. Método de Rayleigh-Ritz e método de Galerkin. Problemas 1D: coordenadas e funções de interpolação, montagem das matrizes globais. Treliças planas e treliças 3D. Vigas e pórticos: formulação de elementos de viga 2D e 3D. Problemas 2D: elemento triangular e axissimétrico. Elementos isoparamétricos: quadrilátero de 4 nós e integração numérica. Elementos de placa em flexão. Sólidos 3D: elementos tetraédricos e hexaédricos. Problemas de campo escalar: transferência de calor, torção, escoamento potencial, escoamento compressível não viscoso, acústica. Bibliografia: CHANDRUPATLA, T. R.; BELEGUNDU, A. D. Introduction to finite elements in engineering. 3. ed. New York: Prentice Hall, 2002. COOK, R. D. Finite element modeling for stress analysis. New York: Wiley, 1995. REDDY, J. N. An introduction to the finite element method. New York: McGraw Hill, 1993.",
            "mainTopics": [
              {
                "id": "10.1.1",
                "name": "Conceitos Fundamentais",
                "description": "Histórico do método dos elementos finitos, tensão e equilíbrio, deformações, equações constitutivas, efeito termoelástico e energia potencial total.",
                "totalSkills": 56,
                "atomicTopics": [
                  {
                    "id": "10.1.1.1",
                    "name": "Histórico do Método dos Elementos Finitos",
                    "description": "Evolução histórica e desenvolvimento do método dos elementos finitos.",
                    "individualConcepts": [
                      {
                        "id": "34.1.1.1.1",
                        "name": "Precursores Teóricos do Método dos Elementos Finitos",
                        "description": "Fundamentos matemáticos iniciais baseados em métodos variacionais, como os princípios de Rayleigh-Ritz e as primeiras aproximações discretas para problemas contínuos.",
                        "specificSkills": [
                          {
                            "id": "34.1.1.1.1.1",
                            "name": "Explicar o método de Rayleigh-Ritz",
                            "description": "Descrever o método de Rayleigh-Ritz como base teórica para aproximações em problemas de energia potencial, destacando sua aplicação em vibrações e estabilidade antes do MEF moderno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Princípios Variacionais Fundamentais",
                                  "subSteps": [
                                    "Estude o princípio da energia mínima em sistemas elásticos.",
                                    "Revise o teorema de Rayleigh para frequências naturais.",
                                    "Identifique a diferença entre métodos exatos e aproximados.",
                                    "Analise o funcional de energia potencial.",
                                    "Explore o critério de estacionariedade."
                                  ],
                                  "verification": "Resuma em 3 frases os princípios variacionais e Rayleigh.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Mecânica dos Sólidos (ex: Timoshenko), vídeo introdutório sobre cálculo variacional.",
                                  "tips": "Comece com exemplos simples como uma mola para visualizar energia.",
                                  "learningObjective": "Dominar a base teórica variacional para aproximações.",
                                  "commonMistakes": "Confundir energia cinética com potencial; ignorar condições de contorno."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formulação do Método Rayleigh para um Grau de Liberdade",
                                  "subSteps": [
                                    "Derive a equação de Rayleigh para frequência fundamental: ω² = V_max / T_max.",
                                    "Aplique a uma barra axial ou viga em flexão.",
                                    "Calcule energia potencial e cinética assumindo forma modal.",
                                    "Compare com solução exata para validar.",
                                    "Discuta o teorema de Rayleigh como cota superior."
                                  ],
                                  "verification": "Resolva um problema simples e compare erro percentual.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel e lápis, calculadora, software simbólico como Mathematica ou SymPy.",
                                  "tips": "Use funções de deslocamento assumidas simples como seno ou polinômio.",
                                  "learningObjective": "Aplicar Rayleigh para estimativas univariadas.",
                                  "commonMistakes": "Escolha inadequada da função de modo; esquecer normalização."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extensão ao Método Rayleigh-Ritz Multivariado",
                                  "subSteps": [
                                    "Introduza funções de aproximação lineares: u ≈ Σ c_i φ_i.",
                                    "Monte a matriz de rigidez [K] e massa [M] via integrais.",
                                    "Formule o problema de autovalores generalizado [K]{c} = ω² [M]{c}.",
                                    "Resolva para autovalores e autovetores.",
                                    "Interprete resultados como aproximações convergentes."
                                  ],
                                  "verification": "Implemente numericamente para 2 funções e verifique convergência.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Planilha Excel ou MATLAB/Python para matrizes, notas de aula.",
                                  "tips": "Escolha funções φ_i ortogonais e satisfazendo contornos.",
                                  "learningObjective": "Construir e resolver formulações matriciais Ritz.",
                                  "commonMistakes": "Funções não completas; erros em integrais de energia."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicações em Vibrações e Estabilidade e Ligação com MEF",
                                  "subSteps": [
                                    "Aplique a buckling de colunas e vibrações de placas.",
                                    "Discuta convergência com mais funções Ritz.",
                                    "Compare com Método dos Elementos Finitos (MEF) moderno.",
                                    "Analise limitações: precisão em singularidades.",
                                    "Explore implementações computacionais históricas."
                                  ],
                                  "verification": "Desenhe diagrama comparativo Rayleigh-Ritz vs. MEF.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Artigos históricos (Rayleigh, Ritz), software FEA gratuito como FreeCAD.",
                                  "tips": "Use exemplos canônicos como viga engastada livre.",
                                  "learningObjective": "Contextualizar Rayleigh-Ritz como precursor do MEF.",
                                  "commonMistakes": "Superestimar precisão sem convergência; ignorar história."
                                }
                              ],
                              "practicalExample": "Calcule a frequência fundamental de uma viga em cantilever usando Rayleigh-Ritz com duas funções polinomiais: φ1 = x²/L², φ2 = x³/L³. Monte [K] e [M], resolva autovalores e compare com solução exata (erro <5%).",
                              "finalVerifications": [
                                "Explicar verbalmente o princípio variacional em 2 minutos.",
                                "Derivar equação Rayleigh para um sistema simples.",
                                "Montar matrizes para exemplo com 2 DOFs.",
                                "Identificar 3 aplicações pré-MEF.",
                                "Discutir convergência Ritz.",
                                "Comparar acurácia com MEF em diagrama."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação matemática (80% correto).",
                                "Correta interpretação de energias e autovalores.",
                                "Escolha adequada de funções de aproximação.",
                                "Análise de erros e convergência.",
                                "Conexão clara com histórico do MEF.",
                                "Clareza na explicação oral/escrita."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e autovalores.",
                                "Física: Dinâmica de vibrações e estática.",
                                "Computação: Programação matricial e FEA.",
                                "História da Engenharia: Evolução de métodos numéricos."
                              ],
                              "realWorldApplication": "Pré-computadores, engenheiros usavam Rayleigh-Ritz manualmente para projetar pontes e aviões, estimando modos de vibração e cargas críticas de flambagem, base para software MEF modernos como ANSYS."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.1.1.1.1.2",
                            "name": "Identificar contribuições de Richard Courant",
                            "description": "Relatar o trabalho seminal de Courant em 1943 sobre a discretização de domínios com triangulações para resolver problemas de torção, considerado o primeiro uso explícito de conceitos de elementos finitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Pesquisar o background histórico e biográfico de Richard Courant",
                                  "subSteps": [
                                    "Ler biografia resumida de Courant, focando em sua carreira na Alemanha e EUA.",
                                    "Identificar publicações principais antes de 1943, como trabalhos em análise matemática.",
                                    "Contextualizar o período da Segunda Guerra Mundial e sua influência em pesquisas aplicadas.",
                                    "Anotar afiliações institucionais, como NYU Courant Institute.",
                                    "Compilar uma linha do tempo pessoal até 1943."
                                  ],
                                  "verification": "Criar um resumo de 200 palavras com fontes citadas confirmando pelo menos 3 fatos chave.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Acesso à internet ou livros de história da matemática",
                                    "Wikipedia ou biografias acadêmicas",
                                    "Notas em documento digital"
                                  ],
                                  "tips": "Priorize fontes acadêmicas como MathWorld ou artigos do SIAM para precisão.",
                                  "learningObjective": "Compreender o contexto pessoal e acadêmico de Courant que levou à sua contribuição.",
                                  "commonMistakes": [
                                    "Confundir com outros matemáticos como Hilbert",
                                    "Ignorar o impacto da emigração nazista em sua carreira",
                                    "Focar apenas em fatos superficiais sem contexto histórico"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o problema matemático de torção em barras prismáticas",
                                  "subSteps": [
                                    "Revisar a formulação clássica do problema de torção de Saint-Venant.",
                                    "Entender as equações diferenciais parciais envolvidas (equação de Laplace para função de tensão).",
                                    "Explorar métodos analíticos tradicionais e suas limitações para geometrias complexas.",
                                    "Visualizar diagramas de barras prismáticas e distribuições de tensão.",
                                    "Calcular um exemplo simples analítico para uma seção circular."
                                  ],
                                  "verification": "Resolver e plotar a solução analítica para torção em seção retangular, comparando com referências.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Livro de mecânica dos sólidos (ex: Timoshenko)",
                                    "Software de plotagem como MATLAB ou Python (Matplotlib)",
                                    "Artigos introdutórios sobre torção"
                                  ],
                                  "tips": "Use animações online para visualizar deformações em torção para melhor intuição.",
                                  "learningObjective": "Dominar o problema que Courant abordou, preparando para sua solução discreta.",
                                  "commonMistakes": [
                                    "Confundir torção com flexão",
                                    "Ignorar condições de contorno essenciais",
                                    "Subestimar a não-linearidade em seções irregulares"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o trabalho seminal de Courant em 1943 sobre discretização",
                                  "subSteps": [
                                    "Localizar e ler o paper 'Variational methods for the solution of problems of equilibrium and vibrations' (1943).",
                                    "Identificar a proposta de dividir o domínio em triângulos para aproximar soluções variacionais.",
                                    "Examinar a formulação variacional e como triangulações aproximam a função de tensão.",
                                    "Desenhar manualmente uma triangulação simples para uma seção transversal.",
                                    "Comparar com métodos de Rayleigh-Ritz contemporâneos."
                                  ],
                                  "verification": "Reproduzir um diagrama de triangulação de Courant e explicar em 1 parágrafo sua função.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "PDF do paper de Courant (disponível em arquivos acadêmicos)",
                                    "Papel e lápis para esboços",
                                    "Ferramentas de visualização como GeoGebra"
                                  ],
                                  "tips": "Foquem nas figuras do paper; elas ilustram melhor que o texto denso.",
                                  "learningObjective": "Extrair e descrever o método de discretização como precursor dos elementos finitos.",
                                  "commonMistakes": [
                                    "Interpretar como FEM completo sem reconhecer limitações (ex: linearidade assumida)",
                                    "Ignorar base variacional",
                                    "Confundir com malha finita moderna"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar a contribuição de Courant com conceitos modernos de Elementos Finitos",
                                  "subSteps": [
                                    "Comparar triangulações de Courant com malhas triangulares em software FEM (ex: ANSYS).",
                                    "Destacar similaridades: funções de forma lineares, minimização de energia.",
                                    "Discutir limitações de Courant (domínios 2D, torção específica) vs. FEM geral.",
                                    "Citar referências históricas que reconhecem Courant como precursor (ex: Zienkiewicz).",
                                    "Sintetizar em uma tabela de comparações."
                                  ],
                                  "verification": "Produzir uma tabela comparativa com 5 similaridades/diferenças entre método de Courant e FEM.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro 'The Finite Element Method' de Zienkiewicz",
                                    "Artigos de revisão histórica do FEM",
                                    "Planilha ou tabela em Markdown"
                                  ],
                                  "tips": "Use timelines visuais para mostrar evolução de Courant (1943) a Clough (1960).",
                                  "learningObjective": "Identificar explicitamente como o trabalho de Courant introduziu conceitos chave de FEM.",
                                  "commonMistakes": [
                                    "Superestimar o escopo (não era FEM computacional)",
                                    "Omitir créditos a outros precursores como Hrenikoff",
                                    "Ignorar contexto computacional ausente em 1943"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de análise de torção de uma hélice de navio com seção irregular, aplique o conceito de Courant dividindo manualmente a seção em triângulos, aproximando a função de tensão via minimização variacional em uma planilha, validando contra solução numérica em software FEM.",
                              "finalVerifications": [
                                "Citar corretamente o ano (1943) e título aproximado do trabalho de Courant.",
                                "Desenhar uma triangulação válida para um domínio 2D simples.",
                                "Explicar como o método resolve o problema de torção via variacional.",
                                "Identificar pelo menos 3 conceitos FEM originados (malha, elementos triangulares, energia mínima).",
                                "Diferenciar de métodos posteriores como FEM de Clough-Tocher.",
                                "Relatar limitações do método de Courant com precisão."
                              ],
                              "assessmentCriteria": [
                                "Precisão factual: 100% correto sobre data, problema e método.",
                                "Profundidade de análise: Demonstra compreensão variacional e discretização.",
                                "Clareza na síntese: Explicação concisa relacionando a FEM moderna.",
                                "Uso de evidências: Citações de fontes primárias/secundárias.",
                                "Criatividade: Diagramas ou tabelas originais ilustrando conceitos.",
                                "Completude: Cobertura de contexto histórico e limitações."
                              ],
                              "crossCurricularConnections": [
                                "História da Ciência: Evolução da matemática aplicada durante WWII.",
                                "Matemática: Métodos variacionais e equações diferenciais parciais.",
                                "Física: Mecânica dos sólidos e teoria da elasticidade.",
                                "Computação: Precursores de algoritmos numéricos e malhas em simulações."
                              ],
                              "realWorldApplication": "O método de Courant pavimentou o caminho para simulações FEM em engenharia aeroespacial (análise de asas torcidas), automotiva (eixos de transmissão) e civil (torque em vigas irregulares), permitindo otimização de designs complexos sem protótipos físicos caros."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.1.1.1.1.3",
                            "name": "Discutir o framework method de Hrenikoff",
                            "description": "Explicar a abordagem de Hrenikoff em 1941, que introduziu estruturas de barras interconectadas como aproximação para continua, pavimentando o caminho para malhas finitas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Contextualizar o período histórico e métodos prévios ao framework de Hrenikoff",
                                  "subSteps": [
                                    "Pesquisar o estado da análise estrutural na década de 1940, focando em métodos exatos como energia de Castigliano e teorema de Rayleigh-Ritz.",
                                    "Identificar limitações dos métodos analíticos para geometrias complexas e continua.",
                                    "Ler resumo do artigo de Hrenikoff publicado em 1941 no Journal of Applied Mechanics.",
                                    "Anotar contribuições de precursores como Courant (1943, mas pós-Hrenikoff) para comparação futura.",
                                    "Mapear a necessidade de aproximações numéricas discretas."
                                  ],
                                  "verification": "Resumo escrito de 200 palavras sobre o contexto histórico, com referências citadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Artigo original de Hrenikoff (1941), livros como 'The Finite Element Method' de Zienkiewicz, acesso à internet para papers históricos.",
                                  "tips": "Use timelines para visualizar a evolução; foque em problemas reais da época como análise de aviões.",
                                  "learningObjective": "Compreender o gap histórico que motivou o framework method.",
                                  "commonMistakes": "Confundir Hrenikoff com Hrenikoff Jr. ou ignorar o foco em estruturas de barras."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever os princípios fundamentais do framework method",
                                  "subSteps": [
                                    "Explicar o conceito central: representação de um contínuo por uma rede de barras interconectadas (framework).",
                                    "Detalhar como as barras substituem elementos contínuos, com nós nas interseções.",
                                    "Discutir formulação baseada em equilíbrio de forças nos nós e compatibilidade de deformações.",
                                    "Ilustrar com diagrama simples de uma treliça aproximando uma placa.",
                                    "Comparar com métodos de momento de flexão distribuído."
                                  ],
                                  "verification": "Diagrama desenhado e explicação oral gravada de 5 minutos sobre os princípios.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel, lápis, software de desenho como Draw.io, cópia do paper de Hrenikoff.",
                                  "tips": "Desenhe redes progressivamente mais finas para mostrar convergência.",
                                  "learningObjective": "Dominar a definição e formulação básica do método.",
                                  "commonMistakes": "Interpretar como método de elementos finitos pleno; era apenas framework de barras."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a aproximação de continua e exemplos de aplicação",
                                  "subSteps": [
                                    "Modelar um contínuo 2D (ex: placa) como grade de barras axiais.",
                                    "Derivar equações de equilíbrio para um nó interno da rede.",
                                    "Calcular rigidez equivalente de barras interconectadas.",
                                    "Simular refinamento da malha e observar convergência para solução exata.",
                                    "Discutir extensões para 3D e problemas dinâmicos."
                                  ],
                                  "verification": "Cálculo manual de uma rede 2x2 barras com cargas aplicadas, comparando com solução analítica.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Calculadora, planilha Excel ou MATLAB para matrizes de rigidez, exemplos do paper.",
                                  "tips": "Comece com malha grosseira para validar intuição antes de refinar.",
                                  "learningObjective": "Aplicar o método em uma aproximação numérica simples.",
                                  "commonMistakes": "Negligenciar condições de contorno ou assumir comportamento flexural sem justificativa."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar contribuições, limitações e impacto nos elementos finitos",
                                  "subSteps": [
                                    "Listar vantagens: simplicidade computacional, generalidade para continua.",
                                    "Identificar limitações: restrito a barras axiais, baixa precisão em cisalhamento.",
                                    "Comparar com MEF moderno (polinômios em elementos arbitrários).",
                                    "Discutir legado: ponte para malhas finitas de Turner (1956) e Clough (1960).",
                                    "Redigir parágrafo sobre importância histórica."
                                  ],
                                  "verification": "Ensaio de 300 palavras avaliando prós/contras e legado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livros de história MEF, timeline de desenvolvimento do MEF.",
                                  "tips": "Use tabela comparativa para clareza visual.",
                                  "learningObjective": "Criticar o método e conectá-lo à evolução do MEF.",
                                  "commonMistakes": "Superestimar precisão; era uma aproximação grosseira."
                                }
                              ],
                              "practicalExample": "Modelar uma placa retangular sob tração uniaxial usando uma grade 3x3 de barras interconectadas: aplicar carga nas bordas, montar sistema de equações nos 16 nós e resolver deslocamentos, comparando com solução analítica ε = σ/E.",
                              "finalVerifications": [
                                "Explicar verbalmente os princípios do framework em menos de 3 minutos.",
                                "Desenhar e rotular uma rede de barras aproximando um contínuo.",
                                "Citar o paper exato (Hrenikoff, 1941) e seu journal.",
                                "Comparar com Rayleigh-Ritz em 2 pontos chave.",
                                "Identificar 3 limitações e 2 contribuições.",
                                "Simular refinamento de malha em exemplo simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão histórica e factual (30%)",
                                "Clareza na explicação de conceitos (25%)",
                                "Profundidade na análise de aproximações (20%)",
                                "Uso correto de terminologia técnica (15%)",
                                "Conexão com evolução do MEF (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sistemas lineares e teoria de grafos para redes de barras.",
                                "História da Ciência: Evolução de métodos numéricos na engenharia.",
                                "Física: Mecânica dos sólidos e equilíbrio de forças.",
                                "Informática: Precursor de algoritmos de malhas em FEM software."
                              ],
                              "realWorldApplication": "O framework de Hrenikoff foi base para softwares FEM como ANSYS e NASTRAN, usados no projeto de estruturas aeroespaciais (ex: fuselagem de aviões), pontes e automóveis, permitindo simulações precisas de tensões em continua complexos antes da era computacional plena."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "34.1.1.1.2",
                        "name": "Desenvolvimento Inicial nas Décadas de 1940 e 1950",
                        "description": "Avanços práticos em engenharia estrutural, com formulações baseadas em energia e aplicações em aeroespacial e análise de tensões.",
                        "specificSkills": [
                          {
                            "id": "34.1.1.1.2.1",
                            "name": "Descrever as contribuições de John Argyris",
                            "description": "Analisar o trabalho de Argyris nos anos 1950, que aplicou métodos de energia mínima para análise de estruturas aeronáuticas, utilizando triangulações flexíveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Contextualizar a vida e carreira inicial de John Argyris",
                                  "subSteps": [
                                    "Pesquise a biografia de John Argyris, focando em sua formação em engenharia aeroespacial na Alemanha e Grécia nos anos 1940.",
                                    "Identifique sua migração para o Reino Unido em 1950 e afiliação com o Imperial College London.",
                                    "Registre datas chave: nascimento em 1913, trabalhos iniciais em aerodinâmica.",
                                    "Anote influências como Richard von Mises e sua transição para análise estrutural.",
                                    "Compile uma linha do tempo pessoal resumida em 5-7 pontos."
                                  ],
                                  "verification": "Criar um resumo de 200 palavras sobre sua trajetória inicial, citando pelo menos 3 fontes confiáveis.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Wikipedia (John Argyris), artigos acadêmicos no Google Scholar, livro 'The Finite Element Method' de Zienkiewicz (edições iniciais).",
                                  "tips": "Use fontes primárias como obituários da Royal Society para precisão histórica.",
                                  "learningObjective": "Compreender o background que levou Argyris à inovação em métodos numéricos estruturais.",
                                  "commonMistakes": "Confundir com outros pioneiros como Clough; ignorar seu trabalho pré-1950 em aerodinâmica."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender os princípios de energia mínima em análise estrutural",
                                  "subSteps": [
                                    "Revise o Princípio dos Trabalhos Virtuais e o Teorema de Castigliano para energia potencial.",
                                    "Estude a formulação variacional: minimização da energia total de deformação + trabalho externo.",
                                    "Compare com métodos de equilíbrio diferencial tradicionais (ex: equações de Navier para vigas).",
                                    "Analise equações matemáticas básicas: δΠ = 0, onde Π é a energia funcional.",
                                    "Resolva um exemplo simples de uma viga em flexão usando minimização de energia."
                                  ],
                                  "verification": "Derivar a equação de rigidez de uma barra axial via energia mínima e verificar numericamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Livro 'Structural Analysis' de Hibbeler (capítulo de energia), Khan Academy vídeos sobre métodos energéticos, caderno para cálculos.",
                                  "tips": "Visualize energia como 'armazenamento elástico' para intuição física.",
                                  "learningObjective": "Dominar a base teórica que Argyris adaptou para discretização.",
                                  "commonMistakes": "Confundir energia complementar com energia de deformação; pular derivação variacional."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar a aplicação de Argyris em estruturas aeronáuticas com triangulações flexíveis",
                                  "subSteps": [
                                    "Leia o paper seminal de Argyris (1954-1957) na série 'Handbook of Aeronautics', focando em triangulações.",
                                    "Descreva triangulações flexíveis: malhas triangulares com nós e barras como elementos iniciais.",
                                    "Analise como ele montou matrizes de rigidez locais e assemblou globalmente via energia mínima.",
                                    "Estude casos: cascas de aeronaves, fuselagens sob cargas aerodinâmicas.",
                                    "Compare com abordagens contemporâneas como Courant (1943) em elipses."
                                  ],
                                  "verification": "Esboçar uma triangulação simples de uma placa aeronáutica e listar graus de liberdade.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Papers originais de Argyris (disponíveis no ResearchGate ou AIAA archives), software como MATLAB para matrizes de rigidez.",
                                  "tips": "Comece com malhas grosseiras para entender montagem antes de refinar.",
                                  "learningObjective": "Identificar como Argyris operacionalizou energia mínima computacionalmente.",
                                  "commonMistakes": "Subestimar o aspecto manual pré-computadores; ignorar adaptação para não-lineares."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar contribuições e impacto histórico no MEF",
                                  "subSteps": [
                                    "Liste 5 contribuições chave: triangulações flexíveis, matriz de rigidez sistemática, aplicações aeroespaciais.",
                                    "Discuta limitações: computação manual, extensão para 3D.",
                                    "Conecte ao MEF moderno: influência em Turner (1956) e códigos FEM atuais.",
                                    "Avalie reconhecimento: prêmios, citações (>10k).",
                                    "Escreva um parágrafo sintetizando seu legado nos anos 1950."
                                  ],
                                  "verification": "Produzir um infográfico ou tabela comparando contribuições de Argyris vs. outros pioneiros (Hrenikoff, McHenry).",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Timeline do MEF (Wikipedia 'Finite element method'), biografias em 'A History of the Finite Element Method' de Logcher.",
                                  "tips": "Use bullet points para síntese clara antes de narrativa.",
                                  "learningObjective": "Articular o papel pivotal de Argyris no nascimento do MEF.",
                                  "commonMistakes": "Atribuir invenções erradas (ex: confundir com elementos poligonais de outros)."
                                }
                              ],
                              "practicalExample": "Analise uma asa de avião simplificada: divida em 6 triângulos flexíveis, compute matriz de rigidez via energia mínima para cargas de sustentação, simulando deformações como Argyris fez em projetos da Bristol Aircraft.",
                              "finalVerifications": [
                                "Liste corretamente 4 contribuições principais de Argyris nos anos 1950.",
                                "Explique como triangulações flexíveis se relacionam com minimização de energia.",
                                "Descreva um exemplo aeronáutico do seu trabalho com precisão histórica.",
                                "Compare impacto de Argyris com contemporâneos como Courant ou Turner.",
                                "Resuma o legado em uma frase concisa e precisa.",
                                "Identifique fontes primárias usadas na descrição."
                              ],
                              "assessmentCriteria": [
                                "Precisão factual: 100% das datas e contribuições corretas (30%).",
                                "Profundidade técnica: Explicação clara de energia mínima e triangulações (25%).",
                                "Estrutura lógica: Narrativa cronológica e conectada (20%).",
                                "Uso de evidências: Citações de pelo menos 3 fontes (15%).",
                                "Clareza e concisão: Linguagem acessível sem jargão excessivo (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e minimização funcional.",
                                "História da Ciência: Evolução de métodos numéricos no pós-guerra.",
                                "Física: Mecânica dos sólidos e princípios energéticos.",
                                "Computação: Primeiros algoritmos de assemblagem matricial pré-FORTRAN."
                              ],
                              "realWorldApplication": "As triangulações flexíveis de Argyris formam a base para simulações FEM em design de aviões modernos (ex: Boeing 787), otimização de fuselagens e testes virtuais de fadiga estrutural, economizando milhões em protótipos físicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.1.1.1.1"
                            ]
                          },
                          {
                            "id": "34.1.1.1.2.2",
                            "name": "Explicar o paper de Turner et al. (1956)",
                            "description": "Detalhar a publicação de Turner, Clough, Martin e Topp em 1956, que introduziu elementos polinomiais para tensão plana constante, marco na formulação de deslocamentos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Acessar e compreender o contexto histórico do paper",
                                  "subSteps": [
                                    "Pesquise o paper 'Stresses in a plate due to the presence of cracks and sharp corners' por Turner, Clough, Martin e Topp (1956) em bases como Google Scholar, JSTOR ou bibliotecas acadêmicas.",
                                    "Leia o resumo e a introdução para identificar o problema: análise de tensão plana em placas com irregularidades.",
                                    "Revise o estado da arte pré-1956, como trabalhos de Hrenikoff (1941) e Courant (1943), para contextualizar a inovação.",
                                    "Anote as motivações: necessidade de formulação baseada em deslocamentos para elementos polinomiais em tensão plana constante."
                                  ],
                                  "verification": "Confirme que você pode resumir o contexto em 3-5 frases precisas, citando referências anteriores.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Acesso online ao paper (JSTOR ou archive.org)",
                                    "Notas de aula sobre história do MEF",
                                    "Calculadora ou software de anotações (ex: Notion ou PDF reader)"
                                  ],
                                  "tips": "Comece pelo abstract para ganhar visão geral antes de mergulhar no texto completo.",
                                  "learningObjective": "Entender o background histórico que levou à publicação, identificando gaps resolvidos pelo paper.",
                                  "commonMistakes": [
                                    "Ignorar referências prévias, achando o paper isolado",
                                    "Confundir tensão plana com tensão uni-dimensional"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a formulação principal: elementos polinomiais para tensão plana",
                                  "subSteps": [
                                    "Identifique a assunção de campo de deslocamentos polinomial completo de terceira ordem para o triângulo.",
                                    "Estude as equações de tensão e deformação derivadas da minimização da energia potencial total.",
                                    "Examine a implementação numérica: montagem da matriz de rigidez para elemento triangular constante.",
                                    "Compare com formulações de strain constante anteriores, destacando a melhoria em precisão."
                                  ],
                                  "verification": "Reproduza manualmente a equação do campo de deslocamento u(x,y) = a0 + a1x + a2y + a3x² + ... em um caderno.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Paper original (seções 2-4)",
                                    "Lápis, papel e calculadora para derivações",
                                    "Software como MATLAB para validar matrizes simples"
                                  ],
                                  "tips": "Desenhe o elemento triangular e label os nós para visualizar as funções de forma.",
                                  "learningObjective": "Dominar a inovação central: uso de polinômios para formulação de deslocamentos em tensão plana constante.",
                                  "commonMistakes": [
                                    "Confundir ordem do polinômio (é completo de 3ª ordem, 10 termos)",
                                    "Pular derivação da energia de deformação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar o impacto e limitações do paper",
                                  "subSteps": [
                                    "Discuta o marco: primeiro uso sistemático de elementos finitos 2D para problemas elásticos lineares.",
                                    "Analise limitações: locking em elementos lineares e necessidade de refinamento de malha.",
                                    "Compare com evoluções posteriores (ex: Zienkiewicz nos anos 60).",
                                    "Prepare um diagrama de timeline mostrando posição do paper na história do MEF."
                                  ],
                                  "verification": "Crie uma tabela comparativa com 3 trabalhos prévios e 2 posteriores, destacando contribuições.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livros de história do MEF (ex: 'The Finite Element Method' de Zienkiewicz)",
                                    "Ferramentas de diagrama (ex: Draw.io ou PowerPoint)"
                                  ],
                                  "tips": "Foque em 'por quês': por que polinômios de deslocamento foram revolucionários?",
                                  "learningObjective": "Compreender a significância histórica como ponte para MEF moderno.",
                                  "commonMistakes": [
                                    "Superestimar o paper como 'invenção' do MEF (foi marco na formulação)",
                                    "Ignorar problemas numéricos como ill-conditioning"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar a explicação do paper de forma estruturada",
                                  "subSteps": [
                                    "Escreva um resumo em 300 palavras cobrindo contexto, método, resultados e impacto.",
                                    "Grave um vídeo ou áudio de 5 minutos explicando para um colega fictício.",
                                    "Responda a 5 perguntas comuns: 'O que é tensão plana constante?', 'Qual polinômio foi usado?', etc.",
                                    "Refine com feedback autoavaliado usando critérios de clareza e precisão."
                                  ],
                                  "verification": "Peça a alguém para testar se entendeu o paper após sua explicação (taxa de acerto >80%).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Gravador de áudio/vídeo (celular)",
                                    "Modelo de perguntas preparadas",
                                    "Folha de autoavaliação"
                                  ],
                                  "tips": "Use analogias: compare elemento finito a 'Lego' para estruturas complexas.",
                                  "learningObjective": "Capacitar-se a explicar o paper de forma clara e didática para audiências variadas.",
                                  "commonMistakes": [
                                    "Usar jargão excessivo sem definir termos",
                                    "Focar só em matemática, ignorando contexto histórico"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar conhecimentos em uma apresentação final",
                                  "subSteps": [
                                    "Crie slides com: slide 1 contexto, slide 2 formulação, slide 3 impacto.",
                                    "Inclua equações chave e um gráfico de tensão do paper.",
                                    "Simule uma apresentação de 10 minutos.",
                                    "Colete feedback ou autoavalie gravando."
                                  ],
                                  "verification": "Verifique se a apresentação cobre todos os pontos sem erros factuais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de slides (PowerPoint/Google Slides)",
                                    "Gravação da apresentação"
                                  ],
                                  "tips": "Mantenha visual: use imagens de malhas triangulares.",
                                  "learningObjective": "Integrar todo o conhecimento em uma narrativa coesa e persuasiva.",
                                  "commonMistakes": [
                                    "Sobrecarregar slides com texto",
                                    "Esquecer limitações para parecer perfeito"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de análise de uma placa com furo sob tração, use o approach de Turner para meshar com triângulos polinomiais e prever concentrações de tensão, validando com software como ANSYS.",
                              "finalVerifications": [
                                "Pode citar exatamente o título e autores do paper?",
                                "Descreve corretamente o campo de deslocamentos polinomial usado?",
                                "Explica por que foi marco na formulação de deslocamentos?",
                                "Identifica pelo menos 2 limitações do método proposto?",
                                "Compara com 1 trabalho anterior (ex: Courant)?",
                                "Resume o paper em <200 palavras com precisão factual?",
                                "Demonstra em diagrama a montagem da matriz de rigidez?"
                              ],
                              "assessmentCriteria": [
                                "Precisão factual: citação correta de equações e contribuições (30%)",
                                "Clareza na explicação: uso de linguagem acessível e estrutura lógica (25%)",
                                "Profundidade histórica: conexão com evolução do MEF (20%)",
                                "Capacidade de síntese: resumo conciso e impactante (15%)",
                                "Criatividade em exemplos: analogias e aplicações práticas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Polinômios e funções de interpolação (análise numérica)",
                                "Física: Teoria da elasticidade e tensão-deformação",
                                "História da Ciência: Evolução de métodos computacionais na engenharia",
                                "Programação: Implementação inicial de solvers matriciais"
                              ],
                              "realWorldApplication": "Esse conhecimento permite engenheiros apreciaram como MEF evoluiu de papers manuais para simulações em aviões (ex: Boeing usa FEA descendente de Turner para fadiga em asas), otimizando designs sem protótipos físicos caros."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.1.1.1.2"
                            ]
                          },
                          {
                            "id": "34.1.1.1.2.3",
                            "name": "Relacionar avanços com necessidades da engenharia",
                            "description": "Contextualizar como as demandas da Segunda Guerra Mundial e da corrida espacial impulsionaram o desenvolvimento computacional inicial do MEF em grandes estruturas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Investigar demandas de engenharia durante a Segunda Guerra Mundial",
                                  "subSteps": [
                                    "Pesquisar o contexto histórico da WWII, focando em projetos aeroespaciais e militares como bombardeiros e mísseis.",
                                    "Identificar desafios estruturais em grandes aeronaves e veículos, como análise de tensões em alas e fuselagens.",
                                    "Analisar como cálculos manuais eram limitados para estruturas complexas e grandes.",
                                    "Documentar exemplos específicos, como o desenvolvimento do B-29 Superfortress.",
                                    "Mapear necessidades iniciais de simulação computacional para otimizar designs sob pressão de tempo."
                                  ],
                                  "verification": "Criar um resumo de 300 palavras listando 5 demandas chave da WWII com evidências históricas.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livros de história da engenharia (ex: 'The Making of the Atomic Bomb'), sites como NASA.gov, artigos acadêmicos sobre história do MEF.",
                                  "tips": "Use timelines visuais para conectar eventos históricos com avanços tecnológicos.",
                                  "learningObjective": "Compreender como restrições de guerra aceleraram a necessidade de métodos numéricos eficientes.",
                                  "commonMistakes": "Confundir WWII com pós-guerra; ignorar o papel da balística e aerodinâmica."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar impulsos da Corrida Espacial nos anos 1950",
                                  "subSteps": [
                                    "Estudar o contexto da Guerra Fria e programas espaciais como o Sputnik e Apollo.",
                                    "Identificar desafios em estruturas espaciais massivas, como foguetes Saturn V e cascos de naves.",
                                    "Examinar limitações de métodos analíticos tradicionais para simulações dinâmicas e térmicas.",
                                    "Pesquisar contribuições iniciais de pioneiros como Argyris e Turner em computação para MEF.",
                                    "Compilar dados sobre o primeiro uso de computadores digitais em análises estruturais."
                                  ],
                                  "verification": "Produzir uma tabela comparativa de 3 projetos espaciais destacando problemas resolvidos por proto-MEF.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Documentos da NASA (ex: relatórios Apollo), vídeos educativos sobre corrida espacial, papers como 'The Genesis of the Finite Element Method' de Zienkiewicz.",
                                  "tips": "Foque em transições de hand-calculations para códigos FORTRAN iniciais.",
                                  "learningObjective": "Reconhecer como ambições espaciais demandaram MEF computacional para estruturas grandes e complexas.",
                                  "commonMistakes": "Superestimar o papel imediato de computadores modernos; negligenciar limitações de hardware da época."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o desenvolvimento inicial computacional do MEF",
                                  "subSteps": [
                                    "Traçar a evolução do MEF de manual (Richardson, 1911) para computacional (Clough, 1956).",
                                    "Estudar adaptações para computadores como IBM 704, focando em malhas para grandes estruturas.",
                                    "Examinar equações matriciais simplificadas usadas em aplicações aeroespaciais iniciais.",
                                    "Comparar códigos primitivos com ferramentas modernas para ilustrar progressos.",
                                    "Identificar inovações chave impulsionadas por necessidades de WWII e espaço."
                                  ],
                                  "verification": "Desenhar um fluxograma mostrando a cadeia causal de necessidade → inovação MEF.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Software gratuito como FreeCAD para simulações simples, artigos históricos do Journal of the Aeronautical Sciences.",
                                  "tips": "Use analogias com planilhas modernas para entender computação limitada dos anos 1940-50.",
                                  "learningObjective": "Mapear avanços técnicos do MEF diretamente às pressões engenheirísticas históricas.",
                                  "commonMistakes": "Atribuir MEF puramente a acadêmicos sem contexto de financiamento militar/espacial."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar relações entre avanços e necessidades da engenharia",
                                  "subSteps": [
                                    "Criar narrativa conectando WWII (balística rápida) e corrida espacial (escala massiva) ao MEF computacional.",
                                    "Avaliar impactos: redução de tempo de design de meses para dias.",
                                    "Discutir lições para engenharia atual, como urgência em crises (ex: COVID).",
                                    "Preparar argumentos contra visões isoladas de história técnica.",
                                    "Revisar e refinar conexões com exemplos quantitativos (ex: redução de peso em 20% via MEF)."
                                  ],
                                  "verification": "Escrever um ensaio de 500 palavras relacionando 3 avanços MEF a necessidades específicas.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Ferramentas de escrita como Google Docs, referências cruzadas dos steps anteriores.",
                                  "tips": "Use frase 'devido a X necessidade, Y avanço ocorreu' para clareza causal.",
                                  "learningObjective": "Contextualizar MEF como resposta pragmática a demandas reais da engenharia.",
                                  "commonMistakes": "Generalizações vagas sem evidências; ignorar limitações éticas de aplicações militares."
                                }
                              ],
                              "practicalExample": "Analisar como o Projeto Manhattan e bombardeiros B-29 durante WWII exigiram simulações rápidas de tensões em reatores e alas, levando a matrizes rígidas iniciais do MEF em códigos como o de Hrenikoff (1941), evoluindo para malhas triangulares computacionais nos anos 1950 para o Saturn V.",
                              "finalVerifications": [
                                "Explicar verbalmente como WWII acelerou MEF de analógico para digital.",
                                "Identificar 3 necessidades espaciais resolvidas por MEF inicial.",
                                "Comparar tempo de análise manual vs. computacional em estruturas grandes.",
                                "Citar 2 pioneiros e suas contribuições ligadas a contextos históricos.",
                                "Demonstrar causalidade em um diagrama de causa-efeito.",
                                "Discutir limitações iniciais superadas por demandas urgentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão histórica: Correta identificação de eventos e timelines (30%).",
                                "Profundidade de conexões: Evidências claras ligando necessidades a avanços (25%).",
                                "Clareza explicativa: Linguagem acessível e lógica sequencial (20%).",
                                "Uso de exemplos: Integração concreta de casos reais (15%).",
                                "Originalidade de insights: Lições além do superficial (10%)."
                              ],
                              "crossCurricularConnections": [
                                "História: Análise de impactos da WWII e Guerra Fria na ciência.",
                                "Computação: Evolução de algoritmos numéricos e programação científica.",
                                "Física: Aplicação de mecânica dos sólidos em contextos dinâmicos.",
                                "Ética: Discussão de dual-use technology em aplicações militares."
                              ],
                              "realWorldApplication": "Entender essas relações ajuda engenheiros atuais a priorizar simulações MEF em projetos urgentes, como drones militares ou satélites, acelerando iterações de design e reduzindo custos em indústrias aeroespaciais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "34.1.1.1.3",
                        "name": "Formalização e Expansão a Partir dos Anos 1960",
                        "description": "Cunhagem do termo 'Método dos Elementos Finitos', desenvolvimento de softwares e ampliação para problemas não lineares e multidisciplinares.",
                        "specificSkills": [
                          {
                            "id": "34.1.1.1.3.1",
                            "name": "Identificar o papel de Ray Clough",
                            "description": "Explicar como Clough cunhou o termo 'Finite Element Method' em 1960, consolidando o método como ferramenta padrão em análise estrutural.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Pesquisar o background histórico e acadêmico de Ray Clough",
                                  "subSteps": [
                                    "Ler biografia resumida de Ray Clough em fontes confiáveis como Wikipedia ou artigos acadêmicos.",
                                    "Identificar sua afiliação com a UC Berkeley e seu foco em engenharia estrutural.",
                                    "Listar contribuições prévias de Clough antes de 1960, como trabalhos em análise de estruturas.",
                                    "Anotar datas chave da carreira de Clough relacionadas ao método dos elementos finitos.",
                                    "Compilar uma linha do tempo pessoal de Clough até 1960."
                                  ],
                                  "verification": "Criar um resumo de 200 palavras sobre a vida e carreira inicial de Clough, citando pelo menos 3 fontes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Acesso à internet",
                                    "Wikipedia",
                                    "Google Scholar",
                                    "Livros de história da engenharia"
                                  ],
                                  "tips": "Priorize fontes acadêmicas para evitar informações imprecisas de sites genéricos.",
                                  "learningObjective": "Compreender o contexto pessoal e profissional de Clough que o levou a cunhar o termo.",
                                  "commonMistakes": "Confundir Ray Clough com outros pesquisadores como John Argyris ou confundir datas de publicações."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a publicação seminal de 1960 de Clough",
                                  "subSteps": [
                                    "Localizar o paper 'The Finite Element Method in Plane Stress Problems' de 1960.",
                                    "Ler o abstract e introdução para identificar o uso explícito do termo 'Finite Element Method'.",
                                    "Destacar trechos onde Clough define ou introduz o termo pela primeira vez.",
                                    "Comparar com publicações anteriores que usavam termos como 'stiffness matrix method'.",
                                    "Extrair citações diretas de Clough sobre o método."
                                  ],
                                  "verification": "Citar verbatim a frase onde Clough cunha o termo e explicar seu contexto em um parágrafo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "PDF do paper original via Google Scholar ou JSTOR",
                                    "Leitor de PDF",
                                    "Caderno de anotações"
                                  ],
                                  "tips": "Use Ctrl+F para buscar 'finite element' no documento para localizar referências rápidas.",
                                  "learningObjective": "Identificar a evidência primária do cunhamento do termo por Clough em 1960.",
                                  "commonMistakes": "Atribuir o paper errado ou ignorar que foi co-autorado com R. J. Melosh."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Contextualizar o impacto da formalização do termo",
                                  "subSteps": [
                                    "Comparar o estado do método antes de 1960 (ex.: direct stiffness method).",
                                    "Explicar como o termo unificou abordagens dispersas em análise estrutural.",
                                    "Pesquisar citações subsequentes do paper de Clough em obras como as de Zienkiewicz.",
                                    "Analisar como o termo se tornou padrão em conferências e softwares dos anos 1960-1970.",
                                    "Mapear a adoção em disciplinas além da estrutural, como térmica."
                                  ],
                                  "verification": "Criar um diagrama de linha do tempo mostrando evolução do termo de 1950 a 1970.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Artigos de revisão histórica sobre MEF",
                                    "Softwares de diagrama como Draw.io",
                                    "Livros como 'The Finite Element Method' de Zienkiewicz"
                                  ],
                                  "tips": "Foque em métricas como número de citações para quantificar o impacto.",
                                  "learningObjective": "Entender como o termo de Clough consolidou o MEF como ferramenta padrão.",
                                  "commonMistakes": "Superestimar o impacto imediato, ignorando que a adoção levou anos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e explicar o papel de Clough em uma apresentação",
                                  "subSteps": [
                                    "Redigir uma explicação clara do papel de Clough em 1-2 parágrafos.",
                                    "Preparar slides ou um pôster resumindo background, paper, contexto e impacto.",
                                    "Praticar explicação oral para um público leigo em engenharia.",
                                    "Incluir referências bibliográficas completas.",
                                    "Autoavaliar a clareza e precisão da explicação."
                                  ],
                                  "verification": "Gravar um vídeo de 3 minutos explicando o papel de Clough e autoavaliar com rubrica.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "PowerPoint ou Google Slides",
                                    "Gravador de vídeo (celular)",
                                    "Referências compiladas"
                                  ],
                                  "tips": "Use analogias simples, como 'cunhar um termo é como nomear uma nova ferramenta para todos usarem'.",
                                  "learningObjective": "Capacitar-se a comunicar efetivamente o legado histórico de Clough.",
                                  "commonMistakes": "Omitir fontes ou exagerar o papel isolado de Clough sem mencionar colaborações."
                                }
                              ],
                              "practicalExample": "Ao analisar a estrutura de uma ponte suspensa usando software como ANSYS, o engenheiro referencia o paper de Clough de 1960 para justificar o uso do termo 'Finite Element Method', destacando como ele padronizou a comunicação em relatórios técnicos para equipes multidisciplinares.",
                              "finalVerifications": [
                                "Citar corretamente o paper de 1960 e a frase cunhadora do termo.",
                                "Explicar o contexto pré-1960 sem o termo unificado.",
                                "Descrever o impacto na adoção do MEF em análises estruturais.",
                                "Identificar pelo menos 2 publicações subsequentes que citam Clough.",
                                "Criar um resumo preciso sem erros factuais.",
                                "Demonstrar compreensão oral ou escrita do legado de Clough."
                              ],
                              "assessmentCriteria": [
                                "Precisão histórica: Ano, paper e citação corretos (30%).",
                                "Profundidade de análise: Contexto e impacto bem explicados (25%).",
                                "Clareza de comunicação: Linguagem acessível e estruturada (20%).",
                                "Uso de evidências: Múltiplas fontes citadas (15%).",
                                "Originalidade: Síntese própria, não cópia (10%)."
                              ],
                              "crossCurricularConnections": [
                                "História da Ciência: Evolução de métodos numéricos na engenharia.",
                                "Matemática: Matrizes de rigidez e formulações discretas.",
                                "Computação: Implementação inicial em códigos Fortran.",
                                "Física: Aplicações em mecânica dos sólidos e dinâmica."
                              ],
                              "realWorldApplication": "Em projetos de engenharia civil moderna, como o design de edifícios altos ou barragens, engenheiros usam o MEF diariamente em softwares comerciais, atribuindo a Clough a padronização que facilitou a colaboração global e o desenvolvimento de ferramentas como NASTRAN pela NASA nos anos 1960."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.1.1.2.2"
                            ]
                          },
                          {
                            "id": "34.1.1.1.3.2",
                            "name": "Descrever o surgimento de softwares MEF",
                            "description": "Relatar o desenvolvimento de programas como NASTRAN (NASA, 1960s-1970s), que popularizou o MEF em indústrias aeroespacial e automotiva.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Contexto Prévio ao Surgimento dos Softwares MEF",
                                  "subSteps": [
                                    "Revise os fundamentos teóricos do MEF desenvolvidos por Courant (1943) e Clough (1956).",
                                    "Identifique limitações dos cálculos manuais na era pré-computacional.",
                                    "Pesquise a necessidade de computação para problemas complexos em engenharia.",
                                    "Anote marcos iniciais como o uso de mainframes IBM nos anos 1950.",
                                    "Compare métodos analíticos tradicionais com a promessa do MEF computacional."
                                  ],
                                  "verification": "Crie um resumo de 1 parágrafo listando 3 limitações pré-softwares e como o MEF as resolveu.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Artigo de Clough (1956) sobre MEF",
                                    "História da NASA online",
                                    "Livro 'The Finite Element Method' de Zienkiewicz"
                                  ],
                                  "tips": "Use timelines visuais para organizar eventos cronologicamente.",
                                  "learningObjective": "Compreender as motivações históricas que pavimentaram o caminho para softwares MEF.",
                                  "commonMistakes": "Confundir datas de contribuições teóricas com implementações computacionais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o Desenvolvimento do NASTRAN pela NASA",
                                  "subSteps": [
                                    "Pesquise o início do projeto NASTRAN em 1964 pela NASA.",
                                    "Identifique líderes como Richard H. MacNeal e o time de desenvolvimento.",
                                    "Analise características chave: suporte a estruturas aeroespaciais complexas.",
                                    "Explore a liberação em 1971 e sua base em Fortran para mainframes.",
                                    "Documente evoluções iniciais até os anos 1970."
                                  ],
                                  "verification": "Monte uma linha do tempo com 5 eventos chave do NASTRAN (1964-1978).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Documentação oficial NASA NASTRAN",
                                    "Site MSC Software (herdeiro do NASTRAN)",
                                    "Vídeos históricos da NASA no YouTube"
                                  ],
                                  "tips": "Foque em fatos verificáveis de fontes primárias para evitar mitos.",
                                  "learningObjective": "Dominar os detalhes técnicos e cronológicos do NASTRAN como pioneiro MEF.",
                                  "commonMistakes": "Atribuir o NASTRAN apenas à NASA sem mencionar colaborações industriais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Popularização em Indústrias Aeroespacial e Automotiva",
                                  "subSteps": [
                                    "Investigue adoção pela Boeing e Lockheed na aeroespacial.",
                                    "Estude impacto na indústria automotiva, como Ford e GM nos anos 1970.",
                                    "Identifique spin-offs como SAMCEF e NISA.",
                                    "Avalie como o NASTRAN reduziu tempos de projeto de meses para dias.",
                                    "Colete evidências de publicações e cases de sucesso."
                                  ],
                                  "verification": "Liste 4 exemplos de aplicações industriais com indústrias e benefícios.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Relatórios históricos da AIAA",
                                    "Artigos SAE sobre MEF automotivo",
                                    "Banco de dados Google Scholar com 'NASTRAN automotive'"
                                  ],
                                  "tips": "Busque métricas quantitativas como redução de custos para tornar concreto.",
                                  "learningObjective": "Reconhecer o papel do NASTRAN na transição do MEF para ferramenta industrial padrão.",
                                  "commonMistakes": "Ignorar barreiras iniciais como custo de mainframes e treinamento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar uma Narrativa Coesa sobre o Surgimento dos Softwares MEF",
                                  "subSteps": [
                                    "Estruture a descrição: introdução, NASTRAN, impactos industriais, conclusão.",
                                    "Incorpore transições lógicas entre contexto, desenvolvimento e expansão.",
                                    "Revise para precisão factual e fluidez narrativa.",
                                    "Pratique verbalizando ou gravando a descrição.",
                                    "Refine com feedback autoavaliado."
                                  ],
                                  "verification": "Escreva um texto de 300-500 palavras descrevendo o surgimento e leia em voz alta sem pausas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Modelo de relatório histórico",
                                    "Ferramenta de gravação de áudio",
                                    "Dicionário técnico de engenharia"
                                  ],
                                  "tips": "Use linguagem acessível, evitando jargões desnecessários para clareza.",
                                  "learningObjective": "Capacitar-se a relatar o histórico de forma estruturada e envolvente.",
                                  "commonMistakes": "Fazer lista de fatos sem conectar em uma história coesa."
                                }
                              ],
                              "practicalExample": "Em uma apresentação de seminário de engenharia, descreva: 'Nos anos 1960, a NASA iniciou o NASTRAN para simular foguetes Apollo, reduzindo iterações físicas em 80%; isso se espalhou para a Boeing em aviões e Ford em crash-tests, revolucionando o design.'",
                              "finalVerifications": [
                                "Pode citar datas precisas de desenvolvimento do NASTRAN (1964-1971)?",
                                "Lista 3 indústrias impactadas e um exemplo por setor?",
                                "Explica como mainframes habilitaram o MEF?",
                                "Diferencia NASTRAN de antecessores teóricos?",
                                "Sintetiza o impacto em uma frase de 20 palavras?",
                                "Identifica 2 spin-offs ou sucessores diretos?"
                              ],
                              "assessmentCriteria": [
                                "Precisão factual (datas, nomes, eventos: 30%)",
                                "Clareza e estrutura narrativa (25%)",
                                "Profundidade de análise de impactos industriais (20%)",
                                "Uso de evidências de fontes confiáveis (15%)",
                                "Fluidez e engajamento na descrição oral/escrita (10%)"
                              ],
                              "crossCurricularConnections": [
                                "História da Computação: Evolução de linguagens como Fortran.",
                                "História da Engenharia: Transição de analógico para digital.",
                                "Programação: Implementação numérica em mainframes.",
                                "Gestão de Projetos: Desenvolvimento colaborativo NASA-indústria."
                              ],
                              "realWorldApplication": "Ao preparar relatórios técnicos para empresas de engenharia, apresentações acadêmicas ou treinamentos corporativos sobre simulação, permitindo contextualizar ferramentas modernas como ANSYS em raízes históricas para melhor compreensão e inovação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.1.1.2.1"
                            ]
                          },
                          {
                            "id": "34.1.1.1.3.3",
                            "name": "Analisar a evolução para problemas avançados",
                            "description": "Discutir a extensão do MEF para dinâmica, não linearidades, fluidos e campos escalares nos anos 1970 em diante, citando referências bibliográficas chave.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o contexto histórico do MEF nos anos 1960 e introdução inicial das extensões nos 1970",
                                  "subSteps": [
                                    "Ler capítulos introdutórios de livros sobre história do MEF, focando em transições de problemas lineares estáticos para dinâmicos.",
                                    "Identificar publicações pioneiras de 1965-1975 que estenderam o método para dinâmica temporal.",
                                    "Mapear cronologia: de Clough e Wilson (1968) para vibrações até Hughes (1970s) em dinâmica não linear.",
                                    "Anotar limitações dos anos 1960 que motivaram expansões.",
                                    "Compilar uma linha do tempo inicial com datas e autores chave."
                                  ],
                                  "verification": "Linha do tempo com pelo menos 5 eventos/marcas históricas documentados em um documento ou slide.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Livros: 'The Finite Element Method' de Zienkiewicz (edições 1971+); artigos de Clough, Wilson; acesso a Google Scholar ou JSTOR.",
                                  "tips": "Use ferramentas como TimelineJS para visualizar a cronologia e facilitar a compreensão.",
                                  "learningObjective": "Compreender as motivações e bases históricas para as extensões do MEF.",
                                  "commonMistakes": "Confundir MEF com outros métodos numéricos como diferenças finitas; ignorar contribuições não ocidentais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar extensões para problemas dinâmicos e não lineares",
                                  "subSteps": [
                                    "Estudar formulações dinâmicas: equações de movimento com integração temporal (Newmark, Wilson-theta).",
                                    "Explorar não linearidades geométricas (grandes deformações) e materiais (plasticidade, hiperelasticidade).",
                                    "Ler papers chave: Hughes & Pister (1978) para dinâmica não linear; Bathe (1982) para métodos implícitos.",
                                    "Comparar abordagens lineares vs. não lineares em termos de matrizes de rigidez e iterações.",
                                    "Simular um exemplo simples de viga vibrante usando software como ANSYS para validar conceitos históricos."
                                  ],
                                  "verification": "Relatório curto com equações derivadas e simulação básica reproduzida.",
                                  "estimatedTime": "6 horas",
                                  "materials": "Papers: Hughes (1976-1980); software gratuito como Code_Aster ou FEniCS; calculadora simbólica (SymPy).",
                                  "tips": "Comece com casos 1D para não linearidades antes de 2D/3D para construir intuição.",
                                  "learningObjective": "Dominar as formulações matemáticas e numéricas das extensões dinâmicas e não lineares.",
                                  "commonMistakes": "Negligenciar estabilidade numérica em esquemas de tempo; superestimar convergência sem iterações Newton-Raphson."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Investigar aplicações em fluidos e campos escalares",
                                  "subSteps": [
                                    "Estudar MEF para equações de Navier-Stokes em fluidos incompressíveis (anos 1970: Oden, Baker).",
                                    "Analisar campos escalares: difusão térmica, potencial eletromagnético (Zienkiewicz & Taylor, 1977).",
                                    "Identificar desafios: estabilização para fluidos (SUPG, Galerkin least-squares).",
                                    "Ler referências: Donea (1984) para fluidos; Johnson (1990s) para evoluções.",
                                    "Mapear evoluções: de estático para convectivo-difusivo e fully coupled."
                                  ],
                                  "verification": "Diagrama de fluxo mostrando pipeline de MEF para um problema de fluido simples.",
                                  "estimatedTime": "5 horas",
                                  "materials": "Livros: 'Finite Elements in Fluids' de Oden; papers via ResearchGate; tutoriais OpenFOAM.",
                                  "tips": "Associe campos escalares a problemas cotidianos como transferência de calor para fixar conceitos.",
                                  "learningObjective": "Entender adaptações do MEF para física de fluidos e campos não mecânicos.",
                                  "commonMistakes": "Confundir MEF com CFD baseado em volumes finitos; ignorar condições de contorno fracas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compilar referências bibliográficas chave e sintetizar a análise evolutiva",
                                  "subSteps": [
                                    "Listar 10+ referências seminal: Zienkiewicz (1977), Hughes (1987), Bathe (1996), etc., com resumos.",
                                    "Escrever discussão: impactos das expansões na engenharia (ex: crash tests, aerodinâmica).",
                                    "Criar ensaio analítico conectando evoluções a avanços computacionais (VAX, supercomputadores).",
                                    "Avaliar limitações persistentes e direções futuras (multifísica).",
                                    "Revisar e citar usando BibTeX ou Zotero para precisão."
                                  ],
                                  "verification": "Ensaio de 1500 palavras com bibliografia formatada e análise crítica.",
                                  "estimatedTime": "7 horas",
                                  "materials": "Gerenciador de referências (Zotero/Mendeley); LaTeX para formatação; bases como Scopus.",
                                  "tips": "Priorize papers com alto número de citações no Google Scholar para relevância.",
                                  "learningObjective": "Capacitar-se a discutir criticamente a evolução histórica com suporte bibliográfico.",
                                  "commonMistakes": "Citar fontes secundárias sem primárias; viés cronológico (ignorar trabalhos paralelos)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar conhecimentos em uma apresentação analítica final",
                                  "subSteps": [
                                    "Estruturar apresentação: intro histórica, extensões por tópico, referências, conclusões.",
                                    "Incluir gráficos/tabelas de evolução (ex: número de papers por década).",
                                    "Praticar discurso destacando inovações chave e contextos computacionais.",
                                    "Receber feedback de pares ou mentor.",
                                    "Refinar com base em verificações finais."
                                  ],
                                  "verification": "Apresentação gravada ou slides com narração, duração 10-15 min.",
                                  "estimatedTime": "4 horas",
                                  "materials": "PowerPoint/Google Slides; gravador de tela (OBS Studio); timer.",
                                  "tips": "Use analogias (ex: MEF como 'Lego avançado' para problemas complexos) para engajar.",
                                  "learningObjective": "Sintetizar análise histórica em comunicação clara e persuasiva.",
                                  "commonMistakes": "Sobrecarregar slides com texto; pular transições lógicas entre tópicos."
                                }
                              ],
                              "practicalExample": "Analisar a evolução do MEF na simulação de colisão veicular: discutir como extensões dinâmicas/não lineares de Belytschko (1970s) permitiram modelos realistas em LS-DYNA, citando papers de 1976-1985.",
                              "finalVerifications": [
                                "Pode listar e resumir 8+ referências chave dos anos 1970-1990 com autores, anos e contribuições específicas.",
                                "Demonstra compreensão das formulações matemáticas para pelo menos 3 extensões (dinâmica, não linear, fluidos).",
                                "Cronologia precisa da evolução sem erros factuais maiores.",
                                "Análise crítica identifica pelo menos 3 impactos na engenharia moderna.",
                                "Bibliografia formatada corretamente em estilo IEEE ou APA.",
                                "Apresentação cobre todos os tópicos com exemplos visuais."
                              ],
                              "assessmentCriteria": [
                                "Precisão histórica e factualidade das referências (30%)",
                                "Profundidade da análise técnica das extensões (25%)",
                                "Qualidade e relevância das citações bibliográficas (20%)",
                                "Clareza e estrutura da discussão evolutiva (15%)",
                                "Integração de contextos computacionais e limitações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "História da Ciência e Tecnologia: evolução paralela com hardware computacional.",
                                "Matemática Avançada: análise numérica, álgebra linear não linear.",
                                "Programação e Computação Científica: implementação em Fortran/C++ históricos.",
                                "Física Aplicada: mecânica dos sólidos/fluidos.",
                                "Gestão de Projetos: tracking de avanços em literatura técnica."
                              ],
                              "realWorldApplication": "Essa análise habilita engenheiros a contextualizar simulações avançadas em FEA software como Abaqus ou COMSOL, otimizando designs em aeroespacial (dinâmica de turbinas), automotivo (crashworthiness não linear) e energia (fluxos em reatores), reduzindo custos de prototipagem física."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.1.1.1.1",
                              "34.1.1.1.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.2",
                    "name": "Tensão e Equilíbrio",
                    "description": "Conceitos de tensão, tipos de tensão e condições de equilíbrio em sólidos deformáveis.",
                    "individualConcepts": [
                      {
                        "id": "34.1.1.1",
                        "name": "Conceito de Tensão",
                        "description": "Definição fundamental de tensão como força interna por unidade de área em sólidos deformáveis, incluindo a representação via tensor de tensões e suas componentes em sistemas de coordenadas.",
                        "specificSkills": [
                          {
                            "id": "34.1.1.1.1",
                            "name": "Definir tensão em sólidos deformáveis",
                            "description": "Explicar tensão como limite de força por área para superfícies infinitesimais, diferenciando tensão média e verdadeira, e sua relevância no contexto do Método dos Elementos Finitos (MEF).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de tensão em sólidos",
                                  "subSteps": [
                                    "Revise a definição de força e área em contextos mecânicos.",
                                    "Visualize um sólido deformável sob carga aplicada.",
                                    "Entenda tensão como uma grandeza intensiva, não extensiva.",
                                    "Discuta exemplos simples como tração em uma barra.",
                                    "Identifique superfícies internas no sólido."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que é tensão sem usar fórmulas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro-texto de Resistência dos Materiais",
                                    "Vídeos introdutórios sobre mecânica dos sólidos (YouTube/Khan Academy)",
                                    "Papel e lápis para esboços"
                                  ],
                                  "tips": "Use analogias como 'pressão em um colchão d'água' para intuitar tensão.",
                                  "learningObjective": "Entender tensão como distribuição de força por área em sólidos deformáveis.",
                                  "commonMistakes": [
                                    "Confundir tensão com força total",
                                    "Ignorar a direção da força",
                                    "Pensar em tensão apenas em superfícies externas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a definição matemática de tensão verdadeira",
                                  "subSteps": [
                                    "Defina tensão média como F/A para áreas finitas.",
                                    "Introduza o conceito de superfície infinitesimal dA.",
                                    "Estabeleça tensão verdadeira como limite de F/dA quando dA → 0.",
                                    "Escreva a fórmula σ = lim (ΔF / ΔA).",
                                    "Discuta componentes normal e cisalhante da tensão."
                                  ],
                                  "verification": "Derive a fórmula da tensão verdadeira em um papel e resolva um exemplo numérico simples.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Calculadora",
                                    "Software de equações como MathType ou LaTeX online",
                                    "Apostila de Elementos Finitos"
                                  ],
                                  "tips": "Desenhe seções infinitesimais para visualizar o limite.",
                                  "learningObjective": "Dominar a definição rigorosa de tensão como limite matemático.",
                                  "commonMistakes": [
                                    "Esquecer o limite no infinitesimal",
                                    "Confundir vetor tensão com escalar",
                                    "Não considerar orientação da superfície"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar tensão média de tensão verdadeira",
                                  "subSteps": [
                                    "Calcule tensão média em uma barra com seção transversal finita.",
                                    "Compare com tensão verdadeira assumindo deformação não-uniforme.",
                                    "Analise erros de aproximação em casos reais.",
                                    "Use gráficos para ilustrar a diferença em distribuições não-uniformes.",
                                    "Discuta quando a tensão média é uma boa aproximação."
                                  ],
                                  "verification": "Resolva um problema comparando ambas as tensões e discuta as diferenças.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python para cálculos",
                                    "Exemplos de problemas resolvidos"
                                  ],
                                  "tips": "Teste com áreas cada vez menores para ver a convergência.",
                                  "learningObjective": "Distinguir precisamente tensão média (engenharia aproximada) de verdadeira (teórica).",
                                  "commonMistakes": [
                                    "Assumir que são sempre iguais",
                                    "Ignorar efeitos de concentração de tensões",
                                    "Não quantificar o erro"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar o conceito de tensão ao Método dos Elementos Finitos (MEF)",
                                  "subSteps": [
                                    "Explique como MEF discretiza o contínuo em elementos finitos.",
                                    "Descreva cálculo de tensões nos nós e elementos.",
                                    "Discuta interpolação de tensões dentro de elementos.",
                                    "Analise relevância para equilíbrio e convergência no MEF.",
                                    "Revise critérios de malha para precisão de tensões."
                                  ],
                                  "verification": "Desenhe um malha simples e indique onde tensões são calculadas.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": [
                                    "Software gratuito como FreeCAD ou Gmsh para visualização de malha",
                                    "Tutorial introdutório de MEF"
                                  ],
                                  "tips": "Comece com 1D (barra) antes de 2D/3D para simplificar.",
                                  "learningObjective": "Compreender o papel fundamental da tensão no MEF para análise estrutural.",
                                  "commonMistakes": [
                                    "Confundir tensões nodais com elementais",
                                    "Subestimar refinamento de malha",
                                    "Ignorar condições de contorno"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma barra de aço de comprimento 1m e seção transversal circular de raio 1cm sob força axial de 50kN. Calcule a tensão média (σ_média = F/A = 50e3 / (π*0.01^2) ≈ 159 MPa). Agora, para tensão verdadeira, considere uma seção infinitesimal interna com variação de área devido a deformação: σ = lim(ΔF/ΔA) ≈ 165 MPa considerando gradiente. No MEF, modele com 10 elementos e verifique tensões nos nós.",
                              "finalVerifications": [
                                "Definir corretamente tensão como lim(ΔF/ΔA) para dA → 0.",
                                "Explicar diferença entre tensão média e verdadeira com exemplo numérico.",
                                "Desenhar tensor de tensão em um ponto de um sólido.",
                                "Relacionar tensão ao equilíbrio local no MEF.",
                                "Identificar quando usar cada tipo de tensão em análises práticas.",
                                "Resolver um problema simples de tensão em MEF 1D."
                              ],
                              "assessmentCriteria": [
                                "Precisão e rigor matemático na definição (30%)",
                                "Clareza na diferenciação média vs. verdadeira (25%)",
                                "Correta integração com conceitos de MEF (20%)",
                                "Uso de exemplos e visualizações (15%)",
                                "Identificação de erros comuns e limitações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo limite e vetores",
                                "Física: Mecânica dos sólidos e equilíbrio",
                                "Engenharia de Materiais: Comportamento elasto-plástico",
                                "Computação: Algoritmos numéricos e simulações",
                                "Engenharia Civil: Análise estrutural"
                              ],
                              "realWorldApplication": "No projeto de pontes ou aviões, o MEF usa tensão verdadeira para prever falhas por fadiga ou colapso, permitindo simulações precisas de estruturas complexas como vigas em pontes suspensas ou fuselagens aeronáuticas, otimizando materiais e segurança."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.1.1.1.2",
                            "name": "Representar o tensor de tensões",
                            "description": "Descrever o tensor simétrico de tensões em 3D, identificando componentes normais (σ_xx, σ_yy, σ_zz) e cisalhantes (τ_xy, τ_xz, τ_yz), e transformações sob rotação de eixos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de tensão normal e cisalhante",
                                  "subSteps": [
                                    "Definir tensão normal como força perpendicular à superfície por unidade de área.",
                                    "Definir tensão cisalhante como força paralela à superfície por unidade de área.",
                                    "Explicar a direção dos eixos x, y e z em um sistema cartesiano 3D.",
                                    "Identificar σ_xx, σ_yy, σ_zz como componentes normais.",
                                    "Identificar τ_xy, τ_xz, τ_yz como componentes cisalhantes."
                                  ],
                                  "verification": "Listar corretamente as definições e componentes em um diagrama simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Resistência dos Materiais (capítulo de tensão)"
                                  ],
                                  "tips": "Visualize forças atuando em um cubo infinitesimal para fixar os conceitos.",
                                  "learningObjective": "Diferenciar e nomear corretamente os tipos de tensão em 3D.",
                                  "commonMistakes": "Confundir tensão normal com cisalhante ou inverter os índices dos componentes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a representação matricial do tensor de tensões",
                                  "subSteps": [
                                    "Escrever o tensor como uma matriz 3x3 simétrica.",
                                    "Posicionar σ_xx em (1,1), σ_yy em (2,2), σ_zz em (3,3).",
                                    "Posicionar τ_xy e τ_yx em (1,2) e (2,1), τ_xz e τ_zx em (1,3) e (3,1), τ_yz e τ_zy em (2,3) e (3,2).",
                                    "Explicar que devido à simetria, τ_ij = τ_ji.",
                                    "Montar um exemplo numérico com valores hipotéticos."
                                  ],
                                  "verification": "Escrever corretamente a matriz do tensor para um caso dado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Planilha ou software como MATLAB para matrizes",
                                    "Exemplos de problemas resolvidos"
                                  ],
                                  "tips": "Sempre use notação consistente com índices duplos para evitar confusão.",
                                  "learningObjective": "Representar visual e matematicamente o tensor de tensões.",
                                  "commonMistakes": "Esquecer a simetria e colocar valores diferentes em τ_ij e τ_ji."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a simetria e independência dos componentes",
                                  "subSteps": [
                                    "Demonstrar matematicamente que o tensor é simétrico (T = T^T).",
                                    "Contar os 6 componentes independentes (3 normais + 3 cisalhantes).",
                                    "Discutir o equilíbrio de momento que impõe a simetria.",
                                    "Comparar com tensor não simétrico em outros contextos (ex: rotação).",
                                    "Resolver um exercício simples de identificação de componentes."
                                  ],
                                  "verification": "Provar a simetria para um tensor exemplo e listar componentes independentes.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Calculadora ou SymPy para verificação simbólica",
                                    "Diagrama de cubo de tensão"
                                  ],
                                  "tips": "Lembre-se: simetria reduz de 9 para 6 parâmetros desconhecidos.",
                                  "learningObjective": "Justificar a simetria e contar componentes essenciais.",
                                  "commonMistakes": "Achar que todos os 9 termos são independentes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar transformações do tensor sob rotação de eixos",
                                  "subSteps": [
                                    "Introduzir a transformação de tensores: σ' = R σ R^T, onde R é matriz de rotação.",
                                    "Derivar fórmulas para componentes transformados em 2D como base para 3D.",
                                    "Calcular um exemplo de rotação de 45° em plano xy.",
                                    "Verificar invariantes como traço (σ_xx + σ_yy + σ_zz constante).",
                                    "Aplicar em um caso 3D simples com rotação em torno de z."
                                  ],
                                  "verification": "Transformar corretamente um tensor dado sob uma rotação específica.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Software como Python/NumPy para multiplicação de matrizes",
                                    "Tabela de fórmulas de Mohr"
                                  ],
                                  "tips": "Use o círculo de Mohr para visualizar transformações em 2D antes de 3D.",
                                  "learningObjective": "Aplicar e verificar transformações de coordenadas no tensor.",
                                  "commonMistakes": "Confundir R com R^T ou esquecer a transposição."
                                }
                              ],
                              "practicalExample": "Em uma viga cantilever sob carga transversal, o tensor de tensões no ponto crítico tem σ_xx = -My/I (flexão), τ_xy = VQ/Ib (cisalhamento), com outros componentes zero em coordenadas alinhadas. Ao rotacionar 45°, calcule os novos σ'_xx e τ'_x'y' para verificar tração principal.",
                              "finalVerifications": [
                                "Listar e posicionar corretamente os 6 componentes do tensor em uma matriz.",
                                "Provar simetria para um tensor arbitrário.",
                                "Calcular transformação sob rotação de 30° em xy e verificar invariante de traço.",
                                "Identificar componentes normais e cisalhantes em um diagrama de cubo.",
                                "Explicar por que o tensor tem apenas 6 independentes.",
                                "Aplicar em um exemplo numérico completo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação e posicionamento de componentes (30%).",
                                "Compreensão da simetria e prova matemática (25%).",
                                "Correção em cálculos de transformação (25%).",
                                "Clareza em diagramas e explicações (10%).",
                                "Identificação de erros comuns e justificativas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes, autovalores para tensões principais).",
                                "Física: Mecânica dos sólidos e equilíbrio de forças.",
                                "Computação: Programação numérica para elementos finitos (NumPy, FEniCS).",
                                "Engenharia Civil: Análise de estruturas sob carregamento.",
                                "Materiais: Falha por tensão de von Mises."
                              ],
                              "realWorldApplication": "Na análise de elementos finitos (FEA) em softwares como ANSYS, o tensor de tensões é usado para prever falhas em pontes, aviões ou implantes médicos, permitindo otimizar designs contra colapso por excesso de tensão cisalhante ou normal."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.1.1.1.3",
                            "name": "Calcular componentes de tensão em planos",
                            "description": "Aplicar a fórmula de Cauchy para determinar vetor de tração e componentes de tensão em um plano arbitrário dado o tensor de tensões.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Representar o tensor de tensões e definir o plano arbitrário",
                                  "subSteps": [
                                    "Identifique o tensor de tensões σ dado em coordenadas cartesianas (matriz 3x3 simétrica).",
                                    "Defina o vetor normal unitário n ao plano arbitrário, garantindo que ||n|| = 1.",
                                    "Verifique a simetria do tensor σ (σ_ij = σ_ji).",
                                    "Escreva n em componentes [n_x, n_y, n_z].",
                                    "Confirme unidades consistentes (ex: Pa ou MPa)."
                                  ],
                                  "verification": "Tensor σ escrito corretamente como matriz e n normalizado com ||n||=1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora científica",
                                    "Folha com fórmulas de tensão"
                                  ],
                                  "tips": "Sempre normalize n dividindo pelo módulo para evitar erros de escala.",
                                  "learningObjective": "Compreender a representação matemática do estado de tensão e orientação do plano.",
                                  "commonMistakes": [
                                    "Esquecer de normalizar n",
                                    "Confundir índices do tensor",
                                    "Ignorar simetria"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a fórmula de Cauchy para calcular o vetor de tração",
                                  "subSteps": [
                                    "Calcule o produto matricial t = σ · n (multiplicação matriz-vetor).",
                                    "Compute cada componente: t_x = σ_xx n_x + σ_xy n_y + σ_xz n_z, e аналогично para t_y, t_z.",
                                    "Verifique o resultado somando componentes e comparando com propriedades conhecidas.",
                                    "Anote o vetor t em componentes.",
                                    "Confirme que t está na mesma unidade de tensão."
                                  ],
                                  "verification": "Vetor t calculado com todas componentes corretas via multiplicação matricial.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou software como MATLAB/Octave",
                                    "Tensor σ e vetor n impressos"
                                  ],
                                  "tips": "Use multiplicação matricial sistemática linha por coluna para evitar erros aritméticos.",
                                  "learningObjective": "Dominar o cálculo do vetor de tração usando a relação constitutiva de Cauchy.",
                                  "commonMistakes": [
                                    "Erro na ordem da multiplicação (vetor-coluna)",
                                    "Sinais errados em cisalhamentos",
                                    "Não usar n unitário"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Decompor o vetor de tração em componentes normal e cisalhante",
                                  "subSteps": [
                                    "Calcule a tensão normal σ_n = t · n (produto escalar).",
                                    "Compute o vetor normal projetado: σ_n n.",
                                    "Determine o vetor cisalhante τ = t - σ_n n.",
                                    "Calcule a magnitude do cisalhamento τ = ||τ||.",
                                    "Verifique ortogonalidade: τ · n = 0."
                                  ],
                                  "verification": "σ_n escalar, τ vetor perpendicular a n, e t = σ_n n + τ.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de vetores (ex: Python NumPy)",
                                    "Gráfica vetorial opcional"
                                  ],
                                  "tips": "Visualize graficamente: t como soma de normal e tangencial para intuição.",
                                  "learningObjective": "Decompor forças em componentes normal e de cisalhamento em um plano.",
                                  "commonMistakes": [
                                    "Erro no produto escalar",
                                    "Não subtrair corretamente para τ",
                                    "Esquecer verificação de ortogonalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e realizar verificações finais",
                                  "subSteps": [
                                    "Compare σ_n e τ com tensões principais conhecidas.",
                                    "Analise se os valores fazem sentido físico (ex: tração positiva?).",
                                    "Calcule tensão equivalente se aplicável (ex: von Mises no plano).",
                                    "Documente todos os componentes em tabela.",
                                    "Teste com plano especial (ex: n=[1,0,0]) para validar."
                                  ],
                                  "verification": "Resultados consistentes com casos conhecidos e verificações passaram.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela de referência de tensões principais",
                                    "Calculadora"
                                  ],
                                  "tips": "Sempre teste com eixos principais onde t = [σ1,0,0] etc. para debug.",
                                  "learningObjective": "Interpretar componentes de tensão fisicamente e validar cálculos.",
                                  "commonMistakes": [
                                    "Ignorar sinal de tração/compressão",
                                    "Não verificar equilíbrio",
                                    "Valores numéricos irreais"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado σ = [[100, 20, 0], [20, 80, 30], [0, 30, 50]] MPa e n = [1/√2, 1/√2, 0], calcule t ≈ [92.8, 72.8, 21.2] MPa, σ_n ≈ 82.8 MPa, τ ≈ [36.4, 36.4, 21.2] MPa com ||τ|| ≈ 53.2 MPa.",
                              "finalVerifications": [
                                "||t|| é consistente com tensões no tensor.",
                                "τ ⊥ n (produto escalar zero).",
                                "Recupera tensões em planos coordenados corretamente.",
                                "Unidades e sinais físicos corretos.",
                                "Decomposição: ||t||² = σ_n² + ||τ||².",
                                "Simetria preservada nos cálculos."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica em todas componentes (<1% erro).",
                                "Correta aplicação de Cauchy e decomposição.",
                                "Verificações internas realizadas e documentadas.",
                                "Interpretação física adequada.",
                                "Uso eficiente de ferramentas sem erros.",
                                "Clareza na documentação passo a passo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (produtos matriciais, vetores).",
                                "Física: Mecânica dos contínuos e equilíbrio de forças.",
                                "Computação: Programação numérica (NumPy, MATLAB para tensores).",
                                "Engenharia Civil: Análise de estruturas e falhas.",
                                "Materiais: Comportamento sob tensão multi-axial."
                              ],
                              "realWorldApplication": "Em simulações de elementos finitos (ex: ANSYS), calcular tensões em planos de fratura para prever falhas em pontes, aviões ou implantes médicos; otimiza design evitando concentrações de tensão."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.1.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "34.1.1.2",
                        "name": "Tipos de Tensão",
                        "description": "Classificação das tensões em normais e cisalhantes, incluindo tensões principais, desvios e suas propriedades invariantes em sólidos deformáveis.",
                        "specificSkills": [
                          {
                            "id": "34.1.1.2.1",
                            "name": "Diferenciar tensão normal e cisalhante",
                            "description": "Identificar tensão normal (perpendicular à seção) e cisalhante (paralela à seção), com exemplos em uni-axial, bi-axial e tri-axial, e seu papel no equilíbrio local.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Tensão em uma Seção",
                                  "subSteps": [
                                    "Revise a definição de tensão como força por unidade de área em uma seção transversal.",
                                    "Identifique o plano de seção como referência para análise de tensões.",
                                    "Desenhe um elemento infinitesimal sob carga para visualizar forças atuantes.",
                                    "Discuta a importância do equilíbrio de forças em mecânica dos sólidos.",
                                    "Classifique tensões como componentes de um tensor de tensão."
                                  ],
                                  "verification": "Desenhe um diagrama de um elemento sob tensão e rotule o plano de seção corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Livro-texto de Resistência dos Materiais",
                                    "Vídeo introdutório sobre tensão (YouTube ou Khan Academy)"
                                  ],
                                  "tips": "Sempre comece visualizando o elemento 3D para evitar confusão com 2D.",
                                  "learningObjective": "Entender tensão como força distribuída em uma seção e sua relação com planos de corte.",
                                  "commonMistakes": [
                                    "Confundir tensão com esforço total",
                                    "Ignorar a direção perpendicular/paralela ao plano",
                                    "Não considerar o elemento infinitesimal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar Tensão Normal e Tensão Cisalhante",
                                  "subSteps": [
                                    "Defina tensão normal: força perpendicular ao plano de seção (alongamento ou compressão).",
                                    "Defina tensão cisalhante: força paralela (ou tangencial) ao plano de seção (deslizamento).",
                                    "Compare direções: normal atua na direção do eixo normal ao plano; cisalhante nos planos tangenciais.",
                                    "Use setas em diagramas para ilustrar direções de ação.",
                                    "Discuta convenções de sinal: tração/compressão para normal; positivo/negativo para cisalhante."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença com um desenho simples de cada tipo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de papel quadriculado",
                                    "Marcadores coloridos",
                                    "Software de desenho vetorial como Draw.io"
                                  ],
                                  "tips": "Use cores diferentes: azul para normal, vermelho para cisalhante, para fixar visualmente.",
                                  "learningObjective": "Distinguir precisamente tensão normal de cisalhante com base na orientação relativa ao plano.",
                                  "commonMistakes": [
                                    "Invertir direções perpendicular e paralela",
                                    "Confundir cisalhante com momento fletor",
                                    "Esquecer convenções de sinal"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Exemplos em Estados Uni-axial, Bi-axial e Tri-axial",
                                  "subSteps": [
                                    "Uni-axial: Examine uma barra em tração simples (apenas σx normal, sem cisalhante).",
                                    "Bi-axial: Estude uma placa sob tensões σx e σy (normais), com τxy cisalhante.",
                                    "Tri-axial: Visualize um elemento sob σx, σy, σz e cisalhantes τxy, τxz, τyz.",
                                    "Desenhe cubos de tensão para cada caso, rotulando componentes.",
                                    "Calcule componentes simples em um exemplo numérico básico."
                                  ],
                                  "verification": "Crie diagramas de cubos de tensão para os três casos e identifique todos os componentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Modelos impressos de cubos de tensão",
                                    "Calculadora",
                                    "Planilha Excel para cálculos"
                                  ],
                                  "tips": "Comece com uni-axial para construir confiança antes de complexidade.",
                                  "learningObjective": "Aplicar diferenciação em diferentes estados de tensão multidimensionais.",
                                  "commonMistakes": [
                                    "Omitir cisalhantes em bi/tri-axial",
                                    "Confundir eixos em diagramas 3D",
                                    "Ignorar simetria em casos simples"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar o Papel no Equilíbrio Local",
                                  "subSteps": [
                                    "Recapitule o equilíbrio de forças em um elemento infinitesimal (∑Fx=0, etc.).",
                                    "Mostre como tensões normais e cisalhantes contribuem para equilíbrio em cada direção.",
                                    "Derive equações de equilíbrio estático envolvendo σ e τ.",
                                    "Analise um exemplo de viga em flexão com cisalhante e normal.",
                                    "Discuta implicações para falha: normal causa fratura, cisalhante causa deslizamento."
                                  ],
                                  "verification": "Resolva um problema simples de equilíbrio e verifique se tensões se equilibram.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Elementos Finitos",
                                    "Software FEA gratuito como FreeCAD",
                                    "Exercícios impressos"
                                  ],
                                  "tips": "Use o método das forças infinitesimais para derivar equilíbrio intuitivamente.",
                                  "learningObjective": "Compreender como tensões normal e cisalhante garantem equilíbrio local em estruturas.",
                                  "commonMistakes": [
                                    "Negligenciar variações lineares de tensão",
                                    "Confundir equilíbrio global com local",
                                    "Esquecer termos cisalhantes no equilíbrio"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma viga cantilever sob carga pontual na ponta: a tensão normal varia linearmente na seção transversal (compressão superior, tração inferior), enquanto a cisalhante é parabólica e máxima no centro neutro. Desenhe a seção, calcule σ e τ em pontos específicos e verifique equilíbrio.",
                              "finalVerifications": [
                                "Explicar diferença entre normal e cisalhante sem hesitação.",
                                "Desenhar cubo de tensão bi-axial corretamente.",
                                "Identificar componentes em um diagrama dado.",
                                "Resolver equilíbrio simples com ambos tipos.",
                                "Dar exemplo real de cada tensão.",
                                "Diferenciar em uni/bi/tri-axial."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições e direções (90% correto).",
                                "Qualidade dos diagramas (clareza, rotulagem).",
                                "Correção em exemplos multidimensionais.",
                                "Compreensão de equilíbrio (equações balanceadas).",
                                "Aplicação prática sem erros comuns.",
                                "Profundidade em verificações finais."
                              ],
                              "crossCurricularConnections": [
                                "Física: Leis de Newton aplicadas a elementos infinitesimais.",
                                "Matemática: Tensores e vetores em álgebra linear.",
                                "Materiais: Critérios de falha por tensão normal vs. cisalhante.",
                                "Computação: Implementação em software FEA como ANSYS.",
                                "Design: Integração em CAD para análise estrutural."
                              ],
                              "realWorldApplication": "Em projetos de pontes ou aviões, engenheiros usam essa distinção para prever falhas: tensão normal em colunas causa buckling, cisalhante em juntas causa delaminação, garantindo segurança via simulações FEA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.1.1.1"
                            ]
                          },
                          {
                            "id": "34.1.1.2.2",
                            "name": "Determinar tensões principais",
                            "description": "Calcular tensões principais resolvendo o polinômio característico do tensor de tensões, identificando direções principais e usando invariantes (I1, I2, I3).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Construir a Matriz do Tensor de Tensões",
                                  "subSteps": [
                                    "Identifique os componentes normais (σ_xx, σ_yy, σ_zz) e de cisalhamento (σ_xy, σ_xz, σ_yz) do estado de tensão dado.",
                                    "Monte a matriz simétrica 3x3 do tensor de tensões: [[σ_xx, σ_xy, σ_xz], [σ_xy, σ_yy, σ_yz], [σ_xz, σ_yz, σ_zz]].",
                                    "Verifique a simetria da matriz (σ_ij = σ_ji).",
                                    "Confirme as unidades (ex: MPa) e sinal das tensões.",
                                    "Anote o estado de tensão para referência futura."
                                  ],
                                  "verification": "A matriz é simétrica e os componentes correspondem aos valores fornecidos no problema.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou software como MATLAB/Excel",
                                    "Livro de Resistência dos Materiais",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Sempre use convenção de sinal consistente (tração positiva). Para casos planares, defina σ_zz = σ_xz = σ_yz = 0.",
                                  "learningObjective": "Representar corretamente qualquer estado de tensão como um tensor simétrico.",
                                  "commonMistakes": [
                                    "Confundir tensões normais com cisalhamento",
                                    "Esquecer simetria nos elementos off-diagonal",
                                    "Usar unidades inconsistentes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os Invariantes do Tensor de Tensões",
                                  "subSteps": [
                                    "Calcule I1 = σ_xx + σ_yy + σ_zz (traço da matriz).",
                                    "Calcule I2 = σ_xx*σ_yy + σ_yy*σ_zz + σ_zz*σ_xx - σ_xy² - σ_xz² - σ_yz².",
                                    "Calcule I3 = det(matriz de tensões) = σ_xx(σ_yy*σ_zz - σ_yz²) - σ_xy(σ_xy*σ_zz - σ_xz*σ_yz) + σ_xz(σ_xy*σ_yz - σ_xz*σ_yy).",
                                    "Verifique cálculos com fórmula alternativa para I2 se possível.",
                                    "Registre os valores para verificação posterior das tensões principais."
                                  ],
                                  "verification": "Os invariantes I1, I2, I3 são números escalares corretos e independentes da orientação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico como SymPy",
                                    "Tabela de fórmulas de invariantes"
                                  ],
                                  "tips": "Use expansão cofatora para I3 em matrizes 3x3 para evitar erros aritméticos.",
                                  "learningObjective": "Computar invariantes que permanecem constantes sob rotação de eixos.",
                                  "commonMistakes": [
                                    "Erros em expansões quadráticas para I2",
                                    "Sinal incorreto em termos de cisalhamento",
                                    "Confundir I2 com traço"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formar e Resolver o Polinômio Característico",
                                  "subSteps": [
                                    "Escreva o polinômio característico: det(σ - λI) = 0, onde λ são as tensões principais σ1, σ2, σ3.",
                                    "Expanda para a forma cúbica: λ³ - I1 λ² + I2 λ - I3 = 0.",
                                    "Resolva numericamente ou analiticamente (use fórmula cúbica ou métodos numéricos como Newton-Raphson).",
                                    "Ordene as raízes: σ1 ≥ σ2 ≥ σ3.",
                                    "Compare com invariantes: soma(σi) = I1, soma(σi*σj) = I2, produto(σi) = I3."
                                  ],
                                  "verification": "As raízes satisfazem o polinômio e os invariantes calculados anteriormente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de resolução polinomial (MATLAB, Python/NumPy)",
                                    "Tabelas de soluções para equações cúbicas"
                                  ],
                                  "tips": "Para tensões planas (σ3=0), reduza a 2D: λ² - I1 λ + I2 = 0.",
                                  "learningObjective": "Encontrar valores próprios (tensões principais) do tensor de tensões.",
                                  "commonMistakes": [
                                    "Sinal errado no polinômio (det(λI - σ)=0 vs det(σ - λI)=0)",
                                    "Não ordenar as tensões principais",
                                    "Erros numéricos em raízes múltiplas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar as Direções Principais",
                                  "subSteps": [
                                    "Para cada σ_i, resolva (σ - σ_i I) n = 0 para o autovetor n_i (direção principal).",
                                    "Normalize os autovetores: ||n_i|| = 1.",
                                    "Verifique ortogonalidade: n_i · n_j = 0 para i ≠ j.",
                                    "Determine o sistema principal de coordenadas rotacionando pelos autovetores.",
                                    "Confirme que no sistema principal, tensões de cisalhamento são zero."
                                  ],
                                  "verification": "Autovetores são unitários, ortogonais e satisfazem σ n_i = σ_i n_i.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software eigenvector (Eigen em C++, eig em MATLAB)",
                                    "Papel para resolução manual 2D"
                                  ],
                                  "tips": "Em 2D, use tan(2θ_p) = 2τ_xy / (σ_x - σ_y) para ângulo principal.",
                                  "learningObjective": "Identificar orientações onde tensões de cisalhamento desaparecem.",
                                  "commonMistakes": [
                                    "Não normalizar vetores",
                                    "Ignorar ortogonalidade em 3D",
                                    "Confundir direção com plano principal"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado um elemento sob tensão com σ_xx = 100 MPa, σ_yy = 40 MPa, σ_zz = 0, σ_xy = 30 MPa, σ_xz = σ_yz = 0 (tensão plana). Construa o tensor [[100,30,0],[30,40,0],[0,0,0]], calcule I1=140, I2=3400, I3=0. Resolva λ² - 140λ + 3400 = 0 → σ1 ≈ 116.4 MPa, σ2 ≈ 23.6 MPa. Direções: θ_p ≈ 28.1°.",
                              "finalVerifications": [
                                "Tensões principais σ1, σ2, σ3 ordenadas corretamente e satisfazem invariantes.",
                                "Direções principais são ortogonais e unitárias.",
                                "No sistema principal, tensor diagonal com zeros off-diagonal.",
                                "Cálculos numéricos precisos (erro < 1%).",
                                "Verificação cruzada: traço e determinante iguais aos originais.",
                                "Consistência com caso especial (hidrostático ou uniaxial)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de invariantes (100% exato).",
                                "Correta formulação e resolução do polinômio (raízes exatas ou <0.1% erro).",
                                "Autovetores normalizados e ortogonais comprovados.",
                                "Explicação clara das verificações com invariantes.",
                                "Aplicação correta a exemplo prático 2D/3D.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (valores próprios e autovetores).",
                                "Física: Mecânica dos sólidos e equilíbrio de forças.",
                                "Computação: Programação numérica (resolução de equações não-lineares).",
                                "Engenharia Civil: Análise de estruturas sob carga.",
                                "Materiais: Critérios de falha baseados em tensões principais (Von Mises)."
                              ],
                              "realWorldApplication": "Em análise de elementos finitos para design de pontes ou aviões, determinar tensões principais previne falhas por fadiga, otimizando orientações de fibras em compósitos ou prevendo trincas em soldas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.1.1.2"
                            ]
                          },
                          {
                            "id": "34.1.1.2.3",
                            "name": "Analisar tensão hidrostática e desviadora",
                            "description": "Decompor o tensor de tensões em partes hidrostática (esférica) e desviadora (distorsional), explicando sua relação com volume e distorção em deformações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Tensor de Tensões e sua Representação",
                                  "subSteps": [
                                    "Revise a definição de tensor de tensões em 3D, incluindo componentes normais (σ_xx, σ_yy, σ_zz) e cisalhantes (τ_xy, τ_xz, τ_yz).",
                                    "Estude a representação matricial do tensor de tensões σ = [[σ_xx, τ_xy, τ_xz], [τ_xy, σ_yy, τ_yz], [τ_xz, τ_yz, σ_zz]].",
                                    "Aprenda invariantes do tensor: I1 = traço(σ), I2 e I3.",
                                    "Pratique traçando tensores de tensões de exemplos simples como tração uniaxial e cisalhamento puro.",
                                    "Visualize o tensor usando elipsoides de tensão ou software como MATLAB."
                                  ],
                                  "verification": "Construa corretamente o tensor de tensões para um estado dado e calcule seus invariantes sem erros.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Mecânica dos Materiais (ex: Beer & Johnston)",
                                    "Software MATLAB ou Python (NumPy)",
                                    "Folhas de cálculo e calculadora"
                                  ],
                                  "tips": "Sempre verifique simetria do tensor (τ_ij = τ_ji) para evitar erros de entrada.",
                                  "learningObjective": "Dominar a representação matemática do tensor de tensões como base para decomposição.",
                                  "commonMistakes": [
                                    "Confundir componentes normais com cisalhantes",
                                    "Esquecer simetria do tensor",
                                    "Erro no cálculo do traço"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Calcular a Parte Hidrostática (Esférica)",
                                  "subSteps": [
                                    "Defina a tensão hidrostática σ_h = (σ_xx + σ_yy + σ_zz)/3 = I1/3, como a parte esférica do tensor.",
                                    "Construa o tensor hidrostático σ_h = σ_h * [[1,0,0],[0,1,0],[0,0,1]].",
                                    "Calcule σ_h para exemplos: tração uniaxial (σ_h = σ/3), pressão hidrostática (σ_h = -p).",
                                    "Interprete fisicamente: σ_h causa mudança volumétrica (dilatação ou contração).",
                                    "Use equação ε_v = (1-2ν)/E * 3σ_h para ligar a deformação volumétrica."
                                  ],
                                  "verification": "Calcule σ_h e o tensor hidrostático para um tensor dado e confirme que traço(σ_h) = I1.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilhas Excel ou Python script para cálculo",
                                    "Gráficos de deformação volumétrica"
                                  ],
                                  "tips": "Lembre-se: σ_h é invariante a rotações, sendo a média das tensões normais principais.",
                                  "learningObjective": "Calcular e interpretar a componente hidrostática responsável por mudanças de volume.",
                                  "commonMistakes": [
                                    "Dividir I1 por 3 incorretamente",
                                    "Confundir σ_h com tensão média em 2D",
                                    "Ignorar sinal negativo em compressão"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e Calcular a Parte Desviadora (Distorsional)",
                                  "subSteps": [
                                    "Defina o tensor desviador σ' = σ - σ_h, onde cada componente é subtraída por σ_h.",
                                    "Verifique que traço(σ') = 0, confirmando ausência de mudança volumétrica.",
                                    "Calcule para exemplos: em cisalhamento puro, σ' = σ; em tração uniaxial, componentes off-diagonal zero.",
                                    "Calcule intensidades como J2 = (1/2) traço(σ'^2) para medir distorção.",
                                    "Interprete: σ' causa deformação em forma (distorção sem mudança de volume)."
                                  ],
                                  "verification": "Decomponha um tensor completo em σ_h + σ' e confirme que σ = σ_h + σ' e traço(σ') = 0.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python para decomposição automática",
                                    "Exemplos de problemas resolvidos em PDF"
                                  ],
                                  "tips": "Use matrizes para subtração: σ' = σ - σ_h * I, onde I é identidade.",
                                  "learningObjective": "Isolar e calcular a componente desviadora ligada à distorção.",
                                  "commonMistakes": [
                                    "Erro aritmético na subtração de σ_h de componentes cisalhantes",
                                    "Não zerar traço de σ'",
                                    "Confundir J2 com I1"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Relações Físicas e Aplicar em Análise de Tensões",
                                  "subSteps": [
                                    "Explique: hidrostática → deformação volumétrica (ε_v ∝ σ_h); desviadora → deformação deviadora (ε' ∝ σ').",
                                    "Aplique em critérios de falha: von Mises usa apenas σ' (distorção domina plasticidade).",
                                    "Simule em software de EF (ex: ANSYS) um elemento sob carga mista e decomponha tensões.",
                                    "Compare estados de tensão: hidrostático puro (sem falha por distorção), desviador puro (alto risco cisalhamento).",
                                    "Resolva problema: dado σ, encontre σ_h, σ', J2 e interprete risco de falha."
                                  ],
                                  "verification": "Interprete corretamente um caso real, ligando decomposição a comportamento material.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software ANSYS ou FreeFEM",
                                    "Casos de estudo em falhas estruturais"
                                  ],
                                  "tips": "Em EF, visualize σ_h e σ_eq (von Mises) em pós-processamento.",
                                  "learningObjective": "Relacionar decomposição a deformações e critérios de projeto.",
                                  "commonMistakes": [
                                    "Atribuir distorção à hidrostática",
                                    "Ignorar ν em cálculos volumétricos",
                                    "Mal aplicar em 2D vs 3D"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma viga sob flexão e torção, decomponha o tensor de tensões no ponto crítico: σ_xx = 100 MPa (flexão), τ_xy = 50 MPa (torção). Calcule σ_h ≈ 33.3 MPa (leve dilatação), σ' domina com J2 alto, indicando risco de escoamento por distorção via von Mises.",
                              "finalVerifications": [
                                "Decompor corretamente 3 tensores de tensão diferentes em hidrostática e desviadora.",
                                "Calcular J2 e ligar a distorção sem erros.",
                                "Explicar verbalmente a diferença física entre σ_h e σ' em 2 minutos.",
                                "Simular em software e interpretar resultados de EF.",
                                "Resolver problema completo: dado σ, encontre partes e risco de falha.",
                                "Confirmar traço(σ') = 0 em todos cálculos."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de σ_h e σ' (erro <1%).",
                                "Correta interpretação física (volume vs distorção).",
                                "Uso apropriado de invariantes e tensores.",
                                "Aplicação em critérios de falha (ex: von Mises).",
                                "Clareza em exemplos e visualizações.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (tensores, autovalores).",
                                "Física: Mecânica dos fluidos (pressão hidrostática).",
                                "Ciência dos Materiais: Critérios de falha plástica.",
                                "Computação: Programação numérica (NumPy, EF solvers).",
                                "Engenharia Civil: Análise de estruturas sob cargas combinadas."
                              ],
                              "realWorldApplication": "No projeto de turbinas eólicas, decompor tensões em pás permite prever falhas por distorção (fatiga), otimizando espessura e material para evitar colapso sem excesso de peso."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.1.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "34.1.1.3",
                        "name": "Condições de Equilíbrio",
                        "description": "Princípios de equilíbrio estático em sólidos deformáveis, incluindo equações diferenciais de equilíbrio e condições de contorno para forças de corpo e superfície.",
                        "specificSkills": [
                          {
                            "id": "34.1.1.3.1",
                            "name": "Estabelecer equações de equilíbrio local",
                            "description": "Derivar as três equações diferenciais de equilíbrio (∇·σ + b = 0) em coordenadas cartesianas para um elemento de volume infinitesimal, considerando forças de corpo b.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o elemento de volume infinitesimal em coordenadas cartesianas",
                                  "subSteps": [
                                    "Desenhe um cubo infinitesimal com dimensões dx, dy, dz centrado em um ponto (x,y,z).",
                                    "Identifique as seis faces do cubo e label as tensões normais (σ_xx, σ_yy, σ_zz) e cisalhantes (σ_xy, σ_xz, etc.) em cada face, considerando variações infinitesimais.",
                                    "Defina a notação para tensões em faces opostas, como σ_xx(x) na face esquerda e σ_xx(x+dx) na direita.",
                                    "Marque o vetor de força de corpo b = (b_x, b_y, b_z) atuando no volume dV = dx dy dz.",
                                    "Verifique que o cubo é infinitesimal para justificar aproximações lineares nas variações de tensão."
                                  ],
                                  "verification": "Diagrama completo com todas as tensões labeladas corretamente em faces opostas e vetor b indicado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado ou software de desenho (ex: GeoGebra, Draw.io)",
                                    "Livro de Mecânica dos Sólidos (ex: Timmoshenko)"
                                  ],
                                  "tips": "Use setas para indicar direção das tensões cisalhantes e normais para evitar confusão.",
                                  "learningObjective": "Compreender a geometria e notação padrão para análise de equilíbrio local.",
                                  "commonMistakes": [
                                    "Confundir tensões em faces opostas",
                                    "Esquecer componentes cisalhantes",
                                    "Ignorar variações infinitesimais (dx, dy, dz)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar forças de tensão atuantes nas faces do elemento",
                                  "subSteps": [
                                    "Calcule a força resultante na direção x das tensões σ_xx nas faces perpendicular ao x: [σ_xx(x+dx) - σ_xx(x)] dy dz.",
                                    "Inclua contribuições das tensões cisalhantes σ_xy e σ_xz nas faces y e z: ∂σ_xy/∂y dy e ∂σ_xz/∂z dz.",
                                    "Repita para direções y e z, listando todas as forças de tensão projetadas em cada eixo.",
                                    "Expresse todas as forças de tensão como diferenças finitas que aproximam derivadas parciais.",
                                    "Some as forças de tensão líquidas em cada direção para preparar o balanço."
                                  ],
                                  "verification": "Lista de forças de tensão líquidas em x, y, z corretas, com aproximações para derivadas parciais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Caderno para cálculos",
                                    "Calculadora simbólica (ex: SymPy online)"
                                  ],
                                  "tips": "Aplique a convenção de sinal: tensão positiva causa tração para fora da face.",
                                  "learningObjective": "Identificar e quantificar contribuições de todas as componentes do tensor de tensão.",
                                  "commonMistakes": [
                                    "Erros de sinal nas diferenças finitas",
                                    "Omitir projeções de cisalhantes",
                                    "Confundir derivadas parciais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar forças de corpo e estabelecer balanço de forças",
                                  "subSteps": [
                                    "Adicione a força de corpo total: b dV = (b_x dx dy dz, b_y dx dy dz, b_z dx dy dz).",
                                    "Escreva a soma de forças em x: [∂σ_xx/∂x + ∂σ_xy/∂y + ∂σ_xz/∂z] dV + b_x dV = 0.",
                                    "Faça o mesmo para y e z, resultando nas três equações: ∇·σ + b = 0 componente a componente.",
                                    "Divida por dV e tome limite dx,dy,dz → 0 para obter as formas diferenciais exatas.",
                                    "Confirme que as equações são independentes para equilíbrio estático (aceleração zero)."
                                  ],
                                  "verification": "Três equações de equilíbrio escritas corretamente na forma diferencial para cada direção.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de papel para equações",
                                    "Referência: Notas de Elementos Finitos"
                                  ],
                                  "tips": "Fatore dV em cada termo para simplificar antes de dividir.",
                                  "learningObjective": "Derivar o balanço completo de forças levando à forma diferencial.",
                                  "commonMistakes": [
                                    "Esquecer de dividir por dV",
                                    "Inverter sinais de b",
                                    "Não tomar limite infinitesimal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e expressar na forma vetorial compacta",
                                  "subSteps": [
                                    "Escreva as três equações scalar como um vetor: div(σ) + b = 0.",
                                    "Discuta simetria do tensor σ (σ_xy = σ_yx) e implicações para o divergente.",
                                    "Teste com caso simples: tensão uniaxial σ_xx constante, b=0 → ∂σ_xx/∂x = 0.",
                                    "Compare com a 2ª lei de Newton em forma diferencial para continuum.",
                                    "Registre a equação geral ∇·σ + b = 0 como resultado final."
                                  ],
                                  "verification": "Forma vetorial correta derivada e verificada com exemplo simples.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Software de LaTeX para equações (ex: Overleaf)",
                                    "Exemplos resolvidos de livros"
                                  ],
                                  "tips": "Use notação de divergente vetorial para compactar e generalizar.",
                                  "learningObjective": "Consolidar a derivação em forma notacional padrão usada em FEM.",
                                  "commonMistakes": [
                                    "Não reconhecer forma vetorial",
                                    "Ignorar simetria do tensor",
                                    "Aplicar incorretamente em exemplos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma barra sob tração uniaxial com σ_xx variando ao longo de x e b_x = 0, o balanço em x dá ∂σ_xx/∂x = 0, implicando σ_xx constante, o que verifica equilíbrio sem forças externas variáveis.",
                              "finalVerifications": [
                                "Pode desenhar o cubo com todas as tensões corretas.",
                                "Escreve as três equações diferenciais sem erros.",
                                "Aplica corretamente em um caso uniaxial simples.",
                                "Explica o papel de b como força por unidade de volume.",
                                "Identifica ∇·σ + b = 0 como forma geral.",
                                "Discute limite infinitesimal justificando derivadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação e labeling de tensões (30%)",
                                "Correção matemática nas diferenças finitas e limites (30%)",
                                "Inclusão completa de forças de corpo e cisalhantes (20%)",
                                "Clareza na derivação para forma vetorial (10%)",
                                "Verificação com exemplo prático (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: 2ª Lei de Newton para continua (F=ma com a=0)",
                                "Matemática: Cálculo vetorial e divergente de tensores",
                                "Engenharia Civil: Análise de tensões em vigas e estruturas",
                                "Computação: Implementação em código FEM (ex: FEniCS)"
                              ],
                              "realWorldApplication": "Essas equações formam a base das simulações por elementos finitos (FEM) em softwares como ANSYS ou Abaqus, usadas para projetar aviões, pontes e implantes médicos, garantindo que estruturas suportem cargas sem colapso."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.1.1.1"
                            ]
                          },
                          {
                            "id": "34.1.1.3.2",
                            "name": "Aplicar equilíbrio em condições de contorno",
                            "description": "Definir condições de tração prescrita (σ·n = t) e forças de corpo, integrando-as na formulação fraca para o MEF.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de equilíbrio e condições de contorno",
                                  "subSteps": [
                                    "Estudar o princípio de equilíbrio estático: div(σ) + b = 0 em cada ponto do domínio.",
                                    "Identificar condições de contorno de Dirichlet (deslocamentos prescritos) e Neumann (trações prescritas σ·n = t).",
                                    "Analisar forças de corpo b como carregamentos volumétricos.",
                                    "Diferenciar trações de superfície t de forças distribuídas.",
                                    "Esboçar um domínio Ω com ∂Ω = Γ_u ∪ Γ_t para ilustrar partição das fronteiras."
                                  ],
                                  "verification": "Escrever as equações de equilíbrio e condições de contorno corretamente em um papel ou documento.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro-texto de Elementos Finitos (ex: Bathe ou Zienkiewicz)",
                                    "Papel e caneta",
                                    "Notas de aula sobre MEF"
                                  ],
                                  "tips": "Visualize o domínio como uma peça mecânica real para fixar os conceitos.",
                                  "learningObjective": "Compreender a base matemática do equilíbrio e classificar condições de contorno.",
                                  "commonMistakes": "Confundir forças de corpo (volumétricas) com trações superficiais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular condições de tração prescrita e forças de corpo",
                                  "subSteps": [
                                    "Definir matematicamente σ·n = t em Γ_t, onde σ é o tensor de tensões e n o vetor normal.",
                                    "Especificar forças de corpo b no domínio Ω inteiro.",
                                    "Verificar equilíbrio global: ∫_Ω b dV + ∫_Γ_t t dA = 0.",
                                    "Escolher exemplos simples de t (uniforme) e b (gravidade).",
                                    "Derivar a condição integral para formulação fraca."
                                  ],
                                  "verification": "Calcular numericamente o equilíbrio global para um exemplo unidimensional e confirmar soma zero.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico como Mathematica/MATLAB",
                                    "Folha de exercícios"
                                  ],
                                  "tips": "Use coordenadas cartesianas para simplificar cálculos iniciais.",
                                  "learningObjective": "Formular precisamente as condições de tração e forças de corpo.",
                                  "commonMistakes": "Esquecer o vetor normal n apontando para fora do domínio."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar condições na formulação fraca do MEF",
                                  "subSteps": [
                                    "Partir da equação forte: encontrar u tal que (div(σ(u)), v) + (b, v) = (t, v)_Γ_t para todo v no espaço de teste.",
                                    "Multiplicar pela função teste v e integrar por partes: ∫_Ω σ(u):ε(v) dV = ∫_Ω b·v dV + ∫_Γ_t t·v dA.",
                                    "Identificar termos de tração e forças de corpo como lado direito da forma bilinear.",
                                    "Discutir espaços de funções com u=0 em Γ_u e v=0 em Γ_u.",
                                    "Escrever a formulação variacional completa."
                                  ],
                                  "verification": "Derivar a forma fraca passo a passo e comparar com referência padrão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software de edição LaTeX ou notebook Jupyter para equações",
                                    "Referência: Hughes 'The Finite Element Method'"
                                  ],
                                  "tips": "A integração por partes move derivadas para a função teste, naturalizando a formulação.",
                                  "learningObjective": "Integrar corretamente condições de equilíbrio na forma fraca.",
                                  "commonMistakes": "Inverter o sinal na integração por partes (deve ser positivo para trações)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e verificar em um exemplo numérico simples",
                                  "subSteps": [
                                    "Montar um problema 1D: barra de comprimento L com σ·n = t constante em x=L e b=0.",
                                    "Discretizar com 2-3 elementos lineares e montar matriz de rigidez.",
                                    "Incorporar termo de tração como vetor de carga nodal.",
                                    "Resolver o sistema Ku = f (com f incluindo contribuições de t e b).",
                                    "Verificar equilíbrio residual: calcular div(σ) + b ≈ 0 nos nós."
                                  ],
                                  "verification": "Comparar solução com analítica exata e residual < 1e-6.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "MATLAB/Python com biblioteca FEniCS ou código MEF simples",
                                    "Exemplo de código template"
                                  ],
                                  "tips": "Comece com malha grosseira para depuração rápida.",
                                  "learningObjective": "Implementar e validar a aplicação prática das condições.",
                                  "commonMistakes": "Não mapear corretamente trações para cargas nodais via funções de forma."
                                }
                              ],
                              "practicalExample": "Em uma placa retangular sob tração uniforme t = (10 MPa, 0) na borda direita, com gravidade b = (0, -9.81 ρ) e fixada na esquerda: integre t e b na forma fraca para resolver deslocamentos via MEF com elementos quadrilaterais.",
                              "finalVerifications": [
                                "Equilíbrio global satisfeito: soma de forças zero.",
                                "Residual local div(σ) + b < tolerância em todos os elementos.",
                                "Convergência da solução com refinamento de malha.",
                                "Correspondência com solução analítica em caso simples.",
                                "Trações recuperadas σ·n = t exata na fronteira Γ_t.",
                                "Energia total positiva definida."
                              ],
                              "assessmentCriteria": [
                                "Definição precisa de σ·n = t e integração correta na forma fraca (peso 25%).",
                                "Tratamento adequado de forças de corpo b no lado direito (peso 20%).",
                                "Derivação completa da formulação variacional sem erros (peso 25%).",
                                "Implementação numérica funcional com verificação (peso 20%).",
                                "Explicação clara de verificações de equilíbrio (peso 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e teorema de Green.",
                                "Física: Mecânica dos sólidos contínuos e leis de Newton.",
                                "Computação: Programação numérica e métodos de discretização.",
                                "Engenharia Civil: Análise de estruturas sob cargas distribuídas."
                              ],
                              "realWorldApplication": "Na simulação FEA de componentes aeronáuticos, como asas sob pressão aerodinâmica (t) e peso próprio (b), garantindo precisão no equilíbrio para prever falhas estruturais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.1.3.1"
                            ]
                          },
                          {
                            "id": "34.1.1.3.3",
                            "name": "Verificar equilíbrio global",
                            "description": "Demonstrar que o equilíbrio local implica equilíbrio global via teorema da divergência, com exemplos em 1D e 2D para treliças e vigas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Equilíbrio Local e Global",
                                  "subSteps": [
                                    "Defina equilíbrio local: condição onde forças e momentos em cada ponto ou elemento são nulos.",
                                    "Defina equilíbrio global: soma de forças e momentos na estrutura inteira é zero.",
                                    "Compare diferenças: local é por elemento/nó, global é para o sistema todo.",
                                    "Discuta importância no Método dos Elementos Finitos (MEF): garante consistência do modelo.",
                                    "Estude notação: forças nodais, tensões, divergência em continuum."
                                  ],
                                  "verification": "Escreva definições e diferenças em um resumo de 1 página e compare com referências padrão.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Livro de Elementos Finitos (ex: Zienkiewicz)",
                                    "Papel e lápis para diagramas",
                                    "Notas de aula sobre estática"
                                  ],
                                  "tips": "Use diagramas de corpo livre (DCL) para visualizar forças em elementos isolados.",
                                  "learningObjective": "Compreender e diferenciar equilíbrio local e global no contexto de MEF.",
                                  "commonMistakes": [
                                    "Confundir equilíbrio local com nodal",
                                    "Ignorar momentos em vigas",
                                    "Não considerar reações de apoio no global"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o Teorema da Divergência e sua Implicação",
                                  "subSteps": [
                                    "Enuncie o teorema da divergência: ∫_V div(σ) dV = ∫_S σ·n dS para tensor de tensões σ.",
                                    "Aplique à equação de equilíbrio local: div(σ) + f = 0, onde f são forças volumétricas.",
                                    "Integre sobre o domínio: equilíbrio global surge como soma de forças de superfície = forças externas.",
                                    "Discuta discretização no MEF: forças nodais equivalentes preservam essa propriedade.",
                                    "Prove matematicamente para um elemento simples usando identidades vetoriais."
                                  ],
                                  "verification": "Derive a implicação local → global em uma prova curta e verifique com exemplo numérico simples.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Caderno de matemática",
                                    "Software simbólico como Mathematica ou SymPy",
                                    "Referência: Continuum Mechanics books"
                                  ],
                                  "tips": "Pense em termos de 'balanço de momentum': entrada = saída + acumulada (zero em equilíbrio).",
                                  "learningObjective": "Demonstrar matematicamente como equilíbrio local implica global via teorema da divergência.",
                                  "commonMistakes": [
                                    "Esquecer forças volumétricas f",
                                    "Confundir divergência com gradiente",
                                    "Não normalizar superfícies internas que cancelam"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar em Exemplos 1D: Barras Axiais",
                                  "subSteps": [
                                    "Monte um sistema 1D simples: barra axial com 2 elementos e 3 nós.",
                                    "Calcule tensões constantes nos elementos (equilíbrio local: dσ/dx + f = 0).",
                                    "Some forças nodais internas: verifique soma zero (equilíbrio global).",
                                    "Varie cargas: aplique forças nodais e reações, confirme cancelamento.",
                                    "Implemente numericamente: use matriz de rigidez para forças equivalentes."
                                  ],
                                  "verification": "Resolva o exemplo e mostre soma de forças globais < 1e-10 (tolerância numérica).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Matlab/Python para MEF 1D",
                                    "Planilha Excel para cálculos manuais",
                                    "Exemplos de código online de truss 1D"
                                  ],
                                  "tips": "Comece com N=2 elementos para simplicidade; escale para mais nós.",
                                  "learningObjective": "Verificar numericamente a implicação em 1D para barras.",
                                  "commonMistakes": [
                                    "Erro na montagem da matriz de rigidez",
                                    "Ignorar condições de contorno",
                                    "Não somar todas forças nodais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estender para 2D: Treliças e Vigas",
                                  "subSteps": [
                                    "Treliça 2D: modele uma treliça simples (3 barras, 3 nós), calcule forças axiais (local).",
                                    "Verifique global: soma Fx=0, Fy=0, Mz=0 em todos nós livres.",
                                    "Viga 2D: use elementos de viga (Euler-Bernoulli), equilíbrio local em cisalhamento e momento.",
                                    "Integre forças nodais: demonstre soma zero para carga distribuída.",
                                    "Compare: discuta diferenças entre treliça (axial only) e viga (flexão)."
                                  ],
                                  "verification": "Crie plot de forças nodais e confirme vetores somam zero visual e numericamente.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Software FEA como ANSYS Student ou FEniCS",
                                    "Código Python/Matlab para truss/beam 2D",
                                    "Papel para esboços manuais"
                                  ],
                                  "tips": "Use simetria para simplificar; valide com solução analítica conhecida.",
                                  "learningObjective": "Aplicar e verificar equilíbrio em estruturas 2D reais via MEF.",
                                  "commonMistakes": [
                                    "Orientação errada de elementos em 2D",
                                    "Confundir forças locais com globais",
                                    "Esquecer rotações em vigas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma treliça 2D triangular com nós A (apoio fixo), B (apoio rolante), C (carga vertical 10kN): calcule forças axiais nos 3 elementos (equilíbrio local), some forças nos nós livres → resulta em equilíbrio global com reações corretas em A e B.",
                              "finalVerifications": [
                                "Derivar teorema da divergência para equilíbrio.",
                                "Resolver exemplo 1D com soma forças =0.",
                                "Analisar treliça 2D e confirmar Fx,Fy,M=0.",
                                "Simular viga com carga distribuída e verificar global.",
                                "Explicar por que MEF preserva essa propriedade.",
                                "Identificar violações em modelos mal montados."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (100% correto).",
                                "Correção numérica nos exemplos (<1% erro).",
                                "Clareza em diagramas e explicações.",
                                "Conexão explícita local → global.",
                                "Uso adequado de software para validação.",
                                "Identificação de pelo menos 3 erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo vetorial e teoremas integrais.",
                                "Física: Estática e mecânica dos sólidos.",
                                "Computação: Programação numérica para MEF (Python/Matlab).",
                                "Engenharia Civil: Análise de estruturas reais.",
                                "Física Computacional: Simulações discretas de PDEs."
                              ],
                              "realWorldApplication": "Na verificação de modelos FEA para pontes e edifícios, assegura que simulações respeitam leis físicas fundamentais, evitando falhas como colapso por desequilíbrio numérico em projetos de engenharia civil e aeroespacial."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.1.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.3",
                    "name": "Deformações",
                    "description": "Definição, componentes e cálculo de deformações em meios contínuos.",
                    "individualConcepts": [
                      {
                        "id": "34.1.1.1",
                        "name": "Definição de Deformações",
                        "description": "Compreensão conceitual da deformação como mudança relativa de configuração em meios contínuos, incluindo deformações infinitesimais e finitas.",
                        "specificSkills": [
                          {
                            "id": "34.1.1.1.1",
                            "name": "Identificar a definição de deformação",
                            "description": "Explicar a deformação como a variação geométrica de um meio contínuo sob ação de cargas, diferenciando deformação total, elástica e plástica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de meio contínuo e ação de cargas",
                                  "subSteps": [
                                    "Defina meio contínuo como um material onde as propriedades são distribuídas de forma contínua, sem interrupções discretas.",
                                    "Explique como cargas externas (forças) atuam sobre o meio, causando mudanças em sua configuração.",
                                    "Identifique exemplos simples de meios contínuos, como metais ou plásticos em estruturas.",
                                    "Descreva a diferença entre configuração inicial e deformada do meio.",
                                    "Relacione cargas com respostas mecânicas no material."
                                  ],
                                  "verification": "Resuma em uma frase o que é um meio contínuo sob ação de cargas e forneça um exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Resistência dos Materiais (ex: Timoshenko), vídeo introdutório sobre mecânica dos sólidos no YouTube."
                                  ],
                                  "tips": "Visualize o meio como uma 'massa contínua' em vez de partículas isoladas para facilitar a compreensão.",
                                  "learningObjective": "Entender a base física de deformações em materiais contínuos.",
                                  "commonMistakes": "Confundir meio contínuo com materiais discretos como areia ou granizo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir deformação como variação geométrica",
                                  "subSteps": [
                                    "Defina deformação como qualquer alteração na geometria ou forma do meio contínuo devido a cargas.",
                                    "Diferencie variação geométrica de movimento rígido (translação ou rotação sem mudança de forma).",
                                    "Descreva como a deformação é medida por tensores ou vetores de deslocamento.",
                                    "Ilustre com um diagrama simples de uma linha reta que se curva sob carga.",
                                    "Explique que a deformação ocorre em pontos infinitesimais do meio."
                                  ],
                                  "verification": "Desenhe um esquema antes/depois de uma deformação e rotule as mudanças geométricas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis para diagramas, software gratuito como GeoGebra para simulações geométricas."
                                  ],
                                  "tips": "Pense em 'esticar, comprimir ou torcer' como variações geométricas básicas.",
                                  "learningObjective": "Identificar deformação especificamente como mudança geométrica sob cargas.",
                                  "commonMistakes": "Equivocar deformação com simples deslocamento sem alteração de forma."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar a deformação total",
                                  "subSteps": [
                                    "Defina deformação total como a soma de todas as mudanças geométricas acumuladas no meio.",
                                    "Descreva como é representada pelo tensor de deformação total (gradiente de deslocamento).",
                                    "Calcule um exemplo simples: deformação uniaxial ε = ΔL/L.",
                                    "Relacione deformação total com o estado final do corpo deformado.",
                                    "Discuta componentes volumétrica e distorcional da deformação total."
                                  ],
                                  "verification": "Calcule a deformação total para uma barra alongada de 100mm para 105mm.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora, planilha Excel para cálculos simples, apostila de Elementos Finitos."
                                  ],
                                  "tips": "Use a fórmula básica ε = (L_final - L_inicial)/L_inicial para fixar o conceito.",
                                  "learningObjective": "Dominar a noção quantitativa e qualitativa de deformação total.",
                                  "commonMistakes": "Ignorar que deformação total inclui rotações e distorções além de alongamentos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar deformação elástica e plástica",
                                  "subSteps": [
                                    "Defina deformação elástica como reversível, recuperada ao remover a carga (abaixo do limite elástico).",
                                    "Defina deformação plástica como permanente, resultante de rearranjo molecular além do limite de escoamento.",
                                    "Compare com curvas tensão-deformação: elástica linear, plástica não-linear.",
                                    "Forneça exemplos: elástica em molas, plástica em amassamento de metal.",
                                    "Explique implicações em análise de falhas e projeto."
                                  ],
                                  "verification": "Classifique deformações em cenários dados (ex: elástica em elástico de borracha, plástica em lata amassada).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráfico de curva tensão-deformação impresso, vídeo de testes de tração."
                                  ],
                                  "tips": "Lembre: elástica = 'volta ao normal', plástica = 'deforma para sempre'.",
                                  "learningObjective": "Distinguir tipos de deformação com base em reversibilidade.",
                                  "commonMistakes": "Confundir limite elástico com ruptura ou ignorar histerese na elástica."
                                }
                              ],
                              "practicalExample": "Considere uma barra de aço de 1m sob tração de 100kN: calcule deformação total (ε_total = 0.001), identifique elástica (até 0.002) e plástica (acima, permanente). Simule com software como FreeCAD.",
                              "finalVerifications": [
                                "Pode definir deformação como variação geométrica de meio contínuo sob cargas?",
                                "Diferencia corretamente deformação total de elástica e plástica?",
                                "Explica com exemplo numérico a deformação uniaxial?",
                                "Identifica movimento rígido vs. deformação em diagramas?",
                                "Relaciona tipos de deformação com curvas tensão-deformação?",
                                "Descreve implicações práticas em engenharia?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de deformação (90% exatidão).",
                                "Clareza na diferenciação elástica/plástica (com exemplos).",
                                "Uso correto de terminologia técnica (meio contínuo, tensor).",
                                "Capacidade de ilustração gráfica ou numérica.",
                                "Completude na cobertura de deformação total.",
                                "Profundidade em conexões com análise de elementos finitos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Mecânica dos sólidos e leis de Hooke.",
                                "Matemática: Tensores e cálculo diferencial para gradientes.",
                                "Química: Microestrutura de materiais e mecanismos plásticos.",
                                "Informática: Simulações numéricas em software de EF."
                              ],
                              "realWorldApplication": "Em projetos de pontes ou aviões, identificar deformações elásticas garante segurança (não ultrapassar limites), enquanto plásticas indicam falha; usado em análise de elementos finitos para prever colapsos em terremotos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.1.1.1.2",
                            "name": "Diferenciar deformações infinitesimais",
                            "description": "Reconhecer a aproximação linear para pequenas deformações em análise de elementos finitos, justificando sua aplicação em problemas lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Deformação em Mecânica dos Sólidos",
                                  "subSteps": [
                                    "Revise a definição de deformação como mudança relativa de configuração de um corpo deformável.",
                                    "Estude o gradiente de deslocamento (F = I + ∇u) e sua decomposição em rotação e deformação.",
                                    "Identifique o tensor de deformação de Green-Lagrange para deformações finitas.",
                                    "Discuta limitações de deformações grandes em análises lineares.",
                                    "Explore exemplos visuais de deformações pequenas vs. grandes usando diagramas."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre configuração de referência e deformada, com esboço de um elemento deformando.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Mecânica dos Continuum (ex: Malvern), slides de aula sobre FEM, papel e lápis para diagramas"
                                  ],
                                  "tips": "Use animações online de deformação para visualizar melhor os conceitos.",
                                  "learningObjective": "Entender a base cinemática da deformação antes da aproximação infinitesimal.",
                                  "commonMistakes": "Confundir deslocamento com deformação; ignorar a distinção entre deformação total e infinitesimal."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Derivar o Tensor de Deformação Infinitesimal",
                                  "subSteps": [
                                    "Defina o tensor de deformação infinitesimal ε como a parte simétrica do gradiente infinitesimal de deslocamento: ε = (∇u + (∇u)^T)/2.",
                                    "Derive a aproximação para pequenas deformações: |∇u| << 1, onde rotação e deformação são aproximadamente independentes.",
                                    "Calcule componentes em 1D (ε_xx = ∂u_x/∂x) e estenda para 3D.",
                                    "Verifique propriedades: simetria, invariância sob rotação rígida.",
                                    "Implemente uma fórmula simples em uma planilha para um campo de deslocamento linear."
                                  ],
                                  "verification": "Derive o tensor ε para um deslocamento u = (x, 2y, 0) e confirme que ε_xx = 1, ε_yy = 2.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Caderno de derivadas matriciais, software como MATLAB ou Python (SymPy para simbólico), vídeo tutorial sobre tensores"
                                  ],
                                  "tips": "Lembre-se: infinitesimais significam que termos quadráticos e superiores são desprezados.",
                                  "learningObjective": "Dominar a formulação matemática exata do tensor infinitesimal.",
                                  "commonMistakes": "Esquecer a simetrização (1/2 fator); incluir termos não-lineares acidentalmente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Justificar a Aproximação Linear para Pequenas Deformações",
                                  "subSteps": [
                                    "Compare ε infinitesimal com E Green-Lagrange: E = (∇u + (∇u)^T + (∇u)^T ∇u)/2 ≈ ε quando ||∇u|| << 1.",
                                    "Analise o erro de truncamento: mostre que para ε < 0.01, erro < 0.5%.",
                                    "Discuta hipóteses: linearidade geométrica, comportamento elástico linear.",
                                    "Aplique em equações de equilíbrio: div(σ) + b = 0 com σ = C : ε.",
                                    "Resolva um problema simples analítico e numérico para validar."
                                  ],
                                  "verification": "Calcule o erro relativo entre ε e E para um alongamento de 1% e justifique linearidade.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Calculadora científica, template de FEM em Python, artigos sobre linear vs. não-linear"
                                  ],
                                  "tips": "Use séries de Taylor para visualizar a aproximação: E ≈ ε + (1/2)∇u^T ∇u.",
                                  "learningObjective": "Capacitar a justificativa teórica e numérica da aproximação.",
                                  "commonMistakes": "Aplicar linearidade sem checar magnitude de deformações; confundir linear geométrico com material."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Análise de Elementos Finitos e Diferenciar de Casos Não-Lineares",
                                  "subSteps": [
                                    "Monte a matriz B de deformação para um elemento linear: ε = B u_e.",
                                    "Implemente em código FEM simples para uma treliça ou viga.",
                                    "Compare resultados lineares vs. não-lineares para cargas crescentes.",
                                    "Identifique critérios de validade: deformações < 5%, rotações < 10°.",
                                    "Discuta quando usar grandes deformações (ex: balões, membranas)."
                                  ],
                                  "verification": "Simule uma barra tracionada com FEM linear e valide tensão-deformação vs. analítico.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Software FEniCS ou FreeFEM, tutoriais de implementação B-matrix, exemplos de benchmark"
                                  ],
                                  "tips": "Comece com malha grosseira para testar convergência rápida da linearidade.",
                                  "learningObjective": "Integrar o conceito em fluxos de FEM práticos.",
                                  "commonMistakes": "Usar B não-linear em solver linear; ignorar atualizações geométricas."
                                }
                              ],
                              "practicalExample": "Em uma análise de uma viga cantilever de aço sob carga ponta de 1 kN, calcule o tensor ε nos nós usando u_x = (P y z)/(2 E I) (teoria de Euler-Bernoulli aproximada). Verifique que max(ε) ≈ 0.001 < 0.01, justificando solver linear FEM com precisão >99%.",
                              "finalVerifications": [
                                "Derivar corretamente ε a partir de ∇u para um caso 2D.",
                                "Calcular erro de aproximação para deformação de 2% e concluir validade.",
                                "Montar matriz B para triângulo linear e computar ε em Gauss point.",
                                "Explicar verbalmente por que FEM linear falha em deformações >10%.",
                                "Simular e plotar campo de deformação em software, checando simetria.",
                                "Justificar uso em projeto real: ponte com deflexão L/500."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (90% correto).",
                                "Compreensão conceitual via justificativas claras (rubrica 1-5).",
                                "Aplicação prática em código ou cálculo manual sem erros.",
                                "Identificação correta de limites de validade.",
                                "Criatividade em exemplos reais e conexões interdisciplinares.",
                                "Clareza na comunicação de verificações finais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo tensorial e séries de Taylor para aproximações.",
                                "Física: Mecânica do contínuo e teoria da elasticidade linear.",
                                "Computação: Programação numérica em FEM (Python/MATLAB).",
                                "Engenharia Civil: Análise estrutural linear de edifícios.",
                                "Materiais: Relação tensão-deformação em regime elástico."
                              ],
                              "realWorldApplication": "Na certificação de aviões, usa-se deformações infinitesimais para simular tensões em asas sob cargas aerodinâmicas pequenas, permitindo iterações rápidas em design via FEM linear, reduzindo custos computacionais em 90% vs. não-linear."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.1.1.1.3",
                            "name": "Relacionar deformação com deslocamento",
                            "description": "Associar o campo de deslocamento ao conceito de deformação como gradiente de deslocamento em coordenadas cartesianas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de campo de deslocamento",
                                  "subSteps": [
                                    "Defina o campo de deslocamento u(x,y,z) como a vetor que descreve o movimento de cada ponto de um corpo deformável.",
                                    "Diferencie deslocamento (translação rígida) de deformação (mudança relativa de posição).",
                                    "Represente o deslocamento em coordenadas cartesianas: u = (u_x, u_y, u_z).",
                                    "Estude exemplos simples, como deslocamento uniforme em uma barra.",
                                    "Visualize usando diagramas de partículas antes e depois da deformação."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre deslocamento e deformação, com um desenho esquemático.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Mecânica dos Sólidos",
                                    "Papel e lápis para diagramas",
                                    "Software de visualização como GeoGebra"
                                  ],
                                  "tips": "Use analogias cotidianas, como esticar uma borracha, para fixar o conceito.",
                                  "learningObjective": "Identificar e representar o campo de deslocamento em sólidos deformáveis.",
                                  "commonMistakes": "Confundir deslocamento global com deformação local; ignorar componentes vetoriais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o gradiente do campo de deslocamento",
                                  "subSteps": [
                                    "Revise derivadas parciais: ∂u_i/∂x_j para i,j = x,y,z.",
                                    "Construa a matriz do gradiente de deslocamento: ∇u = [∂u_i/∂x_j].",
                                    "Interprete os elementos da matriz: diagonais representam alongamentos, off-diagonais rotações e cisalhamentos.",
                                    "Calcule o gradiente para um campo simples, como u_x = kx, u_y=0, u_z=0.",
                                    "Discuta a decomposição em parte simétrica (deformação) e anti-simétrica (rotação)."
                                  ],
                                  "verification": "Calcule e apresente a matriz ∇u para um campo dado e identifique seus componentes.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Caderno de exercícios",
                                    "Calculadora ou Mathematica/MATLAB",
                                    "Notas de cálculo vetorial"
                                  ],
                                  "tips": "Pratique com campos lineares primeiro para simplificar cálculos.",
                                  "learningObjective": "Calcular e interpretar o gradiente do campo de deslocamento.",
                                  "commonMistakes": "Esquecer o fator 1/2 na simetrização; confundir derivadas parciais com totais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir o tensor de deformação como gradiente simétrico",
                                  "subSteps": [
                                    "Apresente a fórmula do tensor de deformação infinitesimal: ε_ij = (1/2)(∂u_i/∂x_j + ∂u_j/∂x_i).",
                                    "Derive a fórmula a partir da mudança infinitesimal de comprimento ds^2 - ds_0^2 = 2 ε_ij dx_i dx_j.",
                                    "Calcule componentes principais: ε_xx = ∂u_x/∂x, ε_xy = (1/2)(∂u_x/∂y + ∂u_y/∂x).",
                                    "Verifique propriedades: simetria (ε_ij = ε_ji) e independência de rotação.",
                                    "Compare com teoria exata para pequenas deformações."
                                  ],
                                  "verification": "Derive a fórmula de ε_ij e aplique a um exemplo unidimensional.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Livro de Elementos Finitos (ex: Bathe)",
                                    "Planilha Excel para cálculos matriciais",
                                    "Vídeos tutoriais sobre strain tensor"
                                  ],
                                  "tips": "Memorize a fórmula central e pratique a simetrização manualmente.",
                                  "learningObjective": "Associar deformação diretamente ao gradiente simétrico do deslocamento.",
                                  "commonMistakes": "Omitir o 1/2 nos termos de cisalhamento; aplicar em deformações grandes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a relação em exemplos e problemas",
                                  "subSteps": [
                                    "Resolva um problema 2D: campo u_x = ax + by, u_y = cx + dy; calcule ε.",
                                    "Implemente em código simples (Python/MATLAB) para visualização do campo de deformação.",
                                    "Analise um caso real: deformação em uma placa sob tração.",
                                    "Compare resultados analíticos com aproximações numéricas.",
                                    "Discuta limites da teoria infinitesimal."
                                  ],
                                  "verification": "Resolva um problema completo e valide com software, explicando resultados.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Python com NumPy/Matplotlib",
                                    "Exercícios impressos",
                                    "Software FEA como FreeCAD"
                                  ],
                                  "tips": "Comece com casos simétricos para ganhar confiança.",
                                  "learningObjective": "Aplicar a relação deformação-deslocamento em contextos práticos.",
                                  "commonMistakes": "Erros de sinal nas derivadas; não verificar simetria do tensor."
                                }
                              ],
                              "practicalExample": "Em uma barra uniaxial de comprimento L sob tração com alongamento total δ, o campo de deslocamento é u_x(x) = (δ/L) x, u_y=0, u_z=0. O gradiente ∂u_x/∂x = δ/L, logo ε_xx = δ/L (deformação normal), demonstrando que a deformação é o gradiente longitudinal do deslocamento.",
                              "finalVerifications": [
                                "Derivar corretamente o tensor de deformação a partir do gradiente de deslocamento.",
                                "Calcular ε_ij para campos lineares em 2D/3D sem erros.",
                                "Explicar a diferença entre deformação e rotação rígida.",
                                "Aplicar em um exemplo numérico e validar simetria.",
                                "Identificar quando a teoria infinitesimal é válida (deformações <5%).",
                                "Visualizar o campo de deformação via software."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação matemática (fórmula exata com 1/2).",
                                "Correção nos cálculos de gradiente e tensor.",
                                "Interpretação física clara dos componentes.",
                                "Uso adequado de coordenadas cartesianas.",
                                "Identificação de erros comuns e limitações.",
                                "Criatividade em exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo vetorial e tensores.",
                                "Física: Mecânica contínua e teoria da elasticidade.",
                                "Programação: Simulações numéricas com Python/MATLAB.",
                                "Engenharia Civil: Análise estrutural.",
                                "Ciência de Materiais: Comportamento mecânico."
                              ],
                              "realWorldApplication": "Na análise de elementos finitos para projetos de pontes ou aviões, onde o software calcula deslocamentos nodais e deriva deformações via gradientes para prever tensões e evitar falhas estruturais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "34.1.1.2",
                        "name": "Componentes das Deformações",
                        "description": "Análise dos componentes do tensor de deformação, incluindo deformações normais e de cisalhamento em 1D, 2D e 3D.",
                        "specificSkills": [
                          {
                            "id": "34.1.1.2.1",
                            "name": "Descrever deformações normais",
                            "description": "Definir e exemplificar deformações normais ε_xx, ε_yy, ε_zz como derivadas parciais do deslocamento nas direções principais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Deslocamento e Deformação",
                                  "subSteps": [
                                    "Estude a definição de campo de deslocamento u(x,y,z) em sólidos deformáveis.",
                                    "Identifique as componentes u_x, u_y, u_z nas direções cartesianas principais.",
                                    "Revise o tensor de deformações como medida de deformação infinitesimal.",
                                    "Entenda a relação entre deformação e variação de comprimento em uma direção.",
                                    "Discuta a hipótese de deformações pequenas (linearização)."
                                  ],
                                  "verification": "Resuma em um diagrama as componentes de deslocamento e sua relação com deformação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Mecânica dos Materiais (ex: Beer & Johnston)",
                                    "Vídeo introdutório sobre strain tensor (YouTube/Khan Academy)",
                                    "Papel e lápis para diagramas"
                                  ],
                                  "tips": "Use coordenadas cartesianas fixas para evitar confusão com sistemas curvilíneos.",
                                  "learningObjective": "Compreender o campo de deslocamento como base para deformações normais.",
                                  "commonMistakes": "Confundir deslocamento total com deslocamento relativo; ignorar a linearização para pequenas deformações."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Matematicamente as Deformações Normais",
                                  "subSteps": [
                                    "Defina ε_xx = ∂u_x / ∂x como a deformação normal na direção x.",
                                    "Defina ε_yy = ∂u_y / ∂y e ε_zz = ∂u_z / ∂z de forma análoga.",
                                    "Escreva as expressões em notação tensorial e escalar.",
                                    "Discuta o significado físico: alongamento ou encurtamento unitário.",
                                    "Compare com deformações cisalhantes (ex: ε_xy)."
                                  ],
                                  "verification": "Escreva as três definições em um caderno e derive uma a partir da definição geral de strain.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de fórmulas de Elementos Finitos",
                                    "Software de edição de texto (LaTeX ou Word) para equações"
                                  ],
                                  "tips": "Lembre-se: derivada parcial mantém outras variáveis constantes.",
                                  "learningObjective": "Dominar as definições exatas das deformações normais como derivadas parciais.",
                                  "commonMistakes": "Usar derivadas totais em vez de parciais; confundir ε_xx com variação de volume."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Exemplificar com Casos Simples",
                                  "subSteps": [
                                    "Considere uma barra uniaxial alongada: u_x = ε x, derive ε_xx.",
                                    "Para tração biaxial, defina u_x = ε_xx x, u_y = ε_yy y, calcule componentes.",
                                    "Em um cubo deformado uniformemente, compute ε_xx, ε_yy, ε_zz.",
                                    "Plote o deslocamento vs. posição para visualização.",
                                    "Verifique neutralidade em direções sem deformação (ε=0)."
                                  ],
                                  "verification": "Calcule ε_xx para u_x = 0.01 x em uma barra de 1m e confirme alongamento de 1%.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB para plots",
                                    "Exemplos de problemas resolvidos em PDF"
                                  ],
                                  "tips": "Comece com casos 1D para construir intuição antes de 3D.",
                                  "learningObjective": "Aplicar definições em exemplos concretos para fixar conceitos.",
                                  "commonMistakes": "Esquecer unidades (deformação é adimensional); assumir isotropia sem justificativa."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e Visualizar Deformações Normais",
                                  "subSteps": [
                                    "Desenhe um elemento finito antes/depois da deformação mostrando ε_xx >0 (alongamento).",
                                    "Discuta sinais: positivo (tração), negativo (compressão).",
                                    "Relacione com tensão via lei de Hooke (ε = σ/E).",
                                    "Use software para simular um campo de deformação.",
                                    "Explique implicações em falhas estruturais."
                                  ],
                                  "verification": "Crie um sketch de um elemento deformado e rotule ε_xx, ε_yy, ε_zz corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software gratuito como FreeCAD ou Gmsh para visualização",
                                    "Papel milimetrado"
                                  ],
                                  "learningObjective": "Interpretar fisicamente as deformações normais em contextos reais.",
                                  "commonMistakes": "Ignorar rotações rígidas (que não contribuem para strain); superestimar deformações grandes."
                                }
                              ],
                              "practicalExample": "Em uma viga de ponte sob carga vertical, ε_zz (vertical) é negativa devido à compressão, enquanto ε_xx e ε_yy podem ser positivas por efeito de Poisson, calculadas como ∂u_z/∂z ≈ -δ/L onde δ é flecha e L é comprimento.",
                              "finalVerifications": [
                                "Defina corretamente ε_xx, ε_yy, ε_zz em termos de deslocamentos.",
                                "Calcule deformações normais para um campo de deslocamento dado.",
                                "Diferencie deformações normais de cisalhantes.",
                                "Interprete um mapa de strain em software FEM.",
                                "Explique o papel em análise de elementos finitos."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições matemáticas (100% correto).",
                                "Correção em cálculos de exemplos (erro <1%).",
                                "Qualidade de visualizações e diagramas (clareza e labels).",
                                "Profundidade na interpretação física (ligação com aplicações).",
                                "Identificação de erros comuns e evitações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo vetorial e derivadas parciais.",
                                "Física: Mecânica continuum e lei de Hooke.",
                                "Programação: Implementação em códigos FEM (Python/Fortran).",
                                "Engenharia Civil: Análise de estruturas sob carga."
                              ],
                              "realWorldApplication": "Na simulação de elementos finitos para projetos de aviões, deformações normais ε_xx, ε_yy, ε_zz são computadas para prever falhas por fadiga em asas, garantindo segurança e otimizando materiais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.1.1.1"
                            ]
                          },
                          {
                            "id": "34.1.1.2.2",
                            "name": "Explicar deformações de cisalhamento",
                            "description": "Detalhar componentes γ_xy, γ_xz, γ_yz como somas de derivadas cruzadas de deslocamentos, e sua relação com ângulos de distorção.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de deformação de cisalhamento",
                                  "subSteps": [
                                    "Revise os conceitos fundamentais de deformação em sólidos, diferenciando deformação normal de cisalhamento.",
                                    "Identifique que o cisalhamento ocorre quando planos paralelos deslizam uns sobre os outros.",
                                    "Analise diagramas de um elemento infinitesimal sujeito a cisalhamento.",
                                    "Discuta exemplos intuitivos, como cartas de baralho deslizando.",
                                    "Defina o tensor de deformação simétrico e sua representação em 3D."
                                  ],
                                  "verification": "Desenhe um diagrama de um elemento cúbico deformado por cisalhamento e rotule os ângulos de distorção.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Resistência dos Materiais (ex: Timoshenko), papel e lápis para diagramas.",
                                  "tips": "Use analogias cotidianas para fixar o conceito visualmente.",
                                  "learningObjective": "Entender a natureza física do cisalhamento como distorção angular.",
                                  "commonMistakes": "Confundir cisalhamento com rotação rígida; lembre-se que o centro de gravidade não se move."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir os componentes matemáticos das deformações de cisalhamento",
                                  "subSteps": [
                                    "Introduza os deslocamentos u(x,y,z), v(x,y,z), w(x,y,z).",
                                    "Escreva a definição de γ_xy = ∂u/∂y + ∂v/∂x.",
                                    "Estenda para γ_xz = ∂u/∂z + ∂w/∂x e γ_yz = ∂v/∂z + ∂w/∂y.",
                                    "Explique por que esses componentes são somas de derivadas cruzadas.",
                                    "Verifique a simetria do tensor de deformação (ε_xy = ε_yx = γ_xy / 2)."
                                  ],
                                  "verification": "Escreva as três equações de γ_xy, γ_xz e γ_yz a partir dos deslocamentos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Caderno de anotações, calculadora simbólica ou software como Mathematica.",
                                  "tips": "Memorize a forma simétrica: cada γ captura o cisalhamento em planos perpendiculares.",
                                  "learningObjective": "Dominar as expressões matemáticas exatas dos componentes de cisalhamento.",
                                  "commonMistakes": "Esquecer o fator 1/2 na tensão de cisalhamento correspondente; foque na deformação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar deformações de cisalhamento com ângulos de distorção",
                                  "subSteps": [
                                    "Defina o ângulo de distorção como a mudança no ângulo reto entre linhas originalmente perpendiculares.",
                                    "Mostre geometricamente que γ_xy ≈ 2 * α, onde α é o ângulo de distorção pequeno.",
                                    "Derive a relação para deformações pequenas usando aproximações lineares.",
                                    "Analise o efeito em um elemento 2D e estenda para 3D.",
                                    "Calcule numericamente um exemplo simples com valores de deslocamento."
                                  ],
                                  "verification": "Calcule γ_xy para um caso onde ∂u/∂y = 0.01 e ∂v/∂x = 0.02, e estime o ângulo de distorção.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de plotagem como MATLAB ou GeoGebra para visualização angular.",
                                  "tips": "Para pequenas deformações, γ é diretamente proporcional ao ângulo em radianos.",
                                  "learningObjective": "Conectar a definição matemática à interpretação geométrica do cisalhamento.",
                                  "commonMistakes": "Usar aproximações para grandes deformações; valide com limite linear."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Visualizar e interpretar deformações de cisalhamento em contexto",
                                  "subSteps": [
                                    "Construa uma malha de elementos finitos deformados mostrando γ_xy.",
                                    "Compare com deformações normais em um tensor completo.",
                                    "Discuta o papel no método dos elementos finitos (MEF).",
                                    "Resolva um problema simples de cálculo de γ a partir de campo de deslocamentos.",
                                    "Reflita sobre invariantes do tensor de deformação envolvendo cisalhamento."
                                  ],
                                  "verification": "Crie um sketch ou simulação de um elemento com γ_xy ≠ 0 e descreva a distorção.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software FEA como ANSYS Student ou FreeCAD, exemplos de problemas resolvidos.",
                                  "tips": "Use cores para visualizar diferentes componentes de γ em 3D.",
                                  "learningObjective": "Aplicar os conceitos em visualizações práticas para consolidação.",
                                  "commonMistakes": "Ignorar a contribuição mútua das derivadas; sempre some ∂u/∂y + ∂v/∂x."
                                }
                              ],
                              "practicalExample": "Considere uma placa sob cisalhamento simples onde u = (γ/2) y e v = (γ/2) x. Calcule γ_xy = γ e visualize como linhas retas se tornam paralelas, simulando deformação em uma junta de cola sob força tangencial.",
                              "finalVerifications": [
                                "Derivar corretamente γ_xy, γ_xz e γ_yz a partir de deslocamentos dados.",
                                "Explicar verbalmente a relação entre γ e ângulo de distorção.",
                                "Desenhar diagrama preciso de elemento deformado por cisalhamento.",
                                "Calcular γ para um campo de deslocamento simples.",
                                "Identificar cisalhamento zero em um tensor dado.",
                                "Discutir simetria do tensor de deformação."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas fórmulas matemáticas (100% correto).",
                                "Correta interpretação geométrica e física.",
                                "Uso apropriado de aproximações lineares.",
                                "Clareza em diagramas e exemplos.",
                                "Capacidade de generalizar para 3D.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo multivariável e tensores.",
                                "Física: Mecânica dos contínuos e equilíbrio.",
                                "Computação: Programação de solvers FEA em Python/MATLAB.",
                                "Engenharia Civil: Análise sísmica de estruturas."
                              ],
                              "realWorldApplication": "Em análise de elementos finitos para prever falhas por cisalhamento em pontes durante terremotos, aviões sob torção ou implantes médicos sob cargas tangenciais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.1.1.2"
                            ]
                          },
                          {
                            "id": "34.1.1.2.3",
                            "name": "Representar o tensor de deformação",
                            "description": "Construir a matriz simétrica do tensor de deformação ε em 3D, destacando sua simetria e independência de rotação rígida.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o conceito de deslocamento e gradiente de deslocamento",
                                  "subSteps": [
                                    "Defina o campo de deslocamento vetorial u(x,y,z) em um sólido deformável.",
                                    "Calcule o gradiente de deslocamento ∇u, representado como matriz 3x3 com componentes ∂u_i/∂x_j.",
                                    "Identifique a decomposição do gradiente em parte simétrica (deformação) e antisimétrica (rotação).",
                                    "Esboce um exemplo simples de um elemento deformado mostrando deslocamentos.",
                                    "Verifique a notação indexial: (∇u)_{ij} = ∂u_i / ∂x_j."
                                  ],
                                  "verification": "Escreva corretamente a matriz do gradiente de deslocamento para um deslocamento dado e identifique suas partes simétrica e antisimétrica.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Mecânica dos Sólidos (ex: Timoshenko)",
                                    "Caderno e lápis",
                                    "Software de álgebra simbólica como SymPy (opcional)"
                                  ],
                                  "tips": "Sempre use coordenadas cartesianas para simplicidade inicial; visualize com vetores de deslocamento em um cubo.",
                                  "learningObjective": "Compreender que o gradiente de deslocamento captura tanto deformação quanto rotação rígida.",
                                  "commonMistakes": [
                                    "Confundir deslocamento u com velocidade v.",
                                    "Esquecer que o gradiente é ∂u_i/∂x_j e não o inverso.",
                                    "Ignorar a distinção entre simétrico e antisimétrico."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o tensor de deformação infinitesimal ε",
                                  "subSteps": [
                                    "Lembre a definição: ε = (1/2)(∇u + (∇u)^T), a parte simétrica do gradiente.",
                                    "Escreva as componentes em notação indexial: ε_ij = (1/2)(∂u_i/∂x_j + ∂u_j/∂x_i).",
                                    "Discuta a aproximação para deformações pequenas (infinitesimal strain theory).",
                                    "Mostre que ε é simétrico: ε_ij = ε_ji.",
                                    "Compare com o tensor de rotação ω = (1/2)(∇u - (∇u)^T), que é antisimétrico."
                                  ],
                                  "verification": "Derive a expressão de ε a partir de ∇u e prove sua simetria algebricamente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Folha de derivadas parciais",
                                    "Exemplos de problemas resolvidos",
                                    "Calculadora ou MATLAB para verificação"
                                  ],
                                  "tips": "Use a transposta (∇u)^T para visualizar a simetria; pratique com i=j e i≠j.",
                                  "learningObjective": "Dominar a definição matemática do tensor de deformação e sua propriedade de simetria.",
                                  "commonMistakes": [
                                    "Esquecer o fator 1/2 na definição.",
                                    "Confundir com o tensor de Green-Lagrange para grandes deformações.",
                                    "Não transpor corretamente o gradiente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a matriz do tensor de deformação em 3D",
                                  "subSteps": [
                                    "Escreva a matriz explícita 3x3: ε = [[ε_xx, ε_xy, ε_xz], [ε_xy, ε_yy, ε_yz], [ε_xz, ε_yz, ε_zz]].",
                                    "Expresse cada componente: ε_xx = ∂u_x/∂x, ε_xy = (1/2)(∂u_x/∂y + ∂u_y/∂x), etc.",
                                    "Conte os 6 componentes independentes devido à simetria.",
                                    "Aplique a um campo de deslocamento exemplo simples, como u = (ax, by, cz).",
                                    "Verifique numericamente com valores específicos."
                                  ],
                                  "verification": "Construa a matriz ε para um deslocamento dado e confirme que é simétrica.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Matriz em branco 3x3",
                                    "Exemplos numéricos impressos",
                                    "Python com NumPy para automação"
                                  ],
                                  "tips": "Ordene as componentes como {ε_xx, ε_yy, ε_zz, 2ε_xy, 2ε_xz, 2ε_yz} no vetor de von Mises para FEM.",
                                  "learningObjective": "Construir e representar visualmente o tensor ε em coordenadas 3D.",
                                  "commonMistakes": [
                                    "Escrever componentes off-diagonal sem o 1/2.",
                                    "Perder a simetria na matriz final.",
                                    "Confundir índices x,y,z com 1,2,3."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Destacar independência de rotação rígida e aplicações",
                                  "subSteps": [
                                    "Explique que rotações rígidas (ω) não contribuem para ε, pois são antisimétricas.",
                                    "Demonstre com transformação de coordenadas: ε transforma como tensor sob rotações.",
                                    "Discuta invariância: traço(ε) = div(u) é invariante.",
                                    "Aplique em um exemplo de deformação pura vs. rígida.",
                                    "Conclua com representação em FEM: vetor de deformações com 6 DOFs."
                                  ],
                                  "verification": "Mostre que adicionando uma rotação rígida arbitrária, ε permanece o mesmo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software FEM como Abaqus/ANSYS tutorial",
                                    "Vídeos sobre decomposição polar",
                                    "Caderno para provas"
                                  ],
                                  "tips": "Use a decomposição polar F = R U, onde U captura deformação (simétrica).",
                                  "learningObjective": "Entender por que ε mede apenas deformação, ignorando rotações.",
                                  "commonMistakes": [
                                    "Achar que rotações afetam ε.",
                                    "Confundir independência com invariância total.",
                                    "Ignorar o contexto de pequenas deformações."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um cubo unitário com deslocamento u = (0.1x, 0.05y + 0.02z, 0.03x). Calcule ∇u, extraia ε e verifique simetria: ε_xy = 0.025, etc. Compare antes/depois de adicionar rotação rígida θ_z = 0.1 rad.",
                              "finalVerifications": [
                                "A matriz ε é simétrica (ε_ij = ε_ji para todos i,j)?",
                                "Existem exatamente 6 componentes independentes?",
                                "Adicionando rotação rígida, ε permanece inalterado?",
                                "O traço de ε equals div(u)?",
                                "Componentes off-diagonal têm fator 1/2 correto?",
                                "Representação em vetor coluna para FEM está correta?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação das componentes de ε (100% correto).",
                                "Correta prova de simetria e independência de rotação.",
                                "Uso apropriado de notação indexial e matricial.",
                                "Aplicação correta em exemplo numérico com verificação.",
                                "Explicação clara da relevância em 3D vs. 2D.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Linear: Propriedades de tensores simétricos e decomposição.",
                                "Física: Mecânica do contínuo e teoria de deformações infinitesimais.",
                                "Programação: Implementação de cálculo de ε em Python/NumPy para FEM.",
                                "Geometria Computacional: Transformações afins e rotações.",
                                "Engenharia Civil: Análise de tensões em estruturas."
                              ],
                              "realWorldApplication": "Em simulações de elementos finitos (FEM) para projetar pontes, aviões ou implantes médicos, onde o tensor ε é usado para calcular deformações e prever falhas sem contaminação por movimentos rígidos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.1.1.3"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "34.1.1.3",
                        "name": "Cálculo de Deformações em Meios Contínuos",
                        "description": "Métodos matemáticos para calcular o tensor de deformação a partir do campo de deslocamento em meios contínuos.",
                        "specificSkills": [
                          {
                            "id": "34.1.1.3.1",
                            "name": "Calcular deformações lineares",
                            "description": "Aplicar a fórmula ε = (1/2)(∇u + (∇u)^T) para obter componentes do tensor de deformação a partir de funções de deslocamento u(x,y,z).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Fundamentais do Gradiente de Deslocamento e Tensor de Deformação",
                                  "subSteps": [
                                    "Revise a definição do campo de deslocamento u(x,y,z) como um vetor com componentes ux, uy, uz.",
                                    "Estude o operador gradiente ∇ em coordenadas cartesianas: ∂/∂x, ∂/∂y, ∂/∂z.",
                                    "Compreenda que o tensor de deformação ε é simétrico e representa deformações lineares pequenas.",
                                    "Memorize a fórmula ε = (1/2)(∇u + (∇u)^T), onde ^T é a transposta.",
                                    "Identifique os componentes εxx = ∂ux/∂x, εxy = (1/2)(∂ux/∂y + ∂uy/∂x), etc."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a origem da fórmula e liste os 6 componentes independentes do tensor.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Mecânica dos Meios Contínuos (ex: Malvern ou Sadd)",
                                    "Caderno e caneta",
                                    "Vídeo tutorial sobre gradientes vetoriais"
                                  ],
                                  "tips": "Visualize ∇u como uma matriz 3x3 que descreve rotações e deformações; foque na parte simétrica para deformações puras.",
                                  "learningObjective": "Compreender a base matemática do tensor de deformação linear.",
                                  "commonMistakes": [
                                    "Confundir gradiente com derivada direcional",
                                    "Esquecer o fator 1/2 nos componentes off-diagonal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o Gradiente do Campo de Deslocamento ∇u",
                                  "subSteps": [
                                    "Escreva o campo de deslocamento u(x,y,z) dado no problema.",
                                    "Compute as 9 parciais: ∂ux/∂x, ∂ux/∂y, ∂ux/∂z, ∂uy/∂x, etc.",
                                    "Monte a matriz ∇u linha por linha (duas por componente).",
                                    "Verifique unidades: derivadas devem ser adimensionais para ε.",
                                    "Pratique com funções simples como u_x = kx, u_y = my."
                                  ],
                                  "verification": "Construa a matriz ∇u para um u dado e confirme que todos os elementos estão corretos comparando com solução modelo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software simbólico como SymPy ou Mathematica",
                                    "Papel quadriculado",
                                    "Exemplos de problemas de livro-texto"
                                  ],
                                  "tips": "Use notação matricial para organizar: ∇u = [∂u_i/∂x_j]_{i,j=1..3}.",
                                  "learningObjective": "Dominar o cálculo do gradiente de um campo vetorial 3D.",
                                  "commonMistakes": [
                                    "Erros de sinal nas derivadas parciais",
                                    "Confundir ordem das componentes na matriz"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a Fórmula para Construir o Tensor de Deformação ε",
                                  "subSteps": [
                                    "Calcule a transposta (∇u)^T trocando linhas por colunas.",
                                    "Some ∇u + (∇u)^T elemento a elemento.",
                                    "Divida por 2 para obter ε.",
                                    "Escreva explicitamente os 6 componentes únicos: ε11, ε22, ε33, ε12, ε13, ε23.",
                                    "Confirme simetria: εij = εji."
                                  ],
                                  "verification": "Compare o tensor resultante com uma solução analítica conhecida e verifique se trace(ε) corresponde à dilatação volumétrica.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Calculadora ou MATLAB para verificação numérica",
                                    "Planilha Excel para matrizes",
                                    "Folhas de exercícios"
                                  ],
                                  "tips": "Lembre-se: diagonais εii = ∂ui/∂xi; off-diagonais precisam do 1/2.",
                                  "learningObjective": "Aplicar corretamente a fórmula ε = (1/2)(∇u + (∇u)^T).",
                                  "commonMistakes": [
                                    "Esquecer de transpor corretamente",
                                    "Não dividir off-diagonais por 2"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Interpretar o Tensor de Deformação",
                                  "subSteps": [
                                    "Calcule os invariantes: I1 = trace(ε), I2, I3.",
                                    "Interprete: deformação normal (diagonal), cisalhamento (off-diagonal).",
                                    "Verifique se ε é simétrico e trace-zero para incompressível.",
                                    "Aplique a um exemplo físico simples.",
                                    "Discuta aproximações lineares (pequenas deformações)."
                                  ],
                                  "verification": "Resolva um problema completo e compare com software FEM como ANSYS para o mesmo u.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software FEM gratuito como Code_Aster ou FreeFEM",
                                    "Problemas resolvidos de Elementos Finitos"
                                  ],
                                  "tips": "Para validação, use u = (x/2, y/2, 0) → ε = diag(0.5, 0.5, 0).",
                                  "learningObjective": "Interpretar resultados físicos do tensor ε.",
                                  "commonMistakes": [
                                    "Ignorar hipóteses de pequenas deformações",
                                    "Confundir deformação com tensão"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado u(x,y,z) = (2x + y, x + 3y, 0), calcule ε: ∇u = [[2,1,0],[1,3,0],[0,0,0]], (∇u)^T = [[2,1,0],[1,3,0],[0,0,0]], ∇u + (∇u)^T = [[4,2,0],[2,6,0],[0,0,0]], ε = [[2,1,0],[1,3,0],[0,0,0]].",
                              "finalVerifications": [
                                "O tensor ε é simétrico (εij = εji).",
                                "Componentes diagonais correspondem a ∂ui/∂xi.",
                                "Componentes off-diagonal têm fator 1/2 correto.",
                                "Unidades adimensionais e valores consistentes com pequenas deformações (|ε| << 1).",
                                "Invariante I1 = εxx + εyy + εzz calculado corretamente.",
                                "Comparação com solução numérica ou FEM coincide dentro de 1%."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de todas as 9 parciais do ∇u (100% correto).",
                                "Construção correta da matriz ε com simetria verificada.",
                                "Interpretação física de pelo menos 3 componentes.",
                                "Tempo de resolução abaixo de 30 min para problema padrão.",
                                "Identificação e correção de erros comuns sem ajuda.",
                                "Aplicação autônoma a novo campo de deslocamento."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo vetorial e álgebra linear (matrizes simétricas).",
                                "Física: Mecânica do contínuo e teoria da elasticidade.",
                                "Computação: Programação em Python/MATLAB para automação de cálculos.",
                                "Engenharia Civil: Análise de deformações em vigas e placas."
                              ],
                              "realWorldApplication": "Em simulações de Elementos Finitos (FEM) para análise estrutural, como prever deformações em pontes sob carga, aviões em voo ou implantes médicos sob estresse, permitindo otimizar designs e prevenir falhas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.1.2.1",
                              "34.1.1.2.2"
                            ]
                          },
                          {
                            "id": "34.1.1.3.2",
                            "name": "Realizar cálculos em 1D e 2D",
                            "description": "Resolver exemplos numéricos de cálculo de deformações em barras (1D) e elementos planos (2D), verificando compatibilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de deformações em 1D para barras",
                                  "subSteps": [
                                    "Defina deformação axial em barras: ε = ΔL / L ou ε = du/dx.",
                                    "Revise a relação entre tensão e deformação pela lei de Hooke: σ = E ε.",
                                    "Estude condições de contorno e cargas axiais em barras simples.",
                                    "Analise o papel da malha 1D em elementos finitos básicos.",
                                    "Discuta aproximações lineares para campos de deslocamento em 1D."
                                  ],
                                  "verification": "Resuma os conceitos em um diagrama de barra com anotações de ε e σ.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Elementos Finitos (cap. deformações 1D)",
                                    "Papel e lápis para diagramas",
                                    "Calculadora"
                                  ],
                                  "tips": "Use unidades consistentes (SI) desde o início para evitar erros.",
                                  "learningObjective": "Compreender a definição e cálculo básico de deformação uniaxial em barras.",
                                  "commonMistakes": "Confundir deformação com deslocamento; esquecer de linearizar du/dx."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar cálculos numéricos de deformações em barras 1D",
                                  "subSteps": [
                                    "Selecione um exemplo: barra de L=1m, E=200GPa, u1=0, u2=0.001m.",
                                    "Calcule ε = (u2 - u1)/L = 0.001.",
                                    "Determine σ = E ε = 200MPa.",
                                    "Verifique equilíbrio de forças: F = σ A.",
                                    "Aplique em malha com 2 elementos e compare resultados."
                                  ],
                                  "verification": "Os valores de ε e σ coincidem com soluções analíticas dentro de 1% de erro.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software MATLAB ou Python para plotagem",
                                    "Planilha Excel para cálculos",
                                    "Exemplos resolvidos de livros"
                                  ],
                                  "tips": "Sempre plote o campo de deformação para visualização intuitiva.",
                                  "learningObjective": "Executar cálculos precisos de deformações em problemas 1D numéricos.",
                                  "commonMistakes": "Erro no sinal de deformação (compressão vs tração); divisão por zero em L=0."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Entender e calcular deformações em elementos planos 2D",
                                  "subSteps": [
                                    "Defina o tensor de deformação 2D: ε_xx=∂u/∂x, ε_yy=∂v/∂y, γ_xy=∂u/∂y + ∂v/∂x.",
                                    "Estude interpolação linear em triângulos ou quadriláteros.",
                                    "Calcule deformações nos pontos de Gauss para um elemento.",
                                    "Discuta estado plano de deformação vs tensão.",
                                    "Revise matriz B de deformações em EF."
                                  ],
                                  "verification": "Derive manualmente a matriz B para um triângulo linear.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Apostila de EF 2D",
                                    "Software FEA gratuito como FreeCAD",
                                    "Papel milimetrado"
                                  ],
                                  "tips": "Use coordenadas isoparamétricas para simplificar cálculos.",
                                  "learningObjective": "Dominar fórmulas e derivação de deformações planas em 2D.",
                                  "commonMistakes": "Esquecer o fator 1/2 em γ_xy; confundir u e v com coordenadas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver problemas numéricos 2D e verificar compatibilidade",
                                  "subSteps": [
                                    "Exemplo: Elemento quadrilateral com nós deslocados conhecidos.",
                                    "Calcule ε_xx, ε_yy, γ_xy no centro do elemento.",
                                    "Verifique compatibilidade: integre deformações para recuperar deslocamentos.",
                                    "Compare com solução 1D equivalente em direção axial.",
                                    "Analise erros e refine malha se necessário."
                                  ],
                                  "verification": "Deslocamentos integrados das deformações coincidem com valores iniciais (erro <5%).",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Exemplos de problemas 2D de livros",
                                    "Gráficos de deformação"
                                  ],
                                  "tips": "Teste com malhas grosseiras primeiro para depuração rápida.",
                                  "learningObjective": "Aplicar cálculos 2D e validar compatibilidade com 1D.",
                                  "commonMistakes": "Incompatibilidade numérica por malha distorcida; erros de arredondamento em derivadas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar e praticar cálculos mistos 1D-2D com verificação final",
                                  "subSteps": [
                                    "Combine barra 1D em estrutura 2D.",
                                    "Calcule deformações em ambos e verifique continuidade.",
                                    "Simule carga e plote contornos de deformação.",
                                    "Avalie sensibilidade a parâmetros (E, nu).",
                                    "Documente o processo em relatório curto."
                                  ],
                                  "verification": "Relatório mostra compatibilidade e gráficos coerentes.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software ANSYS Student ou similar",
                                    "Template de relatório"
                                  ],
                                  "tips": "Salve checkpoints de cálculos para rollback fácil.",
                                  "learningObjective": "Sintetizar habilidades 1D e 2D com verificação de compatibilidade.",
                                  "commonMistakes": "Ignorar efeitos de Poisson em 2D; inconsistência de unidades."
                                }
                              ],
                              "practicalExample": "Considere uma barra de aço (E=200GPa, A=0.01m², L=2m) com u1=0mm e u2=2mm sob tração (1D: ε=0.001, σ=200MPa). Em 2D, modele como elemento plano com deslocamentos nodais equivalentes e verifique se ε_xx=0.001, ε_yy≈0 (plano deformação), γ_xy=0, integrando para recuperar u.",
                              "finalVerifications": [
                                "Cálculos de ε em 1D coincidem com analítico em <1% erro.",
                                "Tensor de deformação 2D é simétrico e trace(ε) correto.",
                                "Integração de deformações recupera deslocamentos originais.",
                                "Campos de deformação são contínuos na interface 1D-2D.",
                                "Equilíbrio de forças verificado em nós.",
                                "Gráficos de deformação mostram comportamento físico esperado."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos de deformação (erro <2%).",
                                "Correta derivação e uso da matriz B em 2D.",
                                "Demonstração clara de verificação de compatibilidade.",
                                "Uso adequado de unidades e condições de contorno.",
                                "Qualidade dos gráficos e documentação.",
                                "Identificação e correção de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo diferencial (gradiente de deslocamentos).",
                                "Física: Mecânica dos sólidos contínuos e lei de Hooke.",
                                "Programação: Implementação numérica em Python/MATLAB para EF.",
                                "Engenharia de Materiais: Propriedades elásticas (E, ν).",
                                "Análise Computacional: Integração numérica em pontos de Gauss."
                              ],
                              "realWorldApplication": "Em projetos de engenharia mecânica, como análise de vigas em pontes ou fuselagens de aviões, onde cálculos precisos de deformações 1D/2D garantem segurança estrutural e otimizam designs via simulações de elementos finitos em softwares como ANSYS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.1.2.3"
                            ]
                          },
                          {
                            "id": "34.1.1.3.3",
                            "name": "Verificar propriedades do tensor",
                            "description": "Demonstrar que o tensor de deformação é simétrico e representa apenas distorção, excluindo rotações rígidas, através de cálculos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o conceito de gradiente de deslocamento",
                                  "subSteps": [
                                    "Defina o campo de deslocamento u(x,y,z) em um meio contínuo.",
                                    "Calcule o gradiente de deslocamento ∇u como a matriz de derivadas parciais ∂u_i/∂x_j.",
                                    "Explique a decomposição do gradiente em componentes simétrica e anti-simétrica.",
                                    "Identifique que ∇u = ε + ω, onde ε é simétrico (deformação) e ω anti-simétrico (rotação).",
                                    "Discuta o papel físico de cada componente."
                                  ],
                                  "verification": "Construa a matriz ∇u para um campo simples e confirme a decomposição.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Livro de Mecânica dos Sólidos (ex: Timoshenko)"
                                  ],
                                  "tips": "Use notação tensorial para clareza: ∇u_{ij} = ∂u_i / ∂x_j.",
                                  "learningObjective": "Compreender a origem matemática do tensor de deformação a partir do gradiente.",
                                  "commonMistakes": "Confundir deslocamento com deformação; esquecer que ∇u inclui rotações."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar o tensor de deformação simétrico",
                                  "subSteps": [
                                    "Escreva a fórmula do tensor infinitesimal de deformação: ε_{ij} = (1/2)(∂u_i/∂x_j + ∂u_j/∂x_i).",
                                    "Demonstre matematicamente que ε_{ij} = ε_{ji}, provando simetria.",
                                    "Calcule os componentes principais em 2D e 3D para um exemplo genérico.",
                                    "Compare com o tensor de rotação ω_{ij} = (1/2)(∂u_i/∂x_j - ∂u_j/∂x_i).",
                                    "Verifique que tr(ω) = 0 e que representa rotações rígidas."
                                  ],
                                  "verification": "Mostre que ε^T = ε e ω^T = -ω para componentes calculados.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Calculadora ou MATLAB para matrizes",
                                    "Folha de exercícios"
                                  ],
                                  "tips": "Memorize a média das derivadas off-diagonal para cisalhamento.",
                                  "learningObjective": "Derivar e provar propriedades fundamentais do tensor ε.",
                                  "commonMistakes": "Esquecer o fator 1/2; inverter os índices i e j."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Excluir rotações rígidas do tensor de deformação",
                                  "subSteps": [
                                    "Analise um movimento rígido puro (rotação sem deformação) e calcule ∇u.",
                                    "Mostre que ε = 0 para rotações rígidas, pois ∇u = ω.",
                                    "Para um caso com deformação + rotação, isole ε removendo ω.",
                                    "Interprete os invariantes de ε (tr(ε) = dilatação volumétrica).",
                                    "Confirme que ε captura apenas distorções (alongamento e cisalhamento)."
                                  ],
                                  "verification": "Em um exemplo, compute ε e verifique ausência de rotações rígidas.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Software como MATLAB ou Python (NumPy)",
                                    "Exemplos impressos"
                                  ],
                                  "tips": "Use rotação simples: u = (-ω y, ω x) para testar ε=0.",
                                  "learningObjective": "Demonstrar que ε exclui componentes rígidos.",
                                  "commonMistakes": "Incluir rotação como deformação; ignorar anti-simétrico."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar cálculos em um exemplo numérico",
                                  "subSteps": [
                                    "Escolha um campo de deslocamento 2D: u_x = 0.01 x + 0.02 y, u_y = 0.02 x + 0.03 y.",
                                    "Calcule ∇u e extraia ε e ω.",
                                    "Verifique simetria: ε_xy = ε_yx = 0.02.",
                                    "Confirme que ω captura rotação e ε apenas deformação.",
                                    "Plote ou visualize o campo deformado."
                                  ],
                                  "verification": "Resultados: ε = [[0.01, 0.02], [0.02, 0.03]], simétrico e tr(ε)=0.04.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "MATLAB/Python",
                                    "Gráficos de deformação"
                                  ],
                                  "tips": "Valide numericamente com sympy para derivadas exatas.",
                                  "learningObjective": "Aplicar teoria em cálculo concreto para verificação.",
                                  "commonMistakes": "Erros aritméticos em derivadas; confundir unidades."
                                }
                              ],
                              "practicalExample": "Considere um elemento quadrilateral em 2D com deslocamentos nos nós: nó1 (0,0): (0,0); nó2 (1,0): (0.01,0.02); nó3 (1,1): (0.03,0.01); nó4 (0,1): (0.02,0.03). Calcule o gradiente aproximado ∇u no centro, extraia ε simétrico e verifique que representa cisalhamento sem rotação rígida global.",
                              "finalVerifications": [
                                "O tensor ε é simétrico: ε_ij = ε_ji para todos i,j.",
                                "Componentes anti-simétricos ω_ij = -ω_ji e representam rotação.",
                                "Para movimento rígido puro, ε = 0.",
                                "Traço tr(ε) indica variação volumétrica sem rotação.",
                                "Cálculos numéricos coincidem com propriedades teóricas.",
                                "Visualização mostra distorção pura excluindo translação/rotação."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de ε (100% correto).",
                                "Correta prova de simetria e exclusão de rotações.",
                                "Exemplo numérico com cálculos verificáveis.",
                                "Interpretação física clara (distorção vs. rígido).",
                                "Uso adequado de notação tensorial.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes simétricas, decomposição).",
                                "Física: Cinemática de sólidos contínuos.",
                                "Computação: Programação numérica em FEM (MATLAB, Python).",
                                "Engenharia Civil: Análise de estruturas deformáveis."
                              ],
                              "realWorldApplication": "Em simulações de Elementos Finitos (ex: ANSYS), verificar propriedades do tensor garante modelagem precisa de deformações em estruturas sob carga, evitando erros de rotação rígida em análises de fadiga ou colapso."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.1.3.1"
                            ]
                          },
                          {
                            "id": "34.1.1.3.4",
                            "name": "Aplicar em contexto de elementos finitos",
                            "description": "Relacionar o cálculo de deformações com a matriz de derivadas das funções de interpolação nos elementos finitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos de Deformação em Meios Contínuos",
                                  "subSteps": [
                                    "Defina tensor de deformação ε como simétrico e relacionado ao gradiente de deslocamentos u via ε = (∇u + (∇u)^T)/2.",
                                    "Explique componentes em 1D (ε_xx = du_x/dx), 2D e 3D.",
                                    "Discuta diferenças entre deformação total, elástica e plástica em contextos lineares.",
                                    "Relacione deformação com tensão via lei de Hooke em MEF.",
                                    "Identifique notação padrão: ε = [ε_xx, ε_yy, γ_xy]^T em 2D."
                                  ],
                                  "verification": "Resuma as equações de deformação em um diagrama e explique verbalmente para um par.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de MEF (ex: Bathe), caderno, calculadora.",
                                  "tips": "Use ilustrações visuais de um elemento deformando para fixar conceitos.",
                                  "learningObjective": "Compreender a base matemática das deformações antes da discretização em MEF.",
                                  "commonMistakes": "Confundir deformação com deslocamento; ignorar simetria do tensor."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Funções de Interpolação em Elementos Finitos",
                                  "subSteps": [
                                    "Defina funções de forma N_i(ξ,η) em coordenadas naturais para elementos lineares (barra, triângulo).",
                                    "Expresse deslocamentos nodais u(x) ≈ Σ N_i u_i.",
                                    "Calcule gradiente de deslocamentos ∇u = Σ (∇N_i) u_i.",
                                    "Discuta transformação de coordenadas isoparamétricas: J^{-1} ∂N/∂ξ.",
                                    "Exemplo: N_1 = (1-ξ)/2 para barra 1D."
                                  ],
                                  "verification": "Escreva funções N para um elemento linear 1D e plote-as.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software MATLAB/Python para plotar N_i, papel milimetrado.",
                                  "tips": "Sempre normalize coordenadas naturais (-1 a 1) para simplicidade.",
                                  "learningObjective": "Dominar interpolação nodal como base para derivadas em MEF.",
                                  "commonMistakes": "Esquecer transformação jacobiana; confundir coordenadas globais e locais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Matriz de Derivadas das Funções de Interpolação",
                                  "subSteps": [
                                    "Compute ∂N/∂x = J^{-1} ∂N/∂ξ, onde J é o jacobiano.",
                                    "Construa matriz [B] com derivadas: B = [∂N1/∂x 0; 0 ∂N1/∂y; ∂N1/∂y ∂N1/∂x; ...] para 2D.",
                                    "Para elemento triangular linear: derive explicitamente B em termos de coordenadas nodais.",
                                    "Verifique propriedades: soma das colunas de B soma a zero em estados rígidos.",
                                    "Implemente cálculo simbólico em SymPy ou manualmente."
                                  ],
                                  "verification": "Derive B para um triângulo específico e confira com fórmula padrão.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "SymPy/MATLAB, exemplos de elementos de referência.",
                                  "tips": "Use Gauss points para avaliação numérica precisa de derivadas.",
                                  "learningObjective": "Calcular corretamente a matriz [B] a partir de funções N.",
                                  "commonMistakes": "Erro no jacobiano invertido; não simetrizar shear strains (γ=2ε_xy)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar Matriz [B] ao Cálculo de Deformações",
                                  "subSteps": [
                                    "Estabeleça ε = [B] {d}, onde {d} são deslocamentos nodais.",
                                    "Demonstre para barra 1D: ε = (1/L) [-1 1] {u1 u2}.",
                                    "Em 2D: monte ε vetorial completo e multiplique por {d}.",
                                    "Integre em formulação fraca: ∫ [B]^T σ dV.",
                                    "Valide com exemplo analítico: deformação uniforme."
                                  ],
                                  "verification": "Compute ε para deslocamentos dados e compare com solução exata.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora matricial, código Python para multiplicação.",
                                  "tips": "Mantenha consistência na ordenação nodal ao montar [B].",
                                  "learningObjective": "Aplicar [B] para obter deformações diretamente de nodais.",
                                  "commonMistakes": "Usar ∇u assimétrico; escalar errado os termos de cisalhamento."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar em Exemplo Prático e Verificar",
                                  "subSteps": [
                                    "Monte malha simples: barra ou placa com carga conhecida.",
                                    "Calcule [B] por elemento, ε por Gauss point.",
                                    "Compare deformações com solução analítica ou FEA comercial.",
                                    "Analise sensibilidade a malha.",
                                    "Documente em relatório com gráficos de ε."
                                  ],
                                  "verification": "Gráfico de deformações coincide com esperado (±5% erro).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "ANSYS/MATLAB PDE Toolbox, Excel para pós-processamento.",
                                  "tips": "Comece com 1D para depurar antes de 2D/3D.",
                                  "learningObjective": "Integrar cálculo de deformações em fluxo MEF completo.",
                                  "commonMistakes": "Malha distorcida levando a J singular; ignorar integração numérica."
                                }
                              ],
                              "practicalExample": "Considere uma barra 1D de comprimento L=1m, nós em x=0 e x=1 com u1=0, u2=0.01m. Funções N1=(1-x)/L, N2=x/L. Derivadas: dN1/dx=-1/L, dN2/dx=1/L. Matriz B=[-1/L, 1/L]. Deformação ε=B*[0,0.01]^T=0.01 (uniforme), confirmando alongamento 1%.",
                              "finalVerifications": [
                                "Deriva corretamente [B] para elemento dado sem erros algébricos.",
                                "Calcula ε=[B]{d} e interpreta fisicamente (ex: tensão via E*ε).",
                                "Identifica e corrige modo rígido (ε=0 para translação).",
                                "Valida com software FEA para malha simples.",
                                "Explica relação ∇u → [B] → ε em entrevista.",
                                "Aplica em 2D com cisalhamento corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de [B] (90%+ correto).",
                                "Compreensão conceitual: liga interpolação a deformações continuum.",
                                "Habilidade prática: implementa em código ou mão sem erros.",
                                "Criatividade: estende a elementos não-lineares.",
                                "Clareza na documentação e comunicação.",
                                "Eficiência: completa em tempo estimado com qualidade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo vetorial, álgebra matricial, transformação de coordenadas.",
                                "Programação: Implementação numérica em Python/MATLAB para automação de [B].",
                                "Física: Mecânica dos sólidos, equilíbrio em continua.",
                                "Engenharia Civil: Análise de estruturas via MEF.",
                                "Ciência de Materiais: Relação ε-σ não-linear."
                              ],
                              "realWorldApplication": "Em projetos de engenharia mecânica, como análise de deformações em asas de aviões ou chassis de carros usando software como Abaqus, onde [B] garante precisão na previsão de falhas por excesso de deformação, otimizando design e segurança."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.1.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.4",
                    "name": "Equações Constitutivas",
                    "description": "Relações constitutivas entre tensões e deformações, incluindo lei de Hooke.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.4.1.1",
                        "name": "Relações Constitutivas Gerais",
                        "description": "Definição e importância das equações constitutivas que relacionam tensões e deformações em materiais contínuos no contexto do método dos elementos finitos.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.1.1.1",
                            "name": "Definir equações constitutivas",
                            "description": "Explicar o que são equações constitutivas e sua função de ligar o campo de tensões ao campo de deformações em sólidos deformáveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de tensão e deformação",
                                  "subSteps": [
                                    "Definir tensão como a intensidade de forças internas por unidade de área em um sólido deformável.",
                                    "Classificar tensões em normais (tração/compressão) e cisalhantes.",
                                    "Definir deformação como a variação relativa de dimensões ou ângulos.",
                                    "Explicar o tensor de tensão e tensor de deformação em notação tensorial básica.",
                                    "Relacionar tensão e deformação como campos contínuos em sólidos."
                                  ],
                                  "verification": "Escrever definições claras e um diagrama simples ilustrando tensão e deformação em uma barra uniaxial.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Resistência dos Materiais (ex: Timoshenko), vídeo introdutório sobre mecânica dos sólidos, papel e caneta para diagramas.",
                                  "tips": "Use analogias cotidianas, como esticar uma borracha para deformação e medir forças em uma mola para tensão.",
                                  "learningObjective": "Dominar as definições precisas de tensão e deformação como base para equações constitutivas.",
                                  "commonMistakes": "Confundir tensão com força total ou deformação absoluta com deformação específica (engenharia)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o conceito e função das equações constitutivas",
                                  "subSteps": [
                                    "Explicar que equações constitutivas relacionam o campo de tensões (σ) ao campo de deformações (ε) em sólidos.",
                                    "Discutir sua posição nos três pilares do MEF: equilíbrio, compatibilidade e constitutivas.",
                                    "Destacar que elas descrevem o comportamento material (elástico, plástico, etc.).",
                                    "Apresentar exemplos qualitativos: materiais lineares vs. não-lineares.",
                                    "Esquematizar o fluxo: tensões → equações constitutivas → deformações."
                                  ],
                                  "verification": "Desenhar um fluxograma mostrando a ligação entre tensão, deformação e equações constitutivas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Slides ou apostila de Elementos Finitos, software de diagramação como Draw.io.",
                                  "tips": "Pense nas equações constitutivas como a 'personalidade' do material que dita como ele responde às forças.",
                                  "learningObjective": "Entender o papel das equações constitutivas como ponte entre tensão e deformação.",
                                  "commonMistakes": "Achar que equações constitutivas resolvem equilíbrio; elas só relacionam campos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar formas matemáticas das equações constitutivas básicas",
                                  "subSteps": [
                                    "Apresentar a lei de Hooke generalizada para materiais isotrópicos lineares: σ_ij = λ δ_ij ε_kk + 2μ ε_ij.",
                                    "Explicar constantes de Lamé (λ e μ) e sua relação com E (módulo de Young) e ν (coeficiente de Poisson).",
                                    "Derivar a forma uniaxial simplificada: σ = E ε.",
                                    "Discutir simetria e invariância para materiais isotrópicos.",
                                    "Comparar com formas anisotrópicas em matriz 6x6."
                                  ],
                                  "verification": "Derivar e escrever corretamente a relação σ = E ε a partir das constantes de Lamé.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora simbólica (ex: Mathematica ou papel), tabela de propriedades de materiais.",
                                  "tips": "Memorize as relações E = μ(3λ + 2μ)/(λ + μ) para conversões rápidas.",
                                  "learningObjective": "Formular matematicamente equações constitutivas para casos lineares elásticos.",
                                  "commonMistakes": "Confundir índices em tensores ou usar equações 2D em problemas 3D."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar generalizações e limitações das equações constitutivas",
                                  "subSteps": [
                                    "Discutir extensões para não-linearidades (hiperelásticas, plásticas).",
                                    "Explicar dependência de temperatura, taxa de deformação e história de carregamento.",
                                    "Apresentar exemplos de modelos: von Mises para plasticidade.",
                                    "Relacionar com hipóteses de pequenos deslocamentos e deformações.",
                                    "Verificar consistência dimensional e unidades."
                                  ],
                                  "verification": "Listar três limitações da lei de Hooke linear e propor uma equação alternativa para um caso.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Artigos introdutórios sobre modelos constitutivos avançados, software ANSYS para visualização.",
                                  "tips": "Sempre verifique se o modelo se aplica ao regime de deformação (elástica pequena vs. grande).",
                                  "learningObjective": "Reconhecer quando usar equações constitutivas gerais vs. simplificadas.",
                                  "commonMistakes": "Aplicar linear elástica a grandes deformações ou materiais viscoelásticos."
                                }
                              ],
                              "practicalExample": "Em uma viga de aço sob flexão uniaxial, use σ_x = E ε_x para calcular a deformação máxima ε_x = σ_x / E, onde E = 200 GPa, ligando diretamente tensão aplicada à deformação local sem resolver equilíbrio completo.",
                              "finalVerifications": [
                                "Explicar verbalmente o papel das equações constitutivas em ligar tensões a deformações.",
                                "Derivar corretamente a lei de Hooke isotrópica 3D.",
                                "Identificar constantes materiais em uma equação dada.",
                                "Diferenciar constitutivas de equações de equilíbrio.",
                                "Aplicar em um exemplo uniaxial simples com números.",
                                "Listar limitações para casos não-lineares."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas sem ambiguidades (30%).",
                                "Domínio matemático: derivações e fórmulas exatas (25%).",
                                "Clareza na explicação: uso de diagramas e analogias (20%).",
                                "Compreensão contextual: ligação com MEF e pilares (15%).",
                                "Capacidade crítica: identificação de limitações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra tensorial e operações em tensores simétricos.",
                                "Física: Mecânica do contínuo e termodinâmica de deformação.",
                                "Ciência dos Materiais: Propriedades microestruturais influenciando λ e μ.",
                                "Computação: Implementação em códigos de MEF como matriz de rigidez."
                              ],
                              "realWorldApplication": "Nas simulações de elementos finitos para projeto de pontes ou aviões, as equações constitutivas permitem prever deformações sob cargas reais, garantindo segurança estrutural e otimizando materiais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.1.2",
                            "name": "Identificar componentes de tensão e deformação",
                            "description": "Listar e descrever os componentes de tensão (σ) e deformação (ε) em notação tensorial e vetorial para problemas 3D.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Tensão e Deformação como Tensores",
                                  "subSteps": [
                                    "Defina tensão como uma grandeza tensorial de segunda ordem que descreve forças internas por unidade de área.",
                                    "Explique deformação como o tensor simétrico que quantifica mudanças geométricas no material.",
                                    "Diferencie tensão normal (diagonal) de tensão cisalhante (fora da diagonal).",
                                    "Discuta a simetria dos tensores de tensão e deformação em problemas 3D.",
                                    "Revise a representação matricial de tensores 3D (6 componentes independentes)."
                                  ],
                                  "verification": "Escreva definições curtas e liste os 6 componentes independentes de cada tensor.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Mecânica dos Sólidos (ex: Timoshenko)",
                                    "Vídeo introdutório sobre tensores (YouTube/Khan Academy)",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Use analogias como 'tensão é como pressão em todas as direções' para fixar conceitos.",
                                  "learningObjective": "Entender tensão e deformação como tensores simétricos de segunda ordem em 3D.",
                                  "commonMistakes": [
                                    "Confundir tensão com força escalar; ignorar simetria (σ_xy = σ_yx)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Componentes de Tensão em Notação Tensorial e Vetorial",
                                  "subSteps": [
                                    "Liste os componentes de tensão: σ_xx, σ_yy, σ_zz (normais); σ_xy, σ_xz, σ_yz (cisalhantes).",
                                    "Represente o tensor de tensão como matriz 3x3: [[σ_xx, σ_xy, σ_xz], [σ_xy, σ_yy, σ_yz], [σ_xz, σ_yz, σ_zz]].",
                                    "Converta para notação vetorial: {σ_xx, σ_yy, σ_zz, σ_xy, σ_xz, σ_yz} ou Voigt notation.",
                                    "Pratique identificando componentes em um diagrama de elemento de tensão 3D.",
                                    "Desenhe vetores de tração em faces de um cubo infinitesimal."
                                  ],
                                  "verification": "Monte a matriz de tensão a partir de 6 valores dados e identifique normais vs. cisalhantes.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software de desenho vetorial (ex: GeoGebra)",
                                    "Folhas de exercícios de tensão 3D",
                                    "Calculadora"
                                  ],
                                  "tips": "Sempre verifique simetria ao montar a matriz para evitar erros de transcrição.",
                                  "learningObjective": "Listar e representar corretamente os 6 componentes de tensão em ambas as notações.",
                                  "commonMistakes": [
                                    "Esquecer a simetria nas posições off-diagonal; confundir ordem Voigt (xy antes de xz)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Componentes de Deformação em Notação Tensorial e Vetorial",
                                  "subSteps": [
                                    "Liste componentes de deformação: ε_xx, ε_yy, ε_zz (normais); ε_xy, ε_xz, ε_yz (cisalhantes, γ/2).",
                                    "Represente o tensor de deformação como matriz simétrica 3x3.",
                                    "Explique a relação com deslocamentos: ε_ij = (1/2)(∂u_i/∂x_j + ∂u_j/∂x_i).",
                                    "Converta para notação de engenharia: {ε_xx, ε_yy, ε_zz, γ_xy, γ_xz, γ_yz} onde γ_ij = 2ε_ij.",
                                    "Pratique com gradientes de deslocamento simples."
                                  ],
                                  "verification": "Dado um campo de deslocamento, calcule e liste os 6 componentes de deformação.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Planilha Excel para cálculos de derivadas",
                                    "Tutorial Ansys ou Abaqus sobre strain tensors",
                                    "Exercícios impressos"
                                  ],
                                  "tips": "Lembre-se: deformação cisalhante em tensor é metade da engenharia (ε_xy = γ_xy/2).",
                                  "learningObjective": "Distinguir e calcular componentes de deformação, notando fatores de 1/2 para cisalhamento.",
                                  "commonMistakes": [
                                    "Confundir ε_xy com γ_xy; ignorar o fator 1/2 na definição tensorial."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação Integrada e Visualização em Problemas 3D",
                                  "subSteps": [
                                    "Analise um problema 3D simples (ex: cubo sob cargas triaxiais) e extraia todos os componentes σ e ε.",
                                    "Compare notações tensorial, matricial e vetorial lado a lado.",
                                    "Use software para visualizar tensores (ex: plot de Mohr's circle 3D ou glyphs).",
                                    "Resolva 3 exercícios variados identificando componentes de σ e ε.",
                                    "Discuta transformações de coordenadas para componentes invariantes."
                                  ],
                                  "verification": "Resolva um exercício completo e rotule todos os componentes corretamente em um diagrama.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Software FEM gratuito (ex: FreeCAD, CalculiX)",
                                    "Exercícios resolvidos de livros de EF",
                                    "Gráficos de tensores online"
                                  ],
                                  "tips": "Comece com casos uniaxial para build-up para 3D; visualize com setas coloridas.",
                                  "learningObjective": "Aplicar identificação de componentes em contextos reais de análise 3D.",
                                  "commonMistakes": [
                                    "Não considerar todas as direções em 3D; erros em transformações de base."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma análise de elementos finitos de uma placa sob flexão biaxial, identifique σ_xx = 150 MPa (normal), σ_xy = 30 MPa (cisalhante), ε_zz = -0.0005 (Poisson), etc., usando a matriz tensorial para input no solver.",
                              "finalVerifications": [
                                "Liste corretamente os 6 componentes independentes de σ e ε sem erros de simetria.",
                                "Converta um tensor de tensão 3x3 para notação Voigt.",
                                "Calcule componentes de deformação a partir de deslocamentos u,v,w dados.",
                                "Identifique normais vs. cisalhantes em um diagrama de cubo 3D.",
                                "Explique a diferença entre ε_xy (tensor) e γ_xy (engenharia).",
                                "Monte matrizes completas para um caso triaxial simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na listagem e descrição de todos os componentes (90% correto).",
                                "Correta representação matricial e vetorial com simetria.",
                                "Compreensão de fatores de escala em deformação cisalhante.",
                                "Habilidade em visualizar e rotular componentes em diagramas.",
                                "Aplicação correta em exemplos práticos de EF.",
                                "Identificação de erros comuns e autocorreção."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (tensores, autovalores para invariantes).",
                                "Física: Mecânica continuum e equilíbrio de forças.",
                                "Programação: Implementação em Python/MATLAB para solvers FEM.",
                                "Materiais: Relações constitutivas ligando σ e ε.",
                                "Computação Gráfica: Visualização de campos tensorais."
                              ],
                              "realWorldApplication": "Em simulações de elementos finitos para design de aviões ou pontes, engenheiros identificam componentes de tensão/deformação para prever falhas, otimizar materiais e validar modelos contra testes experimentais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.1.3",
                            "name": "Explicar linearidade nas relações constitutivas",
                            "description": "Discutir a hipótese de linearidade nas relações constitutivas e sua validade para materiais elásticos lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir Relações Constitutivas e sua Importância",
                                  "subSteps": [
                                    "Explicar que relações constitutivas descrevem a relação entre tensões (σ) e deformações (ε) em um material.",
                                    "Discutir como elas são fundamentais no método dos elementos finitos para modelar comportamento material.",
                                    "Revisar a forma geral não-linear: σ = f(ε), contrastando com formas lineares.",
                                    "Identificar componentes constitutivos em equações de equilíbrio e compatibilidade.",
                                    "Esboçar um diagrama tensão-deformação genérico."
                                  ],
                                  "verification": "Capacidade de definir corretamente relações constitutivas e esboçar diagrama tensão-deformação sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Mecânica dos Sólidos (ex: Timoshenko), caderno para diagramas, acesso a slides ou PDF introdutório.",
                                  "tips": "Use analogias como molas para visualizar a relação tensão-deformação.",
                                  "learningObjective": "Compreender o papel das relações constitutivas na modelagem de materiais.",
                                  "commonMistakes": "Confundir relações constitutivas com leis de equilíbrio; assumir linearidade sem justificativa."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a Hipótese de Linearidade",
                                  "subSteps": [
                                    "Definir linearidade: σ = C ε, onde C é o tensor de rigidez constante.",
                                    "Explicar propriedades: proporcionalidade, sobreposição (superposição de deformações) e elasticidade.",
                                    "Derivar a lei de Hooke unidimensional e estendê-la para 3D isotrópico: E, ν.",
                                    "Discutir premissas matemáticas: homogeneidade, isotropia e independência de rotação.",
                                    "Calcular um exemplo simples: tensão em barra uniaxial."
                                  ],
                                  "verification": "Derivação correta da lei linear e cálculo numérico preciso para exemplo uniaxial.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora ou software simbólico (ex: Mathematica), tabela de propriedades de materiais.",
                                  "tips": "Memorize a matriz de rigidez para casos isotrópicos para agilizar derivações.",
                                  "learningObjective": "Explicar matematicamente a hipótese de linearidade e suas propriedades.",
                                  "commonMistakes": "Ignorar a dependência do tensor C em rotações; confundir linearidade com elasticidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Validade para Materiais Elásticos Lineares",
                                  "subSteps": [
                                    "Descrever materiais elásticos lineares: deformações pequenas (<0.1-1%), regime elástico (aço, alumínio).",
                                    "Discutir testes experimentais: curvas tensão-deformação lineares em ensaios uniaxial.",
                                    "Explicar limites: plasticidade, grandes deformações, visco-elasticidade.",
                                    "Comparar com materiais não-lineares (borracha hiperelástica) via gráficos.",
                                    "Avaliar no contexto de elementos finitos: convergência e precisão."
                                  ],
                                  "verification": "Identificação correta de materiais válidos e limites, com gráfico comparativo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Dados experimentais de materiais (ex: banco de dados MatWeb), software de plotagem (ex: MATLAB ou Python Matplotlib).",
                                  "tips": "Use curvas reais de ensaios para validar visualmente a linearidade.",
                                  "learningObjective": "Avaliar empiricamente a validade da hipótese para elásticos lineares.",
                                  "commonMistakes": "Generalizar linearidade para todos os elásticos; ignorar efeitos de taxa de deformação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Limitações e Aplicações em Elementos Finitos",
                                  "subSteps": [
                                    "Analisar quando a hipótese falha: grandes rotações, não-linearidades geométricas.",
                                    "Explicar impacto em simulações EF: escolha de modelo constitutivo linear vs. não-linear.",
                                    "Realizar uma simulação simples em software EF com modelo linear.",
                                    "Comparar resultados lineares vs. não-lineares para um caso limite.",
                                    "Concluir sobre critérios de seleção da hipótese."
                                  ],
                                  "verification": "Simulação EF executada com resultados coerentes e discussão de discrepâncias.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software EF gratuito (ex: FreeCAD ou CalculiX), modelo de malha simples.",
                                  "tips": "Comece com malhas grosseiras para testar rapidamente a hipótese.",
                                  "learningObjective": "Aplicar e criticar a linearidade em contextos computacionais reais.",
                                  "commonMistakes": "Não considerar não-linearidades geométricas; superestimar precisão linear."
                                }
                              ],
                              "practicalExample": "Em uma viga de aço cantilever sob carga pontual pequena (deformação <0.5%), aplicar σ = E ε para calcular tensões máximas e validar com ensaio experimental, confirmando linearidade via gráfico tensão vs. deformação.",
                              "finalVerifications": [
                                "Explicação clara da equação σ = C ε com propriedades de linearidade.",
                                "Identificação de premissas para elásticos lineares (pequenas deformações, isotropia).",
                                "Gráfico comparativo tensão-deformação linear vs. não-linear.",
                                "Simulação EF simples com modelo linear convergindo corretamente.",
                                "Discussão de um caso real onde linearidade falha (ex: colapso plástico)."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definição e derivação corretas (30%).",
                                "Análise crítica: validade e limitações discutidas com evidências (25%).",
                                "Exemplos práticos: cálculos e simulações precisos (20%).",
                                "Clareza de comunicação: diagramas e explicações acessíveis (15%).",
                                "Conexões interdisciplinares: links com experimentos e EF (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (tensores, autovalores de C).",
                                "Física: Mecânica dos sólidos e experimentos de materiais.",
                                "Computação: Programação de solvers EF e visualização de dados.",
                                "Química: Propriedades microestruturais afetando linearidade."
                              ],
                              "realWorldApplication": "No design de pontes ou aviões, usar linearidade para simulações EF rápidas de estruturas de aço/alumínio em regime elástico, otimizando peso e segurança sem computação excessiva, como na análise de fadiga em asas de aeronaves."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.1.2",
                        "name": "Lei de Hooke",
                        "description": "Formulação da lei de Hooke para materiais isotrópicos lineares elásticos, incluindo relações uniaxial, plana e 3D.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.1.2.1",
                            "name": "Derivar lei de Hooke uniaxial",
                            "description": "Obter a relação σ = E ε a partir de experimentos de tração e sua generalização para múltiplas direções.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Tensão e Deformação",
                                  "subSteps": [
                                    "Defina tensão uniaxial σ como força normal F dividida pela área inicial A (σ = F/A).",
                                    "Defina deformação unitária ε como mudança relativa de comprimento ΔL/L₀.",
                                    "Explique o conceito de comportamento elástico linear dentro do limite de proporcionalidade.",
                                    "Discuta a diferença entre tensão/deformação de engenharia e verdadeira.",
                                    "Revise unidades SI: σ em Pa (N/m²), ε adimensional."
                                  ],
                                  "verification": "Calcule corretamente σ e ε para um exemplo dado com F=1000N, A=10mm², ΔL=0.1mm, L₀=100mm.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Resistência dos Materiais (ex: Beer & Johnston)",
                                    "Folha de fórmulas",
                                    "Calculadora"
                                  ],
                                  "tips": "Use sempre grandezas iniciais para tensão/deformação de engenharia em derivações iniciais.",
                                  "learningObjective": "Dominar definições precisas de σ e ε para basear a derivação experimental.",
                                  "commonMistakes": "Confundir área inicial com deformada; ignorar sinal de tração (positivo)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o Experimento de Tração Uniaxial",
                                  "subSteps": [
                                    "Selecione uma amostra cilíndrica padrão (ex: diâmetro 10mm, comprimento 100mm) de material dúctil como aço baixo carbono.",
                                    "Instale a amostra em uma máquina universal de ensaios com extensômetro ou strain gauge para medir ΔL.",
                                    "Calibre o sistema de carga (célula de carga) e deslocamento.",
                                    "Defina incrementos de carga até ~50% do limite elástico (ex: 0-20kN em passos de 2kN).",
                                    "Registre condições iniciais: L₀, A₀, temperatura ambiente."
                                  ],
                                  "verification": "Descreva o setup completo e confirme que extensômetro está posicionado corretamente nos gauges.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Máquina de tração ou software de simulação (ex: ANSYS Student, Excel com dados simulados)",
                                    "Amostra padrão",
                                    "Extensômetro"
                                  ],
                                  "tips": "Garanta alinhamento perfeito da amostra para evitar flambagem ou cisalhamento.",
                                  "learningObjective": "Preparar um experimento controlado para capturar regime elástico linear.",
                                  "commonMistakes": "Posicionar extensômetro fora da zona gauge; não calibrar zero de carga."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Experimento e Coletar Dados",
                                  "subSteps": [
                                    "Aplique cargas incrementais monotonicamente e registre F e ΔL para cada passo.",
                                    "Meça pelo menos 10 pontos no regime elástico (verifique linearidade visual).",
                                    "Anote dados em tabela: carga F (N), deslocamento ΔL (mm).",
                                    "Repita o teste 2-3 vezes para média e descartar outliers.",
                                    "Pare antes do limite de escoamento (offset 0.2%)."
                                  ],
                                  "verification": "Obtenha tabela com ≥10 pares (F, ΔL) mostrando variação linear.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha Excel/Google Sheets",
                                    "Dados experimentais ou simulados"
                                  ],
                                  "tips": "Aplique carga lentamente (taxa 1mm/min) para evitar vibrações.",
                                  "learningObjective": "Coletar dados empíricos precisos no regime elástico.",
                                  "commonMistakes": "Exceder limite elástico; não repetir testes para reprodutibilidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Dados e Derivar Relação Linear",
                                  "subSteps": [
                                    "Calcule σ = F/A₀ e ε = ΔL/L₀ para cada ponto.",
                                    "Plote gráfico σ (eixo y) vs ε (eixo x) usando software.",
                                    "Verifique linearidade (R² > 0.99) e ajuste reta σ = m ε (m = E).",
                                    "Calcule E como inclinação da reta via regressão linear mínima quadrados.",
                                    "Estime erro com barras de erro dos testes repetidos."
                                  ],
                                  "verification": "Gere gráfico linear com E calculado (ex: 200 GPa para aço) e R² alto.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Excel/MATLAB/Python (numpy, matplotlib)",
                                    "Dados da tabela"
                                  ],
                                  "tips": "Use escala log se necessário, mas foque em linear; ignore pontos não-lineares.",
                                  "learningObjective": "Extrair empiricamente σ = E ε do gráfico experimental.",
                                  "commonMistakes": "Plotar F vs ΔL em vez de σ vs ε; usar regressão inadequada."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Generalizar para Múltiplas Direções",
                                  "subSteps": [
                                    "Explique que uniaxial assume ε_transversal=0; introduza contração lateral ν = -ε_lat/ε_axial.",
                                    "Derive forma 3D isotrópica: ε_ij = (1/E) [ (1+ν) σ_ij - ν δ_ij σ_kk ].",
                                    "Mostre inversa: σ_ij = λ δ_ij ε_kk + 2μ ε_ij (constantes de Lamé).",
                                    "Discuta tensorial: σ_ij = C_ijkl ε_kl para anisotrópicos.",
                                    "Valide com equação uniaxial: para σ_xx ≠0 outros=0, obtém σ_xx = E ε_xx."
                                  ],
                                  "verification": "Escreva e prove que a forma geral reduz a σ = E ε uniaxial.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Notas de Mecânica dos Continuos",
                                    "Software simbólico (SymPy)"
                                  ],
                                  "tips": "Use índices para clareza; memorize E, ν, λ, μ relações.",
                                  "learningObjective": "Estender derivação empírica uniaxial à lei constitutiva geral.",
                                  "commonMistakes": "Esquecer sinal negativo em ν; confundir inversa direta."
                                }
                              ],
                              "practicalExample": "Em um teste de tração de uma barra de alumínio (A₀=50mm², L₀=200mm), dados mostram para F=5kN, ΔL=0.125mm → σ=100MPa, ε=0.000625 → E=σ/ε=160GPa. Plot confirma linearidade até 200MPa.",
                              "finalVerifications": [
                                "Deriva σ = E ε com E correto para material dado.",
                                "Gera gráfico experimental σ-ε linear com R²>0.98.",
                                "Generaliza corretamente para 3D com ν incorporado.",
                                "Calcula E via regressão com erro <5%.",
                                "Identifica limite elástico nos dados.",
                                "Explica redução tensorial à uniaxial."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições de σ e ε (100% correto).",
                                "Qualidade da coleta/análise de dados (≥10 pontos, R²>0.99).",
                                "Correção matemática da derivação linear e generalização.",
                                "Interpretação física (regime elástico, E material).",
                                "Clareza no relatório/gráfico com verificações.",
                                "Tratamento de erros e repetibilidade."
                              ],
                              "crossCurricularConnections": [
                                "Física: Mecânica clássica e elasticidade.",
                                "Matemática: Regressão linear e análise tensorial.",
                                "Programação: Simulação em Python/MATLAB para plots e ajustes.",
                                "Química: Propriedades microestruturais afetando E.",
                                "Engenharia Civil: Aplicação em dimensionamento de vigas."
                              ],
                              "realWorldApplication": "Na análise de elementos finitos para design de pontes ou aviões, a lei de Hooke uniaxial/generalizada permite simular deformações sob carga, prevendo falhas e otimizando materiais em softwares como ABAQUS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.2.2",
                            "name": "Aplicar lei de Hooke em estado plano",
                            "description": "Escrever as equações para tensão e deformação em estados plano de tensões e deformações, com módulos de Young (E) e Poisson (ν).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Lei de Hooke Geral em 3D",
                                  "subSteps": [
                                    "Estude a relação constitutiva geral isotrópica linear: σ_ij = λ δ_ij ε_kk + 2μ ε_ij",
                                    "Expresse em termos de E e ν: ε_x = (1/E)[σ_x - ν(σ_y + σ_z)], e similares para outros componentes",
                                    "Memorize as matrizes de rigidez para tensões e deformações em 3D",
                                    "Pratique convertendo entre tensões e deformações para casos uniaxial e biaxial simples",
                                    "Identifique os componentes nulos em estados planos"
                                  ],
                                  "verification": "Escreva corretamente as 6 equações de deformação em termos de tensões para um caso uniaxial e verifique com valores numéricos (E=200 GPa, ν=0.3)",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Mecânica dos Materiais (ex: Beer & Johnston), calculadora científica, folha de anotações",
                                  "tips": "Use notação tensorial para generalidade, mas foque em componentes cartesianos para clareza",
                                  "learningObjective": "Compreender a base tridimensional da lei de Hooke para simplificações planas",
                                  "commonMistakes": "Confundir E com G (módulo de cisalhamento) ou esquecer o fator (1+ν) em γ_xy"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar Equações para Estado Plano de Tensão (Plane Stress)",
                                  "subSteps": [
                                    "Defina condições: σ_z = τ_xz = τ_yz = 0",
                                    "Substitua na lei geral: ε_z = -(ν/E)(σ_x + σ_y), mas ε_z ≠ 0",
                                    "Escreva ε_x = (1/E)(σ_x - ν σ_y), ε_y = (1/E)(σ_y - ν σ_x), γ_xy = (2(1+ν)/E) τ_xy",
                                    "Inverta para tensões: σ_x = (E/(1-ν²))(ε_x + ν ε_y), e similar para σ_y e τ_xy",
                                    "Verifique dimensionalidade e consistência com caso uniaxial (σ_y=0)"
                                  ],
                                  "verification": "Derive e escreva as 3 equações de tensão-deformação e 3 inversas; teste com σ_x=100 MPa, σ_y=50 MPa",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel quadriculado, software simbólico como Mathematica ou SymPy (opcional), tabela de propriedades de materiais",
                                  "tips": "Lembre-se que em plane stress, ε_z é livre, permitindo contração lateral fora do plano",
                                  "learningObjective": "Dominar as equações constitutivas para plane stress, comuns em placas finas",
                                  "commonMistakes": "Esquecer o denominador (1-ν²) nas expressões invertidas ou usar γ_xy = τ_xy / G incorretamente"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar Equações para Estado Plano de Deformação (Plane Strain)",
                                  "subSteps": [
                                    "Defina condições: ε_z = γ_xz = γ_yz = 0",
                                    "Substitua: σ_z = ν(σ_x + σ_y), τ_xz = τ_yz = 0",
                                    "Escreva ε_x = (1+ν)/E [(1-ν)σ_x - ν σ_y], ε_y = (1+ν)/E [(1-ν)σ_y - ν σ_x], γ_xy = (1+ν)/E τ_xy",
                                    "Inverta: σ_x = (E/(1+ν)(1-2ν))[(1-ν)ε_x + ν ε_y], incluindo σ_z",
                                    "Compare diferenças com plane stress usando um exemplo numérico idêntico"
                                  ],
                                  "verification": "Escreva as equações completas e compute σ_z para um caso dado; confirme ε_z=0",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Mesmos do step anterior, mais exemplos de problemas de FEM",
                                  "tips": "Plane strain é equivalente a plane stress com material 'modificado' E' = E/(1-ν²), ν' = ν/(1-ν)",
                                  "learningObjective": "Entender e aplicar equações para plane strain, usadas em estruturas longas",
                                  "commonMistakes": "Confundir σ_z com zero (não é em plane strain) ou erros nos fatores (1-2ν)"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar as Equações em um Caso Prático",
                                  "subSteps": [
                                    "Escolha um problema: placa fina com σ_x=100 MPa, σ_y=0 (plane stress)",
                                    "Calcule todas deformações e compare com uniaxial 3D",
                                    "Repita para plane strain com mesmas tensões iniciais",
                                    "Discuta quando usar cada um (espessura vs comprimento)",
                                    "Implemente em código simples (ex: Python para matriz constitutiva)"
                                  ],
                                  "verification": "Resolva numericamente e plote gráfico tensão vs deformação; valores devem coincidir com teoria",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python/Jupyter com NumPy, exemplos de código FEM básicos",
                                  "tips": "Sempre verifique simetria das matrizes constitutivas (6x6 reduzida para 3x3 plana)",
                                  "learningObjective": "Integrar equações em aplicações práticas e identificar condições de uso",
                                  "commonMistakes": "Aplicar plane stress em casos thick-walled ou vice-versa sem justificativa geométrica"
                                }
                              ],
                              "practicalExample": "Em uma placa fina de alumínio (E=70 GPa, ν=0.33) sujeita a tração uniaxial σ_x=50 MPa e cisalhamento τ_xy=20 MPa (plane stress): calcule ε_x, ε_y, γ_xy e compare com medições experimentais de strain gauges.",
                              "finalVerifications": [
                                "Escreve corretamente as 3 equações de deformação e 3 de tensão para plane stress sem erros",
                                "Deriva σ_z corretamente em plane strain e verifica ε_z=0",
                                "Aplica inversão matricial para um caso numérico com precisão <1%",
                                "Distinguir condições de aplicação (thin vs thick structures)",
                                "Implementa matriz [D] 3x3 para ambos estados em código",
                                "Compara resultados plane stress vs strain com gráfico coerente"
                              ],
                              "assessmentCriteria": [
                                "Precisão nas equações constitutivas (100% correto em derivação)",
                                "Correta identificação de componentes nulos e livres",
                                "Uso apropriado de E e ν em todos cálculos numéricos",
                                "Capacidade de inverter relações tensão-deformação",
                                "Justificativa contextual para escolha de estado plano",
                                "Ausência de erros dimensionais ou de unidades"
                              ],
                              "crossCurricularConnections": [
                                "Física: Ondas e vibrações em placas (equações similares)",
                                "Programação: Implementação em solvers FEM (MATLAB/Python)",
                                "Matemática: Álgebra linear para matrizes de rigidez",
                                "Materiais: Influência de anisotropia em compósitos"
                              ],
                              "realWorldApplication": "Em simulações de Elementos Finitos para análise de placas aeronáuticas (plane stress) ou barragens (plane strain), otimizando design contra falhas por deformação excessiva."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.4.1.2.3",
                            "name": "Formular lei de Hooke em 3D",
                            "description": "Expressar a relação geral {σ} = [C] {ε} com a matriz constitutiva [C] em termos de E e ν para materiais isotrópicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Lei de Hooke unidimensional e introduzir tensões e deformações em 3D",
                                  "subSteps": [
                                    "Lembre-se da lei de Hooke 1D: σ = E ε, onde σ é tensão normal, ε deformação normal e E módulo de Young.",
                                    "Defina os vetores de tensão {σ} = [σ_x, σ_y, σ_z, τ_xy, τ_xz, τ_yz]^T e deformação {ε} = [ε_x, ε_y, ε_z, γ_xy, γ_xz, γ_yz]^T.",
                                    "Explique o efeito de Poisson: ν = -ε_transversal / ε_longitudinal.",
                                    "Discuta a generalização para multicomponente: relação linear entre {σ} e {ε}.",
                                    "Represente graficamente tensores de tensão e deformação em 3D."
                                  ],
                                  "verification": "Escreva corretamente os vetores {σ} e {ε} e defina E e ν com exemplos numéricos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Resistência dos Materiais, quadro branco, calculadora.",
                                  "tips": "Use analogias como uma barra esticada para visualizar efeitos em 3D.",
                                  "learningObjective": "Compreender a transição da lei 1D para a representação vetorial 3D.",
                                  "commonMistakes": "Confundir deformações de cisalhamento γ com ângulos pequenos (γ = 2ε_xy)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a relação constitutiva geral elástica linear",
                                  "subSteps": [
                                    "Apresente a equação {σ} = [C] {ε}, onde [C] é a matriz de rigidez 6x6.",
                                    "Explique que para materiais lineares elásticos, [C] relaciona tensões e deformações.",
                                    "Discuta simetria da matriz [C] (36 → 21 constantes independentes).",
                                    "Para isotrópicos, reduzem-se a 2 constantes: E e ν (ou λ e μ).",
                                    "Esboce a estrutura da matriz [C] com termos genéricos."
                                  ],
                                  "verification": "Escreva a equação matricial geral e identifique o número de constantes para isotrópicos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de álgebra linear (MATLAB ou Python), notas de aula.",
                                  "tips": "Visualize [C] como uma 'tabela de influência' entre componentes.",
                                  "learningObjective": "Entender a forma matricial da lei constitutiva e suas simplificações.",
                                  "commonMistakes": "Esquecer que [C] é simétrica e positiva definida."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Expressar constantes elásticas em termos de E e ν para isotrópicos",
                                  "subSteps": [
                                    "Derive as constantes de Lamé: λ = E ν / ((1+ν)(1-2ν)), μ = E / (2(1+ν)).",
                                    "Mostre a relação inversa {ε} = [S] {σ}, com [S] compliance matrix.",
                                    "Expresse elementos de [C] usando λ e μ: C_iiii = λ + 2μ, C_iijj = λ (i≠j), C_ijij = μ.",
                                    "Substitua λ e μ por E e ν na matriz completa.",
                                    "Verifique dimensionalmente os termos."
                                  ],
                                  "verification": "Calcule λ e μ para E=200 GPa, ν=0.3 e escreva 3 elementos chave de [C].",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilha Excel ou SymPy para derivações simbólicas.",
                                  "tips": "Memorize o fator comum: E / ((1+ν)(1-2ν)).",
                                  "learningObjective": "Dominar a derivação das constantes isotrópicas em E e ν.",
                                  "commonMistakes": "Erro no denominador (1-2ν) levando a valores negativos inválidos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular e validar a matriz constitutiva [C] completa em 3D",
                                  "subSteps": [
                                    "Escreva a matriz [C] explícita 6x6 com todos os termos em E e ν.",
                                    "Confirme os blocos: diagonais normais, off-diagonais ν, cisalhamento μ.",
                                    "Aplique a um caso simples: tensão uniaxial σ_x, verifique ε_x = σ_x/E, ε_y=ε_z=-ν σ_x/E.",
                                    "Discuta invariância sob rotação para isotrópicos.",
                                    "Implemente em código para um exemplo numérico."
                                  ],
                                  "verification": "Reproduza a matriz [C] completa e valide com caso uniaxial.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código Python/MATLAB pronto, papel para matriz.",
                                  "tips": "Copie a matriz padrão mas derive pelo menos uma linha.",
                                  "learningObjective": "Formular explicitamente [C] e validar sua correção.",
                                  "commonMistakes": "Colocar termos errados nos cisalhamentos (deve ser G=μ, não E)."
                                }
                              ],
                              "practicalExample": "Para um aço com E=200 GPa e ν=0.3, sob tensão uniaxial σ_x=100 MPa, calcule todas as deformações usando {ε} = [S] {σ}, onde [S]=[C]^{-1}, e confirme ε_x=500 με, ε_y=ε_z=-150 με.",
                              "finalVerifications": [
                                "Reproduzir a matriz [C] 6x6 correta em termos de E e ν.",
                                "Derivar λ e μ corretamente para valores dados.",
                                "Validar lei uniaxial a partir da 3D.",
                                "Calcular {σ} para um {ε} dado com precisão.",
                                "Explicar por que isotrópicos têm só 2 parâmetros.",
                                "Identificar erros em matrizes incompletas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de λ, μ e elementos de [C] (80%).",
                                "Correta representação vetorial de {σ} e {ε} (10%).",
                                "Validação numérica com exemplo uniaxial (5%).",
                                "Explicação clara de isotropia e simetria (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes simétricas, autovalores).",
                                "Física: Mecânica do contínuo e teoria da elasticidade.",
                                "Ciência dos Materiais: Propriedades macroscópicas E e ν.",
                                "Computação: Implementação em FEA (software como ANSYS)."
                              ],
                              "realWorldApplication": "Na análise de elementos finitos (FEA) para simular deformações em estruturas como pontes ou aviões, onde [C] é usada para prever tensões sob cargas complexas em materiais isotrópicos como aço ou alumínio."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.1.4.1.2.4",
                            "name": "Calcular tensões a partir de deformações",
                            "description": "Resolver numericamente tensões dadas deformações usando a lei de Hooke em exemplos simples 3D.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Lei de Hooke em 3D",
                                  "subSteps": [
                                    "Revise a relação constitutiva σ = C ε, onde σ é o vetor de tensões, ε de deformações e C a matriz de rigidez.",
                                    "Identifique os componentes em notação Voigt: ε = [ε_x, ε_y, ε_z, γ_xy, γ_xz, γ_yz] e σ similar.",
                                    "Estude a matriz C para materiais isotrópicos lineares elásticos, expressa em termos de módulo de Young E e coeficiente de Poisson ν.",
                                    "Memorize as fórmulas explícitas para os elementos da matriz C, como C11 = E(1-ν)/((1+ν)(1-2ν)).",
                                    "Diferencie tensão normal de cisalhante e fatores de engenharia (γ = 2ε para tensor)."
                                  ],
                                  "verification": "Liste corretamente os 6 componentes de ε e σ e escreva a forma da matriz C para isotrópico.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de fórmulas da lei de Hooke 3D",
                                    "Livro de Resistência dos Materiais (cap. equações constitutivas)",
                                    "Calculadora científica"
                                  ],
                                  "tips": [
                                    "Use notação Voigt para simplificar cálculos matriciais.",
                                    "Verifique sempre a simetria da matriz C."
                                  ],
                                  "learningObjective": "Dominar a formulação matricial da lei de Hooke para problemas 3D isotrópicos.",
                                  "commonMistakes": [
                                    "Confundir deformação de cisalhamento γ com o tensor ε_xy (γ=2ε_xy)",
                                    "Usar fórmulas 1D em problemas 3D",
                                    "Esquecer o denominador (1+ν)(1-2ν) na matriz C"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar Dados de Entrada do Problema",
                                  "subSteps": [
                                    "Colete as deformações dadas: ε_x, ε_y, ε_z, γ_xy, γ_xz, γ_yz.",
                                    "Obtenha propriedades do material: E (módulo de elasticidade) e ν (Poisson).",
                                    "Verifique unidades consistentes (ex: ε adimensional, E em Pa).",
                                    "Forme o vetor ε em notação Voigt.",
                                    "Calcule os elementos da matriz C usando E e ν."
                                  ],
                                  "verification": "Confirme que o vetor ε tem 6 componentes corretos e C é simétrica com valores numéricos precisos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela de propriedades de materiais (aço: E=200 GPa, ν=0.3)",
                                    "Planilha Excel ou papel para matrizes",
                                    "Calculadora"
                                  ],
                                  "tips": [
                                    "Padronize unidades SI para evitar erros de escala.",
                                    "Use ν típico (0.2-0.5) para metais."
                                  ],
                                  "learningObjective": "Preparar entradas numéricas precisas para aplicação da lei de Hooke.",
                                  "commonMistakes": [
                                    "Inverter valores de E e ν",
                                    "Esquecer fatores 2 em γ para notação tensorial",
                                    "Usar ε em % ao invés de fração"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Tensões Numericamente",
                                  "subSteps": [
                                    "Monte a matriz C completa 6x6.",
                                    "Compute σ = C * ε via multiplicação matricial.",
                                    "Calcule cada componente σ_i = sum(C_ij * ε_j) sequencialmente.",
                                    "Arredonde resultados com precisão adequada (ex: 3 casas decimais para MPa).",
                                    "Registre tensões principais se necessário via autovalores (opcional para simples)."
                                  ],
                                  "verification": "Compare σ calculado com verificação manual de 1-2 componentes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software MATLAB/Python para matriz (opcional)",
                                    "Papel quadriculado para multiplicação manual",
                                    "Calculadora matricial"
                                  ],
                                  "tips": [
                                    "Implemente em código para automação futura.",
                                    "Verifique se det(C) > 0 para material estável."
                                  ],
                                  "learningObjective": "Executar cálculos matriciais precisos para tensões 3D.",
                                  "commonMistakes": [
                                    "Erro de índice na multiplicação (linhas vs colunas)",
                                    "Não aplicar fator de engenharia corretamente",
                                    "Arredondamento prematuro levando a erros propagados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Interpretar Resultados",
                                  "subSteps": [
                                    "Confira equilíbrio de unidades (Pa ou MPa).",
                                    "Avalie se valores são fisicamente razoáveis (ex: σ < limite de escoamento).",
                                    "Compare com caso conhecido (ex: uniaxial: σ_x = E ε_x).",
                                    "Discuta implicações: regiões de tração/compressão/cisalhamento.",
                                    "Documente o processo completo para reutilização."
                                  ],
                                  "verification": "Resultados batem com exemplo conhecido e unidades corretas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela de limites de materiais",
                                    "Gráfico de σ vs ε para visualização"
                                  ],
                                  "tips": [
                                    "Use critérios de Von Mises para tensão equivalente.",
                                    "Sempre cheque sinal das tensões."
                                  ],
                                  "learningObjective": "Garantir validade e interpretação prática dos cálculos.",
                                  "commonMistakes": [
                                    "Ignorar sinal negativo (compressão)",
                                    "Não verificar contra limite elástico",
                                    "Confundir tensão com esforço"
                                  ]
                                }
                              ],
                              "practicalExample": "Para aço (E=200 GPa, ν=0.3), dadas deformações ε = [0.001, 0.0005, -0.0002, 0.002, 0.001, 0.0008] em notação Voigt. Calcule σ: σ_x ≈ 225 MPa, σ_y ≈ 120 MPa, etc. Verifique σ_z ≈ -50 MPa considerando efeito Poisson.",
                              "finalVerifications": [
                                "Matriz C montada corretamente com todos elementos.",
                                "Vetor σ tem 6 componentes com unidades consistentes (MPa).",
                                "Verificação cruzada: σ_x = E ε_x ajustado por ν bate.",
                                "Valores de tensão abaixo de 500 MPa para ε~0.001.",
                                "Processo documentado passo a passo.",
                                "Simetria e propriedades elásticas preservadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos (±1% erro).",
                                "Uso correto da notação Voigt e fatores de engenharia.",
                                "Montagem exata da matriz C com E e ν.",
                                "Verificação de unidades e razoabilidade física.",
                                "Documentação clara dos passos e resultados.",
                                "Interpretação correta das tensões calculadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (multiplicação matricial, autovalores para tensões principais).",
                                "Física: Mecânica dos sólidos (estados de tensão e deformação).",
                                "Computação: Programação numérica (Python/NumPy para FEM).",
                                "Química dos Materiais: Relação entre microestrutura e E/ν.",
                                "Engenharia Civil: Aplicação em análise estrutural."
                              ],
                              "realWorldApplication": "Em software de Elementos Finitos (ANSYS, Abaqus) para prever tensões em peças aeronáuticas sob deformações medidas, evitando falhas catastróficas em asas ou fuselagens."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.1.2.3"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.1.3",
                        "name": "Matriz Constitutiva e Propriedades",
                        "description": "Construção e propriedades da matriz de rigidez constitutiva [D] ou [C] no método dos elementos finitos.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.1.3.1",
                            "name": "Construir matriz constitutiva isotrópica",
                            "description": "Derivar explicitamente a matriz 6x6 [D] para materiais isotrópicos em termos de constantes elásticas laminares e volumétricas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais e definir constantes elásticas",
                                  "subSteps": [
                                    "Definir os vetores de tensão {σ_x, σ_y, σ_z, τ_xy, τ_yz, τ_zx} e deformação {ε_x, ε_y, ε_z, γ_xy, γ_yz, γ_zx} em notação de Voigt.",
                                    "Recordar a lei de Hooke generalizada para materiais isotrópicos: σ = [D] ε.",
                                    "Introduzir constantes elásticas laminares (E: módulo de Young plano, ν: coeficiente de Poisson laminar) e volumétricas (K: módulo volumétrico, G: módulo de cisalhamento).",
                                    "Estabelecer relações: λ = K - (2/3)G, μ = G; E = G(3λ + 2G)/(λ + G), ν = λ/(2(λ + G)).",
                                    "Verificar consistência entre constantes com exemplos numéricos simples."
                                  ],
                                  "verification": "Escrever corretamente as definições e relações entre pelo menos 3 pares de constantes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro-texto de Elementos Finitos",
                                    "Calculadora científica",
                                    "Folha de papel quadriculado"
                                  ],
                                  "tips": "Use unidades consistentes (GPa para módulos) para evitar erros de escala.",
                                  "learningObjective": "Compreender as constantes elásticas e sua inter-relação para materiais isotrópicos.",
                                  "commonMistakes": [
                                    "Confundir γ (deformação de cisalhamento engenharia) com 2ε_xy",
                                    "Ignorar a dependência entre constantes laminares e volumétricas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar as componentes normais da matriz [D]",
                                  "subSteps": [
                                    "Partir da decomposição volumétrica: ε_v = (ε_x + ε_y + ε_z), σ_v = 3K ε_v.",
                                    "Escrever equações para σ_x = λ (ε_x + ε_y + ε_z) + 2μ ε_x, e similares para σ_y, σ_z.",
                                    "Expressar λ em termos de constantes laminares: λ = E ν / ((1+ν)(1-2ν)).",
                                    "Substituir nas componentes D11 = D22 = D33 = λ + 2μ; D12 = D13 = D21 = etc. = λ.",
                                    "Verificar com estado de deformação uniaxial para recuperar E."
                                  ],
                                  "verification": "Derivar explicitamente D11, D12 e D22, confirmando simetria.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software simbólico como Mathematica ou papel",
                                    "Tabela de fórmulas de elasticidade"
                                  ],
                                  "tips": "Desenhe a matriz esqueleto 6x6 para visualizar posições das componentes normais.",
                                  "learningObjective": "Derivar as entradas normais da matriz constitutiva usando constantes de Lamé.",
                                  "commonMistakes": [
                                    "Esquecer o termo 2μ nas diagonais principais",
                                    "Usar ν incorretamente na fórmula de λ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar as componentes de cisalhamento da matriz [D]",
                                  "subSteps": [
                                    "Recordar que para cisalhamento puro, τ_xy = G γ_xy, independentemente de outras deformações.",
                                    "Confirmar D44 = D55 = D66 = G = μ = E / (2(1+ν)).",
                                    "Verificar ausência de acoplamento shear-normal em materiais isotrópicos (D14=0, etc.).",
                                    "Expressar G em termos de constantes volumétricas e laminares.",
                                    "Testar com exemplo de cisalhamento simples: deformação γ_xy=0.01, calcular τ_xy."
                                  ],
                                  "verification": "Escrever as 3 componentes de cisalhamento e confirmar independência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Exemplos resolvidos de livros"
                                  ],
                                  "tips": "Lembre-se: γ é a deformação de cisalhamento total, não o tensor ε_xy.",
                                  "learningObjective": "Entender o papel das componentes de cisalhamento na matriz isotrópica.",
                                  "commonMistakes": [
                                    "Atribuir valor errado a G (ex: confundir com E/3)",
                                    "Introduzir acoplamentos shear-normal indevidos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar a matriz completa [D], verificar propriedades e expressar em termos das constantes",
                                  "subSteps": [
                                    "Assemblar a matriz 6x6 completa com todas as entradas derivadas.",
                                    "Verificar propriedades: simetria, positivos definitos (autovalores >0), trace relacionado a K.",
                                    "Substituir λ e μ pelas expressões em E, ν (laminares) e K, G (volumétricas).",
                                    "Calcular numericamente para um material exemplo e comparar com tabelas.",
                                    "Documentar a matriz final em formato pronto para código EF."
                                  ],
                                  "verification": "Produzir a matriz [D] 6x6 explícita e simétrica.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha Excel ou MATLAB para verificação numérica",
                                    "Referência de propriedades de materiais"
                                  ],
                                  "tips": "Copie a matriz em LaTeX ou código para reutilização futura.",
                                  "learningObjective": "Construir e validar a matriz constitutiva isotrópica completa.",
                                  "commonMistakes": [
                                    "Erro de transcrição nas off-diagonais",
                                    "Não verificar simetria final"
                                  ]
                                }
                              ],
                              "practicalExample": "Para alumínio isotrópico com constantes laminares E=70 GPa, ν=0.33 e volumétricas consistentes K=70 GPa, G=26 GPa: Calcule λ ≈ 57.7 GPa, μ=26 GPa; então D11=110.4 GPa, D12=57.7 GPa, D44=26 GPa. Monte [D] e use para calcular σ de ε={0.001,0.001,0,0,0,0}^T.",
                              "finalVerifications": [
                                "Matriz [D] é simétrica com D_ij = D_ji.",
                                "Componentes diagonais normais iguais: D11=D22=D33.",
                                "Componentes de cisalhamento iguais: D44=D55=D66=G.",
                                "Recupera E em teste uniaxial: σ_x / ε_x = E com ε_y=ε_z=-ν ε_x.",
                                "Bulk modulus correto: (D11 + D12 + D13)/3 = K.",
                                "Matriz positiva definida (determinante >0)."
                              ],
                              "assessmentCriteria": [
                                "Correção na derivação de λ e μ a partir de E, ν, K, G.",
                                "Expressões explícitas e exatas para todas as 21 entradas únicas da matriz.",
                                "Verificações numéricas coerentes com propriedades conhecidas do material.",
                                "Explicação clara de hipóteses isotrópicas e notação Voigt.",
                                "Ausência de acoplamentos anisotrópicos indevidos.",
                                "Documentação legível da matriz final."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (inversão de matrizes, autovalores).",
                                "Física: Mecânica continuum (lei de Hooke 3D).",
                                "Computação: Programação de kernels constitutivos em FEM (MATLAB, Fortran).",
                                "Materiais: Determinação experimental de constantes elásticas.",
                                "Química: Influência microestrutural em isotropia."
                              ],
                              "realWorldApplication": "A matriz [D] é usada em softwares de elementos finitos (ANSYS, Abaqus) para simular tensões em estruturas aeronáuticas, automotivas e civis, como análise de fadiga em asas de aviões ou vigas de pontes sob cargas reais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.1.2.3"
                            ]
                          },
                          {
                            "id": "10.1.1.4.1.3.2",
                            "name": "Verificar simetria e propriedades da matriz",
                            "description": "Demonstrar a simetria positiva definida da matriz [D] e calcular seus autovalores para validar estabilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Verificar a simetria da matriz [D]",
                                  "subSteps": [
                                    "Obtenha a matriz constitutiva [D] do contexto do problema (ex: para material isotrópico em elementos finitos).",
                                    "Transpose a matriz [D] para obter [D]^T.",
                                    "Compare elemento por elemento [D] e [D]^T para confirmar se d_ij = d_ji para todos i,j.",
                                    "Registre qualquer assimetria encontrada e investigue possíveis erros de formulação.",
                                    "Conclua se a matriz é simétrica."
                                  ],
                                  "verification": "A matriz [D] é igual à sua transposta [D]^T em todos os elementos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou software como MATLAB/Python (NumPy) para transposição.",
                                  "tips": "Use índices simétricos como d12 e d21 para verificação rápida.",
                                  "learningObjective": "Compreender e aplicar o conceito de simetria em matrizes para propriedades elásticas.",
                                  "commonMistakes": "Confundir transposição com inversa; ignorar elementos fora da diagonal principal."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular autovalores da matriz [D]",
                                  "subSteps": [
                                    "Defina a equação característica det([D] - λI) = 0.",
                                    "Resolva para os autovalores λ1, λ2, ..., λn usando métodos analíticos (para pequenas matrizes) ou numéricos.",
                                    "Use software para matrizes maiores: eig() no MATLAB ou numpy.linalg.eig().",
                                    "Ordene os autovalores em ordem crescente.",
                                    "Confirme que todos λi > 0."
                                  ],
                                  "verification": "Todos os autovalores são reais e positivos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software numérico (MATLAB, Python com NumPy/SciPy), lápis e papel para 2x2.",
                                  "tips": "Para materiais isotrópicos, espere autovalores proporcionais aos módulos elásticos.",
                                  "learningObjective": "Calcular e interpretar autovalores para propriedades espectrais de matrizes.",
                                  "commonMistakes": "Esquecer de subtrair λI; interpretar autovalores complexos como negativos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar estabilidade baseada nas propriedades",
                                  "subSteps": [
                                    "Confirme simetria e positiva definida: garante rigidez positiva e convergência em EF.",
                                    "Discuta implicações: autovalores positivos evitam modos instáveis.",
                                    "Compare com critérios físicos (ex: módulo de Young > 0).",
                                    "Teste sensibilidade alterando parâmetros materiais.",
                                    "Conclua sobre a estabilidade da formulação."
                                  ],
                                  "verification": "Relatório confirma simetria, positiva definida e estabilidade validada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Relatório template, software de EF como ANSYS para validação opcional.",
                                  "tips": "Ligue autovalores mínimos a frequência natural mínima.",
                                  "learningObjective": "Conectar propriedades matriciais à estabilidade numérica em simulações.",
                                  "commonMistakes": "Ignorar contexto físico; assumir estabilidade sem verificação numérica."
                                }
                              ],
                              "practicalExample": "Para um material isotrópico em tensão plana 2D com E=200 GPa, ν=0.3, a matriz [D] é [[1.846, 0.615, 0], [0.615, 1.846, 0], [0, 0, 0.769]] x10^11 Pa. Verifique simetria (d12=d21), menores principais Δ1=1.846e11>0, Δ2=2.666e11>0, autovalores ≈[0.692e11, 2.000e11]>0, confirmando positiva definida e estabilidade.",
                              "finalVerifications": [
                                "[D] = [D]^T confirmada.",
                                "Todos menores principais positivos.",
                                "Todos autovalores reais e positivos.",
                                "Menor autovalor > threshold físico (ex: 1e9 Pa).",
                                "Sem modos zero ou negativos indicando instabilidade.",
                                "Resultados consistentes com propriedades do material."
                              ],
                              "assessmentCriteria": [
                                "Precisão na verificação de simetria (100% match).",
                                "Correção nos cálculos de menores principais e autovalores (erro <1%).",
                                "Interpretação física correta da positiva definida.",
                                "Uso adequado de ferramentas numéricas.",
                                "Relatório claro com evidências e conclusões.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: autovalores e decomposição espectral.",
                                "Física/Mecânica dos Sólidos: relação com constantes elásticas.",
                                "Programação Computacional: implementação em Python/MATLAB para EF.",
                                "Análise Numérica: estabilidade de métodos iterativos."
                              ],
                              "realWorldApplication": "Em simulações de elementos finitos (ex: ANSYS, Abaqus), verificar [D] positiva definida garante convergência do solver, rigidez realista em estruturas como pontes ou aviões, evitando vibrações instáveis ou colapso numérico em análises dinâmicas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.4.1.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.5",
                    "name": "Efeito Termoelástico",
                    "description": "Influência térmica nas deformações e tensões, com expansão térmica.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.5.1",
                        "name": "Expansão Térmica Linear",
                        "description": "Propriedade fundamental dos materiais que descreve o aumento de comprimento devido a uma variação de temperatura, quantificada pelo coeficiente de dilatação térmica α, essencial para entender deformações induzidas por calor.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.1.1",
                            "name": "Definir o coeficiente de dilatação térmica",
                            "description": "Explicar o coeficiente α como a fração de elongação por unidade de variação de temperatura (α = (1/L) dL/dT), com unidades típicas em 1/°C, e citar valores para metais comuns como aço (≈12×10^{-6}/°C).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Dilatação Térmica Linear",
                                  "subSteps": [
                                    "Explique o que é dilatação térmica: o aumento no comprimento de um material devido ao aumento de temperatura.",
                                    "Diferencie dilatação linear (1D), superficial (2D) e volumétrica (3D), focando na linear para sólidos alongados.",
                                    "Discuta o comportamento microscópico: vibração aumentada das moléculas com o calor causa expansão macroscópica.",
                                    "Identifique fatores que influenciam a dilatação: tipo de material, faixa de temperatura e comprimento inicial.",
                                    "Realize uma demonstração simples com uma régua metálica aquecida para observar a expansão."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito o mecanismo microscópico da dilatação e liste 3 fatores influenciadores.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Régua metálica",
                                    "Fonte de calor segura (como água quente)",
                                    "Termômetro",
                                    "Cronômetro"
                                  ],
                                  "tips": "Use analogias como 'moléculas dançando mais rápido com o calor' para fixar o conceito.",
                                  "learningObjective": "Entender o fenômeno físico da dilatação térmica linear em nível conceitual.",
                                  "commonMistakes": [
                                    "Confundir dilatação com contração térmica",
                                    "Ignorar que a expansão é proporcional ao comprimento inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar e Definir a Fórmula do Coeficiente de Dilatação Térmica α",
                                  "subSteps": [
                                    "Comece com a variação de comprimento ΔL = L_final - L_inicial para uma mudança de temperatura ΔT.",
                                    "Introduza a definição aproximada para pequenas ΔT: ΔL ≈ α * L * ΔT, onde α é o coeficiente.",
                                    "Derive a forma diferencial: α = (1/L) * (dL/dT), explicando que é a taxa de elongação relativa por grau.",
                                    "Resolva exercícios simples: dado L=1m, ΔT=10°C, α=12e-6/°C, calcule ΔL.",
                                    "Compare com a forma exata: L(T) = L0 * exp(α ΔT) ≈ L0 (1 + α ΔT) para αΔT <<1."
                                  ],
                                  "verification": "Derive a fórmula α a partir de ΔL/L = f(ΔT) e resolva um problema numérico corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Software de simulação como Python com matplotlib para plotar L vs T"
                                  ],
                                  "tips": "Lembre-se: α é uma constante material para faixas lineares de temperatura; plote gráficos para visualizar.",
                                  "learningObjective": "Dominar a definição matemática precisa de α e sua derivação.",
                                  "commonMistakes": [
                                    "Esquecer o 1/L na definição diferencial",
                                    "Usar unidades erradas como m/°C em vez de 1/°C"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Unidades, Valores Típicos e Medição Experimental",
                                  "subSteps": [
                                    "Confirme unidades de α: [α] = 1/°C ou K^{-1}, tipicamente na ordem de 10^{-6} a 10^{-5}/°C.",
                                    "Memorize valores comuns: aço ≈12×10^{-6}/°C, alumínio ≈23×10^{-6}/°C, cobre ≈17×10^{-6}/°C, vidro ≈9×10^{-6}/°C.",
                                    "Descreva métodos experimentais: dilatômetro (barra em forno com micrômetro), interferômetro laser para precisão.",
                                    "Compare valores para metais vs não-metais e discuta dependência com temperatura (nem sempre constante).",
                                    "Crie uma tabela comparativa com 5 materiais e seus α."
                                  ],
                                  "verification": "Liste corretamente α para 4 metais comuns e explique como medi-lo experimentalmente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de valores de α (impressa ou online)",
                                    "Planilha Excel ou Google Sheets para tabela"
                                  ],
                                  "tips": "Use notação científica consistentemente (ex: 12e-6) para evitar erros de escala.",
                                  "learningObjective": "Conhecer unidades padrão, valores típicos e métodos de determinação de α.",
                                  "commonMistakes": [
                                    "Confundir α linear com volumétrico (α_v ≈ 3α_l)",
                                    "Ignorar variação de α com temperatura"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o Conceito em Cálculos e Análises Práticas",
                                  "subSteps": [
                                    "Calcule a elongação de uma ponte de aço de 100m com ΔT=50°C.",
                                    "Analise efeitos em juntas de dilatação: espaçamento necessário para evitar buckling.",
                                    "Incorpore em modelo simples de elementos finitos: nó com deslocamento térmico u_thermal = α * ΔT * L.",
                                    "Simule numericamente com código básico ou software como ANSYS Student.",
                                    "Discuta limitações: plásticos, anisotropia em compósitos."
                                  ],
                                  "verification": "Resolva 2 problemas aplicados corretamente, incluindo um com elementos finitos básicos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Software gratuito como FreeCAD ou Python (NumPy)"
                                  ],
                                  "tips": "Sempre verifique unidades: ΔL em mm se L em m e α em /°C.",
                                  "learningObjective": "Aplicar α em cenários de engenharia reais e iniciais de EF.",
                                  "commonMistakes": [
                                    "Não converter unidades de temperatura (°C vs K)",
                                    "Esquecer sinal em resfriamento (contração)"
                                  ]
                                }
                              ],
                              "practicalExample": "Calcule a variação de comprimento de uma viga de aço de 50m em uma ponte quando a temperatura sobe de 20°C para 70°C (ΔT=50°C, α_aço=12×10^{-6}/°C). ΔL = α * L * ΔT = 12e-6 * 50 * 50 = 0.03m = 30mm. Isso justifica juntas de dilatação de pelo menos 30mm.",
                              "finalVerifications": [
                                "Deriva corretamente α = (1/L) dL/dT.",
                                "Cita α para aço, alumínio e cobre com precisão.",
                                "Calcula ΔL corretamente em 3 exemplos variados.",
                                "Explica método experimental com dilatômetro.",
                                "Identifica limitações da linearidade de α.",
                                "Aplica em contexto de elementos finitos (deslocamento térmico)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e derivação da fórmula (30%)",
                                "Correção de valores numéricos e unidades (25%)",
                                "Profundidade conceitual e microscópica (20%)",
                                "Habilidade em cálculos aplicados (15%)",
                                "Conexão com experimentação e EF (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física Geral: Termodinâmica e expansão de gases/sólidos.",
                                "Ciência dos Materiais: Propriedades térmicas e anisotropia.",
                                "Matemática: Cálculo diferencial e aproximações lineares.",
                                "Engenharia Civil: Dimensionamento de estruturas contra variações térmicas."
                              ],
                              "realWorldApplication": "Em engenharia mecânica, o coeficiente α é essencial para projetar trilhos de trem (evitar empenamento no verão), tubulações em usinas (juntas de expansão), satélites (controle térmico no vácuo) e simulações de elementos finitos para prever tensões termoelásticas em componentes aeroespaciais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.2",
                            "name": "Calcular deformação térmica uniaxial",
                            "description": "Aplicar a fórmula ε_t = α ΔT para determinar a deformação térmica em uma barra submetida a variação uniforme de temperatura ΔT, considerando casos livres de restrições.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de deformação térmica uniaxial",
                                  "subSteps": [
                                    "Defina deformação térmica como a mudança relativa no comprimento devido à variação de temperatura.",
                                    "Explique o coeficiente de expansão térmica linear α como a constante que relaciona ΔT à deformação ε_t.",
                                    "Descreva uma barra uniaxial livre de restrições, onde não há forças externas impedindo a expansão.",
                                    "Diferencie deformação térmica de deformação mecânica, destacando que ε_t é puramente devido a ΔT.",
                                    "Revise unidades padrão: ε_t é adimensional, α em 1/°C ou 1/K, ΔT em °C ou K."
                                  ],
                                  "verification": "Resuma em suas palavras os conceitos e forneça um diagrama simples de uma barra expandindo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de Engenharia Mecânica",
                                    "Tabela de coeficientes α para materiais comuns",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": "Use analogias como expansão de trilhos de trem para visualizar o conceito.",
                                  "learningObjective": "Entender a base física da fórmula ε_t = α ΔT em barras livres.",
                                  "commonMistakes": [
                                    "Confundir α com coeficiente de volume",
                                    "Ignorar que ΔT deve ser em Kelvin para consistência absoluta",
                                    "Assumir restrições quando o problema especifica 'livre'"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e coletar parâmetros do problema",
                                  "subSteps": [
                                    "Leia o problema para extrair o material da barra e obter α da tabela (ex: aço α ≈ 12 × 10^{-6}/°C).",
                                    "Determine ΔT como T_final - T_inicial, garantindo unidades consistentes.",
                                    "Confirme que a barra é uniaxial e livre de restrições (sem fixações).",
                                    "Anote valores numéricos com precisão significativa e unidades.",
                                    "Calcule comprimento inicial L_0 se necessário para deformação absoluta δ_t = ε_t L_0."
                                  ],
                                  "verification": "Crie uma tabela com α, ΔT e unidades, e justifique cada valor.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela de coeficientes de expansão térmica",
                                    "Calculadora",
                                    "Problema exemplo impresso"
                                  ],
                                  "tips": "Sempre consulte tabelas confiáveis para α, pois varia com material e temperatura.",
                                  "learningObjective": "Selecionar corretamente os inputs da fórmula para um problema dado.",
                                  "commonMistakes": [
                                    "Usar α errado para o material",
                                    "Esquecer sinal de ΔT (expansão positiva para aquecimento)",
                                    "Misturar °C e K sem conversão"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a fórmula e realizar o cálculo",
                                  "subSteps": [
                                    "Escreva a fórmula ε_t = α ΔT explicitamente com valores substituídos.",
                                    "Multiplique α por ΔT, prestando atenção à notação científica (ex: 12e-6 * 50).",
                                    "Calcule o resultado com 3-4 casas decimais e expresse em notação percentual ou científica se apropriado.",
                                    "Se fornecido L_0, calcule δ_t = ε_t L_0 para deformação absoluta.",
                                    "Registre o resultado final com unidades e interpretação qualitativa (ex: expansão de 0.06%)."
                                  ],
                                  "verification": "Mostre todos os passos algébricos e resultado numérico exato.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Folha de cálculo",
                                    "Fórmula anotada"
                                  ],
                                  "tips": "Verifique a ordem de magnitude: ε_t tipicamente 10^{-4} a 10^{-3} para ΔT realistas.",
                                  "learningObjective": "Executar o cálculo preciso da fórmula ε_t = α ΔT.",
                                  "commonMistakes": [
                                    "Erro aritmético em multiplicação",
                                    "Esquecer expoente negativo em α",
                                    "Não expressar ε_t como decimal (ex: 6e-4 ao invés de 0.0006)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar resultados e interpretar implicações",
                                  "subSteps": [
                                    "Recalcule ε_t com valores arredondados para checar consistência.",
                                    "Compare com valores típicos: para aço e ΔT=100°C, ε_t ≈ 0.0012.",
                                    "Discuta o que acontece se houver restrições (tensões surgem).",
                                    "Avalie sensibilidade: como ε_t muda se α ou ΔT variam.",
                                    "Documente o resultado em um relatório curto com gráfico de ε_t vs ΔT."
                                  ],
                                  "verification": "Forneça pelo menos duas verificações independentes e uma interpretação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Gráficos ou software como Excel para plotagem",
                                    "Calculadora"
                                  ],
                                  "tips": "Use dimensional analysis: [ε_t] = [α][ΔT] = (1/°C)(°C) = adimensional.",
                                  "learningObjective": "Validar e contextualizar o cálculo no efeito termoelástico.",
                                  "commonMistakes": [
                                    "Ignorar verificação cruzada",
                                    "Não considerar faixa de validade de α (linearidade)",
                                    "Confundir deformação relativa com absoluta"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma barra de alumínio de 2 m de comprimento com α = 23 × 10^{-6}/°C aquecida de 20°C para 80°C (ΔT = 60°C), calcule ε_t e δ_t. Resposta: ε_t = 23e-6 * 60 = 1.38 × 10^{-3} (0.138%), δ_t = 2.76 mm.",
                              "finalVerifications": [
                                "Pode derivar ε_t = ΔL/L_0 a partir de definição física?",
                                "Calcula corretamente ε_t para ΔT=100°C em aço (α=12e-6)?",
                                "Identifica unidades corretas em 3 problemas variados?",
                                "Explica diferença entre expansão livre e restrita?",
                                "Aplica fórmula em exemplo prático sem erros aritméticos?",
                                "Interpreta resultado como expansão/contração física?"
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erro < 1% no cálculo de ε_t.",
                                "Correta identificação de α e ΔT com fontes justificadas.",
                                "Uso consistente de unidades e notação científica.",
                                "Verificações independentes incluídas em todos os passos.",
                                "Interpretação qualitativa e quantitativa do resultado.",
                                "Documentação clara com passos lógicos e diagramas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Lei de expansão térmica e termodinâmica.",
                                "Ciência dos Materiais: Variação de α com composição e microestrutura.",
                                "Matemática: Álgebra linear e análise dimensional.",
                                "Química: Influência de ligas na expansão térmica."
                              ],
                              "realWorldApplication": "Projeto de juntas de dilatação em pontes e edifícios para evitar rachaduras devido à expansão térmica diária; fabricação de trilhos de trem com folgas; compensação térmica em instrumentos de precisão como relógios atômicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.3",
                            "name": "Analisar expansão em múltiplas dimensões",
                            "description": "Estender o conceito para deformações volumétricas ε_v = 3α ΔT em sólidos isotrópicos e discutir implicações em estruturas confinadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Expansão Térmica Linear e Introduzir Conceito Multidimensional",
                                  "subSteps": [
                                    "Relembre a definição de coeficiente de expansão térmica linear α e a deformação ε = α ΔT.",
                                    "Visualize a expansão em uma direção usando um diagrama de uma barra unidimensional.",
                                    "Estenda o conceito para três dimensões independentes em um cuboide.",
                                    "Discuta a independência das deformações em x, y e z para materiais isotrópicos.",
                                    "Calcule deformações lineares em cada eixo para um ΔT dado."
                                  ],
                                  "verification": "Desenhe um diagrama antes/depois da expansão e liste deformações ε_x, ε_y, ε_z iguais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel, lápis, calculadora, tabela de valores de α para metais comuns.",
                                  "tips": "Use um material familiar como alumínio (α ≈ 23 × 10^{-6}/°C) para exemplos numéricos.",
                                  "learningObjective": "Compreender a transição da expansão linear para multidimensional.",
                                  "commonMistakes": "Confundir α volumétrico com linear; assumir anisotropia em isotrópicos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Deformação Volumétrica ε_v = 3α ΔT",
                                  "subSteps": [
                                    "Defina deformação volumétrica ε_v = (V_final - V_inicial)/V_inicial.",
                                    "Para um cuboide, expresse V_final = L(1+ε_x) * W(1+ε_y) * H(1+ε_z).",
                                    "Aproxime para pequenas deformações: ε_v ≈ ε_x + ε_y + ε_z.",
                                    "Em isotrópicos, ε_x = ε_y = ε_z = α ΔT, logo ε_v = 3α ΔT.",
                                    "Verifique com coeficiente volumétrico β = 3α."
                                  ],
                                  "verification": "Derive a fórmula passo a passo e compute ε_v para ΔT=50°C em aço (α=12×10^{-6}/°C).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Folha de cálculo ou software como Excel, livro de referência em mecânica dos sólidos.",
                                  "tips": "Aproxime ln(1+ε) ≈ ε apenas para ε <<1; valide com volumes exatos.",
                                  "learningObjective": "Dominar a derivação matemática da deformação volumétrica.",
                                  "commonMistakes": "Esquecer a aproximação linear; usar β diretamente sem derivar."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Caracterizar Sólidos Isotrópicos e Suas Propriedades Térmicas",
                                  "subSteps": [
                                    "Defina isotropia: propriedades independentes de direção.",
                                    "Liste exemplos: metais policristalinos como alumínio, cobre.",
                                    "Discuta medição de α via dilatômetro e variação com temperatura.",
                                    "Compare com anisotrópicos (ex: madeira) onde α_x ≠ α_y.",
                                    "Calcule variação volumétrica para um sólido isotrópico confinado termicamente."
                                  ],
                                  "verification": "Classifique 5 materiais como isotrópicos ou não e justifique com valores de α.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Tabelas de propriedades materiais online, software de simulação como ANSYS Student (opcional).",
                                  "tips": "Consulte bases de dados como MatWeb para α precisa em faixas de T.",
                                  "learningObjective": "Identificar e aplicar propriedades isotrópicas em expansão térmica.",
                                  "commonMistakes": "Assumir todos os sólidos como isotrópicos; ignorar efeitos de mudança de fase."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Implicações em Estruturas Confinadas",
                                  "subSteps": [
                                    "Defina confinamento: restrição de deformação por suportes ou adjacências.",
                                    "Calcule tensões térmicas σ = E ε_restringida, onde ε_restringida ≠ α ΔT.",
                                    "Para confinamento total: ε=0, σ = -E α ΔT (compressão em aquecimento).",
                                    "Discuta falhas: trincas em soldas, flambagem em trilhos.",
                                    "Simule numericamente com modelo 1D confinado."
                                  ],
                                  "verification": "Resolva problema: barra de cobre fixa nas extremidades, ΔT=100°C; calcule σ_max.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Calculadora científica, FEA básico (ex: FreeCAD), exemplos de casos reais.",
                                  "tips": "Use equação de compatibilidade de deformações em assemblies.",
                                  "learningObjective": "Prever tensões e falhas em cenários confinados.",
                                  "commonMistakes": "Negligenciar módulo de elasticidade E; confundir sinal de tensão (expansão gera compressão)."
                                }
                              ],
                              "practicalExample": "Considere uma placa de alumínio (α=23×10^{-6}/°C, E=70 GPa) soldada entre duas placas de aço rígidas, aquecida em 80°C. Calcule ε_v livre = 3*23e-6*80 ≈ 0.00552 (0.552%). Com confinamento total, σ = E α ΔT = 70e9 * 23e-6 *80 ≈ 129 MPa (tensão compressiva crítica). Simule em FEA para deformação parcial.",
                              "finalVerifications": [
                                "Derivação correta de ε_v = 3α ΔT com aproximação válida.",
                                "Cálculo preciso de tensões em estrutura confinada com valores numéricos.",
                                "Identificação de 3 exemplos de sólidos isotrópicos com α citados.",
                                "Diagrama qualitativo de expansão livre vs. confinada.",
                                "Discussão de implicações em falha estrutural.",
                                "Verificação numérica com ΔT variado (± erros <5%)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (100% dos passos corretos).",
                                "Compreensão conceitual de isotropia vs. confinamento (explicação clara).",
                                "Aplicação prática com cálculos numéricos realistas.",
                                "Análise de erros comuns e mitigação.",
                                "Conexão com elementos finitos (malha para termoelasticidade).",
                                "Criatividade em exemplos reais e verificações."
                              ],
                              "crossCurricularConnections": [
                                "Física: Termodinâmica e dilatação (lei de Charles adaptada).",
                                "Ciência dos Materiais: Propriedades microestruturais afetando α.",
                                "Matemática: Tensores de deformação e aproximações lineares.",
                                "Engenharia Civil: Análise térmica em pontes e barragens."
                              ],
                              "realWorldApplication": "Em turbinas a gás, lâminas de níquel superligas confinadas geram tensões térmicas durante partida; modelagem FEA prevê fadiga. Em eletrônica, chips de silício em packages plásticos evitam delaminação via mismatch α controlado."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.2",
                        "name": "Deformações Termoelásticas",
                        "description": "Inclusão do termo térmico nas deformações totais, onde a deformação mecânica é superposta à deformação térmica, afetando o comportamento elástico do material.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.2.1",
                            "name": "Formular deformação total",
                            "description": "Escrever ε_total = ε_mecânica + ε_térmica, destacando que apenas ε_mecânica contribui para tensões em formulações elásticas lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender deformação mecânica e térmica",
                                  "subSteps": [
                                    "Definir deformação mecânica (ε_mecânica) como resultado de tensões aplicadas, via lei de Hooke.",
                                    "Definir deformação térmica (ε_térmica) como α * ΔT, onde α é coeficiente de dilatação térmica e ΔT variação de temperatura.",
                                    "Explicar origens: mecânica por forças externas, térmica por expansão molecular.",
                                    "Diferenciar naturezas: mecânica reversível elástica, térmica geralmente livre se sem restrições.",
                                    "Representar ambas como tensores de deformação em 3D."
                                  ],
                                  "verification": "Explicar oralmente ou por escrito as diferenças entre ε_mecânica e ε_térmica com exemplos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre termoelasticidade",
                                    "Livro de Elementos Finitos (ex: Bathe)",
                                    "Calculadora"
                                  ],
                                  "tips": "Use analogias: ε_mecânica como esticar uma mola, ε_térmica como aquecer um metal solto.",
                                  "learningObjective": "Diferenciar conceitualmente as componentes de deformação.",
                                  "commonMistakes": "Confundir ε_térmica com geração de tensão (ela é livre sem restrições)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a equação da deformação total",
                                  "subSteps": [
                                    "Escrever ε_total = ε_mecânica + ε_térmica em notação tensorial (ε_ij_total = ε_ij_mec + ε_ij_term).",
                                    "Justificar additividade pela superposição linear em pequenas deformações.",
                                    "Derivar para caso unidimensional: ε_total = σ/E + α ΔT.",
                                    "Generalizar para 3D considerando isotropia térmica.",
                                    "Verificar dimensionalidade: ambas adimensionais."
                                  ],
                                  "verification": "Escrever a fórmula corretamente em 1D e 3D, justificando additividade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Software simbólico como Mathematica ou papel para derivação"
                                  ],
                                  "tips": "Sempre especifique o referencial: deformação total é observada, mecânica é 'residual'.",
                                  "learningObjective": "Derivar e escrever ε_total com precisão.",
                                  "commonMistakes": "Esquecer a dependência de ΔT em ε_térmica ou usar notação vetorial incorreta."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Destacar contribuição exclusiva da ε_mecânica para tensões",
                                  "subSteps": [
                                    "Recordar constituição elástica linear: σ = C : (ε_total - ε_térmica) = C : ε_mecânica.",
                                    "Explicar que ε_térmica é 'subtraída' na formulação para isolar parte mecânica.",
                                    "Discutir em Elementos Finitos: termo de carga térmica equivalente -C ε_térmica.",
                                    "Analisar caso sem restrições: σ=0, ε_total=ε_térmica.",
                                    "Comparar com caso restrito: σ ≠0 devido a ε_mecânica."
                                  ],
                                  "verification": "Derivar σ em termos de ε_mecânica e explicar por que ε_térmica não gera tensão diretamente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Software FEA como ANSYS (modo demo)",
                                    "Artigos sobre termoelasticidade"
                                  ],
                                  "tips": "Pense em ε_térmica como 'pré-deformação' que altera a rigidez efetiva.",
                                  "learningObjective": "Compreender implicações na relação tensão-deformação.",
                                  "commonMistakes": "Acreditar que ε_térmica contribui diretamente para σ em materiais lineares."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a formulação em exemplo prático",
                                  "subSteps": [
                                    "Escolher exemplo: barra fixa aquecida ΔT=100°C, α=12e-6/°C, E=200GPa.",
                                    "Calcular ε_térmica = α ΔT = 0.0012.",
                                    "Impor ε_total=0 (fixa), então ε_mecânica = -ε_térmica.",
                                    "Calcular σ = E ε_mecânica = -240 MPa.",
                                    "Verificar com gráfico de deformação vs. tensão."
                                  ],
                                  "verification": "Resolver numericamente o exemplo e plotar resultados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Excel ou Python para cálculos",
                                    "Gráficos impressos"
                                  ],
                                  "tips": "Sempre verifique unidades: α em /°C, ΔT em °C, ε adimensional.",
                                  "learningObjective": "Aplicar fórmula em cenário realista.",
                                  "commonMistakes": "Ignorar sinal negativo em compressão térmica."
                                }
                              ],
                              "practicalExample": "Em uma barra de aço presa entre paredes, aquecida de 20°C a 120°C (ΔT=100°C, α=12×10^{-6}/°C, E=200 GPa): ε_térmica=0.0012, ε_total=0, logo ε_mecânica=-0.0012 e σ=-240 MPa (compressão).",
                              "finalVerifications": [
                                "Escrever corretamente ε_total = ε_mecânica + ε_térmica.",
                                "Explicar que σ = C : ε_mecânica em elástica linear.",
                                "Resolver exemplo numérico com valores precisos.",
                                "Identificar ε_mecânica em caso de restrição térmica.",
                                "Diferenciar deformações livres e totais.",
                                "Representar em notação tensorial básica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na equação de deformação total (100% corretude).",
                                "Compreensão conceitual da não-contribuição de ε_térmica para σ.",
                                "Correção em cálculos numéricos (erro <1%).",
                                "Justificativa clara da additividade linear.",
                                "Aplicação correta em exemplo prático.",
                                "Uso adequado de notação e unidades."
                              ],
                              "crossCurricularConnections": [
                                "Física: Termodinâmica e dilatação térmica.",
                                "Matemática: Tensores e álgebra linear para deformações.",
                                "Engenharia de Materiais: Propriedades termo-mecânicas.",
                                "Computação: Implementação em solvers FEA."
                              ],
                              "realWorldApplication": "Na análise de elementos finitos de turbinas a gás ou soldas, onde gradientes térmicos induzem tensões residuais; formulação usada em softwares como Abaqus para prever falhas em componentes aeroespaciais sob ciclos térmicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.2.2",
                            "name": "Interpretar gradientes térmicos",
                            "description": "Analisar como variações não uniformes de temperatura geram deformações diferenciais, levando a curvaturas ou distorções em elementos estruturais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de gradiente térmico",
                                  "subSteps": [
                                    "Definir gradiente térmico como a variação espacial da temperatura (∇T = dT/dx i + dT/dy j + dT/dz k).",
                                    "Diferenciar gradiente uniforme (variação linear) de não uniforme (variações complexas).",
                                    "Visualizar gradientes usando diagramas de linhas de temperatura ou software de simulação.",
                                    "Explicar unidades (ex: °C/m) e direção (vetor aponta para aumento de temperatura).",
                                    "Discutir fontes comuns de gradientes em estruturas (aquecimento localizado, resfriamento convectivo)."
                                  ],
                                  "verification": "Desenhar e rotular um diagrama simples de gradiente térmico em uma barra 1D e explicar verbalmente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de termodinâmica estrutural",
                                    "Papel e lápis para diagramas",
                                    "Software gratuito como ParaView para visualização de campos"
                                  ],
                                  "tips": "Use analogias cotidianas, como o calor de uma chama em uma chapa de metal.",
                                  "learningObjective": "Dominar a definição matemática e física de gradiente térmico.",
                                  "commonMistakes": [
                                    "Confundir gradiente com diferença de temperatura absoluta",
                                    "Ignorar a componente vetorial/direcional",
                                    "Não considerar dimensões espaciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Relacionar gradiente térmico a deformações térmicas diferenciais",
                                  "subSteps": [
                                    "Recordar a equação de deformação térmica: ε_t = α ΔT, onde α é o coeficiente de expansão térmica.",
                                    "Explicar deformações diferenciais: Δε = α ∇T · ds (variação ao longo de uma distância).",
                                    "Analisar como gradientes causam tensões internas devido a restrições geométricas.",
                                    "Derivar qualitativamente curvatura em vigas: κ = α ∇T / h (h=espessura).",
                                    "Simular numericamente um caso 1D simples com planilha ou código básico."
                                  ],
                                  "verification": "Calcular deformação diferencial em um exemplo dado e comparar com resultado esperado.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora ou Excel para cálculos",
                                    "Notas de equações termoelásticas",
                                    "Vídeos tutoriais sobre expansão térmica"
                                  ],
                                  "tips": "Comece com casos 1D para simplificar antes de 2D/3D.",
                                  "learningObjective": "Conectar matematicamente gradientes térmicos a deformações não uniformes.",
                                  "commonMistakes": [
                                    "Usar ΔT total em vez de gradiente local",
                                    "Esquecer o papel do coeficiente α",
                                    "Negligenciar efeitos de restrição"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar efeitos de curvaturas e distorções em elementos estruturais",
                                  "subSteps": [
                                    "Identificar curvatura em placas/barras devido a ∇T perpendicular à superfície.",
                                    "Descrever distorções em 3D: torções, empenamentos e cisalhamentos.",
                                    "Usar método dos elementos finitos básico: discretizar elemento e aplicar ∇T nodal.",
                                    "Interpretar resultados: mapas de deformação e tensão termoelástica.",
                                    "Comparar com casos isotérmicos para isolar efeito térmico."
                                  ],
                                  "verification": "Produzir um diagrama de deformação esperado para uma placa com ∇T linear.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software FEA introdutório (ex: FreeCAD ou ANSYS Student)",
                                    "Modelos impressos de elementos estruturais",
                                    "Tutoriais de FEA térmico"
                                  ],
                                  "tips": "Foque em simetrias para reduzir complexidade computacional.",
                                  "learningObjective": "Interpretar visual e quantitativamente distorções causadas por gradientes.",
                                  "commonMistakes": [
                                    "Confundir tensão térmica com mecânica",
                                    "Ignorar condições de contorno",
                                    "Superestimar deformações lineares em grandes ∇T"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e validar gradientes térmicos em simulações",
                                  "subSteps": [
                                    "Executar simulação FEA de um elemento com ∇T imposto.",
                                    "Extrair e plotar campos de ∇T, ε_t e curvatura.",
                                    "Validar contra soluções analíticas ou experimentais.",
                                    "Discutir mitigação: materiais com baixo α ou designs simétricos.",
                                    "Documentar interpretação em relatório curto."
                                  ],
                                  "verification": "Apresentar simulação com interpretação correta de pelo menos 80% das deformações previstas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Licença trial de software FEA",
                                    "Dados experimentais de referência",
                                    "Templates de relatório"
                                  ],
                                  "tips": "Use malhas finas perto de regiões de alto ∇T para precisão.",
                                  "learningObjective": "Aplicar interpretação prática em contexto de elementos finitos.",
                                  "commonMistakes": [
                                    "Má configuração de condições térmicas",
                                    "Interpretação errada de escalas",
                                    "Omitir validação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma placa de aço de 1m x 1m x 0.01m aquecida a 200°C em uma face e mantida a 20°C na oposta, o gradiente térmico ∇T ≈ 18°C/mm causa curvatura κ ≈ 0.0018 m⁻¹, levando a empenamento central de 0.9mm, simulável em FEA.",
                              "finalVerifications": [
                                "Desenhar diagrama vetorial de ∇T e deformações associadas.",
                                "Calcular corretamente deformação diferencial para ∇T dado.",
                                "Interpretar mapa de contorno de FEA mostrando curvatura.",
                                "Explicar qualitativamente mitigação de distorções.",
                                "Comparar simulação com solução analítica 1D.",
                                "Identificar erros comuns em análises térmicas."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual na definição de ∇T e ε_t (30%)",
                                "Correção matemática em cálculos diferenciais (25%)",
                                "Qualidade da interpretação de resultados FEA (20%)",
                                "Uso adequado de visualizações e diagramas (15%)",
                                "Clareza na discussão de aplicações e erros (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Termodinâmica e transferência de calor",
                                "Matemática: Cálculo vetorial e análise de gradientes",
                                "Química dos Materiais: Coeficientes de expansão térmica",
                                "Engenharia Civil: Análise de estruturas sob carga térmica",
                                "Computação: Programação de simulações numéricas em FEA"
                              ],
                              "realWorldApplication": "Nos discos de freio de automóveis, gradientes térmicos durante frenagens intensas causam deformações diferenciais e empenamento, levando a vibrações; análise via FEA permite designs ventilados para minimizar distorções."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.2.3",
                            "name": "Relacionar com tensão mecânica",
                            "description": "Derivar σ = E (ε_total - α ΔT), mostrando como a expansão térmica induz tensões autoequilibrantes em peças restringidas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Expansão Térmica",
                                  "subSteps": [
                                    "Defina coeficiente de expansão térmica linear α e sua unidade (1/°C).",
                                    "Escreva a fórmula básica de deformação térmica: ε_thermal = α ΔT.",
                                    "Discuta o que acontece em uma peça livre: deformação livre sem tensão.",
                                    "Explique o cenário de restrição: quando a peça não pode se expandir livremente.",
                                    "Calcule um exemplo numérico simples: α = 12e-6 /°C, ΔT = 100°C, ε_thermal = ?"
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e resolva o exemplo numérico corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Tabela de coeficientes α para materiais comuns"
                                  ],
                                  "tips": "Use unidades consistentes (SI) para evitar erros em cálculos.",
                                  "learningObjective": "Compreender a deformação térmica livre e seu papel em cenários restringidos.",
                                  "commonMistakes": "Confundir α com coeficiente volumétrico ou ignorar sinal de ΔT."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Deformação Total em Peças Restringidas",
                                  "subSteps": [
                                    "Defina ε_total como a deformação total observada ou imposta na peça.",
                                    "Em peças fixas (ex: barra engastada), ε_total = 0 para restrição total.",
                                    "Discuta deformação mecânica ε_mecânica como componente elástica.",
                                    "Esboce um diagrama de uma barra fixada nas extremidades aquecida.",
                                    "Relacione: ε_total = ε_mecânica + ε_thermal."
                                  ],
                                  "verification": "Desenhe o diagrama e escreva a equação de decomposição corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel para esboços",
                                    "Calculadora"
                                  ],
                                  "tips": "Visualize a restrição como 'impedir movimento', gerando forças internas.",
                                  "learningObjective": "Decompor deformação total em componentes térmica e mecânica.",
                                  "commonMistakes": "Inverter a relação: ε_total ≠ ε_thermal em restrições."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Lei de Hooke para Deformação Mecânica",
                                  "subSteps": [
                                    "Lembre a lei de Hooke uniaxial: σ = E ε_mecânica, onde E é módulo de Young.",
                                    "Substitua ε_mecânica = ε_total - ε_thermal na lei de Hooke.",
                                    "Derive a fórmula alvo: σ = E (ε_total - α ΔT).",
                                    "Para restrição total (ε_total = 0): σ = -E α ΔT (compressão para ΔT > 0).",
                                    "Verifique dimensionalmente: [σ] = Pa, consistente."
                                  ],
                                  "verification": "Escreva a derivação passo a passo em papel, chegando à fórmula final.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Folha de papel",
                                    "Tabela de E para materiais (ex: aço E=200 GPa)"
                                  ],
                                  "tips": "Mantenha sinais corretos: expansão térmica positiva gera compressão.",
                                  "learningObjective": "Derivar matematicamente a relação tensão-deformação termoelástica.",
                                  "commonMistakes": "Esquecer o sinal negativo em restrição total ou confundir ε_thermal com ε_mecânica."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Tensões Autoequilibrantes",
                                  "subSteps": [
                                    "Explique autoequilíbrio: tensões internas se equilibram sem forças externas líquidas.",
                                    "Em uma barra uniforme restringida, tensão constante σ ao longo do comprimento.",
                                    "Calcule equilíbrio de forças: ∫σ dA = 0 para peça livre, mas interna em restringida.",
                                    "Discuta gradientes de temperatura: tensões variam, mas autoequilibram localmente.",
                                    "Simule numericamente com valores: E=200 GPa, α=12e-6, ΔT=50°C, σ=?"
                                  ],
                                  "verification": "Calcule σ para restrição total e explique por que é autoequilibrante.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Software simples como Excel para cálculo"
                                  ],
                                  "tips": "Pense em equilíbrio estático: soma de forças zero nas seções.",
                                  "learningObjective": "Compreender como tensões térmicas se autoequilibram em peças restringidas.",
                                  "commonMistakes": "Assumir tensão zero em autoequilíbrio; não, deformação é zero."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar com Exemplo Prático e Generalizações",
                                  "subSteps": [
                                    "Aplique a fórmula em um caso: barra de aço fixa, ΔT=100°C.",
                                    "Discuta generalizações para 3D: ε_thermal = α ΔT I (tensor identidade).",
                                    "Relacione com EF: deformação térmica como 'carga' inicial.",
                                    "Identifique limitações: elasticidade linear, ΔT pequeno.",
                                    "Resuma a derivação completa em uma equação anotada."
                                  ],
                                  "verification": "Resolva o exemplo e anote limitações corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Excel ou papel para cálculos numéricos"
                                  ],
                                  "tips": "Sempre verifique unidades: GPa * strain = MPa ou Pa.",
                                  "learningObjective": "Aplicar e validar a fórmula em contextos reais e EF.",
                                  "commonMistakes": "Ignorar efeitos plásticos em ΔT altos."
                                }
                              ],
                              "practicalExample": "Considere uma barra de aço (E=200 GPa, α=12×10^{-6}/°C) de 1m fixada nas duas pontas, aquecida uniformemente em ΔT=100°C. Como ε_total=0, ε_thermal=0.0012, então ε_mecânica=-0.0012, σ=-240 MPa (compressão). As tensões comprimem a barra, equilibrando-se internamente sem expansão macroscópica.",
                              "finalVerifications": [
                                "Derivar corretamente σ = E (ε_total - α ΔT) passo a passo.",
                                "Calcular tensão para restrição total com valores numéricos precisos.",
                                "Explicar decomposição ε_total = ε_mecânica + α ΔT verbalmente.",
                                "Desenhar diagrama de barra restringida com setas de forças internas.",
                                "Identificar sinal da tensão para aquecimento/resfriamento.",
                                "Discutir autoequilíbrio sem forças externas líquidas."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (100% correto).",
                                "Compreensão conceitual de deformações (térmica vs. mecânica).",
                                "Correção em cálculos numéricos (erro <1%).",
                                "Clareza em diagramas e explicações.",
                                "Identificação de limitações e generalizações.",
                                "Aplicação correta em exemplo prático."
                              ],
                              "crossCurricularConnections": [
                                "Física: Termodinâmica e lei de Hooke.",
                                "Matemática: Álgebra linear para tensores de deformação.",
                                "Ciência dos Materiais: Propriedades térmicas e mecânicas.",
                                "Engenharia Civil: Análise de estruturas térmicas em pontes."
                              ],
                              "realWorldApplication": "Em trilhos de trem, aquecimento diurno gera compressão autoequilibrante, prevenindo flambagem; em chips de silício, mismatches térmicos induzem tensões em soldas; pontes expandem com restrições em juntas, calculadas via EF para evitar falhas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.3",
                        "name": "Equações Constitutivas Termoelásticas",
                        "description": "Modificação das relações constitutivas lineares elásticas para incorporar o efeito térmico, fundamental para a formulação do Método dos Elementos Finitos (MEF).",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.3.1",
                            "name": "Escrever a lei de Hooke termoelástica",
                            "description": "Formular {σ} = [D] ({ε} - {ε_t}), onde {ε_t} = α ΔT {I} para isotrópicos, com [D] a matriz de rigidez elástica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Lei de Hooke Linear Elástica Clássica",
                                  "subSteps": [
                                    "Lembre-se da relação constitutiva em forma matricial: {σ} = [D] {ε}, onde {σ} é o vetor de tensões e {ε} o vetor de deformações.",
                                    "Identifique os componentes: [D] é a matriz de rigidez elástica, dependente das propriedades do material (E, ν para isotrópicos).",
                                    "Escreva explicitamente para um material isotrópico em 3D, destacando os termos normais e de cisalhamento.",
                                    "Verifique a dimensionalidade: vetores 6x1 e matriz 6x6.",
                                    "Discuta a linearidade e pequenas deformações assumidas."
                                  ],
                                  "verification": "Escrever corretamente a equação {σ} = [D] {ε} com notação vetorial e explicar cada símbolo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre mecânica dos sólidos",
                                    "Livro de referência em elasticidade (ex: Timoshenko)",
                                    "Calculadora simbólica ou papel e caneta"
                                  ],
                                  "tips": "Use sempre notação consistente com colchetes para matrizes e chaves para vetores.",
                                  "learningObjective": "Compreender a relação tensão-deformação elástica sem efeitos térmicos.",
                                  "commonMistakes": "Confundir tensão (σ) com deformação (ε); ignorar a forma matricial em 3D."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Conceito de Deformação Térmica",
                                  "subSteps": [
                                    "Explique a dilatação térmica linear: ε_t = α ΔT, onde α é o coeficiente de dilatação térmica.",
                                    "Estenda para 3D: em materiais isotrópicos, a deformação térmica é {ε_t} = α ΔT {I}, com {I} a matriz identidade.",
                                    "Discuta a origem física: expansão molecular devido ao aumento de temperatura.",
                                    "Diferencie deformação mecânica (devido a cargas) da térmica (devido a ΔT).",
                                    "Mencione que ε_t é uma deformação livre, sem tensões associadas se livre para expandir."
                                  ],
                                  "verification": "Derivar {ε_t} = α ΔT {I} a partir da dilatação linear e confirmar para os 6 componentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de coeficientes α para materiais comuns",
                                    "Gráficos de dilatação térmica",
                                    "Software como MATLAB para visualização"
                                  ],
                                  "tips": "Lembre-se que {I} é diagonal com 1s nos componentes normais.",
                                  "learningObjective": "Entender a deformação induzida por temperatura em materiais isotrópicos.",
                                  "commonMistakes": "Aplicar α apenas em uma direção, ignorando isotropicidade; confundir α com β (volumétrico)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Superpor Deformações Mecânica e Térmica",
                                  "subSteps": [
                                    "Defina a deformação total: {ε} = {ε_mec} + {ε_t}.",
                                    "Substitua na lei elástica: {σ} = [D] {ε_mec} = [D] ({ε} - {ε_t}).",
                                    "Verifique a equação resultante: {σ} = [D] ({ε} - α ΔT {I}).",
                                    "Confirme que [D] permanece a mesma matriz elástica isotérmica.",
                                    "Discuta hipóteses: linearidade, pequenas deformações, isotropia."
                                  ],
                                  "verification": "Escrever a equação termoelástica completa e derivá-la passo a passo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel para derivação algébrica",
                                    "Referência em elementos finitos (ex: Zienkiewicz)",
                                    "Ferramenta simbólica como SymPy"
                                  ],
                                  "tips": "Substitua passo a passo para evitar erros algébricos.",
                                  "learningObjective": "Formular a lei constitutiva acoplada termoelástica.",
                                  "commonMistakes": "Esquecer o sinal negativo em ({ε} - {ε_t}); alterar [D] indevidamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Contextualizar a Lei Termoelástica",
                                  "subSteps": [
                                    "Escreva a forma final: {σ} = [D] ({ε} - {ε_t}), com {ε_t} = α ΔT {I}.",
                                    "Forneça a expressão explícita de [D] para isotrópicos: D_ij com termos λ e μ.",
                                    "Teste com caso uniaxial: σ = E (ε - α ΔT).",
                                    "Discuta implementação em elementos finitos.",
                                    "Relacione com gradientes de temperatura (pré-requisito para casos avançados)."
                                  ],
                                  "verification": "Aplicar a equação a um caso simples e obter resultado coerente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos numéricos resolvidos",
                                    "Software FEM como ANSYS (demo)",
                                    "Planilha Excel para cálculos matriciais"
                                  ],
                                  "tips": "Sempre normalize unidades: α em /°C, ΔT em °C, E em MPa.",
                                  "learningObjective": "Consolidar a escrita e aplicação da lei de Hooke termoelástica.",
                                  "commonMistakes": "Usar α volumétrico em vez de linear; ignorar identidade {I} nos cisalhamentos."
                                }
                              ],
                              "practicalExample": "Para uma placa de alumínio isotrópico (E=70 GPa, ν=0.33, α=23e-6 /°C) sob ΔT=50°C e deformação total ε_xx=0.002 (livre em outras direções), calcule σ_xx: ε_t=α ΔT=0.00115, ε_mec=0.002-0.00115=0.00085, σ_xx=E ε_mec ≈ 59.5 MPa.",
                              "finalVerifications": [
                                "Escreve corretamente {σ} = [D] ({ε} - {ε_t}) com todos os símbolos.",
                                "Define precisamente {ε_t} = α ΔT {I} para isotrópicos.",
                                "Explica o papel de [D] como matriz elástica isotérmica.",
                                "Aplica a equação em um caso uniaxial simples.",
                                "Identifica hipóteses (isotropia, linearidade).",
                                "Distingue deformação total de mecânica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação matricial e vetorial (100%).",
                                "Correta derivação passo a passo.",
                                "Compreensão física dos termos (explicação oral).",
                                "Aplicação numérica sem erros unitários.",
                                "Identificação de limitações e hipóteses.",
                                "Clareza na explicação de componentes."
                              ],
                              "crossCurricularConnections": [
                                "Física: Termodinâmica e expansão térmica de sólidos.",
                                "Matemática: Álgebra linear (operações com matrizes e vetores).",
                                "Computação: Implementação em códigos de elementos finitos (Python/MATLAB).",
                                "Química dos Materiais: Dependência de α em microestrutura."
                              ],
                              "realWorldApplication": "Essencial em análises de elementos finitos para prever tensões residuais em soldas, deformações em turbinas a gás sob ciclos térmicos ou freios de disco automotivos durante frenagens intensas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.3.2",
                            "name": "Incorporar no MEF",
                            "description": "Explicar a montagem do vetor de carga térmica {F_t} = ∫ [B]^T [D] {ε_t} dV e sua adição ao sistema global Ku = F + F_t.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Equações Constitutivas Termoelásticas",
                                  "subSteps": [
                                    "Relembrar a relação constitutiva linear elástica: {σ} = [D] {ε}",
                                    "Introduzir a deformação térmica {ε_t} = α ΔT {1}, onde α é o coeficiente de expansão térmica",
                                    "Derivar a equação termoelástica: {σ} = [D] ({ε} - {ε_t})",
                                    "Explicar o papel da matriz [B] como operador de deformação: {ε} = [B] {u}",
                                    "Discutir como as tensões termoelásticas contribuem para forças nodais"
                                  ],
                                  "verification": "Escrever corretamente a equação constitutiva termoelástica e identificar componentes chave",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Elementos Finitos (ex: Zienkiewicz), notas de aula, calculadora simbólica (ex: SymPy)",
                                  "tips": "Visualize {ε_t} como uma deformação 'fictícia' que o material tenta impor",
                                  "learningObjective": "Compreender como deformações térmicas modificam as tensões elásticas",
                                  "commonMistakes": "Confundir [D] (rigidez elástica) com propriedades térmicas; esquecer o sinal negativo em {ε - ε_t}"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar o Vetor de Carga Térmica por Elemento",
                                  "subSteps": [
                                    "Partir do trabalho virtual das tensões: ∫ {δ ε}^T {σ} dV = {δ u}^T {F_t}",
                                    "Substituir {σ} = [D] ([B] {u} - {ε_t}) e simplificar para termo forçante: {F_t} = ∫ [B]^T [D] {ε_t} dV",
                                    "Para elemento finito, escrever {F_t}^e = ∫_{V_e} [B]^T [D] {ε_t} dV",
                                    "Assumir {ε_t} constante ou interpolada via funções de forma N_i",
                                    "Verificar dimensionalidade: [B]^T [D] tem unidades de força por temperatura"
                                  ],
                                  "verification": "Derivar a fórmula {F_t} = ∫ [B]^T [D] {ε_t} dV a partir do princípio dos trabalhos virtuais",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel quadriculado, lápis, software de álgebra (MATLAB/SymPy), referência teórica MEF",
                                  "tips": "Use o princípio da estacionariedade da energia potencial para validar a derivação",
                                  "learningObjective": "Derivar analiticamente o vetor nodal de carga térmica equivalente",
                                  "commonMistakes": "Esquecer a transposta [B]^T; inverter a ordem na multiplicação matricial"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Integral Numérica ou Analítica",
                                  "subSteps": [
                                    "Para elementos simples (barra/truss), computar analiticamente ∫ dV sobre o comprimento",
                                    "Para elementos 2D/3D, usar integração numérica de Gauss (2-3 pontos por direção)",
                                    "Implementar em código: definir [B], [D], {ε_t} em pontos de Gauss e somar pesos",
                                    "Exemplo: em uma barra 1D, {F_t} = A E α ΔT ∫ [B]^T d x",
                                    "Normalizar pelo Jacobiano para elementos isoparamétricos"
                                  ],
                                  "verification": "Computar {F_t} para um elemento de teste e comparar com solução analítica conhecida",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Software MEF (ex: FEniCS, código Python custom), tabela de pontos Gauss",
                                  "tips": "Comece com elemento 1D para validar antes de 2D/3D",
                                  "learningObjective": "Avaliar numericamente o vetor de carga térmica em elementos finitos",
                                  "commonMistakes": "Ignorar o Jacobiano det(J) na integração; usar {ε_t} nos nós em vez de pontos de Gauss"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incorporar no Sistema Global Ku = F + F_t",
                                  "subSteps": [
                                    "Montar vetor global {F_global} somando {F^e} por conectividade nodal",
                                    "Adicionar {F_t_global} ao lado direito: Ku = F_mec + F_t",
                                    "Resolver o sistema linear para deslocamentos {u}",
                                    "Verificar equilíbrio: plotar deformações totais {ε_total} = {ε_mec} + {ε_t}",
                                    "Analisar resultados: tensões devem ser zero se livre expansão (F_mec=0)"
                                  ],
                                  "verification": "Assemblar e resolver um problema simples, confirmando que u permite livre expansão térmica",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Solver matricial (NumPy/SciPy), visualizador de malha (Gmsh/Paraview)",
                                  "tips": "Use sparse matrices para eficiência em malhas grandes",
                                  "learningObjective": "Integrar cargas térmicas no processo de solução MEF global",
                                  "commonMistakes": "Erro na conectividade ao assemblar {F_t_global}; esquecer de zerar {F_t} antes da soma"
                                }
                              ],
                              "practicalExample": "Considere uma placa 2D de aço (E=200 GPa, α=12e-6 /°C) com ΔT=100°C linear em x. Malha com 4 elementos quadrilaterais. Calcule {F_t} para cada elemento usando 2x2 Gauss, assembie e resolva Ku=F_t. Verifique deformação uniforme ε_t=0.0012 e σ=0 se sem restrições.",
                              "finalVerifications": [
                                "Derivação correta de {F_t} a partir de princípios variacionais",
                                "Cálculo numérico de {F_t} para elemento 1D/2D com erro <1%",
                                "Assemblagem global sem duplicação de forças nodais",
                                "Solução u reproduz livre expansão térmica (σ≈0 em ausência de F_mec)",
                                "Gráfico de ε_total vs ε_mec + ε_t coincide",
                                "Teste de convergência refinando malha"
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação teórica (fórmula exata com componentes identificados)",
                                "Correção numérica da integral (comparação analítica vs numérica)",
                                "Implementação de assemblagem sem erros de indexação",
                                "Interpretação física dos resultados (livre expansão, tensões induzidas)",
                                "Eficiência computacional (uso de Gauss e sparse solvers)",
                                "Documentação clara do processo e verificações"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Integração numérica de Gauss e álgebra matricial",
                                "Física: Termodinâmica (dilatação térmica) e mecânica dos sólidos",
                                "Programação: Implementação numérica em Python/MATLAB para solvers MEF",
                                "Engenharia de Materiais: Propriedades térmicas anisotrópicas"
                              ],
                              "realWorldApplication": "Análise de tensões residuais em soldagem de tubulações nucleares, previsão de deformações em lâminas de turbinas a gás sob ciclos térmicos, ou simulação de rachaduras em barragens devido a variações sazonais de temperatura."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.3.3",
                            "name": "Aplicar em problemas 1D",
                            "description": "Resolver numericamente um problema de barra com variação linear de temperatura, montando matrizes e calculando deslocamentos e tensões.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o problema e discretizar a barra",
                                  "subSteps": [
                                    "Identifique as propriedades da barra: comprimento L, área de seção transversal A, módulo de elasticidade E, coeficiente de expansão térmica α.",
                                    "Defina as condições de contorno: por exemplo, extremidade esquerda fixada (u=0), direita livre.",
                                    "Especifique a variação linear de temperatura: T(x) = T0 + ΔT*(x/L), com valores numéricos concretos.",
                                    "Discretize a barra em N elementos finitos 1D (ex: 2 elementos), definindo nós e comprimentos de elementos Le.",
                                    "Calcule as temperaturas nos nós dos elementos."
                                  ],
                                  "verification": "Verifique se a discretização cobre todo o comprimento L e se as temperaturas nos nós são consistentes com T(x).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, lápis, calculadora; opcional: planilha Excel ou Python para cálculos iniciais.",
                                  "tips": "Comece com 2 elementos para simplicidade; aumente para mais precisão após validar.",
                                  "learningObjective": "Compreender a formulação do problema termoelástico 1D e preparar a malha finita.",
                                  "commonMistakes": "Esquecer unidades consistentes (ex: metros vs mm); mal definir nós sobrepostos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Montar matrizes de rigidez e vetor de forças térmicas locais",
                                  "subSteps": [
                                    "Para cada elemento, calcule a matriz de rigidez local Ke = (A E / Le) * [1 -1; -1 1].",
                                    "Calcule o vetor de forças térmicas locais Fe_thermal = A E α * (ΔT_avg / 2) * Le * [1; 1], onde ΔT_avg é a média de temperatura nos nós do elemento.",
                                    "Some forças externas se aplicáveis (ex: carga axial F).",
                                    "Verifique simetria e positivos definitos de Ke.",
                                    "Repita para todos os elementos."
                                  ],
                                  "verification": "Confira se Ke é simétrica e Fe_thermal tem sinal correto (expansão positiva para ΔT >0).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora matricial ou software como MATLAB/NumPy; tabela de propriedades de materiais.",
                                  "tips": "Use ΔT_avg = (T1 + T2)/2 para variação linear exata em elementos lineares.",
                                  "learningObjective": "Dominar as equações constitutivas termoelásticas: σ = E(ε - αΔT).",
                                  "commonMistakes": "Confundir ΔT nodal com médio; inverter sinais em Fe_thermal."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Montar e resolver o sistema global",
                                  "subSteps": [
                                    "Monte a matriz de rigidez global K aplicando conectividade dos nós e condições de contorno (ex: remover grau de liberdade fixo).",
                                    "Monte o vetor de forças globais F = soma de Fe_thermal + F_ext.",
                                    "Resolva K u = F para os deslocamentos nodais u.",
                                    "Aplique partição para condições de contorno se necessário.",
                                    "Use solver numérico para sistemas maiores."
                                  ],
                                  "verification": "Verifique se det(K) > 0 e u cresce monotonicamente com x para expansão térmica.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "MATLAB, Python (NumPy/SciPy) ou solver manual para pequenos sistemas.",
                                  "tips": "Implemente em código para automação; teste com N=1 elemento analítico.",
                                  "learningObjective": "Aplicar montagem global em EF e resolver sistemas lineares.",
                                  "commonMistakes": "Erro na conectividade nodal; esquecer aplicar contornos antes de resolver."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular tensões e validar resultados",
                                  "subSteps": [
                                    "Para cada elemento, calcule deformações ε = (u_{i+1} - u_i)/Le.",
                                    "Calcule tensões σ = E (ε - α ΔT_avg).",
                                    "Plote perfis de u(x), ε(x), σ(x) ao longo da barra.",
                                    "Compare com solução analítica: u(x) = α ∫ T(s) ds para barra livre.",
                                    "Analise singularidades ou gradientes abruptos."
                                  ],
                                  "verification": "Tensões devem ser compressivas se contida; perfis lineares para T linear.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software de plotagem (Matplotlib, Excel); solução analítica de referência.",
                                  "tips": "Valide energia total ou equilíbrio nodal ∑F=0.",
                                  "learningObjective": "Interpretar resultados pós-processados em contexto termoelástico.",
                                  "commonMistakes": "Usar ΔT nodal errado em pós-processamento; ignorar efeitos de contorno."
                                }
                              ],
                              "practicalExample": "Barra de aço Aço 1045 (E=200 GPa, α=12e-6 /°C, A=1 cm², L=1 m), fixada em x=0, livre em x=1m, T(x)=20 + 80x °C. Discretize em 2 elementos. Espere u(1m)≈0.4 mm, σ média negativa.",
                              "finalVerifications": [
                                "Deslocamentos u coincidem com solução analítica em <5% erro.",
                                "Tensões σ mostram compressão devido a restrição.",
                                "Equilíbrio nodal: soma forças em cada nó zero.",
                                "Perfil de T interpolado corretamente nos elementos.",
                                "Matriz K simétrica e positiva definida.",
                                "Unidades consistentes em todos cálculos."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erro <10% vs analítico.",
                                "Correta montagem de Ke e Fe_thermal.",
                                "Aplicação adequada de contornos.",
                                "Interpretação física correta de u e σ.",
                                "Código ou cálculos reproduzíveis e comentados.",
                                "Gráficos claros de resultados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (inversão de matrizes, interpolação).",
                                "Física: Termodinâmica (dilatação térmica), Mecânica dos Sólidos.",
                                "Programação: Implementação numérica em Python/MATLAB.",
                                "Engenharia Civil: Análise térmica em estruturas."
                              ],
                              "realWorldApplication": "Análise de tensões em trilhos de trem devido a variações diárias de temperatura, evitando empenamento; dimensionamento de juntas de dilatação em pontes e edifícios."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.3.4",
                            "name": "Discutir hipóteses e limitações",
                            "description": "Abordar pressupostos de linearidade, pequenas deformações e acoplamento unidirecional (térmico para mecânico, sem inverso).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar as equações constitutivas termoelásticas básicas",
                                  "subSteps": [
                                    "Estude a forma geral das equações constitutivas termoelásticas: σ = C : (ε - ε_th), onde ε_th = α ΔT I.",
                                    "Identifique os componentes: tensor de tensão σ, matriz de rigidez C, deformação total ε, deformação térmica ε_th e coeficiente de expansão térmica α.",
                                    "Anote as variáveis envolvidas e suas unidades para contextualizar os pressupostos.",
                                    "Compare com equações elásticas puras para destacar a adição do termo térmico.",
                                    "Desenhe um diagrama esquemático mostrando o fluxo de acoplamento térmico-mecânico."
                                  ],
                                  "verification": "Capacidade de reescrever corretamente as equações e explicar cada termo em uma autoavaliação escrita.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro-texto de Elementos Finitos (ex: Zienkiewicz), caderno de anotações, calculadora simbólica (ex: SymPy online).",
                                  "tips": "Use notação tensorial consistente para evitar confusões com componentes cartesianos.",
                                  "learningObjective": "Compreender a estrutura matemática das equações para identificar onde os pressupostos são aplicados.",
                                  "commonMistakes": "Confundir deformação térmica com deformação mecânica; ignorar a dependência isotrópica."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a hipótese de linearidade",
                                  "subSteps": [
                                    "Defina linearidade: relação proporcional entre tensão e deformação (σ linear em ε).",
                                    "Discuta implicações: superposição válida, propriedades materiais constantes (C independente de ε).",
                                    "Exemplo: Calcule deformação para ΔT pequeno e verifique proporcionalidade.",
                                    "Identifique violações: grandes temperaturas alteram propriedades (não-linearidade material).",
                                    "Quantifique: limite típico |ε| << 1 e |ΔT| < 100°C para metais."
                                  ],
                                  "verification": "Resolva um problema simples numérico mostrando proporcionalidade e discuta validade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de cálculo (MATLAB ou Python com NumPy), exemplos de problemas resolvidos.",
                                  "tips": "Teste com valores extremos para visualizar quebra de linearidade graficamente.",
                                  "learningObjective": "Avaliar quando a linearidade é uma aproximação válida no contexto termoelástico.",
                                  "commonMistakes": "Assumir linearidade sempre válida; não considerar não-linearidades geométricas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar a hipótese de pequenas deformações",
                                  "subSteps": [
                                    "Explique pequenas deformações: ||ε|| << 1, permitindo linearização do tensor de deformação.",
                                    "Discuta consequências: geometria não muda significativamente, rotação desprezível.",
                                    "Calcule exemplo: para α = 10^-5 /K e ΔT = 100K, ε_th ≈ 0.001 << 1.",
                                    "Limitações: falha em grandes expansões térmicas (ex: plásticos ou altas temperaturas).",
                                    "Compare com teoria de grandes deformações (ex: Green-Lagrange strain)."
                                  ],
                                  "verification": "Demonstre graficamente deformação vs. rotação para um caso limite.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Ferramentas de plotagem (Matplotlib), artigos sobre teoria de deformações.",
                                  "tips": "Use norma de Frobenius para quantificar magnitude de ε.",
                                  "learningObjective": "Reconhecer cenários onde pequenas deformações são inadequadas.",
                                  "commonMistakes": "Confundir pequenas deformações com pequenas rotações; ignorar efeitos locais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar o acoplamento unidirecional térmico-mecânico",
                                  "subSteps": [
                                    "Descreva acoplamento unidirecional: campo térmico T(t) → ε_th → σ, sem feedback mecânico em T.",
                                    "Justifique: inércia térmica alta vs. resposta mecânica rápida (acoplamento fraco).",
                                    "Exemplo: simulação sequencial em EF: resolver calor primeiro, depois mecânica.",
                                    "Limitações: ignora dissipação viscosa ou piezoeletricidade (acoplamento bidirecional).",
                                    "Discuta critérios: número de Fourier alto ou baixas velocidades."
                                  ],
                                  "verification": "Esboce fluxograma de solução sequencial vs. monolítica e explique escolha.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Documentação de software EF (ANSYS ou Abaqus), vídeo tutorial sobre acoplamento.",
                                  "tips": "Pense em escalas de tempo: térmica lenta, mecânica rápida favorece unidirecional.",
                                  "learningObjective": "Diferenciar acoplamento unidirecional de totalmente acoplado.",
                                  "commonMistakes": "Assumir bidirecional por default; não verificar escalas de tempo."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar limitações gerais e cenários de aplicação",
                                  "subSteps": [
                                    "Liste limitações combinadas: não para materiais não-lineares, grandes strains ou acoplamento forte.",
                                    "Cenários válidos: fadiga térmica em turbinas, freios de disco automotivos.",
                                    "Proponha testes: comparar solução linear com não-linear para validação.",
                                    "Discuta extensões: modelos não-lineares ou fully coupled para casos avançados.",
                                    "Redija um relatório resumindo hipóteses e quando relaxá-las."
                                  ],
                                  "verification": "Produza um quadro comparativo de casos válidos vs. inválidos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Modelos de referência (papers IEEE ou ASME), template de relatório.",
                                  "tips": "Use tabela para organizar: Hipótese | Condição | Exemplo Falha.",
                                  "learningObjective": "Integrar todas as hipóteses em uma discussão crítica coesa.",
                                  "commonMistakes": "Subestimar interações entre hipóteses; não propor alternativas."
                                }
                              ],
                              "practicalExample": "Em uma análise de freio de disco de carro: ΔT = 300°C, α_aço = 12e-6 /K → ε_th ≈ 0.0036 (pequena). Discuta: linearidade OK (aço em regime elástico), pequenas deformações válidas, acoplamento unidirecional (calor por atrito → deformação, sem feedback significativo). Simule em EF sequencial e verifique tensão máxima.",
                              "finalVerifications": [
                                "Liste e explique os três pressupostos principais com exemplos numéricos.",
                                "Identifique um cenário onde cada hipótese falha e sugira modelo alternativo.",
                                "Desenhe fluxograma de solução termoelástica unidirecional.",
                                "Calcule ε_th para ΔT=200K em alumínio e verifique ||ε|| << 1.",
                                "Compare resultados lineares vs. potenciais não-lineares em um caso simples.",
                                "Redija parágrafo discutindo limitações em aplicação real (ex: turbina)."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica: Correção das equações e definições (30%).",
                                "Profundidade de análise: Detalhes quantitativos e qualitativos (25%).",
                                "Clareza na comunicação: Uso de diagramas e exemplos (20%).",
                                "Crítica construtiva: Identificação de limitações e alternativas (15%).",
                                "Estrutura lógica: Organização sequencial e síntese (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física/Termodinâmica: Equação de calor e difusão térmica.",
                                "Matemática: Álgebra tensorial e linearização de operadores.",
                                "Computação: Implementação numérica em solvers EF (Python/Fortran).",
                                "Materiais: Propriedades térmicas e mecânicas dependentes de T.",
                                "Engenharia de Projeto: Validação de hipóteses em simulações industriais."
                              ],
                              "realWorldApplication": "Na indústria aeroespacial, ao projetar pás de turbina a gás, discute-se essas hipóteses para prever deformações térmicas durante partida; violações levam a falhas como trincas por fadiga, exigindo modelos fully coupled em regimes de alta temperatura."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.6",
                    "name": "Energia Potencial Total",
                    "description": "Formulação da energia potencial total para minimização no método variacional.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.6.1",
                        "name": "Energia de Deformação Interna",
                        "description": "Conceito da energia armazenada no contínuo elástico devido às deformações, expressa como uma integral sobre o volume do produto tensão-deformação.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.6.1.1",
                            "name": "Definir a expressão matemática da energia interna U",
                            "description": "Derivar e explicar a fórmula U = (1/2) ∫_Ω σ : ε dΩ, onde σ é o tensor de tensões e ε o tensor de deformações, para materiais lineares elásticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Tensores de Tensão e Deformação",
                                  "subSteps": [
                                    "Defina o tensor de tensão σ como uma matriz simétrica 3x3 que descreve forças internas por unidade de área.",
                                    "Defina o tensor de deformação ε como a metade da derivada simétrica do deslocamento, ε = (1/2)(∇u + (∇u)^T).",
                                    "Explique o produto duplo σ : ε = σ_ij ε_ij (soma de Einstein).",
                                    "Discuta o significado físico: σ : ε representa densidade de energia de deformação por unidade de volume.",
                                    "Verifique simetria e propriedades invariantes dos tensores."
                                  ],
                                  "verification": "Resuma definições em um diagrama tensorial e calcule σ : ε para um caso uniaxial simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Mecânica dos Sólidos (ex: Timmoshenko), caderno de anotações, calculadora.",
                                  "tips": "Use notação indicial para clareza em derivadas.",
                                  "learningObjective": "Compreender a representação tensorial de tensão e deformação como base para energia interna.",
                                  "commonMistakes": "Confundir tensão com força total ou deformação com deslocamento absoluto."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estabelecer a Relação Constitutiva para Materiais Lineares Elásticos",
                                  "subSteps": [
                                    "Apresente a lei de Hooke generalizada: σ = C ε, onde C é o tensor de elasticidade (matriz 6x6 em voigt).",
                                    "Discuta isotropia: C com módulos E e ν, levando a σ : ε = (1/2) ε : C ε.",
                                    "Derive a densidade de energia de deformação w = (1/2) σ : ε para carregamento proporcional.",
                                    "Justifique linearidade: energia é quadrática em ε devido à integração do trabalho incremental.",
                                    "Calcule w para casos uniaxial e plano de tensão."
                                  ],
                                  "verification": "Derive w para tração uniaxial e compare com fórmula conhecida U = (1/2) F δ.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Tabela de propriedades elásticas, software simbólico como Mathematica ou papel.",
                                  "tips": "Lembre-se que para elásticos lineares, o fator 1/2 surge da média entre σ inicial e final.",
                                  "learningObjective": "Relacionar lei constitutiva à densidade de energia de deformação.",
                                  "commonMistakes": "Esquecer o fator 1/2 ou assumir C escalar em vez de tensor."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Energia Interna Total a partir da Densidade Local",
                                  "subSteps": [
                                    "Integre a densidade w sobre o volume: U = ∫_Ω w dΩ = ∫_Ω (1/2) σ : ε dΩ.",
                                    "Justifique o domínio Ω como o volume deformado do corpo.",
                                    "Discuta hipóteses: pequenas deformações, linearidade, equilíbrio quasi-estático.",
                                    "Mostre equivalência com trabalho virtual das forças internas.",
                                    "Verifique dimensionalmente: [U] = energia (Joules)."
                                  ],
                                  "verification": "Escreva a fórmula integral e reduza para 1D: U = ∫ (1/2) σ ε A dx.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Referência de Elementos Finitos (ex: Zienkiewicz), quadro branco.",
                                  "tips": "Pense em U como trabalho armazenado nas deformações elásticas.",
                                  "learningObjective": "Derivar a expressão integral da energia interna U.",
                                  "commonMistakes": "Integrar sobre área em vez de volume ou omitir o 1/2."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e Aplicar a Fórmula em Contextos de Elementos Finitos",
                                  "subSteps": [
                                    "Explique o papel de U no princípio dos trabalhos virtuais ou minimização de energia.",
                                    "Discuta discretização em MEF: U_h = Σ_e (1/2) ∫_Ωe B^T D B dΩ u_e^T u_e.",
                                    "Analise invariância sob transformações de coordenadas.",
                                    "Compare com energia externa V = -∫ t u dS.",
                                    "Discuta extensões para não-lineares (hiperelástico)."
                                  ],
                                  "verification": "Explique verbalmente como U entra na formulação fraca das EDP elásticas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Slides de MEF, MATLAB para protótipo simples.",
                                  "tips": "Visualize U como 'energia elástica armazenada' em estruturas como vigas ou placas.",
                                  "learningObjective": "Explicar o significado físico e computacional da fórmula U.",
                                  "commonMistakes": "Confundir U com energia cinética ou potencial gravitacional."
                                }
                              ],
                              "practicalExample": "Considere uma barra de aço (E=200 GPa) de comprimento L=1m, seção A=0.01m², sob tração F=10kN. Calcule ε=σ/E=1MPa/200GPa=5e-6, então U=(1/2)σ ε A L = (1/2)*1e6*5e-6*0.01*1=0.025J. Verifique com δ=FL/AE=50μm, U=(1/2)Fδ=0.025J.",
                              "finalVerifications": [
                                "Derive corretamente U = (1/2) ∫_Ω σ : ε dΩ a partir de w.",
                                "Explique o papel dos tensores σ e ε na fórmula.",
                                "Reduza para caso 1D e compare com fórmula clássica.",
                                "Identifique hipóteses (linear elástico, pequenas deformações).",
                                "Discuta uso em MEF (matriz de rigidez).",
                                "Calcule U numericamente para exemplo prático."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da fórmula integral (obrigatório).",
                                "Compreensão tensorial (notação : correta).",
                                "Justificativa física do fator 1/2.",
                                "Correta redução a casos simples (1D/2D).",
                                "Integração com contexto MEF.",
                                "Clareza na explicação verbal/escrita."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo tensorial e integrais em domínios contínuos.",
                                "Física: Princípio da conservação de energia em sólidos deformáveis.",
                                "Computação: Formulação numérica em solvers FEA (ex: Abaqus).",
                                "Materiais: Propriedades constitutivas e anisotropia.",
                                "Engenharia Civil: Análise de estruturas sob carga."
                              ],
                              "realWorldApplication": "Na análise de elementos finitos para projetos de aviões ou pontes, U é computada para verificar estabilidade elástica, otimizar designs contra fadiga e simular falhas em softwares como ANSYS, garantindo segurança em componentes sob estresse."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.1.2",
                            "name": "Calcular U para problemas unidimensionais",
                            "description": "Aplicar a fórmula para calcular a energia interna em barras ou vigas 1D, integrando ao longo do comprimento com deformações lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a fórmula contínua da energia interna U",
                                  "subSteps": [
                                    "Revise a definição de energia de deformação interna: U = ∫_V (1/2) σ ε dV, onde σ é tensão e ε é deformação.",
                                    "Para problemas 1D (barras/vigas), simplifique para U = ∫_0^L (1/2) E A (du/dx)^2 dx, com E módulo elástico, A seção transversal, L comprimento e u deslocamento.",
                                    "Identifique pressupostos: deformação linear, material linear-elástico isotrópo.",
                                    "Derive a relação entre tensão σ = E ε e ε = du/dx.",
                                    "Discuta interpolação linear de u dentro de um elemento: u(x) = N1 u1 + N2 u2, onde Ni são funções de forma."
                                  ],
                                  "verification": "Escreva a fórmula de U para um elemento 1D e explique cada termo em um parágrafo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Elementos Finitos (ex: Zienkiewicz), caderno de anotações, calculadora"
                                  ],
                                  "tips": "Visualize a barra como uma mola gigante para intuitar a energia armazenada.",
                                  "learningObjective": "Compreender a origem física e matemática da energia interna em 1D.",
                                  "commonMistakes": [
                                    "Confundir U com energia potencial total (inclui U + W), esquecer o fator 1/2, ignorar variações de A ao longo de L."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o problema e discretizar a malha",
                                  "subSteps": [
                                    "Defina o domínio geométrico: comprimento L, seção A constante, material E.",
                                    "Aplique condições de contorno: ex. u(0)=0 (engastada), força F em x=L.",
                                    "Gere malha finita: divida em ne elementos de comprimento he = L/ne, nós com deslocamentos ui.",
                                    "Solucione o sistema global Ke u = F para obter vetor de deslocamentos u (use método analítico para casos simples).",
                                    "Calcule o vetor de deformação B por elemento: ε = B u_e, com B derivada das funções de forma."
                                  ],
                                  "verification": "Desenhe a malha com 3 elementos e liste os graus de liberdade nos nós.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software MATLAB/Python para matrizes (opcional), papel milimetrado"
                                  ],
                                  "tips": "Comece com malha grosseira (2-3 elementos) para validar antes de refinar.",
                                  "learningObjective": "Preparar o modelo numérico unidimensional para cálculo de energia.",
                                  "commonMistakes": [
                                    "Erros em condições de contorno levando a u incorreto, malha não uniforme sem ajuste de he."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular energia U por elemento usando integração gaussiana",
                                  "subSteps": [
                                    "Para cada elemento e, compute matriz de rigidez local k_e = ∫ B^T E A B dx ≈ E A / he * [1 -1; -1 1].",
                                    "Calcule deformações nos pontos de Gauss: ε_gp = B u_e em ξ=±1/√3 para 2 pontos.",
                                    "Integre numericamente U_e = ∑_gp w_gp * (1/2) σ_gp ε_gp * A * he * |J|, com pesos w_gp=1, J=he/2.",
                                    "Analiticamente: U_e = (1/2) u_e^T k_e u_e (forma quadrática equivalente).",
                                    "Registre U_e para cada elemento."
                                  ],
                                  "verification": "Calcule U_e para um elemento e compare com fórmula exata U_e = (1/2) E A (Δu/he)^2 * he.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de pontos Gauss 1D, planilha Excel ou código Python simples"
                                  ],
                                  "tips": "Use a forma u^T K u /2 para simplicidade em problemas lineares.",
                                  "learningObjective": "Dominar o cálculo local de energia em elementos 1D.",
                                  "commonMistakes": [
                                    "Esquecer transformação jacobiana |J| na integração, usar σ em vez de ε incorretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Somar energias elementares e validar o resultado",
                                  "subSteps": [
                                    "Some U_total = ∑_e U_e sobre todos elementos.",
                                    "Compare com solução analítica: para barra cantilever, U = (1/2) F δ, com δ= F L^3 / (3 E I) (ajuste para barra axial).",
                                    "Analise convergência: refine malha e observe erro em U.",
                                    "Interprete: U representa energia armazenada, usada em minimização variacional.",
                                    "Documente o processo em relatório com valores numéricos."
                                  ],
                                  "verification": "U_total converge para valor analítico com erro <1% em malha fina.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Solução analítica impressa, gráfico de convergência"
                                  ],
                                  "tips": "Sempre normalize erro como |U_num - U_exata| / U_exata.",
                                  "learningObjective": "Integrar cálculos locais em energia global e validar.",
                                  "commonMistakes": [
                                    "Duplicar energia em nós compartilhados (não somar diretamente u^T K u global sem cuidado)."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma barra axial de aço (E=200 GPa, A=1 cm², L=1 m) engastada em x=0 com tração F=10 kN em x=L. Malha com 2 elementos. Solução analítica: u(L)=F L /(E A)=0.5 mm, U= (1/2) F u(L)=2.5 J. Calcule U_num via EF e compare.",
                              "finalVerifications": [
                                "Fórmula de U_e implementada corretamente para elemento linear.",
                                "Soma de U_e equals (1/2) u^T K u global.",
                                "Convergência observada com refinamento de malha.",
                                "Comparação com analítica dentro de 0.5% de erro.",
                                "Gráfico de distribuição de U por elemento gerado.",
                                "Relatório explica discrepâncias se houver."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de U (erro <2%).",
                                "Correta derivação de B e integração Gauss.",
                                "Uso apropriado de unidades (Joules).",
                                "Identificação e correção de erros comuns.",
                                "Explicação clara da física envolvida.",
                                "Eficiência computacional demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Integração numérica (Gauss), álgebra matricial.",
                                "Física: Princípio dos trabalhos virtuais, conservação de energia.",
                                "Programação: Implementação em Python/MATLAB de loop por elementos.",
                                "Engenharia Civil: Análise de estruturas treliçadas.",
                                "Cálculo Numérico: Erro de truncamento e convergência."
                              ],
                              "realWorldApplication": "Em software de EF como ANSYS ou Abaqus, calcular U valida modelos de fadiga em vigas de pontes ou aeronaves, otimizando designs para minimizar energia deformacional e prever falhas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.1.3",
                            "name": "Relacionar U com as equações constitutivas",
                            "description": "Conectar a energia interna às relações constitutivas lineares σ = D ε, mostrando U = (1/2) ∫_Ω ε^T D ε dΩ.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar as Relações Constitutivas Lineares",
                                  "subSteps": [
                                    "Defina tensão σ e deformação ε como vetores/colunas em 3D.",
                                    "Explique a matriz de rigidez D para materiais isotrópicos (ex: D com módulo de Young E e Poisson ν).",
                                    "Escreva σ = D ε e discuta linearidade para pequenos deslocamentos.",
                                    "Calcule σ para um ε simples, como ε = [0.01, 0, 0]^T.",
                                    "Verifique simetria e positiva definitude de D."
                                  ],
                                  "verification": "Resolva σ para ε dado e compare com fórmula analítica.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Elementos Finitos (ex: Bathe), calculadora ou MATLAB.",
                                  "tips": "Use notação matricial para clareza; memorize D para plano tensão.",
                                  "learningObjective": "Compreender σ = D ε como base para energia.",
                                  "commonMistakes": "Confundir σ e ε como escalares; ignorar dependência de D no material."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a Energia de Deformação Interna Local",
                                  "subSteps": [
                                    "Defina densidade de energia u como trabalho de deformação unitária.",
                                    "Para linear, derive u = ∫ σ dε = 1/2 σ^T ε (triângulo geométrico).",
                                    "Substitua σ = D ε para obter u = 1/2 ε^T D ε.",
                                    "Verifique para caso uniaxial: u = 1/2 σ ε = 1/2 E ε².",
                                    "Discuta quadraticidade e positividade."
                                  ],
                                  "verification": "Derive u para ε uniaxial e confirme com gráfico tensão-deformação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel, lápis, software de plotagem (ex: Python/MATLAB).",
                                  "tips": "Desenhe curva σ-ε para visualizar área 1/2 base altura.",
                                  "learningObjective": "Derivar expressão local da energia interna.",
                                  "commonMistakes": "Esquecer transposta em ε^T D ε; usar σ ε em vez de 1/2."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar para Obter Energia Total U",
                                  "subSteps": [
                                    "Defina U = ∫_Ω u dΩ com u = 1/2 ε^T D ε.",
                                    "Discuta Ω como domínio da estrutura.",
                                    "Para EF, note que ε = B u (B matriz de deformação, u deslocamentos).",
                                    "Escreva U = 1/2 ∫_Ω u_e^T K_e u_e dΩ por elemento (K_e = ∫ B^T D B).",
                                    "Calcule U numericamente para malha simples."
                                  ],
                                  "verification": "Implemente em código simples e compare com analítico uniaxial.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "MATLAB ou Python (NumPy/SciPy), exemplo de malha EF.",
                                  "tips": "Comece com 1D (barra) para validar antes de 2D/3D.",
                                  "learningObjective": "Conectar energia local à total via integração.",
                                  "commonMistakes": "Integrar sem 1/2; confundir u nodal com ε."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Aplicar em Exemplo Prático",
                                  "subSteps": [
                                    "Monte problema: barra fixa com carga, calcule ε, σ, U analítico.",
                                    "Use EF com 1 elemento: monte K, resolva u, compute U.",
                                    "Compare U numérico vs. analítico (erro <1%).",
                                    "Analise sensibilidade a malha/refinamento.",
                                    "Discuta minimização de Π = U - W (trabalho externo)."
                                  ],
                                  "verification": "U coincide dentro de tolerância e ∂U/∂u = forças internas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Código EF pronto (ex: template MATLAB), estrutura simples.",
                                  "tips": "Use simetria para reduzir dimensões; debugue matrizes.",
                                  "learningObjective": "Aplicar relação U em contexto EF completo.",
                                  "commonMistakes": "Erro em montagem de K; esquecer consistência de unidades."
                                }
                              ],
                              "practicalExample": "Em uma barra de aço (E=200 GPa, A=1 cm², L=1m) fixa em uma ponta com tração F=10 kN: ε=0.005, σ=10 MPa, U=1/2 * σ * ε * Volume = 25 J. Com EF (1 elemento), K=AE/L, u=F/K, U=1/2 u^T K u confirma 25 J.",
                              "finalVerifications": [
                                "Derivação correta de u = 1/2 ε^T D ε a partir de σ = D ε.",
                                "Cálculo de U para exemplo 1D coincide analítico e numérico.",
                                "Expressão matricial U = 1/2 ∫ ε^T D ε dΩ escrita corretamente.",
                                "Verificação de positividade: D positiva definida implica U >0 para ε≠0.",
                                "Conexão com forma nodal: U = 1/2 u^T K u.",
                                "Gráfico tensão-deformação mostra área como energia."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação: 1/2 fator e transpostas corretas (30%).",
                                "Compreensão conceitual: ligação constitutivas-energia (25%).",
                                "Implementação numérica: erro <5% em exemplo (20%).",
                                "Explicação clara de passos e verificações (15%).",
                                "Identificação de erros comuns e tips (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (produtos matriciais, integrais quadráticas).",
                                "Física: Mecânica dos sólidos (trabalho, energia potencial).",
                                "Computação: Programação numérica (MATLAB/Python para EF).",
                                "Materiais: Propriedades constitutivas (D de E, ν)."
                              ],
                              "realWorldApplication": "Em simulações EF de estruturas civis (pontes, edifícios), U avalia eficiência energética, detecta falhas por picos locais e otimiza designs minimizando Π para conformidade com normas como Eurocode."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.6.2",
                        "name": "Trabalho das Forças Externas",
                        "description": "Potencial associado ao trabalho realizado pelas forças de corpo e de superfície na configuração deformada.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.6.2.1",
                            "name": "Formular o potencial das forças externas W",
                            "description": "Explicar W = ∫_Ω u^T b dΩ + ∫_Γ u^T t dΓ, onde u é o deslocamento, b forças de volume e t trações superficiais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Deslocamento e Forças Externas",
                                  "subSteps": [
                                    "Defina o vetor de deslocamento u como o campo de deslocamentos no domínio Ω.",
                                    "Explique forças de volume b como cargas por unidade de volume (ex.: gravidade).",
                                    "Descreva trações superficiais t como forças por unidade de área na fronteira Γ.",
                                    "Discuta o princípio do trabalho virtual: δW = δu^T (∫ b dΩ + ∫ t dΓ).",
                                    "Identifique domínios: Ω (volume) e Γ (superfície)."
                                  ],
                                  "verification": "Escreva definições precisas e identifique Ω e Γ em um diagrama simples de uma estrutura.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Elementos Finitos (ex.: Zienkiewicz), papel e caneta, diagrama de uma viga.",
                                  "tips": "Use vetores para representar u, b e t; visualize com setas em um esboço.",
                                  "learningObjective": "Compreender os componentes físicos envolvidos no potencial W.",
                                  "commonMistakes": "Confundir b (volume) com t (superfície); ignorar a natureza vetorial de u."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular o Trabalho das Forças de Volume",
                                  "subSteps": [
                                    "Escreva a expressão de trabalho para forças de volume: ∫_Ω u^T b dΩ.",
                                    "Explique u^T b como produto escalar local entre deslocamento e força por volume.",
                                    "Integre sobre o domínio Ω para obter energia total de deformação volumétrica.",
                                    "Discuta simetria: u^T b = b^T u em espaços euclidianos.",
                                    "Verifique dimensionalmente: [u] m, [b] N/m³, [dΩ] m³ → [W] J."
                                  ],
                                  "verification": "Derive a integral a partir do trabalho virtual δW_v = ∫_Ω δu^T b dΩ e confirme dimensões.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora simbólica (ex.: Mathematica ou papel), exemplos numéricos de gravidade em uma placa.",
                                  "tips": "Comece com caso 1D para intuição: W_v = ∫ u(x) b(x) dx.",
                                  "learningObjective": "Derivar e interpretar o termo de forças de volume em W.",
                                  "commonMistakes": "Esquecer o transposto u^T; usar escalares em vez de vetores."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular o Trabalho das Trações Superficiais",
                                  "subSteps": [
                                    "Escreva a expressão: ∫_Γ u^T t dΓ.",
                                    "Explique t como vetor de tração na fronteira Γ (ex.: cargas aplicadas).",
                                    "Integre sobre a superfície Γ, considerando apenas fronteiras com trações prescritas.",
                                    "Compare com forças de volume: superfície vs. volume.",
                                    "Verifique: para Γ discreta (nós), aproxima-se como soma u_i^T t_i A_i."
                                  ],
                                  "verification": "Calcule ∫_Γ u^T t dΓ para uma face plana com t constante e u linear.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de desenho vetorial ou papel para esboçar Γ, tabela de exemplos.",
                                  "tips": "Pense em t como Neumann BCs; teste com carga pontual aproximada.",
                                  "learningObjective": "Dominar o termo superficial do potencial W.",
                                  "commonMistakes": "Integrar t sobre todo Ω em vez de Γ; confundir com condições de Dirichlet."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar Termos para Obter o Potencial Total W",
                                  "subSteps": [
                                    "Some os termos: W = ∫_Ω u^T b dΩ + ∫_Γ u^T t dΓ.",
                                    "Explique o papel em Princípio dos Trabalhos Virtuais ou Energia Potencial Total Π = U - W.",
                                    "Discuta linearidade em u para problemas lineares.",
                                    "Aplique a uma estrutura simples: viga com peso próprio (b) e carga na ponta (t).",
                                    "Verifique neutralidade: ∇W = forças nodais em MEF."
                                  ],
                                  "verification": "Escreva W completa para um problema 1D e compute numericamente para valores dados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Exemplo numérico resolvido de MEF, Python/MATLAB para integração simples.",
                                  "tips": "Lembre: W é função de u; em MEF, discretiza como W_e = u_e^T f_e.",
                                  "learningObjective": "Formular W total e contextualizá-lo em MEF.",
                                  "commonMistakes": "Inverter sinal de W (é subtraído em Π); omitir um termo."
                                }
                              ],
                              "practicalExample": "Em uma viga cantilever de comprimento L=1m, seção 0.1x0.1m, com gravidade b=[0,0,-9810] N/m³ e tração t=[1000,0,0] N/m² na ponta livre: W = ∫_0^L u(z)^T b dz * A + u_ponta^T t * A_ponta, onde A=0.01m².",
                              "finalVerifications": [
                                "Deriva corretamente W a partir do princípio variacional.",
                                "Identifica corretamente domínios Ω e Γ em um problema dado.",
                                "Verifica dimensões e unidades de W (Joules).",
                                "Aplica W a um exemplo numérico simples com valores corretos.",
                                "Explica o papel de W na minimização de Π = U - W.",
                                "Discretiza W para um elemento finito 1D."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação das integrais (100% dos termos corretos).",
                                "Correta interpretação física de b, t e u (sem confusões vetoriais).",
                                "Exemplo prático resolvido com cálculos numéricos exatos.",
                                "Uso apropriado de notação matemática (transpostos, integrais).",
                                "Conexão clara com MEF (forças nodais f = ∂W/∂u).",
                                "Ausência de erros dimensionais ou de sinal."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo integral multivariado e produtos internos vetoriais.",
                                "Física: Mecânica dos sólidos e princípio dos trabalhos virtuais.",
                                "Computação: Discretização numérica para MEF em software como FEniCS.",
                                "Engenharia Civil: Análise de estruturas sob cargas distribuídas."
                              ],
                              "realWorldApplication": "Na análise de pontes ou aviões via MEF (ex.: ANSYS), W modela cargas como vento (t) e peso próprio (b), essencial para prever deformações e falhas em projetos reais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.2.2",
                            "name": "Calcular W para cargas distribuídas",
                            "description": "Realizar os cálculos de integração para forças uniformes ou lineares em elementos simples como barras.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de trabalho para cargas distribuídas",
                                  "subSteps": [
                                    "Defina trabalho como a integral do produto de força por deslocamento infinitesimal.",
                                    "Explique a diferença entre cargas puntiformes e distribuídas em elementos como barras.",
                                    "Identifique que para cargas distribuídas, W = ∫ F(x) * δ(x) dx ao longo do elemento.",
                                    "Revise deslocamentos nodais em elementos finitos para barras.",
                                    "Discuta forças uniformes (constantes) e lineares (variam linearmente)."
                                  ],
                                  "verification": "Escreva a fórmula geral de W para uma carga distribuída e explique cada termo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Elementos Finitos, papel e caneta, calculadora.",
                                  "tips": "Visualize a carga como infinitos carregamentos puntiformes para entender a integração.",
                                  "learningObjective": "Entender a base matemática do trabalho em cargas distribuídas.",
                                  "commonMistakes": "Confundir deslocamento nodal com deformação local; ignorar variação do deslocamento."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular W para carga uniforme em barra",
                                  "subSteps": [
                                    "Defina a carga uniforme q (N/m) constante ao longo da barra de comprimento L.",
                                    "Expresse a força diferencial dF = q dx.",
                                    "Assuma deslocamento linear δ(x) = (δ2 - δ1)/L * x + δ1 entre nós.",
                                    "Monte a integral W = ∫_0^L q * δ(x) dx.",
                                    "Resolva a integral obtendo W = q * L * (δ1 + δ2)/2."
                                  ],
                                  "verification": "Calcule W para L=1m, q=10N/m, δ1=0, δ2=0.01m e verifique resultado 0.05J.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora, software simbólico como Wolfram Alpha (opcional).",
                                  "tips": "Lembre-se: para uniforme, é como a média dos deslocamentos vezes a carga total.",
                                  "learningObjective": "Derivar e calcular W para cargas uniformes.",
                                  "commonMistakes": "Esquecer de integrar o deslocamento interpolado; usar δ médio incorreto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular W para carga linear em barra",
                                  "subSteps": [
                                    "Defina carga linear q(x) = q1 + (q2 - q1)/L * x.",
                                    "Expresse dF = q(x) dx.",
                                    "Use a mesma interpolação linear para δ(x).",
                                    "Monte W = ∫_0^L q(x) * δ(x) dx.",
                                    "Resolva expandindo o produto e integrando termo a termo, obtendo fórmula fechada."
                                  ],
                                  "verification": "Para L=2m, q1=0, q2=100N/m, δ1=0, δ2=0.02m, calcule W=1.333J.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel quadriculado, calculadora, tabela de integrais.",
                                  "tips": "Expanda q(x)*δ(x) em polinômio e integre cada termo separadamente.",
                                  "learningObjective": "Dominar integração para cargas variáveis linearmente.",
                                  "commonMistakes": "Erro na definição de q(x); integração incorreta de produtos lineares."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e aplicar em elementos finitos",
                                  "subSteps": [
                                    "Compare resultados analíticos com aproximações numéricas (ex: simpson).",
                                    "Implemente em matriz de rigidez para validar energia total.",
                                    "Teste casos limites: q uniforme zero, cargas opostas.",
                                    "Documente o processo em um relatório curto.",
                                    "Resolva um problema completo com dados reais."
                                  ],
                                  "verification": "O resultado coincide com método de elementos finitos padrão dentro de 1% de erro.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Software como MATLAB ou Python (NumPy/SciPy), exemplos de código.",
                                  "tips": "Sempre normalize unidades (N, m) para evitar erros dimensionais.",
                                  "learningObjective": "Integrar cálculo de W no fluxo de análise de elementos finitos.",
                                  "commonMistakes": "Ignorar sinal das forças/deslocamentos; unidades inconsistentes."
                                }
                              ],
                              "practicalExample": "Em uma barra de 3m entre nós com δ1=0mm e δ2=5mm, sob carga uniforme q=200N/m. Calcule W = 200 * 3 * (0 + 0.005)/2 = 1.5J. Para linear q(x)=0 a 400N/m, expanda e integre para W≈2.25J.",
                              "finalVerifications": [
                                "Deriva corretamente a fórmula para carga uniforme.",
                                "Resolve integral para carga linear sem erros algébricos.",
                                "Aplica em barra com deslocamentos dados e obtém valor numérico preciso.",
                                "Identifica quando usar cada tipo de carga.",
                                "Valida com método numérico simples.",
                                "Explica contribuição para energia potencial total."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas integrais (100% correto).",
                                "Correta interpolação de deslocamentos lineares.",
                                "Uso apropriado de unidades e sinais.",
                                "Clareza na derivação passo a passo.",
                                "Aplicação correta em exemplo prático.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo integral e funções lineares.",
                                "Física: Princípios de trabalho e energia em mecânica.",
                                "Programação: Implementação numérica em Python/MATLAB.",
                                "Engenharia Civil: Análise de vigas e estruturas.",
                                "Computação Científica: Métodos numéricos de integração."
                              ],
                              "realWorldApplication": "Na análise de vigas em pontes ou edifícios usando elementos finitos, calcular W preciso garante avaliação correta de deformações e estabilidade estrutural sob cargas como peso próprio ou vento distribuído."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.6.3",
                        "name": "Energia Potencial Total e Minimização Variacional",
                        "description": "Definição da energia potencial total Π = U - W e seu papel na formulação variacional para encontrar o equilíbrio estático.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.6.3.1",
                            "name": "Definir a energia potencial total Π",
                            "description": "Estabelecer Π = U - W e demonstrar que o estado de equilíbrio corresponde a uma minimização estacionária δΠ = 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Energia em Mecânica dos Sólidos",
                                  "subSteps": [
                                    "Estude a definição de energia de deformação elástica U como a energia armazenada devido às deformações no material.",
                                    "Analise o trabalho externo W realizado pelas forças de contorno e cargas volumétricas.",
                                    "Relacione esses conceitos ao Princípio dos Trabalhos Virtuais (PTV) como base para o princípio variacional.",
                                    "Identifique as hipóteses de elasticidade linear e pequenas deformações.",
                                    "Discuta exemplos simples como uma mola ou barra axial para ilustrar U e W."
                                  ],
                                  "verification": "Explique em um parágrafo curto o que são U e W, com um exemplo físico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de Mecânica dos Materiais (ex: Timoshenko), notas de aula sobre PTV, calculadora.",
                                  "tips": "Use diagramas de corpo livre para visualizar forças e deformações.",
                                  "learningObjective": "Compreender os componentes energéticos básicos em sistemas elásticos.",
                                  "commonMistakes": "Confundir energia de deformação U com energia cinética ou dissipativa."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formalizar a Expressão Matemática da Energia Potencial Interna U",
                                  "subSteps": [
                                    "Escreva a integral de U para um sólido elástico: U = (1/2) ∫_Ω ε^T σ dΩ.",
                                    "Expanda em termos de deslocamentos u: ε = B u, onde B é o operador de deformação.",
                                    "Para o caso discreto (pré-FEM), considere elementos finitos iniciais com U_e = (1/2) u_e^T K_e u_e.",
                                    "Verifique dimensionalmente: U deve ter unidades de energia (Joules).",
                                    "Calcule U para um exemplo unidimensional simples (barra em tração)."
                                  ],
                                  "verification": "Derive e compute U para uma barra de comprimento L, módulo E, área A sob força P.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel e lápis para derivações, software simbólico como Mathematica ou SymPy (opcional), exemplos resolvidos de FEM.",
                                  "tips": "Comece com o caso 1D para ganhar confiança antes de generalizar.",
                                  "learningObjective": "Derivar a expressão quadrática de U em termos de deslocamentos.",
                                  "commonMistakes": "Esquecer o fator 1/2 na energia elástica ou usar tensão em vez de deformação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir o Trabalho Externo W e Formular Π = U - W",
                                  "subSteps": [
                                    "Expresse W = ∫_Γ_t u^T t dΓ + ∫_Ω u^T b dΩ, onde t são trações e b cargas volumétricas.",
                                    "No contexto discreto: W = u^T F, com F vetor de forças nodais.",
                                    "Estabeleça Π(u) = U(u) - W(u) como funcional de energia potencial total.",
                                    "Verifique que Π é uma forma quadrática: Π = (1/2) u^T K u - u^T F.",
                                    "Discuta a convexidade de Π para problemas elásticos lineares."
                                  ],
                                  "verification": "Escreva Π para o exemplo da barra 1D e confirme que coincide com a energia conhecida.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Folhas de derivação, tabela de integrais, referências sobre funcionais variacionais.",
                                  "tips": "Pense em W como o 'potencial' das forças externas, negativo para cargas de contorno.",
                                  "learningObjective": "Construir a expressão completa de Π combinando U e W.",
                                  "commonMistakes": "Inverter o sinal de W (deve ser subtraído) ou esquecer cargas volumétricas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar a Condição de Equilíbrio via Minimização Estacionária δΠ = 0",
                                  "subSteps": [
                                    "Compute a primeira variação δΠ = δU - δW.",
                                    "Mostre que δU = ∫_Ω δ ε^T σ dΩ e δW = ∫_Γ_t δ u^T t dΓ + ∫_Ω δ u^T b dΩ.",
                                    "Pelo PTV, δΠ = 0 implica K u = F para o caso discreto.",
                                    "Interprete δΠ = 0 como condição necessária para mínimo local de Π.",
                                    "Verifique a segunda variação δ²Π = δU > 0 para positividade."
                                  ],
                                  "verification": "Derive K u = F a partir de δΠ = 0 e resolva para o deslocamento de equilíbrio.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Software de álgebra simbólica, exemplos numéricos em MATLAB/Python para FEM simples.",
                                  "tips": "Ligue δΠ = 0 ao equilíbrio nodal: forças internas = forças externas.",
                                  "learningObjective": "Provar que o equilíbrio corresponde à minimização variacional de Π.",
                                  "commonMistakes": "Negligenciar condições de contorno na variação ou confundir δΠ com gradiente."
                                }
                              ],
                              "practicalExample": "Considere uma barra cantilever de comprimento L=1m, seção A=0.01m², E=200GPa, com carga P=1000N na ponta livre. Calcule U = (1/2) P² L / (A E), W = P δ (δ=L P/(A E)), Π = U - W. Minimize Π encontrando δ tal que dΠ/dδ=0, obtendo o deslocamento de equilíbrio δ_eq = P L / (A E).",
                              "finalVerifications": [
                                "Derivação correta de Π = U - W com expressões integrais.",
                                "Cálculo preciso de δΠ = 0 levando a K u = F.",
                                "Verificação numérica para um elemento 1D ou 2D simples.",
                                "Explicação conceitual do mínimo estacionário em termos físicos.",
                                "Confirmação da positividade da segunda variação δ²Π > 0.",
                                "Aplicação a um problema com condições mistas (deslocamento e força)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações de U, W e Π (30%).",
                                "Compreensão conceitual do princípio variacional vs. PTV (25%).",
                                "Capacidade de aplicar a um exemplo concreto e resolver numericamente (20%).",
                                "Identificação correta de erros comuns e hipóteses (15%).",
                                "Clareza na comunicação via diagramas e explicações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e métodos de otimização.",
                                "Física: Princípios energéticos em mecânica clássica.",
                                "Computação: Implementação em solvers FEM (ex: FEniCS, Abaqus).",
                                "Engenharia Civil: Análise de estruturas hiperestáticas."
                              ],
                              "realWorldApplication": "Na análise por elementos finitos (FEM), o princípio de minimização de Π fundamenta solvers como o método de Newton-Raphson para problemas não-lineares, usado no design de pontes, aviões e implantes médicos para prever deformações e falhas sob cargas reais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.3.2",
                            "name": "Aplicar o princípio de minimização no MEF",
                            "description": "Explicar como aproximar u por funções de interpolação no método de Rayleigh-Ritz, levando à minimização de Π aproximada e montagem das matrizes de rigidez e carga.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a energia potencial total Π e o princípio variacional",
                                  "subSteps": [
                                    "Revise a definição de energia potencial total Π = U - W, onde U é a energia deformacional e W é o trabalho das forças externas.",
                                    "Explique o teorema variacional: a solução exata u minimiza Π entre todas as funções admissíveis.",
                                    "Discuta como o método de Rayleigh-Ritz usa aproximações para encontrar uma solução estacionária.",
                                    "Identifique condições de contorno essenciais e naturais no contexto variacional.",
                                    "Esboce um diagrama conceitual de Π(u) mostrando o mínimo."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o papel de Π no MEF e desenhe o gráfico de minimização.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de MEF (ex: Bathe ou Zienkiewicz), caderno, calculadora simbólica.",
                                  "tips": "Lembre-se: minimização é para funções com contornos essenciais satisfeitos.",
                                  "learningObjective": "Entender o fundamento energético do MEF e o princípio de minimização.",
                                  "commonMistakes": "Confundir minimização com igualdade das equações diferenciais; ignorar contornos essenciais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e definir funções de interpolação para aproximar u",
                                  "subSteps": [
                                    "Escolha funções de forma N_i(ξ) completas e polinomiais adequadas ao elemento (ex: lineares para barra).",
                                    "Expresse a aproximação u_h(x) = ∑ N_i(x) u_i, onde u_i são graus de liberdade nodais.",
                                    "Verifique a propriedade de partição da unidade: ∑ N_i = 1.",
                                    "Aplique condições de contorno essenciais impondo u_i = valores conhecidos.",
                                    "Calcule derivadas das funções de forma para tensões/ deformações."
                                  ],
                                  "verification": "Escreva explicitamente u_h para um elemento 1D simples e verifique partição da unidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software simbólico (Mathematica ou SymPy), papel milimetrado.",
                                  "tips": "Use coordenadas naturais ξ para simplicidade em elementos padrão.",
                                  "learningObjective": "Dominar a aproximação de deslocamentos por funções de interpolação no Rayleigh-Ritz.",
                                  "commonMistakes": "Escolher funções que não satisfazem contornos essenciais; usar funções incompletas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Substituir a aproximação na expressão de Π para obter Π_h",
                                  "subSteps": [
                                    "Substitua u_h e suas derivadas na energia interna U = (1/2) ∫ ε^T D ε dV.",
                                    "Calcule o trabalho externo W = ∑ F_i u_i + ∫ t^T u_h dS.",
                                    "Formule Π_h = (1/2) u^T K u - F^T u, identificando K e F simbolicamente.",
                                    "Integre numericamente ou analiticamente sobre o elemento usando gaussiana se necessário.",
                                    "Simplifique para um elemento unidimensional como exemplo."
                                  ],
                                  "verification": "Derive Π_h para um elemento de barra e confirme forma quadrática.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora ou MATLAB/SymPy para integrais, exemplos resolvidos de livros.",
                                  "tips": "Mantenha simetria: K deve ser simétrica positiva definida.",
                                  "learningObjective": "Construir a funcional aproximada Π_h a partir da física do problema.",
                                  "commonMistakes": "Erros em integrais de deformações; esquecer termos de corpo ou tração."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o princípio de minimização em Π_h",
                                  "subSteps": [
                                    "Compute a variação δΠ_h = 0 ou derivadas parciais ∂Π_h / ∂u_i = 0.",
                                    "Mostre que isso leva a K u = F para graus de liberdade livres.",
                                    "Interprete: linhas de K u = forças nodais equivalentes.",
                                    "Discuta convergência: Π_h ≥ Π exata, com igualdade no limite.",
                                    "Resolva um sistema pequeno manualmente para validar."
                                  ],
                                  "verification": "Resolva ∂Π_h / ∂u_i = 0 e obtenha as equações de equilíbrio.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Matriz solver manual ou Python/Octave.",
                                  "tips": "Use índice livre para derivadas: ∂/∂u_j de (1/2)∑∑ k_mn u_m u_n.",
                                  "learningObjective": "Derivar as equações discretas via minimização variacional.",
                                  "commonMistakes": "Negligenciar fatores 1/2 na derivação; confundir u livres e impostos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Montar e interpretar as matrizes de rigidez [K] e carga [F]",
                                  "subSteps": [
                                    "Extraia [K]_e = ∫ B^T D B dV e [F]_e de W para cada elemento.",
                                    "Monte a matriz global por superposição nodal.",
                                    "Aplique contornos naturais via [F] e essenciais via modificação de [K].",
                                    "Verifique propriedades: simetria, definitude positiva, consistência nodal.",
                                    "Compare com formulações por forças residuais."
                                  ],
                                  "verification": "Monte [K] e [F] para um malha de 2 elementos e resolva u.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Planilha Excel ou código MEF simples, exemplos numéricos.",
                                  "tips": "Use transformação de coordenadas para elementos 2D/3D.",
                                  "learningObjective": "Construir e assemblar matrizes do sistema global via minimização.",
                                  "commonMistakes": "Erros de indexação na montagem global; rigidez singular por falta de contornos."
                                }
                              ],
                              "practicalExample": "Para uma barra axial de comprimento L, seção A, módulo E, carga F no nó 2: funções lineares N1=1-ξ, N2=ξ (ξ=x/L). Π_h = (EA/2L) (u2-u1)^2 - F u2. Minimização: ∂/∂u1 → (EA/L)(u1-u2)=0; ∂/∂u2 → (EA/L)(u2-u1)=F. Matriz K = (EA/L)[1 -1; -1 1], F=[0;F].",
                              "finalVerifications": [
                                "Deriva corretamente Π_h e suas variações para um elemento dado.",
                                "Monta matrizes [K]_e e [F]_e idênticas às fórmulas padrão.",
                                "Explica convergência do Rayleigh-Ritz via minimização.",
                                "Aplica contornos corretamente sem rigidez singular.",
                                "Valida numericamente com solução analítica simples.",
                                "Identifica erros comuns em uma derivação alheia."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação de Π_h (90% correto).",
                                "Corretude das derivadas de minimização e equações resultantes.",
                                "Montagem global sem erros de indexação.",
                                "Interpretação física das matrizes K e F.",
                                "Criatividade em extensão para elementos não-lineares.",
                                "Tempo de resolução eficiente com verificações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e métodos de aproximação polinomial.",
                                "Física: Princípios de energia em mecânica dos sólidos.",
                                "Computação: Implementação numérica em Python/MATLAB para solvers.",
                                "Engenharia Civil: Análise de estruturas via software comercial (ANSYS).",
                                "Otimização: Métodos de minimização quadrática."
                              ],
                              "realWorldApplication": "No projeto de pontes ou aviões, o MEF usa minimização para simular tensões em milhões de nós, otimizando peso e segurança sem protótipos físicos caros, como na análise da asa de um Boeing 787."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.3.3",
                            "name": "Derivar a equação de equilíbrio a partir de δΠ = 0",
                            "description": "Mostrar que a variação δΠ = 0 resulta em ∫_Ω δ ε^T D ε dΩ = δ W, equivalente às equações de equilíbrio virtual do princípio dos trabalhos virtuais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Recordar a definição da energia potencial total Π",
                                  "subSteps": [
                                    "Defina a energia de deformação interna U como U = ∫_Ω (1/2) ε^T D ε dΩ, onde ε é o vetor de deformações, D a matriz de rigidez elástica e Ω o domínio.",
                                    "Defina o potencial dos carregamentos externos W = ∫_Ω u^T b dΩ + ∫_Γ t^T u dΓ + Σ F_i^T u_i, onde u é o deslocamento, b forças volumétricas, t trações e F_i forças puntiformes.",
                                    "Estabeleça Π = U - W como a energia potencial total do sistema elástico.",
                                    "Verifique a consistência das notações matriciais e os limites de integração.",
                                    "Esboce um diagrama simples do domínio Ω com contornos Γ."
                                  ],
                                  "verification": "Escrever corretamente as expressões exatas de U, W e Π em um caderno ou software de anotações.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Livro-texto de Elementos Finitos (ex: Zienkiewicz), caderno, calculadora simbólica (Mathematica ou papel).",
                                  "tips": "Mantenha a notação consistente: use ε para deformações cinemáticas e σ = D ε para tensões.",
                                  "learningObjective": "Compreender a composição física e matemática da energia potencial total em problemas elásticos.",
                                  "commonMistakes": "Confundir o sinal de W (deve ser subtraído), esquecer termos de contorno ou forças puntiformes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a primeira variação δΠ",
                                  "subSteps": [
                                    "Compute δΠ = δU - δW, onde δ denota variação arbitrária.",
                                    "Derive δU = ∫_Ω δ ε^T D ε dΩ, justificando que δ(1/2 ε^T D ε) = δ ε^T D ε para variações lineares.",
                                    "Derive δW = ∫_Ω δ u^T b dΩ + ∫_Γ δ u^T t dΓ + Σ δ u_i^T F_i, assumindo variações δu admissíveis (cinematicamente admissíveis).",
                                    "Expresse δ ε em termos de δ u via operador de deformação B, i.e., δ ε = B δ u.",
                                    "Substitua para obter δΠ = ∫_Ω (B δ u)^T D (B u) dΩ - δW."
                                  ],
                                  "verification": "Derivar e simplificar δΠ corretamente, mostrando δU = ∫ δ ε^T σ dΩ com σ = D ε.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel milimetrado, lápis, referências de cálculo variacional.",
                                  "tips": "Use a propriedade de simetria de D e linearidade para simplificar variações.",
                                  "learningObjective": "Dominar o cálculo da variação funcional da energia potencial.",
                                  "commonMistakes": "Esquecer o fator 1/2 na derivação de δU (não aparece pois δ(1/2 x^2)=x δx), ou inverter δU e δW."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a condição de estacionariedade δΠ = 0",
                                  "subSteps": [
                                    "Estabeleça δΠ = 0 para todo δu admissível: ∫_Ω δ ε^T D ε dΩ = δW.",
                                    "Reescreva como ∫_Ω δ ε^T σ dΩ = ∫_Ω δ u^T b dΩ + ∫_Γ δ u^T t dΓ + Σ δ u_i^T F_i.",
                                    "Reconheça que o lado esquerdo é o trabalho virtual interno e o direito o externo.",
                                    "Integre por partes o lado esquerdo para obter forma fraca: -∫_Ω ε(δu)^T div σ dΩ + termos de contorno = δW.",
                                    "Conclua que para δu arbitrário, div σ + b = 0 em Ω (equilíbrio local)."
                                  ],
                                  "verification": "Escrever explicitamente ∫_Ω δ ε^T D ε dΩ = δW e relacionar com trabalhos virtuais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software simbólico (SymPy ou Maple) para verificação, quadro branco.",
                                  "tips": "Escolha δu = 0 em Γ_u (suportes) para isolar equilíbrios.",
                                  "learningObjective": "Entender como δΠ=0 implica o princípio dos trabalhos virtuais.",
                                  "commonMistakes": "Não especificar que δu é cinematicamente admissível, ou falhar na integração por partes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar como equações de equilíbrio virtual",
                                  "subSteps": [
                                    "Identifique δΠ=0 como o Princípio dos Trabalhos Virtuais (PTV): δW_int = δW_ext.",
                                    "Mostre equivalência com equações de equilíbrio forte: ∇·σ + b = 0 em Ω, σ·n = t em Γ_t.",
                                    "Discuta condições de contorno essenciais (δu=0) vs. naturais (emergem do PTV).",
                                    "Verifique para um caso 1D simples: barra axial, onde reduz a k u = F.",
                                    "Resuma a minimização variacional como base para discretização em FEM."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito a ligação entre δΠ=0, PTV e equilíbrio.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Exemplo numérico simples (barra), simulador FEM básico (ex: FEniCS online).",
                                  "tips": "Use testes de Gallerkin para validar: peso δu nas equações diferenciais.",
                                  "learningObjective": "Relacionar derivação variacional com formulações clássicas de equilíbrio.",
                                  "commonMistakes": "Confundir equilíbrio forte (pontual) com fraco (integral), ignorar contornos."
                                }
                              ],
                              "practicalExample": "Considere uma barra axial 1D de comprimento L, seção A, módulo E, carga F na ponta livre. Π = (1/2) (EA/L) u^2 - F u. δΠ = (EA/L) u δu - F δu = 0 ⇒ (EA/L) u = F, que é a equação de equilíbrio ku = F.",
                              "finalVerifications": [
                                "Expressão correta de Π = U - W com todos os termos.",
                                "Derivação precisa de δΠ = ∫_Ω δ ε^T D ε dΩ - δW.",
                                "Condição δΠ = 0 escrita como igualdade de trabalhos virtuais.",
                                "Interpretação correta como PTV e ligação com div σ + b = 0.",
                                "Verificação em exemplo 1D ou 2D simples.",
                                "Discussão de admissibilidade de δu."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de δΠ (peso 30%).",
                                "Correta separação e balanceamento de δU e δW (peso 25%).",
                                "Interpretação física do PTV e equilíbrio (peso 20%).",
                                "Tratamento de condições de contorno (peso 15%).",
                                "Exemplo prático resolvido corretamente (peso 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Variacional (Matemática Avançada): derivações funcionais.",
                                "Mecânica dos Meios Contínuos (Física): princípios energéticos.",
                                "Programação Numérica (Computação): implementação em solvers FEM.",
                                "Análise Numérica (Matemática): métodos de Gallerkin."
                              ],
                              "realWorldApplication": "Esta derivação fundamenta os solvers de elementos finitos em softwares como ANSYS, Abaqus e COMSOL, essenciais para análise estrutural de aviões, pontes, carros e implantes médicos, garantindo equilíbrio sob cargas reais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.3.4",
                            "name": "Resolver exemplo simples de minimização",
                            "description": "Aplicar a minimização de Π para um sistema discreto com 1 ou 2 graus de liberdade, resolvendo o sistema K u = F.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e descrever o sistema discreto simples",
                                  "subSteps": [
                                    "Escolha um sistema com 1 ou 2 graus de liberdade (DOF), como uma mola única (1 DOF) ou duas molas em série (2 DOF).",
                                    "Defina os parâmetros: rigidez k, forças F e condições de contorno.",
                                    "Desenhe o esquema do sistema, identificando os nós e elementos.",
                                    "Escreva as equações de equilíbrio estático esperadas para referência futura.",
                                    "Liste os deslocamentos desconhecidos u (u1 para 1 DOF, u1 e u2 para 2 DOF)."
                                  ],
                                  "verification": "Confirme que o diagrama está completo e os DOF estão corretamente identificados, sem ambiguidades.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, lápis, calculadora básica",
                                  "tips": "Comece com 1 DOF para simplicidade antes de expandir para 2 DOF.",
                                  "learningObjective": "Compreender a discretização do problema físico em DOF finitos.",
                                  "commonMistakes": "Esquecer condições de contorno ou confundir forças nodais com distribuídas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a energia potencial total Π",
                                  "subSteps": [
                                    "Escreva a energia de deformação U para cada elemento (ex: U = (1/2) k u^2 para mola).",
                                    "Some as energias de todos os elementos para obter U total.",
                                    "Escreva o trabalho das forças externas V = -F · u.",
                                    "Formule Π = U + V explicitamente em termos dos DOF.",
                                    "Verifique dimensionalmente: Π deve ter unidades de energia (Joules)."
                                  ],
                                  "verification": "A expressão de Π deve ser uma função quadrática em u, com termo (1/2) u^T K u - F^T u.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel quadriculado, calculadora",
                                  "tips": "Use notação matricial mesmo para casos pequenos para praticar generalização.",
                                  "learningObjective": "Construir a expressão variacional da energia potencial.",
                                  "commonMistakes": "Inverter o sinal do trabalho das forças ou duplicar energias de elementos compartilhados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar a minimização variacional de Π",
                                  "subSteps": [
                                    "Compute as derivadas parciais ∂Π/∂u_i para cada DOF i.",
                                    "Iguale cada ∂Π/∂u_i = 0, obtendo as equações do sistema.",
                                    "Monte a matriz de rigidez K e vetor de forças F a partir das derivadas.",
                                    "Resolva o sistema linear K u = F analiticamente.",
                                    "Substitua os valores numéricos dos parâmetros para obter u numérico."
                                  ],
                                  "verification": "As equações ∂Π/∂u_i = 0 devem coincidir exatamente com K u = F.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora científica ou software como MATLAB/Octave para 2 DOF",
                                  "tips": "Para 2 DOF, resolva o sistema 2x2 invertendo K ou por eliminação gaussiana.",
                                  "learningObjective": "Aplicar o princípio variacional para derivar equações de equilíbrio.",
                                  "commonMistakes": "Erros de sinal nas derivadas ou falha em aplicar condições de contorno nas equações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e interpretar os resultados",
                                  "subSteps": [
                                    "Calcule Π no ponto mínimo e compare com valores esperados.",
                                    "Verifique equilíbrio nodal: some forças em cada nó para zero.",
                                    "Compare u obtido com solução direta de K u = F.",
                                    "Analise sensibilidade: varie k ou F e observe impacto em u.",
                                    "Discuta limitações do modelo (ex: linearidade assumida)."
                                  ],
                                  "verification": "u satisfaz K u = F com tolerância <1% e Π é mínimo (segunda derivada positiva).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora, gráfico de Π vs u (opcional)",
                                  "tips": "Plote Π vs u para visualizar o mínimo parabólico.",
                                  "learningObjective": "Validar a solução variacional e conectar à mecânica clássica.",
                                  "commonMistakes": "Não verificar o equilíbrio ou ignorar singularidade em K se mal condicionado."
                                }
                              ],
                              "practicalExample": "Para 1 DOF: mola k=100 N/m, F=10 N em u. Π = (1/2)*100*u^2 - 10*u. Minimização: dΠ/du=100u-10=0 → u=0.1 m. Para 2 DOF: duas molas k1=100, k2=200 N/m em série, F2=10 N em u2 (u1 fixo=0). Π = (1/2)*100*u1^2 + (1/2)*200*(u2-u1)^2 - 10*u2 → K=[[100+200, -200],[-200,200]], u=[0, 0.1] m.",
                              "finalVerifications": [
                                "A expressão de Π é corretamente formulada como quadrática.",
                                "Derivadas parciais levam exatamente a K u = F.",
                                "Solução u satisfaz equilíbrio nodal.",
                                "Valor mínimo de Π é negativo ou zero conforme esperado.",
                                "Segunda derivada (Hessiana) é positiva definida (K positiva definida).",
                                "Resultados numéricos coincidem com solução analítica direta."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação de Π (100% dos termos corretos).",
                                "Correção das derivadas e montagem de K/F (sem erros de sinal).",
                                "Solução exata do sistema linear.",
                                "Verificações completas e interpretação física.",
                                "Uso eficiente de notação matricial.",
                                "Análise de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e resolução de sistemas lineares.",
                                "Física: Princípio dos trabalhos virtuais e energia potencial em mecânica.",
                                "Programação: Implementação em Python/MATLAB para automação.",
                                "Engenharia Civil: Análise de estruturas isostáticas.",
                                "Otimização: Métodos de minimização em problemas convexos."
                              ],
                              "realWorldApplication": "Na análise de elementos finitos em softwares como ANSYS ou NASTRAN, a minimização da energia potencial total Π é o cerne do solver estático, usada para prever deformações em pontes, aviões e implantes médicos sob cargas reais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.2",
                "name": "Métodos de Rayleigh-Ritz e Galerkin",
                "description": "Princípios dos métodos variacionais aplicados à formulação do método dos elementos finitos.",
                "totalSkills": 39,
                "atomicTopics": [
                  {
                    "id": "10.1.2.1",
                    "name": "Energia Potencial Total",
                    "description": "Conceito fundamental de energia potencial total em sistemas elásticos, incluindo contribuições de deformação e carregamento.",
                    "individualConcepts": [
                      {
                        "id": "34.1.2.1.1",
                        "name": "Energia de Deformação em Sistemas Elásticos",
                        "description": "Conceito de energia armazenada devido às deformações no material elástico, expressa como integral do produto tensão-deformação sobre o volume do corpo.",
                        "specificSkills": [
                          {
                            "id": "34.1.2.1.1.1",
                            "name": "Definir a energia de deformação unitária",
                            "description": "Explicar a expressão matemática da densidade de energia de deformação para materiais lineares elásticos, incluindo o papel das equações constitutivas de Hooke.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Tensão e Deformação Elástica",
                                  "subSteps": [
                                    "Defina tensão (σ) como força por unidade de área e deformação (ε) como mudança relativa de comprimento.",
                                    "Explique a linearidade em materiais elásticos: relação proporcional entre σ e ε abaixo do limite elástico.",
                                    "Discuta o tensor de tensão e deformação em 3D para contexto geral.",
                                    "Identifique componentes normais e cisalhantes.",
                                    "Relacione com o diagrama tensão-deformação para materiais lineares."
                                  ],
                                  "verification": "Escreva definições precisas de tensão e deformação e desenhe um diagrama tensão-deformação uniaxial correto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro-texto de Resistência dos Materiais (ex: Beer & Johnston)",
                                    "Folha de papel e caneta para diagramas"
                                  ],
                                  "tips": "Use analogias como molas para visualizar elasticidade linear.",
                                  "learningObjective": "Compreender os fundamentos de tensão e deformação como pré-requisitos para energia de deformação.",
                                  "commonMistakes": "Confundir tensão com força total ou deformação com deslocamento absoluto."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar as Equações Constitutivas de Hooke",
                                  "subSteps": [
                                    "Apresente a lei de Hooke uniaxial: σ = E ε, onde E é o módulo de elasticidade.",
                                    "Estenda para 3D: σ_ij = C_ijkl ε_kl, com C como tensor de rigidez.",
                                    "Discuta formas invertidas: ε_ij = S_ijkl σ_kl, com S como tensor de compliance.",
                                    "Explique simetria e independência para materiais isotrópicos (2 constantes: E e ν).",
                                    "Derive expressões para tensão em termos de deformação."
                                  ],
                                  "verification": "Escreva as equações de Hooke para casos uniaxial e isotrópico 3D sem consultar notas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notas de aula sobre Mecânica dos Sólidos",
                                    "Software simbólico como Mathematica ou SymPy para verificação"
                                  ],
                                  "tips": "Memorize a matriz de Hooke para planos de tensão para prática rápida.",
                                  "learningObjective": "Dominar as relações constitutivas que ligam tensão e deformação em elásticos lineares.",
                                  "commonMistakes": "Esquecer o fator 1/2 na energia ou confundir E com G (módulo de cisalhamento)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Densidade de Energia de Deformação Unitária",
                                  "subSteps": [
                                    "Defina densidade de energia de deformação (u) como trabalho armazenado por unidade de volume.",
                                    "Mostre que para carregamento proporcional, du = σ_ij dε_ij.",
                                    "Integre para elásticos lineares: u = (1/2) σ_ij ε_ij.",
                                    "Substitua Hooke: u = (1/2) ε_ij C_ijkl ε_kl.",
                                    "Verifique para caso uniaxial: u = (1/2) σ ε = (1/2) E ε²."
                                  ],
                                  "verification": "Derive a expressão u = (1/2) σ : ε a partir do trabalho incremental e confirme com uniaxial.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Caderno para derivações matemáticas",
                                    "Referência: Livro de Elementos Finitos (ex: Zienkiewicz)"
                                  ],
                                  "tips": "Use notação de Einstein para tensores para simplificar índices.",
                                  "learningObjective": "Explicar matematicamente a energia de deformação unitária e seu vínculo com Hooke.",
                                  "commonMistakes": "Omitir o 1/2 ao integrar o trabalho ou usar deformação total em vez de incremental."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Integrar a Energia de Deformação em Sistemas Elásticos",
                                  "subSteps": [
                                    "Calcule a energia total U = ∫ u dV sobre o volume do corpo.",
                                    "Discuta seu papel na energia potencial total: Π = U - W, onde W é trabalho externo.",
                                    "Relacione com métodos variationais como Rayleigh-Ritz.",
                                    "Implemente numericamente para um elemento simples.",
                                    "Analise sensibilidade a parâmetros materiais."
                                  ],
                                  "verification": "Compute u para um estado de tensão dado e integre para U em uma barra uniaxial.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB para integração numérica",
                                    "Exemplos de problemas resolvidos"
                                  ],
                                  "tips": "Comece com 1D antes de generalizar para 3D para construir confiança.",
                                  "learningObjective": "Integrar a densidade unitária em formulações de energia para análise elástica.",
                                  "commonMistakes": "Confundir densidade unitária (u) com energia total (U) ou ignorar limites de integração."
                                }
                              ],
                              "practicalExample": "Para uma barra uniaxial de aço (E=200 GPa) com ε=0.001, calcule u = (1/2) E ε² = 0.1 MJ/m³. Em um elemento finito, integre u sobre o volume para obter contribuição à rigidez da estrutura.",
                              "finalVerifications": [
                                "Escreva corretamente u = (1/2) σ_ij ε_ij.",
                                "Derive u a partir de Hooke para tensão uniaxial e plano.",
                                "Calcule u numericamente para um exemplo dado com precisão <1%.",
                                "Explique o papel de u na minimização da energia potencial.",
                                "Identifique quando a hipótese de linearidade falha.",
                                "Compare u para diferentes materiais isotrópicos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação matemática (fórmulas corretas com 1/2).",
                                "Compreensão conceitual: ligação clara entre Hooke e energia.",
                                "Habilidade em calcular u para casos 1D e 3D simples.",
                                "Uso correto de notação tensorial.",
                                "Aplicação em contexto de elementos finitos.",
                                "Identificação de limitações (ex: não-linearidades)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e tensores.",
                                "Física: Princípios de conservação de energia em sólidos.",
                                "Computação: Implementação em código para simulações FEM.",
                                "Química dos Materiais: Dependência de u em propriedades microestruturais."
                              ],
                              "realWorldApplication": "Na análise de elementos finitos para design de pontes ou aviões, u é usada para montar matrizes de rigidez, prevendo deformações sob carga e otimizando contra falhas elásticas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.1.2.1.1.2",
                            "name": "Calcular energia de deformação em problemas 1D",
                            "description": "Derivar e computar a energia total de deformação U em barras ou treliças unidimensionais submetidas a deformações axiais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Fundamentais de Energia de Deformação",
                                  "subSteps": [
                                    "Revise a definição de deformação axial em barras unidimensionais: ε = ΔL / L.",
                                    "Estude o trabalho realizado pela força interna durante a deformação.",
                                    "Compreenda que a energia de deformação U é o trabalho armazenado elásticamente: U = ∫ F dx.",
                                    "Identifique a relação com tensão σ e deformação ε via lei de Hooke: σ = E ε.",
                                    "Derive a expressão básica U = (1/2) F ΔL para deformação linear."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como a energia é conservada em um sistema elástico uniaxial.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Livro de Resistência dos Materiais (ex: Beer & Johnston)",
                                    "Folha de papel e caneta",
                                    "Vídeo tutorial sobre energia elástica"
                                  ],
                                  "tips": "Visualize a deformação como uma mola comprimida para intuitar o armazenamento de energia.",
                                  "learningObjective": "Compreender os princípios físicos da energia de deformação axial em sólidos elásticos.",
                                  "commonMistakes": [
                                    "Confundir energia de deformação com trabalho externo total",
                                    "Ignorar o fator 1/2 na fórmula linear",
                                    "Esquecer que é válida apenas para comportamento elástico linear"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Fórmula Geral para Energia de Deformação em Barras 1D",
                                  "subSteps": [
                                    "Comece com a tensão σ(x) = F(x)/A em uma seção transversal.",
                                    "Expresse a deformação ε(x) = σ(x)/E.",
                                    "Integre o trabalho diferencial: dU = σ ε dV = (σ² / (2E)) dV.",
                                    "Para barra 1D uniforme: U = ∫₀ᴸ (F² / (2 A² E)) A dx = (F² L) / (2 A E).",
                                    "Generalize para campo de deslocamento u(x): U = (1/2) ∫₀ᴸ E A (du/dx)² dx."
                                  ],
                                  "verification": "Derive a fórmula U = (1/2) k Δ² onde k = AE/L e compare com resultados conhecidos.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico como SymPy",
                                    "Quadro branco ou software de desenho (ex: GeoGebra)",
                                    "Notas de aula sobre métodos variacionais"
                                  ],
                                  "tips": "Use integração por partes para conectar com o método dos elementos finitos.",
                                  "learningObjective": "Derivar matematicamente a expressão integral da energia de deformação para problemas 1D.",
                                  "commonMistakes": [
                                    "Erros na integração: esquecer limites ou fator 1/2",
                                    "Confundir volume diferencial dV com dx em 1D",
                                    "Não considerar variação de A ou E ao longo da barra"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar Energia em Problema de Barra Simples",
                                  "subSteps": [
                                    "Defina o problema: barra de comprimento L=2m, A=0.01m², E=200GPa, F=10kN axial.",
                                    "Calcule deformação ΔL = F L / (A E).",
                                    "Aplique U = (1/2) F ΔL.",
                                    "Verifique unidades: J = N·m.",
                                    "Compare com forma integral para uniformidade."
                                  ],
                                  "verification": "O valor de U deve ser aproximadamente 0.05 J; confira cálculos passo a passo.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Planilha Excel ou Python para automação",
                                    "Exemplo resolvido de livro-texto"
                                  ],
                                  "tips": "Sempre converta unidades consistentemente (kN para N, GPa para Pa).",
                                  "learningObjective": "Aplicar fórmulas derivadas para calcular numericamente U em casos simples.",
                                  "commonMistakes": [
                                    "Inconsistência de unidades (ex: MPa vs Pa)",
                                    "Usar F em vez de (1/2)F",
                                    "Arredondamentos prematuros levando a erros"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estender para Treliças e Verificação",
                                  "subSteps": [
                                    "Monte uma treliça simples com 2 barras conectadas.",
                                    "Determine forças internas via equilíbrio estático.",
                                    "Some U_i = Σ (F_i² L_i)/(2 A_i E_i) para cada barra.",
                                    "Implemente em código simples ou planilha para automação.",
                                    "Compare com energia potencial total Π = U - W_ext."
                                  ],
                                  "verification": "A soma de U deve igualar o trabalho externo menos energia cinética (zero em estático).",
                                  "estimatedTime": "25-40 minutos",
                                  "materials": [
                                    "Software FEA básico como FreeCAD",
                                    "Python com NumPy",
                                    "Diagrama de treliça impresso"
                                  ],
                                  "tips": "Desenhe free-body diagrams para forças antes de calcular U.",
                                  "learningObjective": "Calcular energia total em sistemas multicomponentes como treliças 1D.",
                                  "commonMistakes": [
                                    "Esquecer forças de reação em nós",
                                    "Sinal errado em forças compressivas (U sempre positiva)",
                                    "Não somar corretamente sobre todos elementos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma treliça de ponte simples com duas barras de aço (L1=3m, A1=0.02m², E=210GPa; L2=4m, A2=0.015m²), cargas nodais de 20kN levam a F1=15kN tração e F2=10kN compressão. Calcule U_total = (15e3² * 3)/(2*0.02*210e9) + (10e3² * 4)/(2*0.015*210e9) ≈ 0.152 J.",
                              "finalVerifications": [
                                "Energia U é sempre positiva e finita para deformações elásticas.",
                                "Unidades corretas: Joules (N·m).",
                                "Para barra uniforme, U = (1/2) F ΔL bate com integral.",
                                "Em treliças, soma de U_i equals energia total deformação.",
                                "Consistência com princípio de energia mínima (estacionariedade).",
                                "Valores numéricos precisos até 3 casas decimais."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (integral correta).",
                                "Correção numérica nos cálculos (erro <1%).",
                                "Uso apropriado de unidades SI.",
                                "Identificação correta de forças em treliças.",
                                "Explicação clara da física envolvida.",
                                "Aplicação coerente em exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Física: Princípio de conservação de energia e trabalho-energia.",
                                "Matemática: Cálculo integral e métodos variacionais (Rayleigh-Ritz).",
                                "Programação: Implementação numérica em Python/MATLAB para FEA.",
                                "Química dos Materiais: Dependência de E em propriedades microestruturais.",
                                "Engenharia Civil: Análise de estruturas como vigas e cabos."
                              ],
                              "realWorldApplication": "Na análise de elementos finitos para projetos de pontes, edifícios e máquinas, onde a energia de deformação é minimizada para otimizar rigidez e prever falhas por fadiga em componentes axiais como tirantes e colunas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.1.2.1.1.3",
                            "name": "Generalizar para estados de tensão 3D",
                            "description": "Estender o cálculo da energia de deformação para tensões e deformações tridimensionais, considerando o tensor de tensão e deformação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Tensores de Tensão e Deformação em 3D",
                                  "subSteps": [
                                    "Estudar a representação matricial do tensor de tensão σ (6 componentes independentes em materiais isotrópicos).",
                                    "Analisar o tensor de deformação ε simétrico e sua relação com deslocamentos via gradiente.",
                                    "Identificar os componentes normais (σ_xx, σ_yy, σ_zz) e cisalhantes (σ_xy, σ_xz, σ_yz).",
                                    "Praticar notação de Einstein para contração tensorial σ_ij ε_ij.",
                                    "Resolver exercícios simples de transformação de tensores sob rotação."
                                  ],
                                  "verification": "Conseguir representar corretamente um estado de tensão 3D dado e calcular suas invariantes principais.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro de Mecânica dos Sólidos (Timoshenko), notas de aula sobre tensores, calculadora matricial.",
                                  "tips": "Use diagramas cúbicos para visualizar os componentes de tensão em um elemento infinitesimal.",
                                  "learningObjective": "Compreender a estrutura matemática dos tensores 3D para energia de deformação.",
                                  "commonMistakes": "Confundir tensão com deformação ou ignorar a simetria dos tensores."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Energia de Deformação Uniaxial para Casos Multiaxiais",
                                  "subSteps": [
                                    "Partir da energia uniaxial U = (1/2) σ ε V e generalizar para 3D via superposição.",
                                    "Introduzir a lei de Hooke generalizada σ_ij = C_ijkl ε_kl para materiais lineares.",
                                    "Derivar a energia total U = (1/2) ∫ σ_ij ε_ij dV sobre o volume.",
                                    "Simplificar para materiais isotrópicos usando módulo de Young E e coeficiente de Poisson ν.",
                                    "Verificar com caso plano de tensão (σ_zz = 0)."
                                  ],
                                  "verification": "Derivar corretamente a expressão U = (1/2) ε^T [K] ε para um elemento, onde [K] é a matriz de rigidez.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Software simbólico como Mathematica ou SymPy, quadro branco para derivações.",
                                  "tips": "Lembre-se que a energia é sempre positiva definida; teste com ε pequeno.",
                                  "learningObjective": "Estender a fórmula escalar 1D para a forma tensorial 3D.",
                                  "commonMistakes": "Esquecer o fator 1/2 ou integrar incorretamente sobre o volume."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Cálculo Numérico da Energia em 3D",
                                  "subSteps": [
                                    "Discretizar um domínio simples (ex: cubo) em elementos finitos com funções de interpolação lineares.",
                                    "Calcular deformações ε em pontos de Gauss usando B-matrix (∇N).",
                                    "Montar a integral numérica ∫ σ^T ε dV ≈ ∑ w_i σ_i^T ε_i det(J).",
                                    "Codificar em Python/MATLAB para um estado de tensão conhecido.",
                                    "Comparar com solução analítica para validação."
                                  ],
                                  "verification": "Código roda sem erros e resulta em energia coincidente com analítica (±1%).",
                                  "estimatedTime": "4 horas",
                                  "materials": "Python com NumPy/SciPy, tutoriais de FEM (ex: FEniCS ou código template).",
                                  "tips": "Comece com malha 1x1x1 para depuração antes de refinar.",
                                  "learningObjective": "Aplicar a generalização em contexto computacional de Rayleigh-Ritz/Galerkin.",
                                  "commonMistakes": "Erro na matriz B ou esquecimento do determinante do Jacobiano."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar na Energia Potencial Total e Verificar Consistência",
                                  "subSteps": [
                                    "Combinar U com energia de carregamento externa Π = -∫ t u dS - ∫ b u dV.",
                                    "Estacionar Π total para obter equações de equilíbrio via Rayleigh-Ritz.",
                                    "Testar em problema benchmark: tração uniaxial 3D e torção.",
                                    "Analisar sensibilidade a ν e estados hidrostáticos.",
                                    "Documentar resultados em relatório com gráficos de contorno."
                                  ],
                                  "verification": "Equações de equilíbrio recuperam o caso conhecido e energia converge com refinamento de malha.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Software FEM como Abaqus/ANSYS trial ou código customizado, papel para sketches.",
                                  "tips": "Use simetria para reduzir dimensões em testes iniciais.",
                                  "learningObjective": "Conectar energia 3D à formulação variacional de elementos finitos.",
                                  "commonMistakes": "Inverter sinal da energia potencial ou negligenciar termos de corpo."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Explorar Casos Avançados e Limitações",
                                  "subSteps": [
                                    "Estender para grandes deformações (Green-Lagrange strain).",
                                    "Discutir anisotropia e hiperelasticidade básica.",
                                    "Simular falha por energia crítica (von Mises).",
                                    "Comparar com dados experimentais de um teste 3D.",
                                    "Refletir sobre hipóteses lineares elásticas."
                                  ],
                                  "verification": "Identificar corretamente limitações em pelo menos 3 cenários não-lineares.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Artigos IEEE sobre FEM 3D, dados experimentais online.",
                                  "tips": "Foque em invariantos para generalizações.",
                                  "learningObjective": "Reconhecer extensões e limites da teoria linear 3D.",
                                  "commonMistakes": "Aplicar linearidade a problemas geométricos não-lineares."
                                }
                              ],
                              "practicalExample": "Calcule a energia de deformação em um cubo de aço (E=200 GPa, ν=0.3) sob tensão hidrostática σ_xx=σ_yy=σ_zz=100 MPa, usando integração numérica em 2x2x2 Gauss points, e verifique contra fórmula analítica U = (1-2ν) σ^2 V / E.",
                              "finalVerifications": [
                                "Derivação da forma tensorial σ_ij ε_ij sem erros.",
                                "Código numérico converge para solução exata em malha fina.",
                                "Recupera casos 1D/2D como limites especiais.",
                                "Energia positiva e invariante sob rotação.",
                                "Integração correta na minimização de Π para equilíbrio.",
                                "Identifica limitações para não-linearidades."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (100% correta).",
                                "Implementação computacional funcional e validada.",
                                "Explicação clara de conexões com Rayleigh-Ritz/Galerkin.",
                                "Análise de erros comuns e mitigação.",
                                "Criatividade em exemplos práticos 3D.",
                                "Profundidade em conexões interdisciplinares."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra tensorial e cálculo variacional.",
                                "Física: Termodinâmica de deformação elástica.",
                                "Computação: Programação numérica e otimização (métodos de elementos finitos).",
                                "Engenharia Civil: Análise de estruturas sob cargas sísmicas 3D.",
                                "Materiais: Comportamento viscoelástico em simulações."
                              ],
                              "realWorldApplication": "Em análise de elementos finitos para projetos aeronáuticos, como asas de aviões sob cargas aerodinâmicas multidirecionais, onde a energia de deformação 3D garante precisão na previsão de falhas e otimização de peso."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.2.1.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "34.1.2.1.2",
                        "name": "Energia Potencial dos Carregamentos",
                        "description": "Contribuição negativa do trabalho realizado pelos carregamentos externos e deslocamentos impostos na formulação variacional.",
                        "specificSkills": [
                          {
                            "id": "34.1.2.1.2.1",
                            "name": "Expressar o potencial de carga para forças nodais",
                            "description": "Formular o termo de potencial W como produto escalar entre vetores de deslocamento e forças nodais concentradas em nós.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Potencial de Carga em MEF",
                                  "subSteps": [
                                    "Revise a energia potencial total Π = U + W, onde U é a energia de deformação e W é o potencial dos carregamentos.",
                                    "Entenda que W representa o trabalho virtual realizado pelas forças externas nos deslocamentos.",
                                    "Diferencie forças distribuídas de forças nodais concentradas nos métodos de Rayleigh-Ritz e Galerkin.",
                                    "Estude a convenção de sinal: W é negativo para forças que fazem trabalho positivo.",
                                    "Analise exemplos qualitativos de como forças nodais contribuem para o equilíbrio energético."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que W é negativo e sua relação com o princípio dos trabalhos virtuais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Elementos Finitos (ex: Bathe ou Zienkiewicz), notas de aula sobre energia potencial.",
                                  "tips": "Desenhe diagramas de corpo livre para visualizar forças e deslocamentos.",
                                  "learningObjective": "Dominar o papel físico e matemático do potencial de carga W no contexto de MEF.",
                                  "commonMistakes": "Confundir sinal de W (positivo em vez de negativo) ou ignorar a dependência nodal."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Vetores de Deslocamento e Forças Nodais",
                                  "subSteps": [
                                    "Identifique os graus de liberdade (DOFs) em um nó típico (ex: ux, uy em 2D).",
                                    "Monte o vetor global de deslocamentos {d} como concatenação de deslocamentos nodais.",
                                    "Defina o vetor de forças nodais {F} com componentes concentradas em cada DOF nodal.",
                                    "Discuta como forças distribuídas são lumpadas para nodais via métodos equivalentes.",
                                    "Pratique montando {d} e {F} para um malha simples com 3 nós."
                                  ],
                                  "verification": "Construa manualmente {d} e {F} para um sistema com 2 nós e verifique dimensões.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel quadriculado, calculadora, software como MATLAB para vetores simbólicos.",
                                  "tips": "Use índices consistentes (ex: d1 para ux do nó 1) para evitar confusões.",
                                  "learningObjective": "Saber representar kinematicamente e estaticamente um sistema nodal.",
                                  "commonMistakes": "Erro de indexação nos vetores ou inclusão de forças reativas em {F}."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular o Produto Escalar para o Potencial W",
                                  "subSteps": [
                                    "Derive W para uma força nodal única: W_i = -F_i * d_i.",
                                    "Generalize para múltiplas forças: W = - ∑ F_i d_i.",
                                    "Expresse em notação matricial: W = - {F}^T {d} ou - {d}^T {F}.",
                                    "Verifique simetria e propriedades escalares do produto escalar.",
                                    "Integre conceitualmente com U para minimização de Π."
                                  ],
                                  "verification": "Escreva a fórmula W para um vetor {F} = [10, 20]^T e {d} = [0.1, 0.2]^T, calculando o valor numérico.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Folha de derivadas simbólicas, exemplos de livros de MEF.",
                                  "tips": "Lembre-se: produto escalar é comutativo, mas sinal é crucial.",
                                  "learningObjective": "Derivar e escrever corretamente a expressão matricial de W.",
                                  "commonMistakes": "Esquecer o sinal negativo ou usar produto vetorial em vez de escalar."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Validar a Expressão em um Exemplo Simples",
                                  "subSteps": [
                                    "Escolha um elemento de treliça com 2 nós e força nodal em um extremo.",
                                    "Calcule {d} assumindo deslocamentos conhecidos e monte {F}.",
                                    "Compute W e compare com trabalho físico intuitivo.",
                                    "Inclua W na energia total Π e verifique estacionariedade (dΠ/dd = 0).",
                                    "Teste sensibilidade alterando magnitudes de F ou d."
                                  ],
                                  "verification": "Resolva numericamente e confirme que ∂W/∂d_i = -F_i.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Software FEA como ANSYS Student ou código MATLAB simples.",
                                  "tips": "Comece com 1D para simplicidade antes de 2D/3D.",
                                  "learningObjective": "Aplicar W em contexto prático e validar derivadas.",
                                  "commonMistakes": "Não considerar todos DOFs ou erros em transposição de vetores."
                                }
                              ],
                              "practicalExample": "Em uma treliça 2D com 2 nós (A e B), força nodal F = [100 N, 0] no nó B. Vetor deslocamentos {d} = [0.01 m (uxA), 0.02 m (uyA), 0.03 m (uxB), 0.04 m (uyB)]. Então W = - {d}^T {F_eq} onde {F_eq} é expandido com zeros, resultando W ≈ -3.0 J.",
                              "finalVerifications": [
                                "Escreve corretamente W = -{d}^T {F} para um sistema arbitrário.",
                                "Calcula W numericamente para vetores dados com precisão <1%.",
                                "Explica o sinal negativo via princípio virtual de trabalho.",
                                "Deriva ∂W/∂d_i = -F_i sem erros.",
                                "Integra W em Π e identifica contribuições nodais.",
                                "Identifica erros comuns em montagem de {F}."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação matricial (100% corretude sintática).",
                                "Compreensão conceitual demonstrada em explicação (nota >8/10).",
                                "Cálculos numéricos exatos e verificados.",
                                "Aplicação correta em exemplo prático sem falhas dimensionais.",
                                "Identificação de pelo menos 3 erros comuns e prevenções.",
                                "Conexão clara com minimização de Π."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (produtos escalares, vetores).",
                                "Física: Mecânica clássica (trabalho de forças concentradas).",
                                "Programação: Implementação em código para automação de MEF.",
                                "Engenharia Civil: Análise estática de estruturas nodais."
                              ],
                              "realWorldApplication": "Na análise de pontes ou edifícios via MEF, expressar W corretamente permite simular respostas a cargas sísmicas ou ventos concentrados em nós, otimizando projetos para segurança e economia."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.1.2.1.2.2",
                            "name": "Incluir carregamentos distribuídos",
                            "description": "Derivar a expressão integral para o potencial de cargas distribuídas sobre superfícies ou volumes, usando funções de interpolação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Energia Potencial para Cargas Distribuídas",
                                  "subSteps": [
                                    "Revise a definição de energia potencial total em métodos variacionais (Rayleigh-Ritz e Galerkin).",
                                    "Identifique os componentes: energia de deformação interna e energia potencial dos carregamentos.",
                                    "Estude a forma geral da energia potencial dos carregamentos: V = -∫ u · f dV - ∫ u · t dS.",
                                    "Diferencie cargas volumétricas (f) de trações superficiais (t).",
                                    "Analise exemplos simples de cargas distribuídas em sólidos elásticos."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre energia de deformação e potencial de carregamento, com equações corretas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Elementos Finitos (ex: Zienkiewicz), notas de aula sobre Rayleigh-Ritz",
                                    "Calculadora simbólica (SymPy ou Mathematica)"
                                  ],
                                  "tips": "Comece com casos 1D para intuição antes de generalizar para 3D.",
                                  "learningObjective": "Entender o papel físico e matemático da energia potencial dos carregamentos na minimização da energia total.",
                                  "commonMistakes": [
                                    "Confundir sinal negativo da energia potencial",
                                    "Ignorar a dependência da direção do deslocamento u"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Expressão Contínua para Cargas Distribuídas",
                                  "subSteps": [
                                    "Derive a expressão integral para cargas volumétricas: V_v = -∫_Ω u(x) f(x) dV.",
                                    "Estenda para trações superficiais: V_s = -∫_Γ u(x) t(x) dS.",
                                    "Discuta a generalidade para superfícies curvas ou volumes arbitrários.",
                                    "Inclua casos de cargas dependentes do tempo ou não-lineares.",
                                    "Verifique dimensionalmente as expressões derivadas."
                                  ],
                                  "verification": "Escreva as expressões integrais completas em um caderno e confira com referências padrão.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel e caneta para derivações",
                                    "Software de matemática simbólica",
                                    "Artigos sobre princípios variacionais"
                                  ],
                                  "tips": "Use o princípio dos trabalhos virtuais para validar a derivação.",
                                  "learningObjective": "Derivar com precisão as formas integrais contínuas para diferentes tipos de cargas distribuídas.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo",
                                    "Não especificar os domínios de integração (Ω vs Γ)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Discretizar Usando Funções de Interpolação em Elementos Finitos",
                                  "subSteps": [
                                    "Aproxime o campo de deslocamentos: u(x) ≈ ∑ N_i(x) u_i, onde N_i são funções de forma.",
                                    "Substitua na expressão contínua: V ≈ -∑ u_i ∫ N_i f dV - ∑ u_i ∫ N_i t dS.",
                                    "Defina os vetores de carga nodal: F_i = ∫ N_i f dV + ∫ N_i t dS.",
                                    "Formule a contribuição elementar para o vetor de forças equivalente.",
                                    "Integre numericamente usando Gauss-Legendre para elementos finitos."
                                  ],
                                  "verification": "Implemente a discretização para um elemento linear 1D e compute F numericamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software MEF (ex: FEniCS, MATLAB PDE Toolbox)",
                                    "Tabelas de funções de forma e quadratura Gauss"
                                  ],
                                  "tips": "Teste com carga constante para verificar resultados analíticos conhecidos.",
                                  "learningObjective": "Aplicar funções de interpolação para transformar integrais contínuas em somas nodais.",
                                  "commonMistakes": [
                                    "Erro na ordem de integração (elemento vs global)",
                                    "Confundir funções de forma com funções de teste em Galerkin"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar e Verificar a Energia Potencial Total com Cargas Distribuídas",
                                  "subSteps": [
                                    "Some as contribuições elementares ao vetor de carga global.",
                                    "Formule a energia potencial total: Π = U - V, com V incluindo cargas distribuídas.",
                                    "Resolva o sistema Ku = F via minimização de Π.",
                                    "Valide com um problema benchmark (ex: viga com carga distribuída).",
                                    "Analise sensibilidade a malha e ordem das funções de forma."
                                  ],
                                  "verification": "Compare resultados numéricos com solução analítica exata para um caso simples.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código fonte de MEF pronto",
                                    "Problemas de benchmark de livros de MEF"
                                  ],
                                  "tips": "Use simetria para reduzir dimensões em exemplos iniciais.",
                                  "learningObjective": "Integrar a energia de cargas distribuídas na formulação completa de MEF.",
                                  "commonMistakes": [
                                    "Não assemblar corretamente as contribuições nodais",
                                    "Ignorar condições de contorno na montagem de F"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma placa retangular sob carga distribuída volumétrica f = (0, -ρg) (peso próprio). Usando elementos quadrilaterais bilineares, derive F_elemento = ∫∫ N^T f t ds dt e some para a malha, resolvendo para deslocamentos e verificando tensão máxima contra analítico.",
                              "finalVerifications": [
                                "Derivação correta das integrais contínuas com sinal e domínios apropriados.",
                                "Discretização nodal exata usando funções de interpolação padrão.",
                                "Implementação numérica convergente para malhas refinadas.",
                                "Comparação quantitativa com soluções analíticas (erro < 1%).",
                                "Explicação física da contribuição das cargas no equilíbrio.",
                                "Código ou derivação manual reproduzível."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações (sem erros algébricos).",
                                "Compreensão conceitual (explicar minimização de Π).",
                                "Habilidade em discretização e integração numérica.",
                                "Validação com exemplos práticos e análise de erros.",
                                "Clareza na documentação de steps e resultados.",
                                "Criatividade em extensões (ex: cargas dinâmicas)."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Avançado: Integrais múltiplas e mudança de coordenadas.",
                                "Programação Numérica: Implementação de quadratura Gauss em Python/MATLAB.",
                                "Física: Princípio de trabalhos virtuais e equilíbrio elástico.",
                                "Estatística: Análise de convergência e erro de malha.",
                                "Engenharia Civil: Aplicação em análise sísmica de estruturas."
                              ],
                              "realWorldApplication": "Em simulações de MEF para projetos de pontes ou aviões, onde cargas distribuídas como vento, neve ou peso próprio são modeladas para prever deformações e falhas, otimizando designs e garantindo segurança."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.2.1.2.1"
                            ]
                          },
                          {
                            "id": "34.1.2.1.2.3",
                            "name": "Tratar deslocamentos impostos",
                            "description": "Incorporar o potencial associado a deslocamentos prescritos em contornos Dirichlet na energia total.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender deslocamentos impostos e contornos Dirichlet",
                                  "subSteps": [
                                    "Revise as condições de contorno essenciais (Dirichlet) versus naturais (Neumann).",
                                    "Identifique nós com deslocamentos prescritos em uma malha de elementos finitos.",
                                    "Analise como deslocamentos impostos afetam a formulação variacional em Rayleigh-Ritz.",
                                    "Estude a energia potencial total: U = U_elástica + V_carregamentos + restrições.",
                                    "Discuta o papel do potencial associado aos deslocamentos impostos."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre contornos Dirichlet e Neumann, citando um exemplo de estrutura.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Elementos Finitos (ex: Zienkiewicz), notas de aula, software MEF como ANSYS ou código Python com FEniCS."
                                  ],
                                  "tips": "Use diagramas de uma barra axial para visualizar nós fixos.",
                                  "learningObjective": "Dominar os conceitos fundamentais de condições de contorno Dirichlet e seu impacto na energia potencial.",
                                  "commonMistakes": "Confundir deslocamentos impostos com forças aplicadas; ignorar que são condições essenciais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar o potencial associado aos deslocamentos impostos",
                                  "subSteps": [
                                    "Parta da funcional de energia total sem restrições: Π = (1/2) u^T K u - f^T u.",
                                    "Introduza multiplicadores de Lagrange para nós com u_i = \bar{u}_i.",
                                    "Derive o termo de potencial: V_D = - \bar{u}^T R, onde R são reações.",
                                    "Expresse matematicamente: Π_restrito = Π + Σ λ_i (u_i - \bar{u}_i).",
                                    "Simplifique para incorporação direta na energia total."
                                  ],
                                  "verification": "Escreva a equação do potencial V_D para um sistema com 2 graus de liberdade prescritos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel e lápis para derivações, MATLAB ou Python para simbólico (SymPy)."
                                  ],
                                  "tips": "Comece com um caso 1D simples para evitar complexidade matricial inicial.",
                                  "learningObjective": "Derivar corretamente o termo potencial para deslocamentos prescritos.",
                                  "commonMistakes": "Esquecer o sinal negativo no potencial; confundir com trabalho de forças externas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar o potencial na energia total e modificar o sistema",
                                  "subSteps": [
                                    "Adicione V_D à energia potencial total: Π_total = U + V_f + V_D.",
                                    "Monte a matriz de rigidez global K e vetor de forças modificado.",
                                    "Aplique penalização ou remoção de linhas/colunas para DOFs prescritos.",
                                    "Resolva K_red u_red = f_red, interpolando valores impostos.",
                                    "Calcule reações nos nós impostos: R = K_{imp,free} u_free + K_{imp,imp} \bar{u} - f_imp."
                                  ],
                                  "verification": "Implemente em código um sistema 1D e verifique se u_imp = \bar{u} exatamente.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Código Python/MATLAB com NumPy/SciPy, exemplo de malha simples."
                                  ],
                                  "tips": "Use particionamento matricial: [K_ff, K_fp; K_pf, K_pp] para clareza.",
                                  "learningObjective": "Integrar V_D na formulação e resolver o sistema acoplado corretamente.",
                                  "commonMistakes": "Não zerar linhas/colunas correspondentes aos DOFs impostos; erros em índices matriciais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e implementar em um exemplo prático",
                                  "subSteps": [
                                    "Escolha uma viga em flexão com extremidade fixada (u=0, θ=0).",
                                    "Monte o modelo MEF com Rayleigh-Ritz usando funções de forma.",
                                    "Incorpore deslocamentos impostos e resolva para deslocamentos e tensões.",
                                    "Compare com solução analítica exata.",
                                    "Analise reações e energia total computada."
                                  ],
                                  "verification": "Gráfico de deslocamentos coincide com analítico (erro <1%) e energia converge.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Software MEF (FreeFEM, FEniCS), planilha para solução analítica."
                                  ],
                                  "tips": "Teste com malhas refinadas para verificar convergência.",
                                  "learningObjective": "Aplicar a formulação em um problema real e validar resultados.",
                                  "commonMistakes": "Malha inadequada nos nós impostos; não verificar equilíbrio global."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar sensibilidade e generalizações",
                                  "subSteps": [
                                    "Varie valores de \bar{u} e observe impacto em energia e reações.",
                                    "Estenda para 2D/3D com múltiplos nós impostos.",
                                    "Discuta equivalência com métodos de penalização ou Lagrange.",
                                    "Avalie estabilidade numérica para valores grandes de \bar{u}.",
                                    "Documente o processo para relatórios."
                                  ],
                                  "verification": "Relatório com gráficos de sensibilidade e comparação de métodos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código parametrizado, ferramentas de plotagem (Matplotlib)."
                                  ],
                                  "tips": "Automatize com loops para varredura paramétrica.",
                                  "learningObjective": "Generalizar o tratamento para cenários complexos e analisar robustez.",
                                  "commonMistakes": "Ignorar singularidades na matriz K para casos super-determinados."
                                }
                              ],
                              "practicalExample": "Em uma viga cantilever de 1m sujeita a carga pontual na ponta, imponha deslocamento vertical prescrito de 0.01m na ponta. Incorpore V_D na energia total usando 4 elementos lineares, resolva para rotações e reações, validando contra solução de Euler-Bernoulli.",
                              "finalVerifications": [
                                "Deslocamentos impostos são exatamente reproduzidos (erro <1e-10).",
                                "Energia total Π é estacionária e mínima.",
                                "Reações nos nós fixos equilibram forças externas.",
                                "Convergência com refinamento de malha.",
                                "Comparação qualitativa com solução analítica.",
                                "Ausência de modos rígidos espúrios."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de V_D (100% correta).",
                                "Implementação numérica sem erros de indexação.",
                                "Validação com erro relativo <5%.",
                                "Explicação clara de passos intermediários.",
                                "Generalização para casos não-triviais.",
                                "Eficiência computacional demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização variacional e multiplicadores de Lagrange.",
                                "Programação: Implementação matricial em Python/MATLAB.",
                                "Física: Princípio dos trabalhos virtuais em mecânica dos sólidos.",
                                "Engenharia Civil: Análise de estruturas com apoios impostos."
                              ],
                              "realWorldApplication": "Na simulação de estruturas civis como pontes com apoios fixos ou em análise de fadiga de turbinas eólicas com deslocamentos impostos por montagem, garantindo precisão em predições de tensões e vida útil."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.2.1.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "34.1.2.1.3",
                        "name": "Energia Potencial Total e Estacionariedade",
                        "description": "Definição da energia potencial total Π = U - W e o princípio variacional de que a solução exata minimiza Π entre funções admissíveis.",
                        "specificSkills": [
                          {
                            "id": "34.1.2.1.3.1",
                            "name": "Formular a energia potencial total Π",
                            "description": "Escrever a expressão completa Π = ∫(1/2)σ:ε dV - ∫ t·u dS - ∫ f·u dV para problemas elásticos gerais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os princípios variacionais e a energia interna de deformação",
                                  "subSteps": [
                                    "Revise o princípio de energia potencial mínima em problemas elásticos lineares.",
                                    "Identifique a energia interna como o trabalho armazenado na deformação elástica.",
                                    "Lembre-se da relação constitutiva σ = C ε, onde C é o tensor de rigidez.",
                                    "Entenda o produto duplo σ:ε = σ_ij ε_ij (soma de Einstein).",
                                    "Discuta a integração sobre o volume do domínio Ω."
                                  ],
                                  "verification": "Escreva verbalmente a expressão da energia interna e explique cada termo para um colega.",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "Livro de Mecânica dos Sólidos (ex: Timoshenko)",
                                    "Notas de aula sobre elástica linear",
                                    "Calculadora simbólica como SymPy"
                                  ],
                                  "tips": "Visualize a deformação como armazenamento de 'molhas' elásticas no material.",
                                  "learningObjective": "Entender a origem física da energia de deformação interna (1/2)∫ σ:ε dV.",
                                  "commonMistakes": [
                                    "Confundir σ:ε com produto escalar simples σ·ε.",
                                    "Esquecer o fator 1/2 derivado da linearidade."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular o potencial das forças de superfície (trações)",
                                  "subSteps": [
                                    "Defina as trações t como forças por unidade de área na fronteira ∂Ω_t.",
                                    "Identifique o deslocamento u na superfície.",
                                    "Entenda o trabalho virtual como ∫ t·u dS.",
                                    "Note o sinal negativo no potencial, pois minimiza a energia total.",
                                    "Especifique que dS é sobre a parte da fronteira com trações prescritas."
                                  ],
                                  "verification": "Desenhe um diagrama de uma viga com tração aplicada e anote o termo de trabalho.",
                                  "estimatedTime": "30 min",
                                  "materials": [
                                    "Papel e lápis para diagramas",
                                    "Software de desenho vetorial (opcional)",
                                    "Referência: equação de equilíbrio ∂σ/∂x + f = 0"
                                  ],
                                  "tips": "Pense no trabalho como o oposto da energia interna: forças externas 'ajudam' a deformar.",
                                  "learningObjective": "Derivar o termo -∫ t·u dS do princípio dos trabalhos virtuais.",
                                  "commonMistakes": [
                                    "Usar integral de volume em vez de superfície para trações.",
                                    "Esquecer o ponto · para produto escalar vetorial."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular o potencial das forças volumétricas",
                                  "subSteps": [
                                    "Defina forças volumétricas f como forças por unidade de volume (ex: gravidade).",
                                    "Integre o produto f·u sobre todo o volume Ω.",
                                    "Explique o sinal negativo similar ao das trações.",
                                    "Compare com o termo de superfície: ambos representam trabalho externo.",
                                    "Verifique unidades: f (N/m³) · u (m) · dV (m³) = J."
                                  ],
                                  "verification": "Calcule dimensionalmente o termo e confirme que resulta em energia (Joules).",
                                  "estimatedTime": "25 min",
                                  "materials": [
                                    "Tabela de unidades SI",
                                    "Exemplo numérico simples de corpo em gravidade"
                                  ],
                                  "tips": "Para forças como peso próprio, f = ρ g, constante em muitos casos.",
                                  "learningObjective": "Reconhecer -∫ f·u dV como contribuição de cargas distribuídas.",
                                  "commonMistakes": [
                                    "Confundir f com tração t (f é por volume, t por área).",
                                    "Integrar sobre superfície errada."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar a expressão completa Π e discutir estacionariedade",
                                  "subSteps": [
                                    "Some os três termos: Π = energia interna - trabalho superfícies - trabalho volume.",
                                    "Escreva explicitamente Π = ∫_Ω (1/2) σ:ε dV - ∫_∂Ω_t t·u dS - ∫_Ω f·u dV.",
                                    "Explique que o equilíbrio ocorre quando δΠ = 0 para variações δu admissíveis.",
                                    "Discuta condições de contorno: u prescrito em ∂Ω_u, t em ∂Ω_t.",
                                    "Verifique com caso 1D: barra em tração."
                                  ],
                                  "verification": "Derive δΠ = 0 e mostre que leva às equações de equilíbrio.",
                                  "estimatedTime": "50 min",
                                  "materials": [
                                    "SymPy ou Mathematica para variação",
                                    "Exemplo de barra axial"
                                  ],
                                  "tips": "Use notação clara: especifique domínios Ω e ∂Ω_t.",
                                  "learningObjective": "Formular Π completa e ligar à estacionariedade do funcional.",
                                  "commonMistakes": [
                                    "Sinal errado nos termos de trabalho (+ em vez de -).",
                                    "Esquecer subscritos nos integrais."
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma viga cantilever de comprimento L sob carga pontual P na ponta: energia interna ∫ (1/2) E A (du/dx)^2 dx, trabalho da carga -P u(L), sem forças volumétricas. Π estacionária dá u(x) = (P/(6 E I)) (3 L x^2 - x^3) em flexão.",
                              "finalVerifications": [
                                "Escreve corretamente Π com todos os integrais e sinais.",
                                "Explica o papel físico de cada termo.",
                                "Deriva δΠ = 0 verbalmente.",
                                "Aplica a um exemplo 1D simples.",
                                "Identifica domínios de integração corretos.",
                                "Confirma unidades de energia."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação matemática (σ:ε, t·u, etc.).",
                                "Correção dos sinais e fatores (1/2, negativos).",
                                "Compreensão da origem variacional.",
                                "Capacidade de ligar a métodos numéricos como Rayleigh-Ritz.",
                                "Clareza na distinção entre forças de superfície e volume.",
                                "Aplicação correta de condições de contorno."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Variacional: funcional Π e derivada funcional δΠ.",
                                "Física: Princípio de Hamilton e energia potencial em mecânica.",
                                "Programação: Implementação em FEA (ex: código FEM para integrais de energia).",
                                "Matemática: Teoria de distribuições fracas (Galerkin).",
                                "Engenharia Civil: Análise de estruturas sob cargas."
                              ],
                              "realWorldApplication": "Essencial em software de Elementos Finitos (ANSYS, Abaqus) para simular deformações em pontes, aviões e implantes médicos, otimizando designs sob cargas reais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.2.1.1.1",
                              "34.1.2.1.2.1"
                            ]
                          },
                          {
                            "id": "34.1.2.1.3.2",
                            "name": "Aplicar o princípio de Rayleigh-Ritz",
                            "description": "Explicar como aproximar a solução minimizando Π em um espaço de funções de interpolação polinomial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Conceito de Energia Potencial Total Π",
                                  "subSteps": [
                                    "Defina a energia potencial total Π como a soma da energia de deformação interna e do trabalho das forças externas.",
                                    "Escreva a expressão matemática genérica: Π(u) = U(u) - W(u), onde U é a energia interna e W é o trabalho externo.",
                                    "Identifique os termos para problemas elásticos lineares: U = (1/2) ∫ σ:ε dV.",
                                    "Discuta a estacionariedade: a solução exata u minimiza Π.",
                                    "Relacione com o princípio de mínimos potenciais em mecânica."
                                  ],
                                  "verification": "Escreva corretamente a expressão de Π para um problema simples de tração uniaxial e confirme que δΠ = 0 na solução exata.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro-texto de Elementos Finitos (ex: Zienkiewicz), caderno de anotações, calculadora.",
                                  "tips": "Use analogias como 'bola rolando para o vale mais baixo' para visualizar a minimização.",
                                  "learningObjective": "Compreender a base variacional do método Rayleigh-Ritz.",
                                  "commonMistakes": "Confundir Π com energia cinética; ignorar sinais no trabalho externo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar o Espaço de Funções de Interpolação Polinomial",
                                  "subSteps": [
                                    "Escolha o domínio do problema (ex: barra de comprimento L).",
                                    "Defina funções base polinomiais: φ_i(x) = (x/L)^i para i=1 a n, satisfazendo condições de contorno essenciais.",
                                    "Garanta completude e linear independência das funções.",
                                    "Ajuste para condições de contorno: ex: φ_1(0)=1, φ_1(L)=0 para apoio simples.",
                                    "Verifique ortogonalidade se aplicável, mas foque em polinômios simples."
                                  ],
                                  "verification": "Liste 3 funções polinomiais para uma barra com u(0)=0 e desenhe-as, confirmando satisfação das C.C.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de plotagem (Matlab/Octave/Python), papel milimetrado.",
                                  "tips": "Comece com n=2 para simplicidade; aumente para convergência.",
                                  "learningObjective": "Construir um subespaço de aproximação admissível.",
                                  "commonMistakes": "Funções que não satisfazem C.C. essenciais, levando a soluções inválidas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Expressar a Aproximação da Solução e Formular Π",
                                  "subSteps": [
                                    "Aproxime u(x) ≈ ∑ c_i φ_i(x), onde c_i são coeficientes desconhecidos.",
                                    "Substitua na energia interna U: compute ∫ φ_i' φ_j' dx para rigidez.",
                                    "Substitua no trabalho W: compute ∫ f φ_i dx + forças nodais.",
                                    "Escreva Π(c) = (1/2) c^T K c - F^T c, em forma matricial.",
                                    "Confirme que Π é quadrática em c."
                                  ],
                                  "verification": "Derive as matrizes K (3x3 para n=3) e F para um caso de carga distribuída.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilha ou software simbólico (SymPy), exemplos resolvidos.",
                                  "tips": "Use integração analítica para polinômios; memorize integrais básicas.",
                                  "learningObjective": "Formular o funcional Π no espaço de aproximação.",
                                  "commonMistakes": "Erros em limites de integração ou potências nos polinômios."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Minimizar Π e Resolver o Sistema Algébrico",
                                  "subSteps": [
                                    "Aplique o princípio: δΠ = 0 leva a ∂Π/∂c_i = 0 para todo i.",
                                    "Obtenha o sistema K c = F.",
                                    "Resolva para c usando eliminação gaussiana ou inversa.",
                                    "Calcule a solução aproximada u_approx(x).",
                                    "Avalie Π na solução e compare com valores conhecidos."
                                  ],
                                  "verification": "Resolva K c = F e plote u_approx vs. solução exata, medindo erro <5%.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora matricial ou Matlab/Python (numpy.linalg.solve).",
                                  "tips": "Verifique simetria positiva definida de K antes de resolver.",
                                  "learningObjective": "Implementar a minimização variacional numericamente.",
                                  "commonMistakes": "Inverter matriz singular por funções mal escolhidas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar Convergência e Analisar Resultados",
                                  "subSteps": [
                                    "Aumente n (grau polinomial) e resolva novamente.",
                                    "Plote erro de energia ||Π_approx - Π_exact|| vs. n.",
                                    "Compare deslocamentos e tensões com solução exata.",
                                    "Discuta taxa de convergência (monótona decrescente).",
                                    "Documente limitações para problemas não-lineares."
                                  ],
                                  "verification": "Mostre convergência com pelo menos 3 valores de n, erro reduzindo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Gráficos em Python/Matlab, tabela de resultados.",
                                  "tips": "Use norma de energia para verificação robusta.",
                                  "learningObjective": "Avaliar qualidade da aproximação Rayleigh-Ritz.",
                                  "commonMistakes": "Aguardar convergência sem aumentar n adequadamente."
                                }
                              ],
                              "practicalExample": "Considere uma barra em tração axial de comprimento L=1m, seção A=1, E=1, carga distribuída f(x)=x. Use polinômios φ1=x, φ2=x(1-x/2) para aproximar u(x), resolva Kc=F e compare com exata u(x)=x^3/6 - x^2/4 + x/2.",
                              "finalVerifications": [
                                "A matriz K é simétrica e definida positiva.",
                                "Solução satisfaz condições de contorno essenciais.",
                                "Energia Π_approx ≤ Π para qualquer outra tentativa c.",
                                "Erro relativo em deslocamento máximo < 2% para n≥3.",
                                "Convergência observada ao aumentar o espaço de funções.",
                                "Tensões derivadas são contínuas e físicas."
                              ],
                              "assessmentCriteria": [
                                "Precisão da formulação de Π (100% dos termos corretos).",
                                "Correta escolha e satisfação de C.C. pelas funções base.",
                                "Resolução exata do sistema Kc=F sem erros numéricos.",
                                "Análise de convergência com gráficos quantitativos.",
                                "Interpretação física dos resultados (deslocamentos/tensões).",
                                "Clareza na documentação e avoidance de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e métodos de autovalores.",
                                "Física: Princípios de Hamilton e mecânica clássica.",
                                "Programação: Implementação numérica em Python/MATLAB para MEF.",
                                "Engenharia Civil: Análise de vigas e estruturas isostáticas."
                              ],
                              "realWorldApplication": "Em engenharia mecânica, o Rayleigh-Ritz é usado no pré-processamento de análises de elementos finitos para estruturas como vigas, placas e cascas em software como ANSYS, otimizando designs de aviões, pontes e máquinas contra falhas por deformação."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.2.1.3.1"
                            ]
                          },
                          {
                            "id": "34.1.2.1.3.3",
                            "name": "Verificar estacionariedade via derivada",
                            "description": "Demonstrar que δΠ = 0 leva às equações de equilíbrio do método dos elementos finitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a formulação da Energia Potencial Total Π no método dos elementos finitos",
                                  "subSteps": [
                                    "Identificar os componentes de Π: energia de deformação interna U e energia de carregamento externo V, onde Π = U - V.",
                                    "Escrever as expressões matemáticas para U (integral de tensões e deformações) e V (trabalho dos esforços externos).",
                                    "Discutir o contexto do método Rayleigh-Ritz, onde as soluções aproximadas são buscadas minimizando Π.",
                                    "Exemplificar com um sistema discreto simples, como um elemento de barra com deslocamentos nodais.",
                                    "Verificar a dimensionalidade e unidades consistentes em todos os termos."
                                  ],
                                  "verification": "Conferir se a expressão de Π está corretamente escrita e balanceada dimensionalmente em um caderno ou software simbólico.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro-texto de Elementos Finitos (ex: Zienkiewicz), caderno, calculadora simbólica (SymPy ou Mathematica).",
                                  "tips": "Sempre normalize as expressões pela rigidez para facilitar comparações.",
                                  "learningObjective": "Compreender a composição exata da energia potencial total Π em formulações discretas.",
                                  "commonMistakes": "Confundir o sinal de V (deve ser subtraída) ou omitir termos de contorno."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o conceito de variação da energia potencial δΠ",
                                  "subSteps": [
                                    "Explicar a estacionariedade: Π é estacionária no equilíbrio, i.e., primeira variação δΠ = 0 para variações admissíveis.",
                                    "Definir variações virtuais δu dos deslocamentos aproximados u = N d, onde N são funções de forma e d vetor nodal.",
                                    "Derivar δU linearizando as deformações ε = B d, resultando em δU = δd^T K d / 2.",
                                    "Derivar δV como δd^T F, onde F é o vetor de forças nodais.",
                                    "Combinar para obter δΠ = δd^T (K d - F)."
                                  ],
                                  "verification": "Verificar se δΠ é expressa como δd^T (K d - F) = 0 para qualquer δd admissível.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel quadriculado, lápis, software de álgebra simbólica, notas de aula sobre cálculo variacional.",
                                  "tips": "Use a notação matricial desde o início para evitar confusões escalares.",
                                  "learningObjective": "Dominar a derivação da primeira variação δΠ em termos de deslocamentos virtuais.",
                                  "commonMistakes": "Esquecer que δU é quadrática e sua variação linear, ou inverter o sinal de δV."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar que δΠ = 0 implica nas equações de equilíbrio K d = F",
                                  "subSteps": [
                                    "Analisar δΠ = δd^T (K d - F) = 0 para todo δd ≠ 0 admissível.",
                                    "Concluir que o termo entre parênteses deve ser zero: K d - F = 0, ou K d = F.",
                                    "Relacionar K d = F às equações de equilíbrio nodal do método dos elementos finitos.",
                                    "Discutir condições de contorno essenciais incorporadas nas funções de forma.",
                                    "Validar com o Princípio dos Trabalhos Virtuais como base teórica."
                                  ],
                                  "verification": "Resolver um sistema simples K d = F e confirmar que δΠ ≈ 0 numericamente para pequenas perturbações.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Matriz solver (MATLAB, Python/NumPy), exemplo numérico de elemento finito.",
                                  "tips": "Teste com δd unitário em cada grau de liberdade para isolar equações.",
                                  "learningObjective": "Provar rigorosamente a equivalência entre estacionariedade de Π e equações de equilíbrio.",
                                  "commonMistakes": "Ignorar que δd deve ser admissível (respeitar contornos) ou assumir δd arbitrário sem restrições."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e verificar em um exemplo prático de elemento finito",
                                  "subSteps": [
                                    "Escolher um elemento de barra axial com nós 1 e 2, rigidez k, força F no nó 2.",
                                    "Montar Π explicitamente em termos de deslocamentos d1 e d2.",
                                    "Calcular δΠ variando d1 e d2 independentemente e mostrar =0 leva a k(d2 - d1) = 0 e k(d1 - d2) = F.",
                                    "Resolver o sistema e plotar Π vs. d para visualizar o mínimo.",
                                    "Comparar com solução exata para validar."
                                  ],
                                  "verification": "Gráfico de Π mostrando mínimo estacionário e derivadas zero nos pontos de equilíbrio.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python/MATLAB para plotagem, planilha Excel para cálculos manuais.",
                                  "tips": "Use funções de forma lineares N = [1-ξ, ξ] para generalidade.",
                                  "learningObjective": "Aplicar a verificação de estacionariedade em um caso concreto de FEM.",
                                  "commonMistakes": "Erro na montagem da matriz K ou vetor F devido a convenções de sinal."
                                }
                              ],
                              "practicalExample": "Considere uma barra axial de comprimento L=1m, EA=1e6 N, fixa em x=0 e com força F=1000N em x=L. Aproximação linear: u(x) = (1-x/L)d1 + (x/L)d2. Compute Π = (EA/2L)(d2-d1)^2 - F d2. Variação δΠ leva a [[EA/L, -EA/L], [-EA/L, EA/L]] [d1;d2] = [0;F], resolvendo d1=0, d2=FL/EA.",
                              "finalVerifications": [
                                "δΠ é corretamente derivada como δd^T (K d - F).",
                                "Condição δΠ=0 implica K d = F para δd admissíveis.",
                                "Exemplo numérico confirma equilíbrio com erro <1%.",
                                "Gráfico de Π mostra mínimo estacionário.",
                                "Relação com Princípio dos Trabalhos Virtuais é explicitada.",
                                "Unidades e dimensionalidade consistentes em toda derivação."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de δΠ (90% peso).",
                                "Clareza na explicação da implicação para equações de equilíbrio.",
                                "Correção no exemplo prático com validação numérica.",
                                "Uso adequado de notação matricial e funções de forma.",
                                "Identificação de erros comuns e como evitá-los.",
                                "Conexão teórica com métodos Rayleigh-Ritz/Galerkin."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e otimização não-linear.",
                                "Física: Princípio da Estaçãoariedade e Trabalhos Virtuais.",
                                "Computação: Implementação numérica em solvers FEM (ex: FEniCS).",
                                "Engenharia Civil: Análise de estruturas em software como SAP2000."
                              ],
                              "realWorldApplication": "Em simulações de elementos finitos com ANSYS ou Abaqus, a minimização de Π garante que as equações de equilíbrio sejam satisfeitas, permitindo análises precisas de tensões em pontes, aviões e implantes médicos sob cargas reais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.2.1.3.1"
                            ]
                          },
                          {
                            "id": "34.1.2.1.3.4",
                            "name": "Considerar efeitos termoelásticos",
                            "description": "Incluir contribuições térmicas na energia potencial total, modificando a energia de deformação com dilatação térmica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Energia Potencial Total em MEF",
                                  "subSteps": [
                                    "Relembrar a formulação padrão da energia potencial total Π = U - W, onde U é energia de deformação e W é trabalho das cargas externas.",
                                    "Estudar a expressão da energia de deformação U = (1/2) ∫ σ : ε dV para problemas elásticos lineares.",
                                    "Analisar o princípio de estacionariedade: δΠ = 0 leva às equações de equilíbrio.",
                                    "Discutir limitações em problemas isotérmicos e necessidade de acoplamento térmico.",
                                    "Derivar brevemente o método de Rayleigh-Ritz para minimização de Π."
                                  ],
                                  "verification": "Escrever corretamente a expressão de Π sem termos térmicos e explicar o princípio de estacionariedade em um parágrafo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Elementos Finitos (ex: Zienkiewicz), notas de aula, calculadora simbólica como SymPy.",
                                  "tips": "Use diagramas de fluxo para visualizar como Π leva às equações fracas.",
                                  "learningObjective": "Compreender a base teórica da energia potencial total antes da inclusão de efeitos térmicos.",
                                  "commonMistakes": "Confundir energia de deformação com energia cinética; ignorar o domínio de integração."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Conceitos de Dilatação Térmica e Termoelasticidade",
                                  "subSteps": [
                                    "Definir coeficiente de dilatação térmica α e deformação térmica ε_th = α ΔT.",
                                    "Explicar o acoplamento termoelástico: tensão total σ = C : (ε - ε_th), onde C é tensor de elasticidade.",
                                    "Derivar a modificação na energia de deformação: U_te = (1/2) ∫ (ε - ε_th) : C : (ε - ε_th) dV.",
                                    "Discutir expansões lineares para pequenas variações térmicas.",
                                    "Analisar efeitos uncoupled (temperatura conhecida) vs. fully coupled."
                                  ],
                                  "verification": "Calcular ε_th para um material com α=12e-6 /K e ΔT=100K, e modificar σ para uma deformação mecânica dada.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Tabelas de propriedades de materiais (aço, alumínio), software MATLAB ou Python para plots de ε_th.",
                                  "tips": "Visualize com gráficos de ε vs. T para intuitar o efeito expansivo.",
                                  "learningObjective": "Dominar a deformação térmica e sua interação com deformação mecânica.",
                                  "commonMistakes": "Usar α volumétrico em vez de linear; negligenciar sinal negativo em ε - ε_th."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modificar Energia Potencial Total com Termos Termoelásticos",
                                  "subSteps": [
                                    "Expandir U_te: U_te = U_mec - ∫ σ : ε_th dV + (1/2) ∫ ε_th : C : ε_th dV.",
                                    "Identificar termos: energia mecânica padrão, acoplamento linear e energia térmica pura.",
                                    "Formular Π_te = U_te - W, destacando que ε_th atua como 'carga térmica' pré-deformação.",
                                    "Verificar estacionariedade: δΠ_te = 0 resulta em equações com forçantes térmicos.",
                                    "Simplificar para casos 1D (barra térmica)."
                                  ],
                                  "verification": "Derivar Π_te para um elemento 1D e mostrar que δΠ_te = 0 reproduz a equação de equilíbrio com termo α ΔT.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Papel e lápis para derivações, LaTeX ou notebook Jupyter para equações.",
                                  "tips": "Mantenha consistência notacional: use ε_total = ε_mec + ε_th.",
                                  "learningObjective": "Construir a expressão completa de Π incluindo contribuições térmicas.",
                                  "commonMistakes": "Esquecer o termo quadrático (1/2) ε_th : C : ε_th; confundir com energia interna térmica."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Formulação Rayleigh-Ritz/Galerkin",
                                  "subSteps": [
                                    "Escolher funções de aproximação u ≈ ∑ q_i φ_i, com φ_i base.",
                                    "Substituir em Π_te e minimizar: ∂Π_te / ∂q_i = 0 forma [K]{q} = {F_mec + F_th}.",
                                    "Calcular matriz de rigidez K padrão e vetor de carga térmica F_th = ∫ B^T C ε_th dV.",
                                    "Implementar para um problema simples: barra com gradiente térmico.",
                                    "Comparar soluções com e sem termo térmico."
                                  ],
                                  "verification": "Montar [K] e {F_th} para um elemento com 2 nós e resolver para deslocamentos.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Código Python/MATLAB para MEF 1D, exemplo numérico resolvido.",
                                  "tips": "Comece com malha grosseira para validar antes de refinar.",
                                  "learningObjective": "Integrar efeitos termoelásticos na discretização variacional.",
                                  "commonMistakes": "Erro na matriz B (derivadas das funções shape); integração numérica incorreta de F_th."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Analisar Resultados Termoelásticos",
                                  "subSteps": [
                                    "Comparar deslocamentos/deformações com solução analítica exata.",
                                    "Avaliar tensão residual devido a ε_th em estruturas livres de carga.",
                                    "Estudar sensibilidade a ΔT e α.",
                                    "Discutir convergência com refinamento de malha.",
                                    "Explorar extensões para 2D/3D e acoplamento full."
                                  ],
                                  "verification": "Plotar perfis de u(x) com/sem térmico e calcular erro <5%.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software FEA como ANSYS Student ou código customizado.",
                                  "tips": "Use normalização para comparar escalas mecânica vs. térmica.",
                                  "learningObjective": "Verificar implementação e interpretar resultados físico-mecânicos.",
                                  "commonMistakes": "Ignorar condições de contorno térmicas; superestimar efeitos em materiais de baixo α."
                                }
                              ],
                              "practicalExample": "Em uma barra de aço (E=200 GPa, α=12e-6 /K) fixada em uma extremidade, com ΔT(x)=100x/L (gradiente linear), comprimento L=1m. Calcule deslocamentos usando Rayleigh-Ritz com funções lineares, incluindo F_th, e compare com caso isotérmico sob mesma carga mecânica.",
                              "finalVerifications": [
                                "A energia potencial total Π_te inclui explicitamente os termos -∫σ:ε_th dV e (1/2)∫ε_th:C:ε_th dV.",
                                "O vetor de carga térmica F_th é computado corretamente para o exemplo prático.",
                                "Solução numérica converge para solução analítica u(x) = (α ΔT(x) x)/2 com erro <1%.",
                                "Interpretação física: deformação térmica causa tensão auto-equilibrada em estrutura livre.",
                                "Discussão de limitações: validade para pequenas ΔT e linearidade.",
                                "Código ou derivação manual reproduz resultados esperados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de U_te (100% dos termos corretos).",
                                "Correta implementação de F_th em Rayleigh-Ritz (erro numérico <2%).",
                                "Explicação clara do impacto físico dos efeitos termoelásticos.",
                                "Análise de convergência e sensibilidade demonstrada.",
                                "Identificação de pelo menos 3 erros comuns evitados.",
                                "Aplicação coerente ao contexto de Galerkin (equações fracas)."
                              ],
                              "crossCurricularConnections": [
                                "Física/Termodinâmica: Equação de estado termoelástica e 1º lei.",
                                "Matemática: Cálculo variacional e métodos de aproximação espectral.",
                                "Ciência de Materiais: Propriedades térmicas e anisotropia.",
                                "Engenharia Térmica: Distribuição de T em simulações acopladas."
                              ],
                              "realWorldApplication": "Projeto de freios de disco automotivos, onde aquecimento gera dilatação térmica causando deformações residuais e fadiga; ou em turbinas a gás, prevendo stresses termoelásticos para evitar falhas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.2.1.1.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.2",
                    "name": "Método de Rayleigh-Ritz",
                    "description": "Formulação variacional baseada na minimização da energia potencial com funções de aproximação globais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.2.1",
                        "name": "Energia Potencial Total",
                        "description": "Conceito fundamental da formulação variacional no método de Rayleigh-Ritz, onde a energia potencial total Π é definida como a soma da energia de deformação interna U e do trabalho potencial das forças externas V, com o princípio de minimização Π → mínimo.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.1.1",
                            "name": "Definir componentes da energia potencial",
                            "description": "Explicar e formular a energia de deformação U = (1/2) ∫ σ^T ε dV e o trabalho das cargas V = -∫ u^T b dV - ∑ u_i^T F_i, identificando tensões σ, deformações ε, forças volumétricas b e cargas nodais F_i.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Tensão, Deformação e Energia em Mecânica dos Sólidos",
                                  "subSteps": [
                                    "Revise as definições de tensão σ (vetor de tensões) e deformação ε (vetor de deformações) em termos de componentes cartesianos.",
                                    "Entenda a relação constitutiva linear elástica: σ = D ε, onde D é a matriz de rigidez.",
                                    "Discuta o princípio da conservação de energia em sistemas elásticos deformáveis.",
                                    "Identifique forças volumétricas b (como gravidade) e cargas nodais F_i (concentração de forças).",
                                    "Explore o papel do deslocamento u no contexto de elementos finitos."
                                  ],
                                  "verification": "Resuma em um diagrama as relações entre σ, ε, u, b e F_i, confirmando com equações básicas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Mecânica dos Sólidos (ex: Timoshenko), notas de aula sobre Elementos Finitos, calculadora simbólica (SymPy ou Mathematica).",
                                  "tips": "Use analogias como uma mola para visualizar energia armazenada em deformações.",
                                  "learningObjective": "Dominar os blocos de construção teóricos para energias em problemas de elastoestática.",
                                  "commonMistakes": "Confundir tensão (força/área) com esforço total; ignorar a simetria da matriz D."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular e Derivar a Energia de Deformação Interna U",
                                  "subSteps": [
                                    "Derive a expressão diferencial de trabalho incremental: dU = σ^T dε dV.",
                                    "Integre para deformação finita pequena: U = (1/2) ∫ σ^T ε dV sobre o volume.",
                                    "Expresse em termos de deslocamentos: ε = B u, onde B é a matriz de deformação.",
                                    "Discuta a quadraticidade da forma: U = (1/2) u^T K u, com K a matriz de rigidez.",
                                    "Verifique dimensionalmente: [U] = Joules."
                                  ],
                                  "verification": "Escreva a fórmula completa de U para um elemento linear 1D e compute para u constante.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel e lápis para derivação, software como MATLAB para matriz B, exemplos de elementos finitos.",
                                  "tips": "Comece com 1D (barra) para intuitionar antes de generalizar para 3D.",
                                  "learningObjective": "Capacitar a derivação e interpretação da energia elástica armazenada.",
                                  "commonMistakes": "Esquecer o fator 1/2 na integração; usar ε em vez de dε na derivada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular o Trabalho das Cargas Externas V",
                                  "subSteps": [
                                    "Defina o trabalho virtual das forças volumétricas: δV_b = -∫ u^T b dV.",
                                    "Adicione o trabalho das cargas puntiformes/nodais: δV_F = -∑ u_i^T F_i.",
                                    "Combine para V = -∫ u^T b dV - ∑ u_i^T F_i (potencial negativo do trabalho).",
                                    "Linearize em termos de graus de liberdade nodais no método dos elementos finitos.",
                                    "Compare com o princípio dos trabalhos virtuais.",
                                    "verification"
                                  ],
                                  "verification": "Calcule V para um corpo com gravidade uniforme e uma força nodal, simplificando para caso 1D.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Exemplos numéricos de problemas EF, tabela de forças distribuídas.",
                                  "tips": "Lembre-se do sinal negativo: V diminui a potencial total à medida que u aumenta.",
                                  "learningObjective": "Entender como cargas externas contribuem negativamente para a energia potencial.",
                                  "commonMistakes": "Inverter o sinal de V; confundir b (por unidade de volume) com forças totais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir e Interpretar a Energia Potencial Total Π e seus Componentes",
                                  "subSteps": [
                                    "Some os componentes: Π = U + V = (1/2) ∫ σ^T ε dV - ∫ u^T b dV - ∑ u_i^T F_i.",
                                    "Explique o mínimo de Π como condição de equilíbrio no método de Rayleigh-Ritz.",
                                    "Identifique explicitamente σ, ε, b, F_i em contextos de EF.",
                                    "Discuta aproximações Galerkin: u ≈ N d, com N funções de interpolação.",
                                    "Valide com o teorema da energia de Castigliano."
                                  ],
                                  "verification": "Escreva Π completa para um sistema discreto e derive δΠ = 0 levando a K d = F.",
                                  "estimatedTime": "55 minutos",
                                  "materials": "Artigo original de Rayleigh-Ritz, solver EF online (ex: FEA simulator gratuito).",
                                  "tips": "Visualize Π como uma 'superfície parabolóide' com mínimo no equilíbrio.",
                                  "learningObjective": "Integrar U e V na funcional de energia total e ligar ao minimizador.",
                                  "commonMistakes": "Omitir integração sobre V ou soma nodal; confundir com energia cinética."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar e Verificar em um Exemplo Simples",
                                  "subSteps": [
                                    "Escolha um elemento barra axial com carga distribuída e nodal.",
                                    "Compute U, V e Π numericamente.",
                                    "Resolva minimizando Π e compare com solução exata.",
                                    "Analise sensibilidade a parâmetros (E, A, L).",
                                    "Documente identificações de todos componentes."
                                  ],
                                  "verification": "Confirme que o deslocamento de equilíbrio satisfaz ∂Π/∂u_i = 0 para cada nodal.",
                                  "estimatedTime": "70 minutos",
                                  "materials": "Planilha Excel ou Python script para cálculo, diagrama do problema.",
                                  "tips": "Use unidades consistentes (SI) para evitar erros numéricos.",
                                  "learningObjective": "Consolidar definições através de implementação prática.",
                                  "commonMistakes": "Erro em montagem da matriz de rigidez; inconsistência de malha."
                                }
                              ],
                              "practicalExample": "Considere uma barra de aço (E=200 GPa, A=1 cm², L=1 m) fixada em uma extremidade, com gravidade b=-9.81 kN/m³ e força nodal F=1 kN na ponta livre. Calcule U = (1/2) EA (ΔL/L)² L, V = -b A (L/2) ΔL - F ΔL, encontre ΔL minimizando Π.",
                              "finalVerifications": [
                                "Derivar corretamente U e V a partir de princípios de trabalho virtual.",
                                "Identificar todos componentes (σ, ε, b, F_i) em um problema EF simples.",
                                "Escrever Π total e provar que seu mínimo dá o equilíbrio.",
                                "Aplicar em exemplo numérico com erro <1% vs. analítico.",
                                "Explicar o papel no Rayleigh-Ritz vs. Galerkin.",
                                "Discutir extensões para não-lineares."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação das fórmulas (sem erros de sinal ou fator).",
                                "Clareza na identificação de variáveis (σ como tensor, etc.).",
                                "Correção numérica em exemplo prático.",
                                "Profundidade na ligação com minimização variacional.",
                                "Capacidade de generalizar para 2D/3D.",
                                "Uso correto de notação matricial."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e métodos de minimização funcional.",
                                "Física: Princípios de conservação de energia e equilíbrio estático.",
                                "Programação: Implementação em Python/MATLAB para montagem de K e F.",
                                "Engenharia Civil: Análise de estruturas via FEM comercial (ANSYS).",
                                "Matemática Computacional: Aproximações espectrais semelhantes a Ritz."
                              ],
                              "realWorldApplication": "Em simulações FEM para projeto de pontes ou aviões, onde Π é minimizada para prever deformações sob cargas reais, otimizando peso e segurança sem protótipos físicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.2",
                            "name": "Expressar Π para problemas elásticos lineares",
                            "description": "Derivar a expressão completa da energia potencial total Π = U + V para sistemas elásticos lineares, considerando condições de contorno essenciais e naturais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes fundamentais da energia potencial total Π",
                                  "subSteps": [
                                    "Defina Π como a função total de energia potencial: Π = U + V, onde U é a energia de deformação interna e V é o potencial das cargas externas.",
                                    "Explique o princípio de energia mínima: a solução exata minimiza Π sujeito a condições de contorno essenciais.",
                                    "Diferencie condições de contorno essenciais (deslocamentos prescritos, eliminados de V) de naturais (forças prescritas, incluídas em V).",
                                    "Revise a notação para um elemento finito genérico: domínio Ω, deslocamento u(x), tensão σ, deformação ε.",
                                    "Esboce um diagrama conceitual de U (armazenada no material) e V (trabalho das cargas externas)."
                                  ],
                                  "verification": "Escreva definições precisas de Π, U e V em um papel e identifique corretamente 2 exemplos de cada tipo de condição de contorno.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": "Livro-texto de Elementos Finitos (ex: Zienkiewicz ou Bathe), papel e lápis para anotações.",
                                  "tips": "Use analogias como uma mola: U é energia elástica, V é -F*x para carga F.",
                                  "learningObjective": "Entender conceitualmente Π e suas componentes para problemas elásticos lineares.",
                                  "commonMistakes": "Confundir U com energia cinética ou ignorar que condições essenciais não entram em V."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a energia de deformação interna U para materiais elásticos lineares",
                                  "subSteps": [
                                    "Expresse U como integral de volume: U = (1/2) ∫_Ω ε^T σ dV.",
                                    "Substitua relações constitutivas lineares: σ = D ε, onde D é a matriz de rigidez elástica.",
                                    "Expresse deformações em termos de deslocamentos: ε = B u, onde B é a matriz de operadores de deformação e u são os deslocamentos nodais aproximados.",
                                    "Aproxime u via Rayleigh-Ritz: u(x) = N(x) q, onde N são funções de interpolação e q são coeficientes generalizados.",
                                    "Obtenha a forma quadrática: U = (1/2) q^T (∫_Ω B^T D B dV) q = (1/2) q^T K q, definindo a matriz de rigidez K."
                                  ],
                                  "verification": "Derive explicitamente U para um elemento 1D (barra axial) e verifique se resulta em (1/2) q^T K q.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": "Papel quadriculado, calculadora simbólica (ex: SymPy online) ou MATLAB para matrizes.",
                                  "tips": "Comece com 1D para simplicidade antes de generalizar para 2D/3D.",
                                  "learningObjective": "Derivar matematicamente U em forma matricial pronta para montagem global.",
                                  "commonMistakes": "Esquecer o fator 1/2 em U ou usar ε = ∇u incorretamente sem B."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar o potencial das cargas externas V considerando condições naturais",
                                  "subSteps": [
                                    "Defina V = - (trabalho virtual das cargas): V = - ∫_Ω b^T u dV - ∫_Γ_t t^T u dS - ∑ F_i^T u_i (cargas nodais).",
                                    "Aproxime u = N q, resultando em V = - q^T (∫_Ω N^T b dV + ∫_Γ_t N^T t dS + F_nodal) = - q^T F.",
                                    "Identifique forças de volume b, trações de superfície t e forças nodais F como condições naturais.",
                                    "Exclua explicitamente doF's (degrees of freedom) sujeitos a condições essenciais de q e ajuste F consequentemente.",
                                    "Verifique consistência: para cargas distribuídas, use integração numérica se necessário (ex: Gauss).",
                                    "verification`: "
                                  ],
                                  "estimatedTime": "45-60 minutos",
                                  "materials": "Mesmo do step 2, mais exemplos de problemas com cargas distribuídas.",
                                  "tips": "Lembre: sinal negativo em V porque minimizamos Π.",
                                  "learningObjective": "Formar o vetor de carga equivalente F corretamente.",
                                  "commonMistakes": "Incluir cargas de condições essenciais em V ou esquecer integrações de superfície."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incorporar condições de contorno essenciais e formar Π completa",
                                  "subSteps": [
                                    "Liste todos doF's do sistema e identifique essenciais (u_prescrito = valores conhecidos).",
                                    "Particione q = [q_livre; q_fixo], onde q_fixo é conhecido; substitua em Π.",
                                    "Reduza Π para variáveis livres: Π(q_livre) = (1/2) q_livre^T K_red q_livre - q_livre^T F_red + termos constantes (ignorados na minimização).",
                                    "Escreva a expressão final: Π = (1/2) q^T K q - q^T F, com K e F reduzidos/apropriados.",
                                    "Confirme que dΠ/dq = 0 leva a K q = F, o sistema de equações de equilíbrio."
                                  ],
                                  "verification": "Aplique a uma estrutura simples (ex: viga cantilever) e resolva ∂Π/∂q = 0 para verificar equilíbrio.",
                                  "estimatedTime": "60-90 minutos",
                                  "materials": "Software FEM simbólico ou papel para partição matricial.",
                                  "tips": "Use índice livre/fixo para evitar confusão em grandes sistemas.",
                                  "learningObjective": "Montar Π final considerando todas condições de contorno.",
                                  "commonMistakes": "Não reduzir K/F corretamente, levando a singularidade."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e preparar para aplicação no método Rayleigh-Ritz",
                                  "subSteps": [
                                    "Revise Π para consistência dimensional (energia: Joules).",
                                    "Discuta linearidade: válida apenas para elástico linear (D constante).",
                                    "Estenda para montagem global: some U_e e V_e sobre elementos.",
                                    "Prepare para minimização: stationary point via ∇Π = Kq - F = 0.",
                                    "Teste com exemplo numérico simples para confirmar."
                                  ],
                                  "verification": "Implemente Π em código simples e compare com solução analítica.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": "Python/MATLAB para protótipo numérico.",
                                  "tips": "Sempre normalize unidades (ex: kN, mm).",
                                  "learningObjective": "Integrar Π ao fluxo completo do Rayleigh-Ritz.",
                                  "commonMistakes": "Assumir não-linearidade ou ignorar montagem global."
                                }
                              ],
                              "practicalExample": "Considere uma barra axial 1D de comprimento L=1m, seção A=1cm², E=200GPa, fixada em x=0 (condição essencial u(0)=0) e carga F=1kN em x=L (natural). Aproxime u(x) = (x/L) q1 (1 doF livre). Derive Π = (1/2)(EA/L) q1² - F q1, minimizando obtém q1 = F L / (EA).",
                              "finalVerifications": [
                                "Π inclui corretamente U quadrática e V linear negativa.",
                                "Condições essenciais eliminadas de q, naturais em F.",
                                "Dimensionalmente consistente e ∂Π/∂q = Kq - F = 0.",
                                "Redução matricial para doF's livres é precisa.",
                                "Exemplo prático resolve para deslocamento esperado.",
                                "Pronto para montagem em malha multi-elemento."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de U (uso correto de B, D, integração).",
                                "Correção em V (todos termos de carga, sinal negativo).",
                                "Tratamento adequado de condições de contorno (essenciais vs. naturais).",
                                "Forma final matricial válida para resolução numérica.",
                                "Compreensão conceitual (explicação do mínimo estacionário).",
                                "Aplicação em exemplo concreto sem erros aritméticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e minimização funcional.",
                                "Física: Princípio dos trabalhos virtuais e conservação de energia.",
                                "Computação: Implementação em código FEM (MATLAB/Python).",
                                "Engenharia de Materiais: Relações constitutivas lineares D.",
                                "Análise Numérica: Integração numérica para K e F."
                              ],
                              "realWorldApplication": "Na análise de estruturas via Elementos Finitos (ex: ANSYS, Abaqus), Π é usada para prever deformações em pontes, aviões ou implantes médicos sob cargas, otimizando designs para segurança e eficiência."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.3",
                            "name": "Relacionar Π com o princípio dos trabalhos virtuais",
                            "description": "Demonstrar a equivalência entre a minimização de Π e o princípio dos trabalhos virtuais para deslocamentos admissíveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Energia Potencial Total Π",
                                  "subSteps": [
                                    "Definir Π como a soma da energia de deformação interna U e do potencial dos carregamentos externos -W.",
                                    "Escrever a expressão matemática de Π para um sistema discreto com graus de liberdade q_i: Π(q) = (1/2) q^T K q - q^T F.",
                                    "Explicar o papel dos deslocamentos admissíveis no método de Rayleigh-Ritz.",
                                    "Discutir a condição de minimização: δΠ = 0 para equilíbrio.",
                                    "Identificar os termos quadráticos e lineares em Π."
                                  ],
                                  "verification": "Escrever corretamente a expressão de Π para um sistema com 2 graus de liberdade e computar δΠ.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Elementos Finitos (ex: Bathe ou Zienkiewicz)",
                                    "Folha de papel e calculadora",
                                    "Notas de aula sobre Rayleigh-Ritz"
                                  ],
                                  "tips": "Visualize Π como uma função parabolóide cujos mínimos correspondem ao equilíbrio.",
                                  "learningObjective": "Dominar a formulação matemática da energia potencial total e sua minimização.",
                                  "commonMistakes": [
                                    "Confundir energia interna U com energia cinética",
                                    "Esquecer o sinal negativo no potencial dos carregamentos",
                                    "Ignorar restrições de deslocamentos admissíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar o Princípio dos Trabalhos Virtuais (PVV)",
                                  "subSteps": [
                                    "Enunciar o PVV: Para equilíbrio, o trabalho virtual δW_int = δW_ext para variações virtuais δu admissíveis.",
                                    "Expressar em forma discreta: δu^T K u = δu^T F, para qualquer δu kinemáticamente admissível.",
                                    "Explicar o conceito de deslocamentos virtuais δu como variações arbitrárias no espaço admissível.",
                                    "Comparar com princípios de equilíbrio estático tradicional.",
                                    "Derivar a forma matricial do PVV a partir da definição integral."
                                  ],
                                  "verification": "Formular o PVV para um sistema discreto e mostrar que resulta em K u = F.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Referência: Livro de Mecânica dos Sólidos",
                                    "Software simbólico como Mathematica ou SymPy",
                                    "Quadro branco"
                                  ],
                                  "tips": "Lembre-se: PVV é fraco, não requer continuidade de derivadas como no equilíbrio forte.",
                                  "learningObjective": "Entender a formulação fraca do PVV e sua representação matricial.",
                                  "commonMistakes": [
                                    "Confundir trabalhos reais com virtuais",
                                    "Restringir δu a ser finito em vez de infinitesimal",
                                    "Omitir a exigência de admissibilidade kinemática"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Equivalência entre Minimização de Π e PVV",
                                  "subSteps": [
                                    "Calcular a variação de Π: δΠ = δq^T (K q - F) = 0 para todo δq admissível.",
                                    "Mostrar que δΠ = 0 implica δq^T K q = δq^T F, que é exatamente o PVV discreto.",
                                    "Provar a recíproca: se PVV vale, então δΠ = 0, implicando mínimo local de Π.",
                                    "Discutir convexidade de Π para garantir mínimo global em problemas lineares.",
                                    "Generalizar para funções de aproximação no Rayleigh-Ritz."
                                  ],
                                  "verification": "Realizar a derivação passo a passo e verificar que δΠ leva diretamente à equação do PVV.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Caderno de derivadas",
                                    "Exemplos resolvidos de livros de FEM",
                                    "Python/MATLAB para verificação numérica simbólica"
                                  ],
                                  "tips": "Use a linearidade da variação: δ( q^T K q ) = 2 q^T K δq (mas ajuste para 1/2 no coeficiente).",
                                  "learningObjective": "Demonstrar matematicamente a equivalência entre stationary Π e PVV.",
                                  "commonMistakes": [
                                    "Erro no cálculo da variação quadrática (fator 1/2)",
                                    "Não considerar que δq é arbitrário, levando a K q = F",
                                    "Confundir mínimo com stationary point em problemas não-convexos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Equivalência em um Exemplo Simples",
                                  "subSteps": [
                                    "Escolher um sistema: viga cantilever com carga pontual, aproximada por 2 elementos lineares.",
                                    "Computar Π explicitamente em termos dos graus de liberdade.",
                                    "Minimizar Π analiticamente e obter deslocamentos.",
                                    "Aplicar PVV independentemente e comparar resultados.",
                                    "Verificar numericamente com software FEM."
                                  ],
                                  "verification": "Resultados de minimização de Π coincidem com solução do PVV em até 1% de erro.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software FEM como ANSYS Student ou código MATLAB simples",
                                    "Dados do exemplo: L=1m, E=210GPa, I=1e-4 m^4, P=1kN"
                                  ],
                                  "tips": "Comece com um sistema 1D para simplicidade antes de 2D.",
                                  "learningObjective": "Aplicar a relação em prática para consolidar o entendimento.",
                                  "commonMistakes": [
                                    "Erros de unidades nas matrizes de rigidez",
                                    "Aproximações inadequadas nos modos de Rayleigh-Ritz",
                                    "Não validar com solução exata"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma viga em cantilever de comprimento L=1m, seção retangular (E=210 GPa, I=10^{-4} m^4), com carga P=1 kN na ponta. Usando aproximação linear com 2 nós (3 DOFs), compute Π(q) = (1/2) q^T K q - P q_3. Minimize ∂Π/∂q_i=0 e compare com PVV: δq^T (K q - F)=0. Ambas dão q = K^{-1} F idêntico.",
                              "finalVerifications": [
                                "Derivação completa de δΠ = δq^T (K q - F) = 0.",
                                "Prova da equivalência bidirecional entre stationary Π e PVV.",
                                "Aplicação numérica em exemplo simples com resultados coincidentes.",
                                "Explicação clara de deslocamentos admissíveis em ambos os contextos.",
                                "Identificação de condições para mínimo único (problemas lineares).",
                                "Generalização para métodos variacionais em FEM."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação da variação δΠ (sem erros algébricos).",
                                "Correta interpretação física da equivalência (mínimo energia vs. equilíbrio virtual).",
                                "Qualidade da prova da recíproca (PVV implica stationary Π).",
                                "Aplicação prática em exemplo com cálculos verificáveis.",
                                "Clareza na discussão de limitações (ex: não-linearidades).",
                                "Uso adequado de notação matricial e vetorial."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e métodos de otimização.",
                                "Física: Princípios de mecânica clássica e energia em sistemas conservativos.",
                                "Computação: Implementação numérica em solvers FEM (MATLAB, Python).",
                                "Engenharia Civil: Análise estrutural por elementos finitos.",
                                "Matemática Aplicada: Teoria funcional e espaços de Sobolev."
                              ],
                              "realWorldApplication": "Em softwares de Elementos Finitos como ANSYS ou Abaqus, essa equivalência permite escolher entre formulações baseadas em energia (direct stiffness) ou PVV (weak form), otimizando simulações de estruturas reais como pontes ou aviões, reduzindo tempo computacional em problemas lineares elásticos."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.2",
                        "name": "Funções de Aproximação Globais",
                        "description": "Seleção de funções de interpolação globais que satisfazem as condições de contorno essenciais, aproximando o campo de deslocamentos u ≈ ∑ q_i φ_i(x), onde φ_i são funções base e q_i parâmetros generalizados.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.2.1",
                            "name": "Escolher funções admissíveis",
                            "description": "Identificar requisitos para funções φ_i: completude, continuidade e satisfação de condições geométricas e de contorno essenciais, com exemplos como polinômios trigonométricos ou seno para vigas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Requisitos Fundamentais de Completude e Continuidade",
                                  "subSteps": [
                                    "Estude a definição de completude: as funções φ_i devem formar um conjunto completo capaz de aproximar qualquer função suave no domínio.",
                                    "Analise continuidade: garanta que as funções sejam C^0 ou C^1 contínuas conforme exigido pela formulação variacional (ex: derivadas contínuas para energia de flexão).",
                                    "Revise propriedades matemáticas: ortogonalidade, normalização e base de funções (ex: séries de Fourier).",
                                    "Compare com funções não-admissíveis: identifique por que funções descontínuas falham.",
                                    "Resolva exercícios simples: verifique completude em intervalos [0,L] com polinômios."
                                  ],
                                  "verification": "Liste e explique corretamente completude e continuidade com um exemplo matemático.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Elementos Finitos (Zienkiewicz)",
                                    "Notas de aula sobre Rayleigh-Ritz",
                                    "Calculadora simbólica (SymPy ou Mathematica)"
                                  ],
                                  "tips": "Comece com 1D para simplicidade; visualize graficamente as funções.",
                                  "learningObjective": "Identificar e justificar completude e continuidade em funções de aproximação.",
                                  "commonMistakes": [
                                    "Confundir completude com ortogonalidade",
                                    "Ignorar requisitos de derivabilidade para problemas de ordem superior"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar Condições Geométricas e de Contorno Essenciais",
                                  "subSteps": [
                                    "Defina condições essenciais (Dirichlet): deslocamentos prescritos que devem ser exatamente satisfeitos pelas φ_i.",
                                    "Diferencie de condições naturais (Neumann): cargas que são impostas via integral de fraqueza.",
                                    "Estude condições geométricas: simetria, periodicidade para domínios específicos.",
                                    "Aprenda técnicas de satisfação: multiplicar por funções que zeram nas fronteiras (ex: φ_i(x) = sin(nπx/L) para viga engastada).",
                                    "Pratique: modifique funções polinomiais para satisfazer u(0)=0 e u(L)=0."
                                  ],
                                  "verification": "Construa uma função que satisfaça u(0)=u(L)=0 e verifique graficamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Artigos sobre métodos variacionais",
                                    "Software de plotagem (Matplotlib ou MATLAB)",
                                    "Exemplos de problemas de vigas"
                                  ],
                                  "tips": "Use funções seno/trigonométricas para contornos homogêneos; memorize padrões comuns.",
                                  "learningObjective": "Aplicar condições de contorno essenciais às funções de aproximação.",
                                  "commonMistakes": [
                                    "Impor condições essenciais via penalização ao invés de exatamente",
                                    "Confundir essenciais com naturais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Exemplos Comuns de Funções Admissíveis",
                                  "subSteps": [
                                    "Analise polinômios trigonométricos: φ_i(θ) = sin(iθ) para problemas circulares.",
                                    "Estude funções seno para vigas: φ_i(x) = sin(iπx/L) para flexão com contorno livre-engastado.",
                                    "Compare com polinômios de Legendre ou Chebyshev para completude ótima.",
                                    "Implemente numericamente: calcule matriz de rigidez com 3 funções.",
                                    "Avalie convergência: plote erro vs. número de funções."
                                  ],
                                  "verification": "Selecione e justifique 3 funções para uma viga cantilever e compute uma propriedade básica.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código Python/MATLAB para Rayleigh-Ritz",
                                    "Tabelas de funções ortogonais",
                                    "Vídeos tutoriais sobre MEF 1D"
                                  ],
                                  "tips": "Escolha funções ortogonais para reduzir acoplamento na matriz.",
                                  "learningObjective": "Selecionar funções admissíveis adequadas para geometrias comuns.",
                                  "commonMistakes": [
                                    "Usar funções que não satisfazem contorno, levando a singularidade",
                                    "Escolher muitas funções desnecessariamente, aumentando custo computacional"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Seleção e Validação de Funções Admissíveis",
                                  "subSteps": [
                                    "Resolva problema completo: viga em flexão com carga distribuída, escolha φ_i.",
                                    "Valide requisitos: cheque completude via expansão de série, continuidade por derivadas, contorno por avaliação.",
                                    "Compare resultados com solução exata ou FEA comercial.",
                                    "Otimize escolha: teste diferentes famílias (seno vs. polinômios) por precisão/custo.",
                                    "Documente processo: crie relatório com justificativas."
                                  ],
                                  "verification": "Resolva um problema e mostre que os requisitos são satisfeitos com erro <5%.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Problemas resolvidos de livros MEF",
                                    "Software FEA (ex: FreeFEM ou código próprio)",
                                    "Planilha para análise de convergência"
                                  ],
                                  "tips": "Inicie com poucas funções e aumente iterativamente para testar convergência.",
                                  "learningObjective": "Escolher e validar funções admissíveis de forma independente para problemas reais.",
                                  "commonMistakes": [
                                    "Não verificar numericamente a satisfação de contorno",
                                    "Ignorar escalabilidade para problemas 2D/3D"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma viga cantilever de comprimento L sob carga uniforme q, escolha φ_i(x) = (x/L)^i para i=2,3,... (satisfaz φ(0)=φ'(0)=0). Compute deslocamento máximo e compare com solução exata qL^4/(8EI).",
                              "finalVerifications": [
                                "Liste os três requisitos principais (completude, continuidade, contorno essencial) sem erros.",
                                "Construa funções admissíveis para pelo menos dois tipos de contorno (engastado-livre, biengastada).",
                                "Explique por que funções seno são preferíveis para vigas biengastadas.",
                                "Valide uma escolha em um problema simples com cálculo manual.",
                                "Identifique uma função não-admissível e justifique a falha."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de todos os requisitos (100% cobertura).",
                                "Correta aplicação em exemplos concretos (erro <10% vs. exato).",
                                "Justificativa clara e matemática para escolhas.",
                                "Capacidade de otimizar número de funções por convergência.",
                                "Integração com formulação Rayleigh-Ritz (matrizes corretas).",
                                "Criatividade em extensões para geometrias não-triviais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise funcional, séries de Fourier e ortogonalidade.",
                                "Física: Mecânica dos sólidos, princípio dos trabalhos virtuais.",
                                "Computação: Implementação numérica em Python/MATLAB para MEF.",
                                "Engenharia Civil: Análise de estruturas lineares."
                              ],
                              "realWorldApplication": "Na simulação de componentes mecânicos em software como ANSYS ou Abaqus, funções admissíveis globais aceleram prototipagem de modelos Rayleigh-Ritz para otimização de vigas, placas e cascas em design aeroespacial e automotivo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.2",
                            "name": "Formular aproximação do deslocamento",
                            "description": "Escrever a aproximação u(x) = ∑_{i=1}^n q_i φ_i(x) para problemas 1D e estender para 2D/3D, calculando deformações ε ≈ B(q) a partir das funções φ_i.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender funções de aproximação globais em 1D",
                                  "subSteps": [
                                    "Estudar tipos de funções φ_i(x), como polinomiais, senos/cossenos e funções spline.",
                                    "Verificar satisfação das condições de contorno essenciais (ex: φ_i(0)=0 para apoio fixo).",
                                    "Selecionar um conjunto de n funções linearmente independentes para o domínio [0,L].",
                                    "Plotar as funções φ_i(x) para visualizar sua forma e sobreposição.",
                                    "Testar ortogonalidade ou normalização se aplicável."
                                  ],
                                  "verification": "Plotar ou tabular φ_i(x) em pontos chave e confirmar que satisfazem condições de contorno.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Caderno e lápis",
                                    "Software de plotagem como MATLAB ou Python (Matplotlib)",
                                    "Livro de Elementos Finitos (ex: Bathe ou Zienkiewicz)"
                                  ],
                                  "tips": "Comece com funções polinomiais simples para evitar complexidade inicial.",
                                  "learningObjective": "Identificar e validar funções φ_i adequadas para aproximações em 1D.",
                                  "commonMistakes": [
                                    "Ignorar condições de contorno, levando a soluções inválidas.",
                                    "Escolher funções linearmente dependentes, causando singularidade na matriz."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a aproximação do deslocamento u(x) em 1D",
                                  "subSteps": [
                                    "Escrever a expansão geral u(x) ≈ ∑_{i=1}^n q_i φ_i(x), onde q_i são coeficientes generalizados.",
                                    "Exemplificar com n=2 ou 3 funções específicas (ex: φ1(x)=x/L, φ2(x)=sin(πx/L)).",
                                    "Derivar a expressão nodal: u(x) = Φ(x) q, com Φ vetor de funções.",
                                    "Verificar dimensionalidade: u em metros, φ adimensional ou com unidades consistentes.",
                                    "Aplicar em um problema simples de tração axial."
                                  ],
                                  "verification": "Escrever explicitamente u(x) para um caso teste e calcular u em extremos do domínio.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Calculadora simbólica (ex: SymPy em Python)",
                                    "Papel quadriculado"
                                  ],
                                  "tips": "Use notação vetorial desde o início para facilitar extensão multidimensional.",
                                  "learningObjective": "Construir a aproximação trial u(x) no método de Rayleigh-Ritz para 1D.",
                                  "commonMistakes": [
                                    "Confundir q_i com deslocamentos nodais em métodos locais.",
                                    "Esquecer o somatório de i=1 a n."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular deformações ε em 1D a partir de B(q)",
                                  "subSteps": [
                                    "Derivar ε(x) = du/dx ≈ ∑_{i=1}^n q_i dφ_i/dx(x).",
                                    "Definir o operador B(x) = [dφ1/dx, dφ2/dx, ..., dφn/dx] como vetor linha.",
                                    "Escrever ε ≈ B(x) q.",
                                    "Calcular numericamente B em pontos de Gauss ou analiticamente.",
                                    "Verificar que ε é consistente com teoria da elasticidade 1D."
                                  ],
                                  "verification": "Diferenciar u(x) analiticamente e comparar com B q para valores de q teste.",
                                  "estimatedTime": "1-1.5 horas",
                                  "materials": [
                                    "Software simbólico (MATLAB Symbolic ou SymPy)",
                                    "Tabela de derivadas das φ_i"
                                  ],
                                  "tips": "Mantenha B como função de x para integração posterior na energia.",
                                  "learningObjective": "Obter a aproximação das deformações ε via operador B no contexto 1D.",
                                  "commonMistakes": [
                                    "Derivar incorretamente dφ_i/dx.",
                                    "Tratar B como constante em vez de função de x."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estender a formulação para problemas 2D",
                                  "subSteps": [
                                    "Generalizar u(x,y) = ∑_{i=1}^n q_i φ_i(x,y) para vetor deslocamento [u,v].",
                                    "Definir φ_i escalares ou vetoriais para cada componente.",
                                    "Formular tensor de deformações ε = [ε_xx, ε_yy, γ_xy]^T ≈ B q, com B(2x n) ou similar.",
                                    "Exemplificar com funções polinomiais bivariadas (ex: φ_i = x^m y^k).",
                                    "Verificar condições de contorno em 2D."
                                  ],
                                  "verification": "Escrever matriz B explícita para n=3 e calcular ε em um ponto interno.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software vetorial (MATLAB ou FEniCS)",
                                    "Referência de MEF 2D"
                                  ],
                                  "tips": "Use coordenadas normalizadas ξ,η para simplicidade em domínios retangulares.",
                                  "learningObjective": "Adaptar aproximação e operador B para domínios 2D planas.",
                                  "commonMistakes": [
                                    "Confundir γ_xy com 2ε_xy na definição de B.",
                                    "Não considerar acoplamento u-v nas funções."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Estender para problemas 3D e finalizar conceitos",
                                  "subSteps": [
                                    "Estender u(x,y,z) = ∑ q_i φ_i(x,y,z) para [u,v,w].",
                                    "Definir ε 3D com 6 componentes: ε_xx, ε_yy, ε_zz, γ_xy, γ_xz, γ_yz ≈ B q (6x n).",
                                    "Construir linhas de B: ex: linha ε_xx = ∂φ_i/∂x.",
                                    "Discutir escolha de φ_i em 3D (ex: séries de Fourier 3D).",
                                    "Comparar com formulações 1D/2D."
                                  ],
                                  "verification": "Implementar B 3D para caso simples e verificar simetria do tensor ε.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Software 3D como Abaqus viewer ou Python com NumPy",
                                    "Notas de aulas anteriores"
                                  ],
                                  "tips": "Foque em blocos diagonais para componentes desacopladas inicialmente.",
                                  "learningObjective": "Generalizar completamente a aproximação para 3D no Rayleigh-Ritz.",
                                  "commonMistakes": [
                                    "Esquecer fatores 1/2 em γ_ij na matriz de rigidez posterior.",
                                    "Funções φ_i não completas, violando rigidez."
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma barra 1D de L=1m, use φ1(x)=x, φ2(x)=x(1-x). Então u(x)=q1 x + q2 x(1-x). Deformação ε(x)=q1 + q2(1-2x) = [1, 1-2x] q. Em 2D, para placa unitária, φ1=x y, etc., estendendo аналогично.",
                              "finalVerifications": [
                                "u(x) escrita corretamente como soma q_i φ_i em todas dimensões.",
                                "Matriz B derivada e ε = B q verificada por diferenciação.",
                                "Condições de contorno satisfeitas pelas φ_i.",
                                "Extensão dimensional consistente (1D vetor 1xn, 2D 3xn, 3D 6xn).",
                                "Exemplo numérico resolvido sem erros matemáticos.",
                                "Plot de u e ε coerente com física esperada."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática na derivação de u e B (100%).",
                                "Adequação das funções φ_i às condições do problema (90%).",
                                "Clareza na generalização 1D→2D→3D.",
                                "Precisão nos componentes do tensor ε.",
                                "Capacidade de aplicar em exemplo prático.",
                                "Identificação de potenciais issues como ill-conditioning."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise funcional, séries de expansão e derivadas parciais.",
                                "Física: Teoria da elasticidade linear e deformações.",
                                "Programação: Implementação numérica em MATLAB/Python para plot e cálculo.",
                                "Engenharia Civil: Análise de estruturas com MEF global.",
                                "Cálculo Numérico: Integração de B na formulação variacional."
                              ],
                              "realWorldApplication": "Em simulações de elementos finitos globais para otimização de vigas, placas e sólidos em engenharia aeroespacial e automotiva, permitindo análise rápida de estruturas complexas sem malha fina, como em métodos de Rayleigh-Ritz para vibrações modais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.3",
                            "name": "Avaliar precisão da aproximação",
                            "description": "Discutir critérios de convergência e monotonia superior da solução de Rayleigh-Ritz em relação à solução exata.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Princípios Variacionais e Método Rayleigh-Ritz",
                                  "subSteps": [
                                    "Relembrar o princípio da energia mínima em problemas de valores de contorno elásticos.",
                                    "Explicar a formulação do método Rayleigh-Ritz usando funções de aproximação globais.",
                                    "Derivar a equação de Rayleigh quotient para o menor autovalor.",
                                    "Discutir a escolha de funções de base admissíveis (satisfazendo condições de contorno).",
                                    "Calcular a energia potencial total para uma aproximação trial."
                                  ],
                                  "verification": "Derivar corretamente o Rayleigh quotient para um exemplo simples e comparar com referências teóricas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de Elementos Finitos (ex: Zienkiewicz), notas de aula, calculadora simbólica (Mathematica ou SymPy).",
                                  "tips": "Comece com funções polinomiais simples para visualização intuitiva da aproximação.",
                                  "learningObjective": "Compreender a base variacional que garante propriedades como convergência e monotonia.",
                                  "commonMistakes": "Confundir funções trial com funções exatas; ignorar condições de contorno essenciais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Teorema de Convergência de Rayleigh-Ritz",
                                  "subSteps": [
                                    "Enunciar o teorema de convergência: solução aproximada converge para exata à medida que espaço de funções aumenta.",
                                    "Provar ou derivar a estimativa de erro usando norma de energia.",
                                    "Analisar dependência na completude do conjunto de funções de base.",
                                    "Discutir taxas de convergência para funções polinomiais vs. trigonométricas.",
                                    "Implementar numéricamente para um problema 1D (ex: vibração de corda)."
                                  ],
                                  "verification": "Demonstrar numericamente convergência reduzindo erro de energia em iterações sucessivas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software MATLAB/Python com NumPy/SciPy, exemplos de código para Rayleigh-Ritz.",
                                  "tips": "Use refinamento h (mais termos) para observar convergência monotônica.",
                                  "learningObjective": "Dominar critérios matemáticos que garantem convergência da aproximação.",
                                  "commonMistakes": "Assumir convergência uniforme sem verificar completude do espaço funcional."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Monotonia Superior da Solução Aproximada",
                                  "subSteps": [
                                    "Explicar o teorema da monotonia superior: energia de Rayleigh-Ritz ≥ energia exata.",
                                    "Derivar prova usando ortogonalidade residual e princípio mínimo.",
                                    "Comparar autovalores aproximados (sempre maiores ou iguais aos exatos).",
                                    "Estender para autovalores superiores: λ_k^RR ≥ λ_k^exata.",
                                    "Visualizar com gráfico de energia vs. número de graus de liberdade."
                                  ],
                                  "verification": "Provar que para subespaços aninhados, a energia diminui monotonicamente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Papel e lápis para derivações, applet interativo de Rayleigh-Ritz online.",
                                  "tips": "Lembre-se: monotonia é para autovalores ascendentes, não descendentes.",
                                  "learningObjective": "Entender por que soluções Rayleigh-Ritz fornecem limites superiores seguros.",
                                  "commonMistakes": "Confundir monotonia com convergência; aplicar a métodos não-variacionais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Precisão em Exemplo Prático e Discutir Critérios",
                                  "subSteps": [
                                    "Escolher problema modelo: viga em flexão com polinômios cubicos.",
                                    "Calcular solução exata e aproximações com 2, 3, 4 termos.",
                                    "Computar erros relativos em deslocamentos e energias.",
                                    "Aplicar critérios: verificar convergência (erro < 1%), monotonia (energia decrescente).",
                                    "Discutir limites: ill-condicionamento para muitos DOFs."
                                  ],
                                  "verification": "Relatório com tabela de erros mostrando convergência e monotonia superior.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Planilha Excel ou Jupyter Notebook, solução analítica referenciada.",
                                  "tips": "Normalise erros pela solução exata para comparações justas.",
                                  "learningObjective": "Aplicar critérios para quantificar precisão em cenários reais.",
                                  "commonMistakes": "Usar normas inadequadas (L2 vs. energia); ignorar efeitos de contorno."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar Critérios de Avaliação de Precisão",
                                  "subSteps": [
                                    "Listar critérios chave: convergência em norma energia, monotonia, erro a posteriori.",
                                    "Comparar com solução exata ou FEM refinado.",
                                    "Discutir adaptações para problemas não-lineares.",
                                    "Redigir resumo com condições para 'aproximação precisa'.",
                                    "Preparar apresentação de 2 minutos explicando trade-offs."
                                  ],
                                  "verification": "Quiz autoavaliado: explicar 3 critérios com exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Modelo de relatório, gravação de vídeo para autoavaliação.",
                                  "tips": "Priorize energia sobre deslocamentos para avaliação conservadora.",
                                  "learningObjective": "Integrar conhecimentos para avaliação holística de precisão.",
                                  "commonMistakes": "Superestimar precisão sem múltiplos indicadores."
                                }
                              ],
                              "practicalExample": "Em uma viga cantilever de comprimento L sob carga distribuída, use funções trial sin(x/L) e (x/L)^2. Calcule frequências naturais aproximadas com 2 termos: ω1^RR = 3.57 rad/s (exata: 3.52 rad/s), mostrando monotonia superior e convergência ao adicionar termos.",
                              "finalVerifications": [
                                "Explicar teorema de convergência com prova esboçada.",
                                "Demonstrar numericamente monotonia em energia para 3 refinamentos.",
                                "Calcular erro relativo <5% em autovalor dominante.",
                                "Identificar 2 limitações de funções globais.",
                                "Discutir quando usar Rayleigh-Ritz vs. FEM local.",
                                "Apresentar gráfico de convergência monotônica."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática na derivação de teoremas (30%).",
                                "Precisão numérica em exemplos com erros quantificados (25%).",
                                "Profundidade na discussão de monotonia e convergência (20%).",
                                "Clareza na identificação de critérios práticos (15%).",
                                "Integração de conexões reais e limitações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Funcional e Espaços de Sobolev.",
                                "Física: Princípios Variacionais em Mecânica Clássica.",
                                "Computação: Implementação Numérica e Otimização.",
                                "Engenharia Civil: Análise Estrutural Pré-FEM."
                              ],
                              "realWorldApplication": "Em design de aeronaves, avaliar precisão de aproximações Rayleigh-Ritz para modos de vibração de painéis garante margens de segurança conservadoras antes de simulações FEM caras, otimizando peso e custo."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.3",
                        "name": "Minimização da Energia Potencial",
                        "description": "Processo de minimização estacionária de Π com respeito aos parâmetros q_i, resultando no sistema linear [K]{q} = {F}, onde K_{ij} = ∂²Π/∂q_i ∂q_j e F_i = -∂Π/∂q_i.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.3.1",
                            "name": "Derivar as equações de equilíbrio",
                            "description": "Aplicar a condição ∂Π/∂q_i = 0 para obter ∑_j K_{ij} q_j = F_i, com K_{ij} = ∫ B_i^T D B_j dV e F_i envolvendo cargas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a expressão da energia potencial total Π",
                                  "subSteps": [
                                    "Recordar que a energia potencial total Π é a soma da energia de deformação interna U e do potencial das cargas externas V: Π = U + V.",
                                    "Escrever a expressão para U: U = (1/2) ∫ σ^T ε dV = (1/2) ∫ ε^T D ε dV, onde ε = B q.",
                                    "Escrever a expressão para V: V = - ∫ u^T b dV - ∫ u^T t dS - ∑ u^T F.",
                                    "Identificar as funções de interpolação N, a matriz de derivadas B e os graus de liberdade q.",
                                    "Verificar a consistência das expressões para um elemento simples."
                                  ],
                                  "verification": "O aluno deve escrever corretamente as expressões de U e V em termos de q, B e D.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Elementos Finitos (ex: Bathe ou Zienkiewicz)",
                                    "Folha de papel e calculadora",
                                    "Notas de aula sobre Rayleigh-Ritz"
                                  ],
                                  "tips": "Comece sempre pelas definições físicas para evitar confusões algébricas.",
                                  "learningObjective": "Compreender os componentes da energia potencial e expressá-los em termos dos parâmetros do elemento finito.",
                                  "commonMistakes": [
                                    "Confundir ε com σ",
                                    "Esquecer o fator 1/2 em U",
                                    "Não expressar u = N q corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a condição de minimização ∂Π/∂q_i = 0",
                                  "subSteps": [
                                    "Lembrar que o equilíbrio é obtido minimizando Π, ou seja, ∂Π/∂q_i = 0 para todo i.",
                                    "Escrever ∂Π/∂q_i = ∂U/∂q_i + ∂V/∂q_i = 0.",
                                    "Reconhecer que isso leva a uma equação linear do tipo ∑_j K_{ij} q_j = F_i.",
                                    "Discutir o significado físico: forças internas equilibram forças externas.",
                                    "Verificar para um sistema com um grau de liberdade."
                                  ],
                                  "verification": "O aluno deve derivar verbalmente ou por escrito a condição ∂Π/∂q_i = 0 e interpretá-la.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Quadro branco ou papel para derivadas simbólicas",
                                    "Exemplos resolvidos de aula"
                                  ],
                                  "tips": "Pense em termos de trabalho virtual: δΠ = 0 para variações admissíveis.",
                                  "learningObjective": "Aplicar o princípio variacional de Rayleigh-Ritz para obter condições de equilíbrio.",
                                  "commonMistakes": [
                                    "Confundir minimização com maximização",
                                    "Esquecer que a derivada é zero em ponto estacionário",
                                    "Não linearizar corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar o termo de rigidez K_{ij}",
                                  "subSteps": [
                                    "Calcular ∂U/∂q_i = ∂/∂q_i [ (1/2) q^T (∫ B^T D B dV) q ] = ∑_j q_j ∫ B_i^T D B_j dV.",
                                    "Identificar K_{ij} = ∫_Ω B_i^T D B_j dV, onde Ω é o domínio do elemento.",
                                    "Verificar propriedades: K é simétrica (K_{ij} = K_{ji}) e positiva definida.",
                                    "Computar explicitamente para um elemento 1D (barra).",
                                    "Discutir integração numérica se necessário (Gauss)."
                                  ],
                                  "verification": "O aluno deve escrever K_{ij} corretamente e computar para um exemplo simples.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software simbólico como Mathematica ou SymPy",
                                    "Tabelas de matrizes B para elementos comuns"
                                  ],
                                  "tips": "Use a regra da cadeia: ∂(ε^T D ε)/∂q_i = 2 B_i^T D ε, mas ajuste para 1/2.",
                                  "learningObjective": "Derivar a matriz de rigidez elementar a partir da energia de deformação.",
                                  "commonMistakes": [
                                    "Esquecer a transposta B^T",
                                    "Não integrar sobre o volume dV",
                                    "Confundir índices i e j"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar o vetor de forças nodais F_i",
                                  "subSteps": [
                                    "Calcular ∂V/∂q_i = - ∫ N_i^T b dV - ∫ N_i^T t dS - F_i^{concentrado}.",
                                    "Identificar F_i como o vetor de forças nodais equivalentes.",
                                    "Para cargas volumétricas: F_i = ∫ N_i^T b dV.",
                                    "Para tração: F_i = ∫ N_i^T t dS.",
                                    "Montar a equação final: ∑_j K_{ij} q_j = F_i para todo i."
                                  ],
                                  "verification": "O aluno deve derivar F_i para um caso com carga distribuída e verificar equilíbrio.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exemplos numéricos de cargas em elementos finitos",
                                    "Calculadora para integrais simples"
                                  ],
                                  "tips": "Lembre-se do sinal negativo em V, então ∂V/∂q_i é negativo.",
                                  "learningObjective": "Derivar o vetor de forças nodais a partir do potencial das cargas externas.",
                                  "commonMistakes": [
                                    "Sinal errado no vetor F",
                                    "Confundir N_i com B_i",
                                    "Esquecer contribuições de superfície"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Montar e verificar as equações de equilíbrio globais",
                                  "subSteps": [
                                    "Montar o sistema [K] {q} = {F} para o elemento.",
                                    "Discutir montagem global por superposição.",
                                    "Resolver um exemplo numérico simples para validar.",
                                    "Verificar simetria e condições de contorno.",
                                    "Interpretar resultados físicos (deslocamentos e reações)."
                                  ],
                                  "verification": "O aluno resolve um problema completo e verifica se satisfaz ∂Π/∂q_i = 0.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB ou Python com NumPy para resolver [K]q=F",
                                    "Exemplo de treliça simples"
                                  ],
                                  "tips": "Sempre normalize unidades para evitar erros numéricos.",
                                  "learningObjective": "Integrar todos os termos para formar e resolver as equações de equilíbrio.",
                                  "commonMistakes": [
                                    "Erro na montagem global",
                                    "Aplicar condições de contorno incorretamente",
                                    "Não verificar simetria de K"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um elemento de barra 1D de comprimento L, seção A, módulo E, com carga axial distribuída b(x), derive K = (AE/L) [[1, -1], [-1, 1]] e F = ∫ (N1 b + N2 b) dx, onde N1 = 1 - x/L, N2 = x/L. Resolva para deslocamentos nodais.",
                              "finalVerifications": [
                                "A matriz K é simétrica e positiva definida.",
                                "O vetor F equilibra corretamente as cargas aplicadas.",
                                "Substituindo q na equação, ∂Π/∂q_i ≈ 0 numericamente.",
                                "Para caso sem carga, q=0 satisfaz.",
                                "Energia Π é mínima no equilíbrio.",
                                "Condições de contorno são aplicadas corretamente."
                              ],
                              "assessmentCriteria": [
                                "Correção na derivação de K_{ij} (integral exata).",
                                "Correção no sinal e termos de F_i.",
                                "Identificação precisa de B, D, N.",
                                "Verificação de propriedades de K (simetria, definitude).",
                                "Resolução numérica coerente com teoria.",
                                "Interpretação física adequada.",
                                "Clareza na escrita das equações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e integrais em múltiplas dimensões.",
                                "Física: Princípio da energia potencial mínima e trabalhos virtuais.",
                                "Computação: Implementação de FEM em Python/MATLAB.",
                                "Engenharia Civil: Análise estática de estruturas.",
                                "Matemática Numérica: Integração de Gauss e solvers lineares."
                              ],
                              "realWorldApplication": "Essas equações são o coração dos métodos de elementos finitos usados em softwares como ANSYS, Abaqus e NASTRAN para simular tensões em aviões, pontes, carros e implantes médicos, permitindo prever falhas antes da fabricação."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.3.2",
                            "name": "Montar matriz de rigidez e vetor de cargas",
                            "description": "Calcular explicitamente as matrizes globais K e F para um problema simples 1D, como uma barra axial ou viga em flexão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o problema físico e realizar a discretização do domínio",
                                  "subSteps": [
                                    "Identifique o problema 1D: por exemplo, uma barra axial com comprimento L, seção transversal A, módulo de elasticidade E, condições de contorno e cargas distribuídas q(x).",
                                    "Divida o domínio em n elementos finitos, definindo nós e comprimentos elementais le.",
                                    "Atribua graus de liberdade (DOFs) aos nós: deslocamento u em cada nó para barra axial.",
                                    "Esboce a malha com nós numerados e indique elementos conectados.",
                                    "Verifique compatibilidade: nós compartilhados entre elementos adjacentes."
                                  ],
                                  "verification": "Malha esboçada corretamente com DOFs atribuídos e condições de contorno marcadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora",
                                    "Folha com propriedades do material (E, A, L)"
                                  ],
                                  "tips": "Comece com 2-3 elementos para simplicidade; use elementos de comprimento igual inicialmente.",
                                  "learningObjective": "Compreender a discretização como base para o método de elementos finitos.",
                                  "commonMistakes": [
                                    "Ignorar condições de contorno nos DOFs",
                                    "Numerar nós de forma inconsistente",
                                    "Confundir cargas nodais com distribuídas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e derivar as funções de forma (shape functions)",
                                  "subSteps": [
                                    "Escolha funções de forma lineares para elementos 1D: N1(ξ) = 1 - ξ, N2(ξ) = ξ, onde ξ vai de 0 a 1 no elemento local.",
                                    "Expresse o deslocamento aproximado u(x) = Σ Ni(xi) ui.",
                                    "Calcule as derivadas dN/dx necessárias para rigidez: dN1/dx = -1/le, dN2/dx = 1/le.",
                                    "Transforme coordenadas locais x = x1 + ξ le para integrações.",
                                    "Verifique normalização: Σ Ni = 1 em qualquer ponto."
                                  ],
                                  "verification": "Funções de forma e derivadas plotadas ou tabuladas corretamente para um elemento.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora simbólica ou software como SymPy opcional"
                                  ],
                                  "tips": "Use coordenadas naturais ξ para simplificar integrações Gauss.",
                                  "learningObjective": "Dominar funções de forma lineares e suas derivadas para aproximação de campos.",
                                  "commonMistakes": [
                                    "Esquecer transformação de coordenadas locais-globais",
                                    "Erro no sinal das derivadas",
                                    "Funções não interpoladoras nos nós"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a matriz de rigidez elemental Ke",
                                  "subSteps": [
                                    "Escreva a expressão da energia de deformação Ue = (1/2) ∫ B^T E B dV, onde B = dN/dx.",
                                    "Para barra axial 1D: Ke = (A E / le) * [1, -1; -1, 1].",
                                    "Integre analiticamente ou numericamente sobre o elemento: Ke = ∫ (A E) (dN/dx)^T (dN/dx) dx.",
                                    "Confirme simetria e propriedades esperadas (Ke positiva semi-definida).",
                                    "Repita para todos os elementos, numerando Ke^e adequadamente."
                                  ],
                                  "verification": "Matrizes Ke^e calculadas e simétricas para cada elemento.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Calculadora",
                                    "Tabela de integrais padrão",
                                    "Software MATLAB/Octave para verificação numérica"
                                  ],
                                  "tips": "Memorize fórmula fechada para elementos lineares para agilizar.",
                                  "learningObjective": "Derivar matriz de rigidez a partir do princípio de minimização de energia.",
                                  "commonMistakes": [
                                    "Fator A E trocado",
                                    "Não dividir por le corretamente",
                                    "Integração em coordenadas erradas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular o vetor de cargas elementais Fe",
                                  "subSteps": [
                                    "Escreva Fe = ∫ N^T q(x) dV para cargas distribuídas, ou some forças nodais concentradas.",
                                    "Para q constante: Fe = (q le / 2) * [1; 1] para linear.",
                                    "Integre analiticamente: para q(x)=const, Fe = q le [1/2, 1/2]^T.",
                                    "Inclua cargas de ponto se aplicável, adicionando ao DOF correspondente.",
                                    "Calcule Fe^e para cada elemento."
                                  ],
                                  "verification": "Vetores Fe^e somam ao total de carga aplicada (equilíbrio global).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Gráfico de q(x)"
                                  ],
                                  "tips": "Use integração exata para cargas polinomiais baixas.",
                                  "learningObjective": "Computar cargas nodais equivalentes a partir de distribuições.",
                                  "commonMistakes": [
                                    "Confundir cargas distribuídas com nodais",
                                    "Fator le/2 esquecido",
                                    "Sinais errados em direções"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Montar as matrizes globais K e F por assembly",
                                  "subSteps": [
                                    "Inicialize K global (tamanho ndofs x ndofs) e F global (ndofs x 1) zerados.",
                                    "Para cada elemento e, some Ke^e nas posições (i,j) correspondentes aos DOFs globais.",
                                    "Some Fe^e nos DOFs globais respectivos.",
                                    "Aplique condições de contorno: remova DOFs fixos ou imponha deslocamentos.",
                                    "Verifique: K simétrica, rank adequado, soma colunas de F = reações totais."
                                  ],
                                  "verification": "K e F globais consistentes, com assembly correto comparado a cálculo manual.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha Excel ou MATLAB para matriz grande",
                                    "Papel para malha pequena"
                                  ],
                                  "tips": "Use mapa de conectividade (nós por elemento) para índices globais.",
                                  "learningObjective": "Executar o processo de montagem global no método Rayleigh-Ritz.",
                                  "commonMistakes": [
                                    "Índices de DOFs trocados",
                                    "Duplicar contribuições sem zerar inicial",
                                    "Ignorar BCs na montagem"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma barra axial de L=2m, A=0.01m², E=200GPa, fixada em x=0 (u1=0), livre em x=2m, com carga distribuída q=1000N/m constante. Divida em 2 elementos de le=1m cada (nós 1,2,3). Shape functions lineares. Ke1 = Ke2 = (200e9*0.01/1)*[1,-1;-1,1] = 2e9*[1,-1;-1,1]. Fe1=Fe2=(1000*1/2)*[1;1]=500[1;1]. Assembly: K global 3x3 com contribuições, aplicar u1=0 removendo primeira linha/coluna. Resultado: K_red=[4e9, -2e9; -2e9, 2e9], F_red=[1000; 500].",
                              "finalVerifications": [
                                "Matriz K global é simétrica e positiva semi-definida.",
                                "Soma das colunas de K multiplicada por vetor unitário dá zeros (equilíbrio rígido).",
                                "Vetor F global equilibra as cargas totais aplicadas.",
                                "Condições de contorno aplicadas corretamente (linhas/colunas removidas ou penalizadas).",
                                "Valores numéricos coincidem com soluções analíticas para casos simples.",
                                "Assembly preserva continuidade entre elementos."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos de Ke e Fe (erro <1%).",
                                "Correta derivação de shape functions e derivadas.",
                                "Assembly global sem erros de indexação.",
                                "Aplicação adequada de condições de contorno.",
                                "Verificações de simetria e equilíbrio realizadas.",
                                "Explicação clara do processo minimização de energia."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: montagem e propriedades de matrizes esparsas.",
                                "Cálculo: integração de funções de forma e cargas.",
                                "Programação: implementação em Python/MATLAB para automação.",
                                "Física: princípios de equilíbrio estático e energia potencial.",
                                "Geometria Computacional: mapeamento local-global."
                              ],
                              "realWorldApplication": "Em análises de estruturas via FEA (ex: ANSYS, Abaqus), montar K e F é o cerne da simulação de tensões em vigas, cabos ou tubos em pontes, aviões e edifícios, permitindo prever falhas antes da construção."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.3.3",
                            "name": "Resolver sistema e pós-processar",
                            "description": "Resolver [K]{q} = {F} numericamente, recuperar deslocamentos u(x), tensões e validar com solução exata.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Resolver numericamente o sistema [K]{q} = {F}",
                                  "subSteps": [
                                    "Verificar propriedades da matriz de rigidez [K]: simetria, positiva definida e condicionamento.",
                                    "Escolher método de solução: eliminação gaussiana, decomposição LU ou solver iterativo para grandes sistemas.",
                                    "Implementar o solver em software (ex: Python com NumPy ou MATLAB) e computar {q} = [K]^{-1}{F}.",
                                    "Calcular o resíduo r = [K]{q} - {F} para verificar precisão numérica.",
                                    "Armazenar {q} para uso posterior."
                                  ],
                                  "verification": "Resíduo ||r|| < 1e-10 e valores de {q} fisicamente coerentes (ex: positivos para cargas de tração).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software Python/MATLAB com NumPy/SciPy, matriz [K] e vetor {F} do passo anterior.",
                                  "tips": "Use solvers condicionados para matrizes mal condicionadas; prefira decomposição LU para reutilização.",
                                  "learningObjective": "Dominar resolução numérica de sistemas lineares em contexto de elementos finitos.",
                                  "commonMistakes": "Ignorar condicionamento da matriz levando a erros de arredondamento; não verificar resíduo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Recuperar deslocamentos u(x) nos pontos de interesse",
                                  "subSteps": [
                                    "Definir malha de pontos de avaliação ao longo do domínio (nós e pontos internos).",
                                    "Para cada ponto x, computar funções de forma N_i(x) associadas aos graus de liberdade.",
                                    "Calcular u(x) = ∑ N_i(x) q_i para deslocamentos nodais e interpolados.",
                                    "Plotar u(x) vs x para visualização contínua.",
                                    "Exportar dados para análise posterior."
                                  ],
                                  "verification": "u(x) é contínuo entre elementos e satisfaz condições de contorno (ex: u(0)=0).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Funções de forma do elemento (ex: lineares para barra), vetor {q}, ferramenta de plotagem (Matplotlib).",
                                  "tips": "Use avaliação em Gauss points para precisão; vetorize computações para eficiência.",
                                  "learningObjective": "Entender interpolação de deslocamentos via funções de forma no método Rayleigh-Ritz.",
                                  "commonMistakes": "Erro na indexação de funções de forma levando a descontinuidades; esquecer condições de contorno."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular tensões e deformações a partir de u(x)",
                                  "subSteps": [
                                    "Derivar u(x) para obter deformações ε(x) = du/dx (analiticamente ou numericamente).",
                                    "Aplicar relação constitutiva σ(x) = E ε(x) para tensões.",
                                    "Computar em pontos de Gauss ou nós para precisão.",
                                    "Visualizar perfis de σ(x) e ε(x) ao longo do domínio.",
                                    "Verificar equilíbrio integral (∫σ dA = F)."
                                  ],
                                  "verification": "Tensões médias coincidem com força aplicada; picos em regiões esperadas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Matriz constitutiva [D] ou módulo E, derivadas das funções de forma.",
                                  "tips": "Use diferenciação exata das funções de forma; suavize numericamente se necessário.",
                                  "learningObjective": "Coordenar pós-processamento de campos primitivos (deslocamentos) para derivados (tensões).",
                                  "commonMistakes": "Derivada incorreta causando tensões espúrias; não considerar variação da seção ou material."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar resultados com solução exata",
                                  "subSteps": [
                                    "Obter solução analítica u_exact(x), σ_exact(x) para o problema modelo.",
                                    "Computar erros relativos: e_u = ||u - u_exact|| / ||u_exact|| e e_σ similarmente.",
                                    "Gerar gráficos comparativos (u_num vs u_exact, σ_num vs σ_exact).",
                                    "Calcular normas L2 e L∞ dos erros.",
                                    "Analisar convergência refinando a malha se possível."
                                  ],
                                  "verification": "Erros relativos < 5% em norma L2; gráficos sobrepostos visualmente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Fórmula analítica do problema (ex: u(x)=Fx/EA para barra), ferramentas de plotagem.",
                                  "tips": "Use malha adaptativa para validação; reporte erros em tabela.",
                                  "learningObjective": "Avaliar precisão do método numérico Rayleigh-Ritz via comparação analítica.",
                                  "commonMistakes": "Solução exata errada; métricas de erro inadequadas (ex: usar máximo em vez de norma)."
                                }
                              ],
                              "practicalExample": "Para uma barra em tração unitária (L=1m, E=210GPa, A=1cm², F=1kN no final, u(0)=0): solução exata u(x)= (F/(EA)) x = 4.76e-6 x. Com 2 elementos lineares, [K] resulta em q ≈ [0, 2.38e-6, 4.76e-6]^T. Recupere u(x), σ(x)=E du/dx ≈1MPa constante, valide erro <1%.",
                              "finalVerifications": [
                                "{q} satisfaz equilíbrio [K]{q} ≈ {F} com resíduo mínimo.",
                                "u(x) respeita C0-continuidade e condições de contorno.",
                                "Tensões σ(x) equilibram carga externa integralmente.",
                                "Erros L2 vs exata <5%; convergência observada com refinamento.",
                                "Visualizações mostram perfis físicos coerentes.",
                                "Código reproduzível gera mesmos resultados."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica na resolução do sistema (resíduo <1e-12).",
                                "Correta interpolação e derivação para u(x) e σ(x).",
                                "Métricas de erro quantitativas e qualitativas adequadas.",
                                "Visualizações claras e interpretáveis.",
                                "Análise de fontes de erro e limitações do método.",
                                "Eficiência computacional razoável."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (resolução de sistemas, normas de erro).",
                                "Programação: Implementação numérica em Python/MATLAB (vetorização, solvers).",
                                "Física: Mecânica dos sólidos (equilíbrio, constitutivo).",
                                "Estatística: Análise de erros e convergência.",
                                "Engenharia de Software: Validação e verificação de códigos."
                              ],
                              "realWorldApplication": "Em análise estrutural de vigas, placas ou cascas em software como ANSYS ou Abaqus, onde se resolve sistemas globais massivos para prever falhas em pontes, aviões ou edifícios sob cargas reais, otimizando designs e evitando colapsos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.3.4",
                            "name": "Comparar com método de Galerkin",
                            "description": "Explicar similaridades e diferenças entre Rayleigh-Ritz (baseado em energia) e Galerkin (baseado em resíduos ortogonais) para problemas auto-adjuntos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os Fundamentos do Método de Rayleigh-Ritz",
                                  "subSteps": [
                                    "Estude o princípio variacional: minimização da energia potencial total para problemas auto-adjuntos.",
                                    "Identifique a formulação baseada em funções de aproximação trial que satisfazem condições de contorno essenciais.",
                                    "Derive a equação de equilíbrio resultante: ∫ K δu du = ∫ F δu du, levando a um sistema matricial simétrico.",
                                    "Anote as premissas: problema auto-adjunto, linear, com energia de deformação quadrática.",
                                    "Registre exemplos clássicos como barra axial ou viga de Euler-Bernoulli."
                                  ],
                                  "verification": "Escreva um resumo de 1 parágrafo explicando o princípio de minimização de energia e derive a matriz de rigidez para um elemento simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Elementos Finitos (ex: Zienkiewicz), notas de aula, calculadora simbólica (Mathematica ou SymPy).",
                                  "tips": "Comece com o funcional de energia total Π = U - W para visualizar a minimização.",
                                  "learningObjective": "Compreender a base energética do Rayleigh-Ritz e sua formulação variacional.",
                                  "commonMistakes": "Confundir condições de contorno essenciais com naturais; ignorar a simetria da matriz de rigidez."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar os Fundamentos do Método de Galerkin",
                                  "subSteps": [
                                    "Estude o conceito de resíduos: R = L(u) - f = 0, onde a solução exata zera o resíduo.",
                                    "Aprenda a projeção: ∫ w R dΩ = 0 para funções peso w (geralmente as mesmas funções de aproximação).",
                                    "Derive a formulação fraca: encontrar u_h tal que ∫ ∇w · (∇u_h) dΩ = ∫ w f dΩ para equações elípticas auto-adjuntas.",
                                    "Note a ortogonalidade dos resíduos em relação ao espaço de funções peso.",
                                    "Compare com métodos de resíduos colados ou subdomínio."
                                  ],
                                  "verification": "Formule a equação de Galerkin para a equação -u'' + u = f em 1D e mostre a matriz resultante.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Referências de métodos de elementos finitos, software como MATLAB para verificação numérica.",
                                  "tips": "Visualize o resíduo como 'erro' projetado ortogonalmente no espaço de aproximação.",
                                  "learningObjective": "Dominar a abordagem baseada em resíduos ortogonais do método de Galerkin.",
                                  "commonMistakes": "Escolher funções peso diferentes das de aproximação sem justificativa; não integrar por partes corretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Similaridades entre os Métodos",
                                  "subSteps": [
                                    "Observe que ambos usam funções de base para aproximar a solução: u_h = Σ c_i φ_i.",
                                    "Verifique que para problemas auto-adjuntos, a matriz de Galerkin coincide com a de Rayleigh-Ritz.",
                                    "Confirme a simetria e positividade das matrizes em ambos os casos.",
                                    "Liste propriedades compartilhadas: convergência monotônica, estabilidade numérica.",
                                    "Demonstre matematicamente: a integração por partes no Galerkin recupera o princípio variacional."
                                  ],
                                  "verification": "Prove que para o problema -∇·(k∇u) + cu = f, as formas fracas são idênticas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e lápis para derivações, quadro branco para diagramas.",
                                  "tips": "Use o teorema da identidade de Green para ligar resíduos a variações.",
                                  "learningObjective": "Reconhecer as equivalências fundamentais para problemas auto-adjuntos.",
                                  "commonMistakes": "Ignorar que a equivalência requer auto-adjunção; superestimar diferenças em problemas lineares simples."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Diferenças e Aplicações",
                                  "subSteps": [
                                    "Destaque a base conceitual: energia (Rayleigh-Ritz) vs. resíduos (Galerkin).",
                                    "Discuta generalidade: Galerkin aplica a não-auto-adjuntos e não-lineares; Rayleigh-Ritz restrito a variações.",
                                    "Compare implementação: Rayleigh-Ritz requer funcional energia explícito.",
                                    "Examine condições de contorno: Rayleigh-Ritz trata naturais automaticamente via energia.",
                                    "Avalie eficiência computacional e extensões (ex: p-version em Galerkin)."
                                  ],
                                  "verification": "Crie uma tabela comparativa com 5 linhas: base, generalidade, matriz, BCs, exemplos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha ou documento para tabela, artigos comparativos.",
                                  "tips": "Pense em Galerkin como 'mais geral' e Rayleigh-Ritz como 'especializado em energia'.",
                                  "learningObjective": "Discernir diferenças chave e contextos de uso preferencial.",
                                  "commonMistakes": "Afirmar diferenças inexistentes em problemas auto-adjuntos; confundir com métodos espectrais."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Verificar Compreensão",
                                  "subSteps": [
                                    "Resuma similaridades e diferenças em um diagrama de Venn.",
                                    "Aplique a um problema simples: resolva u'' + u = 0 com ambos os métodos.",
                                    "Discuta quando usar cada um em FEA moderna.",
                                    "Identifique limitações compartilhadas (ex: lock-in).",
                                    "Prepare exemplos para ensino ou discussão."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as diferenças para um colega fictício.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software FEA básico (ex: FreeFEM), exemplos numéricos.",
                                  "tips": "Teste numericamente em um problema 1D para validar equivalência.",
                                  "learningObjective": "Integrar conhecimentos para uma comparação holística.",
                                  "commonMistakes": "Generalizar diferenças além do escopo auto-adjunto; omitir provas matemáticas."
                                }
                              ],
                              "practicalExample": "Para uma barra axial 1D com u(0)=0, u(1)=1, -u''=1: Use funções φ_i = x^i (i=1 a 3). No Rayleigh-Ritz, minimize Π = (1/2)∫(u')^2 - ∫x u. No Galerkin, resolva ∫ φ_i (u'' + x) = 0 após integração por partes. Compare coeficientes c_i e energia.",
                              "finalVerifications": [
                                "Pode derivar as matrizes de rigidez idênticas para um problema auto-adjunto simples.",
                                "Lista corretamente 3 similaridades e 3 diferenças principais.",
                                "Explica por que Galerkin é mais geral usando um contraexemplo não-auto-adjunto.",
                                "Constrói uma tabela comparativa precisa.",
                                "Resolve numericamente um exemplo 1D e verifica equivalência.",
                                "Discute condições de contorno em ambos os métodos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações (peso 30%).",
                                "Clareza na distinção conceitual energia vs. resíduos (25%).",
                                "Compreensão de equivalência para auto-adjuntos (20%).",
                                "Uso de exemplos concretos e verificações numéricas (15%).",
                                "Identificação de limitações e aplicações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Propriedades de matrizes simétricas positivas definidas.",
                                "Cálculo Variacional: Funcionais e equações de Euler-Lagrange.",
                                "Métodos Numéricos: Aproximações espectrais e Galerkin descontínuo.",
                                "Física: Princípios de energia em mecânica dos sólidos.",
                                "Programação: Implementação em Python/MATLAB para FEA."
                              ],
                              "realWorldApplication": "Em softwares de FEA como ANSYS ou Abaqus, o método de Galerkin é usado para problemas gerais (estrutural, térmico, fluidos), enquanto Rayleigh-Ritz é a base para análises modais e otimização energética em estruturas aeroespaciais e automotivas, garantindo precisão em simulações de fadiga e vibrações."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.3",
                    "name": "Método de Galerkin",
                    "description": "Método de pesos com funções de teste iguais às de aproximação para equações diferenciais fracas.",
                    "individualConcepts": [
                      {
                        "id": "34.1.2.3.1",
                        "name": "Formulação Fraca das Equações Diferenciais",
                        "description": "Transformação das equações diferenciais diferenciais fortes em formas integrais fracas por meio de multiplicação por funções de teste e integração por partes, eliminando derivadas de alta ordem.",
                        "specificSkills": [
                          {
                            "id": "34.1.2.3.1.1",
                            "name": "Realizar integração por partes em equações diferenciais",
                            "description": "Aplicar a fórmula de integração por partes para converter derivadas de segunda ordem em termos bilineares simétricos, identificando os termos de contorno naturais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a fórmula fundamental de integração por partes",
                                  "subSteps": [
                                    "Relembrar a fórmula básica: ∫ u dv = u v - ∫ v du.",
                                    "Identificar escolhas adequadas para u e dv em integrais indefinidas simples.",
                                    "Praticar com exemplos de funções polinomiais e exponenciais.",
                                    "Estender para integrais definidas em intervalos finitos.",
                                    "Verificar resultados diferenciando para confirmar a identidade."
                                  ],
                                  "verification": "Resolver corretamente ∫ x e^x dx e confirmar por diferenciação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Caderno, calculadora científica, tabela de integrais.",
                                  "tips": "Escolha u como a função que simplifica ao derivar e dv como fácil de integrar.",
                                  "learningObjective": "Dominar a aplicação básica da integração por partes em integrais simples.",
                                  "commonMistakes": "Escolher u e dv incorretamente, levando a integrais mais complexas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar integração por partes em derivadas de primeira ordem em EDOs",
                                  "subSteps": [
                                    "Partir de uma EDO como ∫ (L u) v dx = ∫ f v dx, onde L é um operador diferencial.",
                                    "Escolher u = L w (derivada) e dv = v (função teste).",
                                    "Realizar a primeira integração por partes para transferir a derivada para v.",
                                    "Analisar o termo de contorno resultante: [w v] nos limites.",
                                    "Verificar que o resíduo é ∫ w (L* v) dx, onde L* é o adjunto."
                                  ],
                                  "verification": "Transformar corretamente ∫ u' v dx em -∫ u v' dx + termos de contorno.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Folha de papel milimetrado, software simbólico como Mathematica ou SymPy.",
                                  "tips": "Sempre inclua os limites de integração para capturar termos de contorno.",
                                  "learningObjective": "Entender como a integração por partes transfere derivadas em formulações variacionais.",
                                  "commonMistakes": "Esquecer os termos de contorno nos limites do intervalo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar dupla integração por partes para derivadas de segunda ordem",
                                  "subSteps": [
                                    "Começar com termo como ∫ u'' v dx em uma EDO de segunda ordem.",
                                    "Aplicar integração por partes primeiro: u' = u1, dv1 = v dx → termo [u' v] - ∫ u' v' dx.",
                                    "Aplicar segunda vez no resíduo: ∫ u' v' dx → [u v'] - ∫ u v'' dx.",
                                    "Reorganizar para obter o termo bilinear simétrico ∫ u' v' dx.",
                                    "Confirmar simetria: a(u,v) = a(v,u)."
                                  ],
                                  "verification": "Obter ∫ u'' v dx = [u' v - u v'] - ∫ u' v' dx + ∫ u v'' dx.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Quadro branco ou tablet gráfico, exemplos impressos de EDOs elípticas.",
                                  "tips": "Mantenha o sinal consistente em cada integração para evitar erros de sinal.",
                                  "learningObjective": "Converter derivadas de segunda ordem em formas bilineares simétricas.",
                                  "commonMistakes": "Perder sinais negativos nas integrações sucessivas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e interpretar termos de contorno naturais",
                                  "subSteps": [
                                    "Listar todos os termos de contorno acumulados: [u' v - u v'] nos limites.",
                                    "Classificar termos naturais (relacionados a fluxos ou trações) vs. essenciais (valores de u).",
                                    "Incorporar condições de contorno de Dirichlet ou Neumann adequadamente.",
                                    "Verificar consistência com condições físicas do problema.",
                                    "Testar em um exemplo com condições homogêneas de Neumann."
                                  ],
                                  "verification": "Identificar corretamente os termos [u' v] como naturais para condições de Neumann.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Exemplos de problemas de elementos finitos, simulador online de EDOs.",
                                  "tips": "Termos de contorno naturais surgem de derivadas; essenciais de valores da função.",
                                  "learningObjective": "Reconhecer e aplicar termos de contorno na formulação fraca.",
                                  "commonMistakes": "Confundir termos naturais com essenciais, levando a formulações incorretas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar a formulação fraca completa no método de Galerkin",
                                  "subSteps": [
                                    "Montar a formulação fraca: encontrar a(u,v) = ∫ ∇u · ∇v dx = ∫ f v dx + termos de contorno.",
                                    "Escolher funções teste v do espaço apropriado (ex: H^1).",
                                    "Verificar propriedades: simetria, coercividade e continuidade.",
                                    "Aplicar a uma EDO modelo como -u'' + u = f.",
                                    "Comparar com formulação forte para validar."
                                  ],
                                  "verification": "Escrever a formulação fraca correta para -Δu = f em 1D.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Livro de elementos finitos (ex: Zienkiewicz), Python com NumPy/SciPy.",
                                  "tips": "Garanta que o espaço de funções suporte a simetria bilinear.",
                                  "learningObjective": "Integrar a integração por partes na formulação fraca de Galerkin.",
                                  "commonMistakes": "Não verificar simetria do bilinear, essencial para convergência."
                                }
                              ],
                              "practicalExample": "Considere a EDO -u''(x) = f(x) em [0,1] com u'(0)=0, u'(1)=g. Integre por partes duas vezes: ∫ u'' v dx = [u' v]_0^1 - ∫ u' v' dx = g v(1) - ∫ u' v' dx. A forma fraca é ∫ u' v' dx = ∫ f v dx + g v(1), com termo bilinear simétrico ∫ u' v' dx e contorno natural g v(1).",
                              "finalVerifications": [
                                "O termo bilinear resultante é simétrico: a(u,v) = a(v,u).",
                                "Todos os termos de contorno naturais foram identificados corretamente.",
                                "A formulação fraca coincide com a forte sob condições adequadas.",
                                "Sinais nas integrações estão consistentes.",
                                "Propriedades de coercividade são preservadas.",
                                "Exemplo numérico simples resolve corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na aplicação dupla de integração por partes (sem erros de sinal).",
                                "Correta identificação de termos bilineares simétricos.",
                                "Interpretação adequada de termos de contorno naturais vs. essenciais.",
                                "Verificação de simetria e propriedades variacionais.",
                                "Capacidade de aplicar a uma EDO modelo real.",
                                "Clareza na escrita da formulação fraca final."
                              ],
                              "crossCurricularConnections": [
                                "Física: Formulações variacionais em mecânica dos sólidos e equilíbrio.",
                                "Programação: Implementação em código para métodos numéricos (SciPy, FEniCS).",
                                "Matemática Aplicada: Espaços de Sobolev e análise funcional.",
                                "Engenharia: Simulações de elementos finitos em estruturas.",
                                "Estatística: Inferência bayesiana via métodos variacionais."
                              ],
                              "realWorldApplication": "Na análise de elementos finitos para simulação de tensões em vigas ou placas, a integração por partes converte EDOs de equilíbrio em matrizes de rigidez simétricas, permitindo soluções numéricas eficientes em softwares como ANSYS ou Abaqus para projetos de engenharia mecânica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.1.2.3.1.2",
                            "name": "Identificar forma bilinear e linear na equação fraca",
                            "description": "Reconhecer a estrutura a(u,v) = L(v) da forma fraca, onde a(u,v) é a forma bilinear e L(v) o funcional linear, para problemas elásticos e de campo escalar.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a formulação forte das equações diferenciais elásticas e de campo escalar",
                                  "subSteps": [
                                    "Estude a equação forte para problemas de campo escalar, como -Δu = f em Ω com condições de contorno u=0 em ∂Ω.",
                                    "Analise a equação de elasticidade linear: -div(σ(u)) = f em Ω, onde σ(u) = 2μ ε(u) + λ tr(ε(u)) I.",
                                    "Identifique os operadores diferenciais principais (laplaciano para escalar, div-grad para vetorial).",
                                    "Escreva as condições de contorno de Dirichlet homogênea.",
                                    "Discuta o espaço de funções apropriado (H^1_0(Ω) para escalar, [H^1_0(Ω)]^d para vetorial)."
                                  ],
                                  "verification": "Escreva corretamente as equações fortes para um problema escalar e elástico simples, confirmando com referência padrão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de elementos finitos (ex: Zienkiewicz), caderno e caneta",
                                  "tips": "Comece com o caso escalar mais simples antes de generalizar para vetorial.",
                                  "learningObjective": "Compreender a origem das equações fortes para contextualizar a formulação fraca.",
                                  "commonMistakes": "Confundir condições de contorno ou ignorar a dimensionalidade (escalar vs. vetorial)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a formulação fraca multiplicando por função teste e integrando",
                                  "subSteps": [
                                    "Multiplique a equação forte por uma função teste v ∈ H^1_0(Ω) e integre sobre Ω.",
                                    "Aplique o teorema da integração por partes (Green) para transferir derivadas de u para v.",
                                    "Para escalar: obtenha ∫_Ω ∇u · ∇v dx = ∫_Ω f v dx.",
                                    "Para elasticidade: ∫_Ω σ(u):ε(v) dx = ∫_Ω f · v dx.",
                                    "Verifique que os termos de contorno desaparecem devido a v=0 em ∂Ω."
                                  ],
                                  "verification": "Derive a equação fraca integral para Poisson e elasticidade, comparando com fórmulas padrão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Caderno, calculadora simbólica (ex: Mathematica ou papel), notas de aula",
                                  "tips": "Use notação consistente: denote o espaço de teste como V = H^1_0(Ω).",
                                  "learningObjective": "Dominar a derivação da forma fraca a partir da forte via integração por partes.",
                                  "commonMistakes": "Esquecer o sinal negativo na integração por partes ou não zerar termos de contorno."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar explicitamente a forma bilinear a(u,v) e o funcional linear L(v)",
                                  "subSteps": [
                                    "Na equação fraca: encontre(u,v) = L(v) ∀ v ∈ V.",
                                    "Defina a(u,v) = ∫_Ω ∇u · ∇v dx para escalar (bilinear contínua e coerciva).",
                                    "Para elasticidade: a(u,v) = ∫_Ω 2μ ε(u):ε(v) + λ div(u) div(v) dx.",
                                    "Defina L(v) = ∫_Ω f v dx (linear contínuo).",
                                    "Verifique propriedades: a(u,v) bilinear (linear em u e v), L(v) linear em v."
                                  ],
                                  "verification": "Reescreva a equação fraca no formato a(u,v) = L(v), destacando cada termo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel quadriculado, exemplos de equações de livros ou PDF online",
                                  "tips": "Destaque visualmente a(u,v) em azul e L(v) em verde nas equações.",
                                  "learningObjective": "Reconhecer precisamente os componentes bilinear e linear na estrutura padrão.",
                                  "commonMistakes": "Incluir termos de contorno em a(u,v) ou confundir bilinear com quadrática."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a identificação em exemplos variados e verificar propriedades",
                                  "subSteps": [
                                    "Aplique a um problema com fonte não-homogênea e contornos mistos (ajuste L(v)).",
                                    "Teste com equação de Helmholtz ou biharmonica para generalizar.",
                                    "Confirme coercividade de a(·,·) (constante de coercão α >0) e continuidade.",
                                    "Discuta simetria para Galerkin (a(u,v)=a(v,u)).",
                                    "Compare com código FEM simples para visualizar."
                                  ],
                                  "verification": "Identifique a(u,v) e L(v) em 2-3 equações diferentes sem erros.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Software FEM básico (ex: FEniCS tutorial online), caderno",
                                  "tips": "Use exemplos numéricos simples em 1D para validar manualmente.",
                                  "learningObjective": "Aplicar a identificação de forma robusta e entender propriedades essenciais.",
                                  "commonMistakes": "Ignorar dependência material (μ,λ) na bilinear elástica ou assumir simetria desnecessária."
                                }
                              ],
                              "practicalExample": "Para a equação de Poisson -Δu = π² sin(πx) em [0,1] com u(0)=u(1)=0: multiplique por v, integre por partes → a(u,v) = ∫_0^1 u' v' dx = L(v) = π² ∫_0^1 sin(πx) v dx. Aqui, bilinear é o termo de derivadas, linear é o da fonte.",
                              "finalVerifications": [
                                "Derivação correta da forma fraca sem erros de sinal.",
                                "Identificação precisa de a(u,v) isolando termos bilineares.",
                                "Definição correta de L(v) incluindo apenas termos lineares em v.",
                                "Verificação de propriedades básicas (bilinearidade, lineariedade).",
                                "Aplicação bem-sucedida em pelo menos um exemplo elástico.",
                                "Explicação clara da estrutura a(u,v)=L(v) em palavras."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da integração por partes (90% correto).",
                                "Correta separação de termos bilinear vs. linear (sem confusão).",
                                "Uso apropriado de notação matemática (espaços de Sobolev).",
                                "Demonstração de propriedades (coercividade, continuidade).",
                                "Generalização para casos escalar e vetorial.",
                                "Explicação verbal fluida da estrutura."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Teorema de Lax-Milgram para existência/unicidade.",
                                "Programação: Implementação em códigos FEM (Python/FEniCS).",
                                "Física: Modelagem de tensões em estruturas elásticas.",
                                "Matemática Aplicada: Espaços de Hilbert e formas sesquilinear."
                              ],
                              "realWorldApplication": "Em simulações de elementos finitos para análise estrutural (ex: pontes, aviões), onde a formulação fraca permite discretização via Galerkin, otimizando tensão em materiais sob carga."
                            },
                            "estimatedTime": "45 minutos",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.1.2.3.1.3",
                            "name": "Aplicar condições de contorno essenciais e naturais",
                            "description": "Distinguir e incorporar condições de Dirichlet (essenciais) no espaço de funções e condições de Neumann/Robin (naturais) no funcional linear.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos de condições de contorno essenciais e naturais",
                                  "subSteps": [
                                    "Estude a definição de condições de Dirichlet (essenciais): u = valor prescrito em pontos da fronteira.",
                                    "Analise condições de Neumann (derivada normal prescrita) e Robin (combinação linear de u e derivada).",
                                    "Compare como essenciais afetam o espaço de funções V, enquanto naturais aparecem no funcional.",
                                    "Revise integração por partes na formulação fraca: ∫ v' u' = -∫ v'' u + [v' u - v u'] na fronteira.",
                                    "Identifique termos de fronteira que definem naturais."
                                  ],
                                  "verification": "Resuma em um diagrama as diferenças e forneça exemplos de cada tipo.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro de Elementos Finitos (ex: Zienkiewicz), notas de aula sobre EDEs elípticas.",
                                  "tips": "Use analogias físicas: essenciais fixam deslocamento, naturais forças aplicadas.",
                                  "learningObjective": "Distinguir conceitualmente essenciais de naturais no contexto variacional.",
                                  "commonMistakes": "Confundir Neumann com Dirichlet; ignorar que naturais emergem da integração por partes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a formulação fraca de uma equação diferencial elíptica",
                                  "subSteps": [
                                    "Parta de uma EDE modelo: -Δu = f em Ω, multiplique por v teste e integre.",
                                    "Aplique o teorema da divergência ou integração por partes para obter a forma bilinear a(u,v) = L(v).",
                                    "Identifique termos de fronteira: ∫_Γ (∂u/∂n v) dΓ.",
                                    "Defina o espaço V = {v ∈ H¹(Ω) | v=0 em Γ_D} para essenciais em Γ_D.",
                                    "Escreva a formulação: Encontre u em V_g tal que a(u,v) = L(v) + termos naturais para todo v em V."
                                  ],
                                  "verification": "Escreva a formulação fraca para -u'' = π² sin(πx) em [0,1] e verifique simetria.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Papel e lápis, software simbólico como SymPy ou Mathematica.",
                                  "tips": "Sempre anote os espaços de funções explicitamente para evitar erros.",
                                  "learningObjective": "Derivar corretamente a forma variacional identificando termos de contorno.",
                                  "commonMistakes": "Esquecer o sinal na integração por partes; não especificar condições em V."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar condições de contorno essenciais (Dirichlet)",
                                  "subSteps": [
                                    "Defina o espaço afinado V_g = {v ∈ H¹ | v = g em Γ_D} usando funções lift ou penalização.",
                                    "Para discretização: Escolha base nodal com restrições nos nós de Γ_D (u_i = g_i).",
                                    "Modifique o sistema K u = F removendo graus de liberdade em Γ_D e impondo valores.",
                                    "Implemente em código: Fixe valores nos nós fronteira e resolva para os internos.",
                                    "Teste com u(0)=0, u(1)=1 em um problema 1D."
                                  ],
                                  "verification": "Monte o sistema matricial para malha com 3 elementos e verifique u nos nós fixos.",
                                  "estimatedTime": "4 horas",
                                  "materials": "MATLAB/Python com NumPy/SciPy, template de código EF 1D.",
                                  "tips": "Use interpolação para g não-nodal; evite penalização para precisão.",
                                  "learningObjective": "Impor corretamente essenciais modificando o espaço de aproximação.",
                                  "commonMistakes": "Não zerar linhas/colunas correspondentes; confundir com Lagrange multipliers."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incorporar condições de contorno naturais (Neumann/Robin)",
                                  "subSteps": [
                                    "Na formulação fraca, adicione ∫_Γ_N h v dΓ ao lado direito L(v) para Neumann ∂u/∂n = h.",
                                    "Para Robin: α u + β ∂u/∂n = γ → termo bilinear -∫_Γ_R (α u v + β ∂u/∂n v) + ∫ γ v.",
                                    "Discretize: Contribua para vetor de carga F nos nós de Γ_N/R.",
                                    "Mantenha todos os graus de liberdade livres em Γ_N/R.",
                                    "Valide: Compare solução com analítica para problema misto."
                                  ],
                                  "verification": "Implemente Neumann u'(1)=0 em problema anterior e cheque norma L2 do erro.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Código do Step 3 estendido, malha com fronteiras marcadas.",
                                  "tips": "Gauss-Legendre para integrais de fronteira; normalize vetores de carga.",
                                  "learningObjective": "Integrar naturalmente termos de Neumann/Robin no funcional linear.",
                                  "commonMistakes": "Esquecer termos em L(v); impor essenciais em Γ_N por engano."
                                }
                              ],
                              "practicalExample": "Resolva -u'' + u = 0 em [0,1] com u(0)=0 (essencial Dirichlet), u'(1)=1 (natural Neumann). Solução exata: u(x)=sinh(x)/cosh(1). Discretize com 4 elementos lineares, imponha u(0)=0 fixando nó, adicione ∫_Γ_N 1 * φ_i dΓ ao F.",
                              "finalVerifications": [
                                "Distinção correta: Essenciais em V, naturais em L(v).",
                                "Formulação fraca derivada sem erros de sinal.",
                                "Sistema matricial montado com BCs essenciais impostas (valores fixos).",
                                "Termos naturais corretamente adicionados ao vetor de carga.",
                                "Erro numérico <1% comparado à solução analítica em malha fina.",
                                "Código executável reproduz solução para BCs mistas."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: 90% acerto em quiz sobre tipos de BCs.",
                                "Derivação correta da forma fraca (verificação manual).",
                                "Implementação numérica convergente (ordem de convergência 2 para lineares).",
                                "Tratamento correto de BCs mistas sem singularidades.",
                                "Explicação clara de por que naturais 'aparecem automaticamente'.",
                                "Aplicação a problema 2D simples com visualização."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Espaços de Sobolev H¹ e análise funcional.",
                                "Física: Interpretação em mecânica (deslocamentos vs trações).",
                                "Computação: Programação numérica e montagem de matrizes esparsas.",
                                "Engenharia Civil: Análise de estruturas com cargas de superfície."
                              ],
                              "realWorldApplication": "Em simulações de elementos finitos para análise de tensões em vigas (essenciais: apoios fixos; naturais: cargas distribuídas), fluxo de calor em paredes (Dirichlet: temperatura fixa; Neumann: fluxo térmico) ou vibrações acústicas com impedância Robin."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "34.1.2.3.2",
                        "name": "Funções de Teste e Aproximação no Método de Galerkin",
                        "description": "Definição do método de Galerkin como um caso particular do método dos pesos onde as funções de teste são iguais às funções de base da aproximação trial.",
                        "specificSkills": [
                          {
                            "id": "34.1.2.3.2.1",
                            "name": "Escolher funções de base adequadas para o espaço de aproximação",
                            "description": "Selecionar funções polinomiais ou hierárquicas contínuas que satisfaçam as condições de contorno essenciais e formem uma base para o subespaço finito.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o problema e identificar condições de contorno essenciais",
                                  "subSteps": [
                                    "Estudar a equação diferencial governante e o domínio geométrico do problema.",
                                    "Classificar as condições de contorno: essenciais (Dirichlet, impostas diretamente na solução) e naturais (Neumann ou Robin).",
                                    "Determinar o espaço de funções admissíveis que devem satisfazer as condições essenciais.",
                                    "Verificar simetrias ou particularidades do problema que influenciem a escolha.",
                                    "Documentar as condições essenciais numericamente (ex.: u(0)=0, u(L)=δ)."
                                  ],
                                  "verification": "Lista completa e correta das condições essenciais identificadas, com justificativa.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Equação diferencial do problema",
                                    "Diagrama esquemático do domínio",
                                    "Referência teórica sobre Método de Galerkin"
                                  ],
                                  "tips": "Priorize condições essenciais, pois elas devem ser satisfeitas exatamente pelas funções de base.",
                                  "learningObjective": "Identificar e documentar condições de contorno essenciais para guiar a escolha de funções de base.",
                                  "commonMistakes": [
                                    "Confundir condições essenciais com naturais.",
                                    "Ignorar condições em pontos singulares.",
                                    "Não considerar o domínio multifísico."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar famílias de funções de base candidatas",
                                  "subSteps": [
                                    "Listar opções comuns: polinomiais (ex.: Lagrange), hierárquicas contínuas (ex.: Legendre, Chebyshev) ou trigonométricas.",
                                    "Avaliar continuidade e suavidade requerida (C0, C1) para o problema (ex.: flexão requer C1).",
                                    "Comparar vantagens: polinomiais para simplicidade, hierárquicas para eficiência hierárquica.",
                                    "Verificar suporte local ou global das funções.",
                                    "Escolher família baseada em critérios como condicionamento numérico e custo computacional."
                                  ],
                                  "verification": "Tabela comparativa de 3-5 famílias com prós e contras, justificando a escolha principal.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Tabelas de funções ortogonais",
                                    "Software simbólico como Mathematica ou SymPy",
                                    "Literatura sobre bases hierárquicas em MEF"
                                  ],
                                  "tips": "Prefira funções ortogonais para melhor condicionamento da matriz de rigidez.",
                                  "learningObjective": "Selecionar família de funções adequadas considerando propriedades matemáticas e numéricas.",
                                  "commonMistakes": [
                                    "Escolher funções descontínuas para problemas que requerem continuidade.",
                                    "Ignorar o custo computacional para problemas grandes.",
                                    "Não considerar ortogonalidade."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir funções de base específicas que satisfaçam condições essenciais",
                                  "subSteps": [
                                    "Modificar funções candidatas para impor condições essenciais (ex.: φ_i(x) = x * p_i(x) para u(0)=0).",
                                    "Gerar N funções linearmente independentes para o subespaço finito de dimensão N.",
                                    "Normalizar ou escalar funções para unidade ou conveniência numérica.",
                                    "Plotar ou tabular as funções para visual inspeção.",
                                    "Verificar analiticamente satisfação das condições em todos os pontos essenciais."
                                  ],
                                  "verification": "Gráficos e cálculos confirmando que todas φ_i satisfazem condições essenciais.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de plotagem (Matplotlib, MATLAB)",
                                    "Calculadora simbólica",
                                    "Papel e lápis para derivações"
                                  ],
                                  "tips": "Use multiplicação por fatores que zerem nas fronteiras essenciais para simplicidade.",
                                  "learningObjective": "Construir base de funções que forme subespaço conforme as restrições do problema.",
                                  "commonMistakes": [
                                    "Funções que violam condições em pontos internos.",
                                    "Dependência linear entre funções.",
                                    "Escala inadequada levando a ill-conditioning."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar propriedades da base e validar adequação",
                                  "subSteps": [
                                    "Testar independência linear (determinante da matriz de Gram não-zero).",
                                    "Avaliar completeza aproximada (capacidade de representar soluções suaves).",
                                    "Calcular normas ou condições de contorno naturais via integração.",
                                    "Simular um problema teste simples para checar precisão.",
                                    "Documentar limitações e sugestões de refinamento (aumentar N ou p-refinamento)."
                                  ],
                                  "verification": "Relatório com testes numéricos confirmando independência e boa aproximação.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software numérico (Python/NumPy, FEniCS)",
                                    "Problema teste benchmark",
                                    "Critérios de erro L2"
                                  ],
                                  "tips": "Use ortogonalização (Gram-Schmidt) se necessário para melhorar condicionamento.",
                                  "learningObjective": "Garantir que a base escolhida seja adequada para o Método de Galerkin.",
                                  "commonMistakes": [
                                    "Bases mal-condicionadas por funções quase dependentes.",
                                    "Não testar com problema real.",
                                    "Subestimar efeitos de Runge em polinomiais altos."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma barra axial em tração com condições u(0)=0 e u(L)=1, escolha funções φ_i(x) = x (1 - x/L)^{i-1} para i=1 a 4, baseadas em polinomiais modificados, formando base que satisfaz essencialmente u(0)=0 e permite aproximação para u(L)≈1.",
                              "finalVerifications": [
                                "Todas funções de base satisfazem exatamente as condições de contorno essenciais.",
                                "As funções são linearmente independentes (rank da matriz de Gram = N).",
                                "A base permite boa aproximação de soluções suaves (erro L2 < 5% em teste).",
                                "Condições naturais são corretamente incorporadas via integrais fracos.",
                                "Condicionamento da matriz de rigidez é aceitável (cond < 10^6).",
                                "Visualização confirma comportamento físico esperado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de condições essenciais (100% corretas).",
                                "Justificativa técnica robusta para escolha da família de funções (profundidade conceitual).",
                                "Construção correta das funções com verificação analítica/numérica.",
                                "Análise completa de propriedades (independência, completeza).",
                                "Uso eficiente de ferramentas e documentação clara.",
                                "Capacidade de generalizar para problemas similares."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: conceitos de bases, independência linear e ortogonalidade.",
                                "Análise Numérica: teoria de aproximação de funções e polinômios espectrais.",
                                "Física/Mecânica: formulação variacional de problemas elásticos.",
                                "Programação Computacional: implementação simbólica e numérica em Python/MATLAB.",
                                "Matemática Aplicada: espaços de Sobolev e métodos espectrais."
                              ],
                              "realWorldApplication": "Na simulação de elementos finitos para análise de tensões em vigas de pontes ou lâminas de turbinas eólicas, onde funções de base adequadas garantem precisão e eficiência computacional na previsão de deformações e falhas estruturais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.2.3.1.1"
                            ]
                          },
                          {
                            "id": "34.1.2.3.2.2",
                            "name": "Comparar método de Galerkin com Rayleigh-Ritz",
                            "description": "Explicar que no Galerkin as funções de teste = funções de aproximação, enquanto Rayleigh-Ritz minimiza energia potencial, sendo equivalente para formas bilineares simétricas positivas definidas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos do Método de Rayleigh-Ritz",
                                  "subSteps": [
                                    "Estude a formulação variacional: minimização da energia potencial total Π(u) = ∫ (1/2)ε^T σ dV - ∫ f u dV - ∫ t u dS.",
                                    "Entenda a aproximação u_h = Σ c_i φ_i, onde φ_i são funções de base.",
                                    "Derive o sistema Ku = f pela estacionariedade δΠ = 0, levando a forma bilinear simétrica a(u,v) = l(v).",
                                    "Discuta requisitos: forma bilinear simétrica positiva definida.",
                                    "Examine um exemplo 1D simples, como barra axial."
                                  ],
                                  "verification": "Resolva um problema 1D de barra e verifique se o sistema K é simétrico positivo definido.",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "Livro de Elementos Finitos (ex: Zienkiewicz)",
                                    "Papel e lápis ou MATLAB para matrizes",
                                    "Notas de aula sobre variational principles"
                                  ],
                                  "tips": "Sempre verifique simetria da matriz K; use funções polinomiais simples para testes iniciais.",
                                  "learningObjective": "Compreender a base variacional e minimização de energia no Rayleigh-Ritz.",
                                  "commonMistakes": [
                                    "Confundir energia potencial com energia cinética",
                                    "Esquecer termos de contorno de Neumann",
                                    "Não verificar positividade definida"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar Fundamentos do Método de Galerkin",
                                  "subSteps": [
                                    "Formule o problema fraco: encontrar u em V tal que a(u,v) = l(v) ∀ v em V, onde a é bilinear, l linear.",
                                    "Aproxime u_h = Σ c_i φ_i e teste com v_j = φ_j (Galerkin: funções de teste = aproximação).",
                                    "Derive o sistema Ku = f pela ortogonalidade da residual: ∫ R(u_h) φ_j dV = 0.",
                                    "Compare com métodos de colocation ou subdomain.",
                                    "Resolva exemplo 1D de barra axial usando Galerkin."
                                  ],
                                  "verification": "Implemente Galerkin para barra 1D e confirme que matriz K coincide com Rayleigh-Ritz.",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "Software FEM básico (ex: FEniCS ou código MATLAB)",
                                    "Exemplos numéricos de aula",
                                    "Calculadora simbólica como SymPy"
                                  ],
                                  "tips": "Lembre-se: Galerkin é projeção L2 da residual; escolha funções consistentes.",
                                  "learningObjective": "Dominar a projeção residual e escolha de funções de teste no Galerkin.",
                                  "commonMistakes": [
                                    "Usar funções de teste diferentes sem justificativa",
                                    "Ignorar espaço de funções V_h compatível",
                                    "Confundir com least-squares"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Diferenças Chave entre os Métodos",
                                  "subSteps": [
                                    "Compare formulações: Rayleigh-Ritz minimiza Π(u_h), Galerkin torna residual ortogonal às φ_i.",
                                    "Analise: em Rayleigh-Ritz, δΠ/δc_i = 0; em Galerkin, a(u_h, φ_j) = l(φ_j).",
                                    "Discuta generalidade: Galerkin aplica a não-simétricos/não-lineares; Rayleigh-Ritz requer simetria.",
                                    "Examine estabilidade e precisão em problemas convectivos.",
                                    "Crie tabela comparativa: funções teste/aproximação, condições, aplicações."
                                  ],
                                  "verification": "Preencha tabela comparativa e discuta com colega ou tutor.",
                                  "estimatedTime": "30 min",
                                  "materials": [
                                    "Tabela em branco",
                                    "Referências: Hughes 'The Finite Element Method'",
                                    "Vídeos Khan Academy sobre métodos variationais"
                                  ],
                                  "tips": "Foque em 'teste = aproximação' como diferença pivotal no Galerkin.",
                                  "learningObjective": "Destacar diferenças conceituais e matemáticas precisas.",
                                  "commonMistakes": [
                                    "Achar que são idênticos sempre",
                                    "Ignorar não-simétricos onde diferem",
                                    "Confundir com Petrov-Galerkin"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Equivalência e Aplicações Práticas",
                                  "subSteps": [
                                    "Prove equivalência: para a(u,v) simétrica positiva definida, minimização Π leva a mesmo sistema.",
                                    "Discuta teorema: soluções Galerkin = Rayleigh-Ritz nessas condições.",
                                    "Analise quando diferem: não-simétricos (ex: fluxo convectivo), não-lineares.",
                                    "Escolha método: Rayleigh-Ritz para energia, Galerkin para generalidade.",
                                    "Implemente ambos em código para problema simétrico e compare."
                                  ],
                                  "verification": "Execute simulação numérica e confirme K idêntico para caso simétrico.",
                                  "estimatedTime": "60 min",
                                  "materials": [
                                    "MATLAB/Python com NumPy/SciPy",
                                    "Problema teste: viga Euler-Bernoulli",
                                    "Código template FEM 1D"
                                  ],
                                  "tips": "Use problemas lineares elásticos para demonstrar equivalência.",
                                  "learningObjective": "Entender condições de equivalência e critérios de escolha.",
                                  "commonMistakes": [
                                    "Aplicar Rayleigh-Ritz a não-simétricos",
                                    "Esquecer escalonamento para grandes problemas",
                                    "Não validar numericamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva o problema de deflexão de uma viga cantilever sob carga uniforme usando ambos métodos com 2 elementos lineares. Compare matrizes de rigidez K e soluções u; confirme equivalência pois bilinear é simétrica positiva definida.",
                              "finalVerifications": [
                                "Explique verbalmente por que funções de teste = aproximação no Galerkin.",
                                "Mostre derivação matemática da equivalência para bilinear simétrica.",
                                "Identifique um problema onde Rayleigh-Ritz falha (ex: não-simétrico).",
                                "Implemente código simples e valide resultados idênticos.",
                                "Crie tabela comparativa precisa com 5 diferenças/semelhanças.",
                                "Discuta impacto em software FEM comercial como ANSYS."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção teste vs. minimização de energia (80% peso).",
                                "Correta identificação de condições de equivalência.",
                                "Uso correto de terminologia (bilinear, residual, variacional).",
                                "Exemplo numérico validado com resultados coincidentes.",
                                "Análise de limitações e aplicações práticas.",
                                "Clareza na tabela/diagrama comparativo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (autovalores para positividade), Cálculo variacional.",
                                "Física: Princípios de energia em mecânica dos sólidos.",
                                "Computação: Implementação numérica em FEM codes (Python/MATLAB).",
                                "Engenharia Civil: Análise estrutural com equivalência em softwares.",
                                "Matemática Aplicada: Métodos espectrais e projeções L2."
                              ],
                              "realWorldApplication": "Em simulações FEM para design de aviões (NASA), Galerkin é padrão para generalidade em problemas acoplados/multifísica, enquanto Rayleigh-Ritz otimiza energia em estruturas lineares elásticas, como pontes, reduzindo tempo computacional em códigos como Abaqus."
                            },
                            "estimatedTime": "45 minutos",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.2.3.1.2"
                            ]
                          },
                          {
                            "id": "34.1.2.3.2.3",
                            "name": "Projetar a equação fraca no subespaço de Galerkin",
                            "description": "Impor que a equação fraca seja satisfeita para todas as funções de teste do subespaço, levando a um sistema de equações acopladas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a equação fraca original e o subespaço de Galerkin",
                                  "subSteps": [
                                    "Reescrever a equação diferencial forte na forma fraca integrando por partes e impondo condições de contorno essenciais.",
                                    "Definir o espaço de funções de aproximação V_h como um subespaço finito-dimensional (ex: polinômios por elementos).",
                                    "Especificar que o subespaço de Galerkin usa as mesmas funções para aproximação e teste (Galerkin ortogonal).",
                                    "Verificar consistência: a forma fraca deve ser bilinear e coerente com a forte.",
                                    "Documentar notação: a(u,v) = l(v) para u_h em V_h, v em V_h."
                                  ],
                                  "verification": "Confirme que a forma fraca é satisfeita para funções teste arbitrárias no espaço completo e restrita ao subespaço.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de elementos finitos (ex: Zienkiewicz), caderno de anotações, software simbólico como SymPy.",
                                  "tips": "Use integração por partes sistematicamente para evitar erros de sinal.",
                                  "learningObjective": "Entender a transição da forma forte para fraca e a escolha do subespaço finito.",
                                  "commonMistakes": "Esquecer termos de contorno naturais ou inverter sinais na integração por partes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar funções de teste do subespaço de Galerkin",
                                  "subSteps": [
                                    "Escolher uma base {φ_i}_{i=1}^N para o subespaço V_h (ex: funções hat em malha 1D).",
                                    "Impor que funções de teste v sejam lineares combinadas das φ_i: v = ∑ c_j φ_j.",
                                    "Listar explicitamente as N funções de teste independentes.",
                                    "Verificar ortogonalidade ou propriedades da base se aplicável.",
                                    "Desenhar a malha e funções base para visualização."
                                  ],
                                  "verification": "A expansão da solução u_h = ∑ u_i φ_i deve permitir teste com cada φ_k.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel milimetrado, MATLAB/Mathematica para plotar bases, tutorial de FEM 1D.",
                                  "tips": "Comece com malha uniforme simples para depuração.",
                                  "learningObjective": "Dominar a escolha e representação de funções de teste no subespaço finito.",
                                  "commonMistakes": "Confundir funções de aproximação com teste em métodos não-Galerkin."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Impor a equação fraca para cada função de teste",
                                  "subSteps": [
                                    "Para cada k=1 a N, escrever a(k,u_h, φ_k) = l(φ_k).",
                                    "Substituir u_h = ∑_{j=1}^N u_j φ_j na forma bilinear.",
                                    "Expandir: ∑_{j=1}^N u_j a(φ_j, φ_k) = l(φ_k), formando a k-ésima equação.",
                                    "Calcular integrais matriciais K_{kj} = a(φ_j, φ_k) e vetor f_k = l(φ_k).",
                                    "Verificar simetria da matriz se a forma bilinear for simétrica."
                                  ],
                                  "verification": "Cada equação resulta em uma linha do sistema Ku = f.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora simbólica, código Python com NumPy/SciPy para integrais numéricas.",
                                  "tips": "Use quadratura gaussiana para integrais exatas em elementos lineares.",
                                  "learningObjective": "Formular as equações acopladas via projeção Galerkin.",
                                  "commonMistakes": "Índices errados na soma (confundir j e k) ou esquecimento de fatores de escala."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar e validar o sistema de equações acopladas",
                                  "subSteps": [
                                    "Assemblar a matriz K global e vetor f a partir de contribuições elementares.",
                                    "Aplicar condições de contorno essenciais modificando linhas/colunas de K e f.",
                                    "Resolver o sistema Ku = f numericamente ou analiticamente para caso simples.",
                                    "Comparar solução com solução exata ou refinamento h.",
                                    "Analisar convergência e acoplamento entre graus de liberdade."
                                  ],
                                  "verification": "A solução u_h satisfaz a equação fraca no subespaço: |a(u_h, φ_k) - l(φ_k)| < ε para todo k.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Solver linear (MATLAB, FEniCS, ou código handmade), dados de benchmark.",
                                  "tips": "Teste com N=2 DOFs primeiro para validação manual.",
                                  "learningObjective": "Construir e interpretar o sistema linear resultante da projeção.",
                                  "commonMistakes": "Má montagem da matriz (erros em loop de elementos) ou imposição incorreta de BCs."
                                }
                              ],
                              "practicalExample": "Para a equação de Poisson -u'' + u = f em [0,1] com u(0)=u(1)=0, use malha com 2 elementos lineares. Bases φ1 e φ2 levam a K = [[2, -1], [-1, 2]] + mass matrix, resolvendo Ku=f para f médio.",
                              "finalVerifications": [
                                "A matriz K é simétrica positiva definida para problemas elípticos.",
                                "Resíduo da forma fraca é ortogonal às funções teste: a(u_h - u, φ_k)=0.",
                                "Solução converge com refinamento da malha.",
                                "Condições de contorno essenciais são exatamente satisfeitas.",
                                "Energia da solução bate com norma esperada.",
                                "Teste de consistência: recuperar equação forte nos nós."
                              ],
                              "assessmentCriteria": [
                                "Correta derivação da forma fraca sem erros de sinal.",
                                "Base do subespaço bem definida e funções teste listadas.",
                                "Expansão correta levando a Ku=f com índices precisos.",
                                "Montagem matricial livre de erros de programação/montagem.",
                                "Validação numérica com erro <1% vs. exato.",
                                "Explicação clara do acoplamento entre equações."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Resolução de sistemas esparsos e propriedades de matrizes.",
                                "Análise Numérica: Estabilidade, convergência e erro de aproximação.",
                                "Programação: Implementação em Python/FEniCS para automação.",
                                "Física: Aplicação em equilíbrio mecânico e difusão."
                              ],
                              "realWorldApplication": "Em simulações FEM para análise estrutural (ex: tensão em vigas via NASTRAN), modelagem de fluxo de calor em reatores nucleares ou otimização topológica em design de peças automotivas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.2.3.1.3"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "34.1.2.3.3",
                        "name": "Montagem e Resolução do Sistema no Método de Galerkin",
                        "description": "Construção das matrizes de rigidez e vetores de carga a partir dos coeficientes das integrais definidas pelas formas bilinear e linear.",
                        "specificSkills": [
                          {
                            "id": "34.1.2.3.3.1",
                            "name": "Calcular elementos da matriz de rigidez",
                            "description": "Avaliar integrais duplas ∫ a(φ_i, φ_j) dΩ para obter K_ij, usando funções de base φ_i e φ_j em problemas 1D como barras ou vigas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a forma bilinear e funções de base no método de Galerkin 1D",
                                  "subSteps": [
                                    "Revise o problema modelo: equação de equilíbrio para barras (d/dx (EA du/dx) = f) ou vigas.",
                                    "Identifique a forma fraca: encontre v tal que ∫ a(u,v) dΩ = ∫ f v dΩ para v em espaço de funções teste.",
                                    "Defina a forma bilinear a(φ_i, φ_j) = ∫_Ω (coeficientes * derivadas de φ_i e φ_j) dΩ.",
                                    "Escolha funções de base φ_i: lineares (φ1 = 1-ξ, φ2=ξ) para elementos lineares em barras.",
                                    "Anote propriedades: φ_i contínuas, zero em nós não pertencentes."
                                  ],
                                  "verification": "Escreva explicitamente a(φ_i, φ_j) para um problema de barra axial e confirme simetria (a(φ_i,φ_j)=a(φ_j,φ_i)).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Elementos Finitos (ex: Zienkiewicz), caderno de anotações, software simbólico como SymPy."
                                  ],
                                  "tips": "Comece com o caso mais simples: barra axial com EA constante para ganhar intuição.",
                                  "learningObjective": "Compreender como funções de base geram os elementos da matriz de rigidez via forma bilinear.",
                                  "commonMistakes": [
                                    "Confundir forma forte com fraca.",
                                    "Esquecer que funções de base são zero fora do elemento."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Parametrizar o elemento 1D e expressar funções de base em coordenadas locais",
                                  "subSteps": [
                                    "Defina o elemento: comprimento L, nós em x=0 e x=L, mapeamento ξ = x/L de [0,1].",
                                    "dx = L dξ, derivadas: dφ1/dx = -1/L, dφ2/dx = 1/L (constantes para lineares).",
                                    "Escreva φ_i(ξ) explicitamente: φ1(ξ)=1-ξ, φ2(ξ)=ξ.",
                                    "Inclua propriedades do material: EA(x) ou constante dentro do elemento.",
                                    "Prepare o integrando: para barra, a(φ_i,φ_j) = ∫_0^L EA (dφ_i/dx)(dφ_j/dx) dx."
                                  ],
                                  "verification": "Derive dφ_i/dx corretamente e substitua no integrando, confirmando constantes para elementos lineares.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel milimetrado, calculadora, tutorial de mapeamento isoparamétrico."
                                  ],
                                  "tips": "Use ξ para simplificar: integral torna-se L ∫_0^1 (...) dξ.",
                                  "learningObjective": "Mapear geometria global para local e expressar derivadas em coordenadas de referência.",
                                  "commonMistakes": [
                                    "Erro no Jacobiano (dx/dξ = L).",
                                    "Derivadas erradas: lembre chain rule."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar e avaliar a integral dupla ∫ a(φ_i, φ_j) dΩ",
                                  "subSteps": [
                                    "Identifique pares (i,j): (1,1), (1,2), (2,1), (2,2).",
                                    "Escreva integrando para cada: ex. K11 = ∫ EA ( -1/L )^2 dx = (EA/L) ∫ dx = EA/L.",
                                    "Para lineares constantes: K = (EA/L) * [[1, -1], [-1, 1]].",
                                    "Se EA variável ou funções não-lineares, use integração numérica (Gauss) ou analítica.",
                                    "Calcule numericamente se necessário: divida em pontos de Gauss e pese."
                                  ],
                                  "verification": "Obtenha matriz K 2x2 simétrica e some linhas/colunas para zero (condição de partição de unidade).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "SymPy ou Mathematica para integrais simbólicas, tabela de Gauss-Legendre."
                                  ],
                                  "tips": "Memorize padrão para lineares: sempre [[α, -α], [-α, α]] com α=EA/L.",
                                  "learningObjective": "Avaliar integrais analítica ou numericamente para obter K_ij exatos.",
                                  "commonMistakes": [
                                    "Fator 1/L esquecido nas derivadas.",
                                    "Integral de 0 a L em vez de transformar para [0,1]."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar resultados e preparar para montagem global",
                                  "subSteps": [
                                    "Confira simetria e positivos definitos (autovalores >0).",
                                    "Compare com fórmula conhecida para elemento padrão.",
                                    "Teste com L=1, EA=1: K=[[1,-1],[-1,1]].",
                                    "Discuta generalizações: quadráticas, vigas (com termos de segunda derivada).",
                                    "Documente K_ij para inserção na matriz global."
                                  ],
                                  "verification": "Aplique deslocamentos unitários e verifique forças reativas consistentes (ex: u=[1,0] dá força EA/L no nó1).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software FEA como FreeFEM ou código MATLAB simples para validar."
                                  ],
                                  "tips": "Sempre teste com casos analíticos conhecidos para debug.",
                                  "learningObjective": "Validar elementos locais antes da montagem do sistema global.",
                                  "commonMistakes": [
                                    "Matriz não simétrica devido a erros de cálculo.",
                                    "Ignorar constantes de material."
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma barra axial de A=1, E=1, L=2m, elemento linear entre nós 1 (x=0) e 2 (x=2): K11 = ∫_0^2 (1)( -1/2 )^2 dx = (1/4)*2 = 0.5; K12=K21=-0.5; K22=0.5. Matriz K = 0.5 * [[1,-1],[-1,1]].",
                              "finalVerifications": [
                                "Matriz K é simétrica e definida positiva semi-definida.",
                                "Soma de cada linha/coluna é zero (compatibilidade rígida).",
                                "Valores coincidem com fórmulas padrão para elementos lineares.",
                                "Derivadas das funções de base estão corretas (1/L).",
                                "Integral transformada corretamente para coordenadas locais.",
                                "Forças reativas consistentes com deslocamentos impostos."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo das derivadas de φ_i (pontos totais).",
                                "Correta transformação da integral (Jacobiano L).",
                                "Simetria e propriedades físicas da matriz K.",
                                "Tratamento de casos com coeficientes variáveis.",
                                "Validação com exemplo numérico simples.",
                                "Clareza na derivação passo a passo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo integral duplas e mudança de variáveis.",
                                "Programação: Implementar em Python/SymPy para automação.",
                                "Física: Mecânica dos sólidos e princípio dos trabalhos virtuais.",
                                "Computação Científica: Integração numérica de Gauss.",
                                "Engenharia Civil: Análise de estruturas treliçadas."
                              ],
                              "realWorldApplication": "Em software FEA como ANSYS ou Abaqus, calcular K_ij para milhões de elementos em simulações de aviões, pontes ou implantes médicos, prevendo deformações sob cargas reais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.2.3.2.1"
                            ]
                          },
                          {
                            "id": "34.1.2.3.3.2",
                            "name": "Montar vetor de carga e aplicar condições de contorno",
                            "description": "Computar F_i = L(φ_i) incluindo cargas distribuídas e forças puntiformes, e impor condições essenciais modificando o sistema K u = F.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar funções de forma e identificar cargas",
                                  "subSteps": [
                                    "Defina o domínio do problema e as funções de teste φ_i do espaço de Galerkin.",
                                    "Identifique cargas distribuídas f(x) e forças puntiformes P_j nos nós.",
                                    "Liste todos os graus de liberdade (GL) e marque aqueles com condições de contorno essenciais (CC essenciais).",
                                    "Esboce a malha finita e associe funções φ_i aos elementos.",
                                    "Verifique a normalização das funções φ_i para consistência."
                                  ],
                                  "verification": "Confirme que todas φ_i somam 1 nos nós e que cargas e GL estão listados corretamente em uma tabela.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis para esboços",
                                    "Software de MEF como MATLAB ou FEniCS",
                                    "Referência teórica do método de Galerkin"
                                  ],
                                  "tips": "Sempre use funções φ_i canônicas para elementos lineares (hat functions) para simplicidade inicial.",
                                  "learningObjective": "Entender a base do vetor de carga como <φ_i, f> no produto interno.",
                                  "commonMistakes": [
                                    "Confundir funções de forma com funções de teste",
                                    "Esquecer unidades das cargas",
                                    "Não mapear corretamente GL para nós"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar contribuições de cargas distribuídas no vetor F",
                                  "subSteps": [
                                    "Para cada i, calcule F_i_dist = ∫_Ω φ_i(x) f(x) dΩ numericamente ou analiticamente por elemento.",
                                    "Some as contribuições de todos os elementos para cada GL i.",
                                    "Use quadratura gaussiana para integrais em elementos finitos.",
                                    "Verifique simetria ou propriedades esperadas de F_dist.",
                                    "Armazene em vetor global F, inicializando com zeros."
                                  ],
                                  "verification": "Compare F_i_dist com solução analítica para um elemento teste; erro < 1%.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB para integrais",
                                    "Tabelas de quadratura gaussiana",
                                    "Exemplo de malha simples"
                                  ],
                                  "tips": "Para cargas uniformes, simplifique integrais fechadas para eficiência.",
                                  "learningObjective": "Dominar o cálculo do vetor de carga equivalente para cargas volumétricas ou de superfície.",
                                  "commonMistakes": [
                                    "Não transformar coordenadas para elementos locais",
                                    "Erros em limites de integração",
                                    "Ignorar Jacobiano na integração"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar forças puntiformes ao vetor F",
                                  "subSteps": [
                                    "Identifique nós com forças puntiformes P_j e associe ao GL correspondente.",
                                    "Adicione diretamente P_j a F_j no vetor global.",
                                    "Para forças em midpoints ou superfícies, distribua via funções de forma.",
                                    "Verifique equilíbrio global: soma de F deve igualar carga total aplicada.",
                                    "Atualize F = F_dist + F_punt."
                                  ],
                                  "verification": "Some componentes de F e compare com carga total conhecida do problema.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha Excel ou script Python para soma",
                                    "Diagrama do problema com cargas marcadas"
                                  ],
                                  "tips": "Use lumping se necessário para aproximação em massas ou cargas.",
                                  "learningObjective": "Integrar cargas nodais no sistema global sem duplicação.",
                                  "commonMistakes": [
                                    "Adicionar P_j a GL errado",
                                    "Duplicar contribuições distribuídas",
                                    "Esquecer fatores de escala como espessura"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar condições de contorno essenciais modificando K e F",
                                  "subSteps": [
                                    "Identifique GL com CC essenciais (ex: u_k = g_k).",
                                    "Para cada k: substitua linha/coluna k de K por zeros, exceto K_kk=1; ajuste F_k = g_k.",
                                    "Para GL acoplados, mova termos para F: F_i -= K_ik * g_k para i ≠ k.",
                                    "Remova ou renumereie GL eliminados para sistema reduzido.",
                                    "Verifique que o sistema modificado satisfaz as CC por inspeção."
                                  ],
                                  "verification": "Imponha CC manualmente no vetor solução u e confira K u = F.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB/Python para manipulação matricial",
                                    "Matriz K pré-montada do passo anterior"
                                  ],
                                  "tips": "Implemente via penalidade primeiro para depuração, depois método exato.",
                                  "learningObjective": "Modificar o sistema Ku=F para impor CC Dirichlet sem singularidades.",
                                  "commonMistakes": [
                                    "Esquecer de zerar off-diagonais",
                                    "Não ajustar F para reações",
                                    "Renumerar GL incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar montagem completa do sistema",
                                  "subSteps": [
                                    "Monte sistema completo K u = F modificado.",
                                    "Resolva para u e verifique resíduos r = K u - F ≈ 0.",
                                    "Cheque satisfação de CC: u_k == g_k.",
                                    "Compare com solução analítica ou benchmark.",
                                    "Documente o processo em relatório."
                                  ],
                                  "verification": "Norma do resíduo ||r|| < 10^-6 e CC exatas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Solver linear em software",
                                    "Solução analítica de referência"
                                  ],
                                  "tips": "Use plot de u vs x para inspeção visual.",
                                  "learningObjective": "Garantir integridade do sistema antes da resolução.",
                                  "commonMistakes": [
                                    "Resolver sistema não modificado",
                                    "Ignorar warnings de solver",
                                    "Não normalizar unidades"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma barra 1D de comprimento L=1, equação -u''=1 com u(0)=0, u(1)=0. Use 3 elementos lineares. Calcule F_dist = [1/6, 1/2, 1/6]^T * L, adicione P=0.5 no nó 2 → F=[1/6, 1, 1/6]^T. Para CC u1=u3=0, modifique K removendo linhas 1 e 3, resolva para u2.",
                              "finalVerifications": [
                                "Vetor F inclui corretamente ∫ φ_i f dΩ + P_j.",
                                "Soma de F equals carga total aplicada.",
                                "CC essenciais impostas: u_k = g_k na solução.",
                                "Sistema K u = F satisfeito com resíduo < 10^-8.",
                                "Equilíbrio de forças nos nós verificado.",
                                "Comparação com solução exata u(x)=x(1-x)/2 dentro de 1%."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de integrais para F_dist (erro < 0.5%).",
                                "Correta adição e distribuição de forças puntiformes.",
                                "Modificação exata de K e F para todas CC essenciais.",
                                "Verificação completa de equilíbrio e resíduos.",
                                "Documentação clara com fórmulas e valores numéricos.",
                                "Eficiência computacional (tempo < 5 min para malha 100 nós)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Integração numérica e álgebra linear.",
                                "Programação: Implementação em Python/NumPy para automação.",
                                "Física: Princípios de equilíbrio estático em estruturas.",
                                "Computação Científica: Otimização de solvers esparsos."
                              ],
                              "realWorldApplication": "Na análise de tensões em vigas de pontes ou chassis automotivos via MEF, onde cargas distribuídas (peso próprio, vento) e puntiformes (cargas veiculares) são impostas, com CC de apoio fixo, garantindo precisão na previsão de deformações para segurança estrutural."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.2.3.2.3"
                            ]
                          },
                          {
                            "id": "34.1.2.3.3.3",
                            "name": "Resolver o sistema linear e avaliar a solução",
                            "description": "Usar métodos diretos ou iterativos para resolver K u = F e discutir convergência e precisão da aproximação de Galerkin.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e aplicar método direto para resolver Ku = F",
                                  "subSteps": [
                                    "Identificar o tamanho e propriedades da matriz K (simétrica positiva definida).",
                                    "Escolher método direto adequado (ex: eliminação de Gauss, decomposição LU ou Cholesky).",
                                    "Implementar o solver em software ou manualmente para sistemas pequenos.",
                                    "Calcular a solução u e o vetor residual r = F - K u.",
                                    "Armazenar resultados para comparação posterior."
                                  ],
                                  "verification": "Verificar se o residual ||r|| é menor que um tolerância pré-definida (ex: 1e-10) e se a solução satisfaz as condições de contorno.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software MATLAB ou Python com NumPy/SciPy",
                                    "Matriz K e vetor F do problema de teste",
                                    "Documentação de solvers lineares"
                                  ],
                                  "tips": "Para matrizes sparses grandes, use solvers otimizados como backslash em MATLAB para eficiência.",
                                  "learningObjective": "Compreender e aplicar métodos diretos para soluções exatas de sistemas lineares oriundos do método de Galerkin.",
                                  "commonMistakes": "Ignorar a simetria de K, levando a decomposições ineficientes; não tratar pivoteamento para estabilidade numérica."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar método iterativo para resolver Ku = F",
                                  "subSteps": [
                                    "Escolher iterativo adequado (ex: Gradiente Conjugado - CG, para K SPD).",
                                    "Definir parâmetros iniciais: u0 = 0, tolerância ε, máximo de iterações.",
                                    "Executar iterações: atualizar u_k, calcular residual r_k = F - K u_k.",
                                    "Monitorar normas de residual em cada iteração.",
                                    "Parar quando ||r_k|| < ε ou atingir máximo de iterações."
                                  ],
                                  "verification": "Comparar solução iterativa com a direta; verificar número de iterações necessárias.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código Python/MATLAB para CG",
                                    "Matriz K sparsa",
                                    "Gráficos de convergência (plot residual vs iteração)"
                                  ],
                                  "tips": "Pré-condicione K com diagonal ou ILU para acelerar convergência em problemas reais.",
                                  "learningObjective": "Dominar métodos iterativos e sua implementação para sistemas grandes em EF.",
                                  "commonMistakes": "Escolha inadequada de u0 levando a lentidão; não monitorar estagnação numérica."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar convergência dos métodos iterativos",
                                  "subSteps": [
                                    "Plotar curva de convergência: log(||r_k||) vs k.",
                                    "Calcular taxa de convergência aproximada: ρ = (log ε_final / log ε_inicial) / N_iter.",
                                    "Comparar com teoria: estimar cond(K) e bound de erro.",
                                    "Testar sensibilidade a pré-condicionadores.",
                                    "Documentar condições para convergência rápida."
                                  ],
                                  "verification": "Curva de residual decresce monotonicamente e converge em < 100 iterações para problema médio.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Ferramentas de plotagem (Matplotlib)",
                                    "Dados de iterações de Step 2"
                                  ],
                                  "tips": "Use malha refinada para observar impacto do condicionamento na convergência.",
                                  "learningObjective": "Interpretar e quantificar convergência, relacionando com propriedades espectrais de K.",
                                  "commonMistakes": "Confundir convergência linear com superlinear; ignorar efeito de rounding errors."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar precisão da solução de Galerkin",
                                  "subSteps": [
                                    "Calcular erros: norma ||u - u_exata|| (se disponível) ou ||r||.",
                                    "Comparar soluções direto vs iterativo.",
                                    "Discutir precisão de Galerkin: ordem de convergência com h (tamanho elemento).",
                                    "Analisar sensibilidade a malha e funções de forma.",
                                    "Concluir sobre adequação para o problema físico."
                                  ],
                                  "verification": "Erro relativo < 1% e discussão qualitativa da aproximação.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Solução analítica de referência (ex: viga em flexão)",
                                    "Relatório com métricas de erro"
                                  ],
                                  "tips": "Use norma energia ||u||_E = sqrt(u^T K u) para erros relevantes em EF.",
                                  "learningObjective": "Avaliar qualidade da aproximação de Galerkin e discutir limitações.",
                                  "commonMistakes": "Usar normas inadequadas (L2 vs energia); superestimar precisão sem referência."
                                }
                              ],
                              "practicalExample": "Em uma simulação de viga em cantilever sob carga distribuída, monte K (4x4 para 2 elementos lineares), resolva Ku=F com Cholesky (direto: u exata em 1 passo) e CG (iterativo: converge em 5 iterações). Avalie: residual 1e-12, erro energia 0.1%, convergência linear ρ=0.6.",
                              "finalVerifications": [
                                "Solução u satisfaz ||Ku - F|| < 1e-8.",
                                "Método iterativo converge em < 50 iterações.",
                                "Curva de convergência plotada e analisada.",
                                "Erro relativo comparado entre métodos < 1e-6.",
                                "Discussão sobre impacto do refinamento de malha na precisão.",
                                "Conclusões sobre escolha de solver para problemas reais."
                              ],
                              "assessmentCriteria": [
                                "Correta implementação e resolução com métodos direto e iterativo (30%).",
                                "Análise precisa de convergência com gráficos e métricas (25%).",
                                "Avaliação quantitativa/qualitativa de precisão de Galerkin (20%).",
                                "Uso apropriado de normas e verificações numéricas (15%).",
                                "Relatório claro com discussões teóricas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação de solvers em Python/MATLAB.",
                                "Análise Numérica: Teoria de erros e condicionamento.",
                                "Física/Mecânica: Interpretação de deslocamentos em estruturas.",
                                "Estatística: Análise de curvas de convergência e incertezas."
                              ],
                              "realWorldApplication": "Em softwares de EF como ANSYS ou Abaqus, resolve sistemas com milhões de DOFs para simular tensões em aviões, pontes ou implantes médicos, avaliando precisão para certificação de segurança."
                            },
                            "estimatedTime": "45 minutos",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.2.3.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.4",
                    "name": "Princípios Variacionais na Formulação de Elementos Finitos",
                    "description": "Aplicação dos métodos Rayleigh-Ritz e Galerkin à discretização local por elementos finitos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.4.1",
                        "name": "Princípios Variacionais",
                        "description": "Fundamentos dos princípios variacionais na mecânica dos sólidos, incluindo tensão, equilíbrio, deformações, equações constitutivas, energia potencial total e minimização variacional para formulação de problemas elásticos.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.1.1",
                            "name": "Identificar componentes da energia potencial total",
                            "description": "Reconhecer e descrever os termos de energia de deformação interna, energia de deformação externa e energia cinética na expressão da energia potencial total Π para sistemas elásticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a expressão geral da energia potencial total Π",
                                  "subSteps": [
                                    "Revise a definição de princípios variacionais em mecânica dos sólidos elásticos.",
                                    "Estude a forma funcional da energia potencial total Π como Π = U_int - U_ext + T, onde T representa o termo cinético.",
                                    "Identifique os componentes principais: energia interna de deformação (U_int), externa (U_ext) e cinética (T).",
                                    "Anote a expressão matemática integral para cada termo em notação tensorial ou escalar.",
                                    "Compare com formulações estáticas versus dinâmicas."
                                  ],
                                  "verification": "Escreva a expressão completa de Π e rotule cada termo corretamente em um papel ou software de anotações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro-texto de Elementos Finitos (ex: Zienkiewicz), caderno, calculadora simbólica como SymPy.",
                                  "tips": "Use diagramas de fluxo para visualizar como os termos se somam em Π.",
                                  "learningObjective": "Entender a estrutura matemática da energia potencial total em sistemas elásticos.",
                                  "commonMistakes": "Confundir sinais dos termos (U_ext é subtraído); ignorar o contexto dinâmico do termo cinético."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a energia de deformação interna (U_int)",
                                  "subSteps": [
                                    "Defina U_int como a energia armazenada devido à deformação elástica: U_int = (1/2) ∫_Ω σ : ε dV.",
                                    "Explique os tensores de tensão (σ) e deformação (ε) e sua relação constitutiva (lei de Hooke).",
                                    "Discuta domínios de integração (volume Ω do corpo elástico).",
                                    "Calcule um exemplo simples para uma barra unidimensional.",
                                    "Relacione com o teorema da energia de Castigliano."
                                  ],
                                  "verification": "Derive a expressão de U_int para um elemento finito 1D e verifique numericamente com valores conhecidos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software MATLAB ou Python (NumPy/SciPy), exemplos de problemas resolvidos de livros de EF.",
                                  "tips": "Sempre verifique a simetria da matriz de rigidez derivada de U_int.",
                                  "learningObjective": "Reconhecer U_int como o termo de armazenamento de energia elástica interna.",
                                  "commonMistakes": "Esquecer o fator 1/2; usar deformação linear em vez de Green-Lagrange para grandes deformações."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a energia de deformação externa (U_ext)",
                                  "subSteps": [
                                    "Defina U_ext como o trabalho das forças externas: U_ext = ∫_Γ t · u dS + ∫_Ω b · u dV.",
                                    "Diferencie cargas de superfície (t) de volumétricas (b) e deslocamentos (u).",
                                    "Discuta contornos de Dirichlet e Neumann nas fronteiras.",
                                    "Integre com funções de forma em aproximações de Rayleigh-Ritz.",
                                    "Compare com potenciais carregados em formulações variacionais."
                                  ],
                                  "verification": "Esboce um domínio com cargas aplicadas e escreva a integral de U_ext explicitamente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Diagrama de um elemento finito com cargas, papel milimetrado, referência ao método Galerkin.",
                                  "tips": "Lembre-se: U_ext é subtraída de U_int para minimizar Π.",
                                  "learningObjective": "Descrever U_ext como o trabalho virtual das cargas externas no sistema.",
                                  "commonMistakes": "Inverter o sinal na expressão de Π; confundir com energia cinética."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incorporar e descrever o termo de energia cinética",
                                  "subSteps": [
                                    "Defina o termo cinético T = (1/2) ∫_Ω ρ · ˙{u} · ˙{u} dV, onde ˙{u} é a velocidade.",
                                    "Explique sua inclusão em problemas dinâmicos via Rayleigh-Ritz temporal.",
                                    "Discuta a matriz de massa derivada de T em formulações de elementos finitos.",
                                    "Compare com formulações estáticas (T=0).",
                                    "Verifique dimensionalidade: energia (Joules)."
                                  ],
                                  "verification": "Escreva a expressão de T para uma placa vibrante e compute sua contribuição em Π.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Vídeos tutoriais sobre dinâmica em EF (YouTube/Khan Academy), código Python para integração numérica.",
                                  "tips": "Pense em T como análogo inercial à U_int elástica.",
                                  "learningObjective": "Identificar o papel do termo cinético na energia potencial total dinâmica.",
                                  "commonMistakes": "Confundir T com energia potencial; esquecer densidade ρ."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar a energia potencial total Π completa",
                                  "subSteps": [
                                    "Monte Π = U_int - U_ext + T e discuta o princípio da estacionsriedade (δΠ = 0).",
                                    "Aplique a aproximações discretas u ≈ ∑ N_i u_i em Rayleigh-Ritz.",
                                    "Derive as equações de equilíbrio do sistema.",
                                    "Teste com um exemplo numérico simples (mola-massa).",
                                    "Documente todas as componentes em um resumo."
                                  ],
                                  "verification": "Resolva um problema toy e confirme que os termos balanceiam corretamente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Software FEA como Abaqus Student ou FreeFEM, relatório template.",
                                  "tips": "Use variações δ para validar: δU_int = δU_ext - δT.",
                                  "learningObjective": "Descrever integralmente todos os componentes de Π para sistemas elásticos.",
                                  "commonMistakes": "Omitir termos cinéticos em contextos dinâmicos; erros de sinal na minimização."
                                }
                              ],
                              "practicalExample": "Considere uma viga cantilever elástica de comprimento L, seção A, módulo E, sob carga distribuída q(x) e vibração livre. Compute Π = (1/2) ∫ EI (w'')^2 dx - ∫ q w dx + (1/2) ∫ ρ A ˙{w}^2 dx, identificando U_int (flexão), U_ext (carga q) e T (inércia). Aproxime w com funções de Rayleigh-Ritz e resolva para modos naturais.",
                              "finalVerifications": [
                                "Pode escrever corretamente Π = U_int - U_ext + T com integrais explícitas?",
                                "Descreve verbalmente cada termo sem consultar notas?",
                                "Identifica corretamente os sinais e domínios de integração?",
                                "Aplica a um exemplo 1D sem erros dimensionais?",
                                "Explica a transição de estático para dinâmico via T?",
                                "Deriva a matriz de rigidez e massa de Π?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação dos três componentes principais (U_int, U_ext, T): 30%",
                                "Correção das expressões matemáticas e sinais: 25%",
                                "Profundidade na descrição física de cada termo: 20%",
                                "Capacidade de integração em um exemplo prático: 15%",
                                "Clareza na explicação de variações δΠ = 0: 10%"
                              ],
                              "crossCurricularConnections": [
                                "Física: Mecânica clássica e conservação de energia.",
                                "Matemática: Cálculo variacional e métodos integrais.",
                                "Computação: Programação numérica para FEA (Python/MATLAB).",
                                "Engenharia Civil: Análise dinâmica de estruturas sísmicas."
                              ],
                              "realWorldApplication": "Na análise de elementos finitos para projetos aeroespaciais, como asas de aviões, onde Π guia a simulação de vibrações e fadiga sob cargas dinâmicas, prevendo falhas em turbinas ou fuselagens."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.2",
                            "name": "Formular o funcional variacional",
                            "description": "Derivar o funcional variacional Π(u) para problemas de equilíbrio elástico em termos de deslocamentos u, incorporando condições de contorno essenciais e naturais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar as equações governantes e relações constitutivas do problema de equilíbrio elástico",
                                  "subSteps": [
                                    "Escrever a equação de equilíbrio: ∇·σ + b = 0 em Ω",
                                    "Definir a relação deformação-deslocamento: ε(u) = (∇u + (∇u)^T)/2",
                                    "Especificar a lei constitutiva linear: σ = C : ε(u), onde C é o tensor de elasticidade",
                                    "Identificar domínios e condições de contorno: Γ_u (essenciais) e Γ_t (naturais)",
                                    "Derivar brevemente a forma fraca multiplicando por v admissível e integrando por partes"
                                  ],
                                  "verification": "Verificar se todas as equações estão corretamente anotadas e a forma fraca ∫ σ:ε(v) dV = ∫ b·v dV + ∫ t·v dΓ_t é obtida",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Elasticidade ou Elementos Finitos (ex: Zienkiewicz), papel e caneta, calculadora simbólica opcional"
                                  ],
                                  "tips": "Use notação tensorial consistente para evitar erros de índices em 2D/3D",
                                  "learningObjective": "Compreender as bases matemáticas e físicas do problema elástico linear",
                                  "commonMistakes": [
                                    "Esquecer a simetria do tensor de deformação ε",
                                    "Confundir forças volumétricas b com trações superficiais t"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a energia de deformação interna U(u)",
                                  "subSteps": [
                                    "Integrar a densidade de energia: u_int = (1/2) ε(u) : C : ε(u)",
                                    "Escrever U(u) = ∫_Ω (1/2) ε(u) : C : ε(u) dV",
                                    "Verificar positividade definida: U(u) ≥ 0 e =0 só para u rígido",
                                    "Discutir dependência quadrática em u para linearidade",
                                    "Anotar que U depende apenas de ∇u, não de u diretamente"
                                  ],
                                  "verification": "Confirmar que a expressão de U(u) é bilinear e simétrica em variações",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de derivadas tensorial, software como Mathematica ou SymPy para simplificação"
                                  ],
                                  "tips": "Expanda em componentes para problemas 2D simples para validar",
                                  "learningObjective": "Formular o termo interno do funcional associado à rigidez material",
                                  "commonMistakes": [
                                    "Usar (1/2) incorretamente, levando a fator errado",
                                    "Esquecer integração sobre todo o domínio Ω"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar o potencial dos carregamentos externos W(u)",
                                  "subSteps": [
                                    "Escrever trabalho das forças volumétricas: ∫_Ω b · u dV",
                                    "Adicionar trabalho das trações prescritas: ∫_Γ_t t · u dΓ",
                                    "Definir W(u) = ∫_Ω b · u dV + ∫_Γ_t t · u dΓ",
                                    "Notar linearidade em u",
                                    "Verificar que variações δW correspondem a cargas virtuais"
                                  ],
                                  "verification": "Garantir que δW(v) = ∫ b·v + ∫ t·v, matching a forma fraca direita",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagrama do problema com domínio Ω e bordas destacadas",
                                    "Papel para esboços"
                                  ],
                                  "tips": "Desenhe o domínio para visualizar onde aplicar cada integral",
                                  "learningObjective": "Capturar todos os termos de carregamento no funcional",
                                  "commonMistakes": [
                                    "Incluir trações em Γ_u (essenciais, não entram em W)",
                                    "Esquecer forças de corpo b"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir o funcional variacional total Π(u) e incorporar condições de contorno",
                                  "subSteps": [
                                    "Definir Π(u) = U(u) - W(u) para u satisfazendo condições essenciais u = g em Γ_u",
                                    "Escrever explicitamente: Π(u) = ∫_Ω (1/2) ε(u):C:ε(u) dV - ∫_Ω b·u dV - ∫_Γ_t t·u dΓ",
                                    "Verificar que minimizador u* satisfaz δΠ(u*;v)=0 para v no espaço admissível",
                                    "Discutir condições naturais emergindo de δΠ=0 em Γ_t livres",
                                    "Testar em exemplo 1D para validação"
                                  ],
                                  "verification": "Derivar δΠ e confirmar recuperação da forma fraca do problema",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exemplo numérico simples resolvido analiticamente",
                                    "Lápis para derivação de variação"
                                  ],
                                  "tips": "Sempre imponha essenciais no espaço de trial functions antes de minimizar",
                                  "learningObjective": "Formular Π(u) completo e entender seu papel no método variacional",
                                  "commonMistakes": [
                                    "Incluir u em Γ_u no funcional (essenciais são impostas à priori)",
                                    "Sinal errado em W(u)"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar o funcional através de propriedades e estacionariedade",
                                  "subSteps": [
                                    "Verificar coercividade: existe α>0 tal que Π(u) ≥ α ||u||^2",
                                    "Computar primeira variação δΠ(u;v) = ∫ ε(v):C:ε(u) - ∫ b·v - ∫ t·v",
                                    "Confirmar segunda variação δ²Π >0 para convexidade",
                                    "Aplicar a um caso teste e minimizar analiticamente",
                                    "Discutir generalizações para não-lineares"
                                  ],
                                  "verification": "Resolver δΠ=0 e comparar com solução exata do problema forte",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software de simbólica (Mathematica/SymPy), exemplo resolvido"
                                  ],
                                  "tips": "Use testes de unidade com u constante ou linear para checar",
                                  "learningObjective": "Garantir que Π(u) é adequado para otimização numérica",
                                  "commonMistakes": [
                                    "Ignorar termos de contorno na variação",
                                    "Confundir essencial e natural"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma barra 1D de comprimento L, seção A, módulo E, fixada em x=0 (u(0)=0 essencial), carga distribuída b(x), tração T em x=L (natural). Então Π(u) = ∫_0^L (1/2) E A (u')² dx - ∫_0^L b A u dx - T u(L). Minimizar Π dá -E A u'' + b A =0 com u(L) livre exceto natural.",
                              "finalVerifications": [
                                "Π(u) é quadrático, coercivo e contínuo no espaço de Sobolev H¹_0(Γ_u)",
                                "Estacionariedade δΠ(u;v)=0 recupera a forma fraca bilinear a(u,v)=l(v)",
                                "Condições naturais σ·n = t emergem automaticamente em Γ_t",
                                "Energia total U - W é mínima na solução física",
                                "Teste numérico: para exemplo 1D, solução u(x) bate com integração direta",
                                "Generaliza para 2D/3D sem perda de estrutura"
                              ],
                              "assessmentCriteria": [
                                "Correção matemática completa de todos os termos (40%)",
                                "Incorporação precisa de condições essenciais e naturais (25%)",
                                "Validação via derivação de δΠ e recuperação da weak form (20%)",
                                "Clareza na notação tensorial e integração por partes (10%)",
                                "Exemplo prático resolvido corretamente (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e análise funcional (Espaços de Sobolev)",
                                "Física: Mecânica dos sólidos contínuos e princípio de energia mínima",
                                "Computação: Base para implementação em códigos de Elementos Finitos (ex: FEniCS)",
                                "Engenharia Civil: Formulação de modelos para análise estrutural"
                              ],
                              "realWorldApplication": "Essencial na simulação de estruturas como pontes, aviões e turbinas, onde métodos variacionais como Rayleigh-Ritz ou Galerkin formulam matrizes de rigidez em software de EF para prever deformações sob cargas reais, otimizando designs e evitando falhas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.4.1.3",
                            "name": "Aplicar o princípio da estacioneira",
                            "description": "Explicar e demonstrar que a solução exata minimiza o funcional variacional, com δΠ = 0 levando às equações de equilíbrio via cálculo variacional.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito do Princípio da Estacioneira",
                                  "subSteps": [
                                    "Estudar a definição de um funcional variacional Π[u] como uma integral que representa a energia total do sistema.",
                                    "Explicar que o princípio da estacioneira postula que a solução exata u* torna Π estacionária, ou seja, δΠ[u*] = 0 para variações arbitrárias δu.",
                                    "Diferenciar estacioneira de minimização, destacando que em problemas convexos coincide com mínimo.",
                                    "Revisar noções básicas de cálculo variacional, como a Gateaux ou Fréchet derivative.",
                                    "Analisar exemplos qualitativos de energia potencial em mecânica clássica."
                                  ],
                                  "verification": "Escrever um parágrafo resumindo o princípio e sua importância em suas próprias palavras.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'The Finite Element Method' de Zienkiewicz",
                                    "Notas de aula sobre princípios variacionais",
                                    "Vídeos introdutórios no YouTube sobre cálculo variacional"
                                  ],
                                  "tips": "Pense no funcional como uma 'altura' em um landscape; estacioneira é o ponto plano (mínimo ou máximo).",
                                  "learningObjective": "Dominar a interpretação física e matemática do princípio da estacioneira.",
                                  "commonMistakes": "Confundir δΠ = 0 com otimizações sem restrições ou ignorar condições de contorno."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular o Funcional Variacional para um Problema de Equilíbrio",
                                  "subSteps": [
                                    "Escolher um problema modelo simples, como uma barra em tração axial com carga distribuída f(x).",
                                    "Escrever o funcional Π[u] = (1/2) ∫ EA (du/dx)^2 dx - ∫ f u dx - boundary terms.",
                                    "Verificar que o funcional incorpora energia de deformação interna e trabalho externo.",
                                    "Discutir generalizações para problemas 2D/3D em elasticidade linear.",
                                    "Validar dimensionalmente os termos do funcional."
                                  ],
                                  "verification": "Derivar explicitamente Π[u] para a barra axial e confirmar sua forma canônica.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel e lápis para derivações",
                                    "Software simbólico como Mathematica ou SymPy",
                                    "Exemplos resolvidos de livros de EF"
                                  ],
                                  "tips": "Sempre inclua termos de contorno de Neumann para cargas aplicadas.",
                                  "learningObjective": "Construir funcionais variacionais corretos para problemas de equilíbrio estático.",
                                  "commonMistakes": "Esquecer o fator 1/2 na energia interna ou inverter sinais de trabalho externo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a Variação e Obter δΠ = 0",
                                  "subSteps": [
                                    "Introduzir uma variação admissível δu com δu=0 em contornos essenciais.",
                                    "Calcular a primeira variação δΠ = ∫ (∂L/∂u δu + ∂L/∂u' δu') dx + boundary terms, onde L é o lagrangiano.",
                                    "Integrar por partes para obter δΠ = ∫ δu (-d/dx(EA du/dx) + f) dx + boundary.",
                                    "Impor δΠ = 0 para toda δu, deduzindo a equação diferencial -d/dx(EA du/dx) + f = 0.",
                                    "Verificar condições de contorno naturais emergentes."
                                  ],
                                  "verification": "Realizar o cálculo completo de δΠ para o funcional da barra e mostrar que resulta na EDO de equilíbrio.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Calculadora simbólica ou software como MATLAB Symbolic Toolbox",
                                    "Folhas de derivação",
                                    "Referência: Hughes 'The Finite Element Method'"
                                  ],
                                  "tips": "Use a regra de Leibniz para integração por partes e anote cuidadosamente os limites.",
                                  "learningObjective": "Executar o cálculo variacional para obter condições de estacioneira.",
                                  "commonMistakes": "Erros em integração por partes ou não zerar δu em Dirichlet BCs."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar a Conexão com Equações de Equilíbrio em Elementos Finitos",
                                  "subSteps": [
                                    "Aproximar u ≈ ∑ ui φi (espaço de Rayleigh-Ritz).",
                                    "Substituir em Π e minimizar w.r.t. ui, obtendo K u = F.",
                                    "Mostrar que δΠ = 0 no espaço finito leva às equações discretas de equilíbrio.",
                                    "Comparar com método de Galerkin ponderado.",
                                    "Resolver numericamente o exemplo da barra com 2-3 elementos."
                                  ],
                                  "verification": "Implementar e resolver o sistema Ku=F para a barra, plotando a solução exata vs aproximada.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy ou MATLAB",
                                    "Código template para EF 1D",
                                    "Ferramenta de plotagem como Matplotlib"
                                  ],
                                  "tips": "Comece com malha grosseira para validar antes de refinar.",
                                  "learningObjective": "Aplicar o princípio em formulações numéricas de Elementos Finitos.",
                                  "commonMistakes": "Escolha inadequada de funções de forma ou rigidez singular por BCs mal impostas."
                                }
                              ],
                              "practicalExample": "Para uma barra de comprimento L=1m, EA=1, f(x)=1, u(0)=0, P(L)=0: Π[u] = 0.5 ∫_0^1 (u')^2 dx - ∫_0^1 x u dx. Variação leva a -u'' + x = 0, solução u(x) = (1/6)x^3 - (1/2)x^2 + C1 x + C2, aplicando BCs.",
                              "finalVerifications": [
                                "Derivação correta de δΠ = 0 resulta na EDO de equilíbrio exata.",
                                "Solução numérica via Rayleigh-Ritz converge para exata com refinamento de malha.",
                                "Condições de contorno naturais são recuperadas corretamente.",
                                "Energia Π é minimizada (ou estacionária) na solução.",
                                "Verificação de equilíbrio global: forças internas somam cargas externas.",
                                "Comparação quantitativa: erro L2 < 1% com 4 elementos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na formulação de Π e cálculo de δΠ (sem erros algébricos).",
                                "Correta interpretação física: ligação entre estacioneira e equilíbrio.",
                                "Implementação numérica funcional e convergente.",
                                "Explicação clara da minimização em contextos convexos.",
                                "Identificação de erros comuns e como evitá-los.",
                                "Uso adequado de aproximações em EF."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e métodos de aproximação funcional.",
                                "Física: Princípio dos trabalhos virtuais e energia potencial.",
                                "Computação: Programação numérica e álgebra linear esparsa.",
                                "Engenharia Civil: Análise de estruturas via EF."
                              ],
                              "realWorldApplication": "Na simulação de estruturas mecânicas via software como ANSYS ou Abaqus, o princípio da estacioneira fundamenta a formulação de elementos finitos para prever deformações e tensões em pontes, aviões e implantes médicos, otimizando designs e evitando falhas catastróficas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.2",
                        "name": "Método de Rayleigh-Ritz",
                        "description": "Método aproximado baseado na minimização da energia potencial total usando funções de aproximação admissíveis para discretização em elementos finitos.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.2.1",
                            "name": "Aproximar o campo de deslocamento",
                            "description": "Construir uma aproximação do deslocamento u ≈ ∑ φ_i q_i, onde φ_i são funções de interpolação e q_i parâmetros generalizados, garantindo satisfação de condições essenciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar as condições essenciais do problema",
                                  "subSteps": [
                                    "Analise o problema de contorno elástica, distinguindo condições essenciais (Dirichlet, ex: u=0 em apoios) de naturais (Neumann, ex: tração).",
                                    "Liste todas as condições essenciais no domínio e fronteira.",
                                    "Verifique se as condições são homogêneas ou não-homogêneas.",
                                    "Documente as condições em uma tabela ou diagrama esquemático.",
                                    "Confirme compatibilidade com o método de Rayleigh-Ritz."
                                  ],
                                  "verification": "Condições essenciais listadas corretamente e classificadas em uma tabela verificável.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, diagrama do problema, referência teórica (ex: livro de Elementos Finitos).",
                                  "tips": "Sempre priorize condições de deslocamento sobre trações no Rayleigh-Ritz.",
                                  "learningObjective": "Compreender a distinção entre condições essenciais e naturais no contexto variacional.",
                                  "commonMistakes": "Confundir condições essenciais com naturais, levando a funções de base inadequadas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar funções de interpolação φ_i adequadas",
                                  "subSteps": [
                                    "Escolha funções φ_i que satisfaçam automaticamente as condições essenciais (ex: polinômios sinais para vigas simply supported).",
                                    "Defina o número de funções baseado no grau de precisão desejado (ex: 2-4 para aproximação inicial).",
                                    "Verifique propriedades: completude, continuidade e linear independência.",
                                    "Normaliza as funções se necessário para simplificar cálculos.",
                                    "Teste ortogonalidade ou use funções conhecidas (ex: modais)."
                                  ],
                                  "verification": "Funções φ_i plotadas ou tabuladas, confirmando satisfação das condições essenciais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de plotagem (MATLAB/Python), papel quadriculado.",
                                  "tips": "Use funções que sejam zero nas fronteiras com u=0 para simplicidade.",
                                  "learningObjective": "Selecionar funções de base que garantam satisfação das condições essenciais.",
                                  "commonMistakes": "Escolher funções que não satisfazem condições essenciais, invalidando a aproximação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a aproximação do campo de deslocamento",
                                  "subSteps": [
                                    "Escreva a forma u ≈ ∑_{i=1}^N φ_i q_i, onde q_i são parâmetros generalizados.",
                                    "Expresse explicitamente para o problema específico (ex: u(x) = q1 φ1(x) + q2 φ2(x)).",
                                    "Inclua termos para condições não-homogêneas se aplicável (u = u_particular + u_homogênea).",
                                    "Derive a expressão matricial [u] = [Φ] {q}.",
                                    "Valide dimensionalmente e de unidades."
                                  ],
                                  "verification": "Equação da aproximação escrita e simbólica, com substituição numérica simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Caderno de equações, software simbólico (SymPy).",
                                  "tips": "Mantenha N baixo inicialmente para depuração.",
                                  "learningObjective": "Formular a expansão trial function no método de Rayleigh-Ritz.",
                                  "commonMistakes": "Esquecer termos para condições não-homogêneas ou usar funções inadequadas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar satisfação das condições essenciais",
                                  "subSteps": [
                                    "Substitua a aproximação nas condições essenciais e resolva para restrições em q_i.",
                                    "Confirme que u = valor imposto em todos os pontos essenciais.",
                                    "Calcule resíduos se houver violações e ajuste funções.",
                                    "Compare com solução exata em pontos conhecidos.",
                                    "Documente coeficientes resultantes."
                                  ],
                                  "verification": "Tabela de verificação mostrando u aproximado = u imposto em condições essenciais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora, software numérico (MATLAB).",
                                  "tips": "Use plotagem para visualização gráfica da satisfação.",
                                  "learningObjective": "Validar que a aproximação trial satisfaz rigorosamente as condições essenciais.",
                                  "commonMistakes": "Verificar apenas numericamente sem análise simbólica, ignorando violações exatas."
                                }
                              ],
                              "practicalExample": "Para uma viga em flexão simply supported (u(0)=u(L)=0, momento em extremidades livre), use φ1(x) = sin(πx/L), φ2(x) = sin(2πx/L). Então u(x) ≈ q1 sin(πx/L) + q2 sin(2πx/L), satisfazendo u(0)=u(L)=0 automaticamente.",
                              "finalVerifications": [
                                "Aproximação satisfaz todas as condições essenciais simbolicamente.",
                                "Funções φ_i são linearmente independentes e completas.",
                                "Expressão u_h é contínua e diferenciável conforme necessário.",
                                "Número de parâmetros q_i adequado ao problema.",
                                "Resíduos nas condições essenciais são zero.",
                                "Plot da u_h vs. solução referencial coincide nas fronteiras."
                              ],
                              "assessmentCriteria": [
                                "Correta identificação e satisfação de condições essenciais (30%).",
                                "Seleção apropriada de funções φ_i com propriedades verificadas (25%).",
                                "Formulação precisa da expansão u ≈ ∑ φ_i q_i (20%).",
                                "Verificações completas e documentadas (15%).",
                                "Clareza na apresentação e exemplo prático (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Espaços de funções e séries de Fourier/polímeros.",
                                "Computação: Implementação em código para FEA (MATLAB/Python).",
                                "Física: Princípios variacionais em mecânica dos sólidos.",
                                "Engenharia de Software: Desenvolvimento de solvers numéricos."
                              ],
                              "realWorldApplication": "Essa aproximação é a base para malhas de elementos finitos em softwares como ANSYS ou Abaqus, permitindo simular deformações em estruturas como pontes, aviões e implantes médicos sob cargas reais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.1.3"
                            ]
                          },
                          {
                            "id": "10.1.2.4.2.2",
                            "name": "Montar as matrizes de rigidez e carga",
                            "description": "Calcular a matriz de rigidez K = ∫ B^T D B dV e vetor de carga F = ∫ N^T f dV + ∫ N^T t dS a partir da forma discreta Π ≈ (1/2) q^T K q - q^T F.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir funções de forma, matrizes B e D",
                                  "subSteps": [
                                    "Escolha o tipo de elemento finito (ex: barra 1D, triângulo 2D) e defina as funções de interpolação N(ξ).",
                                    "Calcule a matriz de derivadas B = ∂N/∂x, considerando o mapeamento isoparamétrico.",
                                    "Defina a matriz constitutiva D baseada nas propriedades do material (ex: módulo de elasticidade E para 1D).",
                                    "Verifique as dimensões: B (dof x nós), D (dof x dof).",
                                    "Integre numericamente se necessário, usando pontos de Gauss."
                                  ],
                                  "verification": "Conferir se B tem dimensões corretas e D reflete propriedades materiais; teste com elemento conhecido.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Elementos Finitos (ex: Bathe ou Zienkiewicz)",
                                    "Folha de papel ou software como MATLAB/Python para prototipagem"
                                  ],
                                  "tips": "Use coordenadas naturais ξ para simplificar derivadas; normalize funções N para soma unitária.",
                                  "learningObjective": "Compreender a geometria e cinemática do elemento para derivar operadores diferenciais.",
                                  "commonMistakes": [
                                    "Esquecer transformação de coordenadas jacobiana J",
                                    "Confundir funções N com suas derivadas",
                                    "Ignorar simetria de D"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Montar a matriz de rigidez K",
                                  "subSteps": [
                                    "Escreva a integral K = ∫ B^T D B dV sobre o volume do elemento.",
                                    "Transforme para coordenadas isoparamétricas: dV = det(J) dξ.",
                                    "Aplique integração numérica com pontos de Gauss (2-3 pontos para precisão).",
                                    "Some contribuições de todos pontos de Gauss: K ≈ Σ w_i B_i^T D B_i det(J_i).",
                                    "Verifique simetria e positividade de K."
                                  ],
                                  "verification": "K deve ser simétrica e condicionar bem; compare com solução analítica para elemento simples.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Tabela de pontos/pesos de Gauss",
                                    "Calculadora ou script Python com NumPy/SciPy"
                                  ],
                                  "tips": "Comece com elemento 1D para validar; use fatoração para eficiência computacional.",
                                  "learningObjective": "Dominar o cálculo da energia de deformação discreta via Rayleigh-Ritz.",
                                  "commonMistakes": [
                                    "Erro no det(J)",
                                    "Pontos de Gauss insuficientes levando a imprecisão",
                                    "Não transpor corretamente B^T"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular vetor de carga volumétrico F_vol",
                                  "subSteps": [
                                    "Defina a carga volumétrica f(x) (ex: peso próprio ρg).",
                                    "Escreva F_vol = ∫ N^T f dV.",
                                    "Transforme para isoparamétricas: dV = det(J) dξ.",
                                    "Integre numericamente: F_vol ≈ Σ w_i N_i^T f_i det(J_i).",
                                    "Distribua carga nodal proporcionalmente às funções N."
                                  ],
                                  "verification": "Soma dos componentes de F_vol deve igualar carga total aplicada ∫ f dV.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Propriedades do material (densidade ρ)",
                                    "Software para integração (ex: SymPy para simbólico)"
                                  ],
                                  "tips": "Para cargas constantes, analítico possível; Gauss para variações.",
                                  "learningObjective": "Entender virtual work de cargas distribuídas em nós.",
                                  "commonMistakes": [
                                    "Inverter N e N^T",
                                    "Esquecer det(J) na integral",
                                    "Carga f com unidades erradas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular vetor de carga superficial F_surf e finalizar",
                                  "subSteps": [
                                    "Identifique faces do elemento sujeitas a tração t(s).",
                                    "Escreva F_surf = ∫ N^T t dS sobre a superfície.",
                                    "Use integração de linha/superfície com Gauss (1D ou 2D).",
                                    "Some F = F_vol + F_surf.",
                                    "Monte K e F para o elemento completo e verifique equilíbrio."
                                  ],
                                  "verification": "Equilíbrio nodal aproximado: q^T K q ≈ energia total; F consistente com cargas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Diagrama do elemento com faces",
                                    "Código FEM básico em Python"
                                  ],
                                  "tips": "Trações t são vetores; alinhe com dof locais.",
                                  "learningObjective": "Integrar todas contribuições de carga no potencial total Π.",
                                  "commonMistakes": [
                                    "Confundir dS com dV",
                                    "Orientação errada da normal na tração",
                                    "Não somar F_vol e F_surf"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um elemento de barra 1D com 2 nós, comprimento L=1m, E=210GPa, A=1cm², carga volumétrica f=ρg= -10000N/m³: N=[1-ξ, ξ], B=[-1/L, 1/L], K=(AE/L)[1,-1; -1,1], F_vol=(ρg AL/2)[-1; -1]. Adicione tração t=100N na ponta direita: F_surf=[0; 100*(L/2)].",
                              "finalVerifications": [
                                "Matriz K é simétrica e definida positiva (autovalores >0).",
                                "Soma de F equals carga total física aplicada.",
                                "Dimensões: K (ndof x ndof), F (ndof x 1).",
                                "Recuperação de deslocamentos u=Nq satisfaz equilíbrio aproximado.",
                                "Comparação com solução exata para caso simples (erro <5%).",
                                "Implementação numérica reproduz K/F idênticos."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática das integrais e transformações jacobianas.",
                                "Precisão da integração numérica (ordem de Gauss adequada).",
                                "Consistência de unidades (N/m para K, N para F).",
                                "Simetria e propriedades esperadas de K e F.",
                                "Capacidade de generalizar para elementos 2D/3D.",
                                "Clareza na derivação passo a passo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Integração numérica de Gauss e álgebra linear (autovalores).",
                                "Programação: Implementação em Python/MATLAB para automação FEM.",
                                "Física: Princípio dos trabalhos virtuais e equilíbrio estático.",
                                "Química dos Materiais: Seleção de D baseado em propriedades anisotrópicas."
                              ],
                              "realWorldApplication": "Essas matrizes são o coração dos solvers FEM em softwares como ANSYS, NASTRAN ou Abaqus, usadas para analisar tensões em pontes, fuselagens de aviões, implantes médicos e estruturas sísmicas, otimizando designs para segurança e eficiência."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.4.2.3",
                            "name": "Resolver o sistema discreto",
                            "description": "Resolver K q = F para obter os parâmetros q e, consequentemente, o campo aproximado de deslocamentos nos elementos finitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Verificar o Sistema Discreto Kq = F",
                                  "subSteps": [
                                    "Identifique a matriz de rigidez global K a partir das matrizes elementares assembladas.",
                                    "Confirme o vetor de forças nodais F, incluindo cargas distribuídas equivalentes.",
                                    "Aplique condições de contorno modificando K e F (ex: fixar graus de liberdade).",
                                    "Verifique propriedades de K: simetria, definida positiva e sparse.",
                                    "Particione o sistema se necessário para graus de liberdade conhecidos/desconhecidos."
                                  ],
                                  "verification": "Confirme que Kq = F é balanceado e condições de contorno aplicadas corretamente comparando com equação original.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Matriz K e F do passo anterior",
                                    "Software como MATLAB ou Python (NumPy)",
                                    "Papel e calculadora para casos pequenos"
                                  ],
                                  "tips": "Sempre normalize unidades de K (N/m) e F (N) para consistência.",
                                  "learningObjective": "Compreender a estrutura do sistema discreto e preparar para resolução numérica.",
                                  "commonMistakes": [
                                    "Esquecer condições de contorno levando a singularidade em K",
                                    "Inverter índices de nós na montagem de K",
                                    "Ignorar forças de reação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar Método de Resolução Adequado",
                                  "subSteps": [
                                    "Avalie tamanho de K: direto (Gauss, LU) para pequeno/médio; iterativo (CG, GMRES) para grande.",
                                    "Escolha solver baseado em propriedades: simétrico positivo-definido → Cholesky.",
                                    "Defina tolerância de convergência (ex: 1e-6) e máximo de iterações.",
                                    "Considere pré-condicionadores para métodos iterativos (ex: ILU).",
                                    "Teste solver em subproblema pequeno para validar."
                                  ],
                                  "verification": "Execute teste unitário: resolva K_test * q_test = F_test e verifique norma residual < 1e-8.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação de solvers (MATLAB mldivide, SciPy solve)",
                                    "Exemplos de código para diferentes métodos"
                                  ],
                                  "tips": "Para problemas reais, prefira bibliotecas otimizadas como Eigen ou PETSc.",
                                  "learningObjective": "Selecionar método eficiente baseado em características do problema.",
                                  "commonMistakes": [
                                    "Usar solver direto em matrizes muito grandes causando estouro de memória",
                                    "Não definir tolerância levando a não-convergência",
                                    "Ignorar condicionamento numérico de K"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver o Sistema e Obter Parâmetros q",
                                  "subSteps": [
                                    "Implemente ou chame o solver selecionado: q = K\\F.",
                                    "Monitore iterações/convergência e registre resíduos.",
                                    "Calcule forças de reação para graus de liberdade fixos.",
                                    "Valide solução: compute K*q - F e cheque norma.",
                                    "Salve q para pós-processamento."
                                  ],
                                  "verification": "Norma do resíduo ||Kq - F|| / ||F|| < tolerância especificada.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código de resolução (MATLAB: q = K\\F; Python: np.linalg.solve)",
                                    "Gráficos de convergência para iterativos"
                                  ],
                                  "tips": "Use escalonamento de equações se K mal-condicionado.",
                                  "learningObjective": "Executar resolução numérica precisa e validar resultados.",
                                  "commonMistakes": [
                                    "Arredondamento numérico em K ill-condicionada",
                                    "Não monitorar convergência em iterativos",
                                    "Confundir q com deslocamentos nodais diretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular e Interpretar Campo de Deslocamentos Aproximado",
                                  "subSteps": [
                                    "Use funções de interpolação (shape functions) para u(x) ≈ N(x) * q_elemento.",
                                    "Compute deslocamentos nos nós e pontos de Gauss.",
                                    "Visualize campo: plote u(x) ao longo do domínio.",
                                    "Compare com solução exata se disponível (erro L2).",
                                    "Gere relatório com q, u e métricas de erro."
                                  ],
                                  "verification": "Deslocamentos nos nós coincidem com componentes de q; erro relativo < 5% vs analítico.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Funções shape do elemento (ex: linear para barra)",
                                    "Software de plotagem (Matplotlib, ParaView)"
                                  ],
                                  "tips": "Para elementos 2D/3D, integre sobre o domínio para normas de erro.",
                                  "learningObjective": "Reconstruir campo físico aproximado a partir de parâmetros discretos.",
                                  "commonMistakes": [
                                    "Usar q global diretamente como u nodal sem mapeamento",
                                    "Ignorar continuidade entre elementos",
                                    "Plotar sem normalizar escalas"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma barra axial de comprimento L=1m, E=210GPa, A=1e-4m², fixada em x=0, carga F=1000N em x=L. Monte K = [k -k; -k k] com k=EA/L, resolva q = [0; δ], obtenha δ=F/k=4.76mm, campo u(x)= (F/k)*x.",
                              "finalVerifications": [
                                "Sistema resolvido satisfaz Kq ≈ F (resíduo <1e-6).",
                                "Deslocamentos nodais consistentes com condições de contorno.",
                                "Campo u(x) contínuo e suave dentro de cada elemento.",
                                "Erro vs solução exata < tolerância para problema teste.",
                                "Forças de reação balanceiam cargas aplicadas.",
                                "Solução converge monotonicamente com refinamento de malha."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: resíduo e erro L2 mínimos.",
                                "Eficiência: tempo de CPU e iterações razoáveis.",
                                "Validação completa: testes e verificações documentados.",
                                "Interpretação física: ligação clara entre q e u(x).",
                                "Robustez: funciona para diferentes tamanhos de K.",
                                "Código limpo e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: resolução de sistemas lineares simétricos.",
                                "Programação Numérica: implementação de solvers e análise de erros.",
                                "Física/Engenharia: princípios de equilíbrio e energia variacional.",
                                "Estatística: análise de condicionamento e sensibilidade.",
                                "Visualização de Dados: plotting de campos escalares."
                              ],
                              "realWorldApplication": "Em análises FEA de estruturas como pontes, aviões ou chassis automotivos, resolver Kq=F permite prever deslocamentos sob cargas reais, otimizando design para evitar falhas por deformação excessiva."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.3",
                        "name": "Método de Galerkin",
                        "description": "Formulação baseada na ortogonalidade dos resíduos em relação a funções de peso, equivalente ao Rayleigh-Ritz para problemas auto-adjuntos, aplicada à discretização local.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.3.1",
                            "name": "Formular a equação fraca",
                            "description": "Derivar a forma integral fraca ∫ δu · L(u) dV = 0, onde L é o operador diferencial, incorporando condições de contorno naturais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a equação diferencial forte e o operador L(u)",
                                  "subSteps": [
                                    "Identifique a equação diferencial forte do problema, como -∇²u = f em Ω com condições de contorno u = g em Γ_D e ∂u/∂n = h em Γ_N.",
                                    "Defina o operador diferencial L(u) = -∇²u - f, ou generalize para operadores elípticos como L(u) = ∇·(k∇u) + b·∇u + cu - f.",
                                    "Escreva explicitamente o domínio Ω, fronteira Γ = Γ_D ∪ Γ_N e condições essenciais (Dirichlet) vs. naturais (Neumann).",
                                    "Verifique simetria e propriedades do operador L para problemas auto-adjuntos.",
                                    "Anote a forma forte: L(u) = 0 em Ω."
                                  ],
                                  "verification": "Confirme que a equação forte está corretamente escrita com todos os termos e condições de contorno identificadas em um papel ou software de anotações.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Elementos Finitos (ex: Zienkiewicz), caderno de notas, software como Mathematica ou papel"
                                  ],
                                  "tips": "Comece com um problema simples como a equação de Poisson para fixar ideias antes de generalizar.",
                                  "learningObjective": "Compreender a forma forte do problema como base para a derivação da forma fraca.",
                                  "commonMistakes": [
                                    "Confundir condições essenciais com naturais",
                                    "Esquecer termos de fonte f ou coeficientes variáveis",
                                    "Não especificar o domínio Ω claramente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a função de teste δu e formular o produto fraco",
                                  "subSteps": [
                                    "Escolha δu ∈ H¹(Ω) com δu = 0 em Γ_D (espaço de funções de teste adequadas).",
                                    "Multiplique a equação forte L(u) = 0 por δu: δu · L(u) = 0 em Ω.",
                                    "Integre sobre o domínio: ∫_Ω δu · L(u) dV = 0.",
                                    "Expanda L(u) explicitamente, por exemplo, para Poisson: ∫_Ω δu (-∇²u - f) dV = 0.",
                                    "Reconheça que isso é a base da formulação de Galerkin."
                                  ],
                                  "verification": "Escreva a integral ∫_Ω δu L(u) dV = 0 corretamente, confirmando que δu satisfaz as condições essenciais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Caderno, calculadora simbólica (SymPy ou Mathematica)",
                                    "Referência: Notas de aula sobre métodos variacionais"
                                  ],
                                  "tips": "Use funções de teste arbitrárias mas lisas para manter a generalidade; evite funções específicas ainda.",
                                  "learningObjective": "Formular o produto fraco inicial como ponto de partida para a integração por partes.",
                                  "commonMistakes": [
                                    "Não impor δu=0 em Γ_D",
                                    "Esquecer o sinal negativo em operadores laplacianos",
                                    "Integrar prematuramente sem expansão"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar integração por partes para transferir derivadas",
                                  "subSteps": [
                                    "Aplique o teorema da divergência ou integração por partes termo a termo em δu L(u).",
                                    "Para o termo ∇²u: ∫ δu ∇²u dV = ∫ ∇·(δu ∇u) dV - ∫ ∇δu · ∇u dV = ∫_Γ δu (∂u/∂n) dΓ - ∫_Ω ∇δu · ∇u dV.",
                                    "Generalize para operadores de segunda ordem: transfira derivadas de u para δu, gerando termos bilineares a(δu, u) e lineares l(δu).",
                                    "Mantenha a forma simétrica para problemas auto-adjuntos: a(u,v) = ∫ ∇u · ∇v dV.",
                                    "Verifique que a forma é consistente com a forte para u exato."
                                  ],
                                  "verification": "Derive corretamente os termos após integração por partes, mostrando o termo de contorno emergente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel milimetrado para diagramas, software de álgebra simbólica",
                                    "Tabela de fórmulas de integração por partes"
                                  ],
                                  "tips": "Pratique com 1D primeiro (ex: d²u/dx²) para visualizar antes de 2D/3D.",
                                  "learningObjective": "Dominar a integração por partes para obter a forma bilinear simétrica.",
                                  "commonMistakes": [
                                    "Erros de sinal na integração por partes",
                                    "Confundir ∇u com ∇δu",
                                    "Ignorar termos de primeira ordem em operadores convectivos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incorporar condições de contorno e finalizar a equação fraca",
                                  "subSteps": [
                                    "Substitua o termo de contorno ∫_Γ δu (∂u/∂n) dΓ pelas condições naturais: = ∫_Γ_N δu h dΓ, já que δu=0 em Γ_D.",
                                    "Formule a equação fraca final: Encontrar u ∈ V_g tal que ∫_Ω ∇δu · ∇u dV = ∫_Ω δu f dV + ∫_Γ_N δu h dΓ para todo δu ∈ V_0.",
                                    "Generalize para L(u): Find u s.t. ∫_Ω δu L(u) dV = 0 incorpora naturalmente as condições de Neumann.",
                                    "Discuta estabilidade e coercividade da forma bilinear.",
                                    "Teste com u exato para verificar consistência."
                                  ],
                                  "verification": "Escreva a equação fraca completa na forma ∫ δu L(u) dV = 0 ou equivalente bilinear, com contornos corretos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Exemplos numéricos simples em Python/MATLAB",
                                    "Livro de Hughes 'The Finite Element Method'"
                                  ],
                                  "tips": "Sempre verifique dimensionalidade: volume em 3D, área em 2D.",
                                  "learningObjective": "Finalizar a formulação fraca incorporando contornos naturais automaticamente.",
                                  "commonMistakes": [
                                    "Impor condições essenciais na forma fraca incorretamente",
                                    "Esquecer termos de Neumann",
                                    "Não generalizar para operadores não-simétricos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a equação de Poisson -∇²u = π² sin(πx) sin(πy) em Ω=[0,1]², u=0 em Γ: Multiplique por δu, integre por partes → ∫ ∇δu · ∇u dΩ = ∫ π² sin(πx) sin(πy) δu dΩ, sem termos de contorno extras pois todas Dirichlet.",
                              "finalVerifications": [
                                "A equação fraca está na forma ∫_Ω δu L(u) dV = 0 ou a(δu,u) = l(δu).",
                                "Condições de Dirichlet são impostas no espaço de funções, Neumann emergem naturalmente.",
                                "Forma bilinear é simétrica e coerciva para problemas elípticos.",
                                "Consistência: u exato satisfaz a forma fraca.",
                                "Estabilidade: Inf-sup condition ou coercividade verificada.",
                                "Dimensionalmente consistente (dV para volume)."
                              ],
                              "assessmentCriteria": [
                                "Correta aplicação de integração por partes sem erros de sinal.",
                                "Identificação precisa de espaços de funções V_g e V_0.",
                                "Incorporação correta de condições de contorno naturais.",
                                "Generalização para operadores arbitrários L(u).",
                                "Verificação de propriedades (consistência, simetria).",
                                "Clareza na derivação passo a passo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e teoria de Sobolev.",
                                "Física: Princípio dos trabalhos virtuais em mecânica dos sólidos.",
                                "Programação: Implementação em códigos FEM como FEniCS ou deal.II.",
                                "Engenharia: Análise estrutural e CFD.",
                                "Estatística: Métodos de Monte Carlo para erros de aproximação."
                              ],
                              "realWorldApplication": "Essencial para software de simulação FEM como ANSYS ou Abaqus, usado em design de aviões, análise de tensões em pontes e simulações de fluxo em turbinas, permitindo soluções numéricas aproximadas eficientes para problemas de engenharia complexos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.1.3"
                            ]
                          },
                          {
                            "id": "10.1.2.4.3.2",
                            "name": "Discretizar com funções de Galerkin",
                            "description": "Usar as mesmas funções φ_i para aproximação e peso, levando a ∫ φ_i L(∑ φ_j q_j) dV = 0, resultando no mesmo sistema K q = F do Rayleigh-Ritz.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a formulação contínua e princípios do método de Galerkin",
                                  "subSteps": [
                                    "Estude a equação diferencial fraca geral: Encontre u tal que ∫ φ L(u) dV = 0 para todos os pesos φ no espaço de funções apropriado.",
                                    "Identifique o operador diferencial L e o domínio V.",
                                    "Revise o espaço de funções de teste e trial, notando que no Galerkin φ_i são as mesmas para ambos.",
                                    "Compare brevemente com métodos de colocation e momentos.",
                                    "Esboce um problema modelo simples, como -u'' = f em [0,1] com condições de contorno."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre Galerkin e outros métodos de peso, com exemplo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Elementos Finitos (ex: Zienkiewicz), notas de aula sobre métodos variacionais, software simbólico como SymPy"
                                  ],
                                  "tips": "Comece com problemas 1D para intuição visual; desenhe as funções φ_i.",
                                  "learningObjective": "Compreender a base teórica do método de Galerkin como método de pesos.",
                                  "commonMistakes": [
                                    "Confundir funções de teste com trial",
                                    "Ignorar condições de contorno essenciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e definir funções de base φ_i para aproximação",
                                  "subSteps": [
                                    "Escolha um conjunto finito de funções φ_i lineares independentes que satisfaçam condições de contorno essenciais.",
                                    "Aproxime a solução u_h = ∑ q_j φ_j.",
                                    "Verifique ortogonalidade ou propriedades das φ_i (ex: polinomiais lineares em elementos 1D).",
                                    "Defina nós e malha simples (ex: 2 elementos em [0,1]).",
                                    "Calcule explicitamente φ_1(x), φ_2(x), etc., para o domínio."
                                  ],
                                  "verification": "Liste as funções φ_i e plote-as para um malha com 3 nós.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel e lápis para esboços, MATLAB/Python para plotar funções base",
                                    "Tutoriais de FEM 1D"
                                  ],
                                  "tips": "Use funções hat (chapéu) para simplicidade em 1D; garanta partição unitária.",
                                  "learningObjective": "Dominar a escolha de funções de Galerkin idênticas para trial e teste.",
                                  "commonMistakes": [
                                    "Funções que não satisfazem BCs essenciais",
                                    "Número insuficiente de funções para precisão"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar as equações discretas: ∫ φ_i L(u_h) dV = 0",
                                  "subSteps": [
                                    "Substitua u_h = ∑ q_j φ_j na forma fraca: ∫ φ_i L(∑ q_j φ_j) dV = 0 para i=1 a n.",
                                    "Expanda para ∑ q_j ∫ φ_i L(φ_j) dV = ∫ φ_i f dV.",
                                    "Identifique K_ij = ∫ φ_i L(φ_j) dV e F_i = ∫ φ_i f dV.",
                                    "Integre por partes se necessário para operadores diferenciais de segunda ordem.",
                                    "Mostre que isso resulta no sistema K q = F."
                                  ],
                                  "verification": "Derive explicitamente K e F para um problema 1D com 2 elementos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Calculadora simbólica (Mathematica/SymPy), exemplos resolvidos de livros de FEM"
                                  ],
                                  "tips": "Mantenha simetria da matriz K em problemas auto-adjuntos.",
                                  "learningObjective": "Derivar o sistema algébrico do método de Galerkin.",
                                  "commonMistakes": [
                                    "Erro em integração por partes",
                                    "Confundir L(u) com forma bilinear"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com Rayleigh-Ritz e montar o sistema numérico",
                                  "subSteps": [
                                    "Revise Rayleigh-Ritz: minimizar funcional variacional levando a mesmo K q = F.",
                                    "Prove equivalência para problemas auto-adjuntos: forma fraca Galerkin coincide com variação da energia.",
                                    "Monte numericamente K e F para exemplo 1D e resolva q = K^{-1} F.",
                                    "Implemente em código simples e plote u_h vs solução exata.",
                                    "Analise convergência variando número de elementos."
                                  ],
                                  "verification": "Resolva sistema e compare erro L2 com solução analítica.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy, Jupyter Notebook",
                                    "Código template de FEM 1D"
                                  ],
                                  "tips": "Use solvers lineares eficientes; teste com f=1 para Poisson simples.",
                                  "learningObjective": "Reconhecer equivalência Galerkin-Rayleigh-Ritz e implementar discretização.",
                                  "commonMistakes": [
                                    "Matrriz K não simétrica devido a erros de integração",
                                    "Esquecimento de BCs de Neumann"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e estender para problemas mais complexos",
                                  "subSteps": [
                                    "Teste com problema não-linear ou de ordem superior.",
                                    "Discuta generalizações para 2D/3D e elementos finitos não-conformes.",
                                    "Analise estabilidade e precisão do método.",
                                    "Compare com software comercial (ex: ANSYS) para validação.",
                                    "Documente lições aprendidas em relatório curto."
                                  ],
                                  "verification": "Gere gráfico de convergência e erro < 1% para malha fina.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software FEM gratuito como FEniCS",
                                    "Artigos sobre equivalência Galerkin-Ritz"
                                  ],
                                  "tips": "Foco em problemas elípticos para equivalência clara.",
                                  "learningObjective": "Aplicar discretização Galerkin em contextos reais e validar.",
                                  "commonMistakes": [
                                    "Sobre-refinamento desnecessário",
                                    "Ignorar consistência do método"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva -u'' = π² sin(πx) em [0,1], u(0)=u(1)=0, usando 2 elementos lineares. Funções φ1(x)=(1-x), φ2(x)=x no primeiro elemento, etc. Derive K = [[2/3, -1/3], [-1/3, 2/3]] * π² (ajustado), F=[integrais], solução u_h ≈ sin(πx).",
                              "finalVerifications": [
                                "Derivação correta de ∫ φ_i L(∑ φ_j q_j) dV = 0 leva a K q = F.",
                                "Matriz K é simétrica positiva definida para problemas elípticos auto-adjuntos.",
                                "Solução numérica converge à exata com refinamento de malha.",
                                "Implementação em código reproduz resultados analíticos para caso teste.",
                                "Explicação clara da equivalência com Rayleigh-Ritz.",
                                "Identificação correta de funções de Galerkin vs. outros métodos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação das equações fracas (90% correto).",
                                "Correta montagem de K e F sem erros algébricos.",
                                "Implementação numérica funcional com erro <5%.",
                                "Compreensão conceitual da equivalência Ritz-Galerkin.",
                                "Análise de convergência documentada.",
                                "Uso apropriado de condições de contorno."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise funcional e espaços de Sobolev.",
                                "Programação: Implementação numérica com álgebra linear (NumPy).",
                                "Física: Modelagem de equações diferenciais em mecânica dos sólidos.",
                                "Computação Científica: Métodos numéricos e otimização.",
                                "Engenharia: Formulação de software FEM comercial."
                              ],
                              "realWorldApplication": "Em engenharia mecânica, discretização Galerkin é usada em códigos FEM como ANSYS para análise de tensões em estruturas complexas, como vigas ou placas, garantindo precisão em simulações de fadiga e vibrações onde princípios variacionais asseguram estabilidade."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.3.1",
                              "10.1.2.4.2.2"
                            ]
                          },
                          {
                            "id": "10.1.2.4.3.3",
                            "name": "Comparar com Rayleigh-Ritz",
                            "description": "Demonstrar a equivalência matemática entre os métodos para problemas elásticos lineares e discutir diferenças para problemas não auto-adjuntos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Princípios Fundamentais dos Métodos Rayleigh-Ritz e Galerkin",
                                  "subSteps": [
                                    "Estudar a formulação variacional do problema elástico linear usando o princípio dos trabalhos virtuais.",
                                    "Derivar a forma fraca (weak form) do problema de equilíbrio elástico usando integração por partes.",
                                    "Comparar a minimização da energia total no Rayleigh-Ritz com a forma residual zero no Galerkin.",
                                    "Identificar condições para auto-adjunção do operador diferencial (simetria da matriz de rigidez).",
                                    "Anotar diferenças conceituais: Rayleigh-Ritz como método de otimização vs. Galerkin como método de projeção."
                                  ],
                                  "verification": "Resumir em um diagrama comparativo os princípios de cada método e confirmar simetria para problemas elásticos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Livro de Elementos Finitos (ex: Zienkiewicz), papel e lápis, software simbólico como Mathematica ou SymPy.",
                                  "tips": "Use notação consistente para funções de teste e trial para evitar confusão.",
                                  "learningObjective": "Compreender as bases teóricas e identificar quando os métodos coincidem.",
                                  "commonMistakes": "Confundir funções de teste (Galerkin) com funções de aproximação (Rayleigh-Ritz); ignorar termos de contorno."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Demonstrar Equivalência Matemática em Problemas Elásticos Lineares Auto-Adjointos",
                                  "subSteps": [
                                    "Partir da equação diferencial -div(σ) = f e derivar a forma bilinear simétrica a(u,v) = ∫ σ(u):ε(v) dΩ.",
                                    "Aproximar u_h = Σ u_i φ_i e v_h = Σ v_j ψ_j, mostrando que para φ_i = ψ_j, o sistema Ku = F é o mesmo.",
                                    "Derivar matematicamente que min ∫ (1/2 ε(u):C:ε(u) - f·u) leva à mesma matriz K simétrica.",
                                    "Verificar numericamente com um elemento 1D simples (barra em tração).",
                                    "Provar teorema: Para operadores auto-adjuntos, Rayleigh-Ritz ≡ Galerkin."
                                  ],
                                  "verification": "Resolver um problema 1D manualmente e confirmar que as matrizes de rigidez coincidem exatamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": "MATLAB ou Python (NumPy/SciPy) para montagem de matrizes, exemplos de código de FEM básico.",
                                  "tips": "Escolha funções de forma lineares para simplicidade inicial antes de generalizar.",
                                  "learningObjective": "Provar rigorosamente a equivalência em casos simétricos.",
                                  "commonMistakes": "Esquecer integração por partes nos termos de contorno; assumir simetria sem verificar."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Diferenças em Problemas Não Auto-Adjuntos",
                                  "subSteps": [
                                    "Introduzir exemplo não auto-adjunto: equação de convecção-difusão -εΔu + b·∇u = f.",
                                    "Mostrar que no Rayleigh-Ritz, a matriz não é simétrica (a(u,v) ≠ a(v,u)), enquanto Galerkin projeta residual.",
                                    "Derivar sistema para Galerkin: ∫ (ε∇u·∇v + b·∇u v) = ∫ f v, vs. minimização não equivalente.",
                                    "Discutir instabilidades (oscilações) no Galerkin padrão e estabilizações (SUPG).",
                                    "Comparar soluções numéricas para ε pequeno, destacando discrepâncias."
                                  ],
                                  "verification": "Implementar e plotar soluções para ε=0.01, comparando perfis e normas de erro.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Código Python/MATLAB para convecção-difusão 1D, gráficos de soluções exatas vs. aproximadas.",
                                  "tips": "Comece com malha uniforme e refine para observar comportamentos.",
                                  "learningObjective": "Identificar e quantificar diferenças quando a simetria é quebrada.",
                                  "commonMistakes": "Usar funções de teste assimétricas sem justificativa; ignorar escalas de Peclet alto."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Comparação e Aplicar em Exemplo Prático",
                                  "subSteps": [
                                    "Criar tabela comparativa: equivalência, simetria, estabilidade, aplicações.",
                                    "Aplicar ambos métodos a uma viga em flexão (auto-adjunto) e confirmar resultados idênticos.",
                                    "Estender para problema com carga térmica (potencialmente não simétrico) e discutir implicações.",
                                    "Avaliar convergência de ambos métodos via refinamento de malha.",
                                    "Documentar lições aprendidas em relatório curto."
                                  ],
                                  "verification": "Gerar relatório com tabelas, gráficos e provas, revisado por pares.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Folio ou Jupyter Notebook para documentação, software FEM como FEniCS (opcional).",
                                  "tips": "Use cores para destacar similaridades/diferenças na tabela.",
                                  "learningObjective": "Integrar conhecimentos em uma comparação coesa e aplicável.",
                                  "commonMistakes": "Generalizar demais sem exemplos concretos; omitir análise numérica."
                                }
                              ],
                              "practicalExample": "Em uma barra axial elástica 1D de comprimento L=1, módulo E=1, seção A=1, carga f=1: ambos métodos com 2 elementos lineares dão K = [[2,-1],[-1,1]] e u = [0.25, 0.5], provando equivalência. Para convecção-difusão com b=1, ε=0.1, Galerkin oscila enquanto Rayleigh-Ritz minimiza energia mas diverge em precisão.",
                              "finalVerifications": [
                                "Derivação correta da equivalência para problemas auto-adjuntos.",
                                "Identificação precisa de não auto-adjunção em exemplos como convecção.",
                                "Soluções numéricas coincidentes para caso elástico linear.",
                                "Tabela comparativa completa com prós/contras.",
                                "Gráficos mostrando diferenças em casos assimétricos.",
                                "Relatório explicando implicações em FEM industrial."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações (90% correto).",
                                "Clareza na distinção de casos auto-adjuntos vs. não.",
                                "Qualidade de implementações numéricas e gráficos.",
                                "Profundidade da discussão de estabilidade e convergência.",
                                "Originalidade no exemplo prático escolhido.",
                                "Coerência do relatório final."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Funcional e Espaços de Sobolev.",
                                "Física: Mecânica dos Continuos e Princípios Variacionais.",
                                "Computação: Programação Numérica e Métodos de Elementos Finitos.",
                                "Engenharia Civil: Análise Estrutural Não Linear."
                              ],
                              "realWorldApplication": "Em softwares FEM como ANSYS ou Abaqus, Rayleigh-Ritz é usado para otimização em estruturas lineares (pontes, aviões), enquanto Galerkin estabilizado resolve fluxos multifísicos (turbulência, acoplamento termo-mecânico) em turbinas e reatores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.3.2"
                            ]
                          },
                          {
                            "id": "10.1.2.4.3.4",
                            "name": "Aplicar à discretização local",
                            "description": "Implementar a discretização local em um elemento finito, montando contribuições elementares ke e fe para assembleia global.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o domínio elementar e funções de interpolação",
                                  "subSteps": [
                                    "Identificar o tipo de elemento finito (ex.: barra 1D, triângulo 2D) e seus nós.",
                                    "Definir as funções de forma N_i(ξ) no espaço de referência.",
                                    "Calcular o Jacobiano da transformação para o espaço físico.",
                                    "Verificar a continuidade e completude das funções de interpolação.",
                                    "Documentar as coordenadas dos nós e o mapeamento geométrico."
                                  ],
                                  "verification": "Funções de forma somam 1 em qualquer ponto e são 1 no nó correspondente e 0 nos outros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de papel, calculadora, tabela de funções de forma padrão (ex.: Lagrangeanas).",
                                  "tips": "Comece com elementos lineares para simplicidade antes de quadráticos.",
                                  "learningObjective": "Compreender como as funções de interpolação aproximam o campo desconhecido localmente.",
                                  "commonMistakes": "Esquecer a transformação de coordenadas ou usar funções inadequadas para o problema."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a equação fraca pelo método de Galerkin no elemento",
                                  "subSteps": [
                                    "Escrever a forma integral da equação diferencial no domínio elementar.",
                                    "Escolher funções teste iguais às de interpolação (Galerkin).",
                                    "Integrar por partes para obter termos de rigidez e carga.",
                                    "Identificar os operadores diferenciais envolvidos (ex.: ∇ para Laplace).",
                                    "Expressar o resíduo aproximado e projetá-lo ortogonalmente."
                                  ],
                                  "verification": "A forma bilinear a(u,v) e linear l(v) estão corretamente derivadas e simétricas quando aplicável.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Elementos Finitos (ex.: Zienkiewicz), software simbólico como SymPy.",
                                  "tips": "Use integração por partes sistematicamente para evitar erros em derivadas.",
                                  "learningObjective": "Dominar a discretização variacional que justifica ke e fe.",
                                  "commonMistakes": "Confundir funções teste com interpolação ou ignorar condições de contorno naturais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Montar a matriz de rigidez elementar ke",
                                  "subSteps": [
                                    "Computar a matriz B de derivadas das funções de forma.",
                                    "Calcular ke = ∫ B^T K B det(J) dξ, onde K é a matriz constitutiva.",
                                    "Avaliar integrais numericamente se necessário (ex.: Gauss-Legendre).",
                                    "Verificar simetria e positiva definitude de ke.",
                                    "Armazenar ke em formato para assembleia (ex.: vetor de nós conectividade)."
                                  ],
                                  "verification": "ke é simétrica e seus autovalores são positivos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilha Excel ou MATLAB para integrais, pontos de Gauss tabelados.",
                                  "tips": "Para elementos lineares, integrais analíticas são viáveis; use 2-3 pontos de Gauss.",
                                  "learningObjective": "Implementar computacionalmente a contribuição de rigidez local.",
                                  "commonMistakes": "Erro no cálculo de derivadas em B ou no Jacobiano."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar o vetor de carga elementar fe",
                                  "subSteps": [
                                    "Identificar fontes de carga (volume, superfície, ponto).",
                                    "Computar fe = ∫ N^T f det(J) dξ para cargas volumétricas.",
                                    "Adicionar contribuições de contorno ∫ N^T t dS.",
                                    "Verificar unidades consistentes com ke.",
                                    "Combinar com ke para o sistema elementar completo."
                                  ],
                                  "verification": "fe tem dimensões compatíveis com ke * u_e.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Mesmos da montagem de ke, funções de carga definidas.",
                                  "tips": "Separe cargas consistentes de lumpadas para verificação.",
                                  "learningObjective": "Capturar todas as contribuições de forças no elemento.",
                                  "commonMistakes": "Esquecer det(J) nas integrais ou cargas de superfície."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Preparar contribuições para assembleia global",
                                  "subSteps": [
                                    "Mapear graus de liberdade locais para globais via conectividade.",
                                    "Verificar partilha de nós com elementos adjacentes.",
                                    "Simular assembleia parcial para checar soma de ke/fe.",
                                    "Documentar ke e fe para código ou software FEM.",
                                    "Testar com malha de um elemento só."
                                  ],
                                  "verification": "Sistema de um elemento resolve corretamente o problema exato conhecido.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código simples em Python/MATLAB para assembleia teste.",
                                  "tips": "Use índices locais-globais para evitar sobreposição errada.",
                                  "learningObjective": "Entender a interface local-global no FEM.",
                                  "commonMistakes": "Índices de conectividade incorretos levando a assembleia falha."
                                }
                              ],
                              "practicalExample": "Para um elemento de barra 1D com 2 nós, comprimento L=1, E=1, discretizando -u''=1 com u(0)=u(1)=0. Funções lineares N1=1-ξ, N2=ξ. ke = (E/L) [[1,-1],[-1,1]], fe = (1/6 L) [1,1]^T.",
                              "finalVerifications": [
                                "ke é simétrica positiva definida e fe compatível dimensionalmente.",
                                "Solução de um elemento coincide com analítica para problema teste.",
                                "Assembleia em malha múltipla converge monotonicamente.",
                                "Mudança de malha refina solução corretamente.",
                                "Verificação de energia: a(u,u) = l(u).",
                                "Checagem de equilíbrio nodal elementar."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da forma fraca (sem erros de integração por partes).",
                                "Correção numérica de ke e fe (erro <1% vs. analítico).",
                                "Simetria e propriedades esperadas de ke confirmadas.",
                                "Implementação em código roda sem erros e testa assembleia.",
                                "Documentação clara de passos e verificações.",
                                "Tempo de execução eficiente para elemento simples."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e métodos numéricos de integração.",
                                "Programação: Implementação matricial em Python/MATLAB com NumPy.",
                                "Física: Princípios de equilíbrio e constituição em mecânica.",
                                "Engenharia de Software: Modularidade para solvers FEM.",
                                "Estatística: Análise de convergência e erro a posteriori."
                              ],
                              "realWorldApplication": "Em análise estrutural de pontes ou aviões, onde ke e fe de cada elemento (viga, placa) são montados para prever deformações sob cargas reais, otimizando design e segurança."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.3.2",
                              "10.1.2.4.2.3"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.3",
                "name": "Problemas 1D",
                "description": "Coordenadas e funções de interpolação, montagem das matrizes globais, treliças planas e 3D, formulação de elementos de viga e pórticos 2D e 3D.",
                "totalSkills": 60,
                "atomicTopics": [
                  {
                    "id": "10.1.3.1",
                    "name": "Coordenadas e funções de interpolação em problemas 1D",
                    "description": "Definição de sistemas de coordenadas locais e globais e construção de funções de interpolação para elementos unidimensionais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.1.1",
                        "name": "Sistemas de coordenadas locais em elementos finitos 1D",
                        "description": "Definição e características do sistema de coordenadas local para elementos unidimensionais, tipicamente variando de -1 a 1 ou 0 a 1, utilizado para definir a geometria e o comportamento local do elemento.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.1.1",
                            "name": "Definir o domínio de coordenadas locais para elementos lineares 1D",
                            "description": "Explicar o intervalo padrão ξ ∈ [-1, 1] para elementos de dois nós e como ele simplifica a formulação das funções de interpolação e integração numérica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos básicos de elementos lineares 1D",
                                  "subSteps": [
                                    "Estudar a definição de um elemento finito linear 1D com dois nós.",
                                    "Identificar as coordenadas globais x dos nós (ex: x₁ = 0, x₂ = L).",
                                    "Explicar a necessidade de um sistema de coordenadas locais para padronização.",
                                    "Desenhar um diagrama esquemático do elemento no espaço global e local.",
                                    "Discutir vantagens da abstração para elementos de diferentes comprimentos."
                                  ],
                                  "verification": "Desenhar corretamente o elemento com nós marcados em x e ξ, identificando o mapeamento.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro-texto de Elementos Finitos (capítulo 1D)",
                                    "Software de desenho como GeoGebra (opcional)"
                                  ],
                                  "tips": "Sempre relacione o local ao global para evitar confusão dimensional.",
                                  "learningObjective": "Entender a estrutura de um elemento linear 1D e a motivação para coordenadas locais.",
                                  "commonMistakes": "Confundir coordenadas globais (x com unidades) com locais (ξ adimensional); assumir nós sempre em 0 e 1."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o domínio padrão ξ ∈ [-1, 1] para elementos de dois nós",
                                  "subSteps": [
                                    "Explicar que ξ varia de -1 (nó 1) a +1 (nó 2) por convenção.",
                                    "Derivar a transformação afim: ξ = -1 + 2(x - x₁)/(x₂ - x₁).",
                                    "Verificar o mapeamento para nós: ξ(x₁) = -1, ξ(x₂) = +1.",
                                    "Calcular exemplos numéricos para elementos de comprimentos variados (L=1, L=10).",
                                    "Discutir propriedades: simetria e independência do tamanho físico."
                                  ],
                                  "verification": "Calcular ξ para pontos intermediários e confirmar valores nos nós (±1).",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Planilha Excel ou Python para cálculos",
                                    "Diagrama impresso de elemento"
                                  ],
                                  "tips": "Use a fórmula invertida x = x₁(1-ξ)/2 + x₂(1+ξ)/2 para checagem rápida.",
                                  "learningObjective": "Dominar a definição e cálculo do domínio local ξ ∈ [-1, 1].",
                                  "commonMistakes": "Usar [0,1] em vez de [-1,1]; inverter os sinais nos nós."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o domínio padrão nas funções de interpolação",
                                  "subSteps": [
                                    "Derivar funções de forma: N₁(ξ) = (1 - ξ)/2, N₂(ξ) = (1 + ξ)/2.",
                                    "Verificar propriedades: N₁(-1)=1, N₁(1)=0; soma N₁ + N₂ = 1.",
                                    "Interpolação de campo: u(ξ) = N₁ u₁ + N₂ u₂.",
                                    "Mapear uma função global u(x) para local e vice-versa.",
                                    "Testar com exemplo linear: u(x) = a + b x."
                                  ],
                                  "verification": "Escrever N₁ e N₂ corretamente e interpolar um campo dado com erro zero em nós.",
                                  "estimatedTime": "30-35 minutos",
                                  "materials": [
                                    "Folha de exercícios",
                                    "Software MATLAB/Python para plotar N(ξ)",
                                    "Gráficos de funções de forma"
                                  ],
                                  "tips": "Plote N₁ e N₂ vs ξ para visualizar a partição de unidade.",
                                  "learningObjective": "Construir e verificar funções de interpolação no domínio local.",
                                  "commonMistakes": "Esquecer a normalização (soma=1); derivar funções em x em vez de ξ."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Utilizar o domínio para integração numérica simplificada",
                                  "subSteps": [
                                    "Explicar o Jacobiano J = dx/dξ = (x₂ - x₁)/2 = L/2.",
                                    "Formulação da integral: ∫ f(x) dx = ∫ f(ξ) J dξ de -1 a 1.",
                                    "Aplicar regra de Gauss com pontos em ±1/√3 para quadratura exata em lineares.",
                                    "Calcular exemplo: rigidez de barra ∫ B^T E B dx.",
                                    "Comparar com integração em domínio global para evidenciar simplificação."
                                  ],
                                  "verification": "Computar uma integral numérica no domínio local e comparar com analítica.",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "Tabela de Gauss-Legendre",
                                    "Código Python para integração",
                                    "Exercícios resolvidos"
                                  ],
                                  "tips": "Lembre-se: J é constante para lineares, facilitando computação matricial.",
                                  "learningObjective": "Aplicar integração no domínio padrão com Jacobiano.",
                                  "commonMistakes": "Esquecer o Jacobiano J; usar limites [0,L] na integral local."
                                }
                              ],
                              "practicalExample": "Considere uma barra de aço com L=2 m, nós em x=0 e x=2. Mapeie para ξ ∈ [-1,1]: ξ=0 no meio (x=1). Funções de forma: N₁(0)=0.5, N₂(0)=0.5. Para deslocamentos u₁=0, u₂=δ, u(ξ)= δ(1+ξ)/2. Integração de rigidez: k = (AE/L) ∫_{-1}^1 [(1+ξ)/2]'^2 (L/2) dξ, resolvida via Gauss.",
                              "finalVerifications": [
                                "Mapear corretamente um elemento arbitrário para ξ ∈ [-1,1].",
                                "Escrever e verificar funções de forma N₁(ξ) e N₂(ξ).",
                                "Calcular Jacobiano J e uma interpolação u(ξ).",
                                "Realizar integração numérica Gauss no domínio local.",
                                "Explicar verbalmente as simplificações introduzidas."
                              ],
                              "assessmentCriteria": [
                                "Precisão no mapeamento ξ(x) e x(ξ) (100% nos nós).",
                                "Correção das funções de interpolação (soma=1, valores nos nós).",
                                "Cálculo exato do Jacobiano e integral com erro <1%.",
                                "Identificação de pelo menos 3 simplificações (padronização, simetria, quadratura).",
                                "Clareza na explicação oral ou escrita do conceito.",
                                "Aplicação correta em exemplo prático sem erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Polinômios de Lagrange e transformações afins.",
                                "Programação: Implementação de mapeamentos em códigos FEM (Python/Fortran).",
                                "Física: Modelagem de deformações em barras e molas.",
                                "Geometria Computacional: Mapeamentos paramétricos em malhas."
                              ],
                              "realWorldApplication": "Em simulações de estruturas mecânicas via software FEM (ANSYS, Abaqus), o domínio [-1,1] permite bibliotecas reutilizáveis de funções de forma e quadratura, acelerando análises de tensões em vigas, cabos e tubos em engenharia civil e aeroespacial."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.2",
                            "name": "Mapear coordenadas locais para a geometria do elemento",
                            "description": "Demonstrar o mapeamento isoparamétrico de ξ para as posições nodais x_i em um elemento 1D arbitrário, incluindo cálculo do Jacobiano para transformação de derivadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender coordenadas isoparamétricas e nodais em elementos 1D",
                                  "subSteps": [
                                    "Revise as coordenadas globais x (posição física no elemento) e locais ξ (domínio padrão, tipicamente [-1,1]).",
                                    "Identifique os nós do elemento (ex: 2 nós para linear, 3 para quadrático) e suas posições nodais x_i.",
                                    "Estude funções de interpolação N_i(ξ) que somam a 1 (propriedade de partição da unidade).",
                                    "Desenhe um diagrama de um elemento 1D mostrando ξ e x correspondentes.",
                                    "Compare elementos uniformes vs. arbitrários (distâncias nodais irregulares)."
                                  ],
                                  "verification": "Desenhe e rotule corretamente um diagrama de mapeamento ξ → x para um elemento linear com 2 nós.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Elementos Finitos (capítulo 1D)",
                                    "Slides ou vídeo introdutório sobre EF 1D"
                                  ],
                                  "tips": "Sempre normalize ξ para [-1,1] para simplicidade numérica e evitar singularidades.",
                                  "learningObjective": "Compreender a distinção e relação entre coordenadas locais e globais em elementos finitos 1D.",
                                  "commonMistakes": "Confundir ξ com x diretamente; esquecer que ξ é adimensional."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o mapeamento isoparamétrico x(ξ)",
                                  "subSteps": [
                                    "Escreva a fórmula geral: x(ξ) = Σ N_i(ξ) * x_i para i=1 a n_nós.",
                                    "Para elemento linear (2 nós): defina N1(ξ) = (1-ξ)/2, N2(ξ) = (1+ξ)/2.",
                                    "Calcule x(ξ) explicitamente para ξ = -1, 0, 1 e verifique mapeamento nos nós.",
                                    "Teste para elemento quadrático (3 nós): N1=(ξ(ξ-1))/2, N2=1-ξ², N3=(ξ(ξ+1))/2.",
                                    "Implemente em uma planilha ou código simples para plotar x vs ξ."
                                  ],
                                  "verification": "Compute x(ξ) para ξ=0 em um elemento linear com x1=0, x2=2; resultado deve ser x=1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou Excel/MATLAB",
                                    "Tabela de funções de forma 1D"
                                  ],
                                  "tips": "Verifique sempre Σ N_i(ξ) = 1 para qualquer ξ no domínio.",
                                  "learningObjective": "Derivar e aplicar o mapeamento isoparamétrico para elementos 1D lineares e quadráticos.",
                                  "commonMistakes": "Usar funções de forma erradas (ex: Lagrange vs. Hermite); não avaliar nos nós (deve dar x_i)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Jacobiano J(ξ) = dx/dξ",
                                  "subSteps": [
                                    "Derive analiticamente J(ξ) = Σ (dN_i/dξ) * x_i.",
                                    "Para linear: J = (x2 - x1)/2 (constante).",
                                    "Para quadrático: J(ξ) = (ξ*(x3 - x1) + (x2 - x1/2 - x3/2) ou fórmula exata.",
                                    "Avalie J em pontos de Gauss e verifique positividade (J > 0 para mapeamento monotônico).",
                                    "Discuta degenerescência se nós forem coincidentes (J=0)."
                                  ],
                                  "verification": "Para x1=0, x2=3, calcule J; deve ser 1.5 constante para linear.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para derivadas",
                                    "Software simbólico como SymPy ou Mathematica"
                                  ],
                                  "tips": "Mantenha J positivo ordenando nós crescentemente em x.",
                                  "learningObjective": "Computar o Jacobiano e entender seu papel na transformação geométrica.",
                                  "commonMistakes": "Esquecer a derivada das shape functions; sinal errado em J para elementos invertidos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar transformação de derivadas usando o Jacobiano",
                                  "subSteps": [
                                    "Lembre a regra da cadeia: d/dx = (1/J) * d/dξ.",
                                    "Para uma função u(x), compute du/dx |_{x(ξ)} = (du/dξ / J) em ξ.",
                                    "Exemplo: para shape function N1 em linear, dN1/dx = [dN1/dξ] / J = [-1/2] / J.",
                                    "Integre em uma matriz de rigidez simples: B = dN/dx.",
                                    "Verifique consistência computando em nós e pontos internos."
                                  ],
                                  "verification": "Transforme dN2/dξ = 1/2 para dN2/dx em elemento linear; = (1/2)/J.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código MATLAB/Python para EF 1D básico",
                                    "Exemplos resolvidos de livros"
                                  ],
                                  "tips": "Use integração numérica em pontos de Gauss onde J é avaliado.",
                                  "learningObjective": "Transformar derivadas locais para globais via Jacobiano para análise EF.",
                                  "commonMistakes": "Inverter a fórmula (usar J ao invés de 1/J); ignorar dependência de ξ em elementos não-lineares."
                                }
                              ],
                              "practicalExample": "Considere uma barra 1D com nós em x1=0m, x2=1.5m (elemento linear). Para ξ=0 (meio local), x=0.75m. J=(1.5-0)/2=0.75. Se u(ξ)=ξ, du/dξ=1, então du/dx=1/0.75 ≈1.333 no meio do elemento.",
                              "finalVerifications": [
                                "Pode derivar x(ξ) e J(ξ) para elementos linear e quadrático.",
                                "Calcula corretamente mapeamentos em pelo menos 3 pontos de ξ.",
                                "Transforma derivadas d/dξ → d/dx sem erros em exemplo numérico.",
                                "Identifica e corrige casos de J≤0.",
                                "Implementa mapeamento em código simples e plota x vs ξ.",
                                "Explica verbalmente o processo para um par.",
                                "Verifica propriedades como Σ N_i=1 e mapeamento nodal."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas fórmulas de shape functions e mapeamento (100% correto).",
                                "Cálculo correto de J e transformações de derivadas em exemplos.",
                                "Demonstração de compreensão conceitual via diagrama e explicação.",
                                "Identificação de erros comuns e soluções.",
                                "Aplicação prática em código ou planilha com resultados validados.",
                                "Criatividade em extensão para elementos não-uniformes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo diferencial (derivadas, regra da cadeia) e interpolação polinomial.",
                                "Programação: Implementação numérica em Python/MATLAB para automação.",
                                "Física: Modelagem de deformações em barras e vigas.",
                                "Álgebra Linear: Matrizes de transformação e integração numérica Gauss."
                              ],
                              "realWorldApplication": "Em simulações de Elementos Finitos para análise estrutural (ex: tensão em vigas irregulares de pontes ou aerofólios), onde mapeamentos isoparamétricos permitem mesh adaptativa e precisão em geometrias complexas sem rederivar shape functions."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.3",
                            "name": "Calcular o Jacobiano em coordenadas locais",
                            "description": "Derivar e computar o Jacobiano J = dx/dξ para elementos lineares e quadráticos, explicando sua importância na integração de Gauss e no cálculo de matrizes de rigidez.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar funções de interpolação em coordenadas locais para elementos 1D",
                                  "subSteps": [
                                    "Identifique as funções de forma N(ξ) para elemento linear (2 nós): N1 = (1 - ξ)/2, N2 = (1 + ξ)/2.",
                                    "Descreva as funções para elemento quadrático (3 nós): N1 = ξ(ξ - 1)/2, N2 = 1 - ξ², N3 = ξ(ξ + 1)/2.",
                                    "Mapeie as coordenadas locais ξ ∈ [-1, 1] para posições nodais x_i.",
                                    "Verifique a propriedade de partição da unidade: Σ N_i(ξ) = 1.",
                                    "Pratique plotando as funções N(ξ) manualmente ou com software."
                                  ],
                                  "verification": "Confirme que as funções interpolam corretamente os valores nodais (N_i(ξ_j) = δ_ij).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software de plotagem como MATLAB ou Python (Matplotlib)",
                                    "Referência: Livro de Elementos Finitos (ex: Zienkiewicz)"
                                  ],
                                  "tips": [
                                    "Comece com ξ = -1, 0, 1 para verificar valores nos nós.",
                                    "Use simetria para elementos quadráticos."
                                  ],
                                  "learningObjective": "Compreender as bases das funções de interpolação em coordenadas locais ξ.",
                                  "commonMistakes": [
                                    "Confundir ordem das funções N_i.",
                                    "Esquecer o intervalo ξ ∈ [-1, 1].",
                                    "Não verificar partição da unidade."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar o Jacobiano para elemento linear",
                                  "subSteps": [
                                    "Escreva a transformação isoparamétrica: x(ξ) = Σ N_i(ξ) x_i.",
                                    "Calcule a derivada dx/dξ = Σ (dN_i/dξ) x_i.",
                                    "Para elemento linear: dN1/dξ = -1/2, dN2/dξ = 1/2, logo J = (x2 - x1)/2.",
                                    "Verifique que J é constante para elementos lineares.",
                                    "Teste com exemplo numérico: x1=0, x2=2 → J=1."
                                  ],
                                  "verification": "Calcule J para um elemento de comprimento h e confirme J = h/2.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Folha de exercícios com posições nodais variadas"
                                  ],
                                  "tips": [
                                    "Lembre-se: J relaciona derivadas locais e globais.",
                                    "Sempre normalize ξ de -1 a 1."
                                  ],
                                  "learningObjective": "Derivar e computar o Jacobiano constante para elementos lineares.",
                                  "commonMistakes": [
                                    "Erro no sinal das derivadas dN/dξ.",
                                    "Confundir J com o comprimento total do elemento.",
                                    "Usar ξ fora do domínio."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar o Jacobiano para elemento quadrático",
                                  "subSteps": [
                                    "Escreva x(ξ) = N1(ξ)x1 + N2(ξ)x2 + N3(ξ)x3.",
                                    "Compute dN1/dξ = ξ - 0.5, dN2/dξ = -2ξ, dN3/dξ = ξ + 0.5.",
                                    "Forme J(ξ) = Σ (dN_i/dξ) x_i, que varia com ξ.",
                                    "Avalie J em pontos de Gauss (ξ = ±1/√3).",
                                    "Exemplo: Nós em x1=0, x2=1, x3=2; compute J(ξ)."
                                  ],
                                  "verification": "Plote J(ξ) e confirme variação linear para espaçamento uniforme.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software simbólico como SymPy (Python)",
                                    "Tabela de derivadas das funções de Lagrange"
                                  ],
                                  "tips": [
                                    "Use simplificação algébrica para J(ξ).",
                                    "Integre numericamente se necessário para verificação."
                                  ],
                                  "learningObjective": "Derivar e avaliar o Jacobiano variável para elementos quadráticos.",
                                  "commonMistakes": [
                                    "Derivadas incorretas das funções quadráticas.",
                                    "Avaliar J apenas em nós.",
                                    "Ignorar dependência em ξ."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o Jacobiano na integração de Gauss e matrizes de rigidez",
                                  "subSteps": [
                                    "Explique |J| no integrando: ∫ f(x) dx = ∫ f(ξ) |J| dξ.",
                                    "Monte integral de Gauss: Σ w_g f(ξ_g) |J(ξ_g)|.",
                                    "Para matriz de rigidez: K ∝ ∫ (dN/dx)^T (dN/dx) dx = ∫ (1/|J| dN/dξ)^T (1/|J| dN/dξ) |J| dξ.",
                                    "Compute exemplo simples de K para elemento linear.",
                                    "Discuta impacto de J distorcido (elemento irregular)."
                                  ],
                                  "verification": "Calcule integral exata vs. Gauss e compare erro.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código MATLAB/Python para integração numérica",
                                    "Tabela de pontos/pesos de Gauss (2-3 pontos)"
                                  ],
                                  "tips": [
                                    "Use |det(J)| para generalidade.",
                                    "Teste com h pequeno para convergência."
                                  ],
                                  "learningObjective": "Entender o papel do Jacobiano em integração numérica e formulação EF.",
                                  "commonMistakes": [
                                    "Esquecer |J| na transformação.",
                                    "Confundir d/dx = (1/J) d/dξ.",
                                    "Ignorar sinal de J."
                                  ]
                                }
                              ],
                              "practicalExample": "Para um elemento linear 1D com nós x1=0, x2=4 (h=4), J=(4-0)/2=2. Integre ∫_0^4 x dx usando Gauss 1-ponto em ξ=0: f(0)*|J|*2 = (2)*2*2=8, exato=8.",
                              "finalVerifications": [
                                "Derive J corretamente para linear e quadrático em novo exemplo.",
                                "Compute |J| em pontos de Gauss e monte integral simples.",
                                "Explique verbalmente o papel de J em dN/dx.",
                                "Identifique erro em J distorcido (>1 ou <1).",
                                "Implemente código básico para calcular J(ξ).",
                                "Compare K com/ sem J correto."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas derivadas dN/dξ (100% correto).",
                                "Correta formulação de J(ξ) para ambos elementos.",
                                "Aplicação correta em integração Gauss (erro <1%).",
                                "Explicação clara da importância física/matemática.",
                                "Tratamento de casos irregulares (J variável).",
                                "Eficiência computacional nos exemplos."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Diferencial: Derivadas em mudança de variáveis.",
                                "Programação Numérica: Implementação em Python/MATLAB para EF.",
                                "Álgebra Linear: Matrizes de rigidez e transformação.",
                                "Física Computacional: Simulações em mecânica dos sólidos.",
                                "Geometria Computacional: Mapeamentos isoparamétricos."
                              ],
                              "realWorldApplication": "Em simulações de Elementos Finitos para análise estrutural (ex: tensão em vigas), o Jacobiano garante precisão na integração de cargas/distribuições, essencial em software como ANSYS para projetos de aviões e pontes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.2",
                        "name": "Sistemas de coordenadas globais em problemas 1D",
                        "description": "Definição do sistema de coordenadas globais que abrange todo o domínio do problema, permitindo a montagem e conexão de múltiplos elementos finitos.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.2.1",
                            "name": "Descrever o domínio global em problemas de barra ou viga 1D",
                            "description": "Identificar o eixo x global de 0 a L, onde L é o comprimento total, e explicar como os nós globais conectam elementos adjacentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de domínio global em problemas 1D",
                                  "subSteps": [
                                    "Ler a definição de domínio global como o conjunto completo da estrutura de 0 a L, abrangendo todos os elementos.",
                                    "Diferenciar domínio global (todo o comprimento L) do domínio local (comprimento de um elemento individual).",
                                    "Estudar exemplos iniciais de barras ou vigas 1D em livros ou slides de Elementos Finitos.",
                                    "Anotar as características principais: continuidade ao longo do eixo x e independência de subdivisões locais.",
                                    "Discutir com um colega ou tutor as vantagens do domínio global para montagem da matriz de rigidez."
                                  ],
                                  "verification": "Explicar em 3 frases próprias a diferença entre domínio global e local, sem consultar materiais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Elementos Finitos (capítulo 1D)",
                                    "Slides da aula sobre coordenadas globais",
                                    "Caderno para anotações"
                                  ],
                                  "tips": "Use diagramas simples para visualizar a extensão total de 0 a L antes de pensar em elementos.",
                                  "learningObjective": "Entender o propósito do domínio global como referência unificada para todo o problema estrutural.",
                                  "commonMistakes": [
                                    "Confundir domínio global com o de um único elemento",
                                    "Ignorar que L é o comprimento total fixo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e definir o eixo x global",
                                  "subSteps": [
                                    "Definir o eixo x global iniciando em x=0 (nó inicial) até x=L (nó final).",
                                    "Esboçar o eixo em papel, marcando L como comprimento total da barra ou viga.",
                                    "Explicar que o eixo x é cartesiano unidimensional e orientado monotonicamente.",
                                    "Verificar unidades consistentes (ex: metros) para L e posições x.",
                                    "Praticar com valores numéricos: para L=5m, marque pontos intermediários."
                                  ],
                                  "verification": "Desenhar o eixo x de 0 a L e rotulá-lo corretamente em um diagrama simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel milimetrado ou software de desenho (ex: GeoGebra)",
                                    "Exemplos de problemas 1D"
                                  ],
                                  "tips": "Sempre comece do zero para evitar erros de deslocamento; use régua para precisão no esboço.",
                                  "learningObjective": "Dominar a identificação precisa do eixo x global como base para coordenadas unificadas.",
                                  "commonMistakes": [
                                    "Inverter a direção do eixo (x decrescente)",
                                    "Usar coordenadas locais como globais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar nós globais e conexões entre elementos adjacentes",
                                  "subSteps": [
                                    "Numerar nós globais sequencialmente: nó 1 em x=0, nó n em x=L.",
                                    "Descrever como nós compartilhados conectam elementos: deslocamentos e forças contínuos nos nós comuns.",
                                    "Ilustrar com 2 elementos: nó 2 conecta elemento 1 (0 a x2) e elemento 2 (x2 a L).",
                                    "Explicar implicações: montagem global da matriz K usa graus de liberdade nos nós globais.",
                                    "Simular continuidade: se u(x2-) = u(x2+), o nó garante compatibilidade."
                                  ],
                                  "verification": "Descrever verbalmente ou por escrito como um nó global conecta dois elementos adjacentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagrama de malha 1D impresso",
                                    "Software como MATLAB para visualizar nós"
                                  ],
                                  "tips": "Pense nos nós como 'pontos de solda' que unem elementos sem descontinuidade.",
                                  "learningObjective": "Compreender o papel dos nós globais na integração de elementos em um sistema único.",
                                  "commonMistakes": [
                                    "Numerar nós localmente em vez de globalmente",
                                    "Ignorar continuidade de deslocamentos nos nós"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar conceitos em uma representação completa",
                                  "subSteps": [
                                    "Montar um diagrama completo: eixo x=0 a L, nós marcados, elementos indicados.",
                                    "Escrever uma descrição formal: 'O domínio global é x ∈ [0,L], com nós i em xi conectando elementos'.",
                                    "Verificar consistência: soma de comprimentos locais = L.",
                                    "Discutir aplicações: como isso facilita solução de equações diferenciais via EF.",
                                    "Revisar e refinar a descrição com feedback."
                                  ],
                                  "verification": "Produzir um diagrama e descrição que cubram todos os aspectos do domínio global.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramentas de desenho digital (ex: Draw.io)",
                                    "Modelo resolvido de barra 1D"
                                  ],
                                  "tips": "Use cores diferentes para nós e elementos para clareza visual.",
                                  "learningObjective": "Sintetizar o domínio global, eixo x e nós em uma explicação coesa e acionável.",
                                  "commonMistakes": [
                                    "Esquecer de mencionar L como total",
                                    "Não enfatizar conexões nos nós"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma viga 1D de comprimento total L=10m, dividida em dois elementos de 5m cada. O domínio global é o eixo x de 0 a 10m. Nós globais: nó 1 em x=0m, nó 2 em x=5m (conecta elemento 1 [0-5m] ao elemento 2 [5-10m]), nó 3 em x=10m. Os deslocamentos u1, u2, u3 nos nós globais garantem continuidade: u(5m-) = u(5m+) = u2.",
                              "finalVerifications": [
                                "Identifica corretamente o eixo x global de 0 a L.",
                                "Numera e posiciona nós globais sequencialmente ao longo de L.",
                                "Explica como nós compartilhados conectam elementos adjacentes com continuidade.",
                                "Desenha um diagrama preciso representando o domínio global completo.",
                                "Relaciona o domínio global à montagem da matriz de rigidez global."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição do eixo x global (0 a L).",
                                "Clareza na descrição de nós e suas funções de conexão.",
                                "Uso correto de terminologia (domínio global, nós globais, elementos adjacentes).",
                                "Qualidade do diagrama ou ilustração (escala, rótulos).",
                                "Capacidade de diferenciar global vs. local.",
                                "Explicação de implicações para análise estrutural."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sistemas de coordenadas cartesianas e interpolação linear.",
                                "Física: Mecânica dos sólidos e equilíbrio em estruturas 1D.",
                                "Computação: Geração de malhas numéricas e indexação de nós em código.",
                                "Engenharia Civil: Modelagem de vigas em pontes e edifícios."
                              ],
                              "realWorldApplication": "Em projetos de engenharia civil, como análise de tensões em vigas de pontes suspensas, o domínio global permite simular o comportamento completo da estrutura sob cargas distribuídas, conectando múltiplos elementos finitos nos nós para prever deformações e falhas reais."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.2.2",
                            "name": "Realizar mapeamento local-global",
                            "description": "Executar a transformação de funções definidas em coordenadas locais para globais usando as posições nodais globais x_i, incluindo interpolação do campo u(x) = Σ N_i(ξ) u_i.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender coordenadas locais e globais em elementos finitos 1D",
                                  "subSteps": [
                                    "Defina o domínio local ξ ∈ [-1, 1] para elementos lineares padrão.",
                                    "Identifique as posições nodais globais x_i para os nós do elemento.",
                                    "Explique a relação biunívoca entre ξ e x no elemento.",
                                    "Desenhe um diagrama comparando os domínios local e global.",
                                    "Liste as vantagens do uso de coordenadas locais (simetria, integração Gauss)."
                                  ],
                                  "verification": "Crie um diagrama anotado mostrando ξ e x correspondentes, confirmando a biunivocidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis ou software de desenho (ex: Draw.io)",
                                    "Livro de Elementos Finitos (capítulo 1D)"
                                  ],
                                  "tips": [
                                    "Use sempre o intervalo padrão [-1,1] para evitar confusões em elementos lineares."
                                  ],
                                  "learningObjective": "Compreender a distinção e relação entre coordenadas locais (ξ) e globais (x).",
                                  "commonMistakes": [
                                    "Confundir nós locais com globais; inverter o sentido do mapeamento."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o mapeamento isoparamétrico x(ξ)",
                                  "subSteps": [
                                    "Escreva a forma geral do mapeamento: x(ξ) = Σ N_i(ξ) x_i, onde N_i são funções de forma locais.",
                                    "Para elemento linear (2 nós): derive x(ξ) = (1-ξ)/2 * x_1 + (1+ξ)/2 * x_2.",
                                    "Calcule a derivada dx/dξ para transformação de integrais.",
                                    "Verifique o mapeamento nos nós: x(-1) = x_1, x(1) = x_2.",
                                    "Teste com valores intermediários, ex: ξ=0 → x = (x_1 + x_2)/2."
                                  ],
                                  "verification": "Substitua valores de ξ e confirme que x(ξ) bate com posições nodais esperadas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Calculadora ou MATLAB/Python para verificação numérica",
                                    "Folha de fórmulas de EF 1D"
                                  ],
                                  "tips": [
                                    "Lembre-se: mapeamento é linear para elementos lineares, preservando retas."
                                  ],
                                  "learningObjective": "Derivar e validar a função de mapeamento x(ξ) usando funções de forma locais.",
                                  "commonMistakes": [
                                    "Esquecer a soma Σ ou usar funções de forma erradas; não verificar nos nós."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Transformar funções de interpolação para coordenadas globais",
                                  "subSteps": [
                                    "Expresse N_i(x) via inversa: N_i(x) = N_i(ξ(x)), onde ξ(x) é invertido de x(ξ).",
                                    "Para elemento linear, derive explicitamente N_1(x) = (x_2 - x)/(x_2 - x_1), N_2(x) = (x - x_1)/(x_2 - x_1).",
                                    "Verifique propriedades: Σ N_i(x) = 1, N_i(x_j) = δ_ij.",
                                    "Calcule gradientes se necessário: dN_i/dx = (dN_i/dξ) / (dx/dξ).",
                                    "Plote N_i(x) vs x para visualização."
                                  ],
                                  "verification": "Confirme que Σ N_i(x) = 1 para pontos arbitrários e N_i(x_j) = δ_ij.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": [
                                    "Software de plotagem (Matplotlib ou Excel)",
                                    "Exemplos numéricos de elementos 1D"
                                  ],
                                  "tips": [
                                    "Inverta o mapeamento resolvendo para ξ em termos de x quando possível."
                                  ],
                                  "learningObjective": "Obter funções de forma em coordenadas globais N_i(x) a partir das locais.",
                                  "commonMistakes": [
                                    "Não dividir pela Jacobiana dx/dξ ao transformar derivadas; perder normalização Σ N_i=1."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar interpolação do campo u(x) no domínio global",
                                  "subSteps": [
                                    "Escreva u(x) = Σ N_i(x) u_i, usando N_i(x) derivadas.",
                                    "Para um exemplo: defina u_1 e u_2, compute u em pontos x internos.",
                                    "Compare com u(ξ) = Σ N_i(ξ) u_i para validar consistência.",
                                    "Integre uma funcional simples em x usando transformação.",
                                    "Implemente em código simples para automação."
                                  ],
                                  "verification": "Compute u em 3 pontos e confirme igualdade via mapeamento local-global.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python ou MATLAB com script básico",
                                    "Dados de u_i de um problema de barra"
                                  ],
                                  "tips": [
                                    "Sempre valide continuidade nodal: u(x_i) = u_i."
                                  ],
                                  "learningObjective": "Interpolação correta do campo solução u(x) usando mapeamento.",
                                  "commonMistakes": [
                                    "Usar N_i(ξ) diretamente em x; inconsistência nos valores nodais."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um elemento linear com nós x_1=0, x_2=5 m, deslocamentos u_1=0, u_2=1 mm. O mapeamento é x(ξ)=(5/2)(1+ξ). As funções globais são N_1(x)=1-x/5, N_2(x)=x/5. Assim, u(x)= (1-x/5)*0 + (x/5)*1 = x/5 mm, linear como esperado.",
                              "finalVerifications": [
                                "Mapeamento x(ξ) é contínuo e biunívoco no elemento.",
                                "Funções N_i(x) satisfazem partição da unidade Σ N_i(x)=1.",
                                "Interpolação nodal: u(x_i)=u_i.",
                                "Derivadas transformadas corretamente via Jacobiana.",
                                "Campo u(x) coincide em pontos mapeados local-global.",
                                "Visualização/plots confirmam comportamento esperado."
                              ],
                              "assessmentCriteria": [
                                "Correção na derivação de x(ξ) e verificação nodal (30%).",
                                "Precisão nas funções N_i(x) e propriedades (25%).",
                                "Aplicação correta na interpolação u(x) (20%).",
                                "Tratamento de derivadas/Jacobiana (15%).",
                                "Exemplo numérico validado com código/diagrama (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Mudança de variáveis e funções compostas.",
                                "Programação: Implementação numérica em FEM codes (Python/Fortran).",
                                "Física: Representação de campos contínuos em mecânica dos sólidos.",
                                "Geometria Computacional: Mapeamentos paramétricos em CAD."
                              ],
                              "realWorldApplication": "Em análises FEM de barras ou vigas 1D (ex: software ANSYS/ABAQUS), o mapeamento local-global permite mesh adaptativa e integração eficiente de cargas/distribuições em estruturas reais como pontes ou chassis automotivos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.2.3",
                            "name": "Aplicar condições de contorno em coordenadas globais",
                            "description": "Explicar como impor deslocamentos ou forças prescritas nos graus de liberdade globais nos nós de contorno do domínio 1D.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o sistema de coordenadas globais em problemas 1D",
                                  "subSteps": [
                                    "Defina os nós da malha 1D e os graus de liberdade (GL) globais associados.",
                                    "Construa a matriz de conectividade dos elementos.",
                                    "Numere os GL globais sequencialmente ao longo do domínio.",
                                    "Esboce o vetor de deslocamentos globais {d} e o vetor de forças globais {F}.",
                                    "Identifique os GL internos versus de contorno."
                                  ],
                                  "verification": "Confirme que o diagrama da malha mostra nós numerados corretamente e GL globais listados sem duplicatas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel quadriculado, lápis, software de MEF como MATLAB ou Python com NumPy.",
                                  "tips": "Sempre comece numerando nós da esquerda para a direita para consistência.",
                                  "learningObjective": "Compreender a estrutura do sistema global em coordenadas globais para problemas 1D.",
                                  "commonMistakes": "Confundir GL locais com globais; numerar nós de forma inconsistente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e classificar nós de contorno",
                                  "subSteps": [
                                    "Determine os nós nas extremidades do domínio (ex: nó 1 e nó N).",
                                    "Classifique os tipos de condições de contorno: deslocamento prescrito (essencial/Dirichlet) ou força prescrita (natural/Neumann).",
                                    "Liste os GL de contorno afetados por cada condição.",
                                    "Marque esses GL no vetor {d} e {F} como conhecidos ou desconhecidos.",
                                    "Crie uma tabela resumindo nós, GL e condições."
                                  ],
                                  "verification": "Verifique se todos os nós de contorno estão listados com GL corretos e tipos de BC identificados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Planilha Excel ou tabela em papel para nós/GL/BC.",
                                  "tips": "Use cores diferentes para marcar BC essenciais vs. naturais.",
                                  "learningObjective": "Identificar precisamente os GL globais sujeitos a condições de contorno.",
                                  "commonMistakes": "Ignorar nós intermediários com BC; confundir tipos de BC."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar condições de deslocamento prescrito (Dirichlet)",
                                  "subSteps": [
                                    "Atribua valores conhecidos aos GL de contorno no vetor {d} (ex: d_1 = 0 para apoio fixo).",
                                    "Modifique as linhas/cols correspondentes na matriz de rigidez global [K] zerando-as, exceto diagonal = 1.",
                                    "Mova forças reativas para o vetor {F} nos GL conhecidos.",
                                    "Atualize o sistema [K_red]{d_red} = {F_red}.",
                                    "Implemente em código para automação."
                                  ],
                                  "verification": "Resolva um sistema pequeno e confirme que deslocamentos prescritos são mantidos exatamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código Python/MATLAB com função para aplicar BC Dirichlet.",
                                  "tips": "Use uma máscara booleana para GL livres vs. fixos para eficiência.",
                                  "learningObjective": "Impor corretamente BC essenciais alterando [K] e {d}/{F}.",
                                  "commonMistakes": "Esquecer de zerar linhas inteiras da [K]; não mover reações para {F}."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar condições de força prescrita (Neumann)",
                                  "subSteps": [
                                    "Atribua valores conhecidos aos GL de contorno no vetor {F} (ex: F_N = P para carga aplicada).",
                                    "Mantenha os GL correspondentes livres no vetor {d}.",
                                    "Integre as forças nos nós de contorno via assembly da malha.",
                                    "Resolva o sistema reduzido sem modificações adicionais em [K].",
                                    "Calcule reações nos apoios após solução."
                                  ],
                                  "verification": "Confirme equilíbrio global: soma de forças = 0, incluindo reações calculadas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Exemplo numérico resolvido manualmente e via software.",
                                  "tips": "Para forças distribuídas, use funções de forma para distribuir nodalmente.",
                                  "learningObjective": "Incorporar BC naturais diretamente no vetor de forças globais.",
                                  "commonMistakes": "Aplicar força como deslocamento; esquecer distribuição nodal."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e montar o sistema global completo",
                                  "subSteps": [
                                    "Monte [K_global] via assembly de elementos.",
                                    "Aplique todas BCs sequencialmente.",
                                    "Resolva [K]{d} = {F} ou versão reduzida.",
                                    "Calcule deslocamentos, forças e reações.",
                                    "Valide com equilíbrio e convergência."
                                  ],
                                  "verification": "Compare resultados com solução analítica para barra simples.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Solver linear (SciPy solve ou similar).",
                                  "tips": "Sempre plote deslocamentos para visualização intuitiva.",
                                  "learningObjective": "Integrar todas BCs em um sistema resolvível.",
                                  "commonMistakes": "Erro de indexação em GL durante assembly."
                                }
                              ],
                              "practicalExample": "Em uma barra axial 1D de comprimento L=1m, E=210GPa, A=1cm², fixa em x=0 (d1=0) e com força P=1000N em x=L (F_n=1000N). Aplique BCs em coordenadas globais com 3 elementos: imponha d1=0 modificando [K], adicione F3=1000N, resolva para deslocamentos e reações.",
                              "finalVerifications": [
                                "Deslocamentos prescritos são exatamente atendidos na solução.",
                                "Equilíbrio de forças globais é satisfeito (∑F=0).",
                                "Matriz [K] modificada é simétrica positiva definida para GL livres.",
                                "Reações calculadas batem com equilíbrio estático.",
                                "Resultados convergem com refinamento de malha.",
                                "Implementação em código reproduz solução manual."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e numeração de GL globais (90% correto).",
                                "Correta modificação de [K], {d} e {F} para BC Dirichlet (sem erros de indexação).",
                                "Integração adequada de forças nodais para BC Neumann.",
                                "Solução numérica válida com verificação de equilíbrio.",
                                "Explicação clara do processo em relatório ou código comentado.",
                                "Tempo de execução eficiente em implementação computacional."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (resolução de sistemas [K]{d}={F}).",
                                "Programação: Implementação de assembly e BCs em Python/MATLAB.",
                                "Física: Princípios de equilíbrio estático e leis de Hooke.",
                                "Computação Científica: Uso de solvers esparsos para MEF."
                              ],
                              "realWorldApplication": "Na análise de vigas em pontes ou cabos de suspensão, onde extremidades são fixas ou sujeitas a cargas conhecidas, garantindo precisão na previsão de deformações e segurança estrutural."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.3",
                        "name": "Funções de interpolação para elementos unidimensionais",
                        "description": "Construção das funções de forma (shape functions) N_i(ξ) para elementos lineares e quadráticos em 1D, garantindo unidade de partição e continuidade entre elementos.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.3.1",
                            "name": "Construir funções de interpolação lineares (elemento de 2 nós)",
                            "description": "Derivar N_1(ξ) = (1 - ξ)/2 e N_2(ξ) = (1 + ξ)/2, verificando propriedades como N_i(ξ_j) = δ_ij e Σ N_i = 1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o elemento linear de 2 nós e coordenada mestra ξ",
                                  "subSteps": [
                                    "Defina o elemento de 2 nós com nós em x = -1 e x = 1 no domínio físico.",
                                    "Introduza a coordenada mestra ξ variando de -1 a +1.",
                                    "Mapeie o domínio físico para o mestra: ξ = 2(x - x_mid)/L, onde L é o comprimento.",
                                    "Desenhe um diagrama ilustrando os nós ξ₁ = -1 e ξ₂ = +1.",
                                    "Explique por que usamos coordenada mestra para padronização."
                                  ],
                                  "verification": "Desenhe e label o diagrama do elemento com ξ corretamente mapeado.",
                                  "estimatedTime": "20 min",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software de desenho como GeoGebra ou papel milimetrado"
                                  ],
                                  "tips": "Sempre normalize o elemento para [-1,1] para simplicidade em derivações.",
                                  "learningObjective": "Compreender o mapeamento isoparamétrico básico para elementos 1D.",
                                  "commonMistakes": [
                                    "Confundir ξ com coordenada física x",
                                    "Esquecer que ξ vai de -1 a +1"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar as funções de interpolação de Lagrange N₁(ξ) e N₂(ξ)",
                                  "subSteps": [
                                    "Lembre a forma geral de Lagrange: N_i(ξ) = produto (ξ - ξ_j)/(ξ_i - ξ_j) para j≠i.",
                                    "Para i=1 (ξ₁=-1): N₁(ξ) = (ξ - ξ₂)/(ξ₁ - ξ₂) = (ξ - 1)/(-1 - 1) = (ξ - 1)/(-2) = (1 - ξ)/2.",
                                    "Para i=2 (ξ₂=1): N₂(ξ) = (ξ - ξ₁)/(ξ₂ - ξ₁) = (ξ +1)/(1 - (-1)) = (ξ +1)/2.",
                                    "Escreva as expressões finais: N₁(ξ) = (1 - ξ)/2, N₂(ξ) = (1 + ξ)/2.",
                                    "Simplifique algebricamente e verifique por substituição em pontos simples."
                                  ],
                                  "verification": "Escreva as fórmulas corretas e avalie N₁(0) = 0.5, N₂(0)=0.5.",
                                  "estimatedTime": "30 min",
                                  "materials": [
                                    "Caderno de cálculos",
                                    "Calculadora simbólica como Wolfram Alpha para verificação"
                                  ],
                                  "tips": "Use a propriedade de Lagrange: N_i(ξ_j) = δ_ij como guia na derivação.",
                                  "learningObjective": "Derivar funções shape lineares usando polinômios de Lagrange.",
                                  "commonMistakes": [
                                    "Erro de sinal no denominador",
                                    "Esquecer o fator 1/2"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar propriedade de Kronecker: N_i(ξ_j) = δ_ij",
                                  "subSteps": [
                                    "Calcule N₁(ξ₁) = N₁(-1) = (1 - (-1))/2 = 1, N₁(ξ₂)=N₁(1)=(1-1)/2=0.",
                                    "Calcule N₂(ξ₁)=N₂(-1)=(1 + (-1))/2=0, N₂(ξ₂)=N₂(1)=(1+1)/2=1.",
                                    "Construa a matriz de avaliação: [N₁(ξ₁), N₁(ξ₂); N₂(ξ₁), N₂(ξ₂)] = [[1,0]; [0,1]].",
                                    "Confirme que é identidade, significando interpolação exata nos nós.",
                                    "Discuta implicações: valores nodais são reproduzidos exatamente."
                                  ],
                                  "verification": "Mostre cálculos tabelados confirmando δ_ij para todos i,j.",
                                  "estimatedTime": "15 min",
                                  "materials": [
                                    "Planilha Excel ou tabela em papel"
                                  ],
                                  "tips": "Faça uma tabela 2x2 para visualização rápida.",
                                  "learningObjective": "Validar funções shape pela propriedade delta de Kronecker.",
                                  "commonMistakes": [
                                    "Cálculo aritmético errado em ξ=-1 ou +1",
                                    "Confundir índices i e j"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar partição da unidade: Σ N_i(ξ) = 1 para todo ξ",
                                  "subSteps": [
                                    "Some N₁(ξ) + N₂(ξ) = (1 - ξ)/2 + (1 + ξ)/2 = (1 - ξ + 1 + ξ)/2 = 2/2 = 1.",
                                    "Verifique analiticamente: a soma cancela termos ξ.",
                                    "Avalie numericamente em pontos: ξ=-1 (1+0=1), ξ=0 (0.5+0.5=1), ξ=1 (0+1=1).",
                                    "Plote as funções para visual: N₁ decrescente de 1 a 0, N₂ crescente de 0 a 1, soma=1.",
                                    "Explique: garante convexidade e interpolação afim preservada."
                                  ],
                                  "verification": "Derivação algébrica da soma=1 e gráfico confirmando.",
                                  "estimatedTime": "20 min",
                                  "materials": [
                                    "Software de plotagem como Desmos ou Matplotlib",
                                    "Gráfico em papel"
                                  ],
                                  "tips": "Plote em [-1,1] para ver a 'chapeuzinho' das funções shape.",
                                  "learningObjective": "Confirmar propriedade de partição da unidade para consistência.",
                                  "commonMistakes": [
                                    "Esquecer de simplificar a soma",
                                    "Pontos de avaliação fora de [-1,1]"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar funções em interpolação de campo escalar simples",
                                  "subSteps": [
                                    "Defina u(ξ) ≈ Σ u_i N_i(ξ), com u₁ e u₂ dados nos nós.",
                                    "Exemplo: u₁=0, u₂=1, então u(ξ) = 0*N₁ + 1*N₂ = (1+ξ)/2.",
                                    "Verifique: u(-1)=0, u(1)=1, u(0)=0.5 (média linear).",
                                    "Compare com solução exata u(x)=x para barra unitária.",
                                    "Discuta generalização para vetores de deslocamento em MEF."
                                  ],
                                  "verification": "Calcule u(ξ) para 3 pontos e confirme linearidade.",
                                  "estimatedTime": "25 min",
                                  "materials": [
                                    "Código Python simples para plotar u(ξ)",
                                    "Papel para cálculos manuais"
                                  ],
                                  "tips": "Teste com valores nodais arbitrários para prática.",
                                  "learningObjective": "Aplicar funções shape em aproximação de campos em MEF 1D.",
                                  "commonMistakes": [
                                    "Inverter índices nodais",
                                    "Esquecer mapeamento ξ para x"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma barra de comprimento L=2 com deslocamentos u₁=0 em x=0 e u₂=1 em x=2, mapeie para ξ∈[-1,1]. O deslocamento interpolado é u(ξ) = N₁(ξ)*0 + N₂(ξ)*1 = (1+ξ)/2. Em x=1 (ξ=0), u=0.5, representando deformação linear uniforme.",
                              "finalVerifications": [
                                "Fórmulas N₁(ξ)=(1-ξ)/2 e N₂(ξ)=(1+ξ)/2 derivadas corretamente.",
                                "Tabela de Kronecker confirmada: N_i(ξ_j)=δ_ij.",
                                "Soma N₁+N₂=1 provada analiticamente e graficamente.",
                                "Interpolação de exemplo numérico exata nos nós.",
                                "Gráfico das funções shape mostrando continuidade e partição.",
                                "Explicação verbal das propriedades em contexto MEF 1D."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica nas derivações (sem erros de sinal ou fator).",
                                "Compreensão conceitual das propriedades (explicação clara de δ_ij e soma=1).",
                                "Habilidade em visualizar/plota funções shape.",
                                "Aplicação correta em exemplo prático de interpolação.",
                                "Identificação de erros comuns e como evitá-los.",
                                "Generalização para elementos MEF maiores."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Polinômios de Lagrange e propriedades de bases.",
                                "Programação: Implementação em código para MEF (ex: FEniCS ou MATLAB).",
                                "Física: Aproximação de campos contínuos em mecânica dos sólidos.",
                                "Geometria Computacional: Mapeamentos isoparamétricos.",
                                "Estatística: Interpolação como regressão linear local."
                              ],
                              "realWorldApplication": "Essas funções são fundamentais no Método dos Elementos Finitos (MEF) para simular tensões em vigas, tubos ou cabos em engenharia mecânica, como no projeto de pontes ou análise de deformações em peças automotivas usando softwares como ANSYS ou Abaqus."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.3.2",
                            "name": "Derivar funções de interpolação quadráticas (elemento de 3 nós)",
                            "description": "Formular N_1(ξ) = (ξ(ξ-1))/2, N_2(ξ) = (1-ξ²), N_3(ξ) = (ξ(ξ+1))/2 para nós em ξ = -1, 0, 1, incluindo derivadas dN_i/dξ.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os princípios das funções de interpolação de Lagrange para elementos quadráticos",
                                  "subSteps": [
                                    "Revise a definição de funções de interpolação: devem ser 1 no nó próprio e 0 nos outros nós.",
                                    "Identifique os nós para o elemento de 3 nós: ξ₁ = -1, ξ₂ = 0, ξ₃ = 1.",
                                    "Entenda que para elemento quadrático, as funções são polinômios de grau 2: N_i(ξ) = a_i + b_i ξ + c_i ξ².",
                                    "Discuta a importância no Método dos Elementos Finitos (MEF) para aproximar campos como deslocamento.",
                                    "Esboce graficamente os nós em coordenadas naturais ξ."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito as propriedades unitárias e de partição da unidade das funções N_i.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Gráfico de ξ de -1 a 1"
                                  ],
                                  "tips": "Lembre-se: ∑ N_i(ξ) = 1 para todos ξ (propriedade de partição da unidade).",
                                  "learningObjective": "Entender as propriedades fundamentais das funções de forma em elementos finitos 1D.",
                                  "commonMistakes": [
                                    "Confundir nós lineares (2 nós) com quadráticos (3 nós)",
                                    "Esquecer a simetria em torno de ξ=0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a função de interpolação N₁(ξ) para o nó em ξ = -1",
                                  "subSteps": [
                                    "Estabeleça as condições: N₁(-1) = 1, N₁(0) = 0, N₁(1) = 0.",
                                    "Assuma forma quadrática: N₁(ξ) = a + b ξ + c ξ².",
                                    "Monte o sistema de equações: para ξ=-1: a - b + c = 1; ξ=0: a = 0; ξ=1: a + b + c = 0.",
                                    "Resolva o sistema: substitua a=0, então -b + c =1 e b + c =0 → b = -1/2, c = 1/2.",
                                    "Simplifique: N₁(ξ) = (1/2) ξ (ξ - 1)."
                                  ],
                                  "verification": "Substitua ξ=-1,0,1 e confirme N₁=1,0,0 respectivamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel para equações",
                                    "Calculadora para resolução de sistemas"
                                  ],
                                  "tips": "Use substituição sequencial para resolver o sistema 3x3.",
                                  "learningObjective": "Aplicar condições de interpolação para derivar N₁(ξ) corretamente.",
                                  "commonMistakes": [
                                    "Erro de sinal nas condições",
                                    "Fator 1/2 esquecido"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar as funções N₂(ξ) e N₃(ξ) para os nós em ξ = 0 e ξ = 1",
                                  "subSteps": [
                                    "Para N₂(ξ): condições N₂(-1)=0, N₂(0)=1, N₂(1)=0. Forma: a + b ξ + c ξ².",
                                    "Sistema: ξ=-1: a - b + c =0; ξ=0: a=1; ξ=1: a + b + c =0 → resolva para b=0, c=-1 → N₂(ξ)=1 - ξ².",
                                    "Para N₃(ξ): N₃(-1)=0, N₃(0)=0, N₃(1)=1. Sistema: a - b + c =0; a=0; a + b + c =1 → b=1/2, c=1/2 → N₃(ξ)=(1/2) ξ (ξ + 1).",
                                    "Verifique simetria: note que N₃(ξ) = N₁(-ξ).",
                                    "Esboce as curvas das três funções para visualização."
                                  ],
                                  "verification": "Confirme N₂(-1)=0, N₂(0)=1, N₂(1)=0 e similar para N₃.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software de plotagem como Desmos (opcional)"
                                  ],
                                  "tips": "Aproveite a simetria para acelerar a derivação de N₃.",
                                  "learningObjective": "Derivar funções simétricas e assimétricas usando condições nos nós.",
                                  "commonMistakes": [
                                    "Confundir coeficientes de N₂ e N₃",
                                    "Sinal errado em ξ(ξ+1)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular as derivadas dN_i/dξ e verificar consistência",
                                  "subSteps": [
                                    "Derive N₁: dN₁/dξ = (1/2)(2ξ - 1) = ξ - 1/2.",
                                    "Derive N₂: dN₂/dξ = -2ξ.",
                                    "Derive N₃: dN₃/dξ = (1/2)(2ξ + 1) = ξ + 1/2.",
                                    "Verifique partição da unidade nas derivadas: ∑ dN_i/dξ = 0 (propriedade para elementos finitos).",
                                    "Avalie derivadas nos nós: ex. dN₁/dξ(-1) = -3/2, etc."
                                  ],
                                  "verification": "Confirme ∑ N_i =1 e ∑ dN_i/dξ =0 em pontos arbitrários como ξ=0.5.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou papel"
                                  ],
                                  "tips": "Use regra da cadeia ou produto para derivação.",
                                  "learningObjective": "Computar derivadas analíticas para uso em matrizes de rigidez no MEF.",
                                  "commonMistakes": [
                                    "Esquecer fator 1/2 nas derivadas",
                                    "Não verificar soma zero das derivadas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e sintetizar as funções derivadas",
                                  "subSteps": [
                                    "Liste todas: N₁=(ξ(ξ-1))/2, N₂=1-ξ², N₃=(ξ(ξ+1))/2.",
                                    "Confirme partição: N₁+N₂+N₃=1 para ξ simbólico.",
                                    "Plote ou tabule valores em ξ=-0.5,0.5.",
                                    "Discuta uso: u(ξ) = ∑ u_i N_i(ξ).",
                                    "Registre fórmulas finais incluindo derivadas."
                                  ],
                                  "verification": "Resolva um problema simples: dado u(-1)=1, u(0)=0, u(1)=-1, encontre u(0.5).",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela de valores"
                                  ],
                                  "tips": "Teste em pontos intermediários para validação.",
                                  "learningObjective": "Validar completude das funções de interpolação.",
                                  "commonMistakes": [
                                    "Não expandir polinômio para verificar soma=1"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma barra 1D com nós em ξ=-1 (u=0), ξ=0 (u=1), ξ=1 (u=0), o deslocamento interpolado é u(ξ) = 0*N₁ + 1*N₂ + 0*N₃ = 1 - ξ². Em ξ=0.5, u=0.75, representando deformação parabólica.",
                              "finalVerifications": [
                                "N₁(-1)=1, N₁(0)=0, N₁(1)=0",
                                "N₂(-1)=0, N₂(0)=1, N₂(1)=0",
                                "N₃(-1)=0, N₃(0)=0, N₃(1)=1",
                                "dN₁/dξ = ξ - 0.5, dN₂/dξ = -2ξ, dN₃/dξ = ξ + 0.5",
                                "∑ N_i(ξ) = 1 para qualquer ξ",
                                "∑ dN_i/dξ = 0 para qualquer ξ",
                                "Capacidade de interpolar campo escalar corretamente"
                              ],
                              "assessmentCriteria": [
                                "Correção exata das expressões N_i(ξ) e dN_i/dξ",
                                "Resolução correta dos sistemas de equações para cada N_i",
                                "Verificação numérica nos três nós para cada função",
                                "Compreensão da partição da unidade e suas derivadas",
                                "Aplicação em exemplo prático de interpolação",
                                "Identificação de simetrias e propriedades",
                                "Clareza na derivação passo a passo"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Polinômios de Lagrange e resolução de sistemas lineares",
                                "Programação: Implementação numérica em Python/MATLAB para plotagem e integração",
                                "Física: Modelagem de deformações em barras e vigas no contexto de mecânica dos sólidos",
                                "Engenharia de Computação: Bases para software de simulação FEM como ANSYS",
                                "Cálculo Numérico: Aproximação de funções e análise de erro de interpolação"
                              ],
                              "realWorldApplication": "Essas funções são usadas no Método dos Elementos Finitos para simular tensões e deformações em estruturas mecânicas, como vigas sob carga em pontes ou aeronaves, permitindo análises precisas de fadiga e segurança."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.3.3",
                            "name": "Verificar propriedades das funções de interpolação",
                            "description": "Demonstrar a condição de partição da unidade, Lagrange delta e compatibilidade para elementos 1D lineares e quadráticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Derivação das funções de interpolação para elemento linear 1D",
                                  "subSteps": [
                                    "Lembre-se da parametrização do elemento linear 1D com dois nós em ξ = -1 e ξ = 1.",
                                    "Derive as funções de shape N1(ξ) = (1 - ξ)/2 e N2(ξ) = (1 + ξ)/2.",
                                    "Plote ou esboce as funções para visualizar seu comportamento.",
                                    "Expresse um campo u(ξ) = u1 N1(ξ) + u2 N2(ξ).",
                                    "Verifique graficamente que as funções são lineares e se sobrepõem adequadamente."
                                  ],
                                  "verification": "Confirme que N1(-1)=1, N1(1)=0, N2(-1)=0, N2(1)=1 e que a soma é 1 em pontos arbitrários.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora",
                                    "Software de plotagem como MATLAB ou Python (Matplotlib)"
                                  ],
                                  "tips": "Use coordenadas naturais ξ para simplificar os cálculos.",
                                  "learningObjective": "Entender a forma das funções de shape lineares e sua base polinomial de grau 1.",
                                  "commonMistakes": [
                                    "Confundir coordenadas locais ξ com globais x",
                                    "Esquecer de normalizar para partição da unidade",
                                    "Plotar incorretamente os valores nos nós"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificação das propriedades para elemento linear 1D",
                                  "subSteps": [
                                    "Verifique partição da unidade: N1(ξ) + N2(ξ) = 1 para todo ξ.",
                                    "Verifique propriedade delta de Lagrange: Ni(ξj) = δij, onde δij=1 se i=j, 0 caso contrário.",
                                    "Verifique compatibilidade: funções são C0 contínuas nos nós compartilhados entre elementos adjacentes.",
                                    "Calcule numericamente em pontos médios e nós.",
                                    "Discuta implicações para interpolação de campos em MEF."
                                  ],
                                  "verification": "Todas as três propriedades devem ser satisfeitas analiticamente e numericamente em pelo menos 3 pontos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de cálculo",
                                    "Python ou MATLAB para avaliação numérica"
                                  ],
                                  "tips": "Expanda algebricamente para provar partição: (1-ξ)/2 + (1+ξ)/2 = 1.",
                                  "learningObjective": "Demonstrar que as funções lineares satisfazem as propriedades fundamentais de interpolação.",
                                  "commonMistakes": [
                                    "Ignorar a propriedade delta em pontos não-nós",
                                    "Confundir compatibilidade com diferenciabilidade C1",
                                    "Erros algébricos na soma das funções"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivação das funções de interpolação para elemento quadrático 1D",
                                  "subSteps": [
                                    "Defina o elemento quadrático com três nós: ξ = -1 (nó1), ξ = 0 (nó2), ξ = 1 (nó3).",
                                    "Derive N1(ξ) = -(1-ξ)ξ/2, N2(ξ) = (1-ξ²), N3(ξ) = (1+ξ)ξ/2.",
                                    "Plote as funções para observar o comportamento parabólico.",
                                    "Expresse u(ξ) = u1 N1 + u2 N2 + u3 N3.",
                                    "Compare com o linear em termos de precisão."
                                  ],
                                  "verification": "Confirme Ni(ξj) = δij para i,j=1,2,3.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software de plotagem"
                                  ],
                                  "tips": "Use a forma Lagrangiana geral para derivar: Ni(ξ) = produto (ξ - ξk)/(ξi - ξk) para k≠i.",
                                  "learningObjective": "Construir funções de shape quadráticas de grau 2 com 3 DOFs.",
                                  "commonMistakes": [
                                    "Fórmulas erradas para N1 ou N3 (sinal negativo)",
                                    "Esquecer o nó médio",
                                    "Não verificar valores nos nós"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificação das propriedades para elemento quadrático 1D",
                                  "subSteps": [
                                    "Verifique partição: soma Ni(ξ) = 1 para todo ξ.",
                                    "Verifique delta de Lagrange nos três nós.",
                                    "Verifique compatibilidade C0 entre elementos adjacentes (valores nos nós extremos coincidem).",
                                    "Avalie numericamente em pontos de Gauss ou médios.",
                                    "Compare precisão com elemento linear."
                                  ],
                                  "verification": "Propriedades confirmadas analiticamente e em tabela numérica com 5 pontos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora simbólica como SymPy",
                                    "Planilha Excel"
                                  ],
                                  "tips": "Prove partição expandindo os polinômios: verifica-se que soma é 1.",
                                  "learningObjective": "Validar que funções quadráticas mantêm as propriedades essenciais apesar do maior grau.",
                                  "commonMistakes": [
                                    "Erro na expansão polinomial da soma",
                                    "Achar que quadráticos são C1 contínuos (só C0)",
                                    "Não testar nó médio na delta"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um elemento linear de comprimento L=10m, nós em x=0 e x=10 (ξ=-1 a 1), u1=20°C, u2=80°C. As funções N1 e N2 interpolam linearmente a temperatura. Verifique em x=5m (ξ=0): N1=0.5, N2=0.5, u=50°C, soma=1, delta nos nós OK, compatível com elemento adjacente em x=10.",
                              "finalVerifications": [
                                "Soma das funções de shape =1 em 5 pontos arbitrários para linear e quadrático.",
                                "Ni(ξj)=δij confirmado para todos nós.",
                                "Campos interpolados são contínuos (C0) em interfaces de elementos.",
                                "Gráficos mostram partição visualmente.",
                                "Tabela numérica com valores exatos e aproximados coincide.",
                                "Comparação de precisão: quadrático captura curvatura melhor."
                              ],
                              "assessmentCriteria": [
                                "Precisão analítica nas provas das propriedades (sem erros algébricos).",
                                "Uso correto de coordenadas isoparamétricas.",
                                "Verificações numéricas em múltiplos pontos com tolerância <1e-10.",
                                "Explicação clara da compatibilidade C0 vs. C1.",
                                "Identificação de vantagens do quadrático sobre linear.",
                                "Gráficos ou tabelas bem apresentados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Polinômios de Lagrange e propriedades de bases.",
                                "Programação: Implementação em código para MEF (ex: FEniCS ou MATLAB).",
                                "Física: Interpolação de campos em problemas de calor/condução 1D.",
                                "Geometria Computacional: Mapeamento isoparamétrico."
                              ],
                              "realWorldApplication": "Em simulações MEF de barras axiais ou vigas sob carga, verifica-se essas propriedades para garantir precisão na aproximação de deslocamentos/temperaturas, evitando erros de discretização em estruturas como pontes ou tubulações industriais."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.3.4",
                            "name": "Aplicar funções de interpolação na aproximação do campo",
                            "description": "Usar u^h(x) = Σ N_i(ξ) u_i para aproximar deslocamentos ou campos escalares em problemas 1D, transformando para coordenadas globais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender funções de interpolação em coordenadas locais (ξ)",
                                  "subSteps": [
                                    "Defina o domínio local ξ para um elemento 1D linear, tipicamente de -1 a 1.",
                                    "Derive as funções de forma N_i(ξ) para nós i: N_1(ξ) = (1 - ξ)/2, N_2(ξ) = (1 + ξ)/2.",
                                    "Verifique que as funções satisfazem as condições de partição da unidade: Σ N_i(ξ) = 1 e N_i(ξ_j) = δ_ij.",
                                    "Plote ou esboce N_i(ξ) para visualizar o comportamento linear.",
                                    "Discuta extensão para elementos quadráticos ou de ordem superior."
                                  ],
                                  "verification": "Confirme Σ N_i(ξ) = 1 para vários pontos ξ e N_i(ξ_j) = 1 apenas no nó i.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis ou software como MATLAB/Octave para plotagem",
                                    "Referência: Livro de Elementos Finitos (ex: Zienkiewicz)"
                                  ],
                                  "tips": "Sempre normalize ξ para [-1,1] para simplicidade em elementos lineares.",
                                  "learningObjective": "Compreender e derivar funções de interpolação N_i(ξ) em coordenadas locais.",
                                  "commonMistakes": [
                                    "Confundir funções lineares com quadráticas",
                                    "Esquecer partição da unidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a aproximação do campo u^h(ξ) = Σ N_i(ξ) u_i",
                                  "subSteps": [
                                    "Atribua valores nodais u_i aos nós do elemento (ex: u_1 = 0, u_2 = 1).",
                                    "Calcule u^h(ξ) explicitamente: u^h(ξ) = N_1(ξ)u_1 + N_2(ξ)u_2.",
                                    "Avalie u^h(ξ) em pontos Gauss ou nós para verificação.",
                                    "Compare com a solução exata para um campo conhecido (ex: u(x) = x).",
                                    "Generalize para mais nós em elementos de maior ordem."
                                  ],
                                  "verification": "u^h(ξ_i) = u_i em cada nó i, e interpolação suave entre nós.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB para avaliação numérica"
                                  ],
                                  "tips": "Use valores nodais simples inicialmente para depuração.",
                                  "learningObjective": "Aplicar funções N_i para formar a aproximação local do campo.",
                                  "commonMistakes": [
                                    "Erro aritmético em Σ N_i u_i",
                                    "Não interpolar corretamente nos nós"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Transformar a aproximação para coordenadas globais x",
                                  "subSteps": [
                                    "Defina o mapeamento isoparamétrico: x(ξ) = Σ N_i(ξ) x_i, onde x_i são coordenadas globais dos nós.",
                                    "Calcule o Jacobiano J = dx/dξ para transformação de derivadas.",
                                    "Expresse u^h(x) substituindo ξ(x) na fórmula local.",
                                    "Derive du^h/dx = (du^h/dξ) / J para consistência.",
                                    "Verifique continuidade entre elementos adjacentes."
                                  ],
                                  "verification": "u^h(x_i) = u_i e derivada consistente no mapeamento.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Fórmulas de mapeamento anotadas",
                                    "Software para plotar u^h(x) vs x"
                                  ],
                                  "tips": "Para elementos lineares uniformes, J é constante: J = (x_2 - x_1)/2.",
                                  "learningObjective": "Mapear corretamente de coordenadas locais para globais.",
                                  "commonMistakes": [
                                    "Inverter o sinal do Jacobiano",
                                    "Esquecer de transformar derivadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e validar em um problema 1D completo",
                                  "subSteps": [
                                    "Monte um malha 1D simples (ex: barra de 0 a L com 2 elementos).",
                                    "Aplique u^h(x) para aproximar um deslocamento u(x) = sin(πx/L).",
                                    "Calcule erro de aproximação L2 ou máximo.",
                                    "Implemente em código simples para automação.",
                                    "Analise convergência refinando a malha."
                                  ],
                                  "verification": "Erro de aproximação < 5% para malha grosseira, converge com refinamento.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com NumPy/MeshPy ou MATLAB",
                                    "Exemplo de código base"
                                  ],
                                  "tips": "Comece com malha uniforme para simplicidade.",
                                  "learningObjective": "Integrar interpolação em um fluxo de análise de elementos finitos 1D.",
                                  "commonMistakes": [
                                    "Malha não alinhada com nós",
                                    "Erro na soma global"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma barra axial 1D de comprimento L=1m, com nós em x=0 (u1=0) e x=1 (u2=1), use funções lineares para aproximar u^h(x) = (1-x) * 0 + x * 1 = x. Transforme via x(ξ) = 0.5(1-ξ) + 0.5(1+ξ)*1, resultando em u^h(x)=x exatamente para este caso linear.",
                              "finalVerifications": [
                                "u^h(x_i) reproduz u_i exatamente nos nós.",
                                "Aproximação é contínua entre elementos.",
                                "Derivadas transformadas corretamente via Jacobiano.",
                                "Erro de interpolação diminui com ordem do elemento.",
                                "Partição da unidade mantida: ∫ N_i dx = comprimento do elemento.",
                                "Convergência observada em refinamento de malha."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de N_i(ξ) (90% correto).",
                                "Correta transformação ξ → x com Jacobiano (sem erros de sinal).",
                                "Cálculo numérico de u^h(x) em 5 pontos com erro <1%.",
                                "Identificação de 3 erros comuns e como evitá-los.",
                                "Implementação em código que plota u^h vs exata.",
                                "Explicação verbal da aplicação em problema real."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de polinômios de Lagrange e interpolação numérica.",
                                "Programação: Implementação numérica em Python/MATLAB para MEF.",
                                "Física: Modelagem de campos contínuos (tensão, temperatura) em sólidos.",
                                "Computação Científica: Quadratura numérica e integração em elementos.",
                                "Engenharia de Software: Estruturas de dados para malhas e campos."
                              ],
                              "realWorldApplication": "Na análise de estruturas via MEF (ex: ANSYS), aproxima deslocamentos em vigas/truss para prever deformações sob carga, essencial em design de pontes, aviões e edifícios."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.2",
                    "name": "Montagem das matrizes globais",
                    "description": "Procedimento para assemble das matrizes de rigidez, massa e carregamento globais a partir das contribuições elementares.",
                    "individualConcepts": [
                      {
                        "id": "34.1.3.2.1",
                        "name": "Contribuições Elementares",
                        "description": "Cálculo das matrizes locais de rigidez [K^e], massa [M^e] e vetor de carregamento {F^e} para um elemento unidimensional, como barras ou vigas simples, utilizando funções de interpolação e integração ao longo do elemento.",
                        "specificSkills": [
                          {
                            "id": "34.1.3.2.1.1",
                            "name": "Cálculo da Matriz de Rigidez Elementar [K^e]",
                            "description": "Derivar e computar a matriz de rigidez [K^e] para um elemento barra 1D com base nas funções de forma, módulo de elasticidade E, área A e comprimento L, usando a fórmula [K^e] = (AE/L) * [B]^T [D] [B] * integral.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais do Elemento Barra 1D",
                                  "subSteps": [
                                    "Identifique os parâmetros do elemento: módulo de elasticidade E, área transversal A e comprimento L.",
                                    "Revise as funções de forma lineares para barra 1D: N₁(ξ) = 1 - ξ, N₂(ξ) = ξ, onde ξ = x/L varia de 0 a 1.",
                                    "Entenda a matriz constitutiva [D] = E para comportamento axial elástico unidimensional.",
                                    "Defina o deslocamento u(x) = N₁ u₁ + N₂ u₂, onde u₁ e u₂ são graus de liberdade nos nós.",
                                    "Calcule as derivadas das funções de forma em relação a x: dN₁/dx = -1/L, dN₂/dx = 1/L."
                                  ],
                                  "verification": "Liste corretamente E, A, L, funções de forma N₁ e N₂, e suas derivadas dN/dx.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Elementos Finitos (ex: Bathe)",
                                    "Calculadora"
                                  ],
                                  "tips": "Use coordenada natural ξ para simplificar integrais de 0 a 1 em vez de 0 a L.",
                                  "learningObjective": "Compreender os componentes básicos necessários para derivar [K^e].",
                                  "commonMistakes": [
                                    "Confundir funções de forma com derivadas",
                                    "Esquecer que ξ = x/L",
                                    "Ignorar unidades consistentes para E, A e L"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Matriz de Deformação [B]",
                                  "subSteps": [
                                    "Escreva a deformação ε = du/dx = [dN₁/dx, dN₂/dx] {u₁, u₂} = [B] {u^e}.",
                                    "Formule [B] = [-1/L, 1/L], constante ao longo do elemento para funções lineares.",
                                    "Verifique que [B] tem dimensão 1x2 para elemento 1D com 2 nós.",
                                    "Confirme transposição: [B]^T = [-1/L; 1/L].",
                                    "Discuta por que [B] é derivada das funções de forma em coordenadas globais."
                                  ],
                                  "verification": "Escreva [B] corretamente e multiplique por um vetor de deslocamentos de teste para obter ε.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software de álgebra simbólica como SymPy ou MATLAB"
                                  ],
                                  "tips": "Lembre-se: derivadas são em relação a x físico, não ξ; ajuste com dξ/dx = 1/L se necessário.",
                                  "learningObjective": "Dominar a formação da matriz [B] a partir das funções de forma.",
                                  "commonMistakes": [
                                    "Usar derivadas em ξ ao invés de x",
                                    "Esquecer o sinal negativo em dN₁/dx",
                                    "Confundir [B] com [N]"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular e Calcular a Integral para [K^e]",
                                  "subSteps": [
                                    "Escreva a fórmula geral: [K^e] = ∫_0^L [B]^T [D] [B] A dx.",
                                    "Substitua [D] = E e note que [B]^T E [B] é constante: [[1, -1], [-1, 1]] * (E / L²).",
                                    "Compute o produto [B]^T [D] [B] = (E / L²) * [[1, -1], [-1, 1]].",
                                    "Integre: ∫_0^L dx = L, então [K^e] = A * (E / L²) * L * [[1, -1], [-1, 1]] = (A E / L) * [[1, -1], [-1, 1]].",
                                    "Verifique simetria e positivos definitos (diagonal positiva, off-diagonal negativa)."
                                  ],
                                  "verification": "Derive a fórmula fechada [K^e] = (AE/L) [[1,-1],[-1,1]] e confira dimensionalmente (força/comprimento).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Planilha Excel ou MATLAB para verificação numérica"
                                  ],
                                  "tips": "A integral simplifica porque tudo é constante; use transformação de coordenadas para elementos mais complexos.",
                                  "learningObjective": "Derivar analiticamente a matriz [K^e] via integração.",
                                  "commonMistakes": [
                                    "Esquecer fator A na integral",
                                    "Erro no produto matricial [B]^T [B]",
                                    "Integral errada: L ao invés de L² no denominador"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Implementar Computacionalmente",
                                  "subSteps": [
                                    "Escolha valores numéricos: E=200 GPa, A=1e-4 m², L=1 m.",
                                    "Calcule manualmente [K^e] e compare com código simples.",
                                    "Implemente em pseudocódigo ou MATLAB: defina E,A,L,B e compute K = A*E/L * (B'*B * L).",
                                    "Teste com casos limite: L→0 (K→∞), A→0 (K→0).",
                                    "Discuta generalização para elementos com mais nós ou não-lineares."
                                  ],
                                  "verification": "Código ou cálculo manual reproduz [K^e] exata com erro <1e-10.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "MATLAB/Python/SymPy",
                                    "Papel e caneta"
                                  ],
                                  "tips": "Use unidades SI consistentes para evitar erros de magnitude.",
                                  "learningObjective": "Aplicar a derivação em um contexto computacional e validar.",
                                  "commonMistakes": [
                                    "Erro de unidades (GPa vs Pa)",
                                    "Índices errados em código matricial",
                                    "Não verificar simetria final"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma barra de aço com E=200 GPa, A=1 cm²=10^{-4} m², L=0.5 m: [K^e] = (200e9 * 1e-4 / 0.5) * [[1,-1],[-1,1]] = 4e7 * [[1,-1],[-1,1]] N/m. Verifique aplicando deslocamentos u1=0, u2=1 mm: força nodal F2=4e4 N.",
                              "finalVerifications": [
                                "[K^e] é simétrica com k11=k22>0 e k12=k21=-k11.",
                                "Dimensões corretas: 2x2 para barra com 2 nós.",
                                "Fórmula reduz corretamente para casos conhecidos (ex: mola com k=AE/L).",
                                "Cálculo numérico coincide com analítico dentro de tolerância 1e-6.",
                                "Aplicação de deslocamentos unitários produz forças consistentes com rigidez.",
                                "Sem erros dimensionais (unidades de rigidez: força/comprimento)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de [B] e integral (100% correto).",
                                "Compreensão conceitual: explicar papel de cada componente (E,A,L).",
                                "Habilidade computacional: código reproduz resultado exato.",
                                "Identificação de erros comuns e correções.",
                                "Generalização para outros elementos 1D.",
                                "Clareza na documentação do processo."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: operações matriciais, transposição e produtos.",
                                "Cálculo: derivadas, integrais e mudança de variáveis.",
                                "Programação: implementação numérica em MATLAB/Python.",
                                "Física/Mecânica: conceitos de deformação, tensão e equilíbrio.",
                                "Engenharia Computacional: base para software FEA como ANSYS."
                              ],
                              "realWorldApplication": "Cálculo de [K^e] é fundamental em simulações FEA para análise estrutural de vigas, trusses em pontes, fuselagens de aviões e chassis automotivos, permitindo prever deformações sob cargas reais com precisão de engenharia."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.1.3.2.1.2",
                            "name": "Cálculo da Matriz de Massa Elementar [M^e]",
                            "description": "Computar a matriz de massa consistente [M^e] para elemento 1D utilizando densidade ρ, área A e funções de interpolação N, pela integral [M^e] = ρ A ∫ N^T N dx, e comparar com massa concentrada (lumped).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais da Matriz de Massa em Elementos Finitos",
                                  "subSteps": [
                                    "Definir matriz de massa consistente como derivada da integral de distribuição de massa via funções de interpolação.",
                                    "Explicar matriz de massa lumped como aproximação diagonal com massas concentradas nos nós.",
                                    "Discutir aplicações em problemas dinâmicos como equação M ü + K u = F.",
                                    "Identificar diferenças: consistente distribui massa entre nós, lumped simplifica para modos baixos.",
                                    "Calcular massa total do elemento: m = ρ A L."
                                  ],
                                  "verification": "Escrever um resumo de 3 frases comparando consistente vs. lumped e listar 2 aplicações.",
                                  "estimatedTime": "20 min",
                                  "materials": [
                                    "Notas de aula sobre Elementos Finitos",
                                    "Livro texto (ex: Bathe ou Zienkiewicz)",
                                    "Papel e caneta"
                                  ],
                                  "tips": [
                                    "Visualize a massa distribuída ao longo do elemento como uma 'nuvem' compartilhada entre nós.",
                                    "Lembre-se: consistente é exata para integração Gauss, lumped para eficiência computacional."
                                  ],
                                  "learningObjective": "Compreender o papel físico e matemático da matriz de massa consistente versus lumped.",
                                  "commonMistakes": [
                                    "Confundir matriz de massa com matriz de rigidez.",
                                    "Ignorar que lumped não preserva energia cinética exata para modos altos.",
                                    "Esquecer fator ρ A na formulação."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Geometria do Elemento 1D e Funções de Interpolação N",
                                  "subSteps": [
                                    "Especificar elemento 1D linear com 2 nós, comprimento L, seção transversal A constante.",
                                    "Introduzir coordenada local x de 0 a L, ou normalizada ξ = x/L de 0 a 1.",
                                    "Definir funções de interpolação lineares: N1(ξ) = 1 - ξ, N2(ξ) = ξ.",
                                    "Verificar propriedades: soma Ni = 1 (partição da unidade), derivadas dN1/dξ = -1, dN2/dξ = 1.",
                                    "Esboçar gráfico de N1 e N2 ao longo do elemento."
                                  ],
                                  "verification": "Plotar N1 e N2 em papel e confirmar N(0)=[1,0], N(1)=[0,1].",
                                  "estimatedTime": "15 min",
                                  "materials": [
                                    "Papel milimetrado",
                                    "Calculadora",
                                    "Software de plotagem opcional (ex: MATLAB)"
                                  ],
                                  "tips": [
                                    "Use ξ para simplificar integral: dx = L dξ.",
                                    "Sempre normalize para evitar erros dimensionais."
                                  ],
                                  "learningObjective": "Dominar formulação das funções de interpolação para elemento barra 1D.",
                                  "commonMistakes": [
                                    "Usar funções quadráticas em elemento linear.",
                                    "Esquecer transformação dx = L dξ.",
                                    "Confundir N com vetores de forma em 2D."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a Integral da Matriz de Massa Consistente [M^e]",
                                  "subSteps": [
                                    "Escrever fórmula: [M^e] = ρ A ∫_0^L N^T N dx = ρ A L ∫_0^1 N^T N dξ.",
                                    "Expandir N = [N1; N2], então N^T N = [[N1^2, N1 N2]; [N2 N1, N2^2]].",
                                    "Substituir: ∫ N1^2 dξ = ∫ (1-ξ)^2 dξ = 1/3, ∫ N1 N2 dξ = 1/6, ∫ N2^2 dξ = 1/3.",
                                    "Montar matriz: [M^e] = (ρ A L / 6) * [[2, 1]; [1, 2]].",
                                    "Verificar simetria e positivo-definido (autovalores positivos)."
                                  ],
                                  "verification": "Calcular manualmente os integrais e confirmar [2/6, 1/6; 1/6, 2/6] * ρ A L.",
                                  "estimatedTime": "30 min",
                                  "materials": [
                                    "Folha de cálculo",
                                    "Tabela de integrais indefinidas",
                                    "Calculadora simbólica opcional"
                                  ],
                                  "tips": [
                                    "Integre termo a termo: (1-ξ)^2 = 1 - 2ξ + ξ^2 → ∫ = [ξ - ξ^2 + ξ^3/3]_0^1 = 1/3.",
                                    "Fatore ρ A L no final para clareza."
                                  ],
                                  "learningObjective": "Formular e computar analiticamente a integral para [M^e] consistente.",
                                  "commonMistakes": [
                                    "Esquecer transposta N^T.",
                                    "Integrar de -1 a 1 em vez de 0 a 1.",
                                    "Erro em expansão: N1 N2 = (1-ξ)ξ ≠ ξ^2."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular Matriz Lumped e Comparar com Consistente",
                                  "subSteps": [
                                    "Definir lumped: massas nodais iguais m_node = (ρ A L)/2, [M^e]_lumped = diag([m_node, m_node]).",
                                    "Comparar traço: ambos = ρ A L (massa total preservada).",
                                    "Analisar diferenças: consistente tem acoplamento off-diagonal, lumped diagonal (mais simples).",
                                    "Avaliar precisão: consistente melhor para modos altos, lumped para baixos e eficiência.",
                                    "Implementar em pseudocódigo ou MATLAB para um caso numérico."
                                  ],
                                  "verification": "Calcular ambas matrizes para L=1, ρ=1, A=1 e listar 3 diferenças.",
                                  "estimatedTime": "25 min",
                                  "materials": [
                                    "MATLAB ou Python (opcional)",
                                    "Papel para tabela comparativa"
                                  ],
                                  "tips": [
                                    "Lumped = row-sum de consistente para linear 1D.",
                                    "Teste com autovalores: consistente mais precisa."
                                  ],
                                  "learningObjective": "Comparar quantitativamente [M^e] consistente e lumped, justificando escolhas.",
                                  "commonMistakes": [
                                    "Achar lumped sempre errada (é aproximação válida).",
                                    "Não preservar massa total.",
                                    "Ignorar contexto dinâmico na escolha."
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma barra de aço 1D com L=1 m, ρ=7800 kg/m³, A=0.01 m²: [M^e]_consistente = (7800*0.01*1/6) * [[2,1],[1,2]] = 13 [[2,1],[1,2]] kg. Lumped: diag([13,13]) kg. Note off-diagonais em consistente distribuindo 1/6 da massa entre nós.",
                              "finalVerifications": [
                                "Matriz [M^e] é simétrica com elementos [[2k, k], [k, 2k]] onde k=ρ A L /6.",
                                "Traço([M^e]) = ρ A L (massa total).",
                                "Autovalores positivos confirmam positivo-definido.",
                                "Comparação: lumped tem zeros off-diagonal, mesmo traço.",
                                "Integral computada corretamente sem erros aritméticos.",
                                "Explicação escrita da superioridade consistente para precisão dinâmica."
                              ],
                              "assessmentCriteria": [
                                "Correção analítica da integral (pontos exatos para [[2/6,1/6],[1/6,2/6]] ρ A L).",
                                "Compreensão qualitativa das diferenças consistente vs. lumped (explicação física).",
                                "Precisão numérica no exemplo prático (erro <1%).",
                                "Verificação de propriedades matriciais (simetria, traço).",
                                "Justificativa de uso em contextos reais (ex: vibrações).",
                                "Clareza na documentação dos cálculos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo integral e álgebra linear (matrizes simétricas).",
                                "Física: Dinâmica e conservação de massa/energia cinética.",
                                "Programação: Implementação numérica em MATLAB/Python para integrais.",
                                "Engenharia Civil: Análise modal de vigas e treliças.",
                                "Computação Científica: Integração Gauss para elementos superiores."
                              ],
                              "realWorldApplication": "Em simulações FEA de estruturas dinâmicas como vigas em pontes ou cabos em guindastes, usando consistente para precisão em frequências naturais altas (ex: ANSYS para análise sísmica) ou lumped para modelos grandes e eficientes em vibrações de baixa frequência."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.1.3.2.1.3",
                            "name": "Cálculo do Vetor de Carregamento Elementar {F^e}",
                            "description": "Determinar o vetor nodal de forças {F^e} devido a carregamentos distribuídos q(x) ao longo do elemento, usando {F^e} = ∫ N^T q(x) dx, incluindo casos de carga constante e linear.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Funções de Interpolação e Formulação do Vetor de Carregamento",
                                  "subSteps": [
                                    "Identifique as funções de interpolação N(x) para o elemento 1D (ex: linear: N1 = 1 - ξ, N2 = ξ, onde ξ = x/L).",
                                    "Escreva a fórmula geral {F^e} = ∫_0^L N^T(x) q(x) dx, explicando que N^T é a transposta das funções de forma.",
                                    "Defina o domínio de integração do comprimento do elemento L e o tipo de carga q(x).",
                                    "Converta para coordenadas naturais ξ (-1 a 1) se usando Gauss, com dx = (L/2) dξ.",
                                    "Verifique simetria para cargas uniformes."
                                  ],
                                  "verification": "Confirme que a fórmula está corretamente escrita e as funções N somam 1 em qualquer ponto (propriedade de partição).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Elementos Finitos (ex: Bathe ou Zienkiewicz), papel e calculadora.",
                                  "tips": "Sempre normalize as funções de interpolação para evitar erros de escala.",
                                  "learningObjective": "Compreender a base matemática do vetor de carregamento elementar.",
                                  "commonMistakes": "Confundir N com N^T ou esquecer o Jacobiano na transformação de coordenadas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular {F^e} para Carga Constante q(x) = q0",
                                  "subSteps": [
                                    "Substitua q(x) = q0 na integral: {F^e} = q0 ∫_0^L N^T(x) dx.",
                                    "Para elemento linear 2-nós: F1^e = q0 L / 2, F2^e = q0 L / 2.",
                                    "Integre analiticamente: ∫ N1 dx = L/2, ∫ N2 dx = L/2.",
                                    "Desenhe o elemento com nós 1 e 2, mostrando distribuição simétrica da carga.",
                                    "Calcule numericamente para L=1m, q0=1000 N/m."
                                  ],
                                  "verification": "Resultado deve ser simétrico: F1^e = F2^e = (q0 L)/2.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel quadriculado, calculadora simbólica (ex: SymPy ou Mathematica).",
                                  "tips": "Lembre-se: carga constante resulta em forças nodais iguais nos extremos.",
                                  "learningObjective": "Dominar o cálculo analítico para cargas uniformes distribuídas.",
                                  "commonMistakes": "Esquecer de dividir por 2, resultando em soma total q0 L incorreta."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular {F^e} para Carga Linear q(x) = q0 + (q1 - q0)(x/L)",
                                  "subSteps": [
                                    "Defina q(x) = a + b x, onde a=q0, b=(q1-q0)/L.",
                                    "Substitua na integral: F_i^e = ∫_0^L N_i(x) q(x) dx para i=1,2.",
                                    "Integre analiticamente: Para linear, F1^e = (2 q0 + q1) L / 6, F2^e = (q0 + 2 q1) L / 6.",
                                    "Use integração por partes ou Gauss quadratura (2 pontos) para verificação numérica.",
                                    "Exemplo: q0=0, q1=1000 N/m, L=1m → F1=0, F2=1000/3 N."
                                  ],
                                  "verification": "Verifique equilíbrio: F1^e + F2^e = ∫ q(x) dx = (q0 + q1) L / 2.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software MATLAB/Python para integração numérica, exemplos resolvidos.",
                                  "tips": "Peso de Simpson: 1/6 e 5/6 para linear, aproximando a distribuição.",
                                  "learningObjective": "Aplicar integração para cargas variáveis lineares.",
                                  "commonMistakes": "Inverter coeficientes de q0 e q1 nos resultados finais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e Verificar Numericamente com Integração Gauss",
                                  "subSteps": [
                                    "Escolha pontos de Gauss (2 pontos para linear): ξ1=-1/√3, ξ2=1/√3, pesos=1.",
                                    "Calcule {F^e} ≈ Σ w_k N^T(ξ_k) q(ξ_k) (L/2).",
                                    "Programe em Python/MATLAB para casos constante e linear.",
                                    "Compare analítico vs numérico (erro <1%).",
                                    "Teste com malha de 2 elementos para montagem global parcial."
                                  ],
                                  "verification": "Erro relativo entre analítico e numérico < 0.1%; código roda sem erros.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python com NumPy/SciPy, Jupyter Notebook.",
                                  "tips": "Use funções vetoriais para N(ξ) para eficiência computacional.",
                                  "learningObjective": "Implementar método numérico robusto para qualquer q(x).",
                                  "commonMistakes": "Esquecer o fator Jacobiano (L/2) na quadratura de Gauss."
                                }
                              ],
                              "practicalExample": "Para uma viga de 2m com carga linear q(x)=1000*(x/2) N/m (q0=0, q1=1000), elemento linear: F1^e = (2*0 + 1000)*2/6 ≈ 333.33 N, F2^e = (0 + 2*1000)*2/6 ≈ 666.67 N. Verifique soma=1000 N (total carga).",
                              "finalVerifications": [
                                "Equilíbrio de forças: soma {F^e} = ∫ q(x) dx.",
                                "Simetria para q constante: F1^e = F2^e.",
                                "Correção para linear: pesos 1/3 e 2/3 aproximados.",
                                "Convergência numérica com mais pontos Gauss.",
                                "Compatibilidade com matriz de rigidez [K^e] em exemplo simples.",
                                "Código reproduz resultados analíticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão da fórmula e integração (90% correto).",
                                "Correta derivação analítica para constante e linear.",
                                "Implementação numérica funcional e precisa.",
                                "Verificação de equilíbrio e simetria.",
                                "Clareza na documentação de passos e resultados.",
                                "Tratamento de unidades consistentes (N, m)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Integração analítica e quadratura numérica (Cálculo II/III).",
                                "Programação: Vetorização em Python/MATLAB (Computação Científica).",
                                "Física: Equilíbrio de forças em barras/vigas (Mecânica dos Sólidos).",
                                "Numérico: Análise de erros em métodos aproximados (Análise Numérica)."
                              ],
                              "realWorldApplication": "Em software FEA como ANSYS ou Abaqus, calcular forças nodais de cargas distribuídas em vigas de pontes, aerofólios ou estruturas automotivas, essencial para simulações de tensão e deformação sob ventos ou pesos variáveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "34.1.3.2.2",
                        "name": "Numeração de Nós e Conectividade",
                        "description": "Estabelecimento da numeração sequencial dos graus de liberdade globais e criação da tabela de conectividade que mapeia os nós e GL locais de cada elemento para os índices globais.",
                        "specificSkills": [
                          {
                            "id": "34.1.3.2.2.1",
                            "name": "Construção da Tabela de Conectividade",
                            "description": "Para uma malha 1D com n elementos e neq graus de liberdade, gerar a tabela de conectividade onde cada linha representa um elemento e lista os números dos nós locais (1,2 para barra linear) mapeados para globais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura da malha 1D e numeração de nós globais",
                                  "subSteps": [
                                    "Desenhe a malha 1D representando n elementos como segmentos conectados.",
                                    "Numere os nós globais sequencialmente de 1 até n+1, iniciando pelo nó esquerdo.",
                                    "Identifique o número total de graus de liberdade (neq), considerando gls por nó (ex: 1 para deslocamento axial).",
                                    "Anote o número de nós locais por elemento (ex: 2 para barra linear).",
                                    "Crie um diagrama anotado da malha com nós numerados."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito a numeração global e confirme n+1 nós para n elementos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo de malha impressa ou digital"
                                  ],
                                  "tips": [
                                    "Sempre comece numerando da esquerda para a direita em malhas 1D.",
                                    "Use setas para indicar direção da numeração."
                                  ],
                                  "learningObjective": "Entender a relação entre elementos, nós globais e graus de liberdade em uma malha 1D.",
                                  "commonMistakes": [
                                    "Numerar elementos em vez de nós.",
                                    "Esquecer o nó final (n+1).",
                                    "Confundir neq com número de nós."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir nós locais para cada elemento",
                                  "subSteps": [
                                    "Para cada elemento i (de 1 a n), identifique os nós locais padrão (ex: nó 1 local no início, nó 2 local no fim para barra linear).",
                                    "Liste os nós locais em ordem: [1, 2] para elementos de 2 nós.",
                                    "Repita para todos os elementos, mantendo consistência no tipo de elemento.",
                                    "Crie uma tabela preliminar com colunas: Elemento | Nó Local 1 | Nó Local 2.",
                                    "Preencha apenas os locais sem mapeamento ainda."
                                  ],
                                  "verification": "Mostre a tabela preliminar com nós locais preenchidos corretamente para todos elementos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Planilha ou papel quadriculado",
                                    "Diagrama da malha do passo 1"
                                  ],
                                  "tips": [
                                    "Nós locais são sempre relativos ao elemento, independentes da posição global.",
                                    "Padronize a ordem: esquerda-direita."
                                  ],
                                  "learningObjective": "Dominar a convenção de nós locais para elementos finitos 1D.",
                                  "commonMistakes": [
                                    "Inverter ordem local (2,1 em vez de 1,2).",
                                    "Usar números globais prematuramente.",
                                    "Variar nós locais por elemento."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear nós locais para números globais",
                                  "subSteps": [
                                    "Para o elemento 1: nó local 1 → nó global 1, nó local 2 → nó global 2.",
                                    "Para elemento i: nó local 1 → global i, nó local 2 → global i+1.",
                                    "Generalize a fórmula: para elemento e, nós globais = [e, e+1] em malha uniforme 1D.",
                                    "Preencha a tabela com mapeamentos globais elemento por elemento.",
                                    "Verifique sobreposições: nós compartilhados devem coincidir (ex: fim do elem1 = início do elem2)."
                                  ],
                                  "verification": "Compare mapeamentos adjacentes para confirmar nós compartilhados corretos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela do passo 2",
                                    "Calculadora para n grande"
                                  ],
                                  "tips": [
                                    "Use a fórmula e → [e, e+1] para eficiência.",
                                    "Destaque nós compartilhados em negrito."
                                  ],
                                  "learningObjective": "Aplicar mapeamento local-global corretamente para conectividade.",
                                  "commonMistakes": [
                                    "Pular numeração (ex: elem2 como [3,4] em vez de [2,3]).",
                                    "Não reconhecer compartilhamento de nós.",
                                    "Erros aritméticos em n grande."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e validar a tabela de conectividade completa",
                                  "subSteps": [
                                    "Formate a tabela final: linhas = elementos (1 a n), colunas = nós globais mapeados.",
                                    "Adicione cabeçalho: Elemento | Nó Global 1 | Nó Global 2 | ... (até nós locais).",
                                    "Inclua coluna opcional para neq locais se aplicável.",
                                    "Valide: todos nós de 1 a n+1 aparecem? Conectividade contínua?",
                                    "Teste com software ou manual: simule montagem de matriz usando a tabela."
                                  ],
                                  "verification": "A tabela cobre todos elementos e nós sem lacunas ou duplicatas inválidas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software de planilhas (Excel/Google Sheets)",
                                    "Exemplo de código Python para validação"
                                  ],
                                  "tips": [
                                    "Exporte para CSV para uso em códigos FEA.",
                                    "Sempre valide com malha pequena primeiro."
                                  ],
                                  "learningObjective": "Gerar tabela de conectividade pronta para montagem de matrizes globais.",
                                  "commonMistakes": [
                                    "Tabela com linhas faltando.",
                                    "Cabeçalhos errados.",
                                    "Ignorar validação de conectividade."
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma malha 1D com n=3 elementos (barra dividida em 3 partes), nós globais: 1--2--3--4. Tabela de conectividade: \nElemento 1: [1, 2]\nElemento 2: [2, 3]\nElemento 3: [3, 4]. Isso garante compartilhamento de nós adjacentes para montagem correta da matriz de rigidez global.",
                              "finalVerifications": [
                                "Tabela possui exatamente n linhas (uma por elemento).",
                                "Cada linha lista nós locais mapeados corretamente para globais.",
                                "Nós compartilhados entre elementos adjacentes coincidem.",
                                "Todos nós globais de 1 a n+1 são referenciados pelo menos uma vez.",
                                "Nenhum nó global excede n+1 ou é duplicado indevidamente.",
                                "Tabela é consistente com neq (ex: 2 nós × gls por nó)."
                              ],
                              "assessmentCriteria": [
                                "Precisão 100% nos mapeamentos local-global.",
                                "Compreensão demonstrada na explicação da construção.",
                                "Validação correta de conectividade e compartilhamento.",
                                "Eficiência no uso de fórmulas para malhas grandes.",
                                "Formatação clara e organizada da tabela.",
                                "Aplicação correta em exemplo prático fornecido."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Indexação de matrizes e vetores esparsos.",
                                "Programação: Implementação de loops para geração automática da tabela em Python/MATLAB.",
                                "Física: Discretização de problemas contínuos em domínios 1D (ex: onda em corda).",
                                "Ciência da Computação: Estruturas de dados para malhas (listas de conectividade).",
                                "Engenharia de Software: Validação e testes unitários em simulações FEA."
                              ],
                              "realWorldApplication": "Na análise de elementos finitos para estruturas 1D como barras axiais ou vigas em softwares como ANSYS ou Abaqus, a tabela de conectividade é fundamental para mapear rigidez local para a matriz global, permitindo simulações precisas de tensões e deformações em pontes, edifícios ou componentes mecânicos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.1.3.2.2.2",
                            "name": "Mapeamento de Graus de Liberdade Locais para Globais",
                            "description": "Utilizar a conectividade para mapear os índices locais i,j (ex: 1->no1, 2->no2) para posições globais na matriz esparsa, considerando um GL por nó em problemas de barra axial 1D.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos de Nós, Elementos e Conectividade",
                                  "subSteps": [
                                    "Defina nós como pontos na malha 1D com numeração sequencial global (ex: nó 1, nó 2).",
                                    "Explique elementos como barras conectando dois nós adjacentes em problemas 1D axiais.",
                                    "Descreva a matriz de conectividade: array onde cada linha representa um elemento com IDs dos nós locais (ex: elemento 1: [1,2]).",
                                    "Identifique que cada nó tem 1 Grau de Liberdade (GL) axial (deslocamento u).",
                                    "Revise matriz global esparsa: tamanho N x N, onde N = número total de nós."
                                  ],
                                  "verification": "Desenhe uma malha simples com 3 nós e 2 elementos, listando a conectividade corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, diagrama de malha 1D impresso ou software de desenho (ex: Draw.io).",
                                  "tips": "Sempre numere nós da esquerda para a direita em malhas 1D lineares.",
                                  "learningObjective": "Entender a relação entre nós globais, elementos e conectividade como base para mapeamento.",
                                  "commonMistakes": "Confundir numeração local de nós com global; assumir mais de 1 GL por nó em 1D axial."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Graus de Liberdade Locais por Elemento",
                                  "subSteps": [
                                    "Para um elemento de barra 1D, defina 2 GL locais: local 1 (nó esquerdo), local 2 (nó direito).",
                                    "Associe índices locais i=1 ao primeiro nó do elemento, j=2 ao segundo.",
                                    "Escreva a matriz de rigidez local K_local (2x2) com posições [1,1], [1,2], [2,1], [2,2].",
                                    "Confirme que GL locais são relativos ao elemento, independentes da malha global.",
                                    "Liste GL locais para múltiplos elementos em uma tabela."
                                  ],
                                  "verification": "Crie uma tabela mostrando GL locais para cada elemento de uma malha com 2 elementos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Planilha Excel ou papel quadriculado para tabelas.",
                                  "tips": "Use convenção consistente: nó inicial do elemento = GL local 1.",
                                  "learningObjective": "Dominar a estrutura de GL locais em elementos de barra axial 1D.",
                                  "commonMistakes": "Invertir ordem de nós locais (esquerdo/direito); ignorar simetria da matriz local."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear GL Locais para Globais Usando Conectividade",
                                  "subSteps": [
                                    "Acesse a linha da conectividade para o elemento atual (ex: para elem=1, conect[1] = [no_i, no_j]).",
                                    "Mapeie GL local 1 → GL global = no_i (ex: 1 → 1).",
                                    "Mapeie GL local 2 → GL global = no_j (ex: 2 → 2).",
                                    "Registre pares (local, global) para todas as posições da K_local: (1,1),(1,2),(2,1),(2,2).",
                                    "Repita para todos os elementos, criando uma lista de mapeamentos."
                                  ],
                                  "verification": "Para uma malha de 3 nós/2 elems, liste todos os mapeamentos (local→global) corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código MATLAB/Python simples ou papel para simulação manual.",
                                  "tips": "Implemente como função: map_global = conectividade(elemento, local_index).",
                                  "learningObjective": "Aplicar conectividade para conversão direta local→global.",
                                  "commonMistakes": "Usar índice errado na conectividade (0-based vs 1-based); mapear para nós não conectados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Mapeamento na Montagem da Matriz Global Esparsa",
                                  "subSteps": [
                                    "Inicialize matriz global esparsa vazia (ex: zeros(N,N) ou sparse em MATLAB).",
                                    "Para cada termo K_local(p,q), adicione a (map_global(p), map_global(q)) na global.",
                                    "Some contribuições de elementos adjacentes (ex: nó 2 recebe de elem1 e elem2).",
                                    "Verifique simetria e esparsidade: apenas posições conectadas são preenchidas.",
                                    "Exporte ou visualize a matriz global resultante."
                                  ],
                                  "verification": "Monte K_global para malha de 3 nós e confirme valores em posições corretas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "MATLAB, Python (NumPy/SciPy) ou papel para montagem manual pequena.",
                                  "tips": "Use loops duplos sobre elementos e GL locais para automação.",
                                  "learningObjective": "Integrar mapeamento na assembleia eficiente de matrizes globais.",
                                  "commonMistakes": "Sobrescrever em vez de somar contribuições; erros de indexação off-by-one."
                                }
                              ],
                              "practicalExample": "Considere uma barra 1D com 3 nós (1,2,3) e 2 elementos: elem1 conecta [1,2], elem2 [2,3]. Para elem1, K_local(1,1) vai para global(1,1); K_local(1,2) para (1,2); etc. Para elem2, K_local(1,1) para (2,2). Resultado: K_global 3x3 com diagonais e off-diagonais em [1,2] e [2,3].",
                              "finalVerifications": [
                                "Todos os mapeamentos local→global coincidem com a conectividade.",
                                "Matriz global é simétrica e esparsa, sem entradas em posições não conectadas.",
                                "Contribuições de elementos compartilhando nós são somadas corretamente.",
                                "Para malha de N nós, K_global tem tamanho N x N com 3N-2 entradas não-zero.",
                                "Teste unitário: mapeamento para elemento isolado é identidade.",
                                "Visualização da matriz mostra banda estreita para malha 1D."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos mapeamentos (100% corretos para malha teste).",
                                "Eficiência: tempo de montagem escala linear com número de elementos.",
                                "Correção na soma de contribuições em nós compartilhados.",
                                "Tratamento correto de indexação (1-based consistente).",
                                "Capacidade de debugar erros comuns como off-by-one.",
                                "Clareza na documentação do processo de mapeamento."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Manipulação de índices em matrizes esparsas e vetores de conectividade.",
                                "Programação: Loops indexados e estruturas de dados (arrays/listas) em MATLAB/Python.",
                                "Física: Compreensão de deformações axiais e equilíbrio em estruturas 1D.",
                                "Computação Científica: Técnicas de armazenamento esparso (CSR format)."
                              ],
                              "realWorldApplication": "Em software FEA como ANSYS ou Abaqus, esse mapeamento permite assembleia eficiente de milhões de elementos em simulações de estruturas reais, como vigas em pontes ou fuselagens de aviões, reduzindo tempo de computação de horas para minutos."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.3.2.2.1"
                            ]
                          },
                          {
                            "id": "34.1.3.2.2.3",
                            "name": "Identificação de Graus de Liberdade Totais",
                            "description": "Calcular o número total de equações (neq) como número de nós livres multiplicado pelos GL por nó, excluindo nós com condições de contorno prescritas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a malha de nós e graus de liberdade por nó",
                                  "subSteps": [
                                    "Examine o diagrama da malha 1D, identificando o número total de nós (n_nodes).",
                                    "Determine o número de graus de liberdade (GL) por nó, tipicamente 1 para problemas de barra axial 1D ou 2 para viga.",
                                    "Anote a conectividade dos elementos para mapear nós.",
                                    "Desenhe ou liste todos os nós numerados sequencialmente.",
                                    "Confirme se a numeração segue convenções padrão (ex: de esquerda para direita)."
                                  ],
                                  "verification": "Lista completa de n_nodes e GL por nó documentada corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Diagrama da malha impresso ou digital, papel e lápis, calculadora.",
                                  "tips": "Sempre comece pela malha visual para evitar confusões na numeração.",
                                  "learningObjective": "Compreender a estrutura nodal e GL inerentes ao problema 1D.",
                                  "commonMistakes": "Confundir GL por nó com dimensões do problema (ex: usar 3 GL em 1D)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar nós com condições de contorno prescritas",
                                  "subSteps": [
                                    "Localize no diagrama ou especificações os nós com deslocamentos ou rotações prescritos (suportados).",
                                    "Classifique cada nó como 'livre' ou 'prescrito' com base nas condições de contorno.",
                                    "Liste os nós prescritos e seus GL restritos (ex: u=0 em nó 1).",
                                    "Conte o número total de nós prescritos (n_prescritos).",
                                    "Verifique se condições mistas (ex: apenas um GL prescrito em multi-GL)."
                                  ],
                                  "verification": "Tabela ou lista de nós livres vs. prescritos sem ambiguidades.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Diagrama com marcações coloridas para nós livres/prescritos, tabela em Excel.",
                                  "tips": "Use cores diferentes para destacar nós prescritos no diagrama.",
                                  "learningObjective": "Diferenciar precisamente nós livres de restritos nas condições de contorno.",
                                  "commonMistakes": "Ignorar GL parciais em nós com múltiplos GL (ex: fixo só em translação)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o número de nós livres",
                                  "subSteps": [
                                    "Subtraia n_prescritos de n_nodes para obter n_livres.",
                                    "Ajuste para casos de GL parciais: conte apenas GL livres por nó.",
                                    "Some os GL livres totais: n_livres * GL_por_no_livre.",
                                    "Documente a fórmula: neq = soma(GL_livres_em_cada_no).",
                                    "Valide com um exemplo simples de 2 nós."
                                  ],
                                  "verification": "Cálculo de n_livres e neq preliminar batendo com contagem manual.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora ou software como MATLAB para soma rápida, folha de cálculo.",
                                  "tips": "Faça contagem dupla: uma visual e uma aritmética.",
                                  "learningObjective": "Executar contagem precisa de graus de liberdade livres.",
                                  "commonMistakes": "Multiplicar n_nodes total por GL sem excluir prescritos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e finalizar o cálculo de neq",
                                  "subSteps": [
                                    "Confirme neq = n_livres * GL_por_no (ajustado para variações).",
                                    "Compare com tamanho esperado da matriz global (neq x neq).",
                                    "Teste em um problema de amostra conhecido.",
                                    "Registre neq no contexto da montagem de matrizes.",
                                    "Discuta implicações para alocação de memória em código FEA."
                                  ],
                                  "verification": "neq calculado consistente com verificação cruzada e exemplo.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Exemplo de problema resolvido, código MATLAB simples para matriz.",
                                  "tips": "Sempre valide com o tamanho da matriz de rigidez global.",
                                  "learningObjective": "Finalizar neq com verificações robustas para montagem global.",
                                  "commonMistakes": "Esquecer de ajustar GL em nós com condições parciais."
                                }
                              ],
                              "practicalExample": "Em uma barra axial 1D com 5 nós (n_nodes=5, GL=1 por nó), nós 1 e 5 têm u=0 prescrito. Nós livres: 2,3,4 (n_livres=3). neq = 3 * 1 = 3. Matriz global será 3x3.",
                              "finalVerifications": [
                                "neq equals n_livres * GL_por_no ajustado.",
                                "Todos nós prescritos excluídos corretamente.",
                                "Tamanho da matriz global matches neq.",
                                "Contagem manual bate com fórmula.",
                                "Exemplo prático resolvido sem erros.",
                                "Documentação completa de nós e GL."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de neq (100% correto).",
                                "Identificação correta de 100% dos nós prescritos.",
                                "Substeps documentados com pelo menos 4 itens por step.",
                                "Verificações incluídas em cada step.",
                                "Tempo total dentro de 60 minutos.",
                                "Ausência de common mistakes identificados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Linear: Dimensão de vetores e matrizes em sistemas lineares.",
                                "Programação: Alocação de arrays em solvers FEA (ex: Python/NumPy).",
                                "Física: Conceitos de restrições cinemáticas em mecânica.",
                                "Computação Científica: Otimização de bandwidth em numeração nodal."
                              ],
                              "realWorldApplication": "Em software FEA como ANSYS ou Abaqus, neq determina o tamanho da matriz de rigidez global, impactando eficiência computacional em simulações de estruturas reais como pontes ou fuselagens de aviões."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "34.1.3.2.3",
                        "name": "Procedimento de Montagem das Matrizes Globais",
                        "description": "Algoritmo sistemático para acumular as contribuições elementares nas matrizes globais [K], [M] e {F}, utilizando loops sobre elementos e sobre os GL locais para adicionar K^e_ij em K_global_{lm} onde l,m são globais.",
                        "specificSkills": [
                          {
                            "id": "34.1.3.2.3.1",
                            "name": "Implementação do Algoritmo de Montagem em Pseudocódigo",
                            "description": "Escrever pseudocódigo para montagem: inicializar [K_global](neq,neq)=0, para cada elemento e: para i=1 a n_gl: para j=1 a n_gl: K( conn(e,i), conn(e,j) ) += K^e(i,j); similar para [M] e {F}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Pré-requisitos e Preparar Variáveis de Entrada",
                                  "subSteps": [
                                    "Defina neq como o número total de equações (graus de liberdade globais).",
                                    "Liste os elementos e sua conectividade conn(e,i), onde e é o elemento e i o nó local.",
                                    "Prepare matrizes elementares K^e, M^e e vetor F^e para cada elemento e.",
                                    "Crie uma lista de todos os elementos no modelo.",
                                    "Verifique dimensões: K^e é n_gl x n_gl, onde n_gl é graus de liberdade por elemento."
                                  ],
                                  "verification": "Crie um diagrama ou tabela resumindo neq, conectividade e dimensões das matrizes elementares.",
                                  "estimatedTime": "20-30 minutes",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Editor de texto para anotações",
                                    "Exemplo simples de malha 1D"
                                  ],
                                  "tips": "Use um exemplo pequeno (ex: 3 nós, 2 elementos) para visualizar conectividade.",
                                  "learningObjective": "Identificar e preparar todas as variáveis necessárias para a montagem.",
                                  "commonMistakes": [
                                    "Confundir nós locais com globais",
                                    "Ignorar dimensões inconsistentes",
                                    "Esquecer de listar todos os elementos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar Matrizes e Vetores Globais",
                                  "subSteps": [
                                    "Inicialize K_global como matriz neq x neq zerada.",
                                    "Inicialize M_global como matriz neq x neq zerada.",
                                    "Inicialize F_global como vetor neq x 1 zerado.",
                                    "Confirme que os índices vão de 1 a neq (ou 0-based se preferir, mas especifique).",
                                    "Escreva as linhas de pseudocódigo para inicialização."
                                  ],
                                  "verification": "Execute mentalmente ou em pseudocódigo: todas entradas devem ser zero.",
                                  "estimatedTime": "15-20 minutes",
                                  "materials": [
                                    "Editor de pseudocódigo",
                                    "Calculadora para dimensões pequenas"
                                  ],
                                  "tips": "Use loops ou funções de inicialização zero para grandes neq em implementações reais.",
                                  "learningObjective": "Garantir que as estruturas globais começam vazias para acumulação correta.",
                                  "commonMistakes": [
                                    "Inicializar com identidade em vez de zero",
                                    "Dimensões erradas (ex: neq+1)",
                                    "Esquecer M ou F"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Loop de Montagem para Matriz de Rigidez K_global",
                                  "subSteps": [
                                    "Inicie loop externo: para cada elemento e de 1 a num_elements.",
                                    "Dentro: para i=1 a n_gl: para j=1 a n_gl: K_global[conn(e,i), conn(e,j)] += K^e[i,j].",
                                    "Garanta que += acumule corretamente valores sobrepostos.",
                                    "Teste com um elemento: verifique se K_global recebe K^e nos índices corretos.",
                                    "Escreva pseudocódigo completo para este loop."
                                  ],
                                  "verification": "Para um exemplo com 1 elemento, K_global deve igualar K^e mapeado.",
                                  "estimatedTime": "30-40 minutes",
                                  "materials": [
                                    "Pseudocódigo editor",
                                    "Exemplo numérico com valores de K^e"
                                  ],
                                  "tips": "Aninhe loops com cuidado; i e j internos para evitar confusão.",
                                  "learningObjective": "Dominar o mapeamento local-global via conectividade para acumulação.",
                                  "commonMistakes": [
                                    "Usar = em vez de += causando sobrescrita",
                                    "Índices invertidos conn(e,i) vs conn(e,j)",
                                    "Loop errado em i/j"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estender Montagem para M_global e F_global",
                                  "subSteps": [
                                    "Copie estrutura do loop de K para M: M_global[conn(e,i), conn(e,j)] += M^e[i,j].",
                                    "Para F: para i=1 a n_gl: F_global[conn(e,i)] += F^e[i].",
                                    "Integre todos os loops em um único loop por elemento para eficiência.",
                                    "Escreva pseudocódigo unificado para K, M e F.",
                                    "Verifique simetria: K e M devem permanecer simétricos."
                                  ],
                                  "verification": "Simule com 2 elementos: confirme acumulação em nós compartilhados.",
                                  "estimatedTime": "25-35 minutes",
                                  "materials": [
                                    "Pseudocódigo completo",
                                    "Planilha para simulação manual"
                                  ],
                                  "tips": "F é vetor, então loop só em i, não j.",
                                  "learningObjective": "Adaptar o algoritmo para diferentes tipos de matrizes/vetores.",
                                  "commonMistakes": [
                                    "Tratar F como matriz",
                                    "Esquecer loop para F",
                                    "Perder simetria por indexação errada"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Finalizar o Pseudocódigo Completo",
                                  "subSteps": [
                                    "Adicione comentários explicativos em cada seção.",
                                    "Inclua tratamento de boundary conditions se aplicável (ex: zeros fixos).",
                                    "Teste com exemplo completo: calcule K_global manualmente e compare.",
                                    "Otimize pseudocódigo para legibilidade.",
                                    "Documente suposições (ex: 1-based indexing)."
                                  ],
                                  "verification": "Pseudocódigo roda sem erros lógicos em exemplo teste.",
                                  "estimatedTime": "20-30 minutes",
                                  "materials": [
                                    "Exemplo de teste completo",
                                    "Ferramenta de linting para pseudocódigo"
                                  ],
                                  "tips": "Sempre valide com caso trivial (1 elemento).",
                                  "learningObjective": "Produzir pseudocódigo robusto, comentado e verificável.",
                                  "commonMistakes": [
                                    "Falta de comentários",
                                    "Índices inconsistentes",
                                    "Ignorar condições de contorno"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma barra 1D com 3 nós (neq=3), 2 elementos. Elemento 1: nós 1-2, K^e1 = [[2,-1],[-1,1]]; Elemento 2: nós 2-3, K^e2 = [[1,-1],[-1,2]]. Após montagem: K_global = [[2, -1, 0], [-1, 2, -1], [0, -1, 2]]. Implemente pseudocódigo para gerar isso.",
                              "finalVerifications": [
                                "K_global, M_global inicializados como zero.",
                                "Loops corretos: externo em elementos, internos em DOFs locais.",
                                "Operador += usado para acumulação em posições conn(e,i), conn(e,j).",
                                "F_global acumula corretamente como vetor.",
                                "Pseudocódigo simétrico e lida com sobreposições.",
                                "Teste com exemplo pequeno produz matriz esperada."
                              ],
                              "assessmentCriteria": [
                                "Corretude dos loops e indexação (100% match com definição).",
                                "Clareza e legibilidade do pseudocódigo com comentários.",
                                "Tratamento completo de K, M e F.",
                                "Eficiência: loops aninhados otimizados.",
                                "Validação com exemplo numérico.",
                                "Ausência de erros comuns como sobrescrita."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Linear: Operações de matrizes esparsas e mapeamento.",
                                "Programação: Loops aninhados, indexação de arrays multidimensionais.",
                                "Computação Científica: Algoritmos numéricos em FEA.",
                                "Engenharia de Software: Pseudocódigo para implementação em Fortran/Python.",
                                "Física: Conservação de energia em montagem de rigidez/massa."
                              ],
                              "realWorldApplication": "Em softwares de Elementos Finitos como ANSYS ou Abaqus, este algoritmo monta matrizes globais para simulações de estruturas reais, como análise de tensões em pontes ou aviões, otimizando tempo de computação para milhões de DOFs."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.3.2.2.2"
                            ]
                          },
                          {
                            "id": "34.1.3.2.3.2",
                            "name": "Montagem Manual para Exemplo Simples de 2 Elementos",
                            "description": "Realizar montagem passo a passo para uma barra dividida em 2 elementos com 3 nós, somando [K^e1] e [K^e2] nas posições corretas para obter [K_global] 2x2 (após remoção de apoio).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar as Matrizes de Rigidez Elementares K^e1 e K^e2",
                                  "subSteps": [
                                    "Identifique os parâmetros de cada elemento: comprimento L, módulo de elasticidade E e área A para calcular EA/L.",
                                    "Calcule a matriz de rigidez local para o elemento 1 (nós 1-2): K^e1 = (EA/L) * [[1, -1], [-1, 1]].",
                                    "Calcule a matriz de rigidez local para o elemento 2 (nós 2-3): K^e2 = (EA/L) * [[1, -1], [-1, 1]].",
                                    "Anote os valores numéricos assumindo EA/L = 1 para simplicidade (ex: L=1 para ambos elementos).",
                                    "Verifique simetria e propriedades básicas das matrizes elementares."
                                  ],
                                  "verification": "Confirme que K^e1 e K^e2 são matrizes 2x2 simétricas com soma de linha zero.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel quadriculado, lápis, calculadora ou software como MATLAB/Octave.",
                                  "tips": "Use valores unitários (EA/L=1) para foco no procedimento de montagem.",
                                  "learningObjective": "Compreender o cálculo das matrizes de rigidez elementares em problemas 1D.",
                                  "commonMistakes": "Esquecer o sinal negativo nos termos fora da diagonal ou inverter E e A."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Topologia e Inicializar a Matriz Global K_global (3x3)",
                                  "subSteps": [
                                    "Desenhe o malha: 3 nós (1 fixo, 2 e 3 livres), 2 elementos (e1: nós 1-2, e2: nós 2-3).",
                                    "Inicialize K_global como matriz 3x3 zerada, correspondendo aos 3 graus de liberdade (ux1, ux2, ux3).",
                                    "Crie o mapa de conectividade: e1 contribui em dofs 1 e 2; e2 em dofs 2 e 3.",
                                    "Rotule as posições da matriz global claramente (linhas/colunas 1,2,3).",
                                    "Confirme que a matriz global terá tamanho igual ao número total de nós."
                                  ],
                                  "verification": "K_global é uma matriz 3x3 com todos zeros inicialmente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel quadriculado, lápis.",
                                  "tips": "Desenhe a malha linearmente para visualizar as sobreposições nos nós compartilhados.",
                                  "learningObjective": "Estabelecer a estrutura da matriz global baseada na conectividade dos elementos.",
                                  "commonMistakes": "Confundir ordem dos nós ou inicializar com tamanho errado (ex: 2x2 prematuramente)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Montar a Contribuição do Elemento 1 (K^e1) na Matriz Global",
                                  "subSteps": [
                                    "Posicione K^e1 nas linhas/colunas 1 e 2 de K_global.",
                                    "Adicione: K_global[1,1] += K^e1[1,1], K_global[1,2] += K^e1[1,2], etc.",
                                    "Exemplo numérico (EA/L=1): K_global[1,1]=1, [1,2]=-1, [2,1]=-1, [2,2]=1.",
                                    "Verifique que as posições não sobrepostas permaneçam inalteradas.",
                                    "Anote as contribuições explicitamente."
                                  ],
                                  "verification": "Posições 1-2 de K_global coincidem exatamente com K^e1.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel quadriculado com K_global inicial, lápis.",
                                  "tips": "Use seta para indicar 'expansão' da matriz 2x2 para as posições globais.",
                                  "learningObjective": "Executar montagem direta de um elemento nas posições corretas.",
                                  "commonMistakes": "Adicionar em posições erradas (ex: confundir nó 1 com nó 3)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar a Contribuição do Elemento 2 (K^e2) e Completar K_global 3x3",
                                  "subSteps": [
                                    "Posicione K^e2 nas linhas/colunas 2 e 3 de K_global.",
                                    "Adicione: K_global[2,2] += K^e2[1,1] (sobrepõe com K^e1), K_global[2,3] += K^e2[1,2], etc.",
                                    "Exemplo: K_global[2,2]=2, [2,3]=-1, [3,2]=-1, [3,3]=1.",
                                    "Confirme sobreposição em [2,2] (soma das contribuições).",
                                    "Escreva a matriz K_global completa: [[1,-1,0],[-1,2,-1],[0,-1,1]]."
                                  ],
                                  "verification": "K_global[2,2] é soma de contribuições de ambos elementos; matriz simétrica.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel quadriculado com K_global parcial.",
                                  "tips": "Realce as sobreposições em negrito para visualização.",
                                  "learningObjective": "Gerenciar sobreposições de rigidez em nós compartilhados.",
                                  "commonMistakes": "Esquecer de somar na diagonal compartilhada ou perder simetria."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar Remoção de Apoio para Obter K_global Reduzida 2x2",
                                  "subSteps": [
                                    "Identifique o apoio fixo (nó 1, ux1=0).",
                                    "Remova linha e coluna 1 de K_global 3x3 para obter submatriz 2x2 dos dofs livres (2 e 3).",
                                    "Resultado: [[2, -1], [-1, 1]].",
                                    "Verifique partição: linhas/colunas 2-3.",
                                    "Confirme que a matriz reduzida mantém propriedades (simetria, positiva definida)."
                                  ],
                                  "verification": "K_reduzida 2x2 corresponde às posições [2:3,2:3] da original.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel quadriculado.",
                                  "tips": "Marque dofs fixos com 'X' antes de remover.",
                                  "learningObjective": "Aplicar condições de contorno Dirichlet via remoção de dofs.",
                                  "commonMistakes": "Remover dofs errados ou esquecer de manter simetria."
                                }
                              ],
                              "practicalExample": "Para uma barra de comprimento total 2m, EA=1 (unitário), dividida em 2 elementos de 1m cada: K^e1 = K^e2 = [[1,-1],[-1,1]]. Após montagem: K_global 3x3 = [[1,-1,0],[-1,2,-1],[0,-1,1]]. Com nó 1 fixo, K_global 2x2 = [[2,-1],[-1,1]].",
                              "finalVerifications": [
                                "K_global 3x3 é simétrica e tem soma zero por linha.",
                                "Posição [2,2] soma contribuições de ambos elementos.",
                                "K_reduzida 2x2 tem determinante positivo.",
                                "Nenhuma contribuição fora das posições conectadas.",
                                "Valores diagonais positivos, fora-diagonal negativos.",
                                "Correspondência exata com exemplo numérico fornecido."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de K^e1 e K^e2 (erro <1%).",
                                "Correta identificação de conectividade e sobreposições.",
                                "Simetria mantida em todas as matrizes.",
                                "Aplicação correta de remoção de apoio.",
                                "Explicação clara do procedimento em 3-5 frases.",
                                "Tempo total dentro de 75 minutos com acurácia."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (montagem matricial, partição).",
                                "Programação: Implementação em loops para automontagem (Python/MATLAB).",
                                "Física: Equilíbrio de forças em estruturas 1D.",
                                "Engenharia de Software: Verificação numérica de simetria."
                              ],
                              "realWorldApplication": "Na análise de estruturas como vigas ou cabos em pontes e edifícios, onde o MEF manual valida simulações computacionais em softwares como ANSYS, garantindo precisão em projetos de engenharia civil e mecânica."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.3.2.1.1",
                              "34.1.3.2.2.1"
                            ]
                          },
                          {
                            "id": "34.1.3.2.3.3",
                            "name": "Verificação da Montagem Global",
                            "description": "Verificar propriedades das matrizes globais montadas, como simetria, banda-esparsidade, partição de energia e equilíbrio nodal de forças.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Verificar Simetria da Matriz de Rigidez Global",
                                  "subSteps": [
                                    "Extraia a matriz de rigidez global K da montagem.",
                                    "Calcule a transposta de K (K^T).",
                                    "Compare elemento a elemento: K[i,j] deve igualar K[j,i] para todo i,j.",
                                    "Confirme que a diferença K - K^T é a matriz nula.",
                                    "Registre quaisquer assimetrias detectadas."
                                  ],
                                  "verification": "A matriz K - K^T resulta em todos os elementos zero (tolerância numérica 1e-10).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matriz K global computada",
                                    "Software de álgebra linear (MATLAB/Python) ou papel e caneta"
                                  ],
                                  "tips": [
                                    "Use funções prontas como issymmetric() no MATLAB para agilizar.",
                                    "Verifique índices de nós conectados para simetria física."
                                  ],
                                  "learningObjective": "Entender e validar a propriedade de simetria inerente à formulação de elementos finitos.",
                                  "commonMistakes": [
                                    "Ignorar tolerâncias numéricas em computações flutuantes.",
                                    "Confundir rigidez com massa (que pode não ser simétrica)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar Banda-Esparsidade da Matriz Global",
                                  "subSteps": [
                                    "Identifique o padrão de não-nulos na matriz K baseado na conectividade nodal.",
                                    "Determine a largura de banda semi-largura (half-bandwidth) a partir do número máximo de nós conectados.",
                                    "Confirme que elementos fora da banda (K[i,j] onde |i-j| > largura) são zero.",
                                    "Visualize a estrutura esparsa usando spy plot ou diagrama.",
                                    "Calcule o número de não-nulos e compare com o esperado."
                                  ],
                                  "verification": "Todos os elementos fora da largura de banda são zero; número de não-nulos matches previsão teórica.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Matriz K global",
                                    "Ferramenta de visualização esparsa (spy() no MATLAB ou seaborn heatmap)"
                                  ],
                                  "tips": [
                                    "Numere nós sequencialmente para minimizar largura de banda.",
                                    "Use formatos esparsos (COO, CSR) para eficiência."
                                  ],
                                  "learningObjective": "Reconhecer e validar a estrutura esparsa que otimiza armazenamento e solução em EF.",
                                  "commonMistakes": [
                                    "Sobreestimar largura de banda ignorando renumeração ótima.",
                                    "Preencher zeros desnecessariamente em implementação."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar Partição de Energia",
                                  "subSteps": [
                                    "Calcule a energia de deformação elementar para cada elemento: (1/2) u_e^T K_e u_e.",
                                    "Some as energias elementares para obter energia total elementar.",
                                    "Calcule energia global: (1/2) u^T K u.",
                                    "Compare as duas energias; devem ser iguais dentro de tolerância.",
                                    "Analise distribuição percentual de energia por elemento."
                                  ],
                                  "verification": "Energia global = soma das energias elementares (erro < 1e-8).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Vetores de deslocamento u nodal e elementar",
                                    "Matrizes K_e e K global"
                                  ],
                                  "tips": [
                                    "Use deslocamentos arbitrários não-triviais para teste (ex: u = [1,2,3,...]).",
                                    "Verifique ortogonalidade em modos."
                                  ],
                                  "learningObjective": "Validar conservação de energia na montagem de matrizes EF.",
                                  "commonMistakes": [
                                    "Usar deslocamentos nulos (trivial).",
                                    "Esquecer fator 1/2 na energia."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Equilíbrio Nodal de Forças",
                                  "subSteps": [
                                    "Monte o vetor de forças nodais globais F a partir de contribuições elementares.",
                                    "Para ausência de cargas externas, verifique se soma de forças em cada nó é zero.",
                                    "Aplique deslocamentos conhecidos e compute forças reativas: F = K u.",
                                    "Compare forças computadas com equilíbrio esperado (ex: soma F_i = 0 por nó).",
                                    "Cheque equilíbrio global: soma total de forças = zero."
                                  ],
                                  "verification": "Soma de forças por nó = 0 (ou valor esperado); F = K u holds.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Matriz K global",
                                    "Vetores u e F",
                                    "Conhecimentos de condições de contorno"
                                  ],
                                  "tips": [
                                    "Teste com u unitário em um DOF por vez.",
                                    "Inclua reações em nós suportados."
                                  ],
                                  "learningObjective": "Garantir equilíbrio estático na formulação EF.",
                                  "commonMistakes": [
                                    "Esquecer forças de reação em nós fixos.",
                                    "Não somar contribuições de elementos adjacentes."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma barra 1D com 3 elementos e 4 nós, monte K global 4x4. Verifique: simetria (K12=K21=0.5), banda largura 2, energia total 1.5 J = soma elementar, forças em nó interno somam 0 para u=[1,0.5,0,0].",
                              "finalVerifications": [
                                "Simetria confirmada para toda K.",
                                "Estrutura de banda matches conectividade.",
                                "Energia particionada corretamente.",
                                "Equilíbrio nodal em todos os nós.",
                                "Número total de não-nulos correto.",
                                "Tolerâncias numéricas respeitadas.",
                                "Visualizações geradas e salvas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de propriedades (100% match).",
                                "Eficiência computacional demonstrada.",
                                "Interpretação física das verificações.",
                                "Documentação clara de resultados.",
                                "Tratamento de erros numéricos.",
                                "Uso apropriado de ferramentas."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Propriedades de matrizes simétricas e esparsas.",
                                "Programação: Manipulação de arrays e visualização (NumPy/MATLAB).",
                                "Física: Princípios de equilíbrio e conservação de energia.",
                                "Matemática Numérica: Tolerâncias e estabilidade.",
                                "Engenharia de Software: Validação de código EF."
                              ],
                              "realWorldApplication": "Em simulações de estruturas como vigas de pontes ou fuselagens de aviões, essas verificações previnem erros na predição de tensões, evitando falhas catastróficas em projetos reais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.3.2.3.1"
                            ]
                          },
                          {
                            "id": "34.1.3.2.3.4",
                            "name": "Tratamento de Condições de Contorno na Montagem",
                            "description": "Aplicar modificações na montagem para nós suportados, como zerar linhas/colunas correspondentes e definir deslocamentos prescritos no vetor {F}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar Nós com Condições de Contorno",
                                  "subSteps": [
                                    "Analise o problema 1D e liste todos os nós envolvidos.",
                                    "Classifique cada condição: deslocamento zero (suportado) ou prescrito (valor específico).",
                                    "Mapeie os graus de liberdade (GL) afetados (ex: u1=0 para nó 1).",
                                    "Registre os índices das linhas/colunas na matriz global K.",
                                    "Crie uma tabela de referência para nós livres vs. suportados."
                                  ],
                                  "verification": "Verifique se todos os nós suportados estão listados com GL corretos e sem duplicatas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Diagrama do problema, papel ou software de edição (Excel/MATLAB).",
                                  "tips": "Comece pelos extremos da estrutura, comuns em suportes.",
                                  "learningObjective": "Reconhecer e catalogar condições de contorno em problemas de EF 1D.",
                                  "commonMistakes": "Confundir nós livres com suportados ou ignorar GL múltiplos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Zerar Linhas e Colunas da Matriz de Rigidez Global",
                                  "subSteps": [
                                    "Inicialize a matriz K global com zeros.",
                                    "Para cada GL suportado com u=0, defina K[i,i]=1 e zero outras entradas na linha i e coluna i.",
                                    "Mantenha simetria zerando K[j,i] e K[i,j] simultaneamente.",
                                    "Some as contribuições elementares apenas para nós livres.",
                                    "Confirme que linhas/colunas zeradas não afetam equações livres."
                                  ],
                                  "verification": "A matriz K deve ter linhas/colunas unitárias diagonais para GL suportados e zeros fora.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Matriz K elementar pré-montada, calculadora matricial ou Python/MATLAB.",
                                  "tips": "Use loops em código para automação em problemas maiores.",
                                  "learningObjective": "Implementar penalização por zeramento na montagem da matriz K.",
                                  "commonMistakes": "Esquecer de zerar ambas linha e coluna, quebrando simetria."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Deslocamentos Prescritos no Vetor de Forças",
                                  "subSteps": [
                                    "Inicialize vetor F global com forças nodais conhecidas.",
                                    "Para cada GL prescrito u_i = valor conhecido, defina F[i] = valor * K[i,i] (geralmente 1*valor).",
                                    "Mova forças reativas para o lado direito se necessário.",
                                    "Atualize F apenas para posições de GL suportados.",
                                    "Verifique equilíbrio: soma de forças deve respeitar estática."
                                  ],
                                  "verification": "Vetor F deve ter valores prescritos nas posições corretas de GL suportados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Vetor F inicial, matriz K modificada.",
                                  "tips": "Lembre: para u_i prescrito, F_i = u_i (se K[i,i]=1).",
                                  "learningObjective": "Incorporar condições essenciais no vetor de cargas.",
                                  "commonMistakes": "Aplicar prescrição em nós livres ou inverter sinal."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Resolver o Sistema Modificado",
                                  "subSteps": [
                                    "Resolva K_reduzida * u_livres = F_livres.",
                                    "Preencha u_suportados com valores conhecidos.",
                                    "Calcule reações: R = K * u - F_externo.",
                                    "Compare com solução analítica se disponível.",
                                    "Gere gráfico de deslocamentos/forças."
                                  ],
                                  "verification": "Solução deve satisfazer todas condições de contorno e equilíbrio.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Solver linear (MATLAB, NumPy), software de plotagem.",
                                  "tips": "Reduza o sistema eliminando linhas suportadas para eficiência.",
                                  "learningObjective": "Garantir integridade da montagem com condições de contorno.",
                                  "commonMistakes": "Resolver sistema completo sem redução, levando a singularidade."
                                }
                              ],
                              "practicalExample": "Em uma barra 1D com 3 nós (2 elementos), nó 1 fixo (u1=0), nó 3 com u3=0.01m prescrito, força F2=100N no nó 2. Monte K 3x3: zero linha/coluna 1, defina K[3,3]=1 e F[3]=0.01, resolva para u2.",
                              "finalVerifications": [
                                "Matriz K tem linhas/colunas zeradas ou unitárias para todos GL suportados.",
                                "Vetor F incorpora corretamente deslocamentos prescritos.",
                                "Solução u satisfaz u_suportados = valores conhecidos.",
                                "Reações calculadas equilibram forças aplicadas.",
                                "Erro em relação a solução analítica < 1%.",
                                "Simetria de K preservada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de GL suportados (100% corretos).",
                                "Correta modificação de K (sem erros de indexação).",
                                "Integração precisa de prescrições em F.",
                                "Validação quantitativa com métricas de erro.",
                                "Explicação clara de cada modificação.",
                                "Eficiência computacional demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Linear: Manipulação de matrizes singulares e redução de sistemas.",
                                "Programação: Implementação em loops para montagem automatizada (Python/MATLAB).",
                                "Física: Princípios de equilíbrio estático em estruturas.",
                                "Engenharia de Software: Tratamento de condições de contorno em solvers numéricos."
                              ],
                              "realWorldApplication": "Na análise de vigas em pontes ou edifícios via software como ANSYS, onde suportes fixos e deslocamentos impostos (ex: assentamentos diferenciais) são tratados na montagem global para prever tensões e deformações reais."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.3.2.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.3",
                    "name": "Treliças planas",
                    "description": "Formulação do elemento de treliça plana, incluindo graus de liberdade e montagem do sistema global.",
                    "individualConcepts": [
                      {
                        "id": "34.1.1.1",
                        "name": "Geometria e Graus de Liberdade do Elemento de Treliça Plana",
                        "description": "Compreensão da configuração geométrica do elemento de treliça plana, composto por dois nós em um plano 2D, com dois graus de liberdade por nó (deslocamento axial u e transversal v, ou ux e uy nas coordenadas globais).",
                        "specificSkills": [
                          {
                            "id": "34.1.1.1.1",
                            "name": "Identificar os graus de liberdade nodais",
                            "description": "Reconhecer e listar os dois graus de liberdade por nó (ux e uy) para um elemento de treliça plana, diferenciando coordenadas locais (axial e transversal) das globais (x e y).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os conceitos básicos de graus de liberdade em nós estruturais 2D",
                                  "subSteps": [
                                    "Defina grau de liberdade (GL) como os deslocamentos independentes possíveis em um nó.",
                                    "Identifique que em problemas planares 2D, cada nó livre tem tipicamente 2 GLs: deslocamento horizontal (ux) e vertical (uy).",
                                    "Revise exemplos simples de nós em estruturas como vigas ou frames.",
                                    "Diferencie nós livres de nós fixos ou com restrições.",
                                    "Anote a importância dos GLs na formulação do Método dos Elementos Finitos (MEF)."
                                  ],
                                  "verification": "Crie um diagrama de um nó 2D isolado e rotule ux e uy corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro-texto de MEF (capítulo inicial sobre GLs)",
                                    "Vídeo tutorial sobre graus de liberdade em estruturas 2D"
                                  ],
                                  "tips": "Use setas para representar direções de ux (horizontal) e uy (vertical) no plano xy.",
                                  "learningObjective": "Compreender que cada nó em treliça plana tem 2 GLs globais: ux e uy.",
                                  "commonMistakes": [
                                    "Confundir GLs com rotações (que são para elementos 2D com rigidez flexural)",
                                    "Ignorar que nós conectados compartilham GLs no modelo global"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o sistema de coordenadas global (x-y) para treliças planas",
                                  "subSteps": [
                                    "Desenhe um plano cartesiano global com eixos x horizontal e y vertical.",
                                    "Posicione um elemento de treliça simples entre dois nós (ex: nó i em (0,0) e nó j em (L,0)).",
                                    "Liste os GLs globais para os dois nós: nó i (ux_i, uy_i), nó j (ux_j, uy_j).",
                                    "Explique que no MEF, o vetor de GLs do elemento é {ux_i, uy_i, ux_j, uy_j}.",
                                    "Verifique com um sketch: 4 GLs totais para o elemento."
                                  ],
                                  "verification": "Esboce o elemento e liste os 4 GLs globais com labels corretos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software de desenho como GeoGebra ou SketchUp gratuito"
                                  ],
                                  "tips": "Sempre oriente x para a direita e y para cima, conforme convenção padrão.",
                                  "learningObjective": "Reconhecer os GLs nodais no sistema global x-y para um elemento de treliça.",
                                  "commonMistakes": [
                                    "Rotular uy como rotação",
                                    "Esquecer GLs de ambos os nós"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar coordenadas locais (axial e transversal) das globais",
                                  "subSteps": [
                                    "Defina coordenadas locais para treliça: eixo axial (ao longo do elemento, u_axial) e transversal (perpendicular, u_transv).",
                                    "Calcule o ângulo θ do elemento em relação ao eixo x global.",
                                    "Desenvolva a matriz de transformação de GLs locais para globais: {u_axial, u_transv} = T * {ux, uy}.",
                                    "Note que treliças só resistem axialmente, então u_transv é desprezado na rigidez, mas GLs locais ajudam na formulação.",
                                    "Compare: globais são fixos (x,y); locais rotacionam com o elemento."
                                  ],
                                  "verification": "Para um elemento inclinado 45°, escreva as relações entre ux/uy e u_axial/u_transv.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Planilha Excel para matriz de rotação",
                                    "Referência: equação de transformação de coordenadas em MEF"
                                  ],
                                  "tips": "Lembre: cosθ = (xj - xi)/L; sinθ = (yj - yi)/L para θ.",
                                  "learningObjective": "Diferenciar e relacionar GLs locais (axial/transversal) com globais (ux/uy).",
                                  "commonMistakes": [
                                    "Confundir axial com x-global",
                                    "Esquecer a dependência de θ na transformação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Listar e identificar todos os graus de liberdade nodais de um elemento de treliça",
                                  "subSteps": [
                                    "Selecione um elemento arbitrário com nós i e j em posições dadas.",
                                    "Liste explicitamente: GLs globais - ux_i, uy_i, ux_j, uy_j (2 por nó).",
                                    "Identifique GLs locais equivalentes para cada nó.",
                                    "Monte o vetor de GLs do elemento: d = [ux_i, uy_i, ux_j, uy_j]^T.",
                                    "Pratique com 2-3 geometrias diferentes (horizontal, vertical, inclinada)."
                                  ],
                                  "verification": "Para um dado elemento, liste corretamente os 4 GLs e especifique locais vs globais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplos impressos de treliças",
                                    "Software FEA gratuito como FreeCAD para visualização"
                                  ],
                                  "tips": "Sempre comece pelos nós: 2 GLs cada, total 4 por elemento.",
                                  "learningObjective": "Listar com precisão os dois GLs por nó e diferenciá-los.",
                                  "commonMistakes": [
                                    "Listar apenas 1 GL por nó",
                                    "Incluir rotações θ em treliças"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um elemento de treliça plana entre nó i (0,0) e nó j (3m,4m). GLs globais: ux_i, uy_i (nó i); ux_j, uy_j (nó j). Comprimento L=5m, θ=tan^{-1}(4/3)≈53°. GLs locais no nó i: u_axial_i (direção do elemento), u_transv_i (perpendicular); transforme via matriz [cosθ, sinθ; -sinθ, cosθ].",
                              "finalVerifications": [
                                "Lista corretamente ux e uy para cada nó de um elemento dado.",
                                "Diferencia coordenadas globais x-y de locais axial-transversal.",
                                "Identifica 2 GLs por nó, totalizando 4 por elemento de treliça.",
                                "Esboça diagrama com labels precisos de todos GLs.",
                                "Explica a transformação de coordenadas para um ângulo específico.",
                                "Reconhece ausência de rotações em treliças planas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de ux/uy como os únicos 2 GLs por nó (100% correto).",
                                "Correta diferenciação entre sistemas global e local com exemplo de transformação.",
                                "Diagrama claro e rotulado sem erros de convenção.",
                                "Explicação concisa da relevância no MEF (vetor de deslocamentos).",
                                "Capacidade de aplicar a elementos inclinados (>90% acurácia).",
                                "Ausência de inclusão de GLs extras como rotações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Vetores, matrizes de rotação e transformações lineares.",
                                "Física: Estática de partículas e equilíbrio nodal em 2D.",
                                "Programação: Implementação de loops para montar vetores de GLs em código FEA (Python/MATLAB).",
                                "Geometria: Cálculo de ângulos e comprimentos em triângulos.",
                                "Desenho Técnico: Representação esquemática de estruturas e anotações."
                              ],
                              "realWorldApplication": "Em análises de pontes treliçadas (ex: ponte Golden Gate) ou telhados industriais, identificar GLs nodais é essencial para montar o modelo FEA global, prever deformações sob carga e otimizar o design contra colapso."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.1.1.1.2",
                            "name": "Definir a geometria do elemento",
                            "description": "Descrever o comprimento L, ângulo θ de orientação e posições nodais (x1,y1 e x2,y2) de um elemento de treliça plana, calculando cosθ = (x2-x1)/L e senθ = (y2-y1)/L.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar as posições nodais do elemento",
                                  "subSteps": [
                                    "Localize o nó 1 com coordenadas (x1, y1) no diagrama da treliça.",
                                    "Localize o nó 2 com coordenadas (x2, y2) no mesmo diagrama.",
                                    "Registre as coordenadas em uma tabela ou sketch para visualização clara.",
                                    "Confirme que as coordenadas estão em unidades consistentes (ex: metros).",
                                    "Desenhe o elemento conectando os nós para visualizar a orientação."
                                  ],
                                  "verification": "Verifique se as coordenadas (x1,y1) e (x2,y2) estão corretamente anotadas e coincidem com o diagrama fornecido.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Diagrama da treliça",
                                    "Papel quadriculado",
                                    "Lápis e borracha"
                                  ],
                                  "tips": "Sempre rotule os nós claramente para evitar confusão em treliças complexas.",
                                  "learningObjective": "Compreender a importância das posições nodais como base para cálculos geométricos.",
                                  "commonMistakes": "Confundir nó 1 com nó 2; usar coordenadas erradas do diagrama."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o comprimento L do elemento",
                                  "subSteps": [
                                    "Calcule a diferença Δx = x2 - x1.",
                                    "Calcule a diferença Δy = y2 - y1.",
                                    "Aplique a fórmula L = √(Δx² + Δy²).",
                                    "Arredonde L para precisão adequada (ex: 3 casas decimais).",
                                    "Anote L com unidade e verifique se é positivo."
                                  ],
                                  "verification": "Confirme que L corresponde à distância euclidiana entre os nós usando uma calculadora ou software.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Folha de cálculo (Excel ou papel)"
                                  ],
                                  "tips": "Use a fórmula pitagórica mentalmente para estimar antes de calcular exatamente.",
                                  "learningObjective": "Dominar o cálculo do comprimento usando geometria cartesiana.",
                                  "commonMistakes": "Esquecer a raiz quadrada; calcular |Δx| + |Δy| em vez de √(Δx² + Δy²)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar o ângulo de orientação θ e os cossenos diretores",
                                  "subSteps": [
                                    "Calcule cosθ = Δx / L.",
                                    "Calcule senθ = Δy / L.",
                                    "Verifique se cos²θ + sen²θ = 1 (propriedade trigonométrica).",
                                    "Calcule θ = atan2(Δy, Δx) em graus ou radianos se necessário.",
                                    "Registre cosθ e senθ com precisão adequada."
                                  ],
                                  "verification": "Teste a identidade cos²θ + sen²θ ≈ 1 (erro < 0.001 devido a arredondamentos).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Tabela trigonométrica opcional"
                                  ],
                                  "tips": "Use atan2 para ângulos corretos em todos os quadrantes.",
                                  "learningObjective": "Aplicar trigonometria para definir orientação do elemento.",
                                  "commonMistakes": "Usar θ diretamente sem cossenos; inverter Δx e Δy."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir e documentar a geometria completa do elemento",
                                  "subSteps": [
                                    "Compile todos os valores: posições nodais, L, cosθ, senθ.",
                                    "Crie um resumo ou tabela com todos os parâmetros.",
                                    "Desenhe o elemento com vetor direção e rótulos.",
                                    "Compare com um exemplo conhecido para validação.",
                                    "Prepare para uso em próximos passos (ex: matriz de rigidez)."
                                  ],
                                  "verification": "Gere um sketch ou tabela que inclua todos os parâmetros corretamente calculados.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel para sketch",
                                    "Software de desenho vetorial opcional (ex: GeoGebra)"
                                  ],
                                  "tips": "Mantenha consistência de unidades em todo o documento.",
                                  "learningObjective": "Integrar todos os cálculos em uma definição geométrica coesa.",
                                  "commonMistakes": "Omitir verificação da identidade trigonométrica; inconsistências de unidades."
                                }
                              ],
                              "practicalExample": "Para um elemento com nó 1 em (0,0) e nó 2 em (3,4): L = √(3² + 4²) = 5 m; cosθ = 3/5 = 0.6; senθ = 4/5 = 0.8. Verifique: 0.6² + 0.8² = 1.",
                              "finalVerifications": [
                                "Comprimento L calculado corretamente como distância euclidiana.",
                                "cosθ = (x2 - x1)/L e senθ = (y2 - y1)/L exatos.",
                                "Identidade cos²θ + sen²θ = 1 satisfeita.",
                                "Posições nodais corretamente identificadas e rotuladas.",
                                "Unidades consistentes em todos os valores.",
                                "Sketch do elemento com orientação visualizada."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos (erro < 0.1%).",
                                "Correta aplicação das fórmulas de L, cosθ e senθ.",
                                "Verificação da identidade trigonométrica realizada.",
                                "Clareza na documentação e rotulagem.",
                                "Identificação correta de erros comuns evitados.",
                                "Integração coerente com contexto da treliça plana."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Trigonometria e geometria analítica.",
                                "Física: Vetores e componentes direcionais em mecânica.",
                                "Programação: Implementação em scripts para MEF (ex: Python/MATLAB).",
                                "Desenho Técnico: Representação gráfica de elementos estruturais."
                              ],
                              "realWorldApplication": "Em projetos de engenharia civil, define a geometria de barras em treliças de pontes ou telhados, essencial para análise de elementos finitos em softwares como ANSYS ou SAP2000, garantindo estabilidade estrutural."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.1.1.1.3",
                            "name": "Relacionar deformação e deslocamentos",
                            "description": "Estabelecer a relação entre a deformação axial ε = (u2 - u1)/L e os deslocamentos nodais nos eixos locais, considerando apenas deformação uniaxial em treliças.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de deslocamento e deformação axial",
                                  "subSteps": [
                                    "Defina deslocamento nodal como o movimento de um nó em um elemento finito.",
                                    "Explique deformação axial ε como a variação relativa de comprimento: ε = ΔL / L.",
                                    "Identifique que em treliças, considera-se apenas deformação uniaxial ao longo do eixo do elemento.",
                                    "Diferencie deslocamentos globais (x,y) de locais (ao longo do elemento).",
                                    "Revise a fórmula básica ε = (u2 - u1)/L, onde u1 e u2 são deslocamentos axiais nos nós."
                                  ],
                                  "verification": "Escreva as definições e fórmula em um papel e compare com referências padrão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Elementos Finitos (ex: Bathe), caderno e caneta.",
                                  "tips": "Use diagramas simples para visualizar um elemento esticado.",
                                  "learningObjective": "Dominar as definições básicas de deslocamento e deformação em contexto 1D.",
                                  "commonMistakes": "Confundir deformação com deslocamento absoluto; ignorar que ε é adimensional."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o sistema de coordenadas local para o elemento de treliça",
                                  "subSteps": [
                                    "Desenhe um elemento de treliça plana com nós 1 e 2, comprimento L.",
                                    "Estabeleça o eixo local x' alinhado com o elemento, de nó 1 para nó 2.",
                                    "Calcule o ângulo θ do eixo local em relação ao global x: cosθ = (x2 - x1)/L, senθ = (y2 - y1)/L.",
                                    "Identifique graus de liberdade: u1' e u2' como componentes locais dos deslocamentos nodais.",
                                    "Confirme que deformação é apenas axial, ignorando rotações ou cisalhamento."
                                  ],
                                  "verification": "Desenhe o elemento com coordenadas e rotule θ corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel milimetrado, régua, calculadora.",
                                  "tips": "Sempre oriente o eixo local do nó 1 para o nó 2 para consistência.",
                                  "learningObjective": "Configurar corretamente o sistema local para projeção de deslocamentos.",
                                  "commonMistakes": "Erro no sinal de θ; confundir nós 1 e 2."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar deslocamentos globais nos eixos locais",
                                  "subSteps": [
                                    "Anote deslocamentos globais: u1x, u1y no nó 1; u2x, u2y no nó 2.",
                                    "Projete para local: u1' = u1x * cosθ + u1y * senθ.",
                                    "Para nó 2: u2' = u2x * cosθ + u2y * senθ.",
                                    "Verifique que u1' e u2' representam deslocamentos ao longo do eixo do elemento.",
                                    "Discuta que apenas a componente axial contribui para ε em treliças."
                                  ],
                                  "verification": "Calcule u1' e u2' para um exemplo numérico simples e confira manualmente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora, software como MATLAB ou Python para verificação opcional.",
                                  "tips": "Lembre-se: matriz de rotação [T] = [cosθ, senθ; -senθ, cosθ] para transformação.",
                                  "learningObjective": "Aplicar transformação de coordenadas para obter deslocamentos locais.",
                                  "commonMistakes": "Usar seno em vez de cosseno; esquecer sinais na projeção."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar e aplicar a relação entre deformação e deslocamentos",
                                  "subSteps": [
                                    "Estabeleça ε = (u2' - u1') / L diretamente da definição de deformação média.",
                                    "Substitua u1' e u2' pelas expressões globais para obter ε em termos de u globais.",
                                    "Simplifique assumindo deformação uniaxial: ε depende apenas da diferença axial.",
                                    "Teste com L constante e verifique dimensionalidade (ε adimensional).",
                                    "Discuta aproximações lineares do Método dos Elementos Finitos (MEF)."
                                  ],
                                  "verification": "Derive a fórmula completa e compute ε para um caso dado.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Folha de derivação, exemplos de treliças.",
                                  "tips": "Use vetores unitários para visualização geométrica da projeção.",
                                  "learningObjective": "Estabelecer matematicamente a relação ε = (u2' - u1')/L.",
                                  "commonMistakes": "Dividir por L incorreto; incluir componentes transversais em ε."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e praticar com exemplo numérico",
                                  "subSteps": [
                                    "Monte um elemento com L=2m, θ=30°, deslocamentos globais dados.",
                                    "Calcule u1', u2', então ε.",
                                    "Compare com deformação esperada de um alongamento conhecido.",
                                    "Analise sensibilidade a erros em θ ou deslocamentos.",
                                    "Registre o processo em um relatório curto."
                                  ],
                                  "verification": "Resultado de ε coincide com valor analítico dentro de 1% de erro.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora ou Excel.",
                                  "tips": "Comece com θ=0° para validar antes de ângulos gerais.",
                                  "learningObjective": "Aplicar a relação em prática e validar resultados.",
                                  "commonMistakes": "Erros aritméticos em trigonométricas; unidades inconsistentes."
                                }
                              ],
                              "practicalExample": "Considere um elemento de treliça de nó 1 (0,0) a nó 2 (3,4), L=5m, θ=53.13°. Deslocamentos globais: nó1 (0.01,0)m, nó2 (0.04,0.03)m. Calcule cosθ=0.6, senθ=0.8; u1'=0.01*0.6 + 0*0.8=0.006m; u2'=0.04*0.6 + 0.03*0.8=0.042m; ε=(0.042-0.006)/5=0.0072 ou 0.72%.",
                              "finalVerifications": [
                                "Derivar corretamente ε = (u2' - u1')/L a partir de deslocamentos globais.",
                                "Calcular u' locais com precisão para θ arbitrário.",
                                "Identificar que apenas componente axial afeta ε em treliças.",
                                "Verificar dimensionalidade e unidades corretas.",
                                "Aplicar em exemplo numérico com erro <1%.",
                                "Explicar geometricamente a projeção de deslocamentos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da fórmula (100% correto).",
                                "Correta transformação de coordenadas locais/globais.",
                                "Compreensão conceitual de uniaxialidade em treliças.",
                                "Habilidade em cálculos numéricos sem erros aritméticos.",
                                "Capacidade de identificar e corrigir erros comuns.",
                                "Clareza na explicação escrita ou verbal da relação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Vetores, funções trigonométricas e álgebra linear (matrizes de rotação).",
                                "Física: Mecânica dos sólidos, conceito de deformação strain em materiais.",
                                "Programação: Implementação em códigos FEM (ex: Python com NumPy para matriz [B]).",
                                "Geometria: Projeções ortogonais e sistemas de coordenadas rotacionados."
                              ],
                              "realWorldApplication": "Em software de análise estrutural como ANSYS ou SAP2000, essa relação é usada para montar a matriz de rigidez de treliças em pontes, edifícios e torres, permitindo simular deformações sob cargas reais e prever falhas estruturais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "34.1.1.2",
                        "name": "Formulação da Matriz de Rigidez Local",
                        "description": "Derivação da matriz de rigidez [k_local] para o elemento de treliça plana nas coordenadas locais, baseada na relação tensão-deformação σ = E ε e equilíbrio de forças.",
                        "specificSkills": [
                          {
                            "id": "34.1.1.2.1",
                            "name": "Derivar a matriz de rigidez local",
                            "description": "Calcular a matriz [k_local] = (AE/L) * [[1, -1], [-1, 1]], onde A é a área da seção, E o módulo de elasticidade e L o comprimento, usando o princípio da energia potencial ou método de Galerkin.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o elemento de treliça 1D e definir funções de forma",
                                  "subSteps": [
                                    "Defina o elemento de treliça como uma barra axial com dois nós, cada um com um grau de liberdade axial (deslocamentos u1 e u2).",
                                    "Estabeleça o sistema de coordenadas local x ao longo do comprimento L, com nós em x=0 e x=L.",
                                    "Introduza as funções de forma lineares: N1 = 1 - ξ (onde ξ = x/L), N2 = ξ.",
                                    "Expresse o deslocamento axial u(x) = N1 * u1 + N2 * u2."
                                  ],
                                  "verification": "Confirme que u(0) = u1 e u(L) = u2, e que as funções de forma são contínuas e satisfazem a partição da unidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis para esboços",
                                    "Livro-texto de Elementos Finitos (capítulo de treliças)"
                                  ],
                                  "tips": "Desenhe o elemento esquematicamente para visualizar os nós e o campo de deslocamento.",
                                  "learningObjective": "Compreender a discretização do elemento e interpolação linear do deslocamento.",
                                  "commonMistakes": "Confundir funções de forma com deformação; lembrar que N1 + N2 = 1."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a matriz de deformação B e tensão",
                                  "subSteps": [
                                    "Calcule a deformação axial ε(x) = du/dx = d(N1*u1 + N2*u2)/dx = (1/L) * [-1, 1] * {u1, u2} = B * {u}, onde B = [-1/L, 1/L].",
                                    "Determine a tensão σ(x) = E * ε(x), assumindo comportamento elástico linear.",
                                    "Verifique que B é constante para seção transversal uniforme.",
                                    "Escreva σ(x) = E * B * {u}."
                                  ],
                                  "verification": "Substitua valores: para u1=0, u2=δ, ε deve ser δ/L constante.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou software como Mathematica/MATLAB para derivadas",
                                    "Folha de derivadas matriciais"
                                  ],
                                  "tips": "Use ξ = x/L para simplificar derivação: dN1/dx = -1/L, dN2/dx = 1/L.",
                                  "learningObjective": "Relacionar deslocamentos nodais à deformação via matriz B.",
                                  "commonMistakes": "Esquecer o fator 1/L na derivada; B não é [[-1,1]] mas [-1/L, 1/L]."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a matriz de rigidez usando o princípio da energia potencial",
                                  "subSteps": [
                                    "Estabeleça a energia de deformação U = (1/2) ∫ σ^T ε A dx de 0 a L = (1/2) {u}^T * [∫ B^T E A B dx] * {u}.",
                                    "Identifique a matriz de rigidez local k_local = ∫_0^L B^T E A B dx.",
                                    "Como B é constante, k_local = B^T E A B * L.",
                                    "Substitua B: k_local = (E A / L) * [[1], [-1]] * [-1, 1] * L = (A E / L) * [[1, -1], [-1, 1]]."
                                  ],
                                  "verification": "Compute numericamente para valores exemplo: A=1, E=1, L=1 → k=[[1,-1],[-1,1]].",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de álgebra simbólica (opcional)",
                                    "Tabela de integrais matriciais"
                                  ],
                                  "tips": "Lembre que para minimização de Π = U - W, ∂Π/∂u_i = 0 leva a K u = F.",
                                  "learningObjective": "Aplicar princípio variacional para derivar propriedades elementares.",
                                  "commonMistakes": "Esquecer o A na integral ou fator L na simplificação final."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar com método de Galerkin e interpretar a matriz",
                                  "subSteps": [
                                    "Formule o problema fraco: ∫ N_i^T (dσ/dx) dx = 0 para i=1,2, levando a ∫ B^T E A B dx {u} = {F}.",
                                    "Confirme que resulta na mesma k_local via multiplicação matricial.",
                                    "Interprete: k11=k22=AE/L (rigidez axial), k12=k21=-AE/L (ação reativa).",
                                    "Teste com força nodal: F2 = (AE/L)(u2 - u1)."
                                  ],
                                  "verification": "Aplique deslocamento unitário u1=1, u2=0 → forças F1=AE/L, F2=-AE/L.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplos resolvidos de treliças",
                                    "MATLAB para validação numérica"
                                  ],
                                  "tips": "Galerkin é equivalente à energia para este caso linear; foque na simetria de k.",
                                  "learningObjective": "Validar derivação via método dos pesos e entender propriedades físicas.",
                                  "commonMistakes": "Confundir coordenadas locais vs globais; matriz deve ser simétrica positiva definida."
                                }
                              ],
                              "practicalExample": "Para uma barra de aço com A=0.01 m², E=200 GPa, L=2 m: k_local = (0.01*200e9 / 2) * [[1,-1],[-1,1]] = 1e9 * [[1,-1],[-1,1]] N/m. Aplique u1=0, u2=0.001 m → F1=-1e6 N, F2=1e6 N (força de tração).",
                              "finalVerifications": [
                                "Matriz resultante é simétrica com k11 = k22 = AE/L e k12 = k21 = -AE/L.",
                                "Para deslocamento unitário diferencial (u2-u1=1), força reativa é AE/L.",
                                "Energia armazenada U = (1/2) (u2-u1)^2 * (AE/L) coincide com integral.",
                                "Método de Galerkin produz idêntica matriz.",
                                "Matriz é positiva definida (autovalores positivos)."
                              ],
                              "assessmentCriteria": [
                                "Correção na derivação de B (incluindo fator 1/L).",
                                "Aplicação precisa do princípio da energia ou Galerkin.",
                                "Simplificação algébrica para forma final [[1,-1],[-1,1]] * (AE/L).",
                                "Interpretação física dos termos da matriz.",
                                "Validação numérica com exemplo concreto.",
                                "Ausência de erros dimensionais (unidades N/m)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (multiplicação matricial, integrais de matrizes).",
                                "Física: Mecânica dos sólidos (lei de Hooke, energia de deformação).",
                                "Programação: Implementação em Python/MATLAB para automação de FEM 1D.",
                                "Cálculo: Derivadas fracas e métodos variacionais."
                              ],
                              "realWorldApplication": "Na análise de estruturas como pontes treliçadas ou torres eólicas, a matriz de rigidez local é montada para cada elemento, assemblage global resolve deslocamentos sob cargas reais (vento, peso próprio), permitindo otimização de design e verificação de segurança."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.1.1.2.2",
                            "name": "Aplicar condições de contorno locais",
                            "description": "Determinar as forças nodais locais {f_local} = [k_local] {u_local}, interpretando os esforços axiais nos nós para um dado vetor de deslocamentos locais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e preparar a matriz de rigidez local [k_local] e condições de contorno",
                                  "subSteps": [
                                    "Revise a geometria do elemento de treliça (comprimento L, área A, módulo E).",
                                    "Calcule os termos da matriz [k_local] = (AE/L) * [[1, -1], [-1, 1]].",
                                    "Identifique os graus de liberdade locais (u1 e u2 nos nós 1 e 2).",
                                    "Liste as condições de contorno: ex. u1 = 0 (apoio fixo), u2 = valor conhecido.",
                                    "Anote unidades consistentes (N, m)."
                                  ],
                                  "verification": "Matriz [k_local] simétrica e vetor de contornos documentados corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis, calculadora, tabela de propriedades do material.",
                                  "tips": "Sempre verifique simetria de [k_local] para detectar erros de cálculo.",
                                  "learningObjective": "Compreender a origem e estrutura da matriz de rigidez local em elementos de treliça.",
                                  "commonMistakes": "Esquecer o sinal negativo nos termos fora da diagonal; unidades inconsistentes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Montar o vetor de deslocamentos locais {u_local} aplicando contornos",
                                  "subSteps": [
                                    "Atribua valores conhecidos das condições de contorno aos DOFs correspondentes.",
                                    "Para DOFs livres, use valores resolvidos previamente ou assuma para exemplo.",
                                    "Forme o vetor {u_local} = [u1, u2]^T com valores numéricos.",
                                    "Confirme que contornos fixos (ex. u=0) estão corretamente zerados.",
                                    "Documente o vetor resultante."
                                  ],
                                  "verification": "Vetor {u_local} tem dimensões corretas (2x1) e valores condizem com contornos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Planilha ou software como MATLAB/Excel para vetores.",
                                  "tips": "Use notação colchete para vetores coluna para evitar confusão.",
                                  "learningObjective": "Aplicar condições de contorno diretamente no espaço local do elemento.",
                                  "commonMistakes": "Confundir DOFs locais com globais; inverter ordem de u1 e u2."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular as forças nodais locais {f_local} = [k_local] {u_local}",
                                  "subSteps": [
                                    "Execute a multiplicação matricial: f1 = k11*u1 + k12*u2; f2 = k21*u1 + k22*u2.",
                                    "Calcule cada componente numericamente com precisão.",
                                    "Arredonde resultados conforme precisão de entrada (ex. 3 casas decimais).",
                                    "Verifique equilíbrio: f1 + f2 deve ser zero para elemento isolado sem cargas.",
                                    "Registre {f_local} = [f1, f2]^T."
                                  ],
                                  "verification": "Soma das forças nodais é zero (equilíbrio estático) e cálculos batem manualmente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora matricial ou Python/MATLAB script simples.",
                                  "tips": "Implemente em código para automação: k @ u.",
                                  "learningObjective": "Executar multiplicação matricial para obter forças de elementos finitos.",
                                  "commonMistakes": "Erro aritmético na multiplicação; esquecer transposição implícita."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar {f_local} como esforços axiais nos nós e validar",
                                  "subSteps": [
                                    "Interprete f1 como força axial no nó 1 (positiva = tração).",
                                    "Interprete f2 como força axial no nó 2 (oposta a f1 por equilíbrio).",
                                    "Compare com sinal físico: tração/compressão baseado em deslocamentos.",
                                    "Valide contra equilíbrio global ou deformação esperada (δ = fu / AE).",
                                    "Documente interpretação qualitativa e quantitativa."
                                  ],
                                  "verification": "Interpretação consistente com física (ex. deslocamento positivo gera tração em um extremo).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Diagrama esquemático do elemento desenhado.",
                                  "tips": "Desenhe setas de forças nos nós para visualização.",
                                  "learningObjective": "Traduzir resultados matemáticos em conceitos físicos de esforços axiais.",
                                  "commonMistakes": "Ignorar convenção de sinal (positivo=tração); não validar equilíbrio."
                                }
                              ],
                              "practicalExample": "Para elemento de treliça com L=2m, A=0.01m², E=200GPa, u1=0 (fixo), u2=0.005m: [k_local]=(500000)N/m * [[1,-1],[-1,1]], {u_local}=[0,0.005]^T, {f_local}=[-2500,2500]^T N → compressão de 2500N no nó 1, tração no nó 2.",
                              "finalVerifications": [
                                "Equilíbrio de forças: soma(f_local)=0.",
                                "Consistência de unidades: forças em Newtons.",
                                "Interpretação correta: sinais condizem com deslocamentos.",
                                "Validação numérica: deformação δ=u2-u1=L*(f/AE).",
                                "Documentação completa de [k], {u}, {f}."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos matriciais (>95% exatidão).",
                                "Correta aplicação de contornos locais.",
                                "Interpretação física precisa dos esforços.",
                                "Validação de equilíbrio demonstrada.",
                                "Clareza na documentação e unidades.",
                                "Eficiência temporal dentro dos estimados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e multiplicação matricial.",
                                "Física: Estática e equilíbrio de forças.",
                                "Programação: Implementação numérica em Python/MATLAB.",
                                "Engenharia Civil: Análise de estruturas reais."
                              ],
                              "realWorldApplication": "Em análises de elementos finitos de pontes ou edifícios, aplica contornos locais (ex. apoios fixos) para calcular esforços em barras de treliça, prevendo falhas por tração/compressão excessiva."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.1.1.1"
                            ]
                          },
                          {
                            "id": "34.1.1.2.3",
                            "name": "Verificar propriedades da matriz local",
                            "description": "Confirmar que a matriz [k_local] é simétrica, singular e positiva semi-definida, relacionando com os modos rígidos do elemento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Obter e inspecionar a matriz de rigidez local [k_local]",
                                  "subSteps": [
                                    "Derive ou recupere a matriz [k_local] para um elemento de treliça plana usando a fórmula padrão: k = (AE/L) * [c² cs; cs s²] onde c=cosθ, s=sinθ, A=área, E=módulo elástico, L=comprimento.",
                                    "Escreva a matriz explicitamente em termos de 2x2 para o elemento 1D equivalente em 2D.",
                                    "Inspecione visualmente a estrutura da matriz para identificar padrões iniciais de simetria.",
                                    "Armazene a matriz em um software numérico (ex: MATLAB ou Python com NumPy) para cálculos precisos.",
                                    "Confirme os valores numéricos usando dados do problema (ex: θ=45°, A=1, E=1, L=1)."
                                  ],
                                  "verification": "A matriz [k_local] está corretamente derivada e corresponde à fórmula teórica, com elementos numéricos precisos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, calculadora, software como MATLAB/Python/NumPy, referência teórica de Elementos Finitos.",
                                  "tips": "Use ângulos simples como 0° ou 45° para simplificar cálculos iniciais.",
                                  "learningObjective": "Compreender a origem e estrutura da matriz de rigidez local de um elemento de treliça.",
                                  "commonMistakes": "Esquecer o fator (AE/L) ou confundir c² com cs nos off-diagonais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar a propriedade de simetria da matriz",
                                  "subSteps": [
                                    "Transpose a matriz [k_local] manualmente ou via software (k^T).",
                                    "Compare elemento por elemento: confirme k_{ij} = k_{ji} para todos i,j.",
                                    "Calcule a diferença k - k^T e verifique se resulta na matriz zero.",
                                    "Explique fisicamente por que a simetria surge (conservação de energia: trabalho virtual igual em direções opostas).",
                                    "Teste com um exemplo numérico específico."
                                  ],
                                  "verification": "k - k^T = [0], confirmado analiticamente e numericamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Software NumPy/MATLAB para transposição e subtração, papel para inspeção manual.",
                                  "tips": "Para matrizes 2x2, basta checar se k12 = k21.",
                                  "learningObjective": "Aplicar e validar a simetria como propriedade fundamental das matrizes de rigidez.",
                                  "commonMistakes": "Ignorar erros de arredondamento numérico em software."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar singularidade e identificar modos rígidos",
                                  "subSteps": [
                                    "Calcule o determinante det([k_local]) analiticamente (deve ser zero para elementos sem restrições).",
                                    "Use software para computar rank([k_local]) = 1 (para 2 DOFs em treliça).",
                                    "Encontre autovalores: confirme pelo menos um λ=0.",
                                    "Calcule autovetores para λ=0: interprete como modos rígidos (translação rígida do elemento).",
                                    "Relacione: singularidade implica graus de liberdade rígidos não penalizados."
                                  ],
                                  "verification": "det(k)=0, rank<2, e autovetor nulo corresponde a deslocamento rígido uniforme.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "MATLAB/Python com funções det(), eig(), null(), livro de álgebra linear.",
                                  "tips": "Para treliça 2D, modo rígido é [1;1] normalizado para deslocamento axial uniforme.",
                                  "learningObjective": "Associar singularidade matemática a modos rígidos físicos em estruturas.",
                                  "commonMistakes": "Confundir singularidade com det≠0 devido a erros na derivação de k."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Confirmar positiva semi-definida e validar propriedades finais",
                                  "subSteps": [
                                    "Compute todos autovalores: confirme λ ≥ 0 para todos.",
                                    "Para cada autovetor x_i, verifique x_i^T k x_i = λ_i ||x_i||^2 ≥ 0.",
                                    "Teste forma quadrática para vetores arbitrários (ex: [1;0], [0;1], [1;1]).",
                                    "Interprete: autovalores positivos para deformações energéticas, zero para rígidas.",
                                    "Documente todas propriedades em um relatório resumido."
                                  ],
                                  "verification": "Todos autovalores ≥0, forma quadrática ≥0 para vetores teste.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software para eig() e multiplicações matriciais, tabela para registrar resultados.",
                                  "tips": "Diagonalize k = Q Λ Q^T para visualização clara dos autovalores.",
                                  "learningObjective": "Validar positiva semi-definida como garantia de estabilidade energética.",
                                  "commonMistakes": "Autovalores negativos devido a erros de sinal na derivação de k."
                                }
                              ],
                              "practicalExample": "Para um elemento de treliça com θ=45°, A=1 cm², E=210 GPa, L=1 m: k = (210e9 /1) * [0.5 0.5; 0.5 0.5]. Verifique: simétrica (sim), det=0 (sim), autovalores [0, 210e9] (positiva semi-definida), modo rígido [1;1] (translação 45°).",
                              "finalVerifications": [
                                "Matriz é simétrica: k = k^T.",
                                "Determinante zero: det(k)=0.",
                                "Todos autovalores não-negativos.",
                                "Autovetores de λ=0 correspondem a modos rígidos (ex: translação uniforme).",
                                "Forma quadrática x^T k x ≥0 para x arbitrário.",
                                "Relacionamento físico com rigidez elementar documentado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de k_local (100% match com fórmula).",
                                "Correta verificação de simetria (analítica e numérica).",
                                "Identificação correta de singularidade e rank.",
                                "Análise completa de autovalores/autovetores com interpretação física.",
                                "Ausência de erros em testes de forma quadrática.",
                                "Relatório claro relacionando propriedades a modos rígidos."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: autovalores, transposição, determinantes.",
                                "Física: Princípio dos trabalhos virtuais e conservação de energia.",
                                "Programação: Uso de NumPy/MATLAB para análise matricial.",
                                "Engenharia Civil: Análise estática de treliças reais."
                              ],
                              "realWorldApplication": "Em software FEA como ANSYS ou Abaqus, verifica-se essas propriedades na montagem de [K_global] para evitar instabilidades numéricas em simulações de pontes ou edifícios, garantindo precisão em análises de colapso estrutural."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.1.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "34.1.1.3",
                        "name": "Transformação e Montagem do Sistema Global",
                        "description": "Transformação da matriz de rigidez local para o sistema global usando matriz de rotação e montagem das matrizes globais por superposição para uma treliça composta por múltiplos elementos.",
                        "specificSkills": [
                          {
                            "id": "34.1.1.3.1",
                            "name": "Construir a matriz de transformação",
                            "description": "Definir a matriz de rotação [T] = [[c, s, 0, 0], [-s, c, 0, 0], [0, 0, c, s], [0, 0, -s, c]], onde c=cosθ e s=senθ, para mapear {u_local} = [T] {u_global}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os sistemas de coordenadas local e global em treliças planas",
                                  "subSteps": [
                                    "Identifique o sistema de coordenadas global (eixos X e Y fixos na estrutura).",
                                    "Descreva o sistema local do elemento (eixo x' ao longo do elemento, y' perpendicular).",
                                    "Explique a necessidade de transformação: deslocamentos locais são necessários para rigidez axial, mas globais para montagem.",
                                    "Desenhe um diagrama de um elemento inclinado com θ em relação ao global.",
                                    "Liste os graus de liberdade (DOFs): 2 por nó (ux, uy), total 4 DOFs por elemento."
                                  ],
                                  "verification": "Desenhe corretamente o diagrama com sistemas locais e globais rotacionados por θ, e liste os 4 DOFs.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora",
                                    "Diagrama de exemplo de treliça plana"
                                  ],
                                  "tips": "Sempre meça θ como o ângulo entre o eixo x-global e o eixo local do elemento (sentido anti-horário).",
                                  "learningObjective": "Entender a relação geométrica entre coordenadas locais e globais para justificar a matriz de rotação.",
                                  "commonMistakes": [
                                    "Confundir local com global",
                                    "Errar a direção de θ (horário vs anti-horário)",
                                    "Ignorar os 4 DOFs totais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar o ângulo de rotação θ do elemento",
                                  "subSteps": [
                                    "Obtenha as coordenadas dos nós do elemento (ex: nó i (xi,yi), nó j (xj,yj)).",
                                    "Calcule Δx = xj - xi e Δy = yj - yi.",
                                    "Compute θ = atan2(Δy, Δx) para obter o ângulo correto no quadrante.",
                                    "Verifique se θ está em radianos ou graus conforme a calculadora.",
                                    "Anote θ com precisão de pelo menos 2 casas decimais."
                                  ],
                                  "verification": "Calcule θ para um exemplo dado (ex: nós (0,0) e (3,4)) e confirme θ ≈ 53.13° ou 0.927 rad.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora com função atan2",
                                    "Coordenadas de nós de exemplo"
                                  ],
                                  "tips": "Use atan2(Δy, Δx) para evitar erros de quadrante; converta graus para radianos se necessário (θ_rad = θ_deg * π/180).",
                                  "learningObjective": "Calcular precisamente o ângulo θ que define a orientação do elemento.",
                                  "commonMistakes": [
                                    "Usar atan em vez de atan2",
                                    "Confundir Δx e Δy",
                                    "Esquecer conversão de unidades angulares"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular os coeficientes de rotação c = cosθ e s = sinθ",
                                  "subSteps": [
                                    "Insira θ em radianos na calculadora.",
                                    "Calcule c = cos(θ) com pelo menos 4 casas decimais.",
                                    "Calcule s = sin(θ) com a mesma precisão.",
                                    "Verifique a identidade pitagórica: c² + s² ≈ 1 (erro < 0.001).",
                                    "Registre os valores em uma tabela para referência."
                                  ],
                                  "verification": "Para θ=30° (π/6 rad), confirme c ≈ 0.8660 e s ≈ 0.5000, com c² + s² = 1.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Tabela de valores trigonométricos opcional"
                                  ],
                                  "tips": "Sempre trabalhe em radianos para funções trig em software; arredonde apenas no final.",
                                  "learningObjective": "Dominar o cálculo preciso de cosseno e seno para rotação.",
                                  "commonMistakes": [
                                    "Calcular em graus sem converter",
                                    "Erro de sinal em seno/cosseno",
                                    "Baixa precisão numérica"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar a matriz de transformação [T] 4x4",
                                  "subSteps": [
                                    "Estruture [T] como bloco diagonal: dois blocos 2x2 de rotação.",
                                    "Preencha primeira linha: [c, s, 0, 0].",
                                    "Segunda linha: [-s, c, 0, 0].",
                                    "Terceira linha: [0, 0, c, s].",
                                    "Quarta linha: [0, 0, -s, c].",
                                    "Escreva a matriz completa e verifique simetria/ortogonalidade básica."
                                  ],
                                  "verification": "Multiplique [T] por um vetor global simples e confirme rotação correta para local.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Matriz de exemplo pré-montada para comparação"
                                  ],
                                  "tips": "Lembre-se: esta [T] transforma {u_global} para {u_local}; para o inverso, use [T]^T pois é ortogonal.",
                                  "learningObjective": "Construir corretamente a matriz [T] que mapeia deslocamentos globais para locais.",
                                  "commonMistakes": [
                                    "Trocar posições de c e s",
                                    "Errar sinais em -s",
                                    "Confundir ordem dos DOFs (nó1 vs nó2)"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar a matriz [T] com uma aplicação simples",
                                  "subSteps": [
                                    "Escolha um vetor {u_global} = [1, 0, 0, 0]^T (deslocamento unitário em X no nó1).",
                                    "Multiplique {u_local} = [T] {u_global}.",
                                    "Interprete: u_x' deve ser c, u_y' = -s para nó1.",
                                    "Repita para outro vetor, ex: [0,1,0,0]^T.",
                                    "Confirme que [T] preserva normas (||u_local|| ≈ ||u_global||)."
                                  ],
                                  "verification": "Resultados da multiplicação coincidem com rotação geométrica esperada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora matricial ou software como MATLAB/Octave",
                                    "Vetor de teste"
                                  ],
                                  "tips": "Use multiplicação matricial passo a passo manualmente primeiro para entender.",
                                  "learningObjective": "Verificar funcionalmente a matriz construída.",
                                  "commonMistakes": [
                                    "Erro aritmético na multiplicação",
                                    "Ignorar preservação de comprimento",
                                    "Confundir transformação direta/inversa"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma treliça com elemento entre nós (0,0) e (4,3): Δx=4, Δy=3, L=5, θ=atan2(3,4)≈36.87° ou 0.6435 rad. c=cosθ≈0.8, s=sinθ≈0.6. [T] = [[0.8, 0.6, 0, 0], [-0.6, 0.8, 0, 0], [0, 0, 0.8, 0.6], [0, 0, -0.6, 0.8]]. Aplique a {u_global}=[1,0,0,0]^T → {u_local}≈[0.8, -0.6, 0, 0]^T.",
                              "finalVerifications": [
                                "Calcular θ corretamente a partir de coordenadas de nós.",
                                "Obter c e s precisos com verificação pitagórica.",
                                "Montar [T] 4x4 sem erros de sinal ou posição.",
                                "Multiplicar [T] por vetor global e interpretar resultados locais.",
                                "Confirmar ortogonalidade: [T]^T [T] ≈ [I] (identidade).",
                                "Aplicar a um exemplo completo de treliça com 2 elementos."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos de θ, c, s (erro < 0.01).",
                                "Correção na estrutura e elementos da matriz [T].",
                                "Compreensão conceitual demonstrada em diagramas e explicações.",
                                "Habilidade em multiplicação matricial e interpretação física.",
                                "Identificação e correção de erros comuns em validação.",
                                "Eficiência temporal e uso adequado de materiais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Trigonometria, álgebra linear (matrizes de rotação, propriedades ortogonais).",
                                "Física: Cinemática de sólidos rígidos, vetores de deslocamento em mecânica estrutural.",
                                "Computação: Implementação em Python/MATLAB para automação de FEA.",
                                "Geometria: Cálculo de ângulos via atan2 e vetores direção.",
                                "Engenharia Civil: Análise de estruturas como vigas e frames."
                              ],
                              "realWorldApplication": "Em software de Elementos Finitos (ANSYS, Abaqus), esta matriz transforma rigidez local para global na montagem do sistema de equações, essencial para simular deformações em pontes, edifícios e aviões sob cargas reais, garantindo precisão na previsão de falhas estruturais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.1.1.2"
                            ]
                          },
                          {
                            "id": "34.1.1.3.2",
                            "name": "Obter a matriz de rigidez global do elemento",
                            "description": "Calcular [k_global] = [T]^T [k_local] [T], expandindo para a matriz 4x4 completa com termos como (AE/L)(c², cs, etc.).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar parâmetros do elemento e coeficientes trigonométricos",
                                  "subSteps": [
                                    "Identifique os parâmetros: área transversal A, módulo de elasticidade E, comprimento L e ângulo de orientação θ (com o eixo x global).",
                                    "Calcule c = cos(θ) e s = sin(θ), preferencialmente em radianos.",
                                    "Verifique a identidade fundamental: c² + s² = 1.",
                                    "Construa a matriz de rotação elementar 2x2: R = [[c, s], [-s, c]].",
                                    "Documente os valores numéricos e simbólicos."
                                  ],
                                  "verification": "Coeficientes c e s satisfazem c² + s² = 1 e det(R) = 1 (rotação pura).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Papel e lápis",
                                    "Software como Python (numpy) ou MATLAB para verificação"
                                  ],
                                  "tips": "Converta graus para radianos se necessário (θ_rad = θ_deg * π/180); use valores exatos como cos(30°)=√3/2 quando possível.",
                                  "learningObjective": "Calcular componentes direcionais da orientação do elemento para transformações.",
                                  "commonMistakes": [
                                    "Usar graus em vez de radianos em funções trigonométricas",
                                    "Inverter sinais de s ou c",
                                    "Não verificar c² + s² = 1"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir matriz de transformação [T] e sua transposta [T]^T",
                                  "subSteps": [
                                    "Monte [T] 4x4 como bloco diagonal: [[R, 0], [0, R]], onde R é a matriz 2x2 acima.",
                                    "Calcule [T]^T explicitamente: substitua R por R^T = [[c, -s], [s, c]].",
                                    "Verifique ortogonalidade: multiplique [T]^T [T] e confirme identidade 4x4.",
                                    "Anote elementos individuais de [T] e [T]^T para uso posterior.",
                                    "Teste com um vetor de deslocamento simples para validar transformação."
                                  ],
                                  "verification": "[T]^T [T] = I_{4x4} (identidade), confirmando que [T] é uma matriz de rotação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramentas de álgebra matricial (Excel, Python numpy, MATLAB)",
                                    "Papel quadriculado"
                                  ],
                                  "tips": "Aplique a mesma R para ambos os nós; [T] transforma deslocamentos globais para locais.",
                                  "learningObjective": "Dominar a construção de matrizes de transformação para elementos finitos orientados.",
                                  "commonMistakes": [
                                    "Erros de sinal nos blocos de rotação para o segundo nó",
                                    "Confundir [T] com [T]^T desde o início",
                                    "Não usar blocos para eficiência"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir a matriz de rigidez local [k_local]",
                                  "subSteps": [
                                    "Calcule o fator de rigidez axial k = (A * E) / L.",
                                    "Construa a submatriz axial 2x2: k_axial = k * [[1, -1], [-1, 1]].",
                                    "Expanda para [k_local] 4x4: bloco diagonal com k_axial nos DOF axiais (1-2) e zeros nos transversais (3-4).",
                                    "Verifique simetria e que os zeros representam ausência de rigidez lateral em treliças.",
                                    "Confirme unidades: k em N/m."
                                  ],
                                  "verification": "[k_local] é simétrica, trace([k_local]) = 2k > 0, e soma de linhas = 0.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Folha de cálculo para unidades"
                                  ],
                                  "tips": "Mantenha consistência SI: A em m², E em Pa, L em m; arredonde apenas no final.",
                                  "learningObjective": "Compreender a rigidez uniaxial simplificada para elementos de treliça.",
                                  "commonMistakes": [
                                    "Sinal errado nos termos off-diagonal (-1)",
                                    "Esquecer de zerar DOF transversais",
                                    "Erro em k = AE/L (inverso)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular e expandir a matriz de rigidez global [k_global]",
                                  "subSteps": [
                                    "Compute intermediário M = [k_local] [T].",
                                    "Em seguida, [k_global] = [T]^T M.",
                                    "Expanda simbolicamente: k11 = k c², k12 = k c s, k13 = -k c², k14 = -k c s, etc.",
                                    "Escreva a matriz 4x4 completa com todos os 10 termos únicos.",
                                    "Verifique: simetria, soma linha = 0, diagonais = k (c² + s²) = k."
                                  ],
                                  "verification": "Matriz simétrica, soma elementos linha/coluna = 0, termos combinam c², 2cs, s² corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software para multiplicação matricial simbólica (SymPy, MATLAB Symbolic)",
                                    "Papel para expansão manual"
                                  ],
                                  "tips": "Use propriedades bloco e identidades trig para simplificar antes de multiplicar numericamente.",
                                  "learningObjective": "Executar transformação de rigidez via multiplicação matricial e interpretação física.",
                                  "commonMistakes": [
                                    "Erros aritméticos em produtos cs",
                                    "Não propagar zeros de [k_local]",
                                    "Esquecer fator k em todos termos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um elemento com A=0.001 m², E=2.1e11 Pa, L=3 m, θ=30°: k=(0.001*2.1e11)/3=7e7 N/m, c≈0.866, s=0.5. Então k11=k c²≈5.25e7, k12=k c s≈3.03e7, k22=k s²=1.75e7, k13=-k c²≈-5.25e7, etc. A matriz completa é simétrica com soma zero por linha. Verifique em software.",
                              "finalVerifications": [
                                "Matriz [k_global] 4x4 é simétrica (k_ij = k_ji).",
                                "Diagonais principais iguais a k (c² + s²) = k.",
                                "Soma de elementos de cada linha e coluna é zero (equilíbrio rígido).",
                                "Termos corretos: c², cs, s² com sinais apropriados (+ nas extremidades, - opostas).",
                                "Coincide com fórmula padrão de livros de MF (ex: Logan).",
                                "Teste numérico: aplique deslocamento unitário e verifique forças."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos coeficientes trigonométricos (erro <0.1%).",
                                "Construção correta e verificada de [T] e [T]^T.",
                                "Definição exata de [k_local] com zeros transversais.",
                                "Multiplicações matriciais livres de erros aritméticos.",
                                "Expansão simbólica completa com termos (AE/L)(c², cs, etc.).",
                                "Verificações finais demonstradas (simetria, soma zero).",
                                "Exemplo prático resolvido corretamente."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Transposição, multiplicação e propriedades ortogonais de matrizes.",
                                "Trigonometria: Identidades pitagóricas e funções seno/cosseno em vetores.",
                                "Física: Estática e deformações axiais em sólidos elásticos.",
                                "Programação: Implementação automatizada em Python/MATLAB para FEA.",
                                "Geometria: Vetores direção e ângulos em planos cartesianos."
                              ],
                              "realWorldApplication": "Essa matriz é o bloco básico para montagem do sistema global [K]{u}={F} em análises de elementos finitos de treliças planas, usadas em projetos de pontes, torres de transmissão, estruturas aeroespaciais e telhados metálicos, simulando respostas a cargas reais em softwares como ANSYS, Abaqus ou SAP2000 para garantir segurança e otimização."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.1.2.1",
                              "34.1.1.3.1"
                            ]
                          },
                          {
                            "id": "34.1.1.3.3",
                            "name": "Montar o sistema global da treliça",
                            "description": "Superpor as matrizes [K_global] e vetores {F_global} de todos os elementos conectados nos nós compartilhados, aplicando condições de contorno para resolver [K]{u} = {F}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inicializar as estruturas globais",
                                  "subSteps": [
                                    "Identifique todos os nós da treliça e seus graus de liberdade (geralmente 2 por nó em 2D: ux, uy).",
                                    "Determine o tamanho total da matriz [K_global] (n x n, onde n = total de DOFs) e vetor {F_global} (n x 1).",
                                    "Crie matriz [K_global] zerada e vetor {F_global} zerado.",
                                    "Liste os nós fixos/suportados e seus deslocamentos conhecidos (ex: u=0)."
                                  ],
                                  "verification": "Confirme que [K_global] é uma matriz quadrada simétrica zerada e {F_global} é vetor zero com dimensões corretas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel milimetrado, lápis, calculadora, diagrama da treliça.",
                                  "tips": "Numere os DOFs sequencialmente: nó1-ux=1, nó1-uy=2, nó2-ux=3, etc.",
                                  "learningObjective": "Entender a dimensionalidade do sistema global baseado na topologia da treliça.",
                                  "commonMistakes": "Errar a contagem de DOFs ou esquecer DOFs de nós internos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Montar a matriz de rigidez global [K_global]",
                                  "subSteps": [
                                    "Para cada elemento, transforme [k_local] para [k_element_global] usando ângulo θ e matriz de rotação [T].",
                                    "Identifique os índices dos DOFs locais no sistema global (ex: elemento conectando nós i e j).",
                                    "Some [k_element_global] às posições correspondentes em [K_global].",
                                    "Repita para todos os elementos, superpondo contribuições em nós compartilhados.",
                                    "Verifique simetria de [K_global] (Kij = Kji)."
                                  ],
                                  "verification": "Some uma linha/coluna de [K_global] e confirme que soma das rigidezes conectadas ao nó está correta.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Fórmulas de transformação de rigidez, tabela de senos/cossenos, software como MATLAB opcional.",
                                  "tips": "Use [T] = [[c,s,0,0], [-s,c,0,0], [0,0,c,s], [0,0,-s,c]] onde c=cosθ, s=sinθ.",
                                  "learningObjective": "Dominar a superposição de matrizes elementares no domínio global.",
                                  "commonMistakes": "Erro na matriz de rotação ou índices errados de DOFs."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Montar o vetor de forças globais {F_global}",
                                  "subSteps": [
                                    "Para cada nó com carga aplicada, insira o valor nos DOFs correspondentes de {F_global}.",
                                    "Some forças de elementos se houver (ex: forças térmicas, mas foque em nodais).",
                                    "Para nós sem carga, mantenha zero.",
                                    "Confirme que cargas distribuídas foram equivalentes nodais previamente.",
                                    "Liste todas as forças para auditoria."
                                  ],
                                  "verification": "Verifique se forças em DOFs de nós fixos são reações (ainda desconhecidas).",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Diagrama de cargas da treliça.",
                                  "tips": "Cargas axiais/distribuídas devem ser pré-processadas em equivalentes nodais.",
                                  "learningObjective": "Coletar e organizar forças nodais no vetor global.",
                                  "commonMistakes": "Inserir forças em DOFs errados ou esquecer zeros."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar condições de contorno",
                                  "subSteps": [
                                    "Identifique DOFs conhecidos (ex: apoios fixos u=0).",
                                    "Modifique [K_global]: remova/modifique linhas/colunas dos DOFs conhecidos ou use penalização.",
                                    "Ajuste {F_global}: substitua valores conhecidos (geralmente 0) nos DOFs restritos.",
                                    "Reduza o sistema para DOFs livres: [K_red]{u_red} = {F_red}.",
                                    "Documente os DOFs restritos e livres."
                                  ],
                                  "verification": "Confirme que matriz reduzida é quadrada e positiva definida.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Lista de condições de contorno do problema.",
                                  "tips": "Método de exclusão é simples manualmente; penalização para código.",
                                  "learningObjective": "Incorporar restrições de apoio no sistema de equações.",
                                  "commonMistakes": "Esquecer de ajustar ambos lados da equação ou restringir DOFs errados."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e preparar para resolução",
                                  "subSteps": [
                                    "Cheque dimensões finais de [K_red] e {F_red}.",
                                    "Verifique simetria e diagonal dominante em [K_global].",
                                    "Confirme equilíbrio global aproximado (soma F ≈ 0).",
                                    "Salve o sistema [K]{u} = {F} pronto para solver.",
                                    "Compare com solução analítica se disponível."
                                  ],
                                  "verification": "Teste se [K_red] * {u_test} ≈ {F_test} para vetor teste.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Calculadora matricial ou Python/Excel.",
                                  "tips": "Use propriedades físicas: rigidez positiva, equilíbrio.",
                                  "learningObjective": "Garantir integridade do sistema montado.",
                                  "commonMistakes": "Ignorar verificações levando a singularidade."
                                }
                              ],
                              "practicalExample": "Para uma treliça simples com 3 nós (1-2-3 horizontal), 2 elementos, nó1 e nó3 fixos em y, carga 100N em uy do nó2: Inicialize 6x6 K e 6x1 F; some k1 entre DOFs 1-4; some k2 entre 3-6; insira Fy=100 no DOF4; restrinja DOFs1,2,5,6=0; resolva 2x2 para ux2,uy2.",
                              "finalVerifications": [
                                "[K_global] é simétrica e sparse com zeros fora de conectividades.",
                                "Dimensões de [K_red] igual a número de DOFs livres.",
                                "Forças em DOFs restritos ajustadas corretamente.",
                                "Soma de rigidez em diagonal condiz com elementos conectados.",
                                "Sistema passa teste de equilíbrio estático global.",
                                "Matriz [K_red] é não-singular (det ≠ 0)."
                              ],
                              "assessmentCriteria": [
                                "Correta identificação e contagem de DOFs globais.",
                                "Transformação precisa de [k_local] para global sem erros de índice.",
                                "Superposição correta em nós compartilhados.",
                                "Aplicação impecável de condições de contorno.",
                                "Verificações finais mostram consistência física/matemática.",
                                "Documentação clara de passos e matrizes."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Operações matriciais, superposição e resolução de sistemas.",
                                "Física/Estática: Equilíbrio de forças e momentos em estruturas.",
                                "Programação: Implementação em loops para montagem em código (Python/MATLAB).",
                                "Matemática Computacional: Condicionamento numérico de matrizes."
                              ],
                              "realWorldApplication": "Em engenharia civil, usado para analisar pontes treliçadas ou torres, onde software como ANSYS monta automaticamente [K_global] para prever deformações sob vento/cargas, evitando colapsos como no caso de pontes históricas falhas por análise inadequada."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.1.3.2"
                            ]
                          },
                          {
                            "id": "34.1.1.3.4",
                            "name": "Resolver e pós-processar resultados",
                            "description": "Implementar a solução numérica do sistema global, calcular reações, deslocamentos e tensões em cada elemento de uma treliça plana simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Resolver o sistema global de equações lineares",
                                  "subSteps": [
                                    "Montar a matriz de rigidez global [K] e o vetor de forças nodais {F} a partir da montagem anterior.",
                                    "Aplicar condições de contorno para reduzir o sistema, eliminando graus de liberdade conhecidos (ex: apoios fixos).",
                                    "Usar método de eliminação de Gauss ou decomposição LU para resolver [K_red] {u_red} = {F_red}.",
                                    "Implementar em software como MATLAB ou Python (NumPy) para solução numérica.",
                                    "Verificar simetria e positiva definitude da matriz [K] antes da resolução."
                                  ],
                                  "verification": "Comparar solução numérica com valores esperados de um caso simples manual; norma do resíduo ||[K]{u} - {F}|| < 1e-6.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Matriz [K] montada, software de álgebra linear (MATLAB/Python), calculadora.",
                                  "tips": "Sempre normalize unidades de força e comprimento para evitar erros numéricos.",
                                  "learningObjective": "Dominar resolução numérica de sistemas lineares simétricos em análise estrutural.",
                                  "commonMistakes": "Esquecer de aplicar condições de contorno levando a singularidade da matriz; inverter ordem das equações."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Extrair deslocamentos nodais completos",
                                  "subSteps": [
                                    "Inserir deslocamentos conhecidos (zeros em apoios) no vetor {u} reduzido para obter {u} completo.",
                                    "Calcular rotações ou outros DOFs se aplicável, usando relações cinemáticas.",
                                    "Verificar continuidade dos deslocamentos nos nós compartilhados entre elementos.",
                                    "Plotar diagrama de deslocamentos deformados escalados (fator de ampliação 10-100x).",
                                    "Exportar vetor {u} para pós-processamento subsequente."
                                  ],
                                  "verification": "Deslocamentos em apoios devem ser zero; soma vetorial de deslocamentos compatível com cargas aplicadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Vetor {u_red} resolvido, software de plotagem (MATLAB plot ou Python Matplotlib).",
                                  "tips": "Use fator de escala visual para deformações pequenas serem visíveis.",
                                  "learningObjective": "Entender reconstrução do campo de deslocamentos a partir de solução reduzida.",
                                  "commonMistakes": "Não restaurar DOFs fixos corretamente, resultando em deslocamentos espúrios em apoios."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular forças internas e tensões nos elementos",
                                  "subSteps": [
                                    "Para cada elemento, extrair deslocamentos nodais locais {u_e} = [T]{u_global} usando matriz de transformação.",
                                    "Calcular deformações {ε} = [B]{u_e} onde [B] é a matriz de deformações.",
                                    "Obter tensões σ = E {ε} para barras axiais (E módulo de elasticidade).",
                                    "Determinar forças axiais N = A σ (A área da seção).",
                                    "Classificar elementos como tracionados ou comprimidos."
                                  ],
                                  "verification": "Equilíbrio de forças nos nós: soma de N vetoriais em cada nó igual a carga externa.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Matrizes [T] e [B] por elemento, propriedades dos materiais (E, A).",
                                  "tips": "Automatize loop sobre elementos em script para eficiência.",
                                  "learningObjective": "Aplicar transformação local-global para computar estados internos.",
                                  "commonMistakes": "Erro na matriz de transformação [T] levando a forças incorretas; confundir tração/compressão."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular reações de apoio e validar resultados",
                                  "subSteps": [
                                    "Para nós de apoio, calcular reações {R} = [K_{sup}} {u} - {F_{sup}} onde subscrito sup são DOFs suportados.",
                                    "Verificar equilíbrio global: soma de reações + cargas externas = zero.",
                                    "Comparar com solução analítica para treliça simples (ex: 2 barras).",
                                    "Gerar relatório com tabelas de deslocamentos, forças e reações.",
                                    "Realizar análise de sensibilidade variando cargas em ±10%."
                                  ],
                                  "verification": "Equilíbrio estático global satisfeito; erro < 1% vs. analítico.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Vetor {u} completo, cargas {F}, solução de referência.",
                                  "tips": "Sempre cheque equilíbrio como verificação primária de correção.",
                                  "learningObjective": "Garantir integridade da solução via equilíbrio e validação.",
                                  "commonMistakes": "Calcular reações antes de ter {u} completo; ignorar componentes perpendiculares em apoios."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Pós-processamento e visualização",
                                  "subSteps": [
                                    "Criar diagrama de deformada escalada e contorno de tensões.",
                                    "Gerar tabela comparativa: deslocamentos, forças, tensões por elemento/nó.",
                                    "Exportar para software como Paraview ou ANSYS para visual 3D se extensível.",
                                    "Documentar insights: elemento crítico, modo de falha potencial.",
                                    "Preparar apresentação com gráficos e conclusões."
                                  ],
                                  "verification": "Visualizações coerentes com intuição física; relatório completo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de visualização (MATLAB, Python Plotly), templates de relatório.",
                                  "tips": "Use cores para tensão (vermelho tração, azul compressão).",
                                  "learningObjective": "Comunicar resultados de forma visual e interpretativa.",
                                  "commonMistakes": "Escala inadequada ocultando deformações; overload de informação no relatório."
                                }
                              ],
                              "practicalExample": "Para uma treliça plana de 3 barras formando triângulo isósceles (nós A fixo, B fixo vertical, C livre com carga vertical 10kN em C). Montar [K] 6x6, resolver para deslocamentos em C (ex: 0.5mm descida), calcular N1=5kN tração, N2=N3=2.5kN compressão, reações em A/B equilibrando 10kN.",
                              "finalVerifications": [
                                "Equilíbrio global de forças e momentos satisfeito.",
                                "Deslocamentos nulos em apoios fixos.",
                                "Forças internas compatíveis com deformações via σ = E ε.",
                                "Erro de resíduo do sistema < 1e-6.",
                                "Validação vs. solução analítica para caso simples.",
                                "Visualizações mostram deformada realista sem distorções anômalas."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica da solução do sistema global (erro < 0.1%).",
                                "Correta transformação local-global para forças elementais.",
                                "Cálculo exato de reações e verificação de equilíbrio.",
                                "Qualidade das visualizações e relatório (clareza, completude).",
                                "Identificação de elementos críticos e interpretação física.",
                                "Eficiência do código/fluxo (tempo de execução razoável)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (resolução de sistemas simétricos positivos definidos).",
                                "Programação: Implementação numérica em Python/MATLAB para automação.",
                                "Física/Estática: Princípios de equilíbrio e deformações elásticas.",
                                "Desenho Técnico: Visualização de estruturas e diagramas de forças."
                              ],
                              "realWorldApplication": "Análise de pontes treliçadas, torres de transmissão elétrica ou andaimes industriais, onde se prevê deslocamentos sob vento/cargas para evitar colapso, otimizando material e segurança em projetos civis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.1.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.4",
                    "name": "Treliças 3D",
                    "description": "Formulação do elemento de treliça espacial (3D), com análise de estabilidade e montagem de matrizes.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.4.1",
                        "name": "Geometria e Graus de Liberdade em Treliças 3D",
                        "description": "Compreensão da representação geométrica de elementos de treliça espacial, incluindo coordenadas nodais em 3D, cálculo do vetor direção e comprimento do elemento, e identificação dos 6 graus de liberdade por nó (3 translações).",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.1.1",
                            "name": "Definir coordenadas nodais e vetor direção",
                            "description": "Dado dois nós em coordenadas cartesianas 3D (x1,y1,z1) e (x2,y2,z2), calcular o vetor direção unitário (lx, ly, lz) e o comprimento L do elemento de treliça.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e anotar as coordenadas nodais dos dois nós",
                                  "subSteps": [
                                    "Receba as coordenadas cartesianas 3D do nó 1: (x1, y1, z1)",
                                    "Receba as coordenadas cartesianas 3D do nó 2: (x2, y2, z2)",
                                    "Anote claramente as coordenadas em um diagrama esquemático da treliça",
                                    "Verifique se as coordenadas estão no mesmo sistema de referência",
                                    "Confirme unidades consistentes (ex: metros)"
                                  ],
                                  "verification": "Coordenadas anotadas corretamente em diagrama com rótulos claros e unidades especificadas",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora",
                                    "Diagrama de treliça impresso ou software de desenho (ex: GeoGebra)"
                                  ],
                                  "tips": "Desenhe uma seta conectando os nós para visualizar o elemento claramente",
                                  "learningObjective": "Compreender a representação espacial de nós em treliças 3D",
                                  "commonMistakes": [
                                    "Confundir ordem dos nós (nó1 vs nó2)",
                                    "Ignorar unidades ou sistema de coordenadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os componentes diferenciais do vetor direção",
                                  "subSteps": [
                                    "Calcule dx = x2 - x1",
                                    "Calcule dy = y2 - y1",
                                    "Calcule dz = z2 - z1",
                                    "Anote o vetor direção bruto: (dx, dy, dz)",
                                    "Verifique os sinais dos componentes (positivo/negativo)"
                                  ],
                                  "verification": "Componentes dx, dy, dz calculados e vetor bruto anotado com valores numéricos corretos",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Folha de cálculo (Excel ou papel)"
                                  ],
                                  "tips": "Use parênteses para agrupar subtrações e evitar erros de sinal",
                                  "learningObjective": "Dominar o cálculo de vetores de deslocamento em 3D",
                                  "commonMistakes": [
                                    "Erro de sinal em subtrações",
                                    "Troca de eixos (x com y)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar o comprimento L do elemento de treliça",
                                  "subSteps": [
                                    "Calcule dx², dy² e dz²",
                                    "Some os quadrados: dx² + dy² + dz²",
                                    "Calcule L = √(dx² + dy² + dz²)",
                                    "Arredonde L para precisão necessária (ex: 3 casas decimais)",
                                    "Confirme que L > 0 (nós distintos)"
                                  ],
                                  "verification": "Valor de L calculado matches com verificação manual ou software",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora com função raiz quadrada",
                                    "Tabela de valores quadrados para verificação"
                                  ],
                                  "tips": "Use a fórmula pitagórica 3D: L é a hipotenusa em espaço tridimensional",
                                  "learningObjective": "Aplicar teorema de Pitágoras generalizado para comprimento euclidiano",
                                  "commonMistakes": [
                                    "Esquecer raiz quadrada",
                                    "Erro em soma de quadrados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular o vetor direção unitário (lx, ly, lz)",
                                  "subSteps": [
                                    "Calcule lx = dx / L",
                                    "Calcule ly = dy / L",
                                    "Calcule lz = dz / L",
                                    "Verifique normalização: √(lx² + ly² + lz²) ≈ 1.0",
                                    "Anote o vetor unitário final com precisão adequada"
                                  ],
                                  "verification": "Vetor unitário satisfaz condição de norma unitária (magnitude = 1)",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Software de vetores (ex: MATLAB ou Python NumPy para verificação)"
                                  ],
                                  "tips": "Sempre verifique a normalização para detectar divisões por zero ou erros prévios",
                                  "learningObjective": "Normalizar vetores para obter direções unitárias em análise estrutural",
                                  "commonMistakes": [
                                    "Dividir por L incorreto",
                                    "Esquecer verificação de norma unitária"
                                  ]
                                }
                              ],
                              "practicalExample": "Nó 1: (0, 0, 0) m; Nó 2: (3, 4, 0) m. Vetor bruto: (3,4,0); L = √(9+16+0) = 5 m; Unitário: (0.6, 0.8, 0). Verificação: √(0.36+0.64+0)=1.",
                              "finalVerifications": [
                                "Comprimento L é positivo e matches cálculo euclidiano",
                                "Vetor unitário tem magnitude exatamente 1 (ou ≈1 com arredondamento)",
                                "Componentes do vetor apontam corretamente da nó1 para nó2",
                                "Unidades consistentes em todas etapas",
                                "Cálculos reproduzíveis em software (ex: Python)",
                                "Diagrama final mostra vetor unitário escalado corretamente"
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos (erro < 0.1%)",
                                "Correta sequência lógica de passos sem saltos",
                                "Verificação de normalização realizada e documentada",
                                "Identificação e correção de erros comuns",
                                "Aplicação correta em contexto de treliça 3D",
                                "Clareza na documentação e diagrama"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Vetores e geometria analítica 3D",
                                "Física: Cinemática e forças direcionais em estruturas",
                                "Programação: Implementação em Python/MATLAB para automação",
                                "Desenho Técnico: Visualização CAD de treliças",
                                "Cálculo Numérico: Precisão em raízes e divisões"
                              ],
                              "realWorldApplication": "Em análise de elementos finitos para projetos de pontes, torres ou edifícios, define direções de barras em treliças 3D para calcular esforços internos e deformações sob cargas reais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.2",
                            "name": "Identificar graus de liberdade locais e globais",
                            "description": "Listar os 6 graus de liberdade por nó (ux,uy,uz por nó i e j) e explicar a relação entre o sistema local (apenas axial) e global (3D) para um elemento de treliça.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Graus de Liberdade (DOFs) em Estruturas 3D",
                                  "subSteps": [
                                    "Defina grau de liberdade como os deslocamentos independentes possíveis em um nó.",
                                    "Explique que em 3D, cada nó livre tem 3 DOFs translacionais: ux (x), uy (y), uz (z).",
                                    "Discuta restrições em nós suportados que reduzem DOFs.",
                                    "Revise DOFs totais em um sistema: número de nós livres × 3.",
                                    "Diferencie DOFs cinemáticos de estáticos."
                                  ],
                                  "verification": "Liste corretamente os 3 DOFs translacionais por nó e calcule DOFs totais para um exemplo simples com 2 nós livres.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Diagrama de nó 3D impresso ou desenhado"
                                  ],
                                  "tips": "Visualize o nó como uma partícula em espaço 3D; ignore rotações para treliças.",
                                  "learningObjective": "Entender os DOFs fundamentais por nó em ambientes 3D.",
                                  "commonMistakes": [
                                    "Confundir DOFs translacionais com rotações (treliças só têm translacionais)",
                                    "Esquecer que suportes eliminam DOFs"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar os 6 DOFs Globais por Elemento de Treliça",
                                  "subSteps": [
                                    "Desenhe um elemento de treliça entre nós i e j em 3D.",
                                    "Liste DOFs do nó i: uxi, uyi, uzi.",
                                    "Liste DOFs do nó j: uxj, uyj, uzj.",
                                    "Confirme que um elemento tem exatamente 6 DOFs globais (3 por nó).",
                                    "Marque DOFs em um diagrama do elemento."
                                  ],
                                  "verification": "Rotule um diagrama de elemento com os 6 DOFs globais corretamente nomeados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel milimetrado",
                                    "Régua e lápis",
                                    "Exemplo de treliça 3D simples"
                                  ],
                                  "tips": "Use setas vetoriais para representar cada DOF no diagrama.",
                                  "learningObjective": "Listar e visualizar os 6 DOFs globais para um elemento de treliça.",
                                  "commonMistakes": [
                                    "Listar apenas 2 DOFs por nó (confusão com 2D)",
                                    "Inverter notação i/j"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar DOFs Locais (Axial) dos Globais (3D)",
                                  "subSteps": [
                                    "Explique que no sistema local, o elemento só resiste axialmente: 1 DOF por nó (elongação u').",
                                    "Descreva o sistema local alinhado ao eixo do elemento: u'i e u'j.",
                                    "Compare: local tem 2 DOFs (diferencial axial), global tem 6 DOFs (3D).",
                                    "Discuta que forças locais são apenas axiais, sem cisalhamento ou momento em treliças.",
                                    "Desenhe os dois sistemas lado a lado."
                                  ],
                                  "verification": "Escreva uma tabela comparando DOFs locais vs globais, destacando diferenças.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha com tabela pré-formatada",
                                    "Calculadora para vetores unitários opcionais"
                                  ],
                                  "tips": "Pense no local como 'vista do elemento' (1D axial) vs global como 'vista da estrutura' (3D).",
                                  "learningObjective": "Distinguir sistemas locais (axial) e globais (3D) em treliças.",
                                  "commonMistakes": [
                                    "Confundir DOFs locais com 3D, incluindo transversais",
                                    "Ignorar que local é unidimensional"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar a Relação e Transformação entre Sistemas Local e Global",
                                  "subSteps": [
                                    "Introduza a matriz de transformação de rotação [T] baseada em ângulos do eixo.",
                                    "Mostre {u'} = [T] {u}, onde {u'} são locais e {u} globais.",
                                    "Calcule vetores direção lx, ly, lz para o eixo i-j.",
                                    "Derive DOFs locais dos globais via projeção.",
                                    "Verifique com exemplo: se alinhado ao x, [T] é identidade para ux."
                                  ],
                                  "verification": "Construa [T] para um elemento inclinado e transforme um vetor de deslocamento global para local.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software como MATLAB ou Python (opcional)",
                                    "Tabela de seno/cosseno",
                                    "Exemplo numérico impresso"
                                  ],
                                  "tips": "Use coordenadas dos nós para calcular cosenos diretores automaticamente.",
                                  "learningObjective": "Compreender e aplicar a transformação entre DOFs locais e globais.",
                                  "commonMistakes": [
                                    "Erro em cálculo de ângulos (use atan2)",
                                    "Esquecer transposição em [T]"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um elemento de treliça de nó i (0,0,0) a nó j (1,1,1). DOFs globais: uxi,uyi,uzi,uxj,uyj,uzj. Vetor direção: (1/√3,1/√3,1/√3). DOFs locais: u'i = projeção axial de deslocamentos i; u'j similar. Transforme uxj=1 (outros=0) para local: u'j ≈ 0.577.",
                              "finalVerifications": [
                                "Lista corretamente os 6 DOFs globais por elemento.",
                                "Diferencia DOFs locais (2 axiais) dos globais (6 3D).",
                                "Descreve matriz de transformação [T] corretamente.",
                                "Aplica transformação em exemplo numérico sem erros.",
                                "Explica por que treliças usam apenas DOFs translacionais.",
                                "Identifica DOFs totais em uma treliça simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na listagem de DOFs (100% correto).",
                                "Clareza na distinção local/global (diagrama legível).",
                                "Correção matemática na transformação (erro <1%).",
                                "Completude dos subpassos em cada step.",
                                "Aplicação prática no exemplo fornecido.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Vetores, matrizes de rotação e álgebra linear.",
                                "Física: Estática de partículas e equilíbrio em 3D.",
                                "Programação: Implementação de MEF em Python/MATLAB para DOFs.",
                                "Geometria: Cálculo de coordenadas e ângulos em espaço 3D."
                              ],
                              "realWorldApplication": "Em análise de pontes treliçadas ou torres de telecomunicações, identificar DOFs corretos garante simulações precisas de deformações sob vento ou carga, evitando colapsos como no caso de pontes históricas falhadas por modelagem errada."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.3",
                            "name": "Calcular matriz de rotação",
                            "description": "Construir a matriz de transformação 6x6 [T] usando os cossenos dirigidos (lx,ly,lz) para rotacionar forças e deslocamentos do sistema global para local.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular o comprimento do elemento e os cossenos dirigidos iniciais (lx, ly, lz)",
                                  "subSteps": [
                                    "Obtenha as coordenadas dos nós i (xi, yi, zi) e j (xj, yj, zj).",
                                    "Calcule as diferenças: dx = xj - xi, dy = yj - yi, dz = zj - zi.",
                                    "Calcule o comprimento L = √(dx² + dy² + dz²).",
                                    "Determine os cossenos dirigidos: lx = dx / L, ly = dy / L, lz = dz / L.",
                                    "Verifique se lx² + ly² + lz² = 1 (com tolerância numérica de 10^-6)."
                                  ],
                                  "verification": "Confirme que o vetor direção unitário satisfaz a condição de norma unitária: lx² + ly² + lz² ≈ 1.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Coordenadas dos nós, calculadora científica ou planilha (Excel/Google Sheets).",
                                  "tips": "Mantenha pelo menos 4 casas decimais nos cálculos para evitar erros de propagação.",
                                  "learningObjective": "Compreender o cálculo do vetor unitário diretor do elemento de treliça.",
                                  "commonMistakes": "Esquecer de dividir pelas diferenças por L (não normalizar), erro no sinal das diferenças dx, dy, dz."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o vetor auxiliar p para o eixo y' local",
                                  "subSteps": [
                                    "Verifique se |lz| ≠ 1 (elemento não paralelo ao eixo Z global).",
                                    "Calcule o produto vetorial p = [0, 0, 1] × [lx, ly, lz] = [-ly, lx, 0].",
                                    "Caso |lz| = 1, use p = [0, 1, 0] × [lx, ly, lz] = [lz, 0, -lx].",
                                    "Calcule a norma de p: |p| = √(px² + py² + pz²).",
                                    "Normalize para obter y': y'x = px / |p|, y'y = py / |p|, y'z = pz / |p|."
                                  ],
                                  "verification": "Confirme que y' é unitário: (y'x)² + (y'y)² + (y'z)² = 1 e perpendicular a [lx, ly, lz] (produto escalar ≈ 0).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora, tabela de fórmulas de produtos vetoriais.",
                                  "tips": "Sempre priorize o eixo Z global para evitar singularidades; memorize a fórmula do cross product.",
                                  "learningObjective": "Aprender a construir eixos ortogonais locais usando produtos vetoriais.",
                                  "commonMistakes": "Erro no sinal do produto vetorial, não tratar o caso especial |lz|=1, esquecer de normalizar p."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o vetor z' local como produto vetorial",
                                  "subSteps": [
                                    "Calcule z' = [lx, ly, lz] × [y'x, y'y, y'z].",
                                    "Use a fórmula: z'x = ly * y'z - lz * y'y, z'y = lz * y'x - lx * y'z, z'z = lx * y'y - ly * y'x.",
                                    "Verifique a norma de z': |z'| = √(z'x² + z'y² + z'z²) ≈ 1.",
                                    "Confirme perpendicularidade: produto escalar de z' com l e y' ≈ 0.",
                                    "Ajuste sinal se necessário para orientação direita (destro)."
                                  ],
                                  "verification": "Verifique ortogonalidade completa: l · z' = 0, y' · z' = 0, e |z'| = 1.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Calculadora, papel para anotações vetoriais.",
                                  "tips": "Use a regra da mão direita para o cross product para manter o sistema ortonormal dextrógiro.",
                                  "learningObjective": "Dominar a construção de bases ortonormais locais a partir de um vetor diretor.",
                                  "commonMistakes": "Inversão de ordem no cross product (l × y' vs y' × l), erros aritméticos nos componentes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar a matriz de rotação 3x3 [Λ]",
                                  "subSteps": [
                                    "Primeira linha: [lx, ly, lz].",
                                    "Segunda linha: [y'x, y'y, y'z].",
                                    "Terceira linha: [z'x, z'y, z'z].",
                                    "Verifique se [Λ] [Λ]^T = I (matriz identidade, com tolerância).",
                                    "Confirme que as linhas são os cossenos dirigidos corretos."
                                  ],
                                  "verification": "Multiplique [Λ] por sua transposta: deve resultar em matriz identidade 3x3.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Planilha ou software (MATLAB/Python) para verificação matricial.",
                                  "tips": "Escreva [Λ] explicitamente e teste uma multiplicação simples para validar.",
                                  "learningObjective": "Entender a matriz de cossenos dirigidos como transformação ortogonal.",
                                  "commonMistakes": "Colocar colunas em vez de linhas (ou vice-versa, dependendo da convenção), trocar linhas de y' e z'."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Construir a matriz de transformação 6x6 [T]",
                                  "subSteps": [
                                    "Crie o bloco superior esquerdo: [Λ] (3x3).",
                                    "Crie o bloco inferior direito: [Λ] (3x3).",
                                    "Preencha zeros nos blocos off-diagonal (3x3 zeros).",
                                    "Verifique dimensões: [T] deve ser 6x6.",
                                    "Confirme: [T] {d_global} = {d_local} para um vetor teste."
                                  ],
                                  "verification": "Aplique [T] a um vetor de deslocamento global conhecido e verifique transformação correta.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Matriz 6x6 em papel ou software de álgebra linear.",
                                  "tips": "Use blkdiag(Λ, Λ) em notação para simplicidade; teste com vetor unitário global.",
                                  "learningObjective": "Aplicar a matriz de rotação completa para DOFs de dois nós.",
                                  "commonMistakes": "Erro nos blocos (colocar Λ em posição errada), esquecer zeros nos off-diagonais."
                                }
                              ],
                              "practicalExample": "Considere nós i(0,0,0) e j(3,4,0). L=5, lx=0.6, ly=0.8, lz=0. p=[-0.8, 0.6, 0], y'=[-0.8, 0.6, 0]. z'=[0,0,1]. [Λ] = [[0.6,0.8,0], [-0.8,0.6,0], [0,0,1]]. [T] = blkdiag(Λ, Λ).",
                              "finalVerifications": [
                                "[T] é ortogonal: [T][T]^T = I_{6x6}.",
                                "Linhas de [Λ] têm norma unitária e são mutuamente ortogonais.",
                                "Primeira linha de [Λ] coincide com [lx, ly, lz].",
                                "Sistema local x' aponta de i para j.",
                                "Blocos off-diagonal de [T] são zeros.",
                                "Transformação preserva normas de vetores (isometria)."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cossenos dirigidos (erro < 0.1%).",
                                "Correta escolha e normalização do vetor p para y'.",
                                "Matriz [Λ] resulta em [Λ][Λ]^T = I (verificação exata).",
                                "Montagem correta da [T] 6x6 sem erros de posicionamento.",
                                "Explicação coerente do processo em palavras.",
                                "Tratamento correto de casos especiais (ex: paralelo a Z)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes ortogonais, produtos vetoriais).",
                                "Física: Mecânica vetorial e sistemas de coordenadas rotacionados.",
                                "Programação: Implementação em Python (NumPy) ou MATLAB para automação FEA.",
                                "Geometria Computacional: Definição de frames locais em CAD.",
                                "Engenharia Civil: Análise de estruturas espaciais."
                              ],
                              "realWorldApplication": "Em softwares FEA como ANSYS ou SAP2000, a matriz [T] é usada para transformar rigidez, forças e deslocamentos de elementos de treliças 3D em estruturas reais como torres de transmissão, pontes estaiadas e galpões industriais, garantindo precisão na simulação de deformações e tensões."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.2",
                        "name": "Formulação da Matriz de Rigidez Local",
                        "description": "Derivação da matriz de rigidez [k_local] para o elemento de treliça 3D, considerando apenas deformação axial, propriedades do material (E, A) e geometria.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.2.1",
                            "name": "Derivar rigidez axial local",
                            "description": "Calcular a matriz de rigidez local 2x2 [k'] = (AE/L) * [1 -1; -1 1], onde A é área da seção, E módulo de elasticidade e L comprimento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o elemento de treliça axial e variáveis básicas",
                                  "subSteps": [
                                    "Identifique o elemento como uma barra 1D que resiste apenas a cargas axiais (tração/compressão).",
                                    "Defina os nós: nó 1 com deslocamento axial u₁ e nó 2 com u₂.",
                                    "Introduza as propriedades: A (área da seção transversal), E (módulo de elasticidade) e L (comprimento do elemento).",
                                    "Esboce o elemento com setas indicando deslocamentos positivos.",
                                    "Anote a relação constitutiva σ = E ε, onde σ é tensão e ε é deformação."
                                  ],
                                  "verification": "Verifique se o diagrama do elemento está desenhado corretamente com todas as variáveis rotuladas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel, lápis, régua para esboço.",
                                  "tips": "Use convenções positivas consistentes: deslocamento para a direita é positivo.",
                                  "learningObjective": "Compreender a geometria e propriedades do elemento de treliça 1D.",
                                  "commonMistakes": "Confundir deslocamentos locais com globais ou inverter sinais de u₁ e u₂."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a deformação axial em termos de deslocamentos nodais",
                                  "subSteps": [
                                    "Lembre que a deformação ε é a variação de comprimento dividida por L original.",
                                    "Expresse a elongação δ = u₂ - u₁.",
                                    "Calcule ε = δ / L = (u₂ - u₁) / L.",
                                    "Confirme que ε é constante ao longo do elemento (suposição de barra reta e deformação uniforme).",
                                    "Escreva a expressão matricialmente como {ε} = [B] {u}, onde B = [-1/L, 1/L]."
                                  ],
                                  "verification": "Substitua valores numéricos simples (ex: u₁=0, u₂=0.01L) e confirme ε=0.01.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel, calculadora para testes numéricos.",
                                  "tips": "Sempre normalize pela L para obter deformação adimensional.",
                                  "learningObjective": "Derivar a deformação ε a partir dos graus de liberdade nodais.",
                                  "commonMistakes": "Esquecer o sinal: usar (u₁ - u₂) em vez de (u₂ - u₁)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar a tensão e a força interna no elemento",
                                  "subSteps": [
                                    "Aplique a lei de Hooke: σ = E ε = E (u₂ - u₁)/L.",
                                    "Calcule a força axial interna N = σ A = (A E / L) (u₂ - u₁).",
                                    "Note que N é positiva para tração (u₂ > u₁).",
                                    "Verifique equilíbrio: força constante em todo o elemento.",
                                    "Expresse {σ} = [D] {ε}, onde D = E para comportamento linear elástico."
                                  ],
                                  "verification": "Calcule N para u₂ - u₁ = 0.01L e confirme proporcionalidade.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel, calculadora.",
                                  "tips": "Mantenha N como força escalar positiva para tração.",
                                  "learningObjective": "Relacionar deformação a tensão e força usando propriedades materiais.",
                                  "commonMistakes": "Inverter o sinal de N ou esquecer multiplicar por A."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar as forças nodais e montar a matriz de rigidez local",
                                  "subSteps": [
                                    "Aplique equilíbrio nodal: no nó 1, f₁ = -N; no nó 2, f₂ = N.",
                                    "Substitua N: f₁ = (A E / L) (u₁ - u₂); f₂ = (A E / L) (u₂ - u₁).",
                                    "Escreva em forma matricial: {f} = [k'] {u}, com [k'] = (A E / L) [1, -1; -1, 1].",
                                    "Verifique simetria e propriedades: k'ᵀ = k', soma das linhas zero (equilíbrio).",
                                    "Confirme com teste: para {u} = [1; 0], {f} = (A E / L) [1; -1]."
                                  ],
                                  "verification": "Multiplique matriz por vetor de deslocamentos e obtenha forças corretas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, lápis, calculadora matricial opcional.",
                                  "tips": "Use a forma [1 -1; -1 1] para anti-simétrica nas diagonais opostas.",
                                  "learningObjective": "Obter a matriz 2x2 de rigidez local a partir do equilíbrio.",
                                  "commonMistakes": "Erros nos sinais das off-diagonais ou fator (AE/L) fora do lugar."
                                }
                              ],
                              "practicalExample": "Considere uma barra de aço com A = 1 cm² (10^{-4} m²), E = 200 GPa (2x10^{11} Pa), L = 2 m. Derivar [k'] = (10^{-4} * 2x10^{11} / 2) [1 -1; -1 1] = 10^7 [1 -1; -1 1] N/m. Para u₁=0.001 m, u₂=0, f₁=10^4 N (compressão), f₂=-10^4 N.",
                              "finalVerifications": [
                                "Derivar corretamente ε = (u₂ - u₁)/L.",
                                "Obter N = (AE/L)(u₂ - u₁).",
                                "Montar [k'] = (AE/L) [1 -1; -1 1] sem erros de sinal.",
                                "Verificar equilíbrio: f₁ + f₂ = 0.",
                                "Aplicar a um exemplo numérico e confirmar forças.",
                                "Explicar verbalmente a origem física de cada termo da matriz."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da deformação e tensão (100% correto).",
                                "Correta aplicação de equilíbrio nodal (sinais consistentes).",
                                "Forma matricial exata, incluindo fator escalar AE/L.",
                                "Verificação numérica ou propriedades da matriz (simetria, nulidade).",
                                "Clareza na explicação subjacente (física e matemática).",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes, produto matricial).",
                                "Física: Lei de Hooke e equilíbrio estático.",
                                "Programação: Implementação em código para FEM (ex: Python com NumPy).",
                                "Química dos Materiais: Variação de E para diferentes materiais.",
                                "Desenho Técnico: Representação gráfica de elementos estruturais."
                              ],
                              "realWorldApplication": "Essa matriz é a base para análise de treliças em pontes, torres de transmissão e estruturas aeroespaciais via software FEM como ANSYS ou Abaqus, permitindo simular deformações e tensões em edifícios sob cargas reais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.2.2",
                            "name": "Transformar para rigidez global",
                            "description": "Obter [k_global] = [T]^T [k'] [T], expandindo para matriz 12x12 (6 DOF por nó) com zeros nas direções transversais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Matriz de Rigidez Local e Graus de Liberdade",
                                  "subSteps": [
                                    "Identifique a matriz de rigidez local [k'] para o elemento treliça 3D, tipicamente 2x2 ou expandida para axiais apenas.",
                                    "Liste os 6 DOF por nó: 3 translações (ux, uy, uz) e 3 rotações (θx, θy, θz), totalizando 12 DOF para dois nós.",
                                    "Note que para treliças, apenas DOF axiais têm rigidez não-zero; transversais e rotações são zero.",
                                    "Esboce o vetor de deslocamentos local {u'} = [u1', v1', w1', u2', v2', w2']^T, focando no axial.",
                                    "Confirme o comprimento L e ângulos de orientação do elemento."
                                  ],
                                  "verification": "A matriz [k'] está corretamente definida como [[AE/L, 0, -AE/L, 0], ...] com zeros em transversais, e DOF listados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Folha de papel, calculadora, notas de formulação local de treliças 3D.",
                                  "tips": "Sempre comece pelo sistema local alinhado ao eixo do elemento para simplicidade.",
                                  "learningObjective": "Compreender a estrutura da matriz local e por que expansões com zeros são necessárias em 3D.",
                                  "commonMistakes": "Confundir DOF de treliças (3 por nó) com barras gerais (6 por nó); esquecer zeros em rotações."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Matriz de Transformação [T]",
                                  "subSteps": [
                                    "Calcule os cossenos diretores: λx = (x2-x1)/L, λy = (y2-y1)/L, λz = (z2-z1)/L.",
                                    "Forme a matriz de rotação 3x3 [R] = [[λx, λy, λz], [-μx, -μy, -μz], ...] onde μ, ν são vetores perpendiculares unitários.",
                                    "Expanda [T] para 12x6 ou adequadamente, mas para treliças use [T] 12x12 com blocos [R] nos axiais e identidade/zeros nos outros DOF.",
                                    "Verifique que [T] transforma {u_global} para {u_local} via {u'} = [T] {u}.",
                                    "Teste com vetor unitário para validar ortogonalidade ([T]^T [T] ≈ I)."
                                  ],
                                  "verification": "Multiplique [T] por vetor global simples e confirme mapeamento correto para local.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora matricial (Matlab/Python ou app), coordenadas de exemplo de nós.",
                                  "tips": "Use vetores unitários locais: e1 ao longo do elemento, e2=e3 cruzado.",
                                  "learningObjective": "Dominar a construção de [T] para alinhar coordenadas locais-globais em 3D.",
                                  "commonMistakes": "Erro nos cossenos diretores (não normalizar por L); confundir [R] com transposição."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Transformação [k_global] = [T]^T [k'] [T]",
                                  "subSteps": [
                                    "Expanda [k'] para 12x12 inserindo zeros nas posições transversais e rotações.",
                                    "Compute primeiro [k_temp] = [k'] [T].",
                                    "Em seguida, [k_global] = [T]^T [k_temp].",
                                    "Verifique simetria da matriz resultante (k_ij = k_ji).",
                                    "Confirme que apenas entradas axiais (correspondendo a DOF u ao longo do elemento) são não-zero."
                                  ],
                                  "verification": "A matriz [k_global] é 12x12 simétrica com não-zeros apenas nas direções axiais globais.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software de álgebra linear (Python NumPy, Matlab), matrizes pré-computadas.",
                                  "tips": "Implemente em código para evitar cálculos manuais tediosos; use sparse matrices.",
                                  "learningObjective": "Executar a multiplicação matricial corretamente preservando propriedades de rigidez.",
                                  "commonMistakes": "Não transpor [T] corretamente; multiplicar na ordem errada; esquecer expansão de [k']."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Interpretar a Matriz Global",
                                  "subSteps": [
                                    "Some as linhas/colunas para rigidez total e compare com AE/L esperado.",
                                    "Aplique deslocamento unitário global e verifique força reativa.",
                                    "Compare com formulação analítica para elemento alinhado (deve coincidir).",
                                    "Documente posições exatas de não-zeros (ex: k11 = (AE/L) λx^2).",
                                    "Discuta montagem em estrutura maior."
                                  ],
                                  "verification": "Teste de deslocamento unitário produz força axial esperada; matriz simétrica e positiva definida.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Código de validação, exemplo numérico completo.",
                                  "tips": "Sempre valide com caso simples (elemento alinhado ao eixo X).",
                                  "learningObjective": "Interpretar resultados físicos da transformação.",
                                  "commonMistakes": "Ignorar verificação de simetria; não testar com casos conhecidos."
                                }
                              ],
                              "practicalExample": "Para elemento treliça de A=1 cm², E=200 GPa, L=2m, de nó1(0,0,0) a nó2(1,1,1): λx=λy=λz=1/√3. [k'] local = (AE/L) [[1,0,-1,0],...]. Construa [T] com [R], expanda, compute [k_global] 12x12. Entrada k1,7 (ux1-ux2) = (AE/L)(λx)^2 ≈ 33.33 MN/m.",
                              "finalVerifications": [
                                "Matriz [k_global] é 12x12 simétrica com zeros em rotações e transversais.",
                                "Rigidez axial global soma corretamente: k_axial = (AE/L) para direção local.",
                                "Teste de deslocamento unitário ao longo do elemento produz força AE/L.",
                                "Ortogonalidade: [T]^T [T] = I (dentro de tolerância numérica).",
                                "Comparação com software FEA (ex: Ansys) para mesmo elemento coincide.",
                                "Montagem em treliça simples resolve deslocamentos corretos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção de [T]: cossenos corretos e blocos posicionados.",
                                "Correção da multiplicação matricial sem erros aritméticos.",
                                "Identificação correta de zeros e não-zeros na matriz final.",
                                "Validação física via testes de deslocamento/força.",
                                "Explicação clara da interpretação (ex: contribuição axial global).",
                                "Eficiência: uso de software sem bugs para casos complexos."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Multiplicações matriciais, ortogonalidade, transformações.",
                                "Programação: Implementação em Python/NumPy para automação FEA.",
                                "Física/Mecânica: Princípios de equilíbrio e deformação axial.",
                                "Geometria: Vetores diretores e sistemas de coordenadas 3D."
                              ],
                              "realWorldApplication": "Na análise estrutural de torres de telecomunicações ou pontes treliçadas, transforma rigidez local de cada barra para coordenadas globais, permitindo montagem da matriz global do sistema para prever deformações sob cargas reais como vento ou peso próprio."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.1.3"
                            ]
                          },
                          {
                            "id": "10.1.3.4.2.3",
                            "name": "Verificar simetria e propriedades da matriz",
                            "description": "Confirmar que [k_global] é simétrica positiva definida para elemento estável, identificando termos não nulos apenas ao longo da direção axial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e revisar a matriz de rigidez global [k_global]",
                                  "subSteps": [
                                    "Monte ou obtenha a matriz [k_global] a partir da montagem das matrizes locais de rigidez das barras da treliça 3D.",
                                    "Identifique as dimensões da matriz (ex: 6x6 para dois nós com 3 DOFs cada).",
                                    "Anote os elementos não nulos esperados, concentrados na direção axial das barras.",
                                    "Confirme que a matriz representa um elemento estável (sem mecanismos rígidos)."
                                  ],
                                  "verification": "Verifique se todos os elementos da matriz estão corretamente indexados e se correspondem à geometria da treliça.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Matriz de rigidez local das barras",
                                    "Folha de cálculo ou software como MATLAB/Octave",
                                    "Diagrama da treliça 3D"
                                  ],
                                  "tips": "Use notação matricial padrão e rotule linhas/colunas com DOFs (ex: ux1, uy1, uz1, ux2, uy2, uz2).",
                                  "learningObjective": "Entender a origem e estrutura da [k_global] para análise de propriedades.",
                                  "commonMistakes": "Esquecer de aplicar condições de contorno ou rotacionar matrizes locais incorretamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar a simetria da matriz [k_global]",
                                  "subSteps": [
                                    "Para cada par (i,j) com i < j, compare k[i][j] com k[j][i].",
                                    "Calcule a diferença |k[i][j] - k[j][i]| e confirme que é menor que um tolerância numérica (ex: 1e-10).",
                                    "Verifique a diagonal principal (deve ser positiva para rigidez).",
                                    "Gere a matriz transposta e subtraia da original para obter matriz de simetria zero."
                                  ],
                                  "verification": "A matriz transposta deve ser idêntica à original dentro de tolerância numérica.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora matricial ou Python/MATLAB com funções transpose() e norm()",
                                    "Matriz [k_global] preparada"
                                  ],
                                  "tips": "Use loops ou comandos vetorizados para eficiência em matrizes maiores.",
                                  "learningObjective": "Dominar a verificação explícita de simetria em matrizes de rigidez.",
                                  "commonMistakes": "Ignorar erros de arredondamento numérico em cálculos flutuantes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar termos não nulos e padrão de esparsidade axial",
                                  "subSteps": [
                                    "Plote ou liste os elementos não nulos, destacando posições correspondentes à direção axial das barras.",
                                    "Confirme que termos fora da direção axial (ex: transversais) são zero ou desprezíveis.",
                                    "Verifique o padrão de banda: termos não nulos apenas conectados por barras reais.",
                                    "Compare com o grafo da treliça para validar conexões."
                                  ],
                                  "verification": "Todos os não nulos correspondem a DOFs conectados axialmente; zeros fora disso.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Software de visualização de matriz esparsa (spy() no MATLAB)",
                                    "Diagrama nodal da treliça"
                                  ],
                                  "tips": "Use representação esparsa para treliças grandes e evite matrizes densas desnecessárias.",
                                  "learningObjective": "Reconhecer o padrão de esparsidade típico de treliças para eficiência computacional.",
                                  "commonMistakes": "Confundir DOFs globais com locais, levando a não-nulos espúrios."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar se a matriz é positiva definida",
                                  "subSteps": [
                                    "Calcule todos os autovalores da matriz usando decomposição espectral.",
                                    "Confirme que o menor autovalor é positivo (λ_min > 0).",
                                    "Teste critérios alternativos: todos os principais menores > 0 ou teste de Cholesky bem-sucedido.",
                                    "Analise determinantes de submatrizes principais para validação manual."
                                  ],
                                  "verification": "Menor autovalor > 0 e decomposição de Cholesky converge sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software com eig() ou chol() (MATLAB/Python)",
                                    "Matriz [k_global] simétrica"
                                  ],
                                  "tips": "Para matrizes grandes, use métodos iterativos como Lanczos para autovalores extremos.",
                                  "learningObjective": "Aplicar testes de definitude positiva para garantir estabilidade estática.",
                                  "commonMistakes": "Não remover DOFs rígidos ou reações, levando a autovalores zero."
                                }
                              ],
                              "practicalExample": "Em uma treliça 3D simples com duas barras conectando nós (1: fixo) e (2: livre), com ângulo 45° no plano xy. Matriz local k_local = EA/L * [c² cs 0; cs s² 0; ...] onde c=cosθ, s=sinθ. Após montagem global 6x6, verifique k[1,4]=k[4,1]>0 (axial x), k[2,5]=k[5,2]>0 (axial y), zeros em z e transversais; autovalores todos >0.",
                              "finalVerifications": [
                                "[k_global] é simétrica: k^T = k.",
                                "Padrão de não-nulos limitado à direção axial das barras.",
                                "Menor autovalor positivo, confirmando positiva definida.",
                                "Diagonal dominante com entradas positivas.",
                                "Decomposição de Cholesky bem-sucedida.",
                                "Nenhum autovalor zero ou negativo (sem mecanismos/rigidez negativa)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na verificação de simetria (tolerância <1e-10).",
                                "Correta identificação de todos os não-nulos axiais.",
                                "Cálculo correto de autovalores com interpretação.",
                                "Explicação clara de implicações para estabilidade.",
                                "Uso eficiente de ferramentas computacionais.",
                                "Documentação completa com prints/plots."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Propriedades de matrizes simétricas e autovalores.",
                                "Programação: Manipulação de matrizes esparsas em Python/MATLAB.",
                                "Física: Equilíbrio estático e energia de deformação positiva.",
                                "Engenharia Computacional: Pré-condicionadores para solvers iterativos."
                              ],
                              "realWorldApplication": "Em software FEA como ANSYS ou Abaqus para análise de pontes e edifícios, verificar [k_global] garante soluções estáveis e precisas, evitando colapsos simulados por matrizes singulares em projetos de infraestrutura."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.3",
                        "name": "Montagem Global e Análise de Estabilidade",
                        "description": "Processo de assemblagem das matrizes de rigidez locais na global, aplicação de condições de contorno e verificação de estabilidade numérica e física da treliça.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.3.1",
                            "name": "Montar matriz de rigidez global",
                            "description": "Para uma treliça com ne elementos e nn nós (6*nn DOF), somar contribuições [k^e] nas posições corretas usando conectividade nodal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a estrutura da treliça e inicializar a matriz global",
                                  "subSteps": [
                                    "Identifique o número de nós (nn) e elementos (ne) da treliça 3D.",
                                    "Calcule o total de graus de liberdade (DOF = 6 * nn), considerando 6 DOF por nó (3 translações + 3 rotações).",
                                    "Crie a tabela de conectividade nodal para cada elemento (nós iniciais e finais).",
                                    "Inicialize a matriz de rigidez global K_global como uma matriz nula de tamanho DOF x DOF.",
                                    "Liste as coordenadas dos nós e propriedades dos elementos (comprimento, área, módulo de elasticidade)."
                                  ],
                                  "verification": "Verifique se K_global tem dimensões corretas (6*nn x 6*nn) e está zerada, e se a conectividade está mapeada sem erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Diagrama da treliça",
                                    "Tabela de coordenadas nodais",
                                    "Tabela de propriedades elementares",
                                    "Planilha ou software como MATLAB/Excel para matrizes"
                                  ],
                                  "tips": [
                                    "Numere os nós sequencialmente de 1 a nn.",
                                    "Confirme que cada nó tem DOF 1-6 para nó 1, 7-12 para nó 2, etc.",
                                    "Use índices baseados em 1 para evitar erros off-by-one."
                                  ],
                                  "learningObjective": "Compreender a relação entre nós, elementos e DOF totais na formulação global.",
                                  "commonMistakes": [
                                    "Errar o cálculo de DOF (ex: usar 3 em vez de 6 por nó)",
                                    "Invertar nós inicial/final na conectividade",
                                    "Inicializar matriz com valores não-zero"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular as matrizes de rigidez elementares [k^e]",
                                  "subSteps": [
                                    "Para cada elemento e, calcule o vetor de direção e comprimento L entre nós conectados.",
                                    "Determine a matriz de rotação [T] para transformar DOF locais para globais em 3D.",
                                    "Compute a matriz de rigidez local [k_local] usando fórmula [k] = (AE/L) * [matriz de treliça local].",
                                    "Transforme para global: [k^e] = [T]^T * [k_local] * [T].",
                                    "Armazene [k^e] (12x12 para elemento com 2 nós * 6 DOF)."
                                  ],
                                  "verification": "Confira se cada [k^e] é simétrica e tem soma de linhas zero (equilíbrio), e dimensões 12x12.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Fórmulas de elementos finitos para treliças 3D",
                                    "Calculadora ou software simbólico (SymPy/MATLAB)",
                                    "Tabelas de transformação de coordenadas"
                                  ],
                                  "tips": [
                                    "Use ângulos Euler ou vetores diretores para [T].",
                                    "Verifique unidades consistentes (AE/L em N/m).",
                                    "Teste com elemento alinhado ao eixo para validar."
                                  ],
                                  "learningObjective": "Dominar o cálculo de [k^e] considerando geometria 3D e transformações.",
                                  "commonMistakes": [
                                    "Erro no cálculo de cosenos direcionais",
                                    "Esquecer transposição em [T]^T",
                                    "Confundir local/global"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear e somar contribuições elementares na matriz global",
                                  "subSteps": [
                                    "Para cada elemento e, identifique os índices globais dos DOF usando conectividade (ex: nó i: (i-1)*6+1 a i*6).",
                                    "Extraia submatriz [k^e] e some nas posições correspondentes de K_global para cada par de nós.",
                                    "Repita para todos os ne elementos, acumulando contribuições sobrepostas.",
                                    "Garanta que apenas DOF conectados sejam afetados (sparsity).",
                                    "Use loops ou scatter-add para eficiência em implementação numérica."
                                  ],
                                  "verification": "Inspecione entradas não-zero apenas em posições de nós conectados; confirme soma correta em sobreposições.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": [
                                    "Código de montagem (Python/MATLAB com loops)",
                                    "Matriz esparsa opcional (SciPy sparse)",
                                    "Exemplo impresso de índices"
                                  ],
                                  "tips": [
                                    "Implemente como função: assemble(K, ke, dof_map).",
                                    "Debugue imprimindo contribuições por elemento.",
                                    "Para grandes ne, use formato CSR para eficiência."
                                  ],
                                  "learningObjective": "Aplicar conectividade para montagem eficiente da matriz global.",
                                  "commonMistakes": [
                                    "Índices off-by-one em DOF",
                                    "Não somar corretamente em nós compartilhados",
                                    "Adicionar em posições erradas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e finalizar a matriz de rigidez global",
                                  "subSteps": [
                                    "Confirme simetria: K_global = K_global^T.",
                                    "Verifique propriedades: diagonais positivas, rigidez infinita em suportes (pré-condições).",
                                    "Teste com vetor unitário: verifique energia positiva.",
                                    "Compare com montagem manual para treliça pequena.",
                                    "Salve ou exporte K_global para análise estática."
                                  ],
                                  "verification": "Matriz simétrica, dimensões corretas, não singular prematuramente, e trace positiva.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Funções de verificação (eig, trace, is_symmetric)",
                                    "Software de FEM (ex: FEniCS para validação)"
                                  ],
                                  "tips": [
                                    "Use tol=1e-10 para simetria numérica.",
                                    "Aplique BCs após montagem.",
                                    "Visualize sparsity pattern."
                                  ],
                                  "learningObjective": "Garantir integridade da matriz montada para análises subsequentes.",
                                  "commonMistakes": [
                                    "Ignorar assimetria numérica",
                                    "Esquecer verificação de sparsity",
                                    "Matriz singular por erro de montagem"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma treliça 3D com nn=3 nós (DOF=18) e ne=2 elementos: elemento 1 conecta nós 1-2, elemento 2 conecta nós 2-3. Para elemento 1, [k^1] 12x12 é computado e somado nas linhas/colunas 1-12 de K_global. Elemento 2 adiciona em 7-18. Na posição (7,7), soma contribuições de ambos elementos conectados ao nó 2.",
                              "finalVerifications": [
                                "Dimensões exatas de (6*nn) x (6*nn).",
                                "Simetria perfeita (K[i,j] == K[j,i]).",
                                "Estrutura esparsa: não-zeros apenas em DOF conectados.",
                                "Diagonais principais positivas.",
                                "Soma de rigidez em nós compartilhados correta.",
                                "Compatível com vetor de deslocamentos unitário (energia positiva)."
                              ],
                              "assessmentCriteria": [
                                "Mapeamento preciso de conectividade nodal para índices DOF.",
                                "Cálculo correto de [k^e] com transformações 3D.",
                                "Soma acumulada sem erros de indexação.",
                                "Verificações de simetria e propriedades implementadas.",
                                "Eficiência na montagem (tempo/espaço para ne grande).",
                                "Documentação clara de passos e fórmulas usadas."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: operações de adição e transposição de matrizes grandes.",
                                "Programação: implementação de loops e estruturas de dados esparsas (NumPy/SciPy).",
                                "Física/Estática: princípios de equilíbrio e rigidez estrutural.",
                                "Matemática Numérica: métodos de elementos finitos e estabilidade.",
                                "Engenharia de Software: modularidade em solvers FEM."
                              ],
                              "realWorldApplication": "Na análise de estabilidade de estruturas como torres eólicas, pontes atirantadas ou plataformas offshore, onde a matriz global é essencial para prever deformações e tensões sob cargas reais usando software como ANSYS ou Abaqus."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2.2"
                            ]
                          },
                          {
                            "id": "10.1.3.4.3.2",
                            "name": "Aplicar condições de contorno",
                            "description": "Eliminar ou penalizar DOF restritos (apoios), reduzindo o sistema [K_red] {u_red} = {F_red} para graus de liberdade ativos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e Catalogar DOFs Restritos",
                                  "subSteps": [
                                    "Examinar o diagrama da treliça 3D para localizar nós com apoios (fixos, rolantes, etc.).",
                                    "Para cada nó, listar DOFs restritos: UX, UY, UZ por nó, usando numeração global sequencial.",
                                    "Mapear DOFs ativos vs. restritos em uma tabela (ex: total 24 DOFs, 6 restritos).",
                                    "Documentar reações esperadas nos apoios para validação posterior.",
                                    "Verificar consistência com equilíbrio estático global."
                                  ],
                                  "verification": "Tabela de DOFs restritos e ativos está completa e sem duplicatas, totalizando DOFs corretos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama da treliça 3D",
                                    "Tabela de numeração de nós e DOFs",
                                    "Folha de cálculo ou software como Excel/MATLAB"
                                  ],
                                  "tips": "Use convenção consistente: DOF 3(n-1)+1=UX_n, +2=UY_n, +3=UZ_n.",
                                  "learningObjective": "Catalogar precisamente DOFs restritos baseados em condições de contorno físicas.",
                                  "commonMistakes": [
                                    "Confundir numeração de DOFs entre nós",
                                    "Esquecer restrições parciais em apoios rolantes",
                                    "Ignorar simetria da estrutura"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e Preparar Método de Imposição",
                                  "subSteps": [
                                    "Avaliar métodos: Eliminação direta (remove linhas/colunas) vs. Penalização (K_ii += alfa grande, F_i=0).",
                                    "Escolher eliminação para precisão numérica em problemas pequenos; penalização para implementação matricial geral.",
                                    "Criar vetor de índices: restritos (ex: [1,2,3,9]) e ativos (restantes).",
                                    "Para penalização, definir alfa = 1e12 * max(diag(K)) e preparar modificações.",
                                    "Testar escolha em um DOF isolado para validar."
                                  ],
                                  "verification": "Índices de DOFs ativos/restritos estão corretos e método selecionado justificado por escrito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matriz de rigidez global [K]",
                                    "Vetor de forças [F]",
                                    "Calculadora ou MATLAB para alfa"
                                  ],
                                  "tips": "Prefira eliminação se #DOFs restritos < 20% do total para evitar il-condicionamento.",
                                  "learningObjective": "Selecionar método apropriado de imposição de contorno com justificativa técnica.",
                                  "commonMistakes": [
                                    "Alfa muito pequeno na penalização causando movimento espúrio",
                                    "Índices off-by-one em listas",
                                    "Não considerar rigidez relativa"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Redução do Sistema Global",
                                  "subSteps": [
                                    "Para eliminação: Extrair submatriz [K_red] = K(ativos,ativos), [F_red] = F(ativos), zerar linhas/colunas restritas.",
                                    "Para penalização: Modificar K(restrito,restrito) += alfa * eye, F(restrito)=0.",
                                    "Implementar em software ou manualmente para matriz pequena (ex: 12x12 -> 8x8).",
                                    "Calcular determinante ou cond(K_red) para checar não-singularidade.",
                                    "Salvar [K_red], [u_red] será resolvido depois."
                                  ],
                                  "verification": "Dimensões de [K_red] e [F_red] coincidem com #DOFs ativos; K_red é simétrica positiva definida.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Matriz [K] montada previamente (software: MATLAB/ANSYS)",
                                    "Script de redução ou papel para manual"
                                  ],
                                  "tips": "Use slicing matricial em Python/MATLAB: K_red = K[idx_ativos, idx_ativos].",
                                  "learningObjective": "Executar redução matricial correta para DOFs ativos.",
                                  "commonMistakes": [
                                    "Remover linhas mas não colunas",
                                    "Copiar F_restrito por engano",
                                    "Perder simetria da matriz"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Estabilidade e Consistência do Sistema Reduzido",
                                  "subSteps": [
                                    "Conferir se #linhas [K_red] == #DOFs ativos e rank(K_red) == tamanho.",
                                    "Aplicar teste de equilíbrio: Somar forças em DOFs restritos deve ser zero pós-solução.",
                                    "Simular deslocamentos nulos em restritos: u_restrito ≈ 0 (penalização) ou exato (eliminação).",
                                    "Comparar com solução analítica para treliça simples.",
                                    "Documentar sistema pronto para solver: [K_red]{u_red} = {F_red}."
                                  ],
                                  "verification": "Testes de nulidade em restritos passam e equilíbrio global satisfeito.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "[K_red] e [F_red] gerados",
                                    "Solver linear (MATLAB: \\ ou lu)",
                                    "Solução de referência analítica"
                                  ],
                                  "tips": "Eigenvalues(K_red) > 0 confirma estabilidade rígida.",
                                  "learningObjective": "Validar sistema reduzido quanto a estabilidade e precisão.",
                                  "commonMistakes": [
                                    "Ignorar modos rígidos residuais",
                                    "Não checar singularidade",
                                    "Erro de escala em penalização"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma treliça 3D com 4 nós (12 DOFs), nó 1 fixo (DOFs 1-3=0), nó 4 rolante UZ=0 (DOF 12=0). Matriz K 12x12 montada. Eliminação: idx_ativos=[4:11], K_red=K(4:11,4:11), F_red=F(4:11). Resolver para u_red, então u_full com zeros nos restritos. Resultado: deslocamentos consistentes com apoios.",
                              "finalVerifications": [
                                "DOFs restritos têm u≈0 (tol 1e-10).",
                                "Dimensões [K_red] corretas (n_ativo x n_ativo).",
                                "Equilíbrio de forças nos apoios via reações calculadas.",
                                "Energia total positiva e finita.",
                                "Convergência com malha refinada (teste sensibilidade).",
                                "Comparação qualitativa com intuição física (ex: sem rotações em fixo)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de DOFs (100% match com modelo).",
                                "Correção na redução matricial (erro <1e-8 vs. referência).",
                                "Justificativa técnica do método escolhido.",
                                "Eficiência computacional (tempo < esperado).",
                                "Validações completas executadas e documentadas.",
                                "Tratamento de erros comuns demonstrado."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Redução de sistemas lineares e decomposição.",
                                "Programação Numérica: Implementação de solvers matriciais (MATLAB/Python).",
                                "Física/Estática: Equilíbrio de forças e momentos em 3D.",
                                "Análise Numérica: Condicionamento e estabilidade numérica.",
                                "Engenharia de Software: Modularidade em códigos FEA."
                              ],
                              "realWorldApplication": "Em projetos de pontes treliçadas, torres eólicas ou estruturas aeroespaciais, condições de contorno simulam apoios reais (ex: base fixada em solo), permitindo prever deformações e falhas sob cargas, otimizando design e segurança."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.3.3",
                            "name": "Analisar estabilidade da treliça",
                            "description": "Verificar rank de [K], detectar mecanismos rígidos (autovalores zero) ou instabilidades, e propor soluções como adicionar elementos ou apoios.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Verificar a Matriz de Rigidez Global [K]",
                                  "subSteps": [
                                    "Coletar dados da treliça: coordenadas dos nós, conectividade das barras, propriedades dos materiais (módulo de elasticidade E, área transversal A) e condições de apoio.",
                                    "Montar as matrizes de rigidez locais para cada barra usando fórmulas padrão para treliças 3D.",
                                    "Aplicar transformações de coordenadas e montar [K] global por superposição.",
                                    "Verificar simetria e positivo-definido parcial de [K] preliminarmente.",
                                    "Impor condições de contorno eliminando DOFs restritos ou usando método de penalidade."
                                  ],
                                  "verification": "Conferir se [K] é simétrica, tem tamanho correto (3n x 3n, n=nós) e valores diagonais positivos; testar com vetor unitário para rigidez.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software: MATLAB ou Python (NumPy/SciPy)",
                                    "Planilhas ou papel para modelo pequeno",
                                    "Documentação de EF para treliças 3D"
                                  ],
                                  "tips": "Sempre normalize unidades (N, m) para evitar erros numéricos; use scripts reutilizáveis para montagem.",
                                  "learningObjective": "Dominar a montagem precisa de [K] global para treliças 3D, garantindo base sólida para análise.",
                                  "commonMistakes": [
                                    "Esquecer transformações de eixo local-global",
                                    "Não impor apoios corretamente levando a DOFs espúrios",
                                    "Erros de indexação na superposição"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o Rank da Matriz [K]",
                                  "subSteps": [
                                    "Implementar decomposição SVD (Singular Value Decomposition) ou QR para determinar rank.",
                                    "Contar o número de autovalores singulares não-nulos (threshold ~1e-10).",
                                    "Comparar rank([K]) com valor esperado: 3n - 6 para treliças estáveis em 3D (subtrair 6 DOFs rígidos).",
                                    "Identificar DOFs nulos correspondentes aos menores valores singulares.",
                                    "Visualizar null space para entender direções de colapso."
                                  ],
                                  "verification": "Rank calculado bate com esperado para treliça conhecida estável; null space tem dimensão zero para rígida.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python: NumPy.linalg.svd ou MATLAB svd",
                                    "Exemplos de treliças estáveis/instáveis"
                                  ],
                                  "tips": "Use threshold adaptativo baseado em norma de [K]; plote autovalores singulares em log-scale.",
                                  "learningObjective": "Aplicar ferramentas numéricas para quantificar deficiências de rank em [K], detectando instabilidades kinemáticas.",
                                  "commonMistakes": [
                                    "Threshold inadequado causando falsos zeros",
                                    "Confundir rank com condição numérica",
                                    "Ignorar DOFs de apoio no cálculo esperado"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar Análise de Autovalores para Detectar Mecanismos",
                                  "subSteps": [
                                    "Computar autovalores e autovetores de [K] usando solvers eficientes (eig ou ARPACK para grandes matrizes).",
                                    "Identificar autovalores próximos de zero (mecanismos rígidos) vs. negativos (instabilidades elásticas).",
                                    "Ordenar autovalores crescentes e inspecionar os 6 menores (modos rígidos devem ser ~0).",
                                    "Animar ou plotar modos associados aos autovalores zero para visualização.",
                                    "Verificar ortogonalidade dos modos e convergência numérica."
                                  ],
                                  "verification": "Autovalores zero detectados correspondem a mecanismos conhecidos; modos rígidos (translação/rotação) identificados corretamente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB eig ou Python SciPy.linalg.eigh",
                                    "Ferramentas de visualização: Matplotlib ou Paraview para modos"
                                  ],
                                  "tips": "Para matrizes grandes, use shift-inverso para autovalores próximos de zero; normalize autovetores.",
                                  "learningObjective": "Interpretar espectro de autovalores de [K] para diagnosticar mecanismos e instabilidades.",
                                  "commonMistakes": [
                                    "Solver inadequado para matrizes singulares",
                                    "Confundir modos rígidos com elásticos baixos",
                                    "Não checar simetria antes de eig"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resultados e Propor Soluções de Estabilização",
                                  "subSteps": [
                                    "Classificar instabilidade: mecanismo rígido (rank def < esperado), instabilidade elástica (autovalores neg).",
                                    "Analisar modos nulos para identificar nós/barras problemáticos.",
                                    "Propor adições mínimas: nova barra diagonal, apoio extra, ou pré-tensores.",
                                    "Simular correções recalculando [K] atualizada e verificando rank/autovalores.",
                                    "Documentar trade-offs: custo, peso vs. estabilidade."
                                  ],
                                  "verification": "Soluções propostas elevam rank para valor esperado e eliminam autovalores zero/negativos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Mesmo software anterior",
                                    "Modelos CAD simples para visualização",
                                    "Tabelas de custos hipotéticos"
                                  ],
                                  "tips": "Priorize soluções com menor número de elementos; teste sensibilidade a parâmetros.",
                                  "learningObjective": "Desenvolver raciocínio de engenharia para corrigir instabilidades com intervenções otimizadas.",
                                  "commonMistakes": [
                                    "Adicionar elementos desnecessários criando sobre-rigidez",
                                    "Ignorar efeitos de pré-estresse",
                                    "Não validar simulação pós-correção"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma treliça 3D de ponte pedonal com 6 nós e 9 barras, mas faltando um apoio vertical no nó 5: rank([K])=12 < 12 (3*6-6), autovalor zero indica mecanismo de balanço. Adicionar apoio eleva rank para 15, estabilizando.",
                              "finalVerifications": [
                                "Calcula corretamente rank e autovalores para treliça instável conhecida.",
                                "Identifica mecanismos via null space ou modos.",
                                "Propõe pelo menos 2 soluções viáveis com validação.",
                                "Visualiza e interpreta modos de instabilidade.",
                                "Discute limitações numéricas na análise.",
                                "Aplica a treliças reais com dados fornecidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de rank/autovalores (erro <1e-8).",
                                "Correta interpretação de mecanismos vs. instabilidades.",
                                "Criatividade e minimalismo nas soluções propostas.",
                                "Qualidade da documentação e visualizações.",
                                "Eficiência computacional em implementações.",
                                "Integração de teoria EF com prática numérica."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: SVD, autovalores para análise espectral.",
                                "Física/Estática: Identificação de graus de liberdade rígidos e mecanismos.",
                                "Programação: Desenvolvimento de scripts NumPy/SciPy para automação EF.",
                                "Otimização: Seleção mínima de elementos para estabilização.",
                                "Engenharia Civil: Aplicações em estruturas treliçadas reais."
                              ],
                              "realWorldApplication": "Na análise de pontes treliçadas como a Forth Bridge ou torres de transmissão, detectar instabilidades via rank/[K] previne falhas catastróficas, otimizando design com adição mínima de materiais para economia e segurança."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.3.2"
                            ]
                          },
                          {
                            "id": "10.1.3.4.3.4",
                            "name": "Resolver sistema e pós-processar",
                            "description": "Resolver {u} = [K]^{-1} {F}, calcular reações e deformações elementares, validando resultados com equilíbrio global.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Resolver o sistema linear para obter deslocamentos nodais",
                                  "subSteps": [
                                    "Confirmar que a matriz global de rigidez [K] e o vetor de forças {F} estão corretamente montados e com dimensões compatíveis.",
                                    "Aplicar condições de contorno para restringir graus de liberdade conhecidos (ex: apoios fixos u=0).",
                                    "Resolver o sistema [K_red]{u_red} = {F_red} usando decomposição LU, Cholesky ou solver iterativo.",
                                    "Recuperar todos os deslocamentos nodais {u}, incluindo os zeros das restrições.",
                                    "Verificar simetria e positividez definida de [K] antes da resolução."
                                  ],
                                  "verification": "Comparar norma do resíduo ||[K]{u} - {F}|| < 1e-6 para validar a solução.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de análise numérica (MATLAB, Python com NumPy/SciPy), matrizes [K] e {F} do passo anterior.",
                                  "tips": "Use solvers esparsos para eficiência em problemas grandes; normalize unidades consistentemente.",
                                  "learningObjective": "Dominar a resolução numérica de sistemas lineares simétricos positivos definidos em EF.",
                                  "commonMistakes": "Esquecer de aplicar BCs levando a singularidade em [K]; inverter matriz completa em vez de reduzida."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular reações de apoio",
                                  "subSteps": [
                                    "Identificar nós de apoio e seus graus de liberdade restritos.",
                                    "Computar {R} = [K_{rr}]{u_r} + [K_{rf}]{u_f}, onde r=restrições, f=livres.",
                                    "Somar forças reativas nos apoios para obter reações totais por nó.",
                                    "Verificar sinal das reações (compressão/tração conforme convenção).",
                                    "Armazenar reações em vetor {R} completo para equilíbrio global."
                                  ],
                                  "verification": "Verificar se soma de todas as forças aplicadas + reações = 0 (equilíbrio estático).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Deslocamentos {u} resolvidos, submatrizes de [K], calculadora ou script Python.",
                                  "tips": "Extraia submatrizes corretamente usando índices de nós restritos.",
                                  "learningObjective": "Entender extração de reações de sistemas EF via equilíbrio nodal.",
                                  "commonMistakes": "Confundir índices livres/restritos; ignorar forças concentradas nos apoios."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular deformações e tensões elementares",
                                  "subSteps": [
                                    "Para cada elemento, extrair deslocamentos nodais locais {u_e} = [T]{u_g}, onde [T] é matriz de transformação.",
                                    "Computar deformação ε = (1/L) * [B]{u_e}, com [B] = [-1, 1] para barras 1D.",
                                    "Calcular tensão σ = E * ε, com E módulo de elasticidade.",
                                    "Mapear para 3D considerando orientação do elemento (vetores diretores).",
                                    "Armazenar resultados por elemento em tabela (deformação, tensão, alongamento)."
                                  ],
                                  "verification": "Checar se deformações extremas são coerentes com cargas (ex: tração onde F>0).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Propriedades elementares (L, A, E), matrizes [T] e [B], {u} global.",
                                  "tips": "Visualize elementos com software para confirmar transformações geométricas.",
                                  "learningObjective": "Executar pós-processamento local de deformações/tensões em treliças 3D.",
                                  "commonMistakes": "Erro em rotação [T] levando a deformações incorretas; esquecer área se σ = F/A."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar resultados com equilíbrio global e análise de estabilidade",
                                  "subSteps": [
                                    "Verificar equilíbrio global: soma F_x = 0, F_y=0, F_z=0 incluindo reações.",
                                    "Calcular energia de deformação U = (1/2){u}^T [K]{u} e comparar com trabalho das forças.",
                                    "Checar estabilidade: autovalores de [K] >0; deslocamentos finitos e razoáveis.",
                                    "Comparar com solução analítica para treliça simples ou software comercial.",
                                    "Gerar relatório com gráficos de deslocamentos/deformações."
                                  ],
                                  "verification": "Equilíbrio global satisfeito em todas direções; energia positiva e coerente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Resultados anteriores, software de plotagem (Matplotlib), solução referência.",
                                  "tips": "Use tolerâncias relativas para verificações numéricas.",
                                  "learningObjective": "Validar soluções EF via princípios físicos fundamentais.",
                                  "commonMistakes": "Ignorar momentos em equilíbrio 3D; tolerâncias muito rígidas em resíduos."
                                }
                              ],
                              "practicalExample": "Em uma treliça 3D de 6 barras suportando uma carga vertical de 10kN no nó central, resolva [K] 18x18 (6 nós x 3 DOF), obtenha u_z máx=2.5mm, reações verticais somam 10kN, deformações ε<0.001 nos elementos críticos.",
                              "finalVerifications": [
                                "Resíduo do sistema ||[K]{u}-{F}|| < 1e-8.",
                                "Equilíbrio global satisfeito em X,Y,Z.",
                                "Reações coerentes com cargas aplicadas.",
                                "Deformações/tensões abaixo de limites admissíveis.",
                                "Energia de deformação positiva e finita.",
                                "Deslocamentos contínuos e sem singularidades."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica na resolução (erro <1%).",
                                "Correta aplicação de condições de contorno.",
                                "Cálculo exato de reações e deformações.",
                                "Validação física completa (equilíbrio/energia).",
                                "Uso eficiente de ferramentas computacionais.",
                                "Relatório claro com visualizações."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Resolução de sistemas e autovalores.",
                                "Física/Estática: Princípios de equilíbrio e energia.",
                                "Programação: Implementação em Python/MATLAB.",
                                "Geometria Computacional: Transformações 3D."
                              ],
                              "realWorldApplication": "Análise de estruturas aeroespaciais como fuselagens de aviões ou torres de telecomunicações, onde validação de deslocamentos e tensões garante segurança contra colapso."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.5",
                    "name": "Formulação de elementos de viga 2D",
                    "description": "Desenvolvimento da matriz de rigidez para elementos de viga em duas dimensões, considerando flexão e cisalhamento.",
                    "individualConcepts": [
                      {
                        "id": "34.1.3.1",
                        "name": "Teoria da viga Timoshenko em 2D",
                        "description": "Apresentação das hipóteses fundamentais da teoria de vigas de Timoshenko, incluindo deformação por cisalhamento, para modelagem de elementos finitos em flexão plana.",
                        "specificSkills": [
                          {
                            "id": "34.1.3.1.1",
                            "name": "Identificar hipóteses da teoria Timoshenko",
                            "description": "Reconhecer e explicar as diferenças entre as teorias de Euler-Bernoulli e Timoshenko, destacando a inclusão do cisalhamento transversal e rotação independente da seção transversal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar as hipóteses fundamentais da teoria de Euler-Bernoulli",
                                  "subSteps": [
                                    "Estude a hipótese de seções planas permanecendo planas após deformação.",
                                    "Analise a hipótese de cisalhamento transversal desprezível (γ=0).",
                                    "Revise a relação linear entre rotação da seção transversal e inclinação da linha média (φ = dw/dx).",
                                    "Identifique a hipótese de deformação normal dominante e tensão tangencial desprezível.",
                                    "Anote as condições de aplicabilidade: vigas esguias (L/h > 10)."
                                  ],
                                  "verification": "Liste corretamente as 4 principais hipóteses da Euler-Bernoulli e explique uma em suas palavras.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Mecânica dos Materiais (ex: Beer & Johnston)",
                                    "Notas de aula sobre teorias de vigas",
                                    "Diagrama comparativo de deformações"
                                  ],
                                  "tips": "Desenhe diagramas de deformação para visualizar as simplificações.",
                                  "learningObjective": "Compreender as premissas simplificadoras da teoria Euler-Bernoulli para vigas esguias.",
                                  "commonMistakes": [
                                    "Ignorar a condição de vigas esguias",
                                    "Confundir cisalhamento com deformação axial",
                                    "Achar que EB inclui rotação independente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar as hipóteses específicas da teoria de Timoshenko",
                                  "subSteps": [
                                    "Estude a inclusão do cisalhamento transversal deformação (γ ≠ 0).",
                                    "Analise a hipótese de rotação da seção transversal independente da inclinação da linha média (φ ≠ dw/dx).",
                                    "Revise a seção transversal permanecendo plana, mas com rotação adicional devido ao cisalhamento.",
                                    "Identifique o fator de correção de cisalhamento (κ) para distribuição real de tensões.",
                                    "Anote as condições: vigas moderadamente grossas (L/h < 10)."
                                  ],
                                  "verification": "Descreva as 3 hipóteses chave da Timoshenko e diferencie da Euler-Bernoulli em um parágrafo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Referência: Teoria de Timoshenko (artigo original ou capítulo de livro)",
                                    "Software de desenho para diagramas de cisalhamento",
                                    "Tabela comparativa de hipóteses"
                                  ],
                                  "tips": "Use setas nos diagramas para mostrar rotação φ e cisalhamento γ separadamente.",
                                  "learningObjective": "Reconhecer as modificações na teoria Timoshenko para capturar efeitos de cisalhamento.",
                                  "commonMistakes": [
                                    "Esquecer o fator κ",
                                    "Confundir independência de rotação com seções não-planas",
                                    "Aplicar Timoshenko só para vigas grossas sem justificativa"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar as diferenças entre as duas teorias",
                                  "subSteps": [
                                    "Crie uma tabela comparando hipóteses: cisalhamento (EB:0 vs T:≠0), rotação (EB:dw/dx vs T:independente).",
                                    "Calcule matematicamente a equação diferencial: EB (EI w''''=q) vs T (com termos de cisalhamento GAκ).",
                                    "Analise impacto na deflexão: EB subestima para vigas curtas.",
                                    "Discuta precisão: T mais precisa para frequências altas e vigas grossas.",
                                    "Resuma vantagens/desvantagens de cada teoria."
                                  ],
                                  "verification": "Preencha uma tabela de comparação com pelo menos 5 diferenças e justifique 2 impactos práticos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha Excel ou papel para tabela",
                                    "Derivações matemáticas de livros de Elementos Finitos",
                                    "Gráficos de deflexão comparativos"
                                  ],
                                  "tips": "Comece pela equação governante para ver diferenças emergirem naturalmente.",
                                  "learningObjective": "Explicar quantitativamente e qualitativamente as diferenças entre Euler-Bernoulli e Timoshenko.",
                                  "commonMistakes": [
                                    "Não quantificar impacto no cisalhamento",
                                    "Ignorar fator κ na comparação",
                                    "Generalizar EB como sempre errada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar identificação de hipóteses em um contexto de formulação de elementos finitos",
                                  "subSteps": [
                                    "Escolha um problema 1D de viga 2D e liste hipóteses assumidas.",
                                    "Modele uma viga cantilever com carga ponta usando ambas teorias.",
                                    "Compare resultados numéricos de deflexão e rotação.",
                                    "Identifique quando usar Timoshenko em FEM (malhas grossas, altas frequências).",
                                    "Documente limitações em formulação de elementos."
                                  ],
                                  "verification": "Resolva um exemplo simples e discuta qual teoria escolheria e por quê.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software FEM simples (ex: MATLAB ou Python com SciPy)",
                                    "Exemplo numérico de viga",
                                    "Calculadora simbólica"
                                  ],
                                  "tips": "Use L/h=5 para mostrar discrepância clara entre teorias.",
                                  "learningObjective": "Integrar identificação de hipóteses na formulação prática de elementos de viga Timoshenko.",
                                  "commonMistakes": [
                                    "Não normalizar resultados para comparação",
                                    "Esquecer unidades em cálculos",
                                    "Aplicar teoria errada sem checar L/h"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma viga cantilever de L=1m, h=0.2m (L/h=5, grossa), com carga pontual P=1000N na ponta. Usando Euler-Bernoulli, deflexão δ=PL³/(3EI)=0.015m. Com Timoshenko, δ_T=δ + (P L)/(κ G A)=0.018m (cisalhamento adiciona 20%). Identifique: EB ignora γ, Timoshenko inclui rotação independente φ.",
                              "finalVerifications": [
                                "Liste todas as hipóteses da Timoshenko sem erros.",
                                "Explique corretamente a independência da rotação φ.",
                                "Compare deflexões em exemplo numérico com <5% erro.",
                                "Justifique uso de Timoshenko para vigas com L/h<10.",
                                "Desenhe diagrama mostrando cisalhamento transversal.",
                                "Discuta impacto em formulação FEM 1D."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de hipóteses (100% corretas).",
                                "Clareza na explicação de diferenças (cisalhamento e rotação).",
                                "Uso correto de equações diferenciais comparativas.",
                                "Aplicação prática em exemplo com cálculos quantitativos.",
                                "Análise de limitações e condições de validade.",
                                "Qualidade de diagramas e tabelas comparativas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações diferenciais de ordem 4 e fatores de correção.",
                                "Física: Mecânica dos sólidos e teoria da elasticidade.",
                                "Engenharia Civil: Análise de vigas em estruturas como pontes.",
                                "Computação: Implementação numérica em códigos FEM (Python/MATLAB).",
                                "Materiais: Propriedades de cisalhamento G e κ para diferentes seções."
                              ],
                              "realWorldApplication": "Na análise de asas de aviões ou vigas de turbinas eólicas (grossas, altas frequências), onde Timoshenko corrige erros de 20-30% da EB em deflexões e modos vibratórios, essencial para software FEM como ANSYS em design aeroespacial e civil."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.1.3.1.2",
                            "name": "Derivar relações cinemáticas",
                            "description": "Estabelecer as relações entre deslocamento transversal v(x), rotação φ(x) e deformações: curvatura κ = -dφ/dx e cisalhamento γ = dv/dx - φ.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os campos cinemáticos básicos em vigas Timoshenko",
                                  "subSteps": [
                                    "Defina o deslocamento transversal v(x) como o movimento vertical da linha neutra ao longo do eixo x.",
                                    "Defina a rotação φ(x) como a rotação da seção transversal em relação ao eixo x.",
                                    "Desenhe um diagrama esquemático de uma viga 2D destacando v(x) e φ(x).",
                                    "Explique a hipótese de seções planas rígidas na teoria Timoshenko.",
                                    "Compare com a teoria de Euler-Bernoulli, onde φ(x) ≈ dv/dx."
                                  ],
                                  "verification": "Desenhar corretamente o diagrama e listar as definições em um papel.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Diagrama de viga Timoshenko de um livro-texto"
                                  ],
                                  "tips": "Visualize a deformação da seção transversal para diferenciar v(x) e φ(x).",
                                  "learningObjective": "Identificar e descrever os dois graus de liberdade cinemáticos principais.",
                                  "commonMistakes": [
                                    "Confundir v(x) com rotação",
                                    "Ignorar a independência entre v(x) e φ(x)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a relação para a curvatura κ",
                                  "subSteps": [
                                    "Lembre que a curvatura mede a mudança na inclinação da linha neutra.",
                                    "Partindo da geometria infinitesimal, relacione a rotação φ(x) com a curvatura.",
                                    "Mostre que κ = -dφ/dx usando aproximações de pequenas deformações.",
                                    "Derive passo a passo: considere Δφ ≈ -κ Δx.",
                                    "Verifique dimensionalmente: κ tem unidades de 1/comprimento."
                                  ],
                                  "verification": "Escrever a equação κ = -dφ/dx e derivá-la de um elemento diferencial.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora para verificação simbólica"
                                  ],
                                  "tips": "Use o sinal negativo para convenção: curvatura positiva causa compressão na parte superior.",
                                  "learningObjective": "Derivar matematicamente a curvatura a partir da rotação.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo",
                                    "Confundir com d²v/dx² da teoria de EB"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a relação para o cisalhamento γ",
                                  "subSteps": [
                                    "Defina o cisalhamento γ como a deformação angular na seção transversal.",
                                    "Considere o deslocamento relativo: a derivada dv/dx representa a rotação geométrica.",
                                    "Some o efeito da rotação real φ(x): γ = dv/dx - φ.",
                                    "Desenhe o triângulo de deformações mostrando o ângulo γ infinitesimal.",
                                    "Explique fisicamente: γ captura o cisalhamento que EB ignora."
                                  ],
                                  "verification": "Derivar γ = dv/dx - φ e ilustrar com diagrama de deformação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis de cor para diagrama",
                                    "Referência teórica de Timoshenko"
                                  ],
                                  "tips": "Pense em γ como a 'diferença' entre rotação total e rotacional da linha neutra.",
                                  "learningObjective": "Estabelecer a relação não-clássica entre deslocamento e rotação.",
                                  "commonMistakes": [
                                    "Inverter o sinal: γ = φ - dv/dx",
                                    "Assumir γ=0 como em EB"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar as relações cinemáticas e verificar consistência",
                                  "subSteps": [
                                    "Escreva o conjunto completo: κ = -dφ/dx e γ = dv/dx - φ.",
                                    "Verifique limites: para vigas esbeltas, φ ≈ dv/dx implica γ ≈ 0 e κ ≈ -d²v/dx².",
                                    "Aplique em uma função teste: v(x) = sin(πx/L), φ(x) = cos(πx/L).",
                                    "Calcule numericamente κ e γ em pontos chave.",
                                    "Discuta implicações para elementos finitos 1D."
                                  ],
                                  "verification": "Resolver o exemplo teste e confirmar as relações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software simbólico como SymPy ou papel",
                                    "Exemplo numérico pronto"
                                  ],
                                  "tips": "Use funções suaves para testar derivadas.",
                                  "learningObjective": "Consolidar as relações e entender sua generalidade.",
                                  "commonMistakes": [
                                    "Erros em derivadas de teste",
                                    "Não verificar consistência com EB"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma viga engastada de comprimento L com carga distribuída q, assuma v(x) = (q/(24EI))(x^4 - 4L x^3 + 6 L^2 x^2) ajustado para Timoshenko, e φ(x) derivado numericamente. Calcule κ(x) e γ(x) em x=L/2 e interprete: κ indica flexão, γ indica cisalhamento significativo em vigas curtas.",
                              "finalVerifications": [
                                "Escrever corretamente κ = -dφ/dx sem erros de sinal.",
                                "Derivar γ = dv/dx - φ de diagrama geométrico.",
                                "Comparar com Euler-Bernoulli: γ=0 e κ=-d²v/dx².",
                                "Aplicar em exemplo simples e calcular valores numéricos.",
                                "Explicar fisicamente o papel de cada deformação.",
                                "Identificar quando Timoshenko é superior (vigas curtas/grossas)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática das derivadas (100% correto).",
                                "Interpretação física correta das deformações.",
                                "Uso adequado de convenções de sinal.",
                                "Capacidade de generalizar para elementos finitos.",
                                "Clareza nos diagramas e exemplos.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo diferencial (derivadas de primeira ordem).",
                                "Física: Mecânica dos sólidos contínuos e deformações.",
                                "Engenharia Civil: Análise de estruturas esbeltas.",
                                "Computação: Implementação em código para Método dos Elementos Finitos.",
                                "Materiais: Efeitos de cisalhamento em compósitos."
                              ],
                              "realWorldApplication": "Essas relações são fundamentais na formulação de elementos finitos para vigas em projetos de pontes, edifícios altos, asas de aviões e componentes automotivos, permitindo simulações precisas de estruturas com cisalhamento significativo, evitando superestimações de rigidez como na teoria de EB."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.1.3.1.3",
                            "name": "Calcular tensões e esforços internos",
                            "description": "Determinar momento fletor M = EI dφ/dx e força de cisalhamento V = kGA γ, com k como fator de correção de cisalhamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos da teoria da viga Timoshenko",
                                  "subSteps": [
                                    "Estude as hipóteses da teoria Timoshenko: deformação por cisalhamento incluída e rotação independente da derivada da deflexão.",
                                    "Revise as relações cinemáticas: deflexão w(x), rotação φ(x) e deformação de cisalhamento γ(x) = dw/dx + φ.",
                                    "Identifique as diferenças em relação à teoria de Euler-Bernoulli.",
                                    "Anote as equações constitutivas: tensão normal σ = E ε e tensão de cisalhamento τ = G γ.",
                                    "Desenhe um diagrama esquemático de um elemento de viga destacando os esforços internos."
                                  ],
                                  "verification": "Crie um resumo de 1 página com as equações chave e hipóteses; confira com referência padrão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Mecânica dos Materiais (ex: Beer & Johnston), notas de aula, calculadora.",
                                  "tips": "Use diagramas para visualizar deformações; foque em como o cisalhamento afeta vigas curtas.",
                                  "learningObjective": "Compreender as bases teóricas para cálculo de esforços internos na viga Timoshenko.",
                                  "commonMistakes": "Confundir rotação φ com dw/dx; ignorar o fator k de correção de cisalhamento."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar expressões para momento fletor M e força de cisalhamento V",
                                  "subSteps": [
                                    "Parta das relações de equilíbrio: dV/dx = -q(x) e dM/dx = V(x).",
                                    "Expresse o momento fletor M(x) = ∫ E I dφ/dx dx, confirmando M = E I dφ/dx.",
                                    "Derive a força de cisalhamento V(x) = ∫ k G A γ dx, com γ = dw/dx + φ.",
                                    "Incorpore o fator k (tipicamente 5/6 para seção retangular) e explique sua origem na distribuição de tensões.",
                                    "Escreva as fórmulas finais: M = E I dφ/dx e V = k G A γ."
                                  ],
                                  "verification": "Derive as fórmulas do zero e compare com equações de referência; teste com valores simbólicos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel quadriculado, lápis, software simbólico como Mathematica ou SymPy.",
                                  "tips": "Use integração por partes para derivar; memorize k para seções comuns.",
                                  "learningObjective": "Dominar as expressões matemáticas exatas para M e V na teoria Timoshenko.",
                                  "commonMistakes": "Esquecer o sinal em derivadas; usar G em vez de k G A."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular numericamente M e V para um elemento de viga 1D",
                                  "subSteps": [
                                    "Defina um problema simples: viga cantilever de comprimento L=1m, E=200GPa, I=1e-4 m^4, A=0.01m^2, k=5/6, carga P=10kN na ponta.",
                                    "Obtenha soluções analíticas aproximadas para w(x), φ(x) e γ(x) usando condições de contorno.",
                                    "Calcule dφ/dx e γ em pontos nodais (ex: x=0, L/2, L).",
                                    "Compute M = E I dφ/dx e V = k G A γ em cada ponto, com G=E/2(1+ν), ν=0.3.",
                                    "Plote os diagramas de M(x) e V(x) para visualização."
                                  ],
                                  "verification": "Compare resultados com solução Euler-Bernoulli; erro <5% para vigas longas.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Excel ou MATLAB para cálculos, software de plotagem como Python Matplotlib.",
                                  "tips": "Use diferenças finitas para derivadas se analítico for complexo; normalize unidades SI.",
                                  "learningObjective": "Aplicar fórmulas para obter valores numéricos de esforços internos.",
                                  "commonMistakes": "Inconsistência de unidades (kN vs N); erro em condições de contorno."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar cálculos em formulação de elementos finitos para viga 2D Timoshenko",
                                  "subSteps": [
                                    "Monte a matriz de rigidez para um elemento 2-nós com 2gdl/nó (w, φ).",
                                    "Calcule campos de deslocamento interpolados e derive strains ε e γ.",
                                    "Integre numericamente M e V pós-processando nos Gauss points.",
                                    "Aplique em um problema com 2-3 elementos e cargas distribuídas.",
                                    "Valide convergência refinando a malha."
                                  ],
                                  "verification": "Resultados coincidem com solução analítica dentro de 2%; cheque simetria da matriz K.",
                                  "estimatedTime": "120 minutos",
                                  "materials": "Código MATLAB/Python para EF (template de viga Timoshenko), debugger.",
                                  "tips": "Use integração de Gauss de 2 pontos; shear locking é comum, use ordem reduzida se necessário.",
                                  "learningObjective": "Incorporar cálculo de M e V no fluxo de análise de elementos finitos.",
                                  "commonMistakes": "Shear locking por elementos lineares; esquecer k na matriz B."
                                }
                              ],
                              "practicalExample": "Para uma viga cantilever de 2m, seção retangular 0.1x0.2m, E=70GPa (alumínio), ν=0.33, carga uniforme q=5kN/m: Calcule M e V em x=1m. Solução: φ(x) aproximado via EF, dφ/dx ≈ -0.0125 rad/m → M ≈ 70e9 * 1e-5 * (-0.0125) = -87.5 kNm; γ ≈ 0.008 → V ≈ (5/6)*26e9*0.02*0.008 ≈ 13.9 kN.",
                              "finalVerifications": [
                                "M varia linearmente de 0 na ponta livre para máximo na fixação.",
                                "V é constante ou segue distribuição de carga corretamente.",
                                "Inclusão de k reduz V em ~17% vs sem correção.",
                                "Diagrama M-V satisfaz equilíbrio dM/dx = V.",
                                "Resultados convergem com refinamento de malha EF.",
                                "Comparação com Euler-Bernoulli mostra diferença significativa para L/h < 10."
                              ],
                              "assessmentCriteria": [
                                "Precisão das fórmulas derivadas (100% match com referências).",
                                "Correção numérica (erro <3% vs analítico).",
                                "Visualizações claras de diagramas M-V.",
                                "Explicação adequada do papel de k e γ.",
                                "Integração correta em código EF sem locking.",
                                "Análise de erros e sensibilidade a parâmetros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Derivação diferencial e integração numérica (Gauss quadrature).",
                                "Física: Mecânica dos sólidos contínuos e teoria de elasticidade.",
                                "Programação: Implementação numérica em MATLAB/Python para simulações EF.",
                                "Engenharia Civil: Análise de estruturas esbeltas como pontes e edifícios."
                              ],
                              "realWorldApplication": "Em projetos de vigas em aviões (alas), pontes (vigas de aço) ou edifícios (lajes), onde cisalhamento é crítico em vigas baixas; software como ANSYS usa essas fórmulas para prever falhas por flexão/cisalhamento, otimizando material e segurança."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "34.1.3.2",
                        "name": "Funções de interpolação para elemento de viga 2D",
                        "description": "Definição das funções de forma para aproximar deslocamentos e rotações em um elemento de viga com dois nós e quatro graus de liberdade.",
                        "specificSkills": [
                          {
                            "id": "34.1.3.2.1",
                            "name": "Definir graus de liberdade nodais",
                            "description": "Especificar os quatro graus de liberdade por elemento: deslocamento vertical v e rotação θ em cada extremidade dos dois nós.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de graus de liberdade em elementos finitos",
                                  "subSteps": [
                                    "Revise a definição de graus de liberdade (DOFs) como as deslocamentos independentes que descrevem o movimento de um nó.",
                                    "Estude DOFs em problemas 1D versus 2D, focando em vigas que permitem flexão.",
                                    "Identifique que em vigas 2D, os DOFs incluem translação e rotação.",
                                    "Compare com elementos de barra (apenas axial), destacando a diferença para vigas.",
                                    "Anote exemplos simples de DOFs em sistemas discretos."
                                  ],
                                  "verification": "Explique em suas palavras o que são DOFs e liste diferenças entre barra e viga.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de Elementos Finitos (ex: Logan), notas de aula, diagrama de viga simples.",
                                  "tips": "Use analogias como juntas de um robô para visualizar DOFs independentes.",
                                  "learningObjective": "Entender o papel dos DOFs na formulação de elementos finitos para vigas.",
                                  "commonMistakes": "Confundir DOFs de vigas com os de barras (axial apenas); assumir 3 DOFs por nó em 2D."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever a geometria e nós do elemento de viga 2D",
                                  "subSteps": [
                                    "Desenhe um elemento de viga 2D com dois nós (extremidades esquerda e direita).",
                                    "Marque os nós como Nó 1 (esquerda) e Nó 2 (direita), com comprimento L.",
                                    "Indique o eixo local x ao longo da viga e y perpendicular (vertical).",
                                    "Explique que é um elemento de dois nós linear para interpolação.",
                                    "Verifique simetria e convenções de numeração de nós."
                                  ],
                                  "verification": "Desenhe e rotule corretamente o elemento com nós identificados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel quadriculado, lápis, régua, software de desenho como GeoGebra.",
                                  "tips": "Sempre numere nós da esquerda para a direita para consistência.",
                                  "learningObjective": "Visualizar a estrutura nodal básica do elemento de viga 2D.",
                                  "commonMistakes": "Esquecer que vigas 2D têm dois nós lineares; confundir com elementos quadráticos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir os DOFs por nó para o elemento de viga 2D",
                                  "subSteps": [
                                    "Para cada nó, liste deslocamento vertical v (translação em y).",
                                    "Adicione rotação θ (rotação em torno de z, perpendicular ao plano).",
                                    "Confirme que cada nó tem exatamente dois DOFs: v e θ.",
                                    "Especifique notação: v1 e θ1 para Nó 1; v2 e θ2 para Nó 2.",
                                    "Desenhe setas indicando direções: seta vertical para v, curva para θ."
                                  ],
                                  "verification": "Liste e diagrame os dois DOFs por nó com notação correta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Diagrama impresso de viga, caneta colorida para setas.",
                                  "tips": "Use cores diferentes: azul para v (vertical), vermelho para θ (rotação).",
                                  "learningObjective": "Especificar precisamente os DOFs nodais individuais.",
                                  "commonMistakes": "Incluir deslocamento horizontal u (não presente em vigas Euler-Bernoulli puras 1D); inverter notação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Especificar os quatro DOFs totais do elemento",
                                  "subSteps": [
                                    "Combine DOFs dos dois nós: v1, θ1, v2, θ2.",
                                    "Escreva o vetor de DOFs do elemento como {v1, θ1, v2, θ2}^T.",
                                    "Explique como isso forma a base para a matriz de rigidez.",
                                    "Verifique independência: cada DOF descreve movimento único.",
                                    "Teste com um exemplo: aplique deslocamento só em v1 e observe."
                                  ],
                                  "verification": "Escreva o vetor completo de DOFs e explique sua ordem.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Folha de exercícios, calculadora simbólica como SymPy.",
                                  "tips": "Memorize a ordem padrão: translação primeiro, depois rotação, nó 1 então nó 2.",
                                  "learningObjective": "Consolidar os quatro DOFs por elemento de viga 2D.",
                                  "commonMistakes": "Listar apenas dois DOFs totais; bagunçar a ordem no vetor."
                                }
                              ],
                              "practicalExample": "Considere uma viga cantilever de 1m fixada no Nó 1 (v1=0, θ1=0) e livre no Nó 2, com carga pontual no final. Os DOFs são v1=0, θ1=0 (conhecidos), v2 e θ2 (desconhecidos), resolvidos via equilíbrio.",
                              "finalVerifications": [
                                "Liste corretamente os quatro DOFs: v1, θ1, v2, θ2.",
                                "Desenhe diagrama nodal com setas para cada DOF.",
                                "Explique diferença entre DOFs de viga e barra.",
                                "Escreva vetor de DOFs em notação matricial.",
                                "Identifique DOFs em um elemento vizinho de malha.",
                                "Aplique em exemplo simples de viga engastada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de v e θ por nó (100% correto).",
                                "Correta ordenação e notação dos quatro DOFs.",
                                "Diagrama claro e rotulado sem erros geométricos.",
                                "Explicação conceitual sem confusões com outros elementos.",
                                "Aplicação em exemplo prático demonstrada.",
                                "Ausência de erros comuns como inclusão de DOFs axiais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Vetores e funções de interpolação hermitianas.",
                                "Física: Teoria de vigas Euler-Bernoulli e momentos fletores.",
                                "Programação: Implementação em código FEM (ex: Python com FEniCS).",
                                "Engenharia Civil: Análise de estruturas como vigas em edifícios.",
                                "Desenho Técnico: Representação gráfica de DOFs em CAD."
                              ],
                              "realWorldApplication": "Em software de análise estrutural como ANSYS ou SAP2000, definir DOFs nodais corretamente permite simular deflexões e rotações em vigas de pontes, aviões ou edifícios, previnindo falhas como colapsos por flexão excessiva."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.1.3.2.2",
                            "name": "Construir funções de forma lineares",
                            "description": "Derivar funções de interpolação lineares para v(ξ) e φ(ξ) em coordenada natural ξ ∈ [-1,1], garantindo continuidade de v e φ nos nós.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o elemento de viga 2D na coordenada natural ξ",
                                  "subSteps": [
                                    "Identifique os dois nós do elemento: nó 1 em ξ = -1 e nó 2 em ξ = 1.",
                                    "Defina os graus de liberdade por nó: deslocamento vertical v e rotação φ.",
                                    "Mapeie a coordenada física x para ξ usando ξ = 2(x - x1)/(x2 - x1) - 1, assumindo comprimento L = x2 - x1.",
                                    "Anote os valores nos nós: v(-1) = v1, φ(-1) = φ1, v(1) = v2, φ(1) = φ2.",
                                    "Desenhe um diagrama esquemático do elemento destacando ξ ∈ [-1,1]."
                                  ],
                                  "verification": "Confirme que o mapeamento satisfaz ξ(-1) = -1 e ξ(1) = 1, e liste corretamente os 4 graus de liberdade.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Calculadora para mapeamento",
                                    "Referência de livro de Elementos Finitos (ex: Zienkiewicz)"
                                  ],
                                  "tips": "Sempre normalize para [-1,1] para simetria nas funções de forma.",
                                  "learningObjective": "Compreender o mapeamento isoparamétrico e os graus de liberdade em elementos de viga 2D.",
                                  "commonMistakes": [
                                    "Confundir ordem dos nós (ξ=-1 é nó 1)",
                                    "Esquecer que φ é rotação e não deslocamento",
                                    "Ignorar o intervalo fechado [-1,1]"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar as funções de interpolação lineares N1(ξ) e N2(ξ)",
                                  "subSteps": [
                                    "Assuma interpolação linear: valor em nó 1 para N1(-1)=1, N1(1)=0; N2(-1)=0, N2(1)=1.",
                                    "Proponha forma linear: N1(ξ) = a + bξ, resolva sistema: para ξ=-1, 1=a-b; ξ=1, 0=a+b → N1(ξ)=(1-ξ)/2.",
                                    "Similarmente para N2(ξ): N2(ξ)=(1+ξ)/2.",
                                    "Verifique propriedades: soma N1 + N2 = 1 (partição da unidade), derivadas dN1/dξ = -1/2, dN2/dξ=1/2.",
                                    "Plote ou tabule N1 e N2 em pontos chave: ξ=-1,0,1."
                                  ],
                                  "verification": "Escreva explicitamente N1(ξ)=(1-ξ)/2 e N2(ξ)=(1+ξ)/2, e confirme N1(-1)=1, N2(1)=1.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Papel quadriculado para plotagem",
                                    "Software de plotagem como Desmos ou MATLAB (opcional)"
                                  ],
                                  "tips": "Use condições de contorno nos nós para resolver coeficientes lineares.",
                                  "learningObjective": "Derivar funções de forma lineares que satisfazem continuidade nodal.",
                                  "commonMistakes": [
                                    "Erro aritmético em resolução do sistema (ex: N1(ξ)= (1+ξ)/2)",
                                    "Esquecer normalização para soma=1",
                                    "Confundir com funções quadráticas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a função de interpolação para deslocamento v(ξ)",
                                  "subSteps": [
                                    "Expresse v(ξ) = N1(ξ) v1 + N2(ξ) v2.",
                                    "Substitua: v(ξ) = [(1-ξ)/2] v1 + [(1+ξ)/2] v2.",
                                    "Simplifique: v(ξ) = [v1 + v2 + ξ(v2 - v1)] / 2.",
                                    "Calcule em pontos intermediários, ex: ξ=0, v(0)=(v1+v2)/2.",
                                    "Verifique continuidade: v(-1)=v1, v(1)=v2."
                                  ],
                                  "verification": "Demonstre que v(ξ) recupera valores nodais exatos em ξ=±1.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou SymPy (opcional)",
                                    "Folha de exercícios"
                                  ],
                                  "tips": "Teste com valores numéricos simples como v1=0, v2=1 para visualizar.",
                                  "learningObjective": "Aplicar funções de forma para interpolar o deslocamento vertical linearmente.",
                                  "commonMistakes": [
                                    "Incluir φ nas funções de v por engano",
                                    "Erro na multiplicação matricial",
                                    "Não verificar em ξ=±1"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir φ(ξ), verificar continuidade e propriedades gerais",
                                  "subSteps": [
                                    "Similarmente, φ(ξ) = N1(ξ) φ1 + N2(ξ) φ2 = [(1-ξ)/2] φ1 + [(1+ξ)/2] φ2.",
                                    "Confirme continuidade: φ(-1)=φ1, φ(1)=φ2.",
                                    "Verifique consistência cinemática: em vigas, φ ≈ dv/dx, mas para linear é aproximado.",
                                    "Calcule derivadas: dv/dξ = (v2 - v1)/2, dφ/dξ = (φ2 - φ1)/2.",
                                    "Discuta limitações: linear assume variação constante, bom para malhas finas."
                                  ],
                                  "verification": "Liste verificações: valores nodais corretos para v e φ, e propriedades de partição.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Gráficos de funções para comparar v e φ"
                                  ],
                                  "tips": "Lembre que continuidade é garantida por construção nodal.",
                                  "learningObjective": "Garantir continuidade de v e φ nos nós via interpolação linear.",
                                  "commonMistakes": [
                                    "Assumir funções cúbicas de Euler-Bernoulli",
                                    "Ignorar que φ é independente em Timoshenko",
                                    "Erro em derivadas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um elemento de viga com L=10m, v1=0mm (ξ=-1), φ1=0rad, v2=5mm (ξ=1), φ2=0.01rad. Então v(ξ)=(1+ξ)/4 *5 = (5/4)(1+ξ) mm; φ(ξ)=(1+ξ)/200 rad. No meio (ξ=0), v(0)=2.5mm, φ(0)=0.005rad. Plote para visualizar interpolação linear suave.",
                              "finalVerifications": [
                                "v(-1) = v1 e v(1) = v2 exatamente.",
                                "φ(-1) = φ1 e φ(1) = φ2 exatamente.",
                                "N1(ξ) + N2(ξ) = 1 para todo ξ ∈ [-1,1].",
                                "Derivada dv/dξ é constante (v2 - v1)/2.",
                                "Funções são contínuas e diferenciáveis em [-1,1].",
                                "Valores intermediários interpolam linearmente."
                              ],
                              "assessmentCriteria": [
                                "Correção das expressões N1(ξ) e N2(ξ).",
                                "Expressões explícitas e corretas de v(ξ) e φ(ξ).",
                                "Verificações nodais demonstradas matematicamente.",
                                "Explicação clara da garantia de continuidade.",
                                "Identificação de propriedades (partição da unidade, linearidade).",
                                "Exemplo numérico resolvido sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Polinômios de Lagrange e interpolação linear.",
                                "Física: Teoria de vigas Timoshenko e deformações.",
                                "Programação: Implementação em MATLAB/Python para plotar funções de forma.",
                                "Engenharia Civil: Análise de estruturas com software como ANSYS.",
                                "Cálculo Numérico: Aproximações em métodos de elementos finitos."
                              ],
                              "realWorldApplication": "Essas funções são usadas em softwares de elementos finitos (ex: NASTRAN, Abaqus) para modelar vigas em pontes, edifícios e máquinas, permitindo simulações precisas de deflexões e rotações sob cargas, otimizando designs estruturais contra falhas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.3.1.1"
                            ]
                          },
                          {
                            "id": "34.1.3.2.3",
                            "name": "Calcular matriz de derivação B",
                            "description": "Obter a matriz de deformações B(ξ) relacionando {κ, γ} aos vetores de deslocamentos nodais {v1, θ1, v2, θ2}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir funções de interpolação para deslocamentos v(ξ) e θ(ξ)",
                                  "subSteps": [
                                    "Identifique o elemento de viga 2D Timoshenko com 2 nós e 4 graus de liberdade: v1, θ1, v2, θ2.",
                                    "Estabeleça a coordenada natural ξ ∈ [-1, 1] e o comprimento do elemento L.",
                                    "Escreva v(ξ) = N1(ξ) v1 + N2(ξ) θ1 + N3(ξ) v2 + N4(ξ) θ2, onde N1 = (1-ξ)/2, N3 = (1+ξ)/2, N2 = L(1-ξ)/2, N4 = -L(1+ξ)/2.",
                                    "Escreva θ(ξ) = N1(ξ) θ1 + N3(ξ) θ2, usando funções lineares N1 = (1-ξ)/2, N3 = (1+ξ)/2 para rotações.",
                                    "Verifique que as funções satisfazem condições de contorno nos nós (ξ=±1)."
                                  ],
                                  "verification": "Confirme que v(±1) e θ(±1) reproduzem os valores nodais exatos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, tabela de funções de forma para vigas Timoshenko, calculadora.",
                                  "tips": "Lembre-se que para Timoshenko, deslocamentos transversais e rotações usam funções lineares separadas.",
                                  "learningObjective": "Compreender a interpolação nodal para campos de deslocamento em elementos de viga.",
                                  "commonMistakes": "Confundir funções Hermite (para Euler-Bernoulli) com lineares (Timoshenko); esquecer fator L nas rotações."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular derivadas das funções de interpolação em relação a ξ e x",
                                  "subSteps": [
                                    "Calcule dN_i / dξ para cada função de forma: dN1/dξ = -1/2, dN3/dξ = 1/2, dN2/dξ = -L/2, dN4/dξ = -L/2.",
                                    "Determine o Jacobiano dx/dξ = L/2, logo d/dx = (2/L) d/dξ.",
                                    "Compute dv/dξ = (dN1/dξ)v1 + (dN2/dξ)θ1 + (dN3/dξ)v2 + (dN4/dξ)θ2.",
                                    "Compute dθ/dξ = (dN1/dξ)θ1 + (dN3/dξ)θ2.",
                                    "Obtenha dv/dx = (2/L) dv/dξ e dθ/dx = (2/L) dθ/dξ."
                                  ],
                                  "verification": "Verifique derivadas em pontos específicos, ex: em ξ=0, dv/dξ = (-L/4)θ1 + (-L/4)θ2 + (v2 - v1)/2.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel quadriculado, software simbólico como SymPy ou Mathematica para derivadas.",
                                  "tips": "Use ξ como variável independente para simplificar expressões algébricas.",
                                  "learningObjective": "Dominar a transformação de derivadas entre coordenadas local (x) e natural (ξ).",
                                  "commonMistakes": "Esquecer o Jacobiano (2/L); sinais errados nas derivadas de N2 e N4."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Expressar deformações κ(ξ) e γ(ξ) em termos dos deslocamentos nodais",
                                  "subSteps": [
                                    "Defina curvatura κ = dθ/dx = (2/L) [ (dN1/dξ) θ1 + (dN3/dξ) θ2 ] = (1/L) [ -(1/2) θ1 + (1/2) θ2 ] = (θ2 - θ1)/L.",
                                    "Note que para funções lineares, κ é constante: κ(ξ) = (θ2 - θ1)/L.",
                                    "Defina cisalhamento γ = dv/dx - θ = (2/L) dv/dξ - θ(ξ).",
                                    "Substitua θ(ξ) = N1 θ1 + N3 θ2 e dv/dξ das derivadas anteriores.",
                                    "Simplifique γ(ξ) = (1/L) [ (v2 - v1) - L ((1-ξ)/2 θ1 + (1+ξ)/2 θ2) ]."
                                  ],
                                  "verification": "Confirme que κ é constante e γ varia linearmente com ξ.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de cálculos simbólicos, referência de teoria de vigas Timoshenko.",
                                  "tips": "Mantenha expressões em termos de ξ para clareza antes de matricializar.",
                                  "learningObjective": "Relacionar deformações cinemáticas locais aos graus de liberdade nodais.",
                                  "commonMistakes": "Usar definição de κ errada (ex: d²v/dx² para Timoshenko); omitir subtração em γ."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar e escrever a matriz de derivação B(ξ)",
                                  "subSteps": [
                                    "Estruture {κ, γ}^T = B(ξ) {v1, θ1, v2, θ2}^T, onde B é 2x4.",
                                    "Preencha linha 1 (para κ): [0, -1/L, 0, 1/L] (constante).",
                                    "Preencha linha 2 (para γ): [1/L, -(1-ξ)/2, 1/L, -(1+ξ)/2].",
                                    "Verifique dimensões e independência de ξ apenas em γ.",
                                    "Teste em nós: em ξ=-1, B deve refletir condições locais."
                                  ],
                                  "verification": "Multiplique B por vetor nodal unitário e confira κ e γ esperados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Matriz em branco, MATLAB ou Python para validação numérica.",
                                  "tips": "Agrupe coeficientes por DOF para evitar erros de posicionamento.",
                                  "learningObjective": "Construir matrizes operadoras B para integração em MEF.",
                                  "commonMistakes": "Ordem errada das colunas (DOFs); fator 1/L ausente em κ."
                                }
                              ],
                              "practicalExample": "Para elemento com L=10 m, ξ=0, {v1,θ1,v2,θ2}={0,0.1,0.2,-0.05}, calcule κ=( -0.05 - 0.1)/10 = -0.015 rad/m; γ=(0.2-0)/10 - [0.5*0.1 + 0.5*(-0.05)] = 0.02 - 0.025 = -0.005. Verifique com B(0)= [[0, -0.1, 0, 0.1], [0.1, -0.5, 0.1, -0.5]].",
                              "finalVerifications": [
                                "Dimensões de B: 2 linhas (κ,γ) x 4 colunas (v1,θ1,v2,θ2).",
                                "κ constante = (θ2 - θ1)/L independente de ξ.",
                                "γ(ξ=-1) = (v2 - v1)/L - θ1.",
                                "γ(ξ=1) = (v2 - v1)/L - θ2.",
                                "B simétrica em estrutura para casos simétricos.",
                                "Derivadas das funções de forma corretas via dN/dξ."
                              ],
                              "assessmentCriteria": [
                                "Correção algébrica das funções de forma e derivadas (100% match).",
                                "Precisão na transformação dx/dξ = L/2.",
                                "Definições cinemáticas exatas para κ e γ em Timoshenko.",
                                "Montagem matricial sem erros de índice ou sinal.",
                                "Validação numérica em pelo menos 3 pontos de ξ.",
                                "Expressões simplificadas e livres de variáveis desnecessárias."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo diferencial e álgebra matricial.",
                                "Física: Teoria de vigas e deformações cinemáticas.",
                                "Programação: Implementação em código MEF (MATLAB/Python).",
                                "Engenharia Civil: Análise de estruturas esbeltas."
                              ],
                              "realWorldApplication": "Na análise de elementos finitos para vigas em pontes ou edifícios, a matriz B permite calcular tensões e esforços internos precisos, essencial para dimensionamento seguro contra flexão e cisalhamento em softwares como ANSYS ou Abaqus."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.3.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "34.1.3.3",
                        "name": "Desenvolvimento da matriz de rigidez",
                        "description": "Aplicação do método de Rayleigh-Ritz ou dos trabalhos virtuais para montar a matriz de rigidez local considerando flexão e cisalhamento.",
                        "specificSkills": [
                          {
                            "id": "34.1.3.3.1",
                            "name": "Aplicar método de Rayleigh-Ritz",
                            "description": "Formular a energia de deformação U = ∫ (½ EI κ² + ½ kGA γ²) dx e minimizar a energia potencial total para obter k = ∫ B^T D B dx.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar princípios do método Rayleigh-Ritz e energia potencial",
                                  "subSteps": [
                                    "Estude o princípio de energia mínima em mecânica estrutural.",
                                    "Revise a energia de deformação para vigas: flexão (EI κ²) e cisalhamento (kGA γ²).",
                                    "Entenda a energia potencial total Π = U - W, onde W é o trabalho das cargas.",
                                    "Aprenda a aproximar o deslocamento com funções de interpolação (funções de forma).",
                                    "Identifique o papel da minimização δΠ = 0 levando a k u = f."
                                  ],
                                  "verification": "Resuma em um parágrafo os princípios e formule Π para um caso simples.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Elementos Finitos (ex: Zienkiewicz), notas de aula sobre vigas Euler-Bernoulli-Timoshenko"
                                  ],
                                  "tips": "Use analogias com sistemas de molas para visualizar a minimização de energia.",
                                  "learningObjective": "Compreender a base teórica do método Rayleigh-Ritz para formulação de elementos finitos.",
                                  "commonMistakes": [
                                    "Confundir energia de deformação com energia cinética.",
                                    "Ignorar o cisalhamento em vigas Timoshenko."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a energia de deformação U para elemento de viga 2D",
                                  "subSteps": [
                                    "Defina o elemento de viga 2D com 2 nós, cada um com deslocamentos v (transversal) e θ (rotação).",
                                    "Expresse curvatura κ = d²v/dx² ≈ B_v θ (aproximação via funções de forma).",
                                    "Expresse deformação de cisalhamento γ = dv/dx - θ ≈ B_γ {v, θ}.",
                                    "Integre U = ∫ [½ EI (B_v {d})^T (B_v {d}) + ½ kGA (B_γ {d})^T (B_γ {d})] dx.",
                                    "Escolha funções de forma hermitianas para v e lineares para θ."
                                  ],
                                  "verification": "Escreva a expressão explícita de U em termos de vetor de graus de liberdade {d}.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software simbólico como Mathematica ou SymPy para integração",
                                    "Folha de cálculo para funções de forma"
                                  ],
                                  "tips": "Comece com viga sem cisalhamento (Euler-Bernoulli) para simplificar.",
                                  "learningObjective": "Formular corretamente a energia de deformação strain energy para vigas 2D.",
                                  "commonMistakes": [
                                    "Usar funções de forma inadequadas (ex: lineares para rotação).",
                                    "Esquecer o fator de correção k no cisalhamento."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir matriz de deformação B e matriz de propriedades D",
                                  "subSteps": [
                                    "Defina funções de forma N_v para v e N_θ para θ (hermitianas cúbicas e quadráticas).",
                                    "Derive B = [B_v; B_γ], onde B_v = d²N_v/dx² e B_γ = dN_v/dx - N_θ.",
                                    "Monte D como matriz diagonal [EI, kGA] para os modos de deformação.",
                                    "Verifique dimensionalidade: B é 2x4 para elemento com 4 DOFs (2 nós x 2 DOFs).",
                                    "Calcule numericamente B em pontos de Gauss para integração."
                                  ],
                                  "verification": "Implemente B em uma planilha ou código e plote para um elemento unitário.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/Python com NumPy/SciPy",
                                    "Tabelas de funções de forma para vigas"
                                  ],
                                  "tips": "Use coordenadas naturais ξ para facilitar derivação.",
                                  "learningObjective": "Desenvolver matrizes B e D precisas para o elemento de viga.",
                                  "commonMistakes": [
                                    "Erro no sinal de γ = dv/dx - θ.",
                                    "Dimensões incorretas em B."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Minimizar energia potencial para obter matriz de rigidez k",
                                  "subSteps": [
                                    "Formule energia potencial total Π = ½ {d}^T [∫ B^T D B dx] {d} - {d}^T {f}.",
                                    "Minimize δΠ/δ{d} = 0 resultando em k {d} = {f}, com k = ∫ B^T D B dx.",
                                    "Integre k usando quadratura Gauss-Legendre (2-3 pontos para precisão).",
                                    "Compute elementos explícitos de k para viga uniforme.",
                                    "Inclua cargas consistentes {f} = ∫ N^T p dx."
                                  ],
                                  "verification": "Calcule k para um elemento de comprimento L=1, EI=1, kGA=1 e compare com analítico.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código Python/MATLAB para integração numérica",
                                    "Elemento de referência analítico"
                                  ],
                                  "tips": "Automatize com loop sobre pontos de Gauss para eficiência.",
                                  "learningObjective": "Derivar a matriz de rigidez k via Rayleigh-Ritz.",
                                  "commonMistakes": [
                                    "Esquecer transposições em B^T D B.",
                                    "Integração analítica incorreta."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e aplicar a formulação em um exemplo simples",
                                  "subSteps": [
                                    "Monte um problema de viga cantilever com carga ponta.",
                                    "Ensaie o elemento único e resolva k u = f.",
                                    "Compare deslocamento com solução exata de viga.",
                                    "Analise convergência refinando malha (mais elementos).",
                                    "Discuta limitações (ex: cisalhamento locking)."
                                  ],
                                  "verification": "Erro <5% na ponta da viga em relação à solução analítica.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Solver simples em Python (numpy.linalg.solve)",
                                    "Gráficos de deslocamento"
                                  ],
                                  "tips": "Use malha uniforme e plotes para visualização.",
                                  "learningObjective": "Aplicar e validar a matriz k em um contexto prático.",
                                  "commonMistakes": [
                                    "Condições de contorno erradas.",
                                    "Escala numérica em k."
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma viga cantilever de L=10m, EI=1e6 Nm², kGA=1e5 N, carga distribuída q=1000 N/m: formule U, derive k (12x12 para 2 elementos), resolva deslocamentos e compare com Euler-Bernoulli exato (δ_max = qL^4/(8EI) = 0.0125m).",
                              "finalVerifications": [
                                "Formulação correta de U com termos de flexão e cisalhamento.",
                                "Matriz B com dimensões 2x4 e funções hermitianas.",
                                "k simétrica positiva definida com integração precisa.",
                                "Solução numérica converge para exata com refinamento.",
                                "Cargas consistentes produzem forças nodais corretas.",
                                "Análise de erros comuns evitados na derivação."
                              ],
                              "assessmentCriteria": [
                                "Precisão da matriz k (erro <1% vs. analítica).",
                                "Correção teórica em U, B e minimização.",
                                "Eficiência computacional na integração.",
                                "Validação com exemplo numérico e gráfico.",
                                "Explicação clara de passos e limitações.",
                                "Código reproduzível e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e métodos de Galerkin.",
                                "Programação: Implementação numérica em Python/MATLAB.",
                                "Física: Mecânica dos sólidos e teoria de vigas.",
                                "Engenharia Civil: Análise de estruturas esbeltas.",
                                "Computação Científica: Quadratura numérica e álgebra linear."
                              ],
                              "realWorldApplication": "Desenvolvimento de elementos finitos personalizados em software como ANSYS ou Abaqus para modelagem de vigas em pontes, edifícios ou aerofólios, otimizando rigidez em projetos aeroespaciais e civis onde cisalhamento é crítico."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.3.2.3"
                            ]
                          },
                          {
                            "id": "34.1.3.3.2",
                            "name": "Realizar integração da matriz de rigidez",
                            "description": "Calcular analiticamente os termos da matriz 4x4 de rigidez local k_e para elemento de viga Timoshenko de comprimento L.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o sistema de coordenadas locais e funções de forma para o elemento de viga Timoshenko",
                                  "subSteps": [
                                    "Estabeleça o elemento local com comprimento L, nós em x=0 e x=L.",
                                    "Defina ξ = 2x/L - 1 como coordenada natural (-1 a 1).",
                                    "Escreva funções de forma lineares: N1(ξ) = (1 - ξ)/2, N2(ξ) = (1 + ξ)/2 para deslocamentos transversais w.",
                                    "Defina funções para rotações θ: M1(ξ) = (1 - ξ)/2, M2(ξ) = (1 + ξ)/2.",
                                    "Inclua o fator de cisalhamento κ (ex: 5/6 para seção retangular)."
                                  ],
                                  "verification": "Funções de forma somam 1 em qualquer ξ e são contínuas; verifique interpolação linear.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel quadriculado, calculadora, referência de livro de Elementos Finitos (ex: Zienkiewicz).",
                                  "tips": "Use ξ para simplificar integrais de -1 a 1, com dξ = 2/L dx.",
                                  "learningObjective": "Compreender a parametrização do elemento e funções de interpolação específicas para Timoshenko.",
                                  "commonMistakes": "Confundir funções para w e θ; esquecer o mapeamento dx = (L/2) dξ."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar as matrizes de deformação B para deformação axial, flexão e cisalhamento",
                                  "subSteps": [
                                    "Defina deformações: ε_x = dθ/dx (flexão), γ_xz = dw/dx - θ (cisalhamento).",
                                    "Expresse em termos de graus de liberdade {w1, θ1, w2, θ2}: B_w = [dN1/dx, 0, dN2/dx, 0], B_θ = [0, M1, 0, M2].",
                                    "Monte matriz B 2x4: primeira linha para γ_xz = B_w - B_θ, segunda para ε_x = B_θ.",
                                    "Compute derivadas: dN_i/dx = (2/L) dN_i/dξ, similar para M_i.",
                                    "Verifique consistência dimensional com dx."
                                  ],
                                  "verification": "Matriz B tem dimensões 2x4; derivadas corretas em nós (ex: dN1/dx|_0 = -1/L).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de cálculo simbólico (ex: Mathematica ou papel), tabela de derivadas.",
                                  "tips": "Mantenha simbólico com L, evite números; use Jacobiano J = L/2.",
                                  "learningObjective": "Dominar a relação strain-displacement para vigas com cisalhamento.",
                                  "commonMistakes": "Esquecer sinal negativo em γ = dw/dx - θ; derivadas erradas no domínio natural."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a matriz de rigidez k_e = ∫ B^T D B dx ao longo do elemento",
                                  "subSteps": [
                                    "Defina matriz de materiais D (2x2): D11 = κ G A (cisalhamento), D22 = E I (flexão), off-diagonais zero.",
                                    "Escreva k_e = ∫_0^L B^T D B dx = (L/2) ∫_{-1}^1 B^T D B dξ.",
                                    "Expanda B^T D B em 4x4, identificando 10 termos únicos (simetria).",
                                    "Separe contribuições de cisalhamento (termos com G A) e flexão (E I).",
                                    "Prepare para integração termo a termo."
                                  ],
                                  "verification": "k_e é simétrica 4x4; termos envolvem E I / L^3 e G A / L.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Calculadora simbólica ou software como SymPy, anotações de D e B.",
                                  "tips": "Agrupe termos idênticos; simetria reduz cálculos pela metade.",
                                  "learningObjective": "Entender a origem variacional da matriz de rigidez em EF.",
                                  "commonMistakes": "Inverter ordem B^T D B; esquecer fator κ ou J = L/2."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar a integração analítica dos termos da matriz k_e",
                                  "subSteps": [
                                    "Integre cada termo ∫ B_i D_jk B_k dξ de -1 a 1 (ex: ∫ N1^2 dξ = 1/3).",
                                    "Calcule integrais padrão: ∫1 dξ=2, ∫ξ dξ=0, ∫ξ^2 dξ=2/3.",
                                    "Monte termos de cisalhamento: k11 = k33 = (κ G A)/L * (7/10 - algo wait, fórmula exata).",
                                    "Inclua termos de flexão: k22 = k44 = 4 E I / L^3 * integrais.",
                                    "Escreva matriz completa: ex k13 = - (κ G A)/L * (1/10), etc."
                                  ],
                                  "verification": "Matriz final coincide com fórmulas padrão de literatura (ex: termodiagonal 12 E I / L^3 para Euler, ajustado).",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Tabela de integrais polinomiais, verificador online de EF.",
                                  "tips": "Use expansão binomial para produtos N_i N_j; verifique paridade de funções ímpares.",
                                  "learningObjective": "Realizar integrais exatas para matrizes de rigidez simbólicas.",
                                  "commonMistakes": "Erros em integrais (ex: ∫ξ^2=2/3 não 1); inconsistência de unidades."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e simplificar a matriz de rigidez obtida",
                                  "subSteps": [
                                    "Confirme simetria e positivos definitos (autovalores >0).",
                                    "Compare com caso limite Euler-Bernoulli (G A → ∞, Φ→0).",
                                    "Limpe expressões: fatores comuns como 12 E I / L^3.",
                                    "Discuta efeitos de cisalhamento em elementos curtos.",
                                    "Documente matriz final 4x4 explícita."
                                  ],
                                  "verification": "Particionamento rígido: rigidez infinita em cisalhamento para nós.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software de matriz (MATLAB/Mathematica) para autovalores.",
                                  "tips": "Teste com L pequeno vs grande para ver efeito Timoshenko.",
                                  "learningObjective": "Garantir propriedades físicas da matriz de rigidez.",
                                  "commonMistakes": "Termos off-diagonal errados; não verificar simetria."
                                }
                              ],
                              "practicalExample": "Para viga Timoshenko com L=1 m, E=210 GPa, I=1e-4 m^4, G=81 GPa, A=0.01 m^2, κ=5/6: Compute k_e[1,1] = κ G A / L * (7/10) ≈ 5654 N/m; matriz completa tem k[2,2]=12 E I / L^3 ≈ 2.52e6 N.m; use para deslocamento unitário em nó 1 e verifique reações.",
                              "finalVerifications": [
                                "Matriz k_e é simétrica e definida positiva.",
                                "Termos de cisalhamento κ G A / L aparecem corretamente nos cantos.",
                                "Termos de flexão combinam com 12 E I / L^3, 6 E I / L^2, 4 E I / L.",
                                "Integração em nós dá rigidez consistente (ex: k11 + k12*θ/w).",
                                "Limite G A → ∞ recupera Euler-Bernoulli.",
                                "Dimensões corretas: força/deslocamento, momento/rotação."
                              ],
                              "assessmentCriteria": [
                                "Precisão das funções de forma e derivadas B (80% correto).",
                                "Correta formulação de D e B^T D B (integral simbólica).",
                                "Integrais exatas sem erros aritméticos (ver 5 termos chave).",
                                "Matriz final idêntica à referência padrão.",
                                "Explicação qualitativa de cisalhamento vs flexão.",
                                "Validações numéricas e limite físico."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo integral exato de polinômios e mudança de variável.",
                                "Física: Teoria de vigas Timoshenko, tensão de cisalhamento.",
                                "Programação: Implementar em Python/MATLAB para automação de k_e.",
                                "Engenharia Civil: Análise de vigas em softwares como ANSYS.",
                                "Matemática Computacional: Quadratura numérica como alternativa."
                              ],
                              "realWorldApplication": "Na análise de estruturas aeroespaciais ou civis com vigas curtas/pares (ex: asas de avião, vigas de pontes), onde cisalhamento é significativo; usado em solvers EF como NASTRAN para prever deformações precisas e evitar falhas por subestimação de deflexões."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.3.3.1"
                            ]
                          },
                          {
                            "id": "34.1.3.3.3",
                            "name": "Verificar casos limites",
                            "description": "Comparar a matriz obtida com o caso de Euler-Bernoulli (kGA → ∞) e validar com fórmulas clássicas de vigas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Recordar e formular a matriz de rigidez do elemento de viga Timoshenko 2D",
                                  "subSteps": [
                                    "Identificar os graus de liberdade do elemento: deslocamentos verticais e rotações nos nós (4 DOFs para 2 nós).",
                                    "Escrever a matriz de rigidez [K] geral para viga Timoshenko, incluindo termos de flexão (EI/L^3), cisalhamento (kGA/L) e acoplamentos.",
                                    "Listar explicitamente todos os 4x4 termos da matriz, destacando dependência em EI, kGA, L e Φ (fator de cisalhamento).",
                                    "Verificar unidades e simetria da matriz.",
                                    "Documentar os parâmetros simbólicos usados (L, EI, GA, k)."
                                  ],
                                  "verification": "A matriz [K]_Timoshenko está corretamente escrita e simétrica, com termos de cisalhamento visíveis.",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "Folha de papel ou software simbólico como SymPy/MATLAB",
                                    "Referência teórica de elementos finitos (livro de Bathe ou Zienkiewicz)"
                                  ],
                                  "tips": "Use notação matricial padrão e mantenha símbolos para facilitar o limite posterior.",
                                  "learningObjective": "Compreender a estrutura da matriz de rigidez incluindo efeitos de cisalhamento.",
                                  "commonMistakes": [
                                    "Esquecer termos acoplados entre cisalhamento e flexão",
                                    "Invertar sinais em termos off-diagonal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar o limite kGA → ∞ na matriz de rigidez Timoshenko",
                                  "subSteps": [
                                    "Explicar fisicamente o limite: rigidez ao cisalhamento infinita implica deflexão por cisalhamento nula.",
                                    "Identificar termos na [K]_Timoshenko que dependem de kGA e dividir por kGA onde aplicável.",
                                    "Tomar o limite matemático: termos ~1/(kGA) → 0, termos constantes permanecem.",
                                    "Simplificar cada entrada da matriz, obtendo [K]_limite.",
                                    "Verificar se a matriz resultante mantém propriedades de rigidez (positiva definida)."
                                  ],
                                  "verification": "Todos os termos de cisalhamento desaparecem e a matriz simplificada é obtida corretamente.",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "Calculadora simbólica ou papel para manipulações algébricas",
                                    "Tabela de fórmulas de vigas Timoshenko"
                                  ],
                                  "tips": "Trabalhe termo a termo; use expansão em série para clareza se necessário.",
                                  "learningObjective": "Dominar análise de limites em formulações de elementos finitos.",
                                  "commonMistakes": [
                                    "Não dividir corretamente por kGA em acoplamentos",
                                    "Ignorar termos de ordem superior em 1/kGA"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Obter e recordar a matriz de rigidez clássica Euler-Bernoulli",
                                  "subSteps": [
                                    "Recordar a formulação EB: ignora cisalhamento, usa forma exata de interpolação cúbica para deflexão.",
                                    "Escrever a matriz [K]_EB 4x4 padrão: termos como 12EI/L^3, 6EI/L^2, etc.",
                                    "Derivar brevemente via princípio dos trabalhos virtuais para EB, confirmando os termos.",
                                    "Comparar dimensionalmente com [K]_limite do passo anterior.",
                                    "Notar diferenças chave: EB tem termos exatos sem Φ."
                                  ],
                                  "verification": "Matriz [K]_EB está idêntica à literatura padrão e dimensões coincidem.",
                                  "estimatedTime": "15 minutes",
                                  "materials": [
                                    "Livro de referência EF (ex: Logan's Finite Element Method)",
                                    "Planilha Excel para matrizes numéricas"
                                  ],
                                  "tips": "Memorize os 10 termos únicos da matriz EB; use simetria para agilizar.",
                                  "learningObjective": "Internalizar a matriz clássica e sua derivação.",
                                  "commonMistakes": [
                                    "Confundir com matriz de viga 3D ou placa",
                                    "Erros nos coeficientes como 12 vs 6"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar matrizes e validar com fórmulas clássicas de vigas",
                                  "subSteps": [
                                    "Subtrair [K]_limite - [K]_EB elemento a elemento e verificar nulidade.",
                                    "Escolher um problema clássico (ex: viga bi-apoiada com carga uniforme) e computar deslocamentos com ambas matrizes.",
                                    "Comparar resultados com soluções analíticas EB (ex: δ_max = 5qL^4/384EI).",
                                    "Analisar erro relativo e confirmar convergência no limite.",
                                    "Documentar conclusões e discutir implicações numéricas (condicionamento da matriz)."
                                  ],
                                  "verification": "Matrizes coincidem exatamente e validação numérica tem erro < 0.1%.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Software numérico como MATLAB/Python (NumPy)",
                                    "Tabelas de soluções analíticas de vigas"
                                  ],
                                  "tips": "Use valores numéricos concretos (L=1, EI=1, kGA=1e6) para verificação rápida.",
                                  "learningObjective": "Validar consistência teórica e prática entre formulações.",
                                  "commonMistakes": [
                                    "Não normalizar unidades",
                                    "Escolher problema onde EB não se aplica perfeitamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um elemento de viga 2D com L=1 m, EI=1e4 N.m², kGA inicial=1e6 N: compute [K]_Timoshenko, tome kGA→∞ obtendo [K]_limite = [[12,6,-12,6],[6,4L,-6,2L],... ] (unidades omitidas), compare com [K]_EB padrão e valide deflexão de cantilever sob ponta carga: δ=PL^3/3EI em ambos.",
                              "finalVerifications": [
                                "Matriz no limite kGA→∞ idêntica à EB em todos os 10 termos únicos.",
                                "Simetria e positiva definitividade preservadas.",
                                "Validação numérica em pelo menos 2 casos de carga clássicos (erro <1e-6).",
                                "Discussão de implicações para vigas esbeltas incluída.",
                                "Ausência de termos residuais de cisalhamento.",
                                "Convergência confirmada variando kGA de 1e3 a 1e9."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na aplicação do limite (100% match).",
                                "Correção das matrizes EB e Timoshenko (verificação cruzada com referências).",
                                "Qualidade da validação numérica (gráficos de convergência).",
                                "Profundidade da análise de erros comuns e dicas.",
                                "Clareza na documentação e conexões físicas.",
                                "Eficiência temporal (dentro de 90 min total)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de limites e manipulação matricial.",
                                "Física: Teoria de vigas e princípios de mecânica dos sólidos.",
                                "Programação: Implementação em Python/MATLAB para automação.",
                                "Engenharia Civil: Análise de estruturas esbeltas.",
                                "Estatística: Análise de erro e sensibilidade paramétrica."
                              ],
                              "realWorldApplication": "Em simulações FEA de vigas em softwares como ANSYS ou Abaqus, essa verificação garante que modelos Timoshenko recuperem comportamentos Euler-Bernoulli para vigas esbeltas (h/L < 1/10), evitando discrepâncias em projetos de pontes, edifícios ou aerofólios onde cisalhamento é desprezível, otimizando precisão e tempo computacional."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.3.3.2"
                            ]
                          },
                          {
                            "id": "34.1.3.3.4",
                            "name": "Transformar para coordenadas globais",
                            "description": "Derivar a matriz de rotação R para elementos inclinados em 2D, obtendo k_global = R^T k_local R.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o sistema de coordenadas local e global para o elemento inclinado",
                                  "subSteps": [
                                    "Identifique os nós inicial (i) e final (j) do elemento viga em coordenadas globais (X, Y).",
                                    "Calcule o ângulo de inclinação θ entre o eixo local x' (do nó i ao j) e o eixo global X, usando θ = atan2(ΔY, ΔX).",
                                    "Liste os graus de liberdade (DOFs): para cada nó, ux (desloc. horizontal), uy (vertical), θz (rotação); total 6 DOFs.",
                                    "Defina vetores de deslocamentos locais {d_local} e globais {d_global}, relacionando-os por {d_local} = R {d_global}.",
                                    "Esboce diagramaticamente o elemento inclinado com eixos locais e globais."
                                  ],
                                  "verification": "Confirme que θ está em radianos ou graus consistentes e que os DOFs estão corretamente mapeados em uma tabela ou diagrama.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Papel e lápis ou software de desenho (ex: GeoGebra)",
                                    "Calculadora para atan2",
                                    "Referência de livro de Elementos Finitos"
                                  ],
                                  "tips": "Sempre use θ como o ângulo do local x' com global X; normalize ΔX e ΔY pelo comprimento L para cosθ e senθ.",
                                  "learningObjective": "Compreender a geometria e os DOFs de um elemento viga 2D inclinado em coordenadas globais.",
                                  "commonMistakes": "Confundir θ com o ângulo do global para local; esquecer que rotações θz são invariantes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a matriz de rotação R para os deslocamentos",
                                  "subSteps": [
                                    "Defina c = cosθ e s = sinθ.",
                                    "Construa a matriz de rotação 2D para translações: T = [[c, s], [-s, c]].",
                                    "Para cada nó, a submatriz R_nó é blkdiag(T, 1), onde blkdiag combina T (2x2) com 1 (1x1 para θz).",
                                    "Monte R (6x6) como bloco diagonal: R = blkdiag(R_nó_i, R_nó_j).",
                                    "Verifique que R é ortogonal: R^T R = I (calcule manualmente ou numericamente)."
                                  ],
                                  "verification": "Multiplique R^T * R e confirme identidade; det(R) = 1.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Calculadora matricial ou MATLAB/Python (NumPy)",
                                    "Folha de papel quadriculado",
                                    "Tabela trigonométrica"
                                  ],
                                  "tips": "Use sympy ou software simbólico para derivar; lembre que R transforma de global para local.",
                                  "learningObjective": "Construir a matriz de rotação R que relaciona deslocamentos locais e globais.",
                                  "commonMistakes": "Esquecer o bloco para rotações (deve ser identidade); inverter T para forças vs. deslocamentos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a transformação para obter a matriz de rigidez global k_global",
                                  "subSteps": [
                                    "Lembre que forças locais {f_local} = k_local {d_local}, e {d_local} = R {d_global}, {f_global} = R^T {f_local}.",
                                    "Substitua para obter {f_global} = R^T k_local R {d_global}, logo k_global = R^T k_local R.",
                                    "Assuma uma k_local conhecida (ex: para viga Euler-Bernoulli) e compute simbolicamente ou numericamente.",
                                    "Expanda a multiplicação matricial: primeiro k_local R, depois R^T (resultado).",
                                    "Armazene k_global em formato de vetor coluna para montagem global posterior."
                                  ],
                                  "verification": "Confirme simetria de k_global (k_ij = k_ji) e rigidez nula em direções livres.",
                                  "estimatedTime": "60 minutes",
                                  "materials": [
                                    "Software de álgebra simbólica (SymPy ou Mathematica)",
                                    "k_local exemplo impresso",
                                    "Planilha Excel para multiplicação numérica"
                                  ],
                                  "tips": "Comece com θ=0 para verificar k_global = k_local; use propriedades de ortogonalidade para simplificar.",
                                  "learningObjective": "Derivar a fórmula de transformação de rigidez e computá-la.",
                                  "commonMistakes": "Usar R ao invés de R^T; não transpor corretamente; ignorar consistência de índices de DOFs."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e interpretar a matriz k_global",
                                  "subSteps": [
                                    "Compare k_global com casos especiais (θ=0°, 90°).",
                                    "Calcule a rigidez equivalente axial e flexural em direções globais.",
                                    "Teste com deslocamento unitário global e verifique forças.",
                                    "Discuta como k_global se integra na montagem da matriz global do problema.",
                                    "Implemente em código simples para automação."
                                  ],
                                  "verification": "Aplique deslocamento unitário e confirme energia de deformação igual em local/global.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Código Python/MATLAB pronto",
                                    "Exemplo numérico resolvido",
                                    "Gráficos de deformação"
                                  ],
                                  "tips": "Plote k_global como mapa de calor para visualizar acoplamentos.",
                                  "learningObjective": "Validar a transformação e entender implicações estruturais.",
                                  "commonMistakes": "Não verificar simetria pós-transformação; confundir ordenação de DOFs entre nós."
                                }
                              ],
                              "practicalExample": "Considere uma viga de L=2m, θ=45°, E=200GPa, I=1e-4 m^4, A=0.01m^2. k_local tem termos EA/L=1e6 N/m axial, 12EI/L^3=1.5e6 N/m flexional. Compute R com c=s=√2/2, então k_global(1,1) = (EA/L + 12EI/L^3)/2 ≈ 1.25e6 N/m.",
                              "finalVerifications": [
                                "R é ortogonal (R R^T = I).",
                                "k_global é simétrica e positiva definida.",
                                "Para θ=0, k_global = k_local.",
                                "Energia de deformação invariante: d_g^T k_g d_g = d_l^T k_l d_l.",
                                "Rigidez axial global = (EA/L) em direção do elemento."
                              ],
                              "assessmentCriteria": [
                                "Correção na derivação de θ e c, s.",
                                "Construção precisa da matriz R 6x6.",
                                "Aplicação exata da fórmula k_g = R^T k_l R.",
                                "Verificação de propriedades (ortogonalidade, simetria).",
                                "Interpretação física correta dos termos.",
                                "Exemplo numérico sem erros de cálculo."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: multiplicação e propriedades de matrizes ortogonais.",
                                "Geometria Analítica: vetores direção e ângulos em 2D.",
                                "Programação Computacional: implementação em Python/NumPy para EF.",
                                "Física: transformação de tensores de rigidez."
                              ],
                              "realWorldApplication": "Em análise de estruturas civis como telhados inclinados, torres de vento ou pontes com vigas diagonais, onde elementos não alinhados ao global requerem essa transformação para montagem da matriz de rigidez total e solução de deslocamentos sob cargas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "34.1.3.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.6",
                    "name": "Formulação de pórticos 2D e 3D",
                    "description": "Formulação de elementos de pórtico em 2D e 3D, incluindo rotações e acoplamento de graus de liberdade.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.6.1",
                        "name": "Elementos de pórtico 2D",
                        "description": "Formulação dos elementos de pórtico em duas dimensões, considerando graus de liberdade translacionais e rotacionais por nó.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.6.1.1",
                            "name": "Identificar graus de liberdade em pórticos 2D",
                            "description": "Reconhecer e descrever os 3 graus de liberdade por nó (deslocamentos axiais, transversais e rotação em torno do eixo z) em elementos de pórtico 2D.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos de pórticos 2D",
                                  "subSteps": [
                                    "Defina um pórtico 2D como uma estrutura plana composta por elementos lineares (vigas e colunas) com conexões rígidas no plano XY.",
                                    "Diferencie pórticos de treliças: pórticos suportam momentos e cisalhamento, treliças apenas forças axiais.",
                                    "Identifique o sistema de coordenadas: plano XY para deformações, rotação perpendicular ao plano (eixo Z).",
                                    "Revise conceitos de nós: pontos de conexão onde graus de liberdade são definidos.",
                                    "Estude um diagrama básico de pórtico com apoios fixos e livres."
                                  ],
                                  "verification": "Desenhe e rotule corretamente um pórtico 2D simples com nós e elementos, explicando diferenças com treliças.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Slides ou livro de Elementos Finitos (capítulo de pórticos 2D)",
                                    "Vídeo introdutório online sobre FEM em pórticos"
                                  ],
                                  "tips": "Sempre visualize o pórtico no plano XY para evitar confusão com 3D.",
                                  "learningObjective": "Dominar a definição e geometria básica de pórticos 2D.",
                                  "commonMistakes": [
                                    "Confundir pórticos com treliças (ignorar momentos)",
                                    "Esquecer que análise é planar (XY)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e numerar os nós em um pórtico 2D",
                                  "subSteps": [
                                    "Examine um pórtico exemplo: liste todos os pontos de junção como nós.",
                                    "Numere os nós sequencialmente, começando pelos apoios.",
                                    "Classifique nós por condições de contorno: fixos (sem movimento), engastados ou livres.",
                                    "Marque cada nó em um desenho esquemático do pórtico.",
                                    "Conte o número total de nós e calcule DOFs potenciais (3 por nó inicialmente)."
                                  ],
                                  "verification": "Rotule corretamente todos os nós em um diagrama de pórtico fornecido ou desenhado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de pórtico impresso ou digital",
                                    "Ferramentas de desenho (lápis, régua)"
                                  ],
                                  "tips": "Numere nós de forma consistente para facilitar montagem de matrizes mais adiante.",
                                  "learningObjective": "Localizar e categorizar nós com precisão em estruturas de pórtico.",
                                  "commonMistakes": [
                                    "Omitir nós internos",
                                    "Confundir nós com pontos médios de elementos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever os 3 graus de liberdade por nó",
                                  "subSteps": [
                                    "Descreva o grau 1: deslocamento axial (u_x ou u): movimento longitudinal ao longo do eixo local do elemento.",
                                    "Descreva o grau 2: deslocamento transversal (u_y ou v): movimento perpendicular ao eixo local.",
                                    "Descreva o grau 3: rotação (θ_z): rotação do nó em torno do eixo perpendicular ao plano (Z).",
                                    "Ilustre cada DOF com setas em um nó isolado: seta horizontal para u_x, vertical para u_y, curva para θ_z.",
                                    "Explique que cada nó livre tem exatamente 3 DOFs em pórtico 2D."
                                  ],
                                  "verification": "Liste e ilustre os 3 DOFs para um nó específico, com descrições precisas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel milimetrado",
                                    "Exemplos de nós de pórtico de apostilas",
                                    "Software de desenho vetorial opcional"
                                  ],
                                  "tips": "Use convenções padrão: u para axial, v para transversal, θ para rotação.",
                                  "learningObjective": "Reconhecer e verbalizar os 3 DOFs por nó em pórticos 2D.",
                                  "commonMistakes": [
                                    "Confundir axial com transversal",
                                    "Esquecer rotação ou achar que há 2 DOFs apenas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar identificação de DOFs em um pórtico completo",
                                  "subSteps": [
                                    "Selecione um pórtico simples com 3 nós e 2 elementos.",
                                    "Liste todos os DOFs potenciais: 3 × número de nós.",
                                    "Ajuste por condições de contorno: elimine DOFs restritos em apoios.",
                                    "Crie uma tabela: nó | DOFs (u_x, u_y, θ_z) | status (livre/restrito).",
                                    "Verifique consistência: conte DOFs livres totais."
                                  ],
                                  "verification": "Complete uma tabela de DOFs para um pórtico exemplo, identificando todos os 3 por nó livre.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplo de pórtico impresso",
                                    "Planilha Excel para tabela de DOFs"
                                  ],
                                  "tips": "Comece pelos nós livres para evitar erros em contagens.",
                                  "learningObjective": "Integrar identificação de DOFs em uma estrutura completa.",
                                  "commonMistakes": [
                                    "Não aplicar condições de contorno",
                                    "Duplicar DOFs entre nós adjacentes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um pórtico portal simples com dois nós verticais (nó 1 fixo na base esquerda, nó 2 livre no topo direito) e barras conectando: nó 1 tem 0 DOFs (fixo), nó 2 tem 3 DOFs (u_x: horizontal, u_y: vertical, θ_z: rotação). Desenhe e liste: para nó 2, u_x permite movimento horizontal, u_y vertical, θ_z torção no plano.",
                              "finalVerifications": [
                                "Liste corretamente os 3 DOFs por nó em um pórtico dado.",
                                "Descreva cada DOF com direção e significado físico.",
                                "Identifique DOFs restritos por apoios.",
                                "Conte DOFs livres totais sem erros.",
                                "Ilustre DOFs em um diagrama nodal."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição dos 3 DOFs (axial, transversal, rotação).",
                                "Correta localização e numeração de nós.",
                                "Aplicação de condições de contorno.",
                                "Clareza em ilustrações e tabelas.",
                                "Compreensão de diferenças com outros elementos (ex: treliças)."
                              ],
                              "crossCurricularConnections": [
                                "Física/Estática: Equilíbrio de forças e momentos nos nós.",
                                "Matemática/Álgebra Linear: Vetores de deslocamento e matrizes de rigidez.",
                                "Informática: Programação de solvers FEM (Python/MATLAB).",
                                "Engenharia Civil: Análise de estruturas como edifícios e pontes."
                              ],
                              "realWorldApplication": "Na análise de elementos finitos para edifícios ou pontes, identificar os 3 DOFs por nó em pórticos 2D permite montar o vetor de deslocamentos e matriz global de rigidez, essencial para simular deformações sob cargas reais em softwares como SAP2000 ou ANSYS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.6.1.2",
                            "name": "Derivar matriz de rigidez local para pórtico 2D",
                            "description": "Derivar a matriz de rigidez local de um elemento de pórtico 2D combinando as contribuições de extensão axial e flexão, utilizando funções de interpolação hermitianas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Derivar a matriz de rigidez para extensão axial do elemento pórtico",
                                  "subSteps": [
                                    "Defina o sistema de coordenadas locais: eixo x ao longo do elemento, comprimento L.",
                                    "Expresse o deslocamento axial u(ξ) = (1 - ξ) u_{x1} + ξ u_{x2}, onde ξ = x/L.",
                                    "Calcule a deformação ε = du/dx = (u_{x2} - u_{x1}) / L.",
                                    "Determine a força axial N = (EA / L) (u_{x2} - u_{x1}).",
                                    "Monte a matriz [k_{axial}] = (EA / L) [[1, -1], [-1, 1]] para os graus de liberdade u_{x1} e u_{x2}."
                                  ],
                                  "verification": "Verifique se a matriz é simétrica e resulta em forças corretas para deslocamentos unitários (ex: u_{x2}=1, outros=0 → N = EA/L).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora científica",
                                    "Livro de Elementos Finitos (capítulo de barras)"
                                  ],
                                  "tips": "Sempre normalize com ξ para facilitar cálculos simbólicos.",
                                  "learningObjective": "Compreender e derivar a contribuição axial da matriz de rigidez local.",
                                  "commonMistakes": "Confundir deformação com deslocamento direto; esquecer o fator 1/L na derivada."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir funções de interpolação hermitianas para flexão",
                                  "subSteps": [
                                    "Introduza o parâmetro adimensional ξ = x/L (0 ≤ ξ ≤ 1).",
                                    "Defina as funções de forma hermitianas para deslocamento transverso v e rotação θ: N1 = 1 - 3ξ² + 2ξ³ (v1), N2 = L(ξ - 2ξ² + ξ³) (θ1), N3 = 3ξ² - 2ξ³ (v2), N4 = L(-ξ² + ξ³) (θ2).",
                                    "Expresse v(ξ) = [N] {d_flex}, onde {d_flex} = [v1, Lθ1, v2, Lθ2]^T.",
                                    "Calcule a matriz de derivadas B = (1/L) d[N]/dξ, com componentes para curvatura κ = d²v/dx².",
                                    "Verifique condições de contorno: N1(0)=1, N1'(0)=0, N3(1)=1, etc."
                                  ],
                                  "verification": "Aplique ξ=0 e ξ=1 para confirmar que v e dv/dx coincidem com os nós.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software simbólico como Mathematica ou SymPy (opcional)",
                                    "Tabela de funções hermitianas"
                                  ],
                                  "tips": "Multiplique θ por L nas funções para normalizar unidades.",
                                  "learningObjective": "Dominar funções hermitianas para garantir continuidade de deslocamento e rotação.",
                                  "commonMistakes": "Erros nos coeficientes polinomiais; esquecer normalização por L em rotações."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a matriz de rigidez para flexão do elemento viga",
                                  "subSteps": [
                                    "Recorde a relação constitutiva: momento fletor M = -EI d²v/dx² = -EI κ.",
                                    "Expresse a matriz de deformação B com blocos para curvatura: B = [[0, 12EI/L³, -6EI/L², 4EI/L, 12EI/L³, -6EI/L², 2EI/L], ...] (forma padrão).",
                                    "Calcule [k_{flex}] = ∫_0^L B^T EI B dx, usando integração analítica em ξ.",
                                    "Obtenha a matriz padrão 4x4 para flexão: [[12EI/L³, 6EI/L², -12EI/L³, 6EI/L²], [6EI/L², 4EI/L, -6EI/L², 2EI/L], ...].",
                                    "Confirme simetria e partição correta para v1, θ1, v2, θ2."
                                  ],
                                  "verification": "Compare com fórmula padrão de livros; teste com deslocamento unitário em v2 para obter reações corretas.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Folha de derivação simbólica",
                                    "Referência: Logan 'Elementos Finitos'"
                                  ],
                                  "tips": "Use integração por partes ou tabelas conhecidas para evitar cálculos longos.",
                                  "learningObjective": "Derivar a rigidez flexional via formulação de deslocamentos.",
                                  "commonMistakes": "Sinal incorreto na curvatura (M = -EI κ); erros na matriz B."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar matrizes para obter a rigidez local completa do pórtico 2D",
                                  "subSteps": [
                                    "Estruture a matriz 6x6 com DOFs ordenados: u_{x1}, v1, θ1, u_{x2}, v2, θ2.",
                                    "Insira [k_{axial}] nos índices (1,1),(1,4),(4,1),(4,4).",
                                    "Insira [k_{flex}] nos índices (2,2),(2,3),(2,5),(2,6),(3,2), etc., para v e θ.",
                                    "Preencha zeros nos acoplamentos cruzados (axial-flexão desprezados localmente).",
                                    "Verifique propriedades: simétrica, semi-definida positiva, rigidez infinita para estados rígidos."
                                  ],
                                  "verification": "Multiplique {d} unitário e confira forças; some linhas para equilíbrio.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Matriz 6x6 em branco",
                                    "Resultados dos steps anteriores"
                                  ],
                                  "tips": "Use notação bloqueada para visualizar: [[k_axial, 0], [0, k_flex]].",
                                  "learningObjective": "Montar a matriz de rigidez local integrada do elemento pórtico 2D.",
                                  "commonMistakes": "Ordem errada de DOFs; inserir flexão nos locais axiais."
                                }
                              ],
                              "practicalExample": "Considere um elemento pórtico com L=3m, EA=2e6 N, EI=5e7 N.m². Derive [k_local]: k_axial = (2e6/3) [[1,-1],[-1,1]]; k_flex padrão escalado. Resultado parcial: k11=6.67e5 (axial), k22=12*5e7/(27)=2.22e7 (flexão v1).",
                              "finalVerifications": [
                                "Matriz 6x6 simétrica com zeros nos acoplamentos axial-transverso.",
                                "Bloco axial matches (EA/L) [[1,-1],[-1,1]].",
                                "Bloco flexão idêntico à viga 2D padrão.",
                                "Soma de linhas zero para modos rígidos (translação, rotação).",
                                "Valores diagonais positivos e crescentes com EA/EI.",
                                "Teste numérico: forças para {1,0,0,0,0,0} = coluna 1 correta."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática em todas as derivações (sem erros algébricos).",
                                "Uso preciso de funções hermitianas e matriz B.",
                                "Estrutura 6x6 correta com posicionamento exato dos blocos.",
                                "Verificações de simetria e propriedades físicas realizadas.",
                                "Clareza e organização na apresentação simbólica.",
                                "Exemplo numérico consistente com parâmetros dados."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: manipulação e integração de matrizes.",
                                "Cálculo Diferencial: derivação de funções hermitianas e curvatura.",
                                "Programação: implementação em Python/MATLAB para automação.",
                                "Física: princípios de equilíbrio e energia em estruturas.",
                                "Matemática Numérica: aproximação por elementos finitos."
                              ],
                              "realWorldApplication": "Fundamental para análise de estruturas em software como ANSYS ou SAP2000, permitindo simular edifícios, pontes e torres sob cargas reais, otimizando projetos contra colapsos como no caso de falhas em vigas de concreto armado."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.6.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.6.1.3",
                            "name": "Aplicar condições de contorno em pórticos 2D",
                            "description": "Aplicar restrições de deslocamento e rotação nas extremidades dos elementos para simular apoios fixos, engastados ou articulados em formulações 2D.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar graus de liberdade e tipos de apoios em pórticos 2D",
                                  "subSteps": [
                                    "Identifique os 3 graus de liberdade por nó em pórticos 2D: deslocamento horizontal (ux), deslocamento vertical (uy) e rotação (θz).",
                                    "Classifique apoios comuns: apoio articulado (ux=0, uy=0, θz livre), apoio engastado (ux=0, uy=0, θz=0) e apoio rolamento (uy=0, ux e θz livres).",
                                    "Desenhe diagramas esquemáticos de cada tipo de apoio, anotando as restrições de deslocamento e rotação.",
                                    "Revise a matriz de rigidez local do elemento de pórtico 2D e como as condições afetam a global.",
                                    "Liste exemplos de estruturas reais que usam cada tipo de apoio."
                                  ],
                                  "verification": "Crie um diagrama completo com todos os tipos de apoios corretamente rotulados e graus de liberdade restritos indicados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis",
                                    "Livro de Elementos Finitos (ex: Bathe ou Zienkiewicz)",
                                    "Slides ou vídeo introdutório sobre pórticos 2D"
                                  ],
                                  "tips": "Use setas para indicar direções livres e travas para restrições; memorize ux=horizontal, uy=vertical, θz=rotação no plano.",
                                  "learningObjective": "Compreender os graus de liberdade e restrições associadas a cada tipo de apoio em pórticos 2D.",
                                  "commonMistakes": [
                                    "Confundir rotação θz com deslocamentos lineares",
                                    "Esquecer que apoios rolamento liberam ux mas restringem uy",
                                    "Ignorar a influência na matriz de rigidez global"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e mapear condições de contorno em um modelo de pórtico",
                                  "subSteps": [
                                    "Desenhe o pórtico exemplo: um quadro retangular com apoio engastado em A e articulado em B.",
                                    "Numere os nós e elementos, atribuindo coordenadas (x,y) a cada nó.",
                                    "Analise o problema físico: identifique apoios baseados na descrição (ex: base fixa impede rotação).",
                                    "Crie uma tabela de nós com colunas para ux, uy, θz e marque 'livre' ou 'restrito=0'.",
                                    "Some os graus de liberdade totais e subtraia os restritos para confirmar estaticidade."
                                  ],
                                  "verification": "Tabela completa de condições de contorno com todos os nós mapeados e total de GDLs livres igual ao esperado (geralmente 3 por nó livre).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software de desenho como GeoGebra ou papel milimetrado",
                                    "Planilha Excel para tabela de GDLs"
                                  ],
                                  "tips": "Sempre comece pelos apoios: engastado restringe 3 GDLs, articulado 2; verifique equilíbrio estático manualmente.",
                                  "learningObjective": "Mapear precisamente as restrições de contorno baseadas na geometria e apoios do pórtico.",
                                  "commonMistakes": [
                                    "Rotular nós incorretamente",
                                    "Esquecer GDLs de rotação em apoios articulados",
                                    "Não verificar número total de GDLs livres"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar condições de contorno na formulação matricial",
                                  "subSteps": [
                                    "Monte a matriz de rigidez global [K] sem restrições, somando contribuições locais transformadas.",
                                    "Aplique restrições deletando linhas/colunas correspondentes aos GDLs restritos ou usando método de penalidade.",
                                    "Modifique o vetor de forças {F} para incluir reações nos GDLs restritos (deixe como incógnitas).",
                                    "Resolva o sistema [K_red]{u_red} = {F_red} para deslocamentos livres.",
                                    "Calcule reações nos apoios usando equilíbrio: R = K * u_restrito (zero para livres)."
                                  ],
                                  "verification": "Matriz reduzida [K_red] quadrada e simétrica, solução converge sem erros numéricos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB ou Python com NumPy/SciPy",
                                    "Código template para MEF de pórtico 2D",
                                    "Calculadora matricial"
                                  ],
                                  "tips": "Use método de exclusão para iniciantes; penalidade com fator alto (1e12) para software; normalize unidades.",
                                  "learningObjective": "Aplicar algebraicamente as condições de contorno na equação de equilíbrio global.",
                                  "commonMistakes": [
                                    "Não transformar rigidez local para global",
                                    "Esquecer multiplicar por fatores de rotação",
                                    "Invertar ordem de GDLs na redução"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e validar a aplicação das condições",
                                  "subSteps": [
                                    "Compare deslocamentos nos nós restritos: devem ser zero dentro de tolerância (1e-6).",
                                    "Calcule reações e verifique equilíbrio global: ΣFx=0, ΣFy=0, ΣM=0.",
                                    "Plote deformada escalada e confirme que apoios fixos não rotacionam/deslocam.",
                                    "Teste sensibilidade: libere um GDL restrito e observe mudança drástica nos resultados.",
                                    "Compare com solução analítica para pórtico simples (ex: cantilever beam)."
                                  ],
                                  "verification": "Relatório com plots, tabelas de deslocamentos/reações e confirmação de equilíbrio.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de MEF como ANSYS Student ou FreeFEM",
                                    "Solução analítica de referência"
                                  ],
                                  "tips": "Sempre plote a malha com apoios visíveis; use logs para debug de matrizes.",
                                  "learningObjective": "Validar numericamente a correta imposição das condições de contorno.",
                                  "commonMistakes": [
                                    "Tolerância numérica frouxa permitindo 'quase zero'",
                                    "Esquecer momentos em equilíbrio",
                                    "Não escalar deformada adequadamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um pórtico em L com elemento vertical engastado na base (nó 1: ux=uy=θz=0) e horizontal articulado na ponta (nó 3: ux=uy=0, θz livre), sob carga vertical no cotovelo (nó 2). Aplique restrições, monte [K] 6x6, reduza para 3 GDLs livres e resolva para deslocamentos.",
                              "finalVerifications": [
                                "Deslocamentos nos nós engastados/articulados são zero.",
                                "Reações nos apoios equilibram as cargas aplicadas.",
                                "Deformada mostra rigidez correta nos apoios fixos.",
                                "Matriz de rigidez reduzida é positiva definida.",
                                "Resultados coincidem com solução analítica em 5% de erro.",
                                "Número de GDLs livres corresponde à estaticidade da estrutura."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de restrições por tipo de apoio (100% correto).",
                                "Correta montagem e redução da matriz de rigidez.",
                                "Validação numérica com equilíbrio global satisfeito.",
                                "Uso adequado de software/manual com documentação clara.",
                                "Interpretação física dos resultados (deformada e reações).",
                                "Eficiência temporal: conclusão dentro de 5 horas totais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (inversão de matrizes, autovalores para estabilidade).",
                                "Física: Estática avançada e equilíbrio de estruturas.",
                                "Programação: Implementação numérica em Python/MATLAB para MEF.",
                                "Engenharia Civil: Análise de edifícios e pontes.",
                                "Desenho Técnico: Representação de apoios e deformadas."
                              ],
                              "realWorldApplication": "Na análise de estruturas como edifícios altos ou pontes pênseis, onde condições de contorno simulam fundações engastadas ou articulações em pilares, garantindo precisão na previsão de deformações e segurança contra colapso."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.6.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.6.2",
                        "name": "Elementos de pórtico 3D",
                        "description": "Formulação dos elementos de pórtico em três dimensões, incorporando rotações em múltiplos eixos e acoplamentos torsionais.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.6.2.1",
                            "name": "Identificar graus de liberdade em pórticos 3D",
                            "description": "Descrever os 6 graus de liberdade por nó (3 deslocamentos e 3 rotações) em elementos de pórtico 3D, incluindo torção e flexões em planos XY, YZ e ZX.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de graus de liberdade (DOF) em mecânica estrutural",
                                  "subSteps": [
                                    "Defina DOF como os movimentos independentes possíveis em um nó sem deformação interna.",
                                    "Diferencie DOF cinemáticos de DOF elásticos em elementos estruturais.",
                                    "Classifique DOF em translações (deslocamentos lineares) e rotações (torções e flexões).",
                                    "Explique a importância dos DOF na formulação de elementos finitos.",
                                    "Relacione DOF com equações de equilíbrio estático."
                                  ],
                                  "verification": "Resuma em um diagrama simples os tipos de DOF e confirme com autoavaliação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Elementos Finitos (ex: Zienkiewicz)",
                                    "Vídeo introdutório sobre DOF em estruturas (YouTube ou Khan Academy)"
                                  ],
                                  "tips": "Use analogias como uma junta universal para visualizar movimentos independentes.",
                                  "learningObjective": "Compreender a base teórica dos DOF para contextualizar pórticos 3D.",
                                  "commonMistakes": [
                                    "Confundir DOF com deformações nodais",
                                    "Ignorar restrições de apoios",
                                    "Misturar translações com rotações"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar os 6 graus de liberdade por nó em elementos 3D rígidos",
                                  "subSteps": [
                                    "Liste os 3 DOF de translação: UX (direção X), UY (Y), UZ (Z).",
                                    "Descreva os 3 DOF de rotação: RX (rotação em torno de X - torção), RY (flexão no plano YZ), RZ (flexão no plano XZ).",
                                    "Desenhe um cubo representando um nó com setas indicando cada DOF.",
                                    "Explique convenções de sinal para rotações positivas (regra da mão direita).",
                                    "Compare com nós 2D (apenas 3 DOF: UX, UY, RZ)."
                                  ],
                                  "verification": "Crie um esboço rotulado de um nó 3D com todos os 6 DOF e verifique contra referência padrão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis para esboços",
                                    "Software gratuito como GeoGebra para visualização 3D"
                                  ],
                                  "tips": "Visualize o nó como uma esfera articulada para melhor compreensão espacial.",
                                  "learningObjective": "Dominar a nomenclatura e representação dos 6 DOF em nós 3D.",
                                  "commonMistakes": [
                                    "Invertar eixos de rotação",
                                    "Esquecer torção (RX)",
                                    "Confundir flexões em planos XY/YZ/ZX"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar DOF específicos em elementos de pórtico 3D",
                                  "subSteps": [
                                    "Defina elemento de pórtico 3D como viga com 6 DOF por extremidade (12 DOF totais por elemento).",
                                    "Descreva torção (RX) como rotação ao longo do eixo da viga.",
                                    "Explique flexões: RY (no plano YZ - vertical), RZ (no plano XZ - lateral).",
                                    "Discuta interações entre DOF em pórticos (ex: torção acoplada com flexão bi-momento).",
                                    "Identifique DOF condicionados por seções transversais (ex: seção fechada resiste torção melhor)."
                                  ],
                                  "verification": "Monte uma tabela comparando DOF de pórtico 2D vs 3D e valide com fórmulas de rigidez.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilhas Excel para tabelas",
                                    "Referência: Manual de ANSYS ou ABAQUS para elementos BEAM188"
                                  ],
                                  "tips": "Use coordenadas locais vs globais para evitar confusão em elementos inclinados.",
                                  "learningObjective": "Entender como DOF se manifestam em vigas de pórtico 3D.",
                                  "commonMistakes": [
                                    "Assumir DOF independentes sem considerar acoplamentos",
                                    "Negligenciar torção em seções abertas",
                                    "Confundir planos de flexão"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar identificação de DOF em uma estrutura de pórtico 3D completa",
                                  "subSteps": [
                                    "Desenhe um pórtico 3D simples: 2 colunas e 1 viga, com 4 nós.",
                                    "Liste todos os DOF totais (24 DOF para 4 nós livres).",
                                    "Aplique condições de apoio (ex: nó base fixo remove 6 DOF).",
                                    "Identifique DOF ativos por nó, destacando torção e flexões em planos XY, YZ, ZX.",
                                    "Simule remoção de DOF para estabilidade estática."
                                  ],
                                  "verification": "Gere uma matriz de DOF numerada e confira total de equações de equilíbrio.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Software FEM gratuito como FreeCAD ou CalculiX",
                                    "Papel milimetrado"
                                  ],
                                  "tips": "Numere DOF sequencialmente: 1-6 para nó 1, 7-12 para nó 2, etc.",
                                  "learningObjective": "Capacitar identificação prática de DOF em pórticos 3D reais.",
                                  "commonMistakes": [
                                    "Errar contagem total de DOF",
                                    "Ignorar simetria na estrutura",
                                    "Não considerar apoios corretamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um pórtico 3D de edifício simples com 4 nós: nós 1 e 2 nas bases (fixos, 0 DOF livres), nós 3 e 4 no topo. Cada nó livre tem UX, UY, UZ, RX (torção vertical), RY (flexão YZ), RZ (flexão XZ). Sob carga lateral em X, DOF principais: UZ e RY nos nós 3/4.",
                              "finalVerifications": [
                                "Liste corretamente os 6 DOF por nó com descrições precisas.",
                                "Desenhe diagrama de um nó 3D rotulado sem erros.",
                                "Calcule DOF totais em um pórtico com 6 nós e apoios fixos.",
                                "Diferencie torção (RX) de flexões (RY, RZ) em exemplos.",
                                "Explique impacto de DOF em matriz de rigidez global.",
                                "Identifique DOF restritos em um exemplo de pórtico assimétrico."
                              ],
                              "assessmentCriteria": [
                                "Precisão na nomenclatura e contagem de DOF (90% correto).",
                                "Qualidade de diagramas e visualizações espaciais.",
                                "Correta distinção entre translações, torção e flexões.",
                                "Aplicação correta a estruturas com apoios e cargas.",
                                "Compreensão de acoplamentos entre DOF em 3D.",
                                "Capacidade de reduzir DOF para análise estática."
                              ],
                              "crossCurricularConnections": [
                                "Física: Estática e dinâmica de partículas/rígidos (3D).",
                                "Matemática: Álgebra linear (matrizes de rigidez) e vetores.",
                                "Computação: Programação de solvers FEM (Python/MATLAB).",
                                "Engenharia Civil: Análise de estruturas sísmicas.",
                                "Desenho Técnico: CAD 3D para modelagem de nós."
                              ],
                              "realWorldApplication": "Em projetos de edifícios altos ou pontes, identificar DOF em pórticos 3D permite modelar corretamente torções e flexões sob vento/sismos no software ETABS ou SAP2000, prevenindo colapsos como no caso de falhas por torção em estruturas assimétricas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.6.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.6.2.2",
                            "name": "Derivar matriz de rigidez local para pórtico 3D",
                            "description": "Construir a matriz de rigidez local 12x12 para um elemento de pórtico 3D, somando matrizes de extensão, flexão em dois planos e torção.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir sistema de coordenadas locais e graus de liberdade",
                                  "subSteps": [
                                    "Identifique os 6 graus de liberdade por nó: deslocamentos ux, uy, uz e rotações θx, θy, θz.",
                                    "Defina o eixo local x ao longo do elemento, y e z perpendiculares conforme orientação do pórtico.",
                                    "Numere os 12 DOFs sequencialmente: nó i (1-6), nó j (7-12).",
                                    "Esboce o elemento 3D com vetores de coordenadas locais.",
                                    "Confirme a matriz de transformação global-local se necessário, mas foque no local."
                                  ],
                                  "verification": "Desenhe diagrama com DOFs numerados corretamente e coordenadas rotuladas.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis e borracha",
                                    "Referência: Livro de Elementos Finitos (ex: Bathe ou Zienkiewicz)"
                                  ],
                                  "tips": "Use convenção padrão: θx torção, θy flexão em plano xz, θz em xy.",
                                  "learningObjective": "Compreender e mapear os 12 graus de liberdade locais de um elemento de pórtico 3D.",
                                  "commonMistakes": [
                                    "Confundir ordem dos DOFs entre nós",
                                    "Ignorar rotações como vetores",
                                    "Erro na orientação y/z"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar matriz de rigidez para deformação axial (extensão)",
                                  "subSteps": [
                                    "Lembre a fórmula básica para barra 1D: k_axial = (AE/L) * [1, -1; -1, 1] para DOFs 1 e 7 (ux_i, ux_j).",
                                    "Expanda para 12x12 inserindo zeros nas outras posições, mantendo AE/L nos índices (1,1), (1,7), (7,1), (7,7).",
                                    "Calcule os fatores: A (área), E (módulo de elasticidade), L (comprimento).",
                                    "Verifique simetria e propriedades de partição.",
                                    "Teste com valores numéricos simples."
                                  ],
                                  "verification": "Matriz 12x12 com apenas 4 entradas não-nulas corretas e simétrica.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Calculadora ou spreadsheet",
                                    "Tabela de propriedades do material",
                                    "Software simbólico opcional (SymPy)"
                                  ],
                                  "tips": "Use funções de interpolação lineares N1=1-ξ, N2=ξ para derivar rigorosamente.",
                                  "learningObjective": "Construir a submatriz 2x2 de extensão e embedá-la na matriz 12x12.",
                                  "commonMistakes": [
                                    "Esquecer sinal negativo nas off-diagonais",
                                    "Índices errados para nós i/j",
                                    "Confundir com torção"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar matriz de rigidez para torção",
                                  "subSteps": [
                                    "Use fórmula para torção: k_torsion = (GJ/L) * [1, -1; -1, 1] para DOFs 6 e 12 (θx_i, θx_j).",
                                    "Embed na 12x12 nos índices corretos: (6,6), (6,12), (12,6), (12,12).",
                                    "Defina G (módulo de cisalhamento), J (polar momento de inércia).",
                                    "Derive de princípio de energia ou equilíbrio.",
                                    "Some à matriz axial para sub-total."
                                  ],
                                  "verification": "Adicione à matriz anterior; verifique 4 entradas adicionais corretas.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Fórmulas de seção transversal",
                                    "Calculadora",
                                    "Referência teórica"
                                  ],
                                  "tips": "J = Iy + Iz para seções simples; use valores tabelados.",
                                  "learningObjective": "Isolar e posicionar corretamente a contribuição torsional na matriz total.",
                                  "commonMistakes": [
                                    "Usar E ao invés de G",
                                    "Índices errados para θx",
                                    "Ignorar anti-simétrico falso"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar matrizes de rigidez para flexão em dois planos",
                                  "subSteps": [
                                    "Para flexão em plano x-y (θz): use beam 2D k_bend_y = (EIz/L^3) * matriz 4x4 padrão para DOFs 2,3,8,9 (uy_i, uz_i? Espera, uy_i, θz_i, uy_j, θz_j).",
                                    "Para flexão em x-z (θy): similar com EIy para DOFs 3,5,9,11 (uz_i, θy_i, uz_j, θy_j).",
                                    "Escreva as matrizes 4x4 hermitianas padrão (12 termos cada).",
                                    "Embed cada uma na 12x12 nos blocos correspondentes.",
                                    "Verifique consistência de unidades e simetria."
                                  ],
                                  "verification": "Matrizes de flexão embedadas sem sobreposição; some todas parcial.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Tabelas de matrizes de beam padrão",
                                    "Software para matriz simbólica",
                                    "Papel grande para 12x12"
                                  ],
                                  "tips": "Memorize padrão: [12, 6L, -12, 6L; ...] escalado por EI/L^3.",
                                  "learningObjective": "Derivar e posicionar as submatrizes de flexão para os dois planos.",
                                  "commonMistakes": [
                                    "Confundir Iy/Iz com planos",
                                    "DOFs errados (uy com θy)",
                                    "Fator L^3 vs L^2"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Montar e verificar a matriz de rigidez local total 12x12",
                                  "subSteps": [
                                    "Some todas as submatrizes: axial + torção + flex_y + flex_z.",
                                    "Confirme zeros fora dos blocos DOF acoplados.",
                                    "Verifique simetria, positivos na diagonal, partição conforme nós.",
                                    "Implemente numericamente para exemplo e valide com software.",
                                    "Discuta singularidades ou condicionamento."
                                  ],
                                  "verification": "Matriz final simétrica, diagonal dominante, tamanho 12x12 com ~50 entradas não-nulas.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "MATLAB/Python para soma e plot",
                                    "Exemplo numérico resolvido",
                                    "Validador online de MEF"
                                  ],
                                  "tips": "Use sparse matrix para eficiência; teste com L=1, E=1, etc.",
                                  "learningObjective": "Superpor componentes para obter matriz completa e validá-la.",
                                  "commonMistakes": [
                                    "Sobreposição errada de índices",
                                    "Somas incorretas em diagonais",
                                    "Unidades inconsistentes"
                                  ]
                                }
                              ],
                              "practicalExample": "Para elemento pórtico 3D: L=4m, A=0.02m², E=210GPa, G=81GPa, Iy=8e-5m⁴, Iz=1.2e-4m⁴, J=1.5e-4m⁴. Compute k_axial[1,1]=(AE/L)=1.05e6 N/m; k_torsion[6,6]=(GJ/L)=3.0375e4 Nm/rad; flexões conforme fórmulas. Matriz total usada para montar estrutura global.",
                              "finalVerifications": [
                                "Matriz é 12x12 simétrica com diagonal positiva.",
                                "Sub-blocagens correspondem exatamente a axial(1-7), torção(6-12), flex_y(2,3,8,9), flex_z(3,5,9,11).",
                                "Para deslocamento unitário ux_j=1, força reativa Fx_i = -AE/L correta.",
                                "Energia de deformação positiva definida.",
                                "Comparação numérica com software (ex: ANSYS) <1% erro.",
                                "Nenhum acoplamento espúrio entre DOFs independentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão das fórmulas de cada componente (100% match com referências).",
                                "Correta indexação dos 12 DOFs.",
                                "Simetria e propriedades matemáticas da matriz final.",
                                "Validação numérica com exemplo prático.",
                                "Explicação clara da derivação física/matemática.",
                                "Eficiência na representação (reconhecer estrutura block-diagonal)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (montagem de matrizes, autovalores para modos).",
                                "Física: Mecânica dos sólidos (energia de deformação, princípio dos trabalhos virtuais).",
                                "Computação: Programação numérica (implementar em Python/MATLAB para MEF).",
                                "Engenharia Civil: Análise estática/dinâmica de edifícios e pontes.",
                                "Materiais: Propriedades seccionais (cálculo de I, J)."
                              ],
                              "realWorldApplication": "Essencial para simulações de elementos finitos em softwares como SAP2000, ETABS ou Abaqus, modelando vigas, colunas e treliças em estruturas 3D como arranha-céus, pontes suspensas e torres eólicas, prevendo deformações e tensões sob cargas reais."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.6.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.6.2.3",
                            "name": "Incorporar efeitos torsionais em pórticos 3D",
                            "description": "Incluir o momento de torção e rotação associada na formulação, utilizando constantes de rigidez torsional GJ.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Torção em Elementos de Pórtico 3D",
                                  "subSteps": [
                                    "Revise a teoria de torção em vigas: momento fletor torsional T e ângulo de torção θ.",
                                    "Estude a relação constitutiva T = GJ * (dθ/dx), onde G é o módulo de cisalhamento e J é o momento polar de inércia.",
                                    "Identifique os graus de liberdade adicionais em pórticos 3D: translação em X,Y,Z e rotações Rx,Ry,Rz, com Rz sendo a torção.",
                                    "Analise diferenças entre pórticos 2D e 3D, focando na inclusão da rotação torsional.",
                                    "Desenhe um elemento de pórtico 3D destacando o eixo local e os nós com 6 DOFs cada."
                                  ],
                                  "verification": "Resuma em um diagrama os 6 graus de liberdade de um nó em pórtico 3D e explique o papel de GJ.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Elementos Finitos (ex: Bathe ou Zienkiewicz)",
                                    "Software de desenho como Draw.io",
                                    "Notas de aula sobre mecânica dos sólidos"
                                  ],
                                  "tips": "Use analogias como torcer uma chave para visualizar o ângulo de torção.",
                                  "learningObjective": "Entender os conceitos básicos de torção e seus impactos na formulação de elementos 3D.",
                                  "commonMistakes": [
                                    "Confundir momento polar J com módulo de elasticidade E",
                                    "Ignorar que torção é desacoplada de flexão em vigas retas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Matriz de Rigidez Local para Torção",
                                  "subSteps": [
                                    "Comece com a equação de equilíbrio para torção: dT/dx = 0 (sem cargas distribuídas torsoriais).",
                                    "Aplique aproximação linear para o campo de deslocamento torsional: θ(x) = (1 - ξ)θ_i + ξθ_j, onde ξ = x/L.",
                                    "Calcule as funções de interpolação de Hermite para torção: Nθ_i = 1 - x/L, Nθ_j = x/L.",
                                    "Derive a matriz de rigidez torsional: k_t = (GJ/L) * [[1, -1], [-1, 1]].",
                                    "Integre com as matrizes de tração e flexão para formar a matriz local 12x12 completa."
                                  ],
                                  "verification": "Escreva manualmente a submatriz 2x2 para torção e verifique se simétrica e positiva definida.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Calculadora simbólica como Mathematica ou papel e lápis",
                                    "Planilhas Excel para matrizes",
                                    "Referência: Logan 'A First Course in the Finite Element Method'"
                                  ],
                                  "tips": "Lembre-se: para torção pura, é como uma mola torsional entre nós.",
                                  "learningObjective": "Derivar a contribuição torsional na matriz de rigidez local do elemento.",
                                  "commonMistakes": [
                                    "Usar funções lineares em vez de consistentes para torção",
                                    "Esquecer o sinal negativo nos termos fora da diagonal"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar Torção na Formulação Completa do Elemento de Pórtico 3D",
                                  "subSteps": [
                                    "Monte a matriz de rigidez local total 12x12 combinando tração axial, flexões em dois planos e torção.",
                                    "Posicione o bloco torsional nos DOFs corretos (ex: posições 6 e 12 para Rz_i e Rz_j).",
                                    "Inclua o vetor de forças nodais equivalentes para cargas torsoriais distribuídas, se aplicável.",
                                    "Verifique a simetria e a estrutura tridiagonal bloqueada da matriz.",
                                    "Implemente em código simples (ex: Python com NumPy) para um elemento unitário."
                                  ],
                                  "verification": "Gere a matriz 12x12 para L=1m, GJ=1, EA=1, EIy=1, EIz=1 e confirme valores torsionais.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Editor de código como VS Code",
                                    "Tutoriais de MEF em Python"
                                  ],
                                  "tips": "Ordene DOFs consistentemente: u,v,w,θx,θy,θz por nó.",
                                  "learningObjective": "Integrar efeitos torsionais na matriz de rigidez local completa.",
                                  "commonMistakes": [
                                    "Posição errada dos DOFs torsionais na matriz",
                                    "Confundir θx (rotação em X) com torção"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Transformar para Coordenadas Globais e Aplicar em Pórtico",
                                  "subSteps": [
                                    "Defina a matriz de rotação 3D R baseada em ângulos de Euler ou vetores diretores do eixo local.",
                                    "Construa a matriz de transformação de deslocamentos T = blkdiag(R_i, R_j) para 12 DOFs.",
                                    "Calcule a rigidez global: K_global = T^T * K_local * T.",
                                    "Monte o sistema global para um pórtico simples com 2 elementos.",
                                    "Resolva Ku = F para um caso com torção aplicada e verifique resultados."
                                  ],
                                  "verification": "Compare deslocamentos torsionais com solução analítica para viga cantilever torsional.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código Python estendido",
                                    "Software FEA como ANSYS Student (para validação)",
                                    "Documentação de matrizes de rotação"
                                  ],
                                  "tips": "Use quaternions se ângulos de Euler causarem problemas de gimbal lock.",
                                  "learningObjective": "Transformar e aplicar a formulação em coordenadas globais.",
                                  "commonMistakes": [
                                    "Matriz T incorreta para nós",
                                    "Não preservar simetria após transformação"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Analisar Resultados com Efeitos Torsionais",
                                  "subSteps": [
                                    "Simule um pórtico 3D com carga torsional em um nó.",
                                    "Compare resultados com e sem torção (GJ=0).",
                                    "Calcule tensões torsionais: τ = T * r / J.",
                                    "Analise modos de falha induzidos por torção.",
                                    "Otimize o modelo ajustando GJ para cenários reais."
                                  ],
                                  "verification": "Gráfico de rotações θz vs. posição coincide com teoria elástica.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Matplotlib para plots",
                                    "Exemplos de benchmark em FEA",
                                    "Tabelas de propriedades de seções"
                                  ],
                                  "tips": "Sempre normalize unidades (N, m, Pa) para evitar erros numéricos.",
                                  "learningObjective": "Validar a implementação e interpretar resultados físicos.",
                                  "commonMistakes": [
                                    "Ignorar efeitos de cisalhamento em seções fechadas",
                                    "Escala errada em plots"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise um pórtico 3D em L com dois elementos perpendiculares, aplicando momento torsional de 10 kNm em um nó livre. Calcule rotações e reações, comparando com modelo sem torção para observar diferenças de até 15% em deslocamentos.",
                              "finalVerifications": [
                                "Derivar corretamente a matriz torsional 2x2.",
                                "Montar K_local 12x12 com GJ incluído.",
                                "Resolver um sistema global simples com torção.",
                                "Interpretar rotações θz e momentos T nos resultados.",
                                "Validar contra solução analítica com erro <1%.",
                                "Identificar quando torção é dominante em estruturas assimétricas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da rigidez torsional (sem erros algébricos).",
                                "Correta integração na matriz 12x12 e transformação global.",
                                "Implementação numérica funcional e validada.",
                                "Análise qualitativa dos efeitos torsionais.",
                                "Clareza em diagramas e explicações.",
                                "Eficiência computacional (tempo de execução <1s para 10 nós)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes, autovalores para modos).",
                                "Física: Mecânica dos sólidos e teoria de elasticidade torsional.",
                                "Programação: Implementação numérica com NumPy e solvers lineares.",
                                "Engenharia Civil: Análise de estruturas reais como torres e pontes.",
                                "Materiais: Cálculo de J para perfis I e tubulares."
                              ],
                              "realWorldApplication": "Em projetos de edifícios altos ou pontes pênseis, onde ventos ou cargas assimétricas induzem torção em pórticos 3D, garantindo estabilidade e evitando colapsos como no caso de torres de transmissão de energia."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.6.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.6.3",
                        "name": "Rotações e acoplamento de graus de liberdade",
                        "description": "Tratamento das rotações rígidas e acoplamento entre graus de liberdade translacionais e rotacionais na montagem global.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.6.3.1",
                            "name": "Realizar transformação de coordenadas locais para globais",
                            "description": "Aplicar matriz de rotação para transformar vetores de deslocamentos e forças de coordenadas locais para globais em elementos de pórtico 2D e 3D.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender sistemas de coordenadas locais e globais em pórticos",
                                  "subSteps": [
                                    "Identificar coordenadas globais fixas (X, Y para 2D; X, Y, Z para 3D)",
                                    "Definir coordenadas locais alinhadas ao eixo do elemento (x' ao longo do pórtico, y' perpendicular)",
                                    "Determinar o ângulo θ de rotação entre o eixo local x' e global X",
                                    "Desenhar diagrama do elemento destacando ambos sistemas",
                                    "Notar graus de liberdade: 3 por nó em 2D (u, v, θ), 6 em 3D (u, v, w, θx, θy, θz)"
                                  ],
                                  "verification": "Diagrama completo com ângulo θ marcado e legendas claras",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis e régua",
                                    "Exemplo de pórtico inclinado"
                                  ],
                                  "tips": "Use setas coloridas para diferenciar eixos locais (vermelho) e globais (azul)",
                                  "learningObjective": "Diferenciar e visualizar coordenadas locais vs. globais em elementos de pórtico",
                                  "commonMistakes": [
                                    "Confundir direção local x' com global X",
                                    "Ignorar rotação fora do plano em 3D"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular componentes trigonométricas e construir matriz de rotação",
                                  "subSteps": [
                                    "Calcular c = cos(θ) e s = sin(θ) usando calculadora ou tabela",
                                    "Para 2D (6 DOF): Montar R = [[c, s, 0, 0, 0, 0], [-s, c, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0], ...] estendendo para nós",
                                    "Para 3D (12 DOF): Incluir ângulos φ, ψ e construir R completa com rotações sucessivas",
                                    "Verificar se R é ortogonal: calcular R^T * R ≈ I",
                                    "Escrever matriz explicitamente para o exemplo"
                                  ],
                                  "verification": "Matriz R transcrita corretamente e R^T R = I (erro < 0.01)",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Planilha Excel ou MATLAB para matrizes",
                                    "Tabelas de seno/cosseno"
                                  ],
                                  "tips": "Use convenção de sinal consistente: θ positivo anti-horário",
                                  "learningObjective": "Construir matriz de rotação R para transformações 2D/3D",
                                  "commonMistakes": [
                                    "Erro de sinal em sin(θ)",
                                    "Matriz não simétrica para nós idênticos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Transformar vetores de deslocamento locais para globais",
                                  "subSteps": [
                                    "Escrever vetor deslocamento local {d_l} = [u1_l, v1_l, θ1, u2_l, v2_l, θ2]^T para 2D",
                                    "Aplicar {d_g} = R * {d_l} multiplicando matriz-vetor",
                                    "Calcular componente por componente: ex. u_g1 = c*u1_l + s*v1_l",
                                    "Repetir para 3D estendendo vetor e matriz",
                                    "Arredondar resultados com precisão de 4 casas decimais"
                                  ],
                                  "verification": "Comparar normas: ||d_g|| ≈ ||d_l|| (propriedade de rotação)",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora matricial",
                                    "Software como MATLAB ou Python (NumPy)"
                                  ],
                                  "tips": "Implemente em código para automação: d_g = R @ d_l",
                                  "learningObjective": "Aplicar transformação {d_g} = R {d_l} corretamente",
                                  "commonMistakes": [
                                    "Inverter ordem: usar R^{-1} em vez de R",
                                    "Esquecer DOF rotacionais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Transformar vetores de força locais para globais",
                                  "subSteps": [
                                    "Escrever vetor força local {f_l} = [Fx1_l, Fy1_l, M1, Fx2_l, Fy2_l, M2]^T",
                                    "Aplicar {f_g} = R * {f_l} (mesma R, pois forças transformam igual deslocamentos)",
                                    "Verificar trabalho virtual: {f_l}^T {d_l} = {f_g}^T {d_g}",
                                    "Para 3D: incluir torques e forças Z com matriz expandida",
                                    "Documentar cálculos em tabela"
                                  ],
                                  "verification": "Trabalho preservado: diferença < 1e-6",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Mesmos da Step 3",
                                    "Tabela para organizar vetores"
                                  ],
                                  "tips": "Lembre: R é a mesma para forças e deslocamentos em formulação de deslocamentos",
                                  "learningObjective": "Transformar forças mantendo equilíbrio e trabalho",
                                  "commonMistakes": [
                                    "Usar R^T para forças (correto para rigidez, mas não para vetores básicos)"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar transformações e preparar para matriz de rigidez",
                                  "subSteps": [
                                    "Montar matriz de rigidez local [k_l] simples (ex. treliça ou viga)",
                                    "Transformar [k_g] = R^T [k_l] R",
                                    "Verificar simetria e positiva definitividade de [k_g]",
                                    "Aplicar em sistema simples: resolver deslocamentos globais",
                                    "Comparar resultados com método analítico conhecido"
                                  ],
                                  "verification": "[k_g] simétrica e autovalores positivos",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software FEM básico (ex. Ftool para 2D)",
                                    "MATLAB para autovalores"
                                  ],
                                  "tips": "Teste com θ=0°: deve dar [k_g] = [k_l]",
                                  "learningObjective": "Integrar transformações em montagem de rigidez global",
                                  "commonMistakes": [
                                    "Esquecer R^T na frente de [k_l]"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um pórtico 2D, elemento de 4m a θ=45° (c=s=√2/2≈0.707). Deslocamento local no nó1: u1_l=2mm, v1_l=1mm; nó2 fixo. Força local: Fx1_l=10kN, Fy1_l=5kN. Calcule {d_g} e {f_g}: d_g1x=0.707*2 + 0.707*1≈2.121mm, d_g1y=-0.707*2 + 0.707*1≈-0.707mm; similar para forças.",
                              "finalVerifications": [
                                "Matriz R ortogonal (R^T R = I)",
                                "Normas preservadas: ||d_g|| = ||d_l|| e ||f_g|| = ||f_l||",
                                "Trabalho virtual igual: f_l^T d_l = f_g^T d_g",
                                "Transformação consistente para 2D e extensão 3D",
                                "Rigidez global [k_g] = R^T k_l R simétrica e positiva definida",
                                "Resultados numéricos com erro <0.1%"
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção da matriz R (100%)",
                                "Cálculos corretos de vetores transformados (90-100%)",
                                "Verificação de propriedades ortogonais e trabalho (80-90%)",
                                "Extensão correta para 3D e rigidez (70-80%)",
                                "Clareza em diagramas e documentação (adicional)",
                                "Eficiência no uso de ferramentas computacionais"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: multiplicação matricial e propriedades ortogonais",
                                "Trigonometria e Geometria: seno/cosseno em rotações",
                                "Programação: implementação em Python/NumPy ou MATLAB para FEM",
                                "Física: vetores de força/deslocamento em mecânica estrutural",
                                "Cálculo Numérico: verificação de erros e estabilidade"
                              ],
                              "realWorldApplication": "Na análise de elementos finitos de estruturas como vigas inclinadas em pontes ou edifícios usando software como ANSYS ou SAP2000, garantindo que forças e deslocamentos locais (axiais, cisalhantes) sejam corretamente mapeados para o sistema global para montagem da matriz de rigidez total e solução de problemas reais de engenharia civil/mecânica."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.6.1.2",
                              "10.1.3.6.2.2"
                            ]
                          },
                          {
                            "id": "10.1.3.6.3.2",
                            "name": "Montar matriz de rigidez global com acoplamento",
                            "description": "Montar a matriz de rigidez global de uma estrutura de pórtico, considerando o acoplamento entre rotações e deslocamentos nos nós compartilhados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a geometria da estrutura e numerar os graus de liberdade (DOFs)",
                                  "subSteps": [
                                    "Desenhar o pórtico identificando nós e elementos conectados.",
                                    "Atribuir coordenadas (x,y) a cada nó.",
                                    "Listar DOFs por nó: deslocamento horizontal (u), vertical (v) e rotação (θ), numerando sequencialmente (ex: nó 1: DOF 1=u, 2=v, 3=θ).",
                                    "Contar total de DOFs globais (3 por nó livre).",
                                    "Documentar nós compartilhados para acoplamento."
                                  ],
                                  "verification": "Lista numerada de DOFs corresponde à topologia; total de DOFs é 3 × número de nós.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Diagrama do pórtico",
                                    "Papel milimetrado ou software de desenho (ex: AutoCAD, SketchUp)",
                                    "Folha de cálculo"
                                  ],
                                  "tips": "Comece numerando DOFs da esquerda para direita e baixo para cima para consistência.",
                                  "learningObjective": "Compreender como DOFs nos nós compartilhados criam acoplamento na matriz global.",
                                  "commonMistakes": "Esquecer DOFs de rotação em nós internos ou numerar incorretamente, levando a mismatch nas dimensões."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a matriz de rigidez local para cada elemento do pórtico",
                                  "subSteps": [
                                    "Para cada elemento (viga ou coluna), calcular comprimento L, propriedades (A, I, E).",
                                    "Derivar matriz de rigidez local [k_local] 6x6 em coordenadas locais (axial, transversal, torção).",
                                    "Preencher termos: k11=EA/L, k22=12EI/L³, k33=4EI/L, etc., considerando acoplamento local (ex: k26=-6EI/L²).",
                                    "Verificar simetria e propriedades da matriz.",
                                    "Repetir para todos elementos."
                                  ],
                                  "verification": "Cada [k_local] é 6x6 simétrica positiva definida; termos acoplados (ex: cisalhamento-rotação) presentes.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Fórmulas de elementos de pórtico (livro de Logan's FEM)",
                                    "Calculadora ou Excel/MATLAB"
                                  ],
                                  "tips": "Use convenção consistente: DOFs locais 1-6: u1,v1,θ1,u2,v2,θ2.",
                                  "learningObjective": "Dominar formulação local que introduz acoplamento inerente entre DOFs.",
                                  "commonMistakes": "Inverter sinais em termos acoplados (ex: k26 positivo em vez de negativo) ou usar fórmulas de treliça em vez de pórtico."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Transformar matrizes locais para coordenadas globais",
                                  "subSteps": [
                                    "Para cada elemento inclinado, calcular ângulo α com eixo global X.",
                                    "Construir matriz de transformação de rotação [T] 6x6 (blocos 2x2 para u,v e 1x1 para θ).",
                                    "Computar [k_global_elem] = [T]^T [k_local] [T].",
                                    "Verificar que θ permanece invariante (sem rotação).",
                                    "Manter [k_local] para elementos alinhados (α=0 ou 90°)."
                                  ],
                                  "verification": "[k_global_elem] mantém simetria; termos acoplados preservados após transformação.",
                                  "estimatedTime": "60 minutes",
                                  "materials": [
                                    "Matriz de transformação padrão para pórticos 2D",
                                    "Software simbólico (MATLAB Symbolic ou Python SymPy)"
                                  ],
                                  "tips": "Implemente [T] como blkdiag(R,1,R) onde R = [[c,s],[-s,c]] com c=cosα, s=sinα.",
                                  "learningObjective": "Entender como transformação preserva acoplamento entre rotações e deslocamentos.",
                                  "commonMistakes": "Esquecer transposição em [T]^T ou rotacionar θ incorretamente (θ é invariante)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar a matriz de rigidez global por superposição",
                                  "subSteps": [
                                    "Inicializar [K_global] como matriz n_DOFs × n_DOFs zerada.",
                                    "Para cada elemento, mapear DOFs locais aos globais (ex: elemento 1-2 mapeia DOFs 1-6).",
                                    "Adicionar [k_global_elem] aos índices correspondentes em [K_global] (K(ii) += k(ii)).",
                                    "Garantir acoplamento nos nós compartilhados via sobreposição.",
                                    "Verificar simetria final e ausência de zeros na diagonal principal."
                                  ],
                                  "verification": "[K_global] simétrica, banda-esparsa; entradas nos DOFs compartilhados refletem soma de contribuições.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Lista de conectividade elemento-nós",
                                    "MATLAB/Octave ou Python (NumPy) para assembly"
                                  ],
                                  "tips": "Use loop por elemento: for e in elements: K[np.ix_(dofs_e, dofs_e)] += k_e",
                                  "learningObjective": "Aplicar princípio de superposição para capturar acoplamento global.",
                                  "commonMistakes": "Mapear DOFs errado (off-by-one) ou esquecer adicionar contribuições múltiplas em nós compartilhados."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar a matriz de rigidez global montada",
                                  "subSteps": [
                                    "Verificar dimensões: n_DOFs × n_DOFs.",
                                    "Conferir simetria: K(i,j) == K(j,i) para todos i,j.",
                                    "Testar positiva definida (autovalores >0 ou teste de flexibilidade).",
                                    "Comparar sub-blocos com casos analíticos simples.",
                                    "Documentar partição para condições de contorno futuras."
                                  ],
                                  "verification": "Testes passados; [K_global] pronta para solução {δ} = [K]^-1 {F}.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Código de verificação (MATLAB eig ou cond)",
                                    "Exemplo analítico conhecido"
                                  ],
                                  "tips": "Use sparse matrices em software para eficiência em estruturas grandes.",
                                  "learningObjective": "Garantir integridade da matriz para análises confiáveis.",
                                  "commonMistakes": "Ignorar não-simetria devido a erros de sinal ou inconsistência numérica."
                                }
                              ],
                              "practicalExample": "Considere um pórtico 2D simples: nó1(0,0) fixo, nó2(3m,0), nó3(3m,4m) rolo vertical. Elementos: viga1 nó1-2 (L=3m, EI=1e6 Nm²), coluna2 nó2-3 (L=4m, EI=1e6). DOFs:1u1,2v1,3θ1,4u2,5v2,6θ2,7u3,8v3,9θ3. Monte [K] 9x9 adicionando contribuições locais transformadas, resultando em acoplamento ex: K(5,6) ≠0 devido cisalhamento-rotação na viga.",
                              "finalVerifications": [
                                "Dimensões de [K_global] corretas (3×n_nós × 3×n_nós).",
                                "Simetria confirmada (K^T = K).",
                                "Acoplamento visível em off-diagonais compartilhadas (ex: rotações afetam deslocamentos).",
                                "Soma de rigidezes em DOFs compartilhados exata.",
                                "Matriz banda-esparsa sem entradas espúrias.",
                                "Teste de rigidez: aplicação unitária de força produz deslocamentos finitos."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos termos acoplados (±1% erro).",
                                "Correta identificação e numeração de DOFs.",
                                "Transformação de coordenadas aplicada consistentemente.",
                                "Assembly sem erros de mapeamento.",
                                "Validações matemáticas (simetria, positiva definida) executadas.",
                                "Documentação clara de passos e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Linear: Operações matriciais, autovalores, transformação ortogonal.",
                                "Programação: Implementação em Python/MATLAB para automação de FEM.",
                                "Física: Equilíbrio estático e princípio dos trabalhos virtuais.",
                                "Engenharia Civil: Análise de frames em edifícios."
                              ],
                              "realWorldApplication": "Na análise estrutural de edifícios e pontes via software como SAP2000 ou ANSYS, onde [K_global] com acoplamento permite simular deformações reais sob cargas sísmicas ou vento, prevendo falhas por instabilidade lateral-torsional."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.6.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.6.3.3",
                            "name": "Resolver sistemas com rotações rígidas",
                            "description": "Resolver o sistema global [K]{u}={F} para pórticos, interpretando resultados de deslocamentos, rotações e reações considerando acoplamentos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender rotações rígidas e acoplamento de graus de liberdade em pórticos",
                                  "subSteps": [
                                    "Defina rotação rígida como movimento sem deformação angular em elementos de pórtico.",
                                    "Explique o acoplamento entre graus de liberdade translacionais (ux, uy) e rotacionais (θz) devido à geometria curva.",
                                    "Revise a matriz de rigidez local para elementos de pórtico 2D/3D, destacando termos de acoplamento.",
                                    "Desenhe um elemento de pórtico simples mostrando nós e DOFs acoplados.",
                                    "Compare formulações de barras retas vs. pórticos curvos com rotações rígidas."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito o acoplamento de DOFs e forneça um diagrama anotado.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Finite Element Procedures' de K.J. Bathe (cap. 5)",
                                    "Notas de aula sobre formulação de pórticos",
                                    "Software de desenho como GeoGebra ou papel e lápis"
                                  ],
                                  "tips": "Use analogias com engrenagens rígidas para visualizar acoplamento; foque em transformações de coordenadas locais-globais.",
                                  "learningObjective": "Identificar e explicar como rotações rígidas introduzem acoplamentos na matriz de rigidez.",
                                  "commonMistakes": [
                                    "Confundir rotação rígida com rotação deformacional",
                                    "Ignorar termos off-diagonal na matriz de rigidez",
                                    "Esquecer convenções de sinal para rotações positivas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Montar a matriz de rigidez global considerando rotações rígidas",
                                  "subSteps": [
                                    "Calcule a matriz de rigidez local para um elemento de pórtico com rotação rígida.",
                                    "Aplique a matriz de transformação de coordenadas (R) para obter [k_global] = [R]^T [k_local] [R].",
                                    "Monte a matriz global [K] por superposição para múltiplos elementos.",
                                    "Incorpore condições de contorno removendo/condensando DOFs restritos.",
                                    "Verifique simetria e propriedades de banda esparsa da [K]."
                                  ],
                                  "verification": "Construa [K] para um pórtico de 2 elementos e confirme simetria e valores esperados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Planilha Excel ou MATLAB para montagem matricial",
                                    "Exemplos resolvidos de pórticos 2D",
                                    "Calculadora simbólica como SymPy (Python)"
                                  ],
                                  "tips": "Numere DOFs consistentemente; use funções de shape para pórticos curvos se aplicável.",
                                  "learningObjective": "Construir corretamente a matriz [K] global incorporando acoplamentos de rotações rígidas.",
                                  "commonMistakes": [
                                    "Erro na matriz de rotação (use ângulos corretos)",
                                    "Superposição incorreta de elementos",
                                    "Não penalizar ou remover DOFs fixos adequadamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver o sistema global [K]{u} = {F}",
                                  "subSteps": [
                                    "Defina o vetor de forças {F} incluindo cargas nodais e distribuídas equivalentes.",
                                    "Aplique método direto (Gauss ou LU) ou iterativo para resolver {u} = [K]^{-1} {F}.",
                                    "Use software para validação: implemente em MATLAB ou Python (SciPy).",
                                    "Calcule reações pós-processando {R} = [K]{u} - {F} para DOFs restritos.",
                                    "Analise convergência e verifique equilíbrio global (∑F=0, ∑M=0)."
                                  ],
                                  "verification": "Obtenha {u} e {R} para o exemplo e confirme equilíbrio de forças/momentos.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "MATLAB ou Python com NumPy/SciPy",
                                    "Script template para solver EF 1D",
                                    "Exercício com pórtico conhecido (solução analítica disponível)"
                                  ],
                                  "tips": "Escalone [K] para eficiência; normalize unidades (kN, m) para evitar erros numéricos.",
                                  "learningObjective": "Resolver numericamente o sistema linear considerando acoplamentos.",
                                  "commonMistakes": [
                                    "Inversão direta de [K] grande (use decomposição)",
                                    "Cargas distribuídas não convertidas corretamente",
                                    "Erros de precisão em software devido a tolerâncias"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados de deslocamentos, rotações e reações",
                                  "subSteps": [
                                    "Analise deslocamentos ux, uy e rotações θz em cada nó, considerando convenções.",
                                    "Visualize deformada escalada (fator 10-100x) para observar modos de falha.",
                                    "Calcule tensões/esforços internos nos elementos a partir de {u}.",
                                    "Interprete acoplamentos: como rotação afeta translação e vice-versa.",
                                    "Compare com solução analítica ou software comercial (ex: ANSYS) para validação."
                                  ],
                                  "verification": "Produza gráfico de deformada e tabela de resultados interpretados corretamente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de pós-processamento como Paraview ou MATLAB plot",
                                    "Templates de visualização EF",
                                    "Tabela de resultados de referência"
                                  ],
                                  "tips": "Sempre escale deformada para visibilidade; anote unidades e sinais.",
                                  "learningObjective": "Extrair e interpretar fisicamente os resultados considerando acoplamentos.",
                                  "commonMistakes": [
                                    "Interpretação errada de sinais de rotação",
                                    "Não escalar deformada adequadamente",
                                    "Ignorar verificação de equilíbrio nos resultados"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um pórtico 2D plano com 2 elementos: nó 1 fixo (u1=uy1=θ1=0), nó 2 com carga vertical Fy=-10kN, nó 3 rolamento (ux3=0). Elementos de 3m cada, EA=1e6 kN, EI=1e4 kNm². Monte [K] 6x6, resolva para {u}, obtenha rotações θ2≈-0.001 rad (sentido horário devido a acoplamento), reações corretas.",
                              "finalVerifications": [
                                "Matriz [K] montada corretamente com acoplamentos off-diagonal.",
                                "Solução {u} converge e satisfaz equilíbrio global.",
                                "Interpretação correta de rotações rígidas vs. deformações.",
                                "Visualização da deformada mostra acoplamento lógico.",
                                "Reações calculadas pós-processamento batem com forças aplicadas.",
                                "Validação contra solução analítica dentro de 1% de erro."
                              ],
                              "assessmentCriteria": [
                                "Precisão da montagem de [K]: todos termos de acoplamento corretos (100%).",
                                "Correção da solução numérica: erro <0.5% em deslocamentos/rotações.",
                                "Qualidade da interpretação: explicação física clara dos acoplamentos.",
                                "Visualizações e gráficos: deformada escalada e anotada adequadamente.",
                                "Verificação de equilíbrio: ∑F=0 e ∑M=0 demonstrados.",
                                "Eficiência computacional: uso apropriado de solvers esparsos."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Resolução de sistemas simétricos positivos-definidos.",
                                "Programação Computacional: Implementação de solvers em Python/MATLAB.",
                                "Física/Mecânica: Princípios de equilíbrio estático em estruturas.",
                                "Geometria Analítica: Transformações de coordenadas rotacionais.",
                                "Estatística: Análise de erros numéricos e sensibilidade."
                              ],
                              "realWorldApplication": "Em projetos de edifícios altos ou pontes, análise de pórticos com juntas rígidas prevê rotações que podem causar colapso (ex: falha progressiva), permitindo otimização de materiais e segurança sísmica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.6.3.2"
                            ]
                          },
                          {
                            "id": "10.1.3.6.3.4",
                            "name": "Verificar equilíbrio nodal em pórticos",
                            "description": "Verificar o equilíbrio de forças e momentos nos nós de uma estrutura de pórtico após a solução, garantindo consistência entre elementos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar nós e coletar dados iniciais do modelo",
                                  "subSteps": [
                                    "Liste todos os nós da estrutura de pórtico e seus graus de liberdade (ex: UX, UY, RZ para 2D).",
                                    "Identifique elementos conectados a cada nó (barras, vigas).",
                                    "Registre cargas nodais externas aplicadas em cada nó.",
                                    "Extraia deslocamentos e forças nodais da solução do método dos elementos finitos.",
                                    "Anote condições de contorno (restritas ou livres)."
                                  ],
                                  "verification": "Confirme que todos os nós estão listados com elementos conectados e cargas anotadas em uma tabela organizada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Resultados da análise EF (vetores de deslocamento e força), diagrama da estrutura, planilha ou papel para tabela"
                                  ],
                                  "tips": "Comece pelos nós internos livres, pois eles devem ter equilíbrio perfeito sem cargas externas.",
                                  "learningObjective": "Entender a topologia nodal e preparar dados para verificação de equilíbrio.",
                                  "commonMistakes": [
                                    "Esquecer graus de liberdade rotacionais em pórticos",
                                    "Ignorar cargas distribuídas convertidas para nodais",
                                    "Confundir nós livres com suportados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Extrair forças nodais de cada elemento conectado",
                                  "subSteps": [
                                    "Para cada elemento conectado ao nó, calcule forças nodais usando a matriz de rigidez e deslocamentos (F = K * u).",
                                    "Separe forças axiais, cisalhantes e momentos para barras e vigas.",
                                    "Atribua forças ao nó local correto (início ou fim do elemento).",
                                    "Transforme forças locais para globais se necessário (para orientação não alinhada).",
                                    "Some contribuições de todos elementos no nó."
                                  ],
                                  "verification": "Verifique se as forças extraídas de elementos adjacentes somam corretamente nos dois nós do elemento.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Matrizes de rigidez elementares, vetor de deslocamentos globais, calculadora ou software como MATLAB/Excel"
                                  ],
                                  "tips": "Use convenções de sinal consistentes: positivo para tração, anti-horário para momentos.",
                                  "learningObjective": "Calcular e alocar forças nodais elementares corretamente.",
                                  "commonMistakes": [
                                    "Erro na transformação local-global",
                                    "Inversão de sinais em forças reativas",
                                    "Esquecer acoplamento de rotações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar soma vetorial de forças e momentos por nó",
                                  "subSteps": [
                                    "Para cada direção (X, Y, Z ou RX, RY, RZ), some forças/momentes internas de elementos.",
                                    "Subtraia cargas externas nodais da soma.",
                                    "Para nós suportados, compare soma com reações calculadas.",
                                    "Calcule o resíduo de equilíbrio (deve ser próximo de zero, tolerância 1e-6).",
                                    "Registre somas em tabela por nó."
                                  ],
                                  "verification": "Resíduos de equilíbrio < 1% do valor máximo de força no modelo para todos nós livres.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de forças nodais por nó, software de vetores ou planilha para somas"
                                  ],
                                  "tips": "Vetores devem fechar: soma Fx=0, Fy=0, Mz=0 em 2D para equilíbrio estático.",
                                  "learningObjective": "Aplicar princípios de equilíbrio estático nodal.",
                                  "commonMistakes": [
                                    "Soma escalar em vez de vetorial",
                                    "Ignorar momentos em nós com rotações livres",
                                    "Não considerar unidades consistentes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar equilíbrio global e documentar resultados",
                                  "subSteps": [
                                    "Verifique equilíbrio global: soma total de reações = soma total de cargas.",
                                    "Analise discrepâncias: identifique nós com resíduos altos e investigue causas.",
                                    "Compare com verificação manual para modelo simples.",
                                    "Gere relatório com tabelas de resíduos por nó.",
                                    "Confirme consistência entre elementos (força em um nó = reação no outro)."
                                  ],
                                  "verification": "Relatório final mostra todos resíduos dentro da tolerância e equilíbrio global satisfeito.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Relatório template, gráfico de resíduos por nó"
                                  ],
                                  "tips": "Resíduos altos indicam erro na montagem da matriz global ou condições de contorno.",
                                  "learningObjective": "Interpretar resultados e diagnosticar erros na análise EF.",
                                  "commonMistakes": [
                                    "Não verificar equilíbrio global",
                                    "Aceitar resíduos sem investigar",
                                    "Esquecer documentação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um pórtico portal 2D simples com 3 nós (2 fixos na base, 1 no topo), carga vertical de 10 kN no nó central. Após solução EF, no nó topo: soma Fy de vigas esquerda/direita = -5 kN cada + carga externa 10 kN = resíduo 0; Mz soma = 0. Verifique todos nós para confirmar.",
                              "finalVerifications": [
                                "Soma de forças em X, Y e momentos em Z é zero em todos nós livres (resíduo < 1e-6).",
                                "Reações em nós suportados igualam soma de forças internas opostas.",
                                "Equilíbrio global: soma reações = soma cargas aplicadas.",
                                "Consistência elementar: forças em extremidades opostas se equilibram.",
                                "Nenhum resíduo anômalo (>1% força máx.) sem explicação.",
                                "Documentação completa com tabelas e gráficos de resíduos."
                              ],
                              "assessmentCriteria": [
                                "Precisão das somas nodais (erro < 0.1%).",
                                "Correta identificação e tratamento de graus de liberdade.",
                                "Uso consistente de convenções de sinal e transformações.",
                                "Análise e explicação de qualquer discrepância.",
                                "Relatório claro com verificações finais e global.",
                                "Eficiência: tempo dentro do estimado sem erros graves."
                              ],
                              "crossCurricularConnections": [
                                "Mecânica dos Sólidos: Princípios de equilíbrio estático.",
                                "Matemática: Álgebra linear (matrizes K*e u).",
                                "Programação: Implementação em Python/MATLAB para automação.",
                                "Física: Estática de estruturas rígidas.",
                                "Engenharia Civil: Verificação em softwares como SAP2000."
                              ],
                              "realWorldApplication": "Em projetos de edifícios e pontes, engenheiros usam verificação nodal para validar modelos EF em softwares como ANSYS, detectando erros antes de dimensionar seções e evitar colapsos estruturais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.6.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.4",
                "name": "Problemas 2D",
                "description": "Elemento triangular e axissimétrico, elementos isoparamétricos como quadrilátero de 4 nós com integração numérica, e elementos de placa em flexão.",
                "totalSkills": 47,
                "atomicTopics": [
                  {
                    "id": "10.1.4.1",
                    "name": "Elemento Triangular em Problemas 2D",
                    "description": "Formulação e aplicação do elemento triangular para análise de tensões e deformações em problemas bidimensionais.",
                    "individualConcepts": [
                      {
                        "id": "34.2.1.1",
                        "name": "Geometria e Funções de Interpolação do Elemento Triangular",
                        "description": "Definição da geometria do elemento triangular de três nós (CST - Constant Strain Triangle) em problemas 2D, incluindo coordenadas nodais e derivação das funções de forma lineares em coordenadas naturais e cartesianas.",
                        "specificSkills": [
                          {
                            "id": "34.2.1.1.1",
                            "name": "Identificar a geometria do elemento triangular CST",
                            "description": "Reconhecer e descrever os três nós do elemento triangular, suas coordenadas (x_i, y_i) e a representação em espaço local e global para problemas de tensão plana.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Conceituar o elemento triangular CST",
                                  "subSteps": [
                                    "Estude a definição de CST (Constant Strain Triangle) como um elemento finito com três nós.",
                                    "Identifique que é usado em problemas 2D de tensão plana.",
                                    "Revise os princípios básicos dos Elementos Finitos (MEF).",
                                    "Anote as características principais: tensão constante dentro do elemento.",
                                    "Compare com outros elementos triangulares (LST, etc.)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que é CST e suas aplicações principais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Livro de Elementos Finitos",
                                    "Notas de aula",
                                    "Vídeo introdutório sobre MEF"
                                  ],
                                  "tips": "Comece com uma visão geral para contextualizar; evite pular para fórmulas.",
                                  "learningObjective": "Compreender o conceito fundamental do elemento CST em MEF 2D.",
                                  "commonMistakes": [
                                    "Confundir CST com elementos de tensão linear (LST)",
                                    "Ignorar o contexto de tensão plana"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar os três nós e coordenadas globais",
                                  "subSteps": [
                                    "Desenhe um triângulo genérico e label os nós como 1 (x1,y1), 2 (x2,y2), 3 (x3,y3).",
                                    "Liste as coordenadas globais para cada nó.",
                                    "Verifique se o triângulo não é degenerado (área > 0).",
                                    "Calcule a área usando fórmula de Heron ou determinante.",
                                    "Registre as posições em um diagrama."
                                  ],
                                  "verification": "Desenhe e label corretamente os nós com coordenadas em um papel ou software.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis",
                                    "Calculadora",
                                    "Software como GeoGebra"
                                  ],
                                  "tips": "Use coordenadas simples como (0,0), (1,0), (0,1) para prática inicial.",
                                  "learningObjective": "Reconhecer e anotar precisamente os nós e coordenadas no espaço global.",
                                  "commonMistakes": [
                                    "Rotular nós incorretamente",
                                    "Usar coordenadas colineares levando a área zero"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever a geometria no espaço global",
                                  "subSteps": [
                                    "Explique o espaço global como o sistema de coordenadas reais (x,y).",
                                    "Descreva como as coordenadas dos nós definem a geometria do elemento.",
                                    "Calcule comprimentos dos lados e ângulos se necessário.",
                                    "Relacione com a malha finita geral.",
                                    "Identifique propriedades como isócrono ou escaleno."
                                  ],
                                  "verification": "Forneça uma descrição escrita da geometria global de um triângulo exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de exercícios",
                                    "Calculadora científica",
                                    "Tabela de propriedades geométricas"
                                  ],
                                  "tips": "Visualize em 3D se possível para melhor compreensão, mas foque em 2D.",
                                  "learningObjective": "Descrever com precisão a representação geométrica no espaço global.",
                                  "commonMistakes": [
                                    "Confundir global com local",
                                    "Omitir verificação de validade geométrica"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Introduzir representação no espaço local",
                                  "subSteps": [
                                    "Aprenda coordenadas locais (ξ, η) para nós: nó1 (0,0), nó2 (1,0), nó3 (0,1).",
                                    "Entenda a transformação isoparamétrica de global para local.",
                                    "Descreva funções de interpolação N1=1-ξ-η, N2=ξ, N3=η.",
                                    "Aplique em um exemplo numérico.",
                                    "Compare espaços global e local."
                                  ],
                                  "verification": "Transforme coordenadas globais de um exemplo para local e liste funções de forma.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel ou MATLAB para cálculos",
                                    "Diagrama de coordenadas locais",
                                    "Referência de MEF"
                                  ],
                                  "tips": "Pratique com triângulos equiláteros para simetria.",
                                  "learningObjective": "Dominar a geometria e representação no espaço local do CST.",
                                  "commonMistakes": [
                                    "Erros nos valores das funções de interpolação",
                                    "Inverter ξ e η"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um elemento CST com nós: 1-(0,0), 2-(4,0), 3-(1,3). No espaço global, calcule área=6; no local, nó1(0,0), nó2(1,0), nó3(0,1). Descreva completamente.",
                              "finalVerifications": [
                                "Liste corretamente os três nós e suas coordenadas globais.",
                                "Descreva a geometria no espaço global (lados, área).",
                                "Identifique posições no espaço local (ξ,η).",
                                "Escreva funções de interpolação para os nós.",
                                "Explique transformação global-local.",
                                "Verifique validade geométrica (não degenerado)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação dos nós e coordenadas (100% correto).",
                                "Descrição clara da geometria global e local.",
                                "Correta aplicação de funções de interpolação.",
                                "Compreensão da transformação isoparamétrica.",
                                "Ausência de erros comuns como colinearidade.",
                                "Capacidade de aplicar em exemplo prático."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Geometria analítica e coordenadas cartesianas.",
                                "Física: Mecânica dos sólidos e tensão plana.",
                                "Informática: Programação numérica em MEF (MATLAB/Python).",
                                "Desenho Técnico: Representação de malhas finitas.",
                                "Engenharia Civil: Análise de estruturas 2D."
                              ],
                              "realWorldApplication": "Em simulações de tensão em placas metálicas ou compostas usando software MEF como ANSYS, onde a geometria CST define a precisão da malha para prever falhas estruturais em aviões ou pontes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.2.1.1.2",
                            "name": "Derivar funções de forma lineares",
                            "description": "Calcular as funções de interpolação N_i = (a_i + b_i x + c_i y)/(2A) para deslocamentos u e v dentro do elemento triangular.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a geometria do elemento triangular",
                                  "subSteps": [
                                    "Identifique os três nós do triângulo com coordenadas (x1,y1), (x2,y2), (x3,y3).",
                                    "Calcule a área A do triângulo usando a fórmula A = (1/2)| (x1(y2 - y3) + x2(y3 - y1) + x3(y1 - y2)) |.",
                                    "Desenhe o triângulo e marque os nós para visualizar a interpolação linear dentro do elemento.",
                                    "Revise as propriedades das funções de forma: N_i = 1 no nó i e 0 nos outros nós.",
                                    "Confirme que a soma N1 + N2 + N3 = 1 em qualquer ponto interno."
                                  ],
                                  "verification": "Verifique se a área A foi calculada corretamente comparando com método alternativo (base x altura / 2).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora",
                                    "Software de desenho vetorial opcional (ex: GeoGebra)"
                                  ],
                                  "tips": "Sempre use coordenadas consistentes e verifique o sinal da área para orientação positiva.",
                                  "learningObjective": "Entender a base geométrica necessária para derivar funções de interpolação lineares.",
                                  "commonMistakes": "Esquecer o fator 1/2 na fórmula da área ou usar coordenadas erradas dos nós."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estabelecer o sistema de equações lineares",
                                  "subSteps": [
                                    "Assuma a forma geral da função de interpolação linear: N_i(x,y) = a_i + b_i x + c_i y.",
                                    "Aplique as condições de contorno: N_i(x_j, y_j) = δ_{ij} para j=1,2,3 (δ=1 se i=j, 0 caso contrário).",
                                    "Escreva o sistema de 3 equações para cada i: a_i + b_i x1 + c_i y1 = δ_{i1}, etc.",
                                    "Formule a matriz do sistema em termos das coordenadas dos nós.",
                                    "Identifique o denominador comum 2A na solução final."
                                  ],
                                  "verification": "Confira se o sistema resulta em N_i=1 no nó i e 0 nos outros por substituição direta.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Livro de Elementos Finitos (capítulo de elementos 2D)"
                                  ],
                                  "tips": "Anote as equações separadamente para cada nó para evitar confusão entre i e j.",
                                  "learningObjective": "Construir o sistema algébrico que define as funções de forma lineares.",
                                  "commonMistakes": "Confundir os índices i (função) e j (nó) ou inverter as condições de contorno."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver o sistema para obter coeficientes a_i, b_i, c_i",
                                  "subSteps": [
                                    "Resolva o sistema 3x3 usando eliminação de Gauss ou fórmula de Cramer.",
                                    "Derive explicitamente a_i = (x2 y3 - x3 y2 + (y2 - y3)x + (x3 - x2)y ) / (2A) para i=1, e аналогично para outros.",
                                    "Generalize para qualquer i: a_i = x_j y_k - x_k y_j (ciclicamente), b_i = y_j - y_k, c_i = x_k - x_j.",
                                    "Simplifique dividindo por 2A.",
                                    "Calcule numericamente para um triângulo exemplo para validar."
                                  ],
                                  "verification": "Substitua coeficientes de volta nas equações originais e confirme igualdade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora matricial ou MATLAB/MATHEMATICA",
                                    "Folha de exercícios"
                                  ],
                                  "tips": "Use notação cíclica (1-2-3, 2-3-1, 3-1-2) para evitar repetição de cálculos.",
                                  "learningObjective": "Calcular analiticamente os coeficientes das funções de interpolação.",
                                  "commonMistakes": "Erro nos sinais dos termos b_i e c_i devido a permutações incorretas dos nós."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Escrever as funções N_i e verificar propriedades",
                                  "subSteps": [
                                    "Escreva N_i = (a_i + b_i x + c_i y) / (2A) explicitamente para i=1,2,3.",
                                    "Verifique soma N1 + N2 + N3 = 1 derivando algebricamente.",
                                    "Confirme partição da unidade e interpolação nodal em pontos específicos.",
                                    "Teste em um ponto interno (ex: baricentro) para valores esperados (1/3 cada).",
                                    "Discuta aplicação para deslocamentos u = Σ N_i u_i, v = Σ N_i v_i."
                                  ],
                                  "verification": "Calcule N_i em baricentro e confirme ≈0.333 cada, soma=1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software simbólico (SymPy ou similar)",
                                    "Exemplo numérico impresso"
                                  ],
                                  "tips": "Aproveite simetria para verificar soma sem calcular tudo numericamente.",
                                  "learningObjective": "Finalizar a derivação e validar as funções de forma.",
                                  "commonMistakes": "Esquecer a normalização por 2A, levando a soma ≠1."
                                }
                              ],
                              "practicalExample": "Considere um triângulo com nós: (0,0), (1,0), (0,1). Área A=0.5. Para N1: a1=1, b1=0, c1=0? Não: resolva sistema. N1=(1 - x - y), N2=x, N3=y. Calcule coefs: para N1, a1=0, b1=-1, c1=-1, 2A=1, etc. Avalie em (0.3,0.3): N1=0.4, N2=0.3, N3=0.3.",
                              "finalVerifications": [
                                "N1 + N2 + N3 = 1 em qualquer (x,y) interno.",
                                "N_i(x_j,y_j) = 1 se i=j, 0 caso contrário.",
                                "Gradiente de N_i é constante (linear).",
                                "Área A calculada corretamente com sinal positivo.",
                                "Coeficientes a_i, b_i, c_i coincidem com fórmula cíclica.",
                                "Aplicação correta para u(x,y) = N1 u1 + N2 u2 + N3 u3."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação dos coeficientes a_i, b_i, c_i (erro <1%).",
                                "Correta formulação e resolução do sistema 3x3.",
                                "Validação numérica das propriedades em pelo menos 3 pontos.",
                                "Explicação clara da normalização por 2A.",
                                "Uso correto de notação cíclica para generalização.",
                                "Identificação de erros comuns e como evitá-los."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (sistemas de equações) e geometria analítica.",
                                "Programação: Implementação em código para MEF (Python/MATLAB).",
                                "Física: Interpolação de campos escalares/vetoriais em mecânica dos sólidos.",
                                "Computação Gráfica: Barycentric coordinates em renderização triangular."
                              ],
                              "realWorldApplication": "Em simulações de Elementos Finitos para análise de tensões em placas metálicas, fluxo de calor em painéis 2D ou deformações em estruturas aeronáuticas, onde funções lineares aproximam deslocamentos u,v dentro de malhas triangulares para prever falhas estruturais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "34.2.1.1.1"
                            ]
                          },
                          {
                            "id": "34.2.1.1.3",
                            "name": "Transformar coordenadas locais para globais",
                            "description": "Aplicar a transformação de coordenadas usando a matriz de rotação para alinhar o elemento com o sistema global em problemas 2D.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender coordenadas locais e globais no elemento triangular",
                                  "subSteps": [
                                    "Defina as coordenadas globais (x, y) dos três nós do triângulo no sistema global.",
                                    "Explique o sistema de coordenadas locais: tipicamente, nó 1 em (0,0), nó 2 em (l,0), nó 3 em posição inclinada.",
                                    "Identifique a necessidade de rotação devido à orientação do elemento no plano.",
                                    "Esboce o elemento rotacionado e marque os vetores locais.",
                                    "Liste as diferenças entre sistemas locais e globais."
                                  ],
                                  "verification": "Desenhe o diagrama do elemento com coordenadas locais e globais corretamente rotuladas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel quadriculado, lápis, calculadora",
                                  "tips": "Sempre comece visualizando o elemento para intuitar a rotação necessária.",
                                  "learningObjective": "Compreender a relação espacial entre coordenadas locais e globais em elementos finitos 2D.",
                                  "commonMistakes": "Confundir ordem dos nós ou assumir alinhamento axial sem rotação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular vetores de rotação e ângulo de rotação",
                                  "subSteps": [
                                    "Calcule o vetor do nó 1 para nó 2: (x2 - x1, y2 - y1) e normalize-o para obter o vetor unitário local ξ.",
                                    "Calcule o vetor perpendicular para η: rotacione ξ em 90 graus ( -y_ξ, x_ξ ) e normalize.",
                                    "Determine o ângulo θ de rotação comparando ξ local com eixo global X.",
                                    "Use fórmula cosθ = ξ_x / norma, senθ = ξ_y / norma.",
                                    "Verifique ortogonalidade: produto escalar ξ · η deve ser zero."
                                  ],
                                  "verification": "Confirme que os vetores unitários têm norma 1 e são ortogonais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora científica, software como MATLAB ou Python para vetores",
                                  "tips": "Use funções trigonométricas com precisão; evite arredondamentos prematuros.",
                                  "learningObjective": "Calcular vetores de base locais alinhados com o elemento.",
                                  "commonMistakes": "Erro no sinal da rotação perpendicular ou normalização incompleta."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e aplicar a matriz de rotação",
                                  "subSteps": [
                                    "Monte a matriz de rotação R = [[cosθ, -sinθ], [sinθ, cosθ]] para transformação local para global.",
                                    "Para um ponto local (ξ, η), aplique [x, y]^T = R * [ξ, η]^T + posição do nó de referência.",
                                    "Transforme as coordenadas dos nós para validar: elas devem coincidir com globais.",
                                    "Estenda para ponto arbitrário dentro do elemento.",
                                    "Implemente em fórmula matricial completa."
                                  ],
                                  "verification": "Transforme os nós locais e compare com coordenadas globais originais (erro < 1e-6).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha Excel ou script Python/MATLAB para multiplicação matricial",
                                  "tips": "Lembre-se: matriz de rotação é ortogonal, R^T * R = I.",
                                  "learningObjective": "Construir e aplicar matriz de transformação de coordenadas.",
                                  "commonMistakes": "Inverter seno e cosseno ou esquecer deslocamento do nó origem."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar transformação e integrar em interpolação",
                                  "subSteps": [
                                    "Use funções de interpolação N1, N2, N3 em coordenadas locais para u_local.",
                                    "Transforme gradientes: ∇u_global = J^{-T} * ∇u_local, onde J é Jacobiana.",
                                    "Calcule Jacobiana J baseada na matriz de transformação.",
                                    "Verifique consistência em um campo escalar simples.",
                                    "Teste com rotação de 45 graus para robustez."
                                  ],
                                  "verification": "Compute deslocamento em ponto gaussiano e confirme coerência global.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código FEM simples (ex: FEniCS ou código handmade)",
                                  "tips": "Integre com shape functions desde o início para contexto completo.",
                                  "learningObjective": "Integrar transformação em cálculo de derivadas para elementos finitos.",
                                  "commonMistakes": "Ignorar Jacobiana na transformação de gradientes."
                                }
                              ],
                              "practicalExample": "Considere um triângulo com nós globais: A(0,0), B(1,0), C(0.5, √3/2) rotacionado 30 graus. Calcule matriz R usando vetor AB normalizado, transforme ponto local (0.3, 0.2) para global e verifique.",
                              "finalVerifications": [
                                "Coordenadas dos nós transformadas coincidem com originais.",
                                "Vetores de base locais são unitários e ortogonais.",
                                "Transformação de gradiente preserva propriedades físicas.",
                                "Exemplo prático resolvido sem erros numéricos >1e-5.",
                                "Matriz R é ortogonal (R * R^T = I).",
                                "Aplicação em interpolação linear produz campo contínuo."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de ângulo e matriz (erro <0.01 rad).",
                                "Correta identificação de vetores locais vs globais.",
                                "Aplicação consistente em pontos arbitrários e nós.",
                                "Integração com funções de interpolação demonstrada.",
                                "Explicação clara de verificações e erros comuns evitados.",
                                "Tempo de execução dentro do estimado com qualidade."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: multiplicação matricial e propriedades ortogonais.",
                                "Cálculo: gradientes e Jacobianas em transformações.",
                                "Programação: implementação em Python/MATLAB para automação FEM.",
                                "Física: vetores e rotações em mecânica estrutural."
                              ],
                              "realWorldApplication": "Em simulações de análise estrutural por elementos finitos (ex: ANSYS), essa transformação permite montar matrizes de rigidez locais rotacionadas para malhas arbitrárias, essencial para projetos de pontes, aviões e carrocerias automotivas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.2.1.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "34.2.1.2",
                        "name": "Matriz de Deformação [B] e Matriz de Rigidez [K]",
                        "description": "Construção da matriz de deformação [B] a partir das derivadas das funções de forma e formulação da matriz de rigidez elementar [K] = ∫ [B]^T [D] [B] t dA para materiais isotrópicos em estado plano de tensão ou deformação.",
                        "specificSkills": [
                          {
                            "id": "34.2.1.2.1",
                            "name": "Construir a matriz de deformação [B]",
                            "description": "Derivar a matriz [B] (3x6) contendo as derivadas parciais das funções de forma (∂N_i/∂x, ∂N_i/∂y) para relacionar deformações {ε} = [B] {d_e}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os dados geométricos do elemento triangular",
                                  "subSteps": [
                                    "Identifique as coordenadas dos três nós do triângulo: (x1,y1), (x2,y2), (x3,y3).",
                                    "Calcule a área A do triângulo usando a fórmula A = (1/2)| (x1(y2 - y3) + x2(y3 - y1) + x3(y1 - y2)) |.",
                                    "Compute os coeficientes b_i e c_i para cada função de forma: b1 = y2 - y3, c1 = x3 - x2, etc., cíclico para i=1,2,3.",
                                    "Verifique se a área A é positiva e não zero para evitar elementos degenerados.",
                                    "Anote todos os valores em uma tabela organizada."
                                  ],
                                  "verification": "Confirme que b_i e c_i estão corretos comparando com a fórmula padrão e que A > 0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis ou software como MATLAB/Excel",
                                    "Coordenadas de exemplo do elemento"
                                  ],
                                  "tips": "Use convenção anti-horária para nós para garantir A positiva.",
                                  "learningObjective": "Entender a geometria base do elemento triangular e preparar coeficientes essenciais.",
                                  "commonMistakes": [
                                    "Erro no sinal da área (use valor absoluto)",
                                    "Confundir ordem dos nós (b1 = y2-y3, não y3-y2)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar as funções de forma N_i",
                                  "subSteps": [
                                    "Escreva as funções de forma lineares: N_i = (a_i + b_i x + c_i y)/(2A), onde a1 = x2 y3 - x3 y2, etc.",
                                    "Confirme que Σ N_i = 1 e N_i = 1 no nó i, 0 nos outros.",
                                    "Calcule as derivadas parciais: ∂N_i/∂x = b_i / (2A), ∂N_i/∂y = c_i / (2A). Note que são constantes!",
                                    "Liste ∂N1/∂x, ∂N1/∂y, ∂N2/∂x, etc., para todos i=1,2,3.",
                                    "Valide somando ∂N_i/∂x sobre i: deve ser zero (condição de rigidez)."
                                  ],
                                  "verification": "Verifique se as derivadas são constantes e se Σ ∂N_i/∂x = 0 e Σ ∂N_i/∂y = 0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Fórmulas de funções de forma impressas",
                                    "Calculadora"
                                  ],
                                  "tips": "Memorize que derivadas são constantes em elementos lineares, facilitando [B] constante.",
                                  "learningObjective": "Dominar derivação das funções de forma e suas derivadas parciais.",
                                  "commonMistakes": [
                                    "Esquecer o denominador 2A nas derivadas",
                                    "Erro nos coeficientes a_i, b_i, c_i"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Montar a matriz de deformação [B] (3x6)",
                                  "subSteps": [
                                    "Estruture [B] com 3 linhas (ε_x, ε_y, γ_xy) e 6 colunas (d1x, d1y, d2x, d2y, d3x, d3y).",
                                    "Preencha linha 1 (ε_x): [∂N1/∂x, 0, ∂N2/∂x, 0, ∂N3/∂x, 0].",
                                    "Preencha linha 2 (ε_y): [0, ∂N1/∂y, 0, ∂N2/∂y, 0, ∂N3/∂y].",
                                    "Preencha linha 3 (γ_xy): [∂N1/∂y, ∂N1/∂x, ∂N2/∂y, ∂N2/∂x, ∂N3/∂y, ∂N3/∂x].",
                                    "Escreva a matriz completa e verifique dimensões 3x6."
                                  ],
                                  "verification": "Multiplique [B] por vetor {d_e} unitário e confira se deformações fazem sentido geometricamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Matriz em branco 3x6",
                                    "Valores de derivadas do step 2"
                                  ],
                                  "tips": "Pense em [B] como operador que mapeia deslocamentos para deformações strain-displacement.",
                                  "learningObjective": "Construir corretamente a matriz [B] relacionando {ε} = [B]{d_e}.",
                                  "commonMistakes": [
                                    "Trocar posições em γ_xy (y antes de x)",
                                    "Esquecer zeros nas linhas 1 e 2"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e interpretar a matriz [B]",
                                  "subSteps": [
                                    "Calcule o determinante ou rank de [B] para checar singularidade (deve ser rank 3).",
                                    "Aplique a uma deformação conhecida (ex: tensão pura) e veja se {d_e} = [B]^{-1}{ε} é coerente.",
                                    "Discuta como [B] é usada em [K] = ∫ [B]^T [D] [B] dV.",
                                    "Compare com software FEA (ex: ANSYS) para um elemento simples.",
                                    "Documente a matriz final com interpretação física."
                                  ],
                                  "verification": "Simule um caso simples e confirme deformações esperadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software FEA opcional como FreeFEM ou código Python simples"
                                  ],
                                  "tips": "Teste com triângulo equilátero para simetria.",
                                  "learningObjective": "Validar [B] e entender seu papel na formulação FEM.",
                                  "commonMistakes": [
                                    "Ignorar isoparamétrico vs. constante",
                                    "Não verificar condições de compatibilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Para triângulo com nós (0,0), (1,0), (0,1): A=0.5, b1=1, c1=-1, b2=-1, c2=0, b3=0, c3=1. Derivadas: ∂N1/∂x=1, ∂N1/∂y=-1, etc. [B] = [[1,0,-1,0,0,0], [0,-1,0,0,0,1], [-1,1,0,-1,1,0]].",
                              "finalVerifications": [
                                "Dimensões de [B] são exatamente 3x6.",
                                "Σ colunas ímpares (∂N_i/∂x) = 0 e pares (∂N_i/∂y) = 0.",
                                "Linha 3 tem padrão alternado ∂N/∂y e ∂N/∂x.",
                                "Deformações calculadas para deslocamentos unitários são consistentes.",
                                "Matriz coincide com implementação em código FEM simples.",
                                "Área A usada corretamente em todas derivadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos coeficientes b_i, c_i (erro <1%).",
                                "Correta disposição de zeros e derivadas em [B].",
                                "Validação matemática (somas zero, rank 3).",
                                "Interpretação física clara.",
                                "Tempo de execução dentro do estimado com substeps completos.",
                                "Ausência de erros comuns listados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo vetorial e matrizes jacobianas.",
                                "Programação: Implementação em Python/MATLAB para automação.",
                                "Física: Relação strain-displacement em mecânica dos sólidos.",
                                "Engenharia Civil: Análise de estruturas planas.",
                                "Computação Científica: Integração numérica em FEM."
                              ],
                              "realWorldApplication": "Na simulação FEM de placas e cascas em software como ANSYS ou Abaqus, [B] é essencial para prever deformações em pontes, aviões ou carrocerias automotivas sob carga, otimizando designs para segurança e eficiência."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.2.1.1.3"
                            ]
                          },
                          {
                            "id": "34.2.1.2.2",
                            "name": "Calcular a matriz constitutiva [D]",
                            "description": "Definir a matriz [D] para estado plano de tensão (E/(1-ν^2)) e plano de deformação, incorporando módulo de elasticidade E e coeficiente de Poisson ν.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Estados Planos e Parâmetros Materiais",
                                  "subSteps": [
                                    "Defina estado plano de tensão: σ_z = τ_xz = τ_yz = 0, deformações ε_z ≠ 0.",
                                    "Defina estado plano de deformação: ε_z = γ_xz = γ_yz = 0, tensões σ_z ≠ 0.",
                                    "Identifique parâmetros: módulo de elasticidade E (rigidez) e coeficiente de Poisson ν (razão deformações laterais).",
                                    "Escreva a relação constitutiva geral σ = D ε para comportamento linear elástico isotrópico.",
                                    "Liste valores típicos: E aço ≈ 200 GPa, ν ≈ 0.3."
                                  ],
                                  "verification": "Resuma definições em um parágrafo e liste E, ν com unidades corretas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Elementos Finitos (ex: Bathe), tabela de propriedades materiais.",
                                  "tips": "Use diagramas esquemáticos para visualizar estados planos.",
                                  "learningObjective": "Compreender diferenças entre plane stress e plane strain e papéis de E e ν.",
                                  "commonMistakes": "Confundir plane stress (tensão zero) com plane strain (deformação zero)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar e Construir Matriz [D] para Estado Plano de Tensão",
                                  "subSteps": [
                                    "Parta da lei de Hooke 3D: ε_x = (1/E)(σ_x - ν(σ_y + σ_z)), etc.",
                                    "Imponha σ_z = 0, resolva para σ_x, σ_y, τ_xy em termos de ε_x, ε_y, γ_xy.",
                                    "Multiplique por fator E/(1-ν²): obtenha [D] = (E/(1-ν²)) [[1, ν, 0], [ν, 1, 0], [0, 0, (1-ν)/2]].",
                                    "Escreva matriz explicitamente para valores exemplo: E=200 GPa, ν=0.3.",
                                    "Verifique simetria e positivo-definitude (autovalores >0)."
                                  ],
                                  "verification": "Calcule [D] numérica e confira D11 = E/(1-ν²) ≈ 231 GPa.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de cálculo ou MATLAB para matriz, calculadora simbólica.",
                                  "tips": "Lembre: fator (1-ν)/2 é para cisalhamento G = E/2(1+ν).",
                                  "learningObjective": "Derivar [D] para plane stress incorporando E e ν corretamente.",
                                  "commonMistakes": "Esquecer fator 1/(1-ν²) ou usar (1-ν)/2 errado no cisalhamento."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar e Construir Matriz [D] para Estado Plano de Deformação",
                                  "subSteps": [
                                    "Parta da lei de Hooke 3D novamente.",
                                    "Imponha ε_z = 0, resolva para σ_x, σ_y, τ_xy em termos de ε_x, ε_y, γ_xy.",
                                    "Multiplique por fator E/((1+ν)(1-2ν)): [D] = (E/((1+ν)(1-2ν))) [[1-ν, ν, 0], [ν, 1-ν, 0], [0, 0, (1-2ν)/2]].",
                                    "Calcule numericamente para E=200 GPa, ν=0.3: D11 ≈ 306 GPa.",
                                    "Compare com plane stress: note rigidez maior devido a restrição ε_z=0."
                                  ],
                                  "verification": "Confirme D11 = (E(1-ν))/((1+ν)(1-2ν)) e simetria.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Mesmo que step 2, mais software para autovalores.",
                                  "tips": "Fator (1-2ν)/2 para cisalhamento vem de G ajustado.",
                                  "learningObjective": "Derivar [D] para plane strain e contrastar com plane stress.",
                                  "commonMistakes": "Inverter fatores ou usar ν em vez de 1-ν nos diagonais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Aplicar Matrizes [D] em Contexto de Elementos Finitos",
                                  "subSteps": [
                                    "Integre [D] na matriz de rigidez [K] = ∫ [B]^T [D] [B] dV.",
                                    "Teste com deformação unitária: ε = [1,0,0]^T, verifique σ = primeira coluna de [D].",
                                    "Compare [D]_stress vs [D]_strain para mesmo material.",
                                    "Discuta limites: ν → 0.5 (incompressível), det([D]) → ∞.",
                                    "Documente em tabela: elementos D11, D12, D33 para ambos casos."
                                  ],
                                  "verification": "Tabela completa com valores numéricos e simbólicos corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software EF (ex: ANSYS tutorial), planilha Excel.",
                                  "tips": "Sempre normalize unidades: E em Pa, ν adimensional.",
                                  "learningObjective": "Aplicar [D] em EF e validar consistência.",
                                  "commonMistakes": "Ignorar dependência ν na diagonal cisalhante."
                                }
                              ],
                              "practicalExample": "Para aço (E=200 GPa, ν=0.3): Plane stress [D] = 2.31e11 * [[1, 0.3, 0], [0.3, 1, 0], [0, 0, 0.35]] Pa. Plane strain [D] = 3.077e11 * [[0.7, 0.3, 0], [0.3, 0.7, 0], [0, 0, 0.35]] Pa. Use em elemento triangular com ε=[0.001, 0.0005, 0.002]^T para calcular σ.",
                              "finalVerifications": [
                                "Matriz [D] é 3x3 simétrica para ambos casos.",
                                "D11 = E/(1-ν²) para plane stress; E(1-ν)/((1+ν)(1-2ν)) para plane strain.",
                                "Coeficiente cisalhamento D33 = G = E/2(1+ν) ajustado corretamente.",
                                "Para ν=0, [D] reduz a diagonal E em ambos.",
                                "Valores numéricos batem com software padrão (ex: ABAQUS).",
                                "Determinante positivo confirma estabilidade."
                              ],
                              "assessmentCriteria": [
                                "Correção simbólica das fórmulas (100% match).",
                                "Cálculos numéricos precisos (erro <0.1%).",
                                "Explicação clara das derivações passo-a-passo.",
                                "Identificação correta de diferenças entre casos.",
                                "Aplicação válida em exemplo EF.",
                                "Ausência de erros unitários ou dimensionais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes simétricas, autovalores).",
                                "Física: Mecânica dos sólidos (lei de Hooke isotrópica).",
                                "Computação: Implementação em código (Python/NumPy para [D]ε).",
                                "Materiais: Propriedades E, ν de tabelas experimentais."
                              ],
                              "realWorldApplication": "Em análise EF de placas aeronáuticas finas (plane stress) para prever tensões em asas; ou túneis/barragens longas (plane strain) para segurança estrutural, integrando [D] na matriz [K] para simulações precisas de deformação sob carga."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "34.2.1.2.1"
                            ]
                          },
                          {
                            "id": "34.2.1.2.3",
                            "name": "Montar a matriz de rigidez elementar [K]",
                            "description": "Realizar a integração analítica de [K_e] = t A [B]^T [D] [B] para o elemento triangular, considerando espessura t e área A.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Confirmar a matriz de deformação [B] para o elemento triangular",
                                  "subSteps": [
                                    "Identificar as coordenadas dos três nós do triângulo (xi,yi), (xj,yj), (xk,yk).",
                                    "Calcular a área A do triângulo usando fórmula A = (1/2)| (xi(yj - yk) + xj(yk - yi) + xk(yi - yj)) |.",
                                    "Determinar os coeficientes b_i = yj - yk, c_i = xk - xj (e cíclicos para outros nós).",
                                    "Montar a matriz [B] 3x6: [B] = [ b_i/A  0    b_j/A  0    b_k/A  0   ;  0   c_i/A  0   c_j/A  0   c_k/A ; c_i/A b_i/A c_j/A b_j/A c_k/A b_k/A ].",
                                    "Verificar se [B] está correta comparando com definições padrão para CST."
                                  ],
                                  "verification": "A matriz [B] deve ser 3x6, com linhas somando a zero para equilíbrio rígido.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora",
                                    "Livro de Elementos Finitos (ex: Bathe ou Zienkiewicz)"
                                  ],
                                  "tips": "Use convenção de nós i-j-k no sentido anti-horário para sinal positivo da área.",
                                  "learningObjective": "Entender como as geometrias dos nós definem a matriz de deformação constante.",
                                  "commonMistakes": "Erros no cálculo da área (sinal errado) ou inversão de b e c coeficientes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a matriz de constituição [D] para o material isotrópico",
                                  "subSteps": [
                                    "Obter propriedades do material: módulo de elasticidade E e coeficiente de Poisson ν.",
                                    "Calcular espessura t e confirmar plano tensão ou deformação.",
                                    "Montar [D] 3x3 para plano tensão: [D] = (E/(1-ν²)) * [1 ν 0; ν 1 0; 0 0 (1-ν)/2].",
                                    "Verificar unidades consistentes (E em Pa, t em m).",
                                    "Anotar [D] explicitamente para o problema específico."
                                  ],
                                  "verification": "[D] deve ser simétrica e positiva definida; trace([D]) > 0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela de propriedades de materiais",
                                    "Calculadora"
                                  ],
                                  "tips": "Para plano deformação, use fórmula alternativa com (1+ν)(1-2ν).",
                                  "learningObjective": "Relacionar propriedades macroscópicas do material à resposta linear elástica.",
                                  "commonMistakes": "Confundir plano tensão com plano deformação ou usar ν incorreto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o produto matricial [B]^T [D] [B]",
                                  "subSteps": [
                                    "Calcular primeiro [D] [B], resultando em matriz 3x6.",
                                    "Em seguida, multiplicar [B]^T (6x3) pelo resultado anterior para obter 6x6.",
                                    "Realizar multiplicações elemento a elemento, agrupando por graus de liberdade (ux,uy por nó).",
                                    "Verificar simetria da matriz resultante.",
                                    "Armazenar como matriz intermediária [temp] = [B]^T [D] [B]."
                                  ],
                                  "verification": "A matriz 6x6 deve ser simétrica e ter zeros nos acoplamentos ux-uy incorretos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Calculadora matricial ou software como MATLAB/Octave",
                                    "Papel quadriculado"
                                  ],
                                  "tips": "Explore a estrutura esparsa de [B] para simplificar cálculos manuais.",
                                  "learningObjective": "Dominar multiplicação matricial eficiente em contexto de EF.",
                                  "commonMistakes": "Erros de transposição ou índices errados nos nós."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Multiplicar pela espessura t e área A para obter [K_e]",
                                  "subSteps": [
                                    "Multiplicar a matriz [temp] pelo escalar (t * A).",
                                    "Confirmar unidades: [K] em N/m (força por deslocamento).",
                                    "Arredondar valores numéricos com precisão adequada (ex: 4 casas decimais).",
                                    "Escrever [K_e] final 6x6 explicitamente.",
                                    "Verificar diagonal dominante e positivos."
                                  ],
                                  "verification": "[K_e] simétrica, energia de deformação positiva para vetores modais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora"
                                  ],
                                  "tips": "t*A é o 'volume' efetivo do elemento em 2D.",
                                  "learningObjective": "Compreender o papel geométrico e físico do fator t A.",
                                  "commonMistakes": "Esquecer o fator t ou usar A errada."
                                }
                              ],
                              "practicalExample": "Para triângulo com nós (0,0), (1,0), (0,1); A=0.5; t=0.01m; E=200GPa, ν=0.3. [B] resulta em valores específicos; [K_e] terá elementos como K11 ≈ 2.31e6 N/m após cálculos.",
                              "finalVerifications": [
                                "Matriz [K_e] é 6x6 simétrica.",
                                "Elementos diagonais positivos e maiores que off-diagonais.",
                                "Soma das linhas/ colunas por nó consistente com rigidez.",
                                "Teste de patch: soma de [K_e] sobre malha dá rigidez global correta.",
                                "Energia 1/2 u^T K u >0 para u não-rígido.",
                                "Comparar com software FEA (ex: ANSYS) para mesmo elemento."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos coeficientes b,c e A (>99%).",
                                "Correção da montagem de [B] e [D] conforme teoria CST.",
                                "Execução correta das multiplicações matriciais sem erros algébricos.",
                                "Verificação de simetria e propriedades físicas de [K_e].",
                                "Eficiência no uso de tempo e recursos.",
                                "Capacidade de explicar cada passo oralmente."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (multiplicação e propriedades de matrizes).",
                                "Física: Mecânica dos sólidos contínuos e lei de Hooke.",
                                "Computação: Implementação numérica em Python/MATLAB para automação.",
                                "Engenharia de Materiais: Seleção de E e ν baseada em dados experimentais."
                              ],
                              "realWorldApplication": "Em software de análise estrutural como ANSYS ou Abaqus, montar [K_e] é o cerne do método dos elementos finitos para simular tensões em placas, cascos de aviões, carrocerias de veículos ou fundações sob carga."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.2.1.2.2"
                            ]
                          },
                          {
                            "id": "34.2.1.2.4",
                            "name": "Incorporar condições de contorno no elemento",
                            "description": "Aplicar penalidades ou remoção de graus de liberdade para suportar deslocamentos impostos no elemento triangular.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar Graus de Liberdade e Condições de Contorno no Elemento Triangular",
                                  "subSteps": [
                                    "Revise a topologia do elemento triangular constante de tensão (CST): 3 nós com 2 graus de liberdade por nó (ux, uy), totalizando 6 DOFs.",
                                    "Desenhe o elemento e label os nós (1, 2, 3) e DOFs correspondentes (u1x, u1y, u2x, u2y, u3x, u3y).",
                                    "Analise o problema para listar condições de contorno: identifique deslocamentos impostos (zero ou não-zero) em cada DOF.",
                                    "Classifique CCs: essenciais (deslocamentos impostos) vs. naturais (forças).",
                                    "Documente em uma tabela: DOF, condição, valor imposto."
                                  ],
                                  "verification": "Tabela completa de DOFs e CCs sem erros de numeração ou classificação.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Diagrama do elemento triangular",
                                    "Notas de aula sobre MEF 2D",
                                    "Folha de cálculo ou software como MATLAB/Excel"
                                  ],
                                  "tips": "Sempre desenhe o elemento para visualizar nós e direções de deslocamento.",
                                  "learningObjective": "Compreender e mapear precisamente os DOFs e CCs em um elemento triangular.",
                                  "commonMistakes": [
                                    "Confundir ordem dos DOFs (ex: u1x antes de u1y)",
                                    "Ignorar direções x/y",
                                    "Esquecer CCs em múltiplos nós"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar o Método da Penalidade para Deslocamentos Impostos",
                                  "subSteps": [
                                    "Escolha um fator de penalidade α grande (ex: 10^10 vezes o módulo de elasticidade E).",
                                    "Para DOF com deslocamento imposto d_i = 0: adicione α à diagonal K_ii correspondente.",
                                    "Para DOF com d_i ≠ 0: adicione α à K_ii e inclua termo α*d_i no vetor de forças F_i.",
                                    "Modifique a matriz [K] 6x6 local: aplique a cada DOF restrito.",
                                    "Calcule a matriz [K] penalizada e vetor F modificado manualmente ou via código."
                                  ],
                                  "verification": "Matriz [K] penalizada tem valores α nas diagonais restritas e F atualizado corretamente.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Matriz [K] original do elemento",
                                    "Calculadora ou MATLAB/Python para matrizes",
                                    "Exemplo numérico resolvido"
                                  ],
                                  "tips": "Teste α com valores progressivamente maiores para convergência numérica.",
                                  "learningObjective": "Implementar penalidades para modificar [K] e F em CCs essenciais.",
                                  "commonMistakes": [
                                    "Usar α muito pequeno (instabilidade)",
                                    "Esquecer termo α*d_i em F para d_i ≠ 0",
                                    "Modificar linhas/colunas erradas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Remoção de Graus de Liberdade",
                                  "subSteps": [
                                    "Para DOFs com d_i = 0: remova linha e coluna correspondente da [K] e F.",
                                    "Para d_i ≠ 0: mova DOF para lado direito (F_j -= K_ji * d_i para outros j), então remova linha/coluna i.",
                                    "Reorganize a matriz reduzida: renumere DOFs ativos mantendo ordem.",
                                    "Aplique sequencialmente a todos DOFs restritos, obtendo [K]_red e F_red.",
                                    "Verifique dimensões: se 2 DOFs fixos, [K]_red é 4x4."
                                  ],
                                  "verification": "Matriz reduzida [K]_red é simétrica positiva definida e dimensões corretas.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "[K] original",
                                    "Software de álgebra linear (MATLAB, NumPy)",
                                    "Papel para rastrear remoções"
                                  ],
                                  "tips": "Faça remoções uma por uma e verifique simetria após cada.",
                                  "learningObjective": "Reduzir sistema eliminando DOFs restritos manualmente.",
                                  "commonMistakes": [
                                    "Erro na subtração K_ji * d_i",
                                    "Perder simetria da matriz",
                                    "Renumerar DOFs incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Comparar os Dois Métodos na Matriz de Rigidez Modificada",
                                  "subSteps": [
                                    "Resolva {u_red} = [K]_red^{-1} F_red para DOFs livres.",
                                    "Compare solução com penalidade: resolva sistema completo e isole DOFs livres.",
                                    "Calcule erro relativo entre métodos (deve ser <1%).",
                                    "Analise condicionamento numérico de [K] penalizada (evite α excessivo).",
                                    "Documente diferenças e escolha método baseado em precisão/estabilidade."
                                  ],
                                  "verification": "Soluções coincidem dentro de tolerância 10^{-6} e relatório de comparação completo.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Código para inversão/solução de sistemas",
                                    "Gráficos de deslocamentos",
                                    "Referência analítica se disponível"
                                  ],
                                  "tips": "Use solvers robustos como lu() em MATLAB para sistemas grandes.",
                                  "learningObjective": "Validar implementação comparando métodos e avaliando precisão.",
                                  "commonMistakes": [
                                    "Ignorar ill-conditioning em penalidade",
                                    "Comparar DOFs errados",
                                    "Tolerância muito frouxa"
                                  ]
                                }
                              ],
                              "practicalExample": "Elemento triangular CST com nós (1: (0,0), 2: (1,0), 3: (0,1)); E=210e9 Pa, ν=0.3, t=1m. [K] original calculada. CCs: nó 1 fixo (u1x=u1y=0), nó 2: u2x=0.01m. Aplique penalidade (α=1e15) → K11,K22 +=α, F1=F2=0; ou remova DOFs 1 e 2 → resolva para u2y,u3x,u3y. Solução: deslocamentos livres ≈ [0.0045, 0.0021, 0.0032]m.",
                              "finalVerifications": [
                                "Matriz [K] modificada mantém simetria e positivos definitos.",
                                "Deslocamentos impostos são satisfeitos (erro <10^{-8}).",
                                "Soluções de penalidade e remoção coincidem nos DOFs livres.",
                                "Vetores de forças atualizados corretamente para d_i ≠ 0.",
                                "Condicionamento numérico de [K] penalizada <10^12.",
                                "Dimensões da matriz reduzida corretas (6 - #DOFs restritos)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de DOFs e CCs (100% correto).",
                                "Implementação correta de penalidade (α adequada, termos em K e F).",
                                "Remoção de DOFs sem perda de simetria ou erros aritméticos.",
                                "Comparação quantitativa entre métodos (erro relativo reportado).",
                                "Verificação de condicionamento e estabilidade numérica.",
                                "Clareza na documentação e desenhos do elemento."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (modificação de matrizes, condicionamento).",
                                "Programação: Implementação em Python/MATLAB para automação de MEF.",
                                "Física: Mecânica dos sólidos (equilíbrio estático, deformações).",
                                "Engenharia Civil: Análise de estruturas 2D como placas.",
                                "Computação Científica: Solvers numéricos e análise de erros."
                              ],
                              "realWorldApplication": "Em simulações FEM de estruturas aeronáuticas ou civis (ex: análise de tensão em asas de avião ou vigas de ponte), onde suportes fixos e deslocamentos impostos (dilatações térmicas) são incorporados na matriz global via montagem de elementos locais modificados, garantindo precisão em softwares como ANSYS ou Abaqus."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "34.2.1.2.3"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "34.2.1.3",
                        "name": "Análise de Tensões e Deformações e Aplicação Global",
                        "description": "Avaliação pós-processamento de tensões e deformações a partir dos deslocamentos nodais e montagem das matrizes globais para malhas compostas por elementos triangulares em problemas bidimensionais.",
                        "specificSkills": [
                          {
                            "id": "34.2.1.3.1",
                            "name": "Calcular tensões e deformações elementares",
                            "description": "Usar {σ} = [D] {ε} = [D] [B] {d_e} para obter tensões σ_x, σ_y, τ_xy constantes no elemento CST.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar dados do elemento CST: geometria, materiais e deslocamentos",
                                  "subSteps": [
                                    "Identifique as coordenadas dos três nós do triângulo (x1,y1), (x2,y2), (x3,y3).",
                                    "Determine as propriedades do material: módulo de elasticidade E, coeficiente de Poisson ν, e espessura t (para tensão plana).",
                                    "Obtenha os deslocamentos nodais {d_e} = [u1, v1, u2, v2, u3, v3]^T de uma análise global prévia.",
                                    "Calcule o Jacobiano ou área do elemento para validar a geometria (A = (1/2)| (x1(y2-y3) + x2(y3-y1) + x3(y1-y2)) |).",
                                    "Monte a matriz de constituição [D] para tensão plana: [D] = (E/(1-ν²)) * [[1, ν, 0], [ν, 1, 0], [0, 0, (1-ν)/2]]."
                                  ],
                                  "verification": "Verifique se as coordenadas formam um triângulo válido (área > 0) e [D] tem valores consistentes com o material.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Folha de papel quadriculado, calculadora científica, tabela de propriedades de materiais.",
                                  "tips": "Desenhe o elemento para visualizar; use unidades consistentes (SI).",
                                  "learningObjective": "Compreender e coletar todos os insumos necessários para o cálculo de tensões no CST.",
                                  "commonMistakes": "Esquecer espessura t ou usar fórmula errada para [D] (tensão vs. deformação plana)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a matriz de deformações [B] para o elemento CST",
                                  "subSteps": [
                                    "Calcule os termos geométricos: a1 = y2 - y3, b1 = x3 - x2, c1 = x2 y3 - x3 y2 (e cíclicos para a2,b2,c2 e a3,b3,c3).",
                                    "Monte [B] (3x6): primeira linha [b1/A, 0, b2/A, 0, b3/A, 0]; segunda [0, a1/A, 0, a2/A, 0, a3/A]; terceira [a1/A, b1/A, a2/A, b2/A, a3/A, b3/A], onde 2A é o dobro da área.",
                                    "Verifique se det([B]) ou propriedades indicam deformações constantes.",
                                    "Confirme que [B] é constante (característica do CST).",
                                    "Salve [B] para uso posterior."
                                  ],
                                  "verification": "Multiplique [B] por um vetor de deslocamentos unitário e confira se resulta em deformações razoáveis.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora matricial ou software como MATLAB/Octave, tabela de fórmulas MEF.",
                                  "tips": "Use convenção de numeração anti-horária para nós; automatize com script se possível.",
                                  "learningObjective": "Dominar a derivação e montagem da matriz [B] exclusiva do elemento triangular CST.",
                                  "commonMistakes": "Erro nos sinais dos termos ai, bi, ci ou divisão por 2A em vez de A."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular as deformações elementares {ε} = [B] {d_e}",
                                  "subSteps": [
                                    "Multiplique a matriz [B] (3x6) pelo vetor {d_e} (6x1) para obter {ε} = [ε_x, ε_y, γ_xy]^T.",
                                    "Execute a multiplicação matricial passo a passo: ε_x = (b1 u1 + b2 u2 + b3 u3)/A, etc.",
                                    "Arredonde para precisão numérica (ex: 4 casas decimais).",
                                    "Interprete: ε_x >0 tração, <0 compressão; γ_xy é cisalhamento.",
                                    "Registre valores de ε_x, ε_y, γ_xy."
                                  ],
                                  "verification": "Confira se norma de {ε} é coerente com deslocamentos magnitudes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de álgebra linear (Excel, MATLAB) ou calculadora matricial.",
                                  "tips": "Verifique multiplicação manual com um nó fixo (u=v=0).",
                                  "learningObjective": "Aplicar corretamente a relação cinemática {ε} = [B] {d_e} em CST.",
                                  "commonMistakes": "Confundir ordem de {d_e} ou multiplicar [B]^T em vez de [B]."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular as tensões elementares {σ} = [D] {ε}",
                                  "subSteps": [
                                    "Multiplique [D] (3x3) por {ε} (3x1) para {σ} = [σ_x, σ_y, τ_xy]^T.",
                                    "Execute: σ_x = D11 ε_x + D12 ε_y, etc.",
                                    "Inclua sinal: positivo tração, negativo compressão.",
                                    "Calcule tensões principais se desejado (opcional para verificação).",
                                    "Compare com critérios de falha (ex: Von Mises)."
                                  ],
                                  "verification": "Verifique equilíbrio aproximado ou sinal físico (ex: tração em área esticada).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Mesmos da etapa 3.",
                                  "tips": "Use [D] simétrica; teste com ε unitário.",
                                  "learningObjective": "Conectar deformações a tensões via constitutiva linear elástica.",
                                  "commonMistakes": "Usar [D] errada ou inverter ordem de multiplicação."
                                }
                              ],
                              "practicalExample": "Para triângulo com nós (0,0), (1,0), (0,1); E=200 GPa, ν=0.3; {d_e}=[0.001,0,0.002,0.001,0,0.002]^T. Área A=0.5. Calcule [B], {ε}=[0.004,0.004,0]^T, {σ}=[1.44, 0.864, 0] MPa.",
                              "finalVerifications": [
                                "Tensões calculadas coincidem com software MEF (erro <1%).",
                                "{ε} e {σ} têm sinais físicos coerentes com deslocamentos.",
                                "Matrizes [B] e [D] montadas corretamente por inspeção.",
                                "Valores de τ_xy corretos para cisalhamento.",
                                "Reproduz exemplo prático com exatidão numérica.",
                                "Elemento CST mostra tensões constantes (independente de ponto)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos matriciais (erro <0.1%).",
                                "Correta montagem de [B] e [D] conforme fórmulas padrão.",
                                "Interpretação física das tensões/deformações.",
                                "Eficiência no tempo e ausência de erros comuns.",
                                "Capacidade de generalizar para outros elementos.",
                                "Documentação clara dos passos e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (multiplicação matricial, determinantes).",
                                "Física: Mecânica dos sólidos (lei de Hooke generalizada).",
                                "Programação: Implementação em Python/MATLAB para automação MEF.",
                                "Engenharia Civil: Análise de placas e cascas.",
                                "Estatística: Análise de erro em aproximações finitas."
                              ],
                              "realWorldApplication": "Em análise de tensão de componentes aeronáuticos como asas de aviões ou chassis de veículos, usando software como ANSYS para prever falhas por fadiga em malhas triangulares CST."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.2.1.2.4"
                            ]
                          },
                          {
                            "id": "34.2.1.3.2",
                            "name": "Montar matriz de rigidez global",
                            "description": "Somar contribuições de [K_e] para todos os elementos triangulares, considerando conectividade nodal em uma malha 2D.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a topologia da malha e identificar conectividade nodal",
                                  "subSteps": [
                                    "Liste todos os nós da malha 2D com suas coordenadas (x, y).",
                                    "Enumere os elementos triangulares e registre os nós conectados a cada um (ex: elemento 1: nós 1,2,3).",
                                    "Crie uma tabela de conectividade nodal para mapear graus de liberdade locais (2 por nó em 2D: ux, uy).",
                                    "Determine o número total de graus de liberdade globais (2 * número de nós livres).",
                                    "Desenhe a malha para visualizar nós compartilhados entre elementos."
                                  ],
                                  "verification": "Verifique se a tabela de conectividade corresponde à malha desenhada e se todos os nós estão conectados corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel milimetrado ou software como MATLAB/Python para plotar malha; tabela de nós e elementos.",
                                  "tips": "Use numeração consistente de nós para evitar confusão no mapeamento posterior.",
                                  "learningObjective": "Compreender a relação entre malha física e graus de liberdade matemáticos.",
                                  "commonMistakes": "Ignorar nós compartilhados, levando a duplicação de DOFs; numeração inconsistente de nós."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar a matriz de rigidez global e calcular [K_e] para cada elemento",
                                  "subSteps": [
                                    "Inicialize [K_global] como uma matriz zero de tamanho (n_dof x n_dof), onde n_dof = 2 * n_nós.",
                                    "Para cada elemento triangular, calcule a matriz [K_e] 6x6 usando fórmula [K_e] = ∫ [B]^T [D] [B] dV.",
                                    "Compute matrizes [B] (derivadas de forma) e [D] (constitutiva) baseadas em coordenadas nodais e propriedades do material.",
                                    "Armazene [K_e] para cada elemento em uma lista ou estrutura de dados.",
                                    "Confirme unidades consistentes (ex: N/m para rigidez)."
                                  ],
                                  "verification": "Confira dimensões de [K_global] e valores não-nulos apenas em [K_e]; teste um [K_e] manualmente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora ou software (MATLAB, Python com NumPy/SciPy); propriedades do material (E, ν, t).",
                                  "tips": "Automatize cálculo de [K_e] com script para malhas maiores, mas entenda a fórmula manualmente primeiro.",
                                  "learningObjective": "Dominar o cálculo local de rigidez elementar para elementos triangulares.",
                                  "commonMistakes": "Erro em Jacobiano ou inversão de coordenadas ao calcular [B]; dimensões erradas em [K_e]."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear e expandir [K_e] para o sistema global usando conectividade",
                                  "subSteps": [
                                    "Para cada elemento, identifique os índices globais dos DOFs usando a tabela de conectividade (ex: nó 1: DOFs 1-2).",
                                    "Crie um vetor de mapeamento local-para-global (6 posições para triangular).",
                                    "Expanda [K_e] 6x6 para o tamanho global, colocando valores nos índices corretos e zeros elsewhere.",
                                    "Some a expansão de [K_e] à [K_global] nas posições correspondentes.",
                                    "Repita para todos os elementos, acumulando contribuições em nós compartilhados."
                                  ],
                                  "verification": "Verifique se contribuições de elementos adjacentes somam corretamente em DOFs compartilhados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilha Excel ou código Python para mapeamento; matriz [K_global] inicial.",
                                  "tips": "Use loops em código: for each element, map local to global indices before adding.",
                                  "learningObjective": "Aplicar transformação de coordenadas locais para globais via conectividade.",
                                  "commonMistakes": "Mapeamento incorreto de DOFs (ex: confundir ux/uy); não somar em nós compartilhados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar e validar a matriz de rigidez global",
                                  "subSteps": [
                                    "Aplique condições de contorno zerando linhas/colunas de DOFs fixos (simplificado).",
                                    "Verifique simetria de [K_global] (K_ij = K_ji).",
                                    "Confira estrutura de banda esparsa: não-zeros apenas entre DOFs conectados.",
                                    "Calcule traço ou norma para consistência energética.",
                                    "Exporte [K_global] para análise posterior (ex: solver de autovalores)."
                                  ],
                                  "verification": "Matriz simétrica, positiva definida (autovalores >0), perfil de banda correto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software para checagem (MATLAB eig() ou Python scipy.sparse.linalg); visualizador de matriz.",
                                  "tips": "Use formatos esparsos (CSR) para eficiência em malhas reais.",
                                  "learningObjective": "Garantir propriedades matemáticas da matriz global para solvência.",
                                  "commonMistakes": "Violar simetria por erros de mapeamento; ignorar banda esparsa levando a ineficiência."
                                }
                              ],
                              "practicalExample": "Considere uma malha 2D com 4 nós (1:(0,0), 2:(1,0), 3:(0,1), 4:(1,1)) formando 2 elementos triangulares: e1(1,2,3), e2(2,3,4). Material: E=200GPa, ν=0.3, t=1mm. Calcule [K_e1] e [K_e2] (6x6 cada), mapeie DOFs (8 totais), some para [K_global] 8x8. Resultado: não-zeros em posições conectadas, simétrica.",
                              "finalVerifications": [
                                "Dimensões de [K_global] = (2*n_nós x 2*n_nós).",
                                "Simetria confirmada: K[i,j] == K[j,i] para todos i,j.",
                                "Estrutura esparsa: 90%+ zeros, perfil de banda alinhado à malha.",
                                "Contribuições somadas corretamente em nós compartilhados.",
                                "Propriedades do material propagadas consistentemente.",
                                "Matriz positiva semi-definida (autovalores ≥0)."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos de [K_e] (erro <1%).",
                                "Correto mapeamento de conectividade (sem DOFs duplicados/orfãos).",
                                "Eficiência na soma (tempo computacional O(n_elementos * dofs_e^2)).",
                                "Validação de simetria e esparsidade.",
                                "Clareza na documentação do processo e verificações.",
                                "Capacidade de escalar para malha com 10+ elementos."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Operações de matrizes esparsas e soma bloqueada.",
                                "Programação Computacional: Implementação em Python/MATLAB para automação.",
                                "Física (Mecânica dos Sólidos): Interpretação de rigidez como energia de deformação.",
                                "Geometria Computacional: Geração e refinamento de malhas triangulares."
                              ],
                              "realWorldApplication": "Na análise estrutural de placas aeronáuticas ou fundações de pontes, onde [K_global] é montada para prever deformações sob cargas, otimizando design e evitando falhas catastróficas em simulações FEM industriais como ANSYS ou Abaqus."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.2.1.3.1"
                            ]
                          },
                          {
                            "id": "34.2.1.3.3",
                            "name": "Resolver sistema global e interpretar resultados",
                            "description": "Aplicar método de Gauss ou decomposição para {d} = [K_g]^{-1} {F}, e extrair tensões/deformações para análise de problemas como placas sob carga.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a matriz de rigidez global [K_g] e vetor de forças {F}",
                                  "subSteps": [
                                    "Reunir as matrizes de rigidez elementares [K_e] de todos os elementos triangulares.",
                                    "Aplicar condições de contorno para modificar [K_g] e {F}, eliminando graus de liberdade restritos.",
                                    "Montar [K_g] somando contribuições elementares usando funções de conectividade.",
                                    "Verificar simetria e positiva definitividade de [K_g].",
                                    "Construir {F} incorporando cargas nodais e distribuídas."
                                  ],
                                  "verification": "Conferir dimensões de [K_g] (n_dof x n_dof) e {F} (n_dof x 1), e testar multiplicação [K_g]{d_test} ≈ {F_test} com vetor teste.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de EF (MATLAB, Python/NumPy/SciPy), malha 2D de placa, propriedades materiais (E, ν).",
                                  "tips": "Use índices de conectividade para montagem eficiente; armazene [K_g] em formato esparso para malhas grandes.",
                                  "learningObjective": "Dominar montagem do sistema global a partir de contribuições elementares.",
                                  "commonMistakes": "Esquecer aplicação de contornos levando a singularidade; duplicar nós na conectividade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Resolver o sistema linear {d} = [K_g]^{-1} {F}",
                                  "subSteps": [
                                    "Escolher método: eliminação de Gauss para matrizes pequenas ou decomposição LU/Cholesky para simetria.",
                                    "Implementar ou chamar solver: fatorar [K_g] = LU, resolver Ly = {F}, Ux = y.",
                                    "Aplicar pivoteamento parcial se necessário para estabilidade numérica.",
                                    "Obter vetor de deslocamentos nodais {d}.",
                                    "Verificar resíduo ||[K_g]{d} - {F}|| < tolerância (ex: 1e-6)."
                                  ],
                                  "verification": "Calcular resíduo normatizado e comparar com tolerância; plotar deslocamentos esperados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Bibliotecas lineares (SciPy.linalg.solve, MATLAB backslash), timer para benchmark.",
                                  "tips": "Prefira Cholesky para [K_g] simétrica positiva definida; monitore condição numérica cond([K_g]).",
                                  "learningObjective": "Aplicar solvers diretos para sistemas lineares em EF.",
                                  "commonMistakes": "Ignorar singularidade por contornos inadequados; overflow numérico sem escalonamento."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extrair tensões e deformações dos deslocamentos elementares",
                                  "subSteps": [
                                    "Para cada elemento triangular, extrair {d_e} de {d} usando conectividade.",
                                    "Calcular deformações {ε} = [B]{d_e}, onde [B] é matriz de deformação.",
                                    "Computar tensões {σ} = [D]{ε}, com [D] matriz de constitutivo (plano tensão/esforço).",
                                    "Média ou extrapolação para pontos de Gauss/nós.",
                                    "Visualizar campos via contour plots."
                                  ],
                                  "verification": "Verificar compatibilidade de deformações nos nós compartilhados; checar equilíbrio local.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Funções de pós-processamento (Matplotlib para plots), fórmulas [B] e [D] para triângulo linear.",
                                  "tips": "Use integração numérica em pontos de Gauss para precisão; normalize tensões por carga aplicada.",
                                  "learningObjective": "Conectar deslocamentos globais a campos locais de tensão/deformação.",
                                  "commonMistakes": "Erro na extração {d_e} por índices errados; confundir plano tensão com esforço."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e validar análise",
                                  "subSteps": [
                                    "Identificar máximos de tensão/deformação e locais críticos.",
                                    "Comparar com soluções analíticas ou benchmarks para placa sob carga.",
                                    "Analisar convergência refinando malha.",
                                    "Avaliar critérios de falha (Von Mises, Tresca).",
                                    "Documentar insights para design."
                                  ],
                                  "verification": "Erro relativo < 5% vs. analítico; mesh convergence study.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Benchmarks analíticos (placa cantilever), software de visualização (Paraview).",
                                  "tips": "Sempre plote deformed shape escalado; cheque simetria em problemas simétricos.",
                                  "learningObjective": "Interpretar saídas de EF para tomada de decisão em engenharia.",
                                  "commonMistakes": "Sobrepor oscilações numéricas como físicas; ignorar efeitos de contorno."
                                }
                              ],
                              "practicalExample": "Para uma placa retangular sob carga uniforme na borda livre (cantilever), com malha de 10 elementos triangulares: monte [K_g] 12x12, resolva para {d}, calcule σ_xx máx ≈ 1.2 MPa e ε_yy máx ≈ 6e-6, validando vs. solução de Timoshenko.",
                              "finalVerifications": [
                                "Resíduo do sistema < 1e-8.",
                                "Deslocamentos consistentes com direção da carga.",
                                "Tensões contínuas entre elementos (salto < 10%).",
                                "Convergência com refinamento de malha.",
                                "Equilíbrio global de forças.",
                                "Critério de falha não excedido em pontos críticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão da solução (erro < 5% vs. benchmark).",
                                "Correta implementação de solver e pós-processamento.",
                                "Visualizações claras de campos de tensão/deformação.",
                                "Análise de erros numéricos e validação.",
                                "Interpretação física correta dos resultados.",
                                "Eficiência computacional (tempo/espaço)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (solvers, autovalores para modos).",
                                "Programação: Implementação numérica em Python/MATLAB.",
                                "Física: Mecânica dos sólidos, equilíbrio.",
                                "Design: CAD para malha, otimização estrutural."
                              ],
                              "realWorldApplication": "Análise de tensões em asas de aeronaves ou painéis de carroceria sob carga dinâmica, prevendo falhas e otimizando espessura para segurança e leveza em indústrias aeroespacial e automotiva."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.2.1.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.2",
                    "name": "Elemento Axissimétrico",
                    "description": "Desenvolvimento de elementos finitos para problemas com simetria de rotação em geometrias axissimétricas.",
                    "individualConcepts": [
                      {
                        "id": "34.2.1.1",
                        "name": "Simetria Axissimétrica e Coordenadas Cilíndricas",
                        "description": "Compreensão dos problemas com simetria de rotação ao redor de um eixo, permitindo modelagem em 2D no plano meridional (r, z), com independência em relação ao ângulo θ, e definição das componentes relevantes de tensão e deformação em coordenadas cilíndricas.",
                        "specificSkills": [
                          {
                            "id": "34.2.1.1.1",
                            "name": "Identificar problemas axissimétricos",
                            "description": "Reconhecer geometrias e carregamentos com simetria de rotação, como discos, cilindros sob pressão interna ou rotações, e justificar a redução dimensional de 3D para 2D axissimétrico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Simetria Axissimétrica",
                                  "subSteps": [
                                    "Estude a definição de simetria axissimétrica: invariância sob rotação em torno de um eixo.",
                                    "Revise coordenadas cilíndricas (r, θ, z) e como elas simplificam problemas simétricos.",
                                    "Analise diagramas de geometrias 3D que exibem simetria radial, como cilindros e cones.",
                                    "Compare simetria axissimétrica com simetria plana e 3D completa.",
                                    "Pratique visualizando rotações em torno de um eixo usando ferramentas de modelagem 3D simples."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que é simetria axissimétrica e dê um exemplo de coordenadas cilíndricas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Elementos Finitos (capítulo sobre coordenadas cilíndricas)",
                                    "Software gratuito como GeoGebra ou FreeCAD para visualização 3D"
                                  ],
                                  "tips": "Sempre imagine girar a geometria em torno do eixo para verificar invariância.",
                                  "learningObjective": "Dominar a definição e representação matemática da simetria axissimétrica.",
                                  "commonMistakes": [
                                    "Confundir com simetria esférica",
                                    "Ignorar variações ao longo do eixo z"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Geometrias Axissimétricas Comuns",
                                  "subSteps": [
                                    "Liste geometrias típicas: discos, cilindros, esferas cortadas, cones e anéis.",
                                    "Examine desenhos técnicos de peças mecânicas e destaque as que possuem simetria radial.",
                                    "Use cortes meridionais (plano r-z) para representar geometrias 3D em 2D.",
                                    "Pratique com imagens de componentes reais, como rolamentos e pistões.",
                                    "Crie esboços manuais de 5 geometrias axissimétricas e suas representações 2D."
                                  ],
                                  "verification": "Classifique 5 geometrias fornecidas como axissimétricas ou não, justificando cada uma.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Imagens de componentes mecânicos (catálogos online)",
                                    "Papel e lápis para esboços",
                                    "Tutorial de corte meridional em PDF"
                                  ],
                                  "tips": "Foque no plano que contém o eixo de rotação; ele deve representar toda a geometria.",
                                  "learningObjective": "Reconhecer visualmente geometrias que admitem modelagem axissimétrica.",
                                  "commonMistakes": [
                                    "Considerar geometrias com perfurações assimétricas como axissimétricas",
                                    "Esquecer de verificar simetria em todas as direções radiais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconhecer Carregamentos e Condições de Contorno Simétricos",
                                  "subSteps": [
                                    "Identifique carregamentos axissimétricos: pressão interna uniforme, rotação angular constante, temperatura radial.",
                                    "Analise exemplos: cilindro sob pressão hidrostática, disco rotativo com inércia.",
                                    "Verifique se forças, momentos ou deslocamentos variam apenas com r e z, não com θ.",
                                    "Estude condições de contorno: fixação no eixo, rolamento radial simétrico.",
                                    "Simule carregamentos em software para observar deformações simétricas."
                                  ],
                                  "verification": "Para 3 cenários de carregamento, determine se são axissimétricos e descreva por quê.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Exemplos de problemas de FEA em ANSYS ou Abaqus (tutoriais gratuitos)",
                                    "Vídeos de simulações de cilindros pressurizados"
                                  ],
                                  "tips": "Pergunte: 'O carregamento muda se eu girar o modelo?' Se não, é simétrico.",
                                  "learningObjective": "Avaliar se carregamentos preservam a simetria da geometria.",
                                  "commonMistakes": [
                                    "Assumir pressão assimétrica como simétrica",
                                    "Ignorar carregamentos gravitacionais não radiais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificar a Redução Dimensional de 3D para 2D Axissimétrico",
                                  "subSteps": [
                                    "Explique a redução: eliminar variável θ, modelar em plano r-z com fatores de integração 2πr.",
                                    "Calcule economia computacional: número de elementos reduzido em fator de ~360°/incremento θ.",
                                    "Compare resultados de simulações 3D full vs. 2D axissimétrico para validação.",
                                    "Discuta limitações: quando a simetria é quebrada (ex.: furos excêntricos).",
                                    "Redija uma justificativa formal para um problema exemplo."
                                  ],
                                  "verification": "Escreva uma justificativa de 200 palavras para reduzir um cilindro 3D para 2D axissimétrico.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software FEA trial (ex.: CalculiX)",
                                    "Planilhas para cálculo de DOFs (graus de liberdade)"
                                  ],
                                  "tips": "Sempre quantifique a redução em tempo de computação para fortalecer a justificativa.",
                                  "learningObjective": "Capacitar-se a argumentar tecnicamente pela simplificação dimensional.",
                                  "commonMistakes": [
                                    "Não mencionar o jacobiano 2πr na formulação fraca",
                                    "Aplicar redução sem verificar simetria completa"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise um cilindro fechado sob pressão interna uniforme: geometria cilíndrica simétrica, pressão radial constante, condições de contorno fixas nas extremidades. Justifique modelagem em 2D axissimétrico usando corte r-z, prevendo tensões circunferenciais via fórmula de Lamé.",
                              "finalVerifications": [
                                "Identifica corretamente 90% das geometrias e carregamentos axissimétricos em um conjunto de 10 exemplos.",
                                "Fornece justificativa dimensional precisa, incluindo economia computacional.",
                                "Representa corretamente um problema 3D em plano 2D com coordenadas cilíndricas.",
                                "Reconhece e exclui casos não-simétricos, como furos desalinhados.",
                                "Explica o impacto da simetria nas equações de equilíbrio.",
                                "Valida redução comparando com solução analítica simples (ex.: disco grosso)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de simetria (geometria e carregamento).",
                                "Clareza e completude da justificativa de redução dimensional.",
                                "Uso correto de terminologia (r, θ, z; corte meridional).",
                                "Profundidade nos exemplos práticos e limitações.",
                                "Quantificação de benefícios computacionais.",
                                "Capacidade de visualização e esboço manual."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações em coordenadas cilíndricas e integrais de linha (2πr).",
                                "Física: Mecânica dos sólidos, tensões principais em rotações.",
                                "Computação: Programação de solvers FEA e otimização de malhas.",
                                "Engenharia de Materiais: Comportamento sob pressão hidrostática."
                              ],
                              "realWorldApplication": "Projeto de tubulações de alta pressão em indústrias petroquímicas, rotores de turbinas eólicas ou vasos de reatores nucleares, onde a modelagem axissimétrica reduz tempo de simulação de dias para horas, otimizando designs para segurança e custo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.2.1.1.2",
                            "name": "Expressar tensões e deformações em coordenadas cilíndricas",
                            "description": "Derivar as expressões para as componentes de tensão (σ_r, σ_θ, σ_z, τ_rz) e deformação (ε_r, ε_θ, ε_z, γ_rz) em termos das deslocamentos u_r(r,z) e u_z(r,z), considerando o efeito circunferencial devido ao raio r.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Coordenadas Cilíndricas e Deslocamentos",
                                  "subSteps": [
                                    "Estude as coordenadas cilíndricas (r, θ, z) e sua relação com cartesianas (x, y, z).",
                                    "Identifique os componentes de deslocamento: u_r(r,z) radial e u_z(r,z) axial, assumindo independência de θ devido à simetria axissimétrica.",
                                    "Revise os operadores diferenciais em coordenadas cilíndricas: ∂/∂r, ∂/∂z, e o termo circunferencial 1/r.",
                                    "Desenhe um elemento diferencial cilíndrico para visualizar deformações.",
                                    "Liste as hipóteses de deformação pequena e linearidade."
                                  ],
                                  "verification": "Crie um diagrama anotado mostrando u_r e u_z em um elemento cilíndrico e liste 3 operadores diferenciais chave.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Mecânica dos Sólidos (ex: Timoshenko)",
                                    "Folha de derivadas em coordenadas cilíndricas",
                                    "Software de desenho (ex: Draw.io)"
                                  ],
                                  "tips": "Sempre normalize com o raio r para termos circunferenciais; pratique convertendo vetores cartesianos para cilíndricos.",
                                  "learningObjective": "Compreender a geometria e os deslocamentos em simetria axissimétrica.",
                                  "commonMistakes": [
                                    "Confundir u_θ com zero (não existe em axissimétrica)",
                                    "Ignorar dependência de r no termo θ",
                                    "Esquecer que θ é ignorado por simetria"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar Componentes de Deformação (Strains)",
                                  "subSteps": [
                                    "Derive ε_r = ∂u_r / ∂r a partir da extensão radial.",
                                    "Derive ε_θ = u_r / r considerando a circunferência 2πr.",
                                    "Derive ε_z = ∂u_z / ∂z da extensão axial.",
                                    "Derive γ_rz = ∂u_r / ∂z + ∂u_z / ∂r do cisalhamento rz.",
                                    "Escreva todas as 4 deformações em termos de u_r e u_z."
                                  ],
                                  "verification": "Escreva as 4 equações de deformação e verifique dimensionalmente (todas unitless).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Caderno de derivadas",
                                    "Tabela de deformações em coordenadas cilíndricas",
                                    "Calculadora simbólica (ex: SymPy online)"
                                  ],
                                  "tips": "Use o elemento diferencial para intuição: ε_θ surge da mudança no raio médio.",
                                  "learningObjective": "Derivar precisamente as strains ε_r, ε_θ, ε_z, γ_rz.",
                                  "commonMistakes": [
                                    "Esquecer 1/r em ε_θ",
                                    "Inverter ∂u_z/∂r e ∂u_r/∂z em γ_rz",
                                    "Incluir termos em θ desnecessários"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar Componentes de Tensão (Stresses) via Lei de Hooke",
                                  "subSteps": [
                                    "Lembre a lei de Hooke isotrópica: σ_ij = λ δ_ij ε_kk + 2μ ε_ij.",
                                    "Calcule a dilatância ε_kk = ε_r + ε_θ + ε_z.",
                                    "Derive σ_r = λ (ε_r + ε_θ + ε_z) + 2μ ε_r.",
                                    "Derive similarmente σ_θ, σ_z e τ_rz = μ γ_rz.",
                                    "Substitua as strains para expressar tudo em u_r e u_z."
                                  ],
                                  "verification": "Expanda σ_r completamente e confirme que contém ∂u_r/∂r, u_r/r e ∂u_z/∂z.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Fórmulas de elasticidade linear",
                                    "SymPy ou Mathematica para expansão simbólica",
                                    "Exemplos de livros de FEM"
                                  ],
                                  "tips": "Agrupe termos volumétricos (λ) e devióricos (2μ); verifique simetria.",
                                  "learningObjective": "Aplicar constitutiva para obter stresses em função das strains derivadas.",
                                  "commonMistakes": [
                                    "Usar μ em vez de 2μ para normais",
                                    "Esquecer λ na dilatância",
                                    "Confundir τ_rz com γ_rz/2"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar, Simplificar e Integrar Expressões",
                                  "subSteps": [
                                    "Verifique consistência limitando r→0 ou casos conhecidos (ex: uniaxial).",
                                    "Simplifique expressões destacando dependência em r (ex: 1/r em ε_θ).",
                                    "Escreva o conjunto completo: 4 stresses em termos de u_r, u_z e derivadas.",
                                    "Discuta implicações numéricas em FEM (singularidades em r=0).",
                                    "Teste com um deslocamento simples (ex: u_r = kr, u_z=0)."
                                  ],
                                  "verification": "Aplique a um caso teste e compare com solução analítica conhecida.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Casos teste de livros de FEM",
                                    "Python/SymPy para validação numérica"
                                  ],
                                  "tips": "Sempre cheque unidades e limites físicos (ex: ε_θ finito em r=0).",
                                  "learningObjective": "Validar e refinar as expressões derivadas.",
                                  "commonMistakes": [
                                    "Singularidade não tratada em r=0",
                                    "Erros de sinal em derivadas mistas",
                                    "Omitir dependência circunferencial"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um disco cilíndrico sob deslocamento radial u_r = a r (expansão uniforme). Derive ε_r = a, ε_θ = a, ε_z = 0, γ_rz=0; então σ_r = σ_θ = (2μ + λ) a, σ_z = λ (2a), τ_rz=0. Implemente em código FEM simples para um malha radial.",
                              "finalVerifications": [
                                "ε_θ corretamente como u_r / r (termo 1/r presente).",
                                "γ_rz simétrica: ∂u_r/∂z + ∂u_z/∂r.",
                                "σ_r inclui λ(ε_r + ε_θ + ε_z) + 2μ ε_r.",
                                "τ_rz = μ γ_rz (não 2μ).",
                                "Todas expressões dependem só de r,z (sem θ).",
                                "Verificação limite: em r grande, aproxima cartesiano."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas derivadas parciais e fatores 1/r.",
                                "Correta aplicação da lei de Hooke (λ, μ corretos).",
                                "Expressões finais livres de erros algébricos.",
                                "Inclusão de todos componentes: 3 normais + 1 cisalhante.",
                                "Demonstração de verificação com caso simples.",
                                "Clareza na dependência de u_r(r,z), u_z(r,z)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo vetorial e coordenadas curvilíneas.",
                                "Física: Mecânica do contínuo e teoria da elasticidade.",
                                "Computação: Implementação em código FEM (ex: FEniCS, Abaqus scripting).",
                                "Engenharia Civil: Análise de silos e reservatórios cilíndricos.",
                                "Matemática Numérica: Tratamento de singularidades em r=0."
                              ],
                              "realWorldApplication": "Essas expressões são fundamentais em simulações FEM de vasos de pressão, tubos sob carga interna/externa, rotores de turbinas e análise de deformações em estruturas axissimétricas como pilhas de solo ou reservatórios nucleares, permitindo prever falhas por tensão circunferencial elevada."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.2.1.1.3",
                            "name": "Aplicar equações de equilíbrio axissimétricas",
                            "description": "Formular as equações diferenciais de equilíbrio em coordenadas cilíndricas para o plano (r,z), incluindo termos de corpo e contorno, preparando para a formulação fraca via métodos variacionais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar coordenadas cilíndricas e simetria axissimétrica",
                                  "subSteps": [
                                    "Estudar a transformação de coordenadas cartesianas (x,y,z) para cilíndricas (r, θ, z), focando no plano (r,z) onde θ é constante devido à simetria.",
                                    "Identificar componentes de deslocamento u_r(r,z), u_θ=0, u_z(r,z) e tensões σ_rr, σ_θθ, σ_zz, σ_rz sob simetria axissimétrica.",
                                    "Derivar os operadores de deformação ε_rr = ∂u_r/∂r, ε_θθ = u_r/r, ε_zz = ∂u_z/∂z, ε_rz = (1/2)(∂u_r/∂z + ∂u_z/∂r).",
                                    "Visualizar geometricamente a simetria em problemas como discos ou cilindros.",
                                    "Praticar conversão de um problema cartesiano simples para cilíndrico."
                                  ],
                                  "verification": "Capacidade de escrever corretamente os operadores de deformação em coordenadas cilíndricas sem erros.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Mecânica dos Sólidos (ex: Timoshenko)",
                                    "Software de plotagem como MATLAB para visualizar coordenadas",
                                    "Notas de aula sobre coordenadas curvilíneas"
                                  ],
                                  "tips": "Use diagramas polares para visualizar r e θ; lembre que divisão por r é crítica perto do eixo.",
                                  "learningObjective": "Compreender a geometria e cinemática em coordenadas cilíndricas para problemas axissimétricos.",
                                  "commonMistakes": [
                                    "Confundir ε_θθ com ∂u_θ/∂θ (que é zero)",
                                    "Esquecer o fator 1/r nos operadores",
                                    "Ignorar singularidade em r=0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular equações de equilíbrio diferencial em coordenadas cilíndricas",
                                  "subSteps": [
                                    "Escrever o balanço de forças no plano (r,z): ∂(r σ_rr)/∂r + ∂(r σ_rz)/∂z + r f_r = 0 para direção r.",
                                    "Derivar para direção z: ∂(r σ_rz)/∂r + ∂(r σ_zz)/∂z + r f_z = 0.",
                                    "Expandir os termos: para r: σ_rr + ∂σ_rr/∂r + (1/r)∂σ_rz/∂z + f_r = 0 (dividindo por r).",
                                    "Verificar consistência dividindo pela circunferência 2πr para obter forma padrão.",
                                    "Implementar numericamente em um solver simbólico como SymPy para validar."
                                  ],
                                  "verification": "Derivação correta das equações sem termos espúrios, confirmada por comparação com referências padrão.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Referência: Zienkiewicz 'Finite Element Method'",
                                    "SymPy ou Mathematica para derivação simbólica",
                                    "Papel e lápis para derivação manual"
                                  ],
                                  "tips": "Sempre multiplique por r antes de derivar para evitar erros; use o princípio de momentos virtuais para intuição.",
                                  "learningObjective": "Derivar as equações de equilíbrio fortes em forma diferencial para tensões axissimétricas.",
                                  "commonMistakes": [
                                    "Esquecer o fator r nos termos divergentes",
                                    "Confundir σ_θθ no equilíbrio (não aparece diretamente)",
                                    "Erros de sinal nos termos mistos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar termos de corpo e validar equilíbrio",
                                  "subSteps": [
                                    "Identificar forças de corpo f_r e f_z (ex: gravidade, centrifugação: f_r = ρ ω² r).",
                                    "Substituir nos balanços: adicionar r f_r e r f_z nos membros direitos das equações expandidas.",
                                    "Verificar equilíbrio global integrando sobre volume: ∫∇·σ dV + ∫f dV = 0.",
                                    "Testar com caso simples: cilindro sob gravidade axial.",
                                    "Simular numericamente em código para plotar campos de tensão."
                                  ],
                                  "verification": "Equações incluem corretamente forças de corpo e passam em teste de equilíbrio integral.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python/MATLAB com NumPy para simulação",
                                    "Exemplos de problemas com rotação (turbinas)"
                                  ],
                                  "tips": "Para centrifugação, f_r é positivo radial; normalize unidades consistentemente.",
                                  "learningObjective": "Integrar forças volumétricas nas equações de equilíbrio axissimétricas.",
                                  "commonMistakes": [
                                    "Colocar f fora do fator r",
                                    "Usar f cartesiano sem transformação",
                                    "Ignorar direção radial de forças centrífugas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar condições de contorno e preparar para formulação fraca",
                                  "subSteps": [
                                    "Definir contornos: trações prescritas t_r, t_z em σ_rr n_r + σ_rz n_z = t_r, etc.",
                                    "Condições essenciais: u_r=0, u_z=0 em superfícies rígidas.",
                                    "Multiplicar equações por função teste v_r, v_z e integrar por partes: ∫ σ : ∇v dV - ∫ t·v dS = ∫ f·v dV.",
                                    "Identificar forma bilinear a( u, v ) = l(v) para métodos variacionais.",
                                    "Verificar consistência com FEM: elementos triangulares em (r,z)."
                                  ],
                                  "verification": "Formulação fraca derivada corretamente, com termos de contorno naturais e essenciais separados.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Notas sobre métodos variacionais",
                                    "Software FEA como Abaqus para validação",
                                    "Artigo sobre elementos axissimétricos"
                                  ],
                                  "tips": "Integração por partes em cilíndricas requer cuidado com 2πr dA; teste com v=1 para equilíbrio global.",
                                  "learningObjective": "Estabelecer condições de contorno e transitar para formulação fraca via princípio virtual.",
                                  "commonMistakes": [
                                    "Erros na integração por partes (sinais invertidos)",
                                    "Confundir contornos naturais vs. essenciais",
                                    "Esquecer fator 2πr na área"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Implementar e testar a formulação completa",
                                  "subSteps": [
                                    "Codificar as equações em um mini-FEM 2D axissimétrico para um problema benchmark.",
                                    "Aplicar BCs e forças de corpo em malha radial.",
                                    "Comparar solução com analítica (ex: Lamé para tubo espesso).",
                                    "Analisar convergência variando malha.",
                                    "Documentar o processo para revisão."
                                  ],
                                  "verification": "Solução numérica converge para solução exata com erro <1%.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Código base FEM em Python (FEniCS ou custom)",
                                    "Problema benchmark: tubo pressurizado"
                                  ],
                                  "tips": "Use elementos lineares iniciais; refine perto de r=0.",
                                  "learningObjective": "Aplicar integralmente as equações em um contexto computacional preparatório para FEM.",
                                  "commonMistakes": [
                                    "Malha singular em r=0 sem tratamento",
                                    "Índices errados em matrizes de rigidez",
                                    "BCs aplicadas incorretamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Analisar o equilíbrio em um disco rotativo de turbina: formular equações para σ_rr, σ_θθ, σ_zz sob centrifugação f_r = ρ ω² r, com contorno livre em r externo e fixo em r=0, preparando para simulação FEM.",
                              "finalVerifications": [
                                "Derivação correta das equações de equilíbrio em (r,z) com termos de corpo.",
                                "Condições de contorno aplicadas sem ambiguidades.",
                                "Transição suave para forma fraca com bilineares simétricas.",
                                "Validação numérica em exemplo simples converge.",
                                "Identificação de singularidades em r=0 tratadas.",
                                "Equilíbrio global satisfeito (∫f dV + ∫t dS = 0)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação diferencial (sem erros geométricos).",
                                "Correta inclusão de fatores r e 2π em integrais.",
                                "Separação clara de BCs essenciais e naturais.",
                                "Capacidade de implementar em código funcional.",
                                "Análise de erros comuns evitados.",
                                "Conexão explícita com FEM variacional."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações diferenciais em coordenadas curvilíneas e cálculo variacional.",
                                "Física: Mecânica dos contínuos e princípios de equilíbrio estático.",
                                "Computação: Programação numérica para PDEs e métodos de elementos finitos.",
                                "Engenharia de Materiais: Comportamento de tensões hoop em cilindros."
                              ],
                              "realWorldApplication": "Projeto de eixos de motores, tubos sob pressão interna (ex: caldeiras), análise de fadiga em rotores de turbinas eólicas, onde simetria reduz problema 3D a 2D eficiente em software FEA como ANSYS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "34.2.1.2",
                        "name": "Formulação do Elemento Triangular Axissimétrico",
                        "description": "Desenvolvimento do elemento finito triangular de 3 nós para problemas axissimétricos, incluindo funções de interpolação, matriz de deformação B e matriz de rigidez considerando o jacobiano com fator r.",
                        "specificSkills": [
                          {
                            "id": "34.2.1.2.1",
                            "name": "Definir funções de interpolação axissimétricas",
                            "description": "Construir funções de forma lineares N_i(r,z) para o triângulo no plano (r,z), aproximando deslocamentos u_r = Σ N_i u_{ri} e u_z = Σ N_i u_{zi}, garantindo compatibilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a geometria do elemento triangular axissimétrico",
                                  "subSteps": [
                                    "Estude as coordenadas cilíndricas (r, θ, z), focando no plano meridional (r,z) para simetria axial.",
                                    "Identifique os três nós do triângulo: nó 1 (r1,z1), nó 2 (r2,z2), nó 3 (r3,z3), garantindo r > 0.",
                                    "Revise o conceito de elemento isoparamétrico e mapeamento do elemento pai triangular.",
                                    "Desenhe o elemento no plano (r,z) e marque os graus de liberdade: u_r e u_z em cada nó.",
                                    "Explique a importância da simetria para reduzir de 3D para 2D."
                                  ],
                                  "verification": "Desenhe corretamente o triângulo com nós rotulados e liste os 6 graus de liberdade (3 u_r e 3 u_z).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Livro de Elementos Finitos (capítulo axissimétrico)",
                                    "Calculadora"
                                  ],
                                  "tips": "Sempre verifique se r ≥ 0 para evitar singularidades no eixo.",
                                  "learningObjective": "Entender a configuração geométrica e os graus de liberdade do elemento.",
                                  "commonMistakes": "Confundir coordenadas cilíndricas com cartesianas; ignorar restrição r > 0."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir funções de interpolação em coordenadas locais (naturais)",
                                  "subSteps": [
                                    "Introduza coordenadas locais (ξ, η) no triângulo de referência: ξ ≥ 0, η ≥ 0, ξ + η ≤ 1.",
                                    "Escreva as funções de forma lineares: N1 = 1 - ξ - η, N2 = ξ, N3 = η.",
                                    "Verifique propriedades básicas: Ni = δ_ij (1 no nó i, 0 nos outros), Σ Ni = 1.",
                                    "Calcule gradientes em coordenadas locais: ∂N_i/∂ξ e ∂N_i/∂η.",
                                    "Discuta a linearidade e continuidade C0 entre elementos."
                                  ],
                                  "verification": "Escreva as expressões de N1, N2, N3 e confirme Σ Ni = 1 em pontos arbitrários.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Folha de papel",
                                    "Software simbólico como Mathematica ou SymPy",
                                    "Notas de aula"
                                  ],
                                  "tips": "Use o triângulo unitário para simplificar cálculos iniciais.",
                                  "learningObjective": "Dominar as funções de shape lineares no domínio de referência.",
                                  "commonMistakes": "Erros em gradientes: ∂N1/∂ξ = -1, ∂N1/∂η = -1."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear funções para coordenadas globais (r, z)",
                                  "subSteps": [
                                    "Defina o mapeamento isoparamétrico: r(ξ,η) = Σ Ni ri, z(ξ,η) = Σ Ni zi.",
                                    "Calcule a matriz Jacobiana J = [∂r/∂ξ ∂r/∂η; ∂z/∂ξ ∂z/∂η].",
                                    "Expresse Ni(r,z) implicitamente via inverso do mapeamento.",
                                    "Para linear, derive explicitamente Ni resolvendo o sistema linear em r,z.",
                                    "Verifique det(J) > 0 para orientação positiva."
                                  ],
                                  "verification": "Para um triângulo exemplo, escreva Ni(r,z) e compute em um nó.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": [
                                    "Calculadora matricial",
                                    "Python/MATLAB para Jacobiana",
                                    "Exemplos resolvidos"
                                  ],
                                  "tips": "Resolva o sistema 3x3: [r1  r2  r3; z1 z2 z3; 1 1 1] * [N1;N2;N3] = [r;z;1].",
                                  "learningObjective": "Construir expressões explícitas de Ni em (r,z).",
                                  "commonMistakes": "Inverter ordem dos nós levando a det(J) < 0; fórmulas erradas no sistema."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar às aproximações de deslocamento e verificar compatibilidade",
                                  "subSteps": [
                                    "Escreva u_r(r,z) = Σ Ni u_ri, u_z(r,z) = Σ Ni u_zi.",
                                    "Verifique continuidade C0: campos coincidem nos nós vizinhos.",
                                    "Confirme partição da unidade e reprodutibilidade de constantes.",
                                    "Discuta compatibilidade com formulações fracas (espaço H1).",
                                    "Teste numericamente em um ponto interno: Σ Ni = 1, gradientes corretos."
                                  ],
                                  "verification": "Demonstre u_r e u_z para valores nodais dados e verifique em centroide.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha Excel ou código simples",
                                    "Gráfico do elemento"
                                  ],
                                  "tips": "Use centroide (médias de r,z) para teste rápido: Ni ≈ 1/3.",
                                  "learningObjective": "Garantir que as funções aproximem corretamente os deslocamentos com compatibilidade.",
                                  "commonMistakes": "Esquecer que u_θ = 0 por simetria; não verificar continuidade."
                                }
                              ],
                              "practicalExample": "Para triângulo com nós (r1,z1)=(1,0), (r2,z2)=(2,0), (r3,z3)=(1.5,1), resolva N1(r,z) do sistema: N1 = ( (r2 z3 - r3 z2) + z(r3 - r2) + r(z2 - z3) ) / det, onde det = (r1(z2 - z3) + r2(z3 - z1) + r3(z1 - z2)). Compute u_r(1.5, 0.5) com u_r1=0.1, u_r2=0.2, u_r3=0.15.",
                              "finalVerifications": [
                                "Σ Ni(r,z) = 1 para qualquer ponto interno.",
                                "Ni = 1 no nó i e 0 nos outros nós.",
                                "Gradientes ∂Ni/∂r e ∂Ni/∂z computados corretamente via J^{-1}.",
                                "det(J) > 0 em todos os pontos de Gauss.",
                                "Aproximação reproduz campo constante exatamente.",
                                "Continuidade C0 nos lados compartilhados com elementos adjacentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão das expressões explícitas de Ni(r,z).",
                                "Correção da Jacobiana e seu determinante.",
                                "Verificação numérica de propriedades em pelo menos 3 pontos.",
                                "Explicação clara da compatibilidade e continuidade.",
                                "Aplicação correta aos deslocamentos u_r e u_z.",
                                "Identificação de erros potenciais em r=0."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sistemas lineares e geometria analítica.",
                                "Física: Mecânica dos sólidos de revolução e tensão radial.",
                                "Computação: Implementação em códigos FEM como FEniCS ou Abaqus.",
                                "Engenharia Civil: Análise de silos e reservatórios.",
                                "Matemática Numérica: Integração em elementos axissimétricos."
                              ],
                              "realWorldApplication": "Essas funções são fundamentais na análise de elementos finitos para componentes axissimétricos como tubos pressurizados, rotores de turbinas, vasos de pressão e eixos rotativos, permitindo simular deformações e tensões com eficiência computacional reduzida."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.2.1.2.2",
                            "name": "Derivar a matriz de deformação B",
                            "description": "Calcular a matriz B que relaciona os vetores de deformação {ε} = B {d} aos graus de liberdade nodais, incorporando derivadas parciais em r e z, e o termo ε_θ = u_r / r.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o campo de deslocamento interpolado",
                                  "subSteps": [
                                    "Identifique os graus de liberdade (DOFs) nodais: cada nó tem u_r,i e u_z,i para i=1,2,3 em um elemento triangular com 3 nós.",
                                    "Escreva a interpolação para u_r(r,z) = Σ N_i(r,z) u_r,i onde N_i são as funções de forma.",
                                    "Escreva similarmente u_z(r,z) = Σ N_i(r,z) u_z,i.",
                                    "Especifique as funções de forma para elemento triangular linear: N1 = L1, N2 = L2, N3 = L3 com L1 + L2 + L3 = 1.",
                                    "Defina as coordenadas dos nós (r1,z1), (r2,z2), (r3,z3) para contextualizar."
                                  ],
                                  "verification": "Verifique se {d} = [u_r1, u_z1, u_r2, u_z2, u_r3, u_z3]^T está corretamente relacionado a u_r e u_z via N_i.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, diagrama do elemento triangular axissimétrico, livro de Elementos Finitos (ex: Zienkiewicz).",
                                  "tips": "Desenhe o elemento no plano r-z para visualizar os nós e funções de forma.",
                                  "learningObjective": "Entender como os deslocamentos nodais são interpolados no domínio do elemento.",
                                  "commonMistakes": "Confundir funções de forma lineares com quadráticas; esquecer que é axissimétrico (sem variação em θ)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Expressar as componentes de deformação",
                                  "subSteps": [
                                    "Liste as deformações relevantes: ε_r = ∂u_r/∂r, ε_z = ∂u_z/∂z, γ_rz = ∂u_r/∂z + ∂u_z/∂r, ε_θ = u_r / r.",
                                    "Substitua as interpolações: ε_r = Σ (∂N_i/∂r) u_r,i; similar para outras.",
                                    "Escreva em forma matricial: {ε} = [ε_r, ε_z, γ_rz, ε_θ]^T = B {d}.",
                                    "Note que ε_θ não envolve derivadas, mas divisão por r.",
                                    "Confirme que há 4 componentes de deformação para 6 DOFs."
                                  ],
                                  "verification": "Escreva explicitamente {ε} em termos de derivadas de N_i e confirme a relação linear com {d}.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel quadriculado, calculadora simbólica (ex: Mathematica ou papel).",
                                  "tips": "Agrupe termos por DOF nodal para visualizar a estrutura de B.",
                                  "learningObjective": "Relacionar deformações locais aos deslocamentos nodais via operador diferencial.",
                                  "commonMistakes": "Esquecer o termo de cisalhamento γ_rz ou tratar ε_θ como derivada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular as derivadas das funções de forma",
                                  "subSteps": [
                                    "Expresse funções de forma em coordenadas locais: L1 = a1 + b1 r + c1 z, etc., onde coeficientes vêm das coordenadas nodais.",
                                    "Calcule o Jacobiano J = [∂r/∂ξ ∂r/∂η; ∂z/∂ξ ∂z/∂η] para transformação isoparamétrica (ξ,η).",
                                    "Obtenha ∂N_i/∂r = (∂N_i/∂ξ ∂ξ/∂r + ∂N_i/∂η ∂η/∂r), usando J^{-1}.",
                                    "Avalie em um ponto de integração (ex: Gauss point) para valores numéricos.",
                                    "Verifique consistência dimensional: derivadas têm unidade 1/comprimento."
                                  ],
                                  "verification": "Compute ∂N_i/∂r e ∂N_i/∂z para todos i em um ponto específico e confira soma Σ ∂N_i/∂r = 0 (propriedade geométrica).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software simbólico (MATLAB/SymPy), tabela de pontos de Gauss, coordenadas exemplo dos nós.",
                                  "tips": "Use coordenadas naturais para simplicidade em triângulo linear.",
                                  "learningObjective": "Dominar o cálculo de gradientes das funções de forma em coordenadas curvilíneas.",
                                  "commonMistakes": "Inverter o Jacobiano incorretamente; ignorar dependência em r para ε_θ."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar e verificar a matriz B",
                                  "subSteps": [
                                    "Estruture B (4x6): linhas para ε_r, ε_z, γ_rz, ε_θ; colunas para u_r1,u_z1,...,u_r3,u_z3.",
                                    "Preencha: para coluna u_r,i: [∂N_i/∂r, ∂N_i/∂z, 1/r]^T na posição i; para u_z,i: [0, ∂N_i/∂z, ∂N_i/∂r]^T.",
                                    "Escreva B = [B1 B2 B3] onde cada Bi é 4x2.",
                                    "Verifique propriedades: rigidez (rank), simetria se aplicável.",
                                    "Teste com deslocamento rígido: B deve dar deformações zero."
                                  ],
                                  "verification": "Multiplique B por vetor de deslocamento rígido (ex: translação) e confirme {ε}=0.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Matriz em Excel ou MATLAB para montagem.",
                                  "tips": "Rotule colunas explicitamente para evitar confusão entre u_r e u_z.",
                                  "learningObjective": "Construir a matriz B completa e validá-la.",
                                  "commonMistakes": "Colocar termos errados nas colunas de u_z; esquecer /r em ε_θ para todas as linhas de u_r."
                                }
                              ],
                              "practicalExample": "Para um elemento triangular com nós (r1=1,z1=0), (r2=2,z2=0), (r3=1.5,z3=1), avalie B no centro (r=1.5,z=0.333). Calcule ∂N1/∂r=-0.5, etc., resultando em B = [[-0.5,0,0.5,0,0,0], [0,0,0,1,0,-1], [0,0.5,0,0,0.5,0], [1/1.5,0,0,0,-1/1.5,0], ...] (valores aproximados; compute exato).",
                              "finalVerifications": [
                                "Dimensões de B: 4 linhas x 6 colunas.",
                                "Para deslocamento rígido em r (todos u_r,i=const, u_z=0), ε_r=ε_z=γ_rz=ε_θ=0.",
                                "Soma das colunas de u_r: [0,0,0, Σ(1/r) N_i mas ajustado]=0 para rigidez.",
                                "Derivadas de N somam zero: Σ ∂N_i/∂r =0, Σ ∂N_i/∂z=0.",
                                "ε_θ linha tem apenas entradas nas colunas u_r,i como N_i / r.",
                                "B é consistente em um ponto de Gauss."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas expressões de deformação (incluindo ε_θ = u_r/r).",
                                "Correção no cálculo de derivadas via Jacobiano.",
                                "Estrutura matricial B com blocos 4x2 por nó.",
                                "Verificação de testes de patch (deformação zero para movimentos rígidos).",
                                "Clareza na derivação passo a passo.",
                                "Uso correto de notação vetorial {ε}=B{d}."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo multivariável e Jacobianos.",
                                "Programação: Implementação numérica em MATLAB para automação de B.",
                                "Física: Teoria de deformação em mecânica dos contínuos.",
                                "Engenharia Civil: Similar para elementos axissimétricos em barragens."
                              ],
                              "realWorldApplication": "Usado na análise de vasos de pressão, tubos sob pressão interna, rotores de turbinas e estruturas axisimétricas como silos, onde simulações FEM predizem tensões com precisão sem malha 3D completa."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.2.1.2.3",
                            "name": "Montar a matriz de rigidez do elemento",
                            "description": "Integrar numericamente ou analiticamente k_e = ∫_A B^T D B t r dA, onde t é espessura circunferencial implícita, D é matriz constitutiva plano-tensão, e r é o peso de integração axissimétrica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir geometria, propriedades materiais e pontos de integração do elemento triangular axissimétrico",
                                  "subSteps": [
                                    "Identificar as coordenadas (r, z) dos três nós do elemento triangular.",
                                    "Especificar propriedades materiais: módulo de elasticidade E, coeficiente de Poisson ν, e espessura unitária implícita t=1.",
                                    "Escolher esquema de integração Gauss axissimétrica (ex: 1 ou 3 pontos de Gauss por direção r-z).",
                                    "Calcular pesos e posições dos pontos de Gauss (ξ, η) e o Jacobiano J para transformação isoparamétrica.",
                                    "Verificar o determinante do Jacobiano |J| > 0 em todos os pontos para garantir orientação correta."
                                  ],
                                  "verification": "Listar coordenadas dos nós, matriz D e tabela de pontos/pesos de Gauss; plotar o elemento para visualização.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Folha de coordenadas do elemento",
                                    "Tabela de Gauss axissimétrica (7 pontos)",
                                    "Calculadora ou MATLAB para Jacobiano"
                                  ],
                                  "tips": [
                                    "Use coordenadas normalizadas para simplicidade inicial.",
                                    "Sempre verifique unidades consistentes (r em metros)."
                                  ],
                                  "learningObjective": "Compreender a configuração inicial do elemento axissimétrico e preparar dados para integração.",
                                  "commonMistakes": [
                                    "Confundir coordenadas r-z com x-y cartesianas.",
                                    "Esquecer o fator r no peso de integração."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar funções de forma N e matriz de derivadas para o elemento triangular",
                                  "subSteps": [
                                    "Escrever funções de forma lineares em coordenadas naturais: N1 = (1-ξ-η), N2=ξ, N3=η.",
                                    "Computar derivadas ∂N/∂ξ e ∂N/∂η em cada ponto de Gauss.",
                                    "Calcular Jacobiana geométrica [J] = [∂r/∂ξ ∂r/∂η; ∂z/∂ξ ∂z/∂η] usando coordenadas dos nós.",
                                    "Obter derivadas globais [∂N/∂r; ∂N/∂z] = [J]^(-1) * [∂N/∂ξ; ∂N/∂η].",
                                    "Verificar que as funções de forma somam 1 e derivadas são consistentes com geometria."
                                  ],
                                  "verification": "Tabela de N, ∂N/∂r, ∂N/∂z em pontos de Gauss; soma de N_i =1 em todos os pontos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Matriz de funções de forma padrão para triângulo",
                                    "Software simbólico como SymPy ou MATLAB"
                                  ],
                                  "tips": [
                                    "Implemente em loop para múltiplos pontos Gauss.",
                                    "Inverta J numericamente com cuidado para precisão."
                                  ],
                                  "learningObjective": "Dominar a derivação de funções de forma e suas derivadas em domínio mestre para elementos axissimétricos.",
                                  "commonMistakes": [
                                    "Erro na inversão da Jacobiana.",
                                    "Usar derivadas locais sem transformar para globais."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a matriz de deformação-dislocamento B para plano-tensão axissimétrico",
                                  "subSteps": [
                                    "Definir operadores de deformação axissimétrica: ε_r = ∂u/∂r, ε_z = ∂w/∂z, ε_θ = u/r, γ_rz = ∂u/∂z + ∂w/∂r.",
                                    "Montar matriz B (6x6 para 3 nós, 2 gls/nó): linhas para ε_r, ε_z, ε_θ, γ_rz por nó.",
                                    "Preencher B com ∂N_i/∂r, ∂N_i/∂z, N_i/r para cada grau de liberdade u_i, w_i.",
                                    "Avaliar B em cada ponto de Gauss usando derivadas do passo anterior.",
                                    "Verificar simetria e continuidade das deformações no centro (r=0)."
                                  ],
                                  "verification": "Matriz B impressa para um ponto Gauss; verificar ε_θ = u/r correto e nulo em r=0 para u=0.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": [
                                    "Template da matriz B axissimétrica",
                                    "Folha de operadores de strain",
                                    "MATLAB para montagem matricial"
                                  ],
                                  "tips": [
                                    "Cuide do termo N_i/r que é singular em r=0; use limite ou pontos Gauss afastados.",
                                    "B deve ser 6x6 para elemento completo."
                                  ],
                                  "learningObjective": "Construir corretamente a matriz B que relaciona deformações a deslocamentos em formulação axissimétrica.",
                                  "commonMistakes": [
                                    "Omitir ε_θ = u/r.",
                                    "Usar operadores plano-strain em vez de plano-stress."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir matriz constitutiva D para material isotrópico em plano-tensão",
                                  "subSteps": [
                                    "Escrever D (3x3) para plano-tensão: D11=D22 = E/(1-ν^2), D12=D21=ν E/(1-ν^2), D33 = E/(2(1+ν)).",
                                    "Confirmar que D relaciona {ε_r, ε_z, γ_rz} a {σ_r, σ_z, τ_rz} (ignorando σ_θ na integração).",
                                    "Verificar propriedades: traço(D) consistente com bulk modulus.",
                                    "Expandir para voigt notation se necessário para multiplicação matricial.",
                                    "Testar com strain unitário para stress esperado."
                                  ],
                                  "verification": "Matriz D numérica impressa; multiplicar por vetor strain unitário e comparar com fórmulas analíticas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Fórmulas padrão de D plano-tensão",
                                    "Tabela de propriedades E, ν para aço/alumínio"
                                  ],
                                  "tips": [
                                    "Para plano-tensão, divisor é (1-ν^2), não (1-ν-2ν^2).",
                                    "Mantenha simetria de D."
                                  ],
                                  "learningObjective": "Formular a matriz constitutiva D adequada para problemas axissimétricos em plano-tensão.",
                                  "commonMistakes": [
                                    "Confundir plano-tensão com plano-strain (D33 diferente).",
                                    "Usar E errada para unidades."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Realizar integração numérica/analítica para montar a matriz de rigidez ke",
                                  "subSteps": [
                                    "Inicializar ke = zeros(6,6).",
                                    "Para cada ponto Gauss: computar detJ, r_gauss, B^T * D * B, multiplicar por 2π * r * t * detJ * w_r * w_z.",
                                    "Acumular contribuição em ke para todos os pontos.",
                                    "Verificar simetria de ke (ke ≈ ke^T dentro de tolerância 1e-10).",
                                    "Normalizar por t se explícito, e validar energia de deformação positiva definida."
                                  ],
                                  "verification": "Matriz ke final simétrica, trace(ke)>0, e comparação com solução analítica para caso simples.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": [
                                    "Código MATLAB/Python pronto para loop Gauss",
                                    "Validador de simetria (norm(ke-ke')/norm(ke))"
                                  ],
                                  "tips": [
                                    "Fator 2π r é crucial para revolução.",
                                    "Use quadratura de alta ordem perto de r=0."
                                  ],
                                  "learningObjective": "Executar a integração Gauss axissimétrica para obter ke = ∫ B^T D B t 2π r dA corretamente.",
                                  "commonMistakes": [
                                    "Esquecer 2π r ou detJ.",
                                    "Índices errados na acumulação de ke."
                                  ]
                                }
                              ],
                              "practicalExample": "Para um elemento triangular com nós (r,z): (1,0), (2,0), (1.5,1), E=200 GPa, ν=0.3, use 1 ponto Gauss (ξ=1/3,η=1/3, w=1). Compute B em centro, D, e ke parcial. Resultado esperado: ke[1,1] ≈ 1.23e6 N/m (verificar com código).",
                              "finalVerifications": [
                                "Matriz ke é simétrica e definida positiva (autovalores >0).",
                                "Ordem 6x6 correta para 3 nós x 2 gls.",
                                "Comparação com ke de elemento vizinho ou analítico <5% erro.",
                                "Fator r integrado corretamente (ke escala com tamanho radial).",
                                "Energia de deformação u^T ke u >0 para u≠0."
                              ],
                              "assessmentCriteria": [
                                "Precisão da matriz B em pontos Gauss (erro <1e-6).",
                                "Correção da integração (fator 2π r t detJ w incluso).",
                                "Simetria e positividade de ke.",
                                "Implementação numérica reproduz analítica para caso teste.",
                                "Explicação física dos termos (ε_θ impacto).",
                                "Eficiência computacional (tempo <1s para 7 pontos)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Integração numérica Gauss e Jacobianas.",
                                "Programação: Loops matriciais em MATLAB/Python para EF.",
                                "Física: Mecânica dos sólidos, tensão circunferencial em rotação.",
                                "Engenharia de Materiais: Comportamento isotrópico plano-tensão."
                              ],
                              "realWorldApplication": "Cálculo de rigidez para análise de eixos rotativos em turbinas, vasos de pressão cilíndricos sob carga interna, ou anéis de pistão em motores, permitindo simulação FEM de deformações em estruturas axisimétricas como tubos e discos."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "34.2.1.3",
                        "name": "Montagem Global e Aplicações",
                        "description": "Integração de elementos axissimétricos em malhas globais, tratamento de condições de contorno e solução para problemas de tensão em geometrias rotacionais.",
                        "specificSkills": [
                          {
                            "id": "34.2.1.3.1",
                            "name": "Montar matrizes globais para malha axissimétrica",
                            "description": "Superpor matrizes de rigidez elementares k_e em K global, considerando conectividade nodal no plano (r,z), e vetor de forças nodais com contribuições de tração e corpo ponderadas por r.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a malha axissimétrica e mapear conectividade nodal",
                                  "subSteps": [
                                    "Definir os nós da malha no plano (r,z) com coordenadas cilíndricas.",
                                    "Numerar os nós globalmente e listar a conectividade de cada elemento (nós locais para globais).",
                                    "Identificar graus de liberdade por nó (geralmente ur e uz para deslocamentos radial e axial).",
                                    "Criar uma tabela de mapeamento local-global para cada elemento.",
                                    "Verificar se a malha respeita a simetria axial (r >= 0)."
                                  ],
                                  "verification": "Tabela de conectividade completa e mapeamento local-global sem erros de indexação.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel milimetrado ou software de pré-processador (ex: Gmsh)",
                                    "Folha de cálculo (Excel ou Python pandas)"
                                  ],
                                  "tips": "Comece com malhas simples (2-3 elementos) para validar o mapeamento antes de complexas.",
                                  "learningObjective": "Compreender a importância da conectividade nodal em problemas axissimétricos.",
                                  "commonMistakes": [
                                    "Confundir nós locais com globais",
                                    "Esquecer que r=0 é o eixo de simetria",
                                    "Não considerar múltiplos graus de liberdade por nó"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar matrizes globais e calcular matrizes elementares k_e",
                                  "subSteps": [
                                    "Inicializar K global como matriz zero de tamanho (n_gdl x n_gdl), onde n_gdl é total de graus de liberdade.",
                                    "Inicializar vetor F global como zero de tamanho n_gdl.",
                                    "Para cada elemento, calcular a matriz de rigidez local k_e usando integrais ponderadas por 2πr (fator circunferencial).",
                                    "Aplicar condições de contorno iniciais (ex: fixar uz no eixo r=0).",
                                    "Armazenar k_e transformada para cada elemento."
                                  ],
                                  "verification": "K e F têm dimensões corretas e são inicializados em zero; k_e calculada para pelo menos um elemento.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Calculadora ou MATLAB/Python para integrais numéricas",
                                    "Fórmulas de elementos axissimétricos (triangular ou quadrilateral)"
                                  ],
                                  "tips": "Use formato esparso para K em implementações computacionais para eficiência.",
                                  "learningObjective": "Dominar a inicialização e o cálculo de contribuições elementares com fator r.",
                                  "commonMistakes": [
                                    "Esquecer o fator 2πr nas integrais de k_e",
                                    "Dimensões erradas de K (não multiplicar por gdl/nó)",
                                    "Não zerar adequadamente as matrizes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Superpor matrizes elementares em K global considerando conectividade",
                                  "subSteps": [
                                    "Para cada elemento, transformar k_e local para posições globais usando o vetor de conectividade.",
                                    "Adicionar (somar) as entradas de k_e transformada às posições correspondentes em K global.",
                                    "Repetir para todos os elementos, acumulando contribuições sobrepostas.",
                                    "Aplicar condições de contorno modificando linhas/colunas de K e F para nós fixos.",
                                    "Verificar simetria de K (K(i,j) == K(j,i))."
                                  ],
                                  "verification": "K global é simétrica e positiva definida; contribuições de elementos adjacentes somadas corretamente.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": [
                                    "Software de MEF (ex: FEniCS, código próprio em Python com NumPy/SciPy)",
                                    "Matriz esparsa viewer"
                                  ],
                                  "tips": "Implemente um loop sobre elementos com scatter-add para evitar loops aninhados ineficientes.",
                                  "learningObjective": "Executar a montagem global corretamente com sobreposição nodal.",
                                  "commonMistakes": [
                                    "Erro de indexação no mapeamento local-global",
                                    "Não aplicar simetria ao adicionar k_e",
                                    "Esquecer condições de contorno após montagem"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar vetor de forças nodais F com contribuições ponderadas",
                                  "subSteps": [
                                    "Calcular forças de corpo (ex: gravidade) integradas sobre o volume elementar com peso 2πr.",
                                    "Calcular trações superficiais nos contornos, ponderadas por r e comprimento circunferencial.",
                                    "Mapear forças elementares para nodais globais usando conectividade e somar em F.",
                                    "Adicionar cargas pontuais nos nós, se aplicável.",
                                    "Verificar equilíbrio: para nós sem cargas externas, F deve ser zero inicialmente."
                                  ],
                                  "verification": "F tem tamanho correto; forças ponderadas por r somam corretamente nos nós compartilhados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Mesmos do Step 3",
                                    "Dados de cargas (tração, volume)"
                                  ],
                                  "tips": "Sempre integre forças com o jacobiano incluindo r para consistência com k_e.",
                                  "learningObjective": "Incorporar corretamente cargas distribuídas em domínios axissimétricos.",
                                  "commonMistakes": [
                                    "Omitir peso r nas forças de tração ou corpo",
                                    "Confundir tração normal/tangencial",
                                    "Não somar forças sobrepostas em nós"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma malha com 3 elementos triangulares axissimétricos modelando um tanque cilíndrico sob pressão interna (p=10 MPa em r interno), calcule k_e para elemento 1 (nós 1,2,3 com r=[0.1,0.2,0.15]m), transforme usando conectividade [1,2,4], adicione a K 6x6 (2 gdl/nó), e some forças de pressão F=[0, p*A/2, ...] ponderadas por r médio.",
                              "finalVerifications": [
                                "Dimensões de K e F corretas (n_gdl x n_gdl e n_gdl).",
                                "K é simétrica e tem banda-esparsa consistente com malha.",
                                "Soma das contribuições elementares recupera k_e isolada.",
                                "Forças em nós no eixo (r=0) têm componente ur=0 por simetria.",
                                "Condições de contorno aplicadas: linhas de K zeradas e F ajustado.",
                                "Teste de equilíbrio: K * u_test ≈ F_test para solução conhecida trivial."
                              ],
                              "assessmentCriteria": [
                                "Correta inclusão do fator 2πr em todas as integrais elementares.",
                                "Mapeamento local-global sem erros de indexação em >95% dos casos.",
                                "Simetria e semi-bandalarga de K preservadas.",
                                "Ponderação correta de trações e forças volumétricas por r.",
                                "Aplicação precisa de condições de contorno Dirichlet.",
                                "Eficiência computacional: uso de estruturas esparsas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (montagem de matrizes esparsas e simétricas).",
                                "Programação: Implementação numérica em Python (NumPy/SciPy) ou MATLAB.",
                                "Física: Mecânica dos sólidos e equilíbrio em coordenadas cilíndricas.",
                                "Geometria Computacional: Geração de malhas em plano (r,z).",
                                "Engenharia de Software: Pré e pós-processadores MEF."
                              ],
                              "realWorldApplication": "Análise de tensões em tubulações pressurizadas, rotores de turbinas, reservatórios cilíndricos e componentes rotativos, reduzindo problemas 3D simétricos a 2D para economia computacional em simulações industriais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.2.1.3.2",
                            "name": "Implementar condições de contorno axissimétricas",
                            "description": "Aplicar restrições em nós de simetria (u_r=0 no eixo r=0), apoios e cargas distribuídas, resolvendo o sistema K u = F via métodos diretos ou iterativos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e identificar condições de contorno em problemas axissimétricos",
                                  "subSteps": [
                                    "Estude a geometria axissimétrica e a simetria radial (revolução em torno do eixo z).",
                                    "Identifique nós no eixo de simetria (r=0) onde u_r deve ser zero devido à simetria.",
                                    "Liste condições típicas: apoios fixos (u_r=u_z=0), apoios rolantes (u_r=0 ou u_z=0) e simetria.",
                                    "Revise a formulação fraca do problema para entender como condições de Dirichlet e Neumann são impostas.",
                                    "Desenhe um esquema de malha 2D (r-z) destacando nós com restrições."
                                  ],
                                  "verification": "Crie um diagrama anotado da malha com todas as condições de contorno identificadas corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Elementos Finitos (ex: Zienkiewicz)",
                                    "Software de MEF como Abaqus ou código Python/FEniCS",
                                    "Papel e lápis para esboços"
                                  ],
                                  "tips": [
                                    "Sempre comece pela simetria para reduzir o modelo.",
                                    "Visualize o modelo 3D a partir da seção 2D."
                                  ],
                                  "learningObjective": "Identificar precisamente todas as condições de contorno necessárias para um problema axissimétrico.",
                                  "commonMistakes": [
                                    "Ignorar a condição u_r=0 no eixo r=0, levando a rotações espúrias.",
                                    "Confundir coordenadas r-z com x-y cartesianas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar restrições de simetria e apoios nos graus de liberdade",
                                  "subSteps": [
                                    "Selecione os nós afetados: eixo r=0 para simetria (fixar u_r), superfícies de apoio para u_r ou u_z=0.",
                                    "Modifique a matriz de rigidez global K removendo ou penalizando linhas/colunas dos GLs fixos (método de eliminação).",
                                    "Ajuste o vetor de forças F para valores prescritos (ex: deslocamento imposto).",
                                    "Implemente em código: use flags booleanas por nó para aplicar restrições.",
                                    "Teste em uma malha simples: verifique se os nós fixos têm u=0 após resolução."
                                  ],
                                  "verification": "Execute uma simulação estática simples e confirme que deslocamentos nos nós restritos são exatamente zero.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código fonte em Python/MATLAB com biblioteca MEF (ex: FEniCS, SciPy)",
                                    "Malha de teste com 10-20 elementos"
                                  ],
                                  "tips": [
                                    "Use penalidade alta (1e12) para métodos de Lagrange se eliminação for complexa.",
                                    "Mantenha índices de GLs em um vetor para rastreamento."
                                  ],
                                  "learningObjective": "Aplicar corretamente restrições Dirichlet em nós específicos sem alterar a simetria do problema.",
                                  "commonMistakes": [
                                    "Aplicar u_z=0 no eixo em vez de u_r=0.",
                                    "Esquecer de ajustar F para valores não-zero prescritos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar cargas distribuídas e montar o vetor de forças F",
                                  "subSteps": [
                                    "Defina cargas: pressão interna (Neumann em r constante), peso próprio ou tração axial.",
                                    "Integre numericamente as cargas sobre elementos: use Gauss quadratura para ∫ N^T t dS no contorno.",
                                    "Some contribuições elementares ao vetor global F, considerando fator 2πr para axissimétrico.",
                                    "Implemente funções de carga (ex: pressão p(r,z)) e associe a faces de elementos.",
                                    "Valide montagem: some normas de F_elemento e compare com analítico para casos simples."
                                  ],
                                  "verification": "Calcule F analiticamente para um elemento carregado e compare com o numérico (erro <1%).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação de integração Gauss",
                                    "Código MEF com rotina de montagem de cargas"
                                  ],
                                  "tips": [
                                    "Lembre-se do jacobiano 2πr na integração de contorno.",
                                    "Teste com carga uniforme primeiro."
                                  ],
                                  "learningObjective": "Montar corretamente o vetor F considerando a geometria axissimétrica.",
                                  "commonMistakes": [
                                    "Esquecer o fator 2πr, subestimando cargas.",
                                    "Integrar sobre área em vez de contorno para Neumann."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver o sistema Ku=F e validar a solução",
                                  "subSteps": [
                                    "Escolha solver: direto (LU para malhas pequenas) ou iterativo (CG para grandes).",
                                    "Aplique BCs no sistema: elimine GLs fixos ou use pré-condicionadores.",
                                    "Resolva u = K^{-1} F e compute reações nos apoios.",
                                    "Plote campos: u_r, u_z, von Mises; verifique continuidade e simetria.",
                                    "Compare com solução analítica (ex: cilindro grosso sob pressão) para validação."
                                  ],
                                  "verification": "Erro relativo L2 da solução <5% vs. analítica; u_r=0 no eixo confirmado.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Bibliotecas SciPy.linalg ou PETSc",
                                    "Solução analítica de referência (Lamé para cilindros)"
                                  ],
                                  "tips": [
                                    "Use solvers esparsos para eficiência.",
                                    "Monitore resíduo ||Ku - F||."
                                  ],
                                  "learningObjective": "Resolver sistemas lineares de MEF axissimétrico de forma estável e precisa.",
                                  "commonMistakes": [
                                    "Solver não convergindo por K mal-condicionada sem BCs adequadas.",
                                    "Ignorar fator de escala 2πr na pós-processamento."
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente condições de contorno para um cilindro oco sob pressão interna: u_r=0 no eixo r=0 (simetria), u_z=0 na base (apoio), pressão p=10 MPa na face interna. Monte K (100 nós), aplique F e resolva com solver direto; verifique tensão radial via solução de Lamé.",
                              "finalVerifications": [
                                "Deslocamentos u_r exatos zero em todos nós do eixo r=0.",
                                "Reações nos apoios equilibram as cargas totais aplicadas.",
                                "Campos de tensão/deslocamento simétricos e contínuos na malha.",
                                "Erro de energia <1% vs. solução analítica para benchmark.",
                                "Tempo de resolução razoável (<10s para 1000 GLs).",
                                "Visualização 3D rotacional confirma simetria."
                              ],
                              "assessmentCriteria": [
                                "Precisão das restrições: 100% dos nós fixos com u=0.",
                                "Correção do vetor F: norma coincide com cálculo analítico.",
                                "Estabilidade numérica: resíduo <1e-10.",
                                "Eficiência: escolha adequada de solver para tamanho de malha.",
                                "Validação: comparação quantitativa com analítica.",
                                "Código modular e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Solução de sistemas esparsos simétricos positivos definidos.",
                                "Programação Numérica: Integração Gauss e manipulação de matrizes esparsas.",
                                "Física/Mecânica dos Sólidos: Teoria de elasticidade axissimétrica.",
                                "Matemática Computacional: Métodos iterativos como Conjugado Gradiente.",
                                "Visualização de Dados: Plotagem de campos em coordenadas polares."
                              ],
                              "realWorldApplication": "Análise de vasos de pressão, tubos sob carga interna/externa, rotores de turbinas e pistões em motores, onde simetria reduz tempo computacional em 50-90% comparado a 3D full."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.2.1.3.3",
                            "name": "Analisar resultados em problemas axissimétricos",
                            "description": "Extrair tensões e deformações pós-processamento, validar contra soluções analíticas como cilindro grosso de Lamé, e discutir convergência com refinamento de malha.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Realizar pós-processamento para extrair tensões e deformações",
                                  "subSteps": [
                                    "Acesse o módulo de pós-processamento no software de EF (ex: ANSYS ou Abaqus).",
                                    "Selecione o modelo axissimétrico resolvido e visualize contornos de tensões radiais (σ_r), tangenciais (σ_θ) e deformações equivalentes.",
                                    "Extraia valores numéricos em pontos críticos, como interface interna/externa do cilindro.",
                                    "Gere gráficos de distribuição ao longo do raio (path plot).",
                                    "Exporte dados para planilha para análise quantitativa."
                                  ],
                                  "verification": "Verifique se gráficos e tabelas mostram distribuições suaves sem singularidades artificiais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de EF (ANSYS, Abaqus)",
                                    "Modelo axissimétrico resolvido",
                                    "Planilha (Excel)"
                                  ],
                                  "tips": "Use escalas logarítmicas para deformações pequenas e filtre ruídos de malha.",
                                  "learningObjective": "Dominar extração e visualização de campos de tensão/deformação em problemas axissimétricos.",
                                  "commonMistakes": [
                                    "Ignorar coordenadas axissimétricas ao plotar",
                                    "Não normalizar deformações",
                                    "Confundir σ_r com σ_θ"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Validar resultados numéricos contra soluções analíticas de Lamé",
                                  "subSteps": [
                                    "Calcule soluções analíticas para cilindro grosso sob pressão interna: σ_r = (a²P)/(b²-a²) * (1 - b²/r²), σ_θ = (a²P)/(b²-a²) * (1 + b²/r²).",
                                    "Compare valores numéricos extraídos com analíticos em 5-10 pontos ao longo do raio.",
                                    "Calcule erros percentuais: |numérico - analítico| / analítico * 100%.",
                                    "Plote curvas superpostas (numérica vs. analítica).",
                                    "Documente discrepâncias e justifique (ex: efeitos de malha)."
                                  ],
                                  "verification": "Erros percentuais < 5% em pontos principais confirmam validade.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Fórmulas de Lamé (livro ou PDF)",
                                    "Planilha para cálculos analíticos",
                                    "Gráficos do Step 1"
                                  ],
                                  "tips": "Use raios normalizados (r/a) para facilitar comparação.",
                                  "learningObjective": "Aplicar e validar soluções exatas em contextos numéricos axissimétricos.",
                                  "commonMistakes": [
                                    "Erro nos limites de integração de Lamé",
                                    "Unidades inconsistentes (MPa vs. Pa)",
                                    "Comparar em malha grosseira"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar convergência com refinamento de malha",
                                  "subSteps": [
                                    "Gere 3-4 malhas progressivamente refinadas (ex: elementos de 1000 a 10000).",
                                    "Resolva o modelo para cada malha e extraia tensões em pontos fixos.",
                                    "Plote tensão vs. número de elementos ou tamanho de malha (h-refinement).",
                                    "Calcule taxa de convergência: log(|erro_coarse - erro_fine|) / log(h_ratio).",
                                    "Identifique malha convergida (variação < 2%)."
                                  ],
                                  "verification": "Curvas de convergência monotônicas e platô em malha fina.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de EF com meshing",
                                    "Modelos do Step 1",
                                    "Script para automação (opcional)"
                                  ],
                                  "tips": "Refine localmente na interface para eficiência computacional.",
                                  "learningObjective": "Compreender e quantificar convergência em simulações axissimétricas.",
                                  "commonMistakes": [
                                    "Refinamento uniforme ineficiente",
                                    "Não fixar seed de solver",
                                    "Ignorar DOFs totais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e discutir implicações",
                                  "subSteps": [
                                    "Resuma discrepâncias: analítica vs. numérica e convergência.",
                                    "Discuta fontes de erro (malha, elementos, condições de contorno).",
                                    "Relacione com comportamento físico: concentração de tensão na interface interna.",
                                    "Proponha melhorias (ex: elementos quadráticos).",
                                    "Redija relatório com figuras e conclusões."
                                  ],
                                  "verification": "Relatório cobre todos aspectos com evidências quantitativas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Resultados dos steps anteriores",
                                    "Editor de texto/LaTeX"
                                  ],
                                  "tips": "Use ANOVA para análise estatística de erros se múltiplas simulações.",
                                  "learningObjective": "Desenvolver habilidades de interpretação crítica em EF axissimétrico.",
                                  "commonMistakes": [
                                    "Atribuir erros só à malha",
                                    "Não quantificar incertezas",
                                    "Omitir limitações do modelo"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um cilindro grosso de aço (a=50mm, b=100mm) sob pressão interna P=100MPa, extraia σ_θ máx=250MPa na interface interna, valide com Lamé (erro<1%), e mostre convergência com malha de 5000 elementos.",
                              "finalVerifications": [
                                "Erros de validação <5% vs. Lamé em 80% dos pontos.",
                                "Curva de convergência atinge platô com variação <2%.",
                                "Relatório inclui gráficos superpostos e tabela de erros.",
                                "Discussão identifica pelo menos 2 fontes de discrepância.",
                                "Valores físicos coerentes (ex: σ_θ > σ_r internamente).",
                                "Exportação de dados numéricos funcional."
                              ],
                              "assessmentCriteria": [
                                "Precisão quantitativa na extração e comparação (30%).",
                                "Qualidade da análise de convergência (25%).",
                                "Profundidade da interpretação e discussão (20%).",
                                "Clareza de visualizações e relatório (15%).",
                                "Correção conceitual em axissimétrico (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Soluções analíticas elásticas (equações diferenciais).",
                                "Física: Teoria da elasticidade e equilíbrio em coordenadas cilíndricas.",
                                "Computação: Programação para automação de mesh studies.",
                                "Materiais: Propriedades isotrópicas em simulações."
                              ],
                              "realWorldApplication": "Validação de tubulações pressurizadas em indústrias petroquímica e aeroespacial, garantindo segurança contra falhas por tensão excessiva em vasos de pressão."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.3",
                    "name": "Elementos Isoparamétricos: Quadrilátero de 4 Nós",
                    "description": "Construção de elementos quadriláteros isoparamétricos com 4 nós, incluindo mapeamento geométrico e interpolação.",
                    "individualConcepts": [
                      {
                        "id": "34.2.4.1",
                        "name": "Funções de Forma Bilineares",
                        "description": "Definição e propriedades das funções de interpolação N_i(ξ, η) no domínio natural quadrilátero de referência, variando ξ e η de -1 a 1.",
                        "specificSkills": [
                          {
                            "id": "34.2.4.1.1",
                            "name": "Definir as funções de forma N_i",
                            "description": "Escrever explicitamente as expressões das quatro funções de forma para os nós: N1 = (1-ξ)(1-η)/4, N2 = (1+ξ)(1-η)/4, N3 = (1+ξ)(1+η)/4, N4 = (1-ξ)(1+η)/4.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o elemento mestre quadrilátero de 4 nós e coordenadas naturais ξ-η",
                                  "subSteps": [
                                    "Revise o conceito de elemento isoparamétrico e domínio de referência (elemento mestre).",
                                    "Identifique o domínio ξ-η como um quadrado unitário de [-1,1] x [-1,1].",
                                    "Localize as posições dos 4 nós: N1(-1,-1), N2(1,-1), N3(1,1), N4(-1,1).",
                                    "Desenhe o domínio ξ-η com os nós numerados.",
                                    "Explique por que usamos coordenadas naturais para simplificar a formulação."
                                  ],
                                  "verification": "Desenho correto do domínio com nós posicionados e rótulos ξ, η.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Gráficos de referência de elementos finitos"
                                  ],
                                  "tips": "Sempre comece visualizando o domínio para fixar as posições dos nós.",
                                  "learningObjective": "Compreender o mapeamento do elemento mestre e posições nodais em ξ-η.",
                                  "commonMistakes": [
                                    "Confundir ordem dos nós (ex: N1 como (1,-1))",
                                    "Usar [0,1] em vez de [-1,1]"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Recordar propriedades das funções de forma e interpolação bilinear",
                                  "subSteps": [
                                    "Liste as propriedades: Ni = 1 no nó i, Ni = 0 nos outros nós, soma Ni = 1 em todo domínio.",
                                    "Entenda a interpolação bilinear como produto de funções lineares 1D em ξ e η.",
                                    "Revise funções de Lagrange 1D: L_left = (1-ξ)/2, L_right = (1+ξ)/2.",
                                    "Explique como bilinear surge do produto: N(ξ,η) = L(ξ) * L(η).",
                                    "Discuta continuidade e completude para elementos bilineares."
                                  ],
                                  "verification": "Lista escrita corretamente das 4 propriedades principais das funções de forma.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de anotações",
                                    "Livro de Elementos Finitos (capítulo de isoparamétricos)"
                                  ],
                                  "tips": "Use tabelas para comparar propriedades em cada nó para memorizar.",
                                  "learningObjective": "Dominar as propriedades matemáticas que as funções de forma devem satisfazer.",
                                  "commonMistakes": [
                                    "Esquecer soma Ni=1 (partição da unidade)",
                                    "Confundir bilinear com linear simples"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar as expressões das funções de forma N1 a N4",
                                  "subSteps": [
                                    "Para N1(-1,-1): multiplique L_left(ξ) * L_bottom(η) = [(1-ξ)/2] * [(1-η)/2] = (1-ξ)(1-η)/4.",
                                    "Para N2(1,-1): L_right(ξ) * L_bottom(η) = [(1+ξ)/2] * [(1-η)/2] = (1+ξ)(1-η)/4.",
                                    "Para N3(1,1): L_right(ξ) * L_top(η) = [(1+ξ)/2] * [(1+η)/2] = (1+ξ)(1+η)/4.",
                                    "Para N4(-1,1): L_left(ξ) * L_top(η) = [(1-ξ)/2] * [(1+η)/2] = (1-ξ)(1+η)/4.",
                                    "Escreva todas as quatro expressões em uma tabela organizada."
                                  ],
                                  "verification": "Expressões derivadas corretamente e tabuladas para cada Ni.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Software simbólico como Mathematica ou SymPy (opcional)"
                                  ],
                                  "tips": "Derive 1D primeiro, depois multiplique; verifique fator 1/4 para normalização.",
                                  "learningObjective": "Derivar explicitamente as funções bilineares a partir de produtos Lagrangeanos.",
                                  "commonMistakes": [
                                    "Esquecer o /4 na normalização",
                                    "Trocar sinais de ξ ou η"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar as funções de forma e praticar avaliação",
                                  "subSteps": [
                                    "Avalie Ni em cada nó: confirme Ni=1 no próprio, 0 nos outros.",
                                    "Verifique soma N1+N2+N3+N4=1 em um ponto interno, ex: (0,0).",
                                    "Calcule Ni em ponto gaussiano, ex: (0,0) deve dar 1/4 cada.",
                                    "Desenhe curvas de Ni=0.5 para visualizar comportamento bilinear.",
                                    "Compare com funções lineares para notar diferenças."
                                  ],
                                  "verification": "Tabela de verificação com valores corretos em 5 pontos chave.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Planilha Excel ou MATLAB para avaliação numérica"
                                  ],
                                  "tips": "Use pontos extremos e centro para verificações rápidas.",
                                  "learningObjective": "Validar numericamente as propriedades das funções derivadas.",
                                  "commonMistakes": [
                                    "Erro aritmético em avaliações",
                                    "Não verificar soma=1 em múltiplos pontos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um elemento quadrilátero com nós em posições físicas (x1,y1)=(0,0), (x2,y2)=(1,0), etc., para aproximar u(ξ=0,η=0), compute u = N1(0,0)u1 + N2(0,0)u2 + ... onde cada Ni(0,0)=0.25, interpolando valores nodais uniformemente.",
                              "finalVerifications": [
                                "N1(-1,-1)=1, N1 em outros nós=0",
                                "Expressões exatas: N1=(1-ξ)(1-η)/4, etc.",
                                "Soma N1+N2+N3+N4=1 para qualquer (ξ,η)",
                                "Avaliação correta em centro (0,0): todos Ni=0.25",
                                "Comportamento bilinear confirmado por curvas Ni=constante",
                                "Derivação via produto Lagrange 1D correta"
                              ],
                              "assessmentCriteria": [
                                "Precisão das expressões N_i (100% match)",
                                "Correta derivação de produtos bilineares",
                                "Verificação completa das 4 propriedades em nós",
                                "Uso correto de coordenadas [-1,1]",
                                "Tabela ou derivação organizada e legível",
                                "Identificação de pelo menos 2 erros comuns evitados"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções de Lagrange e interpolação polinomial",
                                "Programação: Implementação em código FEA (ex: Python/FEniCS)",
                                "Física: Aproximação de campos em mecânica dos sólidos",
                                "Geometria Computacional: Mapeamento isoparamétrico"
                              ],
                              "realWorldApplication": "Essas funções são fundamentais em softwares de análise por elementos finitos (ANSYS, Abaqus) para mapear elementos reais distorcidos para o domínio mestre, permitindo simulações precisas de tensões em placas 2D, como em design de pontes ou componentes automotivos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.2.4.1.2",
                            "name": "Verificar propriedades das funções de forma",
                            "description": "Demonstrar que as funções satisfazem a partição da unidade (∑N_i = 1) e a condição delta de Kronecker (N_i no nó j = δ_ij).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o domínio de referência e as funções de forma bilineares",
                                  "subSteps": [
                                    "Identifique o domínio mestre quadrilátero isoparamétrico: -1 ≤ ξ ≤ 1, -1 ≤ η ≤ 1.",
                                    "Escreva as funções de forma para os 4 nós: N1 = (1-ξ)(1-η)/4, N2 = (1+ξ)(1-η)/4, N3 = (1+ξ)(1+η)/4, N4 = (1-ξ)(1+η)/4.",
                                    "Desenhe o quadrilátero mestre e rotule os nós: (1: (-1,-1), 2: (1,-1), 3: (1,1), 4: (-1,1)).",
                                    "Explique o papel das funções de forma na interpolação de campos nos elementos finitos.",
                                    "Liste as propriedades esperadas: partição da unidade e delta de Kronecker."
                                  ],
                                  "verification": "Confirme que as expressões das funções N_i estão corretas comparando com referências padrão de MEF.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis, calculadora, livro-texto de Elementos Finitos (ex: Zienkiewicz).",
                                  "tips": "Use coordenadas normalizadas para simplificar cálculos simbólicos.",
                                  "learningObjective": "Compreender a geometria e notação das funções bilineares no domínio de referência.",
                                  "commonMistakes": "Confundir ordem dos nós ou fator de normalização (sempre /4 para soma=1)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar a partição da unidade analiticamente",
                                  "subSteps": [
                                    "Calcule a soma S(ξ,η) = N1 + N2 + N3 + N4 expandindo algebraicamente.",
                                    "Simplifique a expressão: colete termos em ξ e η separadamente.",
                                    "Mostre que S(ξ,η) = [(1-ξ) + (1+ξ) + (1+ξ) + (1-ξ)](1+η + 1-η + 1+η + 1-η)/16 = 1.",
                                    "Avalie S em pontos arbitrários, ex: centro (0,0), bordas (1,0), para confirmação.",
                                    "Discuta por que essa propriedade garante interpolação consistente."
                                  ],
                                  "verification": "A soma simplificada deve resultar exatamente em 1 para qualquer (ξ,η).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel quadriculado, software simbólico opcional (ex: SymPy ou Mathematica).",
                                  "tips": "Expanda produtos (1±ξ)(1±η) sistematicamente para evitar erros aritméticos.",
                                  "learningObjective": "Demonstrar que ∑N_i = 1 em todo o domínio, provando partição da unidade.",
                                  "commonMistakes": "Esquecer o fator 1/4 em cada N_i, levando a soma=4."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a condição delta de Kronecker nos nós",
                                  "subSteps": [
                                    "Liste as coordenadas dos nós: nó1 (-1,-1), nó2 (1,-1), nó3 (1,1), nó4 (-1,1).",
                                    "Para cada nó j, avalie N_i(ξ_j, η_j) para i=1 a 4.",
                                    "Exemplo nó1: N1(-1,-1)=1, N2=0, N3=0, N4=0; repita para outros nós.",
                                    "Construa uma tabela resumindo N_i(nó j) = δ_ij.",
                                    "Verifique numericamente com valores decimais para precisão."
                                  ],
                                  "verification": "Matriz de valores nos nós deve ser identidade 4x4.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Planilha Excel ou tabela em papel, calculadora.",
                                  "tips": "Substitua diretamente nas funções; nos nós, dois fatores se tornam zero exceto o próprio.",
                                  "learningObjective": "Confirmar que cada função N_i é 1 apenas no seu nó e 0 nos outros.",
                                  "commonMistakes": "Erro de sinal em (1±ξ) ou (1±η) ao avaliar nos nós opostos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar numericamente e discutir implicações",
                                  "subSteps": [
                                    "Escolha 3-5 pontos internos/arbitrários (ex: (0,0), (0.5,0.5), (-0.5,1)) e verifique ∑N_i=1.",
                                    "Para cada ponto, confirme N_i nos nós via tabela ou código simples.",
                                    "Implemente uma verificação rápida em Python/MATLAB plotando as funções.",
                                    "Explique como falhas nessas propriedades afetam precisão em MEF.",
                                    "Resuma as verificações em um relatório curto."
                                  ],
                                  "verification": "Todos os pontos testados satisfazem ∑N_i=1 e delta nos nós.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Computador com Python/MATLAB (opcional), gráfico das funções.",
                                  "tips": "Use meshgrid para plots 3D das N_i para visualização intuitiva.",
                                  "learningObjective": "Aplicar verificações numéricas e relacionar propriedades à robustez do elemento.",
                                  "commonMistakes": "Pontos fora do domínio [-1,1]; sempre clamp valores."
                                }
                              ],
                              "practicalExample": "Para um quadrilátero de 4 nós com funções bilineares, calcule no centro (0,0): cada N_i=0.25, soma=1. No nó1 (-1,-1): N1=1, outras=0. Isso garante interpolação precisa de deslocamentos em uma placa sob carga.",
                              "finalVerifications": [
                                "Soma das funções de forma é exatamente 1 em pelo menos 5 pontos testados.",
                                "Cada N_i é 1 no seu nó e 0 nos outros três nós.",
                                "Expansão algébrica confirma partição da unidade independentemente de ξ,η.",
                                "Tabela ou matriz delta de Kronecker está completa e correta.",
                                "Gráfico ou plot mostra comportamentos esperados sem anomalias.",
                                "Relatório resume provas sem erros aritméticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na derivação da soma (sem simplificações erradas).",
                                "Correção em avaliações nos nós (100% identidade).",
                                "Uso de múltiplos pontos de verificação numérica.",
                                "Explicação clara da importância das propriedades para MEF.",
                                "Ausência de erros comuns como fatores de escala incorretos.",
                                "Qualidade do relatório e visualizações (se aplicável)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra simbólica e propriedades de funções polinomiais.",
                                "Programação: Implementação numérica em Python/MATLAB para validação.",
                                "Física: Aplicação em mecânica dos sólidos e métodos numéricos.",
                                "Geometria Computacional: Mapeamentos isoparamétricos."
                              ],
                              "realWorldApplication": "Em simulações de elementos finitos para análise estrutural (ex: ANSYS), essas propriedades garantem que deslocamentos e tensões sejam interpolados corretamente em malhas de elementos quadrilaterais, evitando erros em projetos de pontes, aviões ou carrocerias automotivas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.2.4.1.3",
                            "name": "Avaliar funções em pontos do domínio natural",
                            "description": "Calcular valores das N_i em pontos específicos como centro (0,0), lados médios e nós, e interpretar geometricamente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o domínio natural e as funções de forma bilineares",
                                  "subSteps": [
                                    "Identifique o domínio natural do elemento quadrilátero de 4 nós: ξ e η variando de -1 a 1.",
                                    "Escreva as expressões das funções de forma N1, N2, N3 e N4: N1 = (1-ξ)(1-η)/4, etc.",
                                    "Verifique as propriedades básicas: soma das Ni = 1 em qualquer ponto (partição da unidade).",
                                    "Desenhe o domínio natural e marque os nós: (-1,-1), (1,-1), (1,1), (-1,1).",
                                    "Confirme que Ni = 1 no seu próprio nó e 0 nos outros nós."
                                  ],
                                  "verification": "Confirme que você pode recitar as 4 funções de forma e suas propriedades principais sem olhar as notas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para desenhos",
                                    "Folha de referência com funções de forma"
                                  ],
                                  "tips": [
                                    "Use cores diferentes para cada Ni ao desenhar",
                                    "Memorize a forma simétrica das funções"
                                  ],
                                  "learningObjective": "Compreender a estrutura matemática das funções de forma bilineares no domínio natural.",
                                  "commonMistakes": [
                                    "Confundir os sinais de ξ e η nas funções",
                                    "Esquecer a divisão por 4",
                                    "Ignorar a ordem dos nós"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar funções de forma nos nós do domínio natural",
                                  "subSteps": [
                                    "Selecione o nó 1 (-1,-1) e substitua ξ=-1, η=-1 em todas as Ni.",
                                    "Calcule: N1 deve ser 1, N2=N3=N4=0.",
                                    "Repita para nó 2 (1,-1), nó 3 (1,1) e nó 4 (-1,1).",
                                    "Registre os valores em uma tabela: linhas para pontos, colunas para Ni.",
                                    "Verifique a propriedade de Kronecker δij (Ni=δij nos nós)."
                                  ],
                                  "verification": "Tabela completa com valores corretos nos 4 nós, soma=1 em cada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico como SymPy",
                                    "Tabela em Excel ou papel"
                                  ],
                                  "tips": [
                                    "Substitua valores passo a passo para evitar erros aritméticos",
                                    "Sempre verifique soma das Ni=1"
                                  ],
                                  "learningObjective": "Calcular precisamente as funções de forma nos nós e validar propriedades de interpolação.",
                                  "commonMistakes": [
                                    "Erros de sinal ao substituir ±1",
                                    "Não verificar soma das funções"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar funções de forma no centro do domínio natural (0,0)",
                                  "subSteps": [
                                    "Substitua ξ=0, η=0 em todas as Ni.",
                                    "Calcule: cada Ni = (1*1)/4 = 0.25.",
                                    "Confirme que todas as 4 funções valem 1/4 no centro.",
                                    "Interprete: no centro, cada nó contribui igualmente (25%).",
                                    "Desenhe vetores de Ni no centro para visualização."
                                  ],
                                  "verification": "Cálculo exato mostrando Ni=0.25 para i=1 a 4, com soma=1.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel quadriculado para plotagem",
                                    "Calculadora"
                                  ],
                                  "tips": [
                                    "Simplifique a expressão antes de substituir: (1-0)(1-0)/4=1/4",
                                    "Pense em simetria"
                                  ],
                                  "learningObjective": "Demonstrar a contribuição igual das funções no baricentro do elemento.",
                                  "commonMistakes": [
                                    "Calcular errado como 1/2 em vez de 1/4",
                                    "Esquecer normalização"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar funções de forma nos pontos médios dos lados",
                                  "subSteps": [
                                    "Identifique pontos: médio inferior (0,-1), direito (1,0), superior (0,1), esquerdo (-1,0).",
                                    "Para (0,-1): N1=N2=0.5, N3=N4=0.",
                                    "Calcule para cada ponto e preencha a tabela.",
                                    "Verifique soma=1 e zeros nas funções opostas.",
                                    "Compare com nós: transições suaves."
                                  ],
                                  "verification": "Tabela com 4 pontos médios corretos, todos somando 1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela expandida",
                                    "Gráfico do domínio com pontos marcados"
                                  ],
                                  "tips": [
                                    "Lados opostos têm Ni=0",
                                    "Use fatoração: para η=-1, (1-η)=2, etc."
                                  ],
                                  "learningObjective": "Calcular e tabular valores em pontos de Gauss ou de integração típicos.",
                                  "commonMistakes": [
                                    "Confundir ordem dos lados",
                                    "Erros em (1±ξ)(1±η)"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar geometricamente os valores das funções de forma",
                                  "subSteps": [
                                    "Plote as Ni sobre o domínio natural (superfícies ou curvas de nível).",
                                    "Nos nós: picos unitários, zeros nos outros.",
                                    "Centro: plano constante 0.25.",
                                    "Lados médios: 0.5 nos adjacentes, zero nos opostos (linear ao longo do lado).",
                                    "Discuta interpolação: u(ξ,η) = Σ Ni ui aproxima campo contínuo."
                                  ],
                                  "verification": "Diagrama ou descrição escrita mostrando interpretação visual correta.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de plotagem como MATLAB/Mathematica ou Python (Matplotlib)",
                                    "Papel para esboço manual"
                                  ],
                                  "tips": [
                                    "Visualize como 'pirâmides' suavizadas nos nós",
                                    "Use animação se possível para ξ fixo"
                                  ],
                                  "learningObjective": "Conectar cálculos numéricos à geometria e física da interpolação em MEF.",
                                  "commonMistakes": [
                                    "Ignorar variação bilinear (não linear)",
                                    "Não ligar a partição da unidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um elemento quadrilátero com deslocamentos nos nós: u1=1, u2=0, u3=-1, u4=0. No centro (0,0), todas Ni=0.25, então u(0,0)=(1+0-1+0)/4=0, interpretado como interpolação média nula geometricamente simétrica.",
                              "finalVerifications": [
                                "Tabela completa com valores corretos em 9 pontos (4 nós, 4 médios, 1 centro).",
                                "Soma das Ni=1 verificada em todos os pontos calculados.",
                                "Plot ou descrição geométrica mostrando picos nos nós e transições bilineares.",
                                "Exemplo prático resolvido com interpretação física correta.",
                                "Explicação verbal de como Ni interpolam um campo escalar.",
                                "Identificação de pontos de Gauss padrão usando esses valores."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos (erro <0.01 em valores exatos).",
                                "Completude da tabela e verificações de soma.",
                                "Qualidade da interpretação geométrica e visual.",
                                "Correta ligação com propriedades de MEF (interpolação, partição da unidade).",
                                "Criatividade no exemplo prático e aplicação.",
                                "Clareza na documentação e avoidance de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementar avaliação em Python/MATLAB para automação.",
                                "Geometria Computacional: Mapeamento isoparamétrico ξ-η para x-y físico.",
                                "Física: Interpretação como pesos em simulações de tensão/deformação.",
                                "Cálculo Numérico: Pontos de Gauss para integração numérica em MEF.",
                                "Visualização de Dados: Plotar superfícies Ni com ferramentas como ParaView."
                              ],
                              "realWorldApplication": "Em software de Elementos Finitos como ANSYS ou Abaqus, essas avaliações determinam deslocamentos/tensões em pontos de interesse dentro de elementos, essenciais para análise estrutural de peças mecânicas como vigas, placas ou carrocerias de veículos sob carga."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "34.2.4.2",
                        "name": "Mapeamento Geométrico Isoparamétrico",
                        "description": "Transformação das coordenadas do domínio natural (ξ, η) para o domínio físico real (x, y) utilizando as funções de forma.",
                        "specificSkills": [
                          {
                            "id": "34.2.4.2.1",
                            "name": "Construir expressões de mapeamento x(ξ,η) e y(ξ,η)",
                            "description": "Escrever x = ∑N_i x_i e y = ∑N_i y_i, onde (x_i, y_i) são coordenadas dos nós do elemento real.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar coordenadas dos nós e domínio isoparamétrico",
                                  "subSteps": [
                                    "Liste os quatro nós do quadrilátero isoparamétrico de 4 nós (Q4), rotulados como 1 (ξ=-1,η=-1), 2 (ξ=1,η=-1), 3 (ξ=1,η=1), 4 (ξ=-1,η=1).",
                                    "Anote as coordenadas reais (x_i, y_i) para cada nó i=1 a 4.",
                                    "Desenhe o elemento real no plano xy e o domínio de referência no plano ξ-η (quadrado [-1,1] x [-1,1]).",
                                    "Confirme a ordem anti-horária dos nós para consistência.",
                                    "Marque as posições dos nós no domínio isoparamétrico."
                                  ],
                                  "verification": "Verifique se as 8 coordenadas (x1,y1 a x4,y4) estão corretamente associadas aos nós e desenhos coincidem com definições padrão.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel quadriculado, lápis, calculadora, diagrama de referência de elemento Q4.",
                                  "tips": "Use rótulos claros como 'Nó 1: (-1,-1)' para evitar confusão visual.",
                                  "learningObjective": "Compreender a relação entre nós reais e domínio isoparamétrico.",
                                  "commonMistakes": "Invertir ordem dos nós ou confundir domínio real com isoparamétrico."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir as funções de forma (shape functions) N_i(ξ,η)",
                                  "subSteps": [
                                    "Escreva N1(ξ,η) = (1 - ξ)(1 - η)/4.",
                                    "Escreva N2(ξ,η) = (1 + ξ)(1 - η)/4.",
                                    "Escreva N3(ξ,η) = (1 + ξ)(1 + η)/4.",
                                    "Escreva N4(ξ,η) = (1 - ξ)(1 + η)/4.",
                                    "Verifique propriedades: soma Ni = 1 e Ni=1 apenas no nó i, zero nos outros."
                                  ],
                                  "verification": "Substitua valores nos nós (ex: ξ=-1,η=-1 → N1=1, outros=0) e confirme.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Folha de fórmulas de elementos finitos, software simbólico como Mathematica ou papel.",
                                  "tips": "Memorize o padrão bilinear: produto de funções lineares em ξ e η divididas por 4.",
                                  "learningObjective": "Dominar as funções de interpolação bilineares para Q4.",
                                  "commonMistakes": "Esquecer o fator /4 ou sinais errados nos termos lineares."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a expressão de mapeamento x(ξ,η)",
                                  "subSteps": [
                                    "Escreva a forma geral: x(ξ,η) = Σ_{i=1}^4 N_i(ξ,η) * x_i.",
                                    "Expanda: x(ξ,η) = N1 x1 + N2 x2 + N3 x3 + N4 x4.",
                                    "Substitua as Ni: x(ξ,η) = [(1-ξ)(1-η)/4] x1 + [(1+ξ)(1-η)/4] x2 + [(1+ξ)(1+η)/4] x3 + [(1-ξ)(1+η)/4] x4.",
                                    "Opcionalmente, expanda os produtos para forma polinomial em ξ e η.",
                                    "Verifique em um nó: ex, ξ=-1,η=-1 → x = x1."
                                  ],
                                  "verification": "Avalie nos quatro nós: deve recuperar x_i exato em cada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Coordenadas dos nós do passo 1, lápis e borracha para expansões.",
                                  "tips": "Mantenha simbólico primeiro; substitua números só para verificação.",
                                  "learningObjective": "Aplicar interpolação para coordenada x no mapeamento geométrico.",
                                  "commonMistakes": "Associar Ni errado ao x_i ou esquecer soma de quatro termos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir a expressão de mapeamento y(ξ,η) e validar",
                                  "subSteps": [
                                    "Escreva y(ξ,η) = Σ_{i=1}^4 N_i(ξ,η) * y_i, usando as mesmas Ni do passo 2.",
                                    "Expanda: y(ξ,η) = N1 y1 + N2 y2 + N3 y3 + N4 y4, substituindo Ni.",
                                    "Verifique interpolação nos nós para y_i.",
                                    "Confirme que mapeamento é bijetivo (injetivo e sobrejetivo) para elemento convexo.",
                                    "Teste um ponto interno, ex: centro (0,0) → média das coordenadas."
                                  ],
                                  "verification": "Substituições nos nós recuperam (x_i, y_i) corretos; centro dá barycentro.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Expressões de x do passo 3, tabela de verificação nos nós.",
                                  "tips": "Copie Ni de x para y para evitar recálculo desnecessário.",
                                  "learningObjective": "Completar mapeamento geométrico isoparamétrico para ambas coordenadas.",
                                  "commonMistakes": "Usar diferentes Ni para x e y ou erros de transcrição."
                                }
                              ],
                              "practicalExample": "Para um quadrilátero com nós: 1(0,0), 2(2,0), 3(2,1), 4(0,1). Então x(ξ,η) = [(1-ξ)(1-η)/4]*0 + [(1+ξ)(1-η)/4]*2 + [(1+ξ)(1+η)/4]*2 + [(1-ξ)(1+η)/4]*0 = (1-η)/2 * (1+ξ). Similar para y(ξ,η) = (1-ξ)(1+η)/4 *1 + (1+ξ)(1+η)/4 *1 = (1+η)/2.",
                              "finalVerifications": [
                                "x(ξ,η) e y(ξ,η) têm exatamente quatro termos com Ni corretos.",
                                "Avaliação nos quatro nós recupera coordenadas reais exatas.",
                                "Soma das funções de forma é 1 para qualquer (ξ,η).",
                                "No centro (ξ=0,η=0), obtém-se o baricentro do quadrilátero.",
                                "Expressões são bilineares em ξ e η.",
                                "Mapeamento preserva convexidade do elemento."
                              ],
                              "assessmentCriteria": [
                                "Precisão das funções de forma Ni (100% correto).",
                                "Correta associação de Ni a coordenadas x_i/y_i.",
                                "Expansão simbólica sem erros algébricos.",
                                "Verificações nos nós realizadas e corretas.",
                                "Forma final simplificada quando possível.",
                                "Explicação clara da interpolação isoparamétrica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Interpolação polinomial bilinear e funções de base.",
                                "Programação: Implementação em código para solvers FEA (ex: Python com NumPy).",
                                "Física: Modelagem de campos escalares em mecânica dos sólidos.",
                                "Geometria Computacional: Transformações de coordenadas em CAD."
                              ],
                              "realWorldApplication": "Essas expressões são fundamentais em softwares de Elementos Finitos (ANSYS, Abaqus) para mapear elementos curvos reais para integração numérica em simulações de tensão, vibração e fluxo em estruturas mecânicas como placas, carrocerias de veículos e componentes aeroespaciais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "34.2.4.1"
                            ]
                          },
                          {
                            "id": "34.2.4.2.2",
                            "name": "Calcular a matriz Jacobiana J",
                            "description": "Derivar a matriz Jacobiana 2x2 com elementos ∂x/∂ξ, ∂x/∂η, ∂y/∂ξ, ∂y/∂η, usando derivadas das funções de forma.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o mapeamento isoparamétrico e funções de forma",
                                  "subSteps": [
                                    "Revise as funções de forma N1, N2, N3, N4 para o elemento quadrilátero de 4 nós no domínio ξ-η (-1 a 1).",
                                    "Exemplo: N1 = (1-ξ)(1-η)/4; N2 = (1+ξ)(1-η)/4; N3 = (1+ξ)(1+η)/4; N4 = (1-ξ)(1+η)/4.",
                                    "Expresse as coordenadas globais x(ξ,η) = Σ Ni(ξ,η) xi e y(ξ,η) = Σ Ni(ξ,η) yi, onde xi,yi são coordenadas nodais.",
                                    "Identifique o ponto de avaliação, como centro (ξ=0,η=0) ou pontos de Gauss.",
                                    "Anote as coordenadas nodais de um exemplo simples."
                                  ],
                                  "verification": "Confirme que x(ξ,η) e y(ξ,η) interpolam corretamente as coordenadas nodais em ξ,η = ±1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Elementos Finitos (ex: Zienkiewicz)",
                                    "Calculadora"
                                  ],
                                  "tips": "Comece sempre avaliando no centro do elemento para simplicidade inicial.",
                                  "learningObjective": "Compreender como as funções de forma mapeiam o domínio mestre para o elemento real.",
                                  "commonMistakes": [
                                    "Confundir ordem dos nós (1,2,3,4: inferior esquerdo, inferior direito, superior direito, superior esquerdo)",
                                    "Esquecer o domínio ξ,η de -1 a 1."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular as derivadas das funções de forma ∂N_i/∂ξ e ∂N_i/∂η",
                                  "subSteps": [
                                    "Derive cada Ni em relação a ξ: ∂N1/∂ξ = -(1-η)/4; ∂N2/∂ξ = (1-η)/4; etc.",
                                    "Derive cada Ni em relação a η: ∂N1/∂η = -(1-ξ)/4; ∂N2/∂η = -(1+ξ)/4; etc.",
                                    "Avalie essas derivadas no ponto desejado (ex: ξ=0, η=0).",
                                    "Tabule as derivadas em uma tabela para N1 a N4.",
                                    "Verifique somando: Σ ∂Ni/∂ξ deve ser 0 e Σ ∂Ni/∂η = 0 (propriedade das funções de forma bilineares)."
                                  ],
                                  "verification": "As derivadas somam zero em cada direção, confirmando consistência.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora para simplificações algébricas"
                                  ],
                                  "tips": "Use a regra da cadeia ou derive diretamente; memorize as formas padrão para quadrilátero.",
                                  "learningObjective": "Dominar o cálculo analítico das derivadas das funções de forma no domínio natural.",
                                  "commonMistakes": [
                                    "Erros de sinal nas derivadas (ex: esquecer o sinal negativo em N1)",
                                    "Não avaliar no ponto específico antes de prosseguir."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar os elementos da matriz Jacobiana",
                                  "subSteps": [
                                    "Calcule ∂x/∂ξ = Σ (∂Ni/∂ξ * xi) para i=1 a 4.",
                                    "Calcule ∂x/∂η = Σ (∂Ni/∂η * xi).",
                                    "Calcule ∂y/∂ξ = Σ (∂Ni/∂ξ * yi).",
                                    "Calcule ∂y/∂η = Σ (∂Ni/∂η * yi).",
                                    "Insira os valores numéricos usando coordenadas nodais exemplo."
                                  ],
                                  "verification": "Cada elemento é uma soma ponderada correta das derivadas vezes coordenadas nodais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de derivadas do passo anterior",
                                    "Coordenadas nodais anotadas"
                                  ],
                                  "tips": "Mantenha os termos simbólicos antes de numerizar para verificar.",
                                  "learningObjective": "Aplicar a definição da Jacobiana como derivadas parciais das coordenadas globais.",
                                  "commonMistakes": [
                                    "Trocar xi por yi ou ξ por η nos produtos",
                                    "Esquecer de somar todos os 4 nós."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar a matriz J e verificar sua qualidade",
                                  "subSteps": [
                                    "Forme J = [ ∂x/∂ξ  ∂x/∂η ; ∂y/∂ξ  ∂y/∂η ].",
                                    "Calcule det(J) = (∂x/∂ξ)(∂y/∂η) - (∂x/∂η)(∂y/∂ξ); deve ser positivo e não-zero.",
                                    "Interprete: J transforma gradientes do domínio mestre para o real.",
                                    "Verifique se J é constante ou varia (para quadrilátero linear, varia).",
                                    "Compare com valor esperado para elemento referência."
                                  ],
                                  "verification": "det(J) > 0 e J é 2x2 com elementos corretos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Matriz esboçada",
                                    "Calculadora para determinante"
                                  ],
                                  "tips": "Se det(J)=0, o elemento está degenerado; ajuste nós.",
                                  "learningObjective": "Ensamblar e validar a matriz Jacobiana para uso em integração numérica.",
                                  "commonMistakes": [
                                    "Ordem errada das linhas/colunas de J",
                                    "Determinante com sinal invertido."
                                  ]
                                }
                              ],
                              "practicalExample": "Para um quadrilátero com nós: (x1,y1)=(0,0), (x2,y2)=(2,0), (x3,y3)=(2,1), (x4,y4)=(0,1). No centro (0,0): ∂Ni/∂ξ = [-0.25,0.25,0.25,-0.25], ∂Ni/∂η=[-0.25,-0.25,0.25,0.25]. Então ∂x/∂ξ=1, ∂x/∂η=0, ∂y/∂ξ=0, ∂y/∂η=1; J=identidade, det(J)=1.",
                              "finalVerifications": [
                                "Matriz J é 2x2 com elementos ∂x/∂ξ, ∂x/∂η, ∂y/∂ξ, ∂y/∂η corretos.",
                                "Derivadas das funções de forma somam zero em cada direção.",
                                "det(J) > 0 e não-zero, indicando mapeamento válido.",
                                "Cálculos reproduzem coordenadas nodais via integração inversa.",
                                "Resultados consistentes em pelo menos dois pontos de Gauss.",
                                "Nenhum erro aritmético em somas ou produtos."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos das derivadas das funções de forma (100% correto).",
                                "Correta aplicação da soma para elementos de J (sem omissões).",
                                "Cálculo exato do determinante e interpretação qualitativa.",
                                "Clareza na documentação: tabelas e passos mostrados.",
                                "Uso correto de coordenadas nodais sem transposições.",
                                "Validação em exemplo numérico com det(J) positivo."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Multivariável: Derivadas parciais e Jacobianas.",
                                "Álgebra Linear: Multiplicação matricial e determinantes.",
                                "Programação Numérica: Implementação em Python/MATLAB para automação.",
                                "Física: Transformação de tensores em mecânica dos sólidos.",
                                "Geometria Computacional: Mapeamentos paramétricos em CAD."
                              ],
                              "realWorldApplication": "Na análise de elementos finitos em softwares como ANSYS ou Abaqus, a Jacobiana J é essencial para transformar integrais de Gauss do domínio mestre para o elemento real, garantindo precisão em simulações de tensão, deformação e fluxo em estruturas mecânicas 2D."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.2.4.1"
                            ]
                          },
                          {
                            "id": "34.2.4.2.3",
                            "name": "Verificar invertibilidade do mapeamento",
                            "description": "Calcular det(J) em pontos de integração e garantir que seja positivo para evitar distorções inválidas do elemento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o elemento isoparamétrico e identificar pontos de integração",
                                  "subSteps": [
                                    "Defina as coordenadas globais (x, y) dos 4 nós do quadrilátero no domínio físico.",
                                    "Estabeleça o domínio de referência (ξ, η) de [-1,1] x [-1,1] para o elemento isoparamétrico.",
                                    "Liste os pontos de integração de Gauss para integração 2x2: (±1/√3, ±1/√3).",
                                    "Calcule as funções de forma N_i(ξ, η) para cada nó i=1 a 4.",
                                    "Verifique se as funções de forma somam 1 e interpolam corretamente."
                                  ],
                                  "verification": "Confirme que as coordenadas dos nós formam um quadrilátero válido sem cruzamentos e que os pontos de Gauss estão corretamente posicionados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de coordenadas do elemento",
                                    "Tabela de pontos de Gauss 2x2",
                                    "Calculadora ou software como MATLAB/Python"
                                  ],
                                  "tips": "Sempre desenhe o elemento para visualizar distorções potenciais.",
                                  "learningObjective": "Compreender o mapeamento do domínio de referência para o físico e preparar pontos de avaliação.",
                                  "commonMistakes": "Confundir ordem dos nós (sentido anti-horário padrão) ou usar pontos de Gauss errados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a matriz Jacobiana J nos pontos de integração",
                                  "subSteps": [
                                    "Compute as derivadas das funções de forma: ∂N_i/∂ξ e ∂N_i/∂η em cada ponto de Gauss.",
                                    "Forme o vetor de derivadas: [∂N/∂ξ, ∂N/∂η] para os 4 nós.",
                                    "Calcule as coordenadas derivadas: ∂x/∂ξ = Σ N_i,ξ * x_i; ∂y/∂ξ = Σ N_i,ξ * y_i; similar para ∂/∂η.",
                                    "Monte a matriz Jacobiana J = [[∂x/∂ξ, ∂y/∂ξ], [∂x/∂η, ∂y/∂η]] para cada ponto.",
                                    "Verifique se J é 2x2 e não singular visualmente (determinante não zero aproximado)."
                                  ],
                                  "verification": "J deve ser calculada corretamente em todos os 4 pontos de Gauss, com valores numéricos consistentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Funções de forma bilineares",
                                    "Coordenadas nodais",
                                    "Planilha de cálculo ou código NumPy"
                                  ],
                                  "tips": "Use notação matricial para eficiência: J = [x ηξ] [N,ξ; N,η], onde ηξ são derivadas.",
                                  "learningObjective": "Dominar o cálculo das derivadas parciais no mapeamento isoparamétrico.",
                                  "commonMistakes": "Erros em derivadas das funções de forma (ex: ∂N1/∂ξ = (1-η)/4) ou soma incorreta das contribuições nodais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar o determinante det(J) e verificar sua positividade",
                                  "subSteps": [
                                    "Calcule det(J) = (∂x/∂ξ)(∂y/∂η) - (∂y/∂ξ)(∂x/∂η) para cada ponto de Gauss.",
                                    "Registre os valores de det(J) em uma tabela para os 4 pontos.",
                                    "Verifique se det(J) > 0 em TODOS os pontos (tolerância 1e-6 para numéricos).",
                                    "Identifique o menor det(J); se próximo de zero, avalie singularidade.",
                                    "Se algum det(J) ≤ 0, marque o elemento como inválido."
                                  ],
                                  "verification": "Todos det(J) > 0 confirmados numericamente e tabela completa.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Matriz J calculada",
                                    "Calculadora simbólica opcional (SymPy)"
                                  ],
                                  "tips": "det(J) > 0 garante orientação consistente e mapeamento localmente injetivo.",
                                  "learningObjective": "Aplicar cálculo de determinante para testar invertibilidade local do mapeamento.",
                                  "commonMistakes": "Inverter termos no det(J) ou ignorar sinal negativo em um único ponto."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar resultados e propor correções para distorções",
                                  "subSteps": [
                                    "Resuma: 'Elemento válido' se todos det(J)>0; senão, 'Invertido/Distorcido'.",
                                    "Visualize o elemento: plote nós e contorno para detectar cruzamentos.",
                                    "Se inválido, sugira ajustes: mover nós para melhorar qualidade (ângulos <180°).",
                                    "Calcule métricas extras: min(det(J)), aspect ratio.",
                                    "Documente relatório com tabela de det(J) e recomendação."
                                  ],
                                  "verification": "Relatório escrito confirmando validade ou propondo fixes, com plot opcional.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software de plotagem (Matplotlib)",
                                    "Template de relatório"
                                  ],
                                  "tips": "Elementos com det(J)<0 causam loops infinitos ou resultados errados em FEM.",
                                  "learningObjective": "Interpretar det(J) para qualidade de malha e debugar elementos ruins.",
                                  "commonMistakes": "Aceitar det(J) negativo como 'pequeno erro numérico' sem correção."
                                }
                              ],
                              "practicalExample": "Considere um quadrilátero com nós: (0,0), (2,0), (2,1), (0,1.5). Nos pontos de Gauss 2x2, calcule J e det(J): tipicamente todos >0 (válido). Altere nó4 para (1, -0.5): det(J) negativo em alguns pontos (invertido, visualize cruzamento).",
                              "finalVerifications": [
                                "Todos 4 pontos de Gauss têm det(J) calculado corretamente.",
                                "Sinal de det(J) positivo em todos os pontos (com tolerância).",
                                "Tabela de resultados completa e sem erros aritméticos.",
                                "Interpretação correta: válido/inválido.",
                                "Visualização confirma ausência de distorções.",
                                "Relatório inclui métricas min(det(J)) e sugestões."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de J e det(J): 100% correto nos 4 pontos.",
                                "Compreensão conceitual: explica por que det(J)>0 é necessário.",
                                "Identificação correta de elementos inválidos em exemplos.",
                                "Eficiência: tempo dentro do estimado, sem erros comuns.",
                                "Criatividade em correções: propõe ajustes viáveis.",
                                "Documentação clara com tabelas e plots."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo multivariável (Jacobianas, determinantes).",
                                "Programação: Implementar em Python/MATLAB para automação FEM.",
                                "Física: Deformações em continuum mechanics (evitar flips).",
                                "Computação Gráfica: Mapeamentos paramétricos em superfícies.",
                                "Estatística: Análise de qualidade de malha (distribuição det(J))."
                              ],
                              "realWorldApplication": "Em simulações FEM (ex: ANSYS, Abaqus), verificar det(J)>0 previne falhas de convergência, resultados espúrios em análises de tensão/fluxo, garantindo malhas robustas para projetos de estruturas aeronáuticas ou automotivas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.2.4.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "34.2.4.3",
                        "name": "Interpolação de Campos e Derivadas",
                        "description": "Interpolação isoparamétrica de campos como deslocamentos e cálculo de derivadas espaciais via regra da cadeia para uso em matrizes de rigidez.",
                        "specificSkills": [
                          {
                            "id": "34.2.4.3.1",
                            "name": "Interpolar campos escalares e vetoriais",
                            "description": "Expressar deslocamentos u = ∑N_i u_i, v = ∑N_i v_i no domínio físico usando mapeamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender as Funções de Interpolação (Shape Functions) para o Elemento Quadrilátero de 4 Nós",
                                  "subSteps": [
                                    "Revise as coordenadas naturais (ξ, η) no domínio isoparamétrico (-1 ≤ ξ, η ≤ 1).",
                                    "Defina as funções de shape N_i para i=1 a 4: N1 = (1-ξ)(1-η)/4, N2 = (1+ξ)(1-η)/4, N3 = (1+ξ)(1+η)/4, N4 = (1-ξ)(1+η)/4.",
                                    "Verifique que ∑ N_i = 1 em qualquer ponto interno do elemento.",
                                    "Plote ou esboce as funções N_i em pontos Gauss para visualização.",
                                    "Confirme a propriedade de partição da unidade plotando em uma grade."
                                  ],
                                  "verification": "As funções N_i somam 1 em pontos aleatórios (ξ,η) e são zero nos nós opostos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel quadriculado, calculadora, software como MATLAB ou Python (Matplotlib para plotagem).",
                                  "tips": "Use simetria do quadrilátero para memorizar as fórmulas das N_i.",
                                  "learningObjective": "Dominar as funções de interpolação base para elementos isoparamétricos.",
                                  "commonMistakes": "Confundir índices dos nós ou esquecer o fator 1/4 nas fórmulas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpolar um Campo Escalar no Domínio Isoparamétrico",
                                  "subSteps": [
                                    "Defina um campo escalar φ com valores nos nós: φ_i para i=1 a 4.",
                                    "Expresse φ(ξ,η) = ∑_{i=1}^4 N_i(ξ,η) φ_i.",
                                    "Calcule φ em pontos específicos, como centro (0,0) ou pontos de Gauss (±1/√3, ±1/√3).",
                                    "Mapeie para o domínio físico usando x = ∑ N_i x_i, y = ∑ N_i y_i, e avalie φ(x,y).",
                                    "Compare valores interpolados com uma função analítica conhecida para validação."
                                  ],
                                  "verification": "φ interpolado coincide com valor exato em nós e é suave internamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilha Excel ou Python (NumPy para cálculos matriciais), coordenadas dos nós do elemento.",
                                  "tips": "Implemente em código para automação; use vetores de nós para multiplicação matricial.",
                                  "learningObjective": "Aplicar interpolação escalar usando shape functions no domínio físico.",
                                  "commonMistakes": "Esquecer de mapear (ξ,η) para (x,y) antes de reportar φ(x,y)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estender a Interpolação para Campos Vetoriais (Deslocamentos u e v)",
                                  "subSteps": [
                                    "Defina deslocamentos nodais: u_i e v_i para cada nó i=1 a 4.",
                                    "Interpole componentes separadamente: u(ξ,η) = ∑ N_i u_i, v(ξ,η) = ∑ N_i v_i.",
                                    "Mapeie para domínio físico: u(x,y) = u(ξ(x,y),η(x,y)), similar para v.",
                                    "Calcule o vetor deslocamento \\vec{d} = (u,v) em pontos de interesse.",
                                    "Verifique continuidade entre elementos adjacentes nos nós compartilhados."
                                  ],
                                  "verification": "Componentes u e v são contínuas nos nós e vetores coincidem em interfaces.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software FEA básico (ex: FreeFEM ou código Python customizado), dados nodais de u_i, v_i.",
                                  "tips": "Trate u e v como campos escalares independentes para simplificar.",
                                  "learningObjective": "Expressar deslocamentos vetoriais via soma ponderada por shape functions.",
                                  "commonMistakes": "Misturar componentes u e v ou usar shape functions diferentes para cada."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Interpolação com Derivadas e Aplicação Prática",
                                  "subSteps": [
                                    "Calcule derivadas: ∂u/∂x = (∂u/∂ξ ∂ξ/∂x + ∂u/∂η ∂η/∂x), usando Jacobiana J.",
                                    "Inverta a Jacobiana para obter ∂/∂x e ∂/∂y em termos de ∂/∂ξ, ∂/∂η.",
                                    "Aplique em um problema simples: placa sob tração uniaxial.",
                                    "Compare deformação interpolada ε_xx = ∂u/∂x com solução analítica.",
                                    "Documente o processo em um relatório com gráficos de contorno."
                                  ],
                                  "verification": "Deformações calculadas batem com teoria elástica em ±5% de erro.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "MATLAB/Python com bibliotecas SymPy/NumPy para derivadas simbólicas, plotagem de campos.",
                                  "tips": "Use pontos de Gauss para integração precisa de derivadas.",
                                  "learningObjective": "Integrar interpolação vetorial com cálculo de gradientes via mapeamento.",
                                  "commonMistakes": "Inverter incorretamente a Jacobiana ou ignorar det(J) > 0."
                                }
                              ],
                              "practicalExample": "Em uma placa quadrilátera de 1x1 m sob tração uniaxial (u1=0.01, u2=0.01, u3=0, u4=0; v_i=0 todos), interpole u e v para obter mapa de deformação ε_xx ≈ 0.01 no centro.",
                              "finalVerifications": [
                                "∑ N_i = 1 verificado em 5 pontos internos.",
                                "Campos u e v contínuos nos nós compartilhados.",
                                "Gradientes ∂u/∂x calculados corretamente via Jacobiana.",
                                "Erro de interpolação < 1% vs. solução exata.",
                                "Visualização de contorno suave sem discontinuidades.",
                                "Código ou cálculos reproduzíveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão das shape functions (100% soma unitária).",
                                "Correta separação de componentes escalares u/v.",
                                "Mapeamento isoparamétrico-físico sem erros na Jacobiana.",
                                "Validação quantitativa com erros reportados.",
                                "Clareza na documentação e gráficos.",
                                "Eficiência computacional (uso matricial)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (vetores de shape) e cálculo multivariável (Jacobianas).",
                                "Programação: Implementação numérica em Python/MATLAB para automação FEA.",
                                "Física: Mecânica dos sólidos (deslocamentos e deformações).",
                                "Engenharia Civil: Análise de estruturas 2D semelhantes."
                              ],
                              "realWorldApplication": "Na análise de elementos finitos para simulação de tensões em placas de aviões ou pontes, onde deslocamentos vetoriais são interpolados para prever falhas estruturais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "34.2.4.2"
                            ]
                          },
                          {
                            "id": "34.2.4.3.2",
                            "name": "Calcular derivadas parciais em coordenadas reais",
                            "description": "Usar [∂/∂x ∂/∂y]^T = J^{-1} [∂/∂ξ ∂/∂η]^T para obter matriz B com derivadas das funções de forma em x,y.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir funções de forma em coordenadas naturais (ξ, η)",
                                  "subSteps": [
                                    "Identifique o elemento isoparamétrico quadrilátero de 4 nós.",
                                    "Escreva as funções de forma N_i(ξ, η) para i=1 a 4: N1 = (1-ξ)(1-η)/4, etc.",
                                    "Calcule as derivadas parciais das funções de forma em relação a ξ e η em um ponto de Gauss específico.",
                                    "Verifique que as funções de forma somam 1 e derivadas são corretas.",
                                    "Armazene em matrizes [∂N/∂ξ] e [∂N/∂η]."
                                  ],
                                  "verification": "Confirme que Σ N_i = 1 e derivadas batem com fórmulas padrão em ξ=0, η=0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Folha de papel, calculadora, tabela de funções de forma para Q4.",
                                  "tips": "Use simetria do elemento para acelerar cálculos.",
                                  "learningObjective": "Dominar representação bilinear das funções de forma em domínio mestre.",
                                  "commonMistakes": "Confundir índices dos nós ou fórmulas bilineares."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a matriz Jacobiana J em coordenadas reais (x, y)",
                                  "subSteps": [
                                    "Defina as coordenadas reais dos nós: x_i, y_i para i=1 a 4.",
                                    "Expresse x(ξ, η) = Σ N_i x_i e y(ξ, η) = Σ N_i y_i.",
                                    "Compute ∂x/∂ξ = Σ (∂N_i/∂ξ) x_i, ∂x/∂η = Σ (∂N_i/∂η) x_i, e аналогично para y.",
                                    "Forme J = [[∂x/∂ξ, ∂y/∂ξ], [∂x/∂η, ∂y/∂η]].",
                                    "Calcule det(J) para verificar não-singularidade."
                                  ],
                                  "verification": "det(J) ≠ 0 e J é 2x2 simétrica em forma.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Coordenadas dos nós, software como MATLAB ou Python para verificação opcional.",
                                  "tips": "Escolha ponto de Gauss interno para evitar det(J)=0 nas bordas.",
                                  "learningObjective": "Entender mapeamento geométrico do domínio mestre para real.",
                                  "commonMistakes": "Erro nos sinais das derivadas ∂N/∂ξ ou soma incorreta."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar a inversa da Jacobiana J^{-1}",
                                  "subSteps": [
                                    "Use fórmula para inversa 2x2: J^{-1} = (1/det(J)) * [[∂y/∂η, -∂y/∂ξ], [-∂x/∂η, ∂x/∂ξ]].",
                                    "Calcule det(J) = ∂x/∂ξ * ∂y/∂η - ∂x/∂η * ∂y/∂ξ.",
                                    "Multiplique adjunta por 1/det(J).",
                                    "Verifique J * J^{-1} = I (identidade).",
                                    "Armazene elementos: J^{-1}_{11}, J^{-1}_{12}, etc."
                                  ],
                                  "verification": "Multiplicação matricial resulta em [[1,0],[0,1]].",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora matricial ou papel para multiplicação.",
                                  "tips": "det(J) positivo garante orientação correta.",
                                  "learningObjective": "Aplicar inversão analítica para transformação de derivadas.",
                                  "commonMistakes": "Inverter linhas/colunas ou sinal errado no adjunto."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Transformar derivadas parciais para coordenadas reais usando J^{-1}",
                                  "subSteps": [
                                    "Defina vetor de derivadas naturais: [∂/∂ξ, ∂/∂η]^T.",
                                    "Aplique [∂/∂x, ∂/∂y]^T = J^{-1} * [∂u/∂ξ, ∂u/∂η]^T para campo u.",
                                    "Para funções de forma, compute ∂N_i/∂x = J^{-1}_{11} ∂N_i/∂ξ + J^{-1}_{12} ∂N_i/∂η.",
                                    "Аналогично para ∂N_i/∂y.",
                                    "Verifique consistência em ponto conhecido."
                                  ],
                                  "verification": "Derivadas transformadas satisfazem propriedades esperadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Matrizes J^{-1}, derivadas naturais, vetor coluna.",
                                  "tips": "Vetorize para todos i=1..4 simultaneamente.",
                                  "learningObjective": "Executar chain rule via Jacobiana para gradientes.",
                                  "commonMistakes": "Usar J ao invés de J^{-1} ou transposição errada."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Formar a matriz B com derivadas das funções de forma",
                                  "subSteps": [
                                    "Estruture B (2x8 para Q4, pois 4 nós x 2 DOF): B = [B1 B2 B3 B4], onde Bi = [[∂N_i/∂x, 0], [0, ∂N_i/∂y], [∂N_i/∂y, ∂N_i/∂x]].",
                                    "Preencha colunas para tensão/strain em 2D.",
                                    "Verifique que ∇u = B * {d}, onde {d} são deslocamentos nodais.",
                                    "Teste com campo linear conhecido.",
                                    "Salve B para integração em elemento."
                                  ],
                                  "verification": "B * {1,0,1,0,1,0,1,0}^T = gradiente constante correto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Template de matriz B, software para plotagem de strains.",
                                  "tips": "Lembre que para plane strain, terceira linha é shear.",
                                  "learningObjective": "Construir operador de strain para elementos finitos.",
                                  "commonMistakes": "Ordem errada de DOF ou esquecer termos shear."
                                }
                              ],
                              "practicalExample": "Para quadrilátero com nós (0,0), (2,0), (2,1), (0,1), em ponto Gauss (0,0): N1=N4=0.25, N2=N3=0.25. ∂N/∂ξ etc. levam J=[[1,0],[0,1]], J^{-1}=I, B direta. Compute ∂N1/∂x=-0.5, etc., e verifique ∇x = [1,0]^T.",
                              "finalVerifications": [
                                "det(J) > 0 em todos pontos de Gauss.",
                                "J * J^{-1} = I exata.",
                                "∂N_i/∂x + ∂N_i/∂y testados em pelo menos 2 pontos.",
                                "Matriz B produz gradiente correto para campo linear u=x.",
                                "Consistência com software FEA como ANSYS.",
                                "Sem NaN ou inf em cálculos."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica das derivadas (<1e-6 erro).",
                                "Correta formação de J e J^{-1}.",
                                "Estrutura válida da matriz B (dimensões 3x8 para plane stress).",
                                "Verificação de propriedades (particionamento, soma).",
                                "Eficiência computacional (vetorização).",
                                "Explicação clara do chain rule aplicado."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Inversão matricial e produtos.",
                                "Cálculo Multivariável: Regra da cadeia para gradientes.",
                                "Programação Numérica: Implementação em Python/MATLAB para automação.",
                                "Geometria Computacional: Mapeamentos diferenciais.",
                                "Física: Gradientes em campos contínuos (tensões, temperaturas)."
                              ],
                              "realWorldApplication": "Em simulações FEA de estruturas 2D como placas perfuradas, calcular strains locais para prever falhas em aviões ou pontes, otimizando designs sem protótipos físicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.2.4.2.3"
                            ]
                          },
                          {
                            "id": "34.2.4.3.3",
                            "name": "Aplicar integração numérica Gauss",
                            "description": "Configurar integração 2x2 Gauss com pontos e pesos para calcular integrais como ∫ B^T D B det(J) dξ dη na montagem da matriz de rigidez.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar funções de forma e mapeamento isoparamétrico",
                                  "subSteps": [
                                    "Defina as funções de forma N_i(ξ, η) para o quadrilátero de 4 nós: N1 = (1-ξ)(1-η)/4, etc.",
                                    "Calcule as derivadas ∂N_i/∂ξ e ∂N_i/∂η em pontos genéricos.",
                                    "Mapeie coordenadas reais (x,y) para naturais (ξ,η) usando J = [∂x/∂ξ ∂x/∂η; ∂y/∂ξ ∂y/∂η].",
                                    "Verifique det(J) para garantir mapeamento válido (det(J) > 0).",
                                    "Pratique com um elemento distorcido para observar variação de det(J)."
                                  ],
                                  "verification": "Confirme que derivadas das funções de forma estão corretas em ξ=0, η=0 e det(J) calculado manualmente coincide com fórmula.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel, caneta, calculadora científica, tabela de funções de forma impressa.",
                                  "tips": "Use simetria do elemento para simplificar cálculos iniciais.",
                                  "learningObjective": "Compreender o mapeamento isoparamétrico como base para integração.",
                                  "commonMistakes": "Confundir derivadas parciais (∂/∂ξ vs ∂/∂η) ou sinal de det(J)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender integração numérica Gauss em 2D",
                                  "subSteps": [
                                    "Revise Gauss 1D: pontos e pesos para n=2 (ξ=±1/√3, w=1).",
                                    "Estenda para 2D: produto tensorial, 2x2 pontos (ξ_i, η_j) com pesos w_i * w_j.",
                                    "Liste pontos Gauss 2x2: (±0.577, ±0.577) com peso total 1x1=1.",
                                    "Formule a aproximação ∫ f(ξ,η) dξ dη ≈ Σ Σ f(ξ_i,η_j) w_i w_j.",
                                    "Compare precisão com integração exata para polinômio de grau 3."
                                  ],
                                  "verification": "Calcule ∫_{-1}^1 ∫_{-1}^1 (ξ^2 + η^2) dξ dη exata (8/3) e via Gauss (deve coincidir).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Tabela de pontos/pesos Gauss (impressa ou online), software como MATLAB para verificação.",
                                  "tips": "Memorize pontos 2x2: √(1/3)≈0.577, pesos=1.",
                                  "learningObjective": "Dominar pontos e pesos Gauss para integração exata de polinômios até grau 3 em 2D.",
                                  "commonMistakes": "Usar pesos errados (não multiplicar w_ξ * w_η) ou limites errados (-1 a 1)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar matrizes B e D para o elemento",
                                  "subSteps": [
                                    "Defina matriz B(ξ,η): colunas com [∂N_i/∂x; ∂N_i/∂y] usando J^{-1}.",
                                    "Especifique matriz constitutiva D para material isotrópico 2D (plano tensão).",
                                    "Calcule B em um ponto Gauss específico (ex: ξ=0.577, η=0.577).",
                                    "Verifique simetria e propriedades de B^T D B.",
                                    "Implemente fórmula para det(J) em cada ponto Gauss."
                                  ],
                                  "verification": "Confirme que B tem dimensões 3x8 (2D, 4 nós) e det(J) varia corretamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilha Excel ou MATLAB para inversão de J e multiplicações matriciais.",
                                  "tips": "Automatize inversão de J com fórmula analítica para 2x2.",
                                  "learningObjective": "Construir corretamente as matrizes locais B e det(J) nos pontos Gauss.",
                                  "commonMistakes": "Erro na inversão de J (trocar ∂x/∂ξ com ∂y/∂η) ou esquecer chain rule."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar integral da matriz de rigidez via Gauss 2x2",
                                  "subSteps": [
                                    "Inicialize K = zeros(8,8).",
                                    "Loop sobre 4 pontos Gauss: K += B^T * D * B * det(J) * w_ξ * w_η.",
                                    "Calcule para todos pontos e some contribuições.",
                                    "Verifique simetria final de K (K = K^T).",
                                    "Compare com solução analítica para elemento retangular uniforme."
                                  ],
                                  "verification": "K final deve ser simétrica positiva definida; trace(K) > 0.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB/Python script template para loop Gauss, coordenadas de exemplo.",
                                  "tips": "Use indexação nodal correta (dofs: ux1,uy1,ux2,...).",
                                  "learningObjective": "Implementar numericamente a montagem da matriz de rigidez.",
                                  "commonMistakes": "Esquecer det(J) ou peso no loop, ou loop só em 1D."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e otimizar a integração",
                                  "subSteps": [
                                    "Teste com elemento retangular: compare K_Gauss vs K_exata.",
                                    "Analise convergência aumentando pontos Gauss (2x2 vs 3x3).",
                                    "Aplique a tensão unitária e verifique deslocamentos esperados.",
                                    "Documente erros e ajustes necessários.",
                                    "Generalize para elemento distorcido."
                                  ],
                                  "verification": "Erro relativo em K < 1% para caso exato; código roda sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código do step 4, casos teste pré-definidos.",
                                  "tips": "Salve K em arquivo para inspeção visual (spy plot).",
                                  "learningObjective": "Validar precisão da integração Gauss na prática.",
                                  "commonMistakes": "Não normalizar pesos (soma w=2 em 1D, mas 4 em 2D? Não, é 1 total)."
                                }
                              ],
                              "practicalExample": "Para um quadrilátero retangular 2x1 (nós: (0,0),(2,0),(2,1),(0,1)), E=210e9 Pa, ν=0.3, plano tensão. Calcule K usando Gauss 2x2; entrada: coords nós, D material; saída: K 8x8 com valores como K11≈1.47e10.",
                              "finalVerifications": [
                                "Cálculo de ∫ B^T D B det(J) dξ dη coincide com Gauss 2x2 em pelo menos 2 exemplos.",
                                "Matriz K é simétrica e positiva semi-definida (autovalores ≥0).",
                                "Código implementa loop exato sobre 4 pontos Gauss sem erros numéricos.",
                                "Erro vs solução analítica <0.1% para elemento retangular.",
                                "det(J) >0 em todos pontos Gauss.",
                                "Derivadas em B corretas via chain rule verificadas manualmente."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Integração Gauss reproduz integral exata para polinômios teste.",
                                "Implementação: Código ou cálculo manual sem erros em B, J, loop.",
                                "Compreensão: Explicação correta de porquê 2x2 é exato para ordem quadrática.",
                                "Eficiência: Tempo de computação razoável (<1s para 1 elemento).",
                                "Generalização: Funciona para elementos distorcidos sem singularidades.",
                                "Documentação: Passos comentados e verificações incluídas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Quadratura Gauss e análise de erro de truncamento.",
                                "Programação: Loops matriciais em MATLAB/Python (NumPy).",
                                "Física/Engenharia: Teoria de elasticidade linear e FEA.",
                                "Cálculo: Derivadas parciais, Jacobiano e mudança de variáveis.",
                                "Estatística: Verificação de convergência e análise de sensibilidade."
                              ],
                              "realWorldApplication": "Na análise de estruturas via Método dos Elementos Finitos (ex: ANSYS, Abaqus), essa integração é usada para montar matrizes de rigidez de malhas 2D em projetos de pontes, aviões e carrocerias automotivas, garantindo precisão computacional eficiente sem integração analítica complexa."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.2.4.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.4",
                    "name": "Integração Numérica em Elementos Isoparamétricos",
                    "description": "Métodos de integração numérica, como Gauss, para avaliação de integrais em elementos quadriláteros.",
                    "individualConcepts": [
                      {
                        "id": "34.2.4.1",
                        "name": "Elemento Isoparamétrico Quadrilátero de 4 Nós",
                        "description": "Definição e mapeamento do elemento quadrilátero físico no domínio real para o elemento de referência no espaço ξ-η (-1 a 1), utilizando funções de interpolação bilineares para aproximar deslocamentos e geometria.",
                        "specificSkills": [
                          {
                            "id": "34.2.4.1.1",
                            "name": "Identificar funções de forma do quadrilátero isoparamétrico",
                            "description": "Derivar e escrever as funções de forma N_i(ξ,η) = (1/4)(1±ξ)(1±η) para os 4 nós do elemento de referência, explicando sua propriedade de partição da unidade e interpolação nodal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o elemento de referência quadrilátero isoparamétrico",
                                  "subSteps": [
                                    "Desenhe o quadrilátero unitário no plano ξ-η, com vértices nos nós: (1,1), (1,-1), (-1,-1), (-1,1).",
                                    "Identifique as coordenadas naturais dos 4 nós: nó 1 (ξ=1,η=1), nó 2 (ξ=1,η=-1), nó 3 (ξ=-1,η=-1), nó 4 (ξ=-1,η=1).",
                                    "Explique que ξ e η variam de -1 a 1, formando um domínio padrão para mapeamento isoparamétrico.",
                                    "Discuta a importância do domínio de referência para padronizar integrações numéricas em elementos finitos.",
                                    "Anote as propriedades bilineares das funções de forma neste domínio."
                                  ],
                                  "verification": "Desenho correto do quadrilátero com coordenadas dos nós rotuladas e explicação escrita da variação de ξ e η.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado ou software de desenho (GeoGebra/Mathematica)",
                                    "Livro de Elementos Finitos (ex: Zienkiewicz)"
                                  ],
                                  "tips": "Use simetria para visualizar: o centro está em (0,0).",
                                  "learningObjective": "Entender o domínio ξ-η e seus nós para basear derivação das funções de forma.",
                                  "commonMistakes": [
                                    "Confundir ordem dos nós (ex: nó 1 como (-1,-1))",
                                    "Pensar que ξ e η vão de 0 a 1 em vez de -1 a 1."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar as funções de forma N_i(ξ,η) para cada nó",
                                  "subSteps": [
                                    "Para nó 1 (1,1): derive N1 = (1/4)(1+ξ)(1+η) multiplicando fatores lineares que são 1 nos extremos.",
                                    "Para nó 2 (1,-1): derive N2 = (1/4)(1+ξ)(1-η), verificando valor 1 em (1,-1) e 0 nos outros.",
                                    "Para nó 3 (-1,-1): derive N3 = (1/4)(1-ξ)(1-η).",
                                    "Para nó 4 (-1,1): derive N4 = (1/4)(1-ξ)(1+η).",
                                    "Escreva todas as quatro funções explicitamente e teste em um ponto arbitrário, como (0,0)."
                                  ],
                                  "verification": "Escrita correta das 4 funções N_i e tabela de valores nos nós mostrando 1 no próprio nó e 0 nos outros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Caderno para derivações algébricas",
                                    "Calculadora ou SymPy para simplificação"
                                  ],
                                  "tips": "Lembre-se do fator 1/4 para normalizar a soma a 1 no centro.",
                                  "learningObjective": "Derivar matematicamente as funções bilineares de forma para os 4 nós.",
                                  "commonMistakes": [
                                    "Esquecer o 1/4",
                                    "Erros nos sinais ± nos fatores (1±ξ)(1±η)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a propriedade de partição da unidade",
                                  "subSteps": [
                                    "Some as funções: Σ N_i(ξ,η) = N1 + N2 + N3 + N4.",
                                    "Expanda algebricamente: (1/4)[(1+ξ)(1+η) + (1+ξ)(1-η) + (1-ξ)(1-η) + (1-ξ)(1+η)].",
                                    "Simplifique para mostrar que Σ N_i = 1 para qualquer (ξ,η) no domínio.",
                                    "Teste numericamente em pontos como centro (0,0), bordas e nós.",
                                    "Explique como isso garante consistência na interpolação de campos."
                                  ],
                                  "verification": "Prova algébrica mostrando Σ N_i = 1 e tabela numérica com soma=1 em 5 pontos distintos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software simbólico (Mathematica/MATLAB) para expansão",
                                    "Planilha Excel para testes numéricos"
                                  ],
                                  "tips": "Agrupe termos com (1+ξ) e (1-ξ) para simplificar rapidamente.",
                                  "learningObjective": "Demonstrar que as funções de forma somam 1 em todo o domínio, reproduzindo constantes perfeitamente.",
                                  "commonMistakes": [
                                    "Erros na expansão algébrica levando a soma ≠1",
                                    "Testar só nos nós, ignorando interior."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a propriedade de interpolação nodal",
                                  "subSteps": [
                                    "Defina interpolação: u(ξ,η) = Σ u_i N_i(ξ,η), onde u_i são valores nodais.",
                                    "Avalie em nó j: u(ξ_j,η_j) = u_j *1 + Σ_{i≠j} u_i *0 = u_j.",
                                    "Teste com função conhecida, ex: u=1 (constante), u=ξ (linear).",
                                    "Discuta limitações para funções não-lineares (ex: quadráticas requerem nós extras).",
                                    "Implemente em código simples para plotar N_i."
                                  ],
                                  "verification": "Exemplo numérico com valores nodais arbitrários reproduzindo corretamente nos nós e interpolação suave.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python/MATLAB com meshgrid para plotar superfícies N_i",
                                    "Gráfico de contorno das funções"
                                  ],
                                  "tips": "Plote as N_i para visualizar: cada uma é 1 no seu nó e 0 nos vizinhos.",
                                  "learningObjective": "Confirmar que as funções reproduzem valores nodais exatamente na interpolação.",
                                  "commonMistakes": [
                                    "Confundir com Lagrange (que é geral), ignorando bilineares específicas",
                                    "Não testar interpolação em campo não-constante."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um elemento quadrilátero mapeado para uma placa deformada, defina temperaturas nodais T1=100°C, T2=50°C, T3=0°C, T4=25°C. Use N_i para interpolar T no centro (0,0): T=(100+50+0+25)/4=43.75°C, verificando partição da unidade.",
                              "finalVerifications": [
                                "Escreve corretamente as 4 funções N_i(ξ,η).",
                                "Prova algébrica de Σ N_i = 1.",
                                "Demonstra interpolação nodal com exemplo numérico.",
                                "Plota ou descreve o comportamento de cada N_i no domínio.",
                                "Explica limitações bilineares vs. lineares.",
                                "Aplica em interpolação de um campo escalar simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação das funções (100% correto).",
                                "Compreensão demonstrada na prova de partição da unidade.",
                                "Correção na verificação de interpolação nodal.",
                                "Uso de exemplos numéricos e visuais.",
                                "Explicação clara de propriedades e contexto em MEF.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra polinomial e simplificação simbólica.",
                                "Programação: Implementação em Python/MATLAB para plotagem e integração numérica.",
                                "Física: Aplicação em campos contínuos (tensão, temperatura) nos elementos finitos.",
                                "Geometria Computacional: Mapeamentos ξ-η para malhas arbitrárias."
                              ],
                              "realWorldApplication": "Em simulações de elementos finitos para análise estrutural (ex: ponte sob carga), as funções de forma interpolam deslocamentos nodais para prever deformações em toda a malha, essencial em engenharia aeroespacial e automotiva."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.2.4.1.2",
                            "name": "Mapear coordenadas físicas para naturais",
                            "description": "Aplicar a transformação isoparamétrica x(ξ,η) = Σ N_i(ξ,η) x_i e y(ξ,η) = Σ N_i(ξ,η) y_i para converter integrais no domínio físico para o domínio de referência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Domínio de Referência e Funções de Forma",
                                  "subSteps": [
                                    "Descreva o domínio de referência para o elemento quadrilátero de 4 nós: ξ, η ∈ [-1, 1].",
                                    "Liste as funções de forma N_i(ξ, η) para i=1 a 4: N1 = (1-ξ)(1-η)/4, etc.",
                                    "Desenhe o quadrado mestre e marque os nós em (±1, ±1).",
                                    "Explique o papel das funções N_i na interpolação.",
                                    "Verifique que Σ N_i = 1 para qualquer (ξ, η)."
                                  ],
                                  "verification": "Reproduzir corretamente as 4 funções de forma e confirmar a propriedade de partição da unidade em 3 pontos distintos.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro-texto de Elementos Finitos (Cap. Isoparamétricos)",
                                    "Calculadora"
                                  ],
                                  "tips": "Use um gráfico para visualizar como as funções N_i variam de 0 a 1.",
                                  "learningObjective": "Dominar as funções de interpolação no domínio natural para elementos isoparamétricos.",
                                  "commonMistakes": [
                                    "Confundir as coordenadas locais ξ, η com globais x, y",
                                    "Esquecer o fator 1/4 nas funções bilineares",
                                    "Não verificar a soma das N_i"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Coordenadas Físicas dos Nós do Elemento",
                                  "subSteps": [
                                    "Identifique os 4 nós do elemento no domínio físico: (x1,y1), (x2,y2), (x3,y3), (x4,y4).",
                                    "Atribua correspondência: nó 1 (-1,-1), nó 2 (1,-1), nó 3 (1,1), nó 4 (-1,1).",
                                    "Esboce o elemento físico distorcido no plano x-y.",
                                    "Liste as coordenadas em uma tabela organizada.",
                                    "Confirme que o elemento não é degenerado (área > 0)."
                                  ],
                                  "verification": "Criar uma tabela com nós corretamente mapeados e esboço que reflita a geometria física.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Exemplo de malha 2D impressa"
                                  ],
                                  "tips": "Numere os nós no sentido anti-horário para evitar inversões.",
                                  "learningObjective": "Preparar dados de entrada precisos para a transformação isoparamétrica.",
                                  "commonMistakes": [
                                    "Ordem errada dos nós levando a Jacobiano negativo",
                                    "Confundir domínio físico com referência",
                                    "Ignorar distorções que causam singularidades"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a Transformação Isoparamétrica",
                                  "subSteps": [
                                    "Escreva as fórmulas: x(ξ,η) = Σ N_i(ξ,η) x_i, y(ξ,η) = Σ N_i(ξ,η) y_i.",
                                    "Escolha pontos de Gauss no domínio natural (ex: (0,0), (±1/√3, ±1/√3)).",
                                    "Calcule x, y para cada ponto selecionado expandindo a soma.",
                                    "Implemente em uma planilha ou código simples (ex: Python/MATLAB).",
                                    "Compare resultados analíticos vs numéricos."
                                  ],
                                  "verification": "Calcular x,y para 4 pontos de Gauss e validar contra fórmula expandida manualmente.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Editor de código (opcional)",
                                    "Pontos de Gauss tabelados"
                                  ],
                                  "tips": "Comece com ponto central (0,0) onde N_i=1/4 para todos.",
                                  "learningObjective": "Aplicar a mapeação para transferir pontos do domínio natural ao físico.",
                                  "commonMistakes": [
                                    "Erro aritmético na expansão de N_i",
                                    "Usar coordenadas erradas dos nós",
                                    "Não expandir corretamente a soma bilineares"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar o Mapeamento e Preparar para Integração Numérica",
                                  "subSteps": [
                                    "Calcule o Jacobiano J = ∂(x,y)/∂(ξ,η) em pontos de Gauss.",
                                    "Verifique det(J) > 0 em todos os pontos para orientação positiva.",
                                    "Aplique em uma integral de teste: ∫_f g(x,y) dA ≈ Σ w_i g(x_i,y_i) |det(J_i)|.",
                                    "Compare com integral analítica em elemento retangular simples.",
                                    "Documente o processo para um elemento distorcido."
                                  ],
                                  "verification": "Realizar uma integração numérica de uma função teste (ex: 1 para área) com erro < 1%.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Código ou planilha para Jacobiano",
                                    "Função teste simples como x^2 + y^2"
                                  ],
                                  "tips": "Use regra 2x2 Gauss para precisão inicial.",
                                  "learningObjective": "Integrar o mapeamento em esquemas de integração numérica para elementos isoparamétricos.",
                                  "commonMistakes": [
                                    "Esquecer o |det(J)| na integral",
                                    "Pontos de Gauss incorretos",
                                    "Jacobiano singular em nós distorcidos"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um quadrilátero com nós: 1=(0,0), 2=(3,0), 3=(2,2), 4=(0,1). No ponto Gauss (0,0): N_i=0.25 cada, x= (0+3+2+0)/4=1.25, y=(0+0+2+1)/4=0.75. Use para integrar f(x,y)=x*y sobre o elemento, somando contribuições nos 4 pontos Gauss 2x2.",
                              "finalVerifications": [
                                "Reproduzir x(ξ,η), y(ξ,η) para 4 pontos arbitrários com precisão <0.01.",
                                "Calcular det(J) em pontos de Gauss e confirmar positivo.",
                                "Executar integração numérica de área com erro relativo <0.5%.",
                                "Explicar verbalmente o propósito do mapeamento em FEM.",
                                "Implementar em código e validar contra caso analítico.",
                                "Identificar e corrigir uma distorção que causa det(J)=0."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de mapeamento (erro <1%).",
                                "Correta formulação de funções de forma e Jacobiano.",
                                "Capacidade de aplicar em exemplo distorcido sem erros.",
                                "Clareza na documentação de passos e verificações.",
                                "Entendimento conceitual demonstrado em explicações.",
                                "Eficiência na implementação numérica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Interpolação polinomial e funções bilineares.",
                                "Programação: Implementação numérica em Python/MATLAB para FEM.",
                                "Geometria Computacional: Mapeamentos afins e não-lineares.",
                                "Física: Integração em domínios irregulares para equações diferenciais.",
                                "Engenharia de Software: Validação de malhas em solvers FEM."
                              ],
                              "realWorldApplication": "Em análises de estruturas via Método dos Elementos Finitos (ex: ANSYS, Abaqus), permite integrar propriedades materiais sobre elementos de geometria arbitrária, essencial para simular tensões em peças automotivas distorcidas ou aerodinâmicas complexas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "34.2.4.1.1"
                            ]
                          },
                          {
                            "id": "34.2.4.1.3",
                            "name": "Calcular o Jacobiano da transformação",
                            "description": "Computar a matriz Jacobiana J = [∂(x,y)/∂(ξ,η)] e seu determinante |J| para elementos retangulares e distorcidos, verificando sua positividade para mapeamentos válidos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o mapeamento isoparamétrico e coordenadas",
                                  "subSteps": [
                                    "Revise as coordenadas naturais (ξ, η) no domínio [-1,1] x [-1,1] para o elemento de referência.",
                                    "Identifique as coordenadas globais (x, y) dos 4 nós do quadrilátero isoparamétrico.",
                                    "Escreva a equação de mapeamento: x(ξ,η) = Σ N_i(ξ,η) x_i, y(ξ,η) = Σ N_i(ξ,η) y_i.",
                                    "Diferencie conceitualmente x e y em relação a ξ e η para formar a Jacobiana.",
                                    "Desenhe o elemento de referência e um elemento distorcido para visualizar."
                                  ],
                                  "verification": "Desenhe e rotule corretamente o domínio de referência e liste as coordenadas dos nós.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Diagrama de elemento quadrilátero de 4 nós"
                                  ],
                                  "tips": "Sempre use o domínio padrão [-1,1] para evitar confusões com normalizações.",
                                  "learningObjective": "Compreender o mapeamento de coordenadas locais para globais em elementos isoparamétricos.",
                                  "commonMistakes": [
                                    "Confundir coordenadas naturais com globais",
                                    "Esquecer que ξ e η variam de -1 a 1"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e derivar as funções de forma (shape functions)",
                                  "subSteps": [
                                    "Escreva as funções de forma bilineares: N1 = (1-ξ)(1-η)/4, N2 = (1+ξ)(1-η)/4, etc.",
                                    "Verifique que Σ N_i = 1 e N_i = 1 apenas no nó i.",
                                    "Calcule as derivadas parciais: ∂N_i/∂ξ e ∂N_i/∂η em um ponto genérico (ξ,η).",
                                    "Liste as derivadas para todos os 4 nós em uma tabela.",
                                    "Pratique em um ponto específico, como o centro (0,0)."
                                  ],
                                  "verification": "Confirme que as derivadas das shape functions estão corretas comparando com fórmulas padrão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Folha com fórmulas de shape functions"
                                  ],
                                  "tips": "Memorize as derivadas: elas são lineares em ξ e η, facilitando cálculos.",
                                  "learningObjective": "Dominar as funções de forma e suas derivadas parciais para quadriláteros de 4 nós.",
                                  "commonMistakes": [
                                    "Erro nos sinais das derivadas bilineares",
                                    "Dividir por 4 incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a matriz Jacobiana J",
                                  "subSteps": [
                                    "Monte a matriz J = [ ∂x/∂ξ  ∂y/∂ξ ; ∂x/∂η  ∂y/∂η ], onde ∂x/∂ξ = Σ (∂N_i/∂ξ) x_i.",
                                    "Calcule cada entrada da matriz usando as derivadas e coordenadas dos nós.",
                                    "Faça isso para um elemento retangular e um distorcido.",
                                    "Verifique dimensionalmente: J deve ter unidades de comprimento.",
                                    "Inverta conceitualmente J para obter derivadas inversas."
                                  ],
                                  "verification": "A matriz J resultante deve ser 2x2 e não-singular para o ponto escolhido.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB para matrizes",
                                    "Exemplo de coordenadas de nós"
                                  ],
                                  "tips": "Calcule em pontos de Gauss (ex: (0,0)) para integração futura.",
                                  "learningObjective": "Construir corretamente a matriz Jacobiana a partir de derivadas e coordenadas nodais.",
                                  "commonMistakes": [
                                    "Trocar ∂/∂ξ com ∂/∂η",
                                    "Esquecer de somar contribuições de todos os nós"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular determinante |J| e verificar positividade",
                                  "subSteps": [
                                    "Compute det(J) = (∂x/∂ξ)(∂y/∂η) - (∂x/∂η)(∂y/∂ξ).",
                                    "Verifique se |J| > 0 em todos os pontos do elemento.",
                                    "Compare |J| constante para retangular vs. variável para distorcido.",
                                    "Discuta implicações: |J| < 0 indica inversão de orientação inválida.",
                                    "Calcule |J| médio ou em pontos de Gauss."
                                  ],
                                  "verification": "det(J) positivo e consistente com geometria do elemento.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Software para plotar |J| (opcional)"
                                  ],
                                  "tips": "Para retangular, |J| = (a/2)(b/2) onde a,b são lados.",
                                  "learningObjective": "Avaliar a validade do mapeamento via determinante da Jacobiana.",
                                  "commonMistakes": [
                                    "Sinal errado no det(J)",
                                    "Ignorar variação em elementos distorcidos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um quadrilátero retangular com nós: (0,0), (2,0), (2,1), (0,1). No centro (ξ=0,η=0), shape derivs: ∂N1/∂ξ=-0.25, etc. J = [[0.5, 0], [0, 0.25]], det(J)=0.125 >0. Para distorcido movendo nó4 para (0.5,1.5), recalcule J e verifique det(J)>0.",
                              "finalVerifications": [
                                "Matriz J corretamente montada para elemento retangular e distorcido.",
                                "Determinante |J| calculado e positivo em pelo menos 3 pontos.",
                                "Explicação verbal do papel de J na integração numérica.",
                                "Identificação de um caso onde |J|<0 (elemento inválido).",
                                "Cálculo manual de J em ponto de Gauss coincide com fórmula.",
                                "Gráfico qualitativo de |J| no domínio."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de derivadas e matriz J (erro <1%).",
                                "Correta interpretação da positividade de |J|.",
                                "Uso apropriado de shape functions bilineares.",
                                "Distinção clara entre elementos retangulares e distorcidos.",
                                "Explicação conceitual do mapeamento isoparamétrico.",
                                "Eficiência no tempo e organização dos passos."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Multivariável: Derivadas parciais e Jacobianas.",
                                "Álgebra Linear: Manipulação de matrizes 2x2 e determinantes.",
                                "Programação Numérica: Implementação em Python/MATLAB para FEM.",
                                "Geometria Computacional: Mapeamentos e distorções de malhas.",
                                "Física Computacional: Integração em simulações de PDEs."
                              ],
                              "realWorldApplication": "Em softwares FEM como ANSYS ou Abaqus, calcular J garante mapeamentos válidos em meshes complexas para análise de tensões em estruturas mecânicas, evitando erros em simulações de fadiga ou vibrações."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.2.4.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "34.2.4.2",
                        "name": "Método de Integração Numérica de Gauss-Legendre",
                        "description": "Princípios da quadratura de Gauss em uma e duas dimensões, incluindo pontos de Gauss, pesos de integração e ordens de precisão exata para polinômios.",
                        "specificSkills": [
                          {
                            "id": "34.2.4.2.1",
                            "name": "Listar pontos e pesos de Gauss para 1D e 2D",
                            "description": "Memorizar e tabular pontos ξ_i e pesos w_i para integração 2x2, 3x3 em [-1,1], demonstrando precisão exata para polinômios até grau 3 (2 pontos) ou 5 (3 pontos).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos da Integração de Gauss-Legendre em 1D",
                                  "subSteps": [
                                    "Revise o polinômio de Legendre e suas raízes como pontos de Gauss.",
                                    "Estude a fórmula de integração numérica: ∫_{-1}^1 f(ξ) dξ ≈ Σ w_i f(ξ_i).",
                                    "Aprenda que para n pontos, a integração é exata para polinômios até grau 2n-1.",
                                    "Derive ou memorize a tabela básica para n=1 (ponto médio).",
                                    "Pratique com um exemplo simples de integral exata."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que Gauss é exato para polinômios de grau até 2n-1.",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "Livro de Elementos Finitos (cap. Integração Numérica)",
                                    "Tabela de pontos Gauss online ou PDF",
                                    "Caderno para anotações"
                                  ],
                                  "tips": "Use visualizações gráficas dos polinômios de Legendre para fixar raízes.",
                                  "learningObjective": "Compreender a base teórica da quadratura de Gauss-Legendre em 1D.",
                                  "commonMistakes": [
                                    "Confundir raízes de Legendre com zeros de Chebyshev.",
                                    "Esquecer que o intervalo é [-1,1]."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar e Tabular Pontos e Pesos para 2 e 3 Pontos em 1D",
                                  "subSteps": [
                                    "Liste para n=2: ξ = ±√(1/3) ≈ ±0.57735, w=1 cada.",
                                    "Liste para n=3: ξ = 0 (w=8/9), ±√(3/5)≈±0.7746 (w=5/9 cada).",
                                    "Crie uma tabela com colunas: n, ξ_i, w_i (precisão 5 casas).",
                                    "Recite de memória 3 vezes sem olhar.",
                                    "Teste copiando a tabela em papel em branco."
                                  ],
                                  "verification": "Reproduza a tabela completa sem erros em menos de 2 minutos.",
                                  "estimatedTime": "30 min",
                                  "materials": [
                                    "Tabela oficial de Gauss-Legendre",
                                    "Flashcards auto-feitas",
                                    "Calculadora para verificação numérica"
                                  ],
                                  "tips": "Associe ξ_2 ≈0.577 a 1/√3, e memorize frações exatas primeiro.",
                                  "learningObjective": "Memorizar precisamente os valores para n=2 e n=3 em 1D.",
                                  "commonMistakes": [
                                    "Trocar pesos de n=3 (8/9 vs 5/9).",
                                    "Arredondar incorretamente ξ."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estender para Integração 2D via Produto Tensorial",
                                  "subSteps": [
                                    "Aprenda que para 2D: ∫∫ f(ξ,η) dξ dη ≈ ΣΣ w_i w_j f(ξ_i, η_j).",
                                    "Para 2x2: Use produto de n=2 em ξ e η (4 pontos totais).",
                                    "Para 3x3: Produto de n=3 (9 pontos), exato até grau 5.",
                                    "Tabule os 4+9 pontos (ξ_i, η_j, w_i w_j).",
                                    "Calcule um peso exemplo: para (0,0) em 3x3 é (8/9)^2."
                                  ],
                                  "verification": "Construa e liste corretamente a tabela 2x2 e pelo menos 3 pontos de 3x3.",
                                  "estimatedTime": "40 min",
                                  "materials": [
                                    "Grade 2x2 e 3x3 em papel",
                                    "Software como MATLAB para plotar pontos",
                                    "Referência de EF"
                                  ],
                                  "tips": "Visualize como uma malha no quadrilátero mestre [-1,1]x[-1,1].",
                                  "learningObjective": "Aplicar produto tensorial para gerar pontos/pesos em 2D.",
                                  "commonMistakes": [
                                    "Usar w_i + w_j em vez de w_i * w_j.",
                                    "Confundir ordem de ξ e η."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar Precisão Exata para Polinômios de Grau Específico",
                                  "subSteps": [
                                    "Escolha polinômio p(x)=x^3 (grau 3), integre exata=0 em [-1,1].",
                                    "Aplique Gauss n=2: verifique soma w_i (ξ_i)^3 =0.",
                                    "Para grau 5, use p(x)=(x^2-0.5)^2 * x ou similar, teste n=3.",
                                    "Em 2D, teste p(ξ,η)=ξ^2 η +1, verifique exatidão com 2x2.",
                                    "Compare erro com regra Simpson para validar superioridade."
                                  ],
                                  "verification": "Realize 2 cálculos demonstrando erro zero para graus apropriados.",
                                  "estimatedTime": "35 min",
                                  "materials": [
                                    "Calculadora ou Python/MATLAB",
                                    "Folha de exercícios",
                                    "Tabelas de Gauss"
                                  ],
                                  "tips": "Comece com polinômios monomiais para simplicidade.",
                                  "learningObjective": "Validar numericamente a precisão de Gauss.",
                                  "commonMistakes": [
                                    "Escolher polinômio de grau >2n-1 esperando exatidão.",
                                    "Erro aritmético em somas."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um elemento finito quadrilateral isoparamétrico, compute ∫∫_Q (ξ^2 + η^2) dξ dη usando Gauss 2x2: pontos (±0.577,±0.577) com w=1*1=1 cada; soma=4*( (1/3)+ (1/3) )=8/3, exato pois grau 2 <3.",
                              "finalVerifications": [
                                "Recitar de memória todos ξ_i, w_i para 1D n=2,3.",
                                "Listar 4 pontos/pesos de 2x2 e 9 de 3x3 sem erros.",
                                "Calcular integral exata de x^3 com n=2 (erro=0).",
                                "Explicar por que n=3 é exato até grau 5.",
                                "Tabular completa em formato LaTeX ou Excel.",
                                "Demonstrar 2D com polinômio bilinear."
                              ],
                              "assessmentCriteria": [
                                "Precisão na memorização (>95% correto).",
                                "Correta aplicação do produto tensorial em 2D.",
                                "Demonstração de exatidão com pelo menos 2 exemplos numéricos.",
                                "Tabelas claras e completas (ξ, w com 5 dígitos).",
                                "Explicação teórica concisa e correta.",
                                "Tempo de reprodução <3 min para tabelas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Quadratura e polinômios ortogonais.",
                                "Computação: Implementação em código para EF (MATLAB/Fortran).",
                                "Física: Simulações dinâmicas em malhas finitas.",
                                "Estatística: Integração em métodos Monte Carlo vs Gauss."
                              ],
                              "realWorldApplication": "Em análise de elementos finitos para estruturas mecânicas (ex: tensão em placas), Gauss 2x2/3x3 garante precisão eficiente na integração de matrizes de rigidez sem analiticamente complexa."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.2.4.2.2",
                            "name": "Formular regra de quadratura em 2D",
                            "description": "Escrever ∫∫ f(ξ,η) dξ dη ≈ Σ Σ w_i w_j f(ξ_i, η_j) para produto de regras 1D separáveis, justificando eficiência computacional em elementos isoparamétricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Quadratura Gauss-Legendre em 1D",
                                  "subSteps": [
                                    "Explicar o problema de integração numérica em 1D: aproximar ∫_{-1}^{1} f(ξ) dξ ≈ Σ w_i f(ξ_i).",
                                    "Listar propriedades dos pontos e pesos de Gauss-Legendre (ex: para n=2, ξ1=-√(1/3), w1=1).",
                                    "Derivar ou recordar a exatidão para polinômios até grau 2n-1.",
                                    "Praticar cálculo de integral de uma função teste, como f(ξ)=ξ^3."
                                  ],
                                  "verification": "Calcular corretamente a integral de um polinômio cúbico com erro zero usando 2 pontos Gauss.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Tabela de pontos e pesos Gauss-Legendre, calculadora ou papel e caneta.",
                                  "tips": "Memorize pontos para n=1,2,3; eles são simétricos em [-1,1].",
                                  "learningObjective": "Compreender a base da quadratura exata para polinômios em 1D.",
                                  "commonMistakes": "Confundir pontos de Gauss com zeros de Legendre; esquecer normalização no intervalo [-1,1]."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Elementos Isoparamétricos em 2D",
                                  "subSteps": [
                                    "Descrever o mapeamento de um elemento de referência quadrilateral [-1,1]x[-1,1] para o elemento físico.",
                                    "Explicar coordenadas naturais (ξ, η) e jacobiano J para transformação de integrais.",
                                    "Discutir por que usar domínio de referência: padronização para funções de forma.",
                                    "Calcular det(J) para um quadrilátero bilinear simples."
                                  ],
                                  "verification": "Esboçar mapeamento e escrever ∫∫_Ω f(x,y) dx dy = ∫∫_{-1,1} f(ξ,η) |det(J)| dξ dη corretamente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Diagrama de elemento isoparamétrico, software como MATLAB para plotar (opcional).",
                                  "tips": "Visualize o 'parent element' como uma unidade padrão para todos quadriláteros.",
                                  "learningObjective": "Dominar a transformação integral para coordenadas naturais em 2D.",
                                  "commonMistakes": "Esquecer o |det(J)| ou assumir J constante em elementos distorcidos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular Regra de Quadratura 2D como Produto Tensorial",
                                  "subSteps": [
                                    "Derivar ∫∫ f(ξ,η) dξ dη ≈ Σ_i Σ_j w_i w_j f(ξ_i, η_j) a partir de separabilidade.",
                                    "Explicar produto de regras 1D: usar mesma ordem n em ξ e η para tensor n x n.",
                                    "Listar pontos e pesos 2D para 2x2 Gauss (4 pontos).",
                                    "Verificar exatidão para polinômios bi-quadráticos (grau 2 em cada direção)."
                                  ],
                                  "verification": "Escrever a fórmula Σ Σ w_i w_j f(ξ_i, η_j) e computar integral de f(ξ,η)=ξ^2 η^2 com erro zero.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Tabelas Gauss 1D, planilha para calcular produtos.",
                                  "tips": "Pense em grade cartesiana no domínio de referência; pesos são produtos diretos.",
                                  "learningObjective": "Construir a aproximação 2D a partir de 1D separáveis.",
                                  "commonMistakes": "Usar soma simples em vez de produto duplo; inverter índices i,j."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificar Eficiência Computacional",
                                  "subSteps": [
                                    "Comparar custo: n^2 pontos em 2D vs. métodos não-separáveis (ex: triangulação).",
                                    "Discutir otimização em FEM: reuso de pontos/pesos em funções de forma polinomiais.",
                                    "Analisar convergência: erro O(h^{2n}) para elementos de ordem 1.",
                                    "Exemplificar com 2x2 vs. 3x3 pontos em um problema real."
                                  ],
                                  "verification": "Explicar verbalmente por que n x n pontos são eficientes para exatidão em polinômios de grau 2n-1.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Gráfico de custo computacional vs. precisão, código FEM simples.",
                                  "tips": "Eficiência vem da separabilidade: evita loops aninhados desnecessários.",
                                  "learningObjective": "Avaliar vantagens numéricas em contextos FEM.",
                                  "commonMistakes": "Ignorar que |det(J)| varia, assumindo integração uniforme."
                                }
                              ],
                              "practicalExample": "Em um elemento quadrilateral isoparamétrico para análise de tensão em uma placa 2D, use regra 2x2 Gauss para integrar o termo de rigidez ∫∫ B^T D B |det(J)| dξ dη, computando Σ_{i=1}^2 Σ_{j=1}^2 w_i w_j B(ξ_i,η_j)^T D B(ξ_i,η_j) |det(J)_{ij}|, resultando em matriz 8x8 exata para elementos bilineares.",
                              "finalVerifications": [
                                "Escrever corretamente a fórmula de quadratura 2D como produto tensorial.",
                                "Listar pontos e pesos para uma regra 2x2 Gauss.",
                                "Calcular integral numérica de f(ξ,η)=1 + ξη + ξ^2 + η^2 com erro <1e-10.",
                                "Explicar transformação via jacobiano em elementos isoparamétricos.",
                                "Comparar custo de 2x2 vs. 3x3 em termos de FLOPs.",
                                "Justificar exatidão para funções de forma bilineares."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da fórmula produto (100% dos termos corretos).",
                                "Correta aplicação do jacobiano na integral transformada.",
                                "Análise quantitativa de eficiência (ex: redução de pontos vs. precisão).",
                                "Exatidão em exemplo prático com erro numérico mínimo.",
                                "Conexão clara com elementos isoparamétricos em FEM.",
                                "Ausência de erros comuns como confusão de dimensões."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Polinômios de Legendre e ortogonalidade.",
                                "Programação: Implementação em loops aninhados para FEM (Python/MATLAB).",
                                "Física Computacional: Solução de EDP elípticas em 2D.",
                                "Engenharia de Software: Otimização de algoritmos em simulações.",
                                "Estatística: Análise de erro de truncamento em métodos numéricos."
                              ],
                              "realWorldApplication": "Na simulação de elementos finitos para análise estrutural de componentes mecânicos como placas perfuradas ou carrocerias de veículos, onde a regra de quadratura 2D Gauss-Legendre permite integração exata e eficiente das matrizes de rigidez, reduzindo tempo de computação em solvers industriais como ANSYS ou Abaqus."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "34.2.4.2.1"
                            ]
                          },
                          {
                            "id": "34.2.4.2.3",
                            "name": "Avaliar precisão e convergência da integração",
                            "description": "Analisar erro de truncamento para funções polinomiais e racionais, escolhendo ordem de Gauss (ex: 2x2 para rigidez linear) baseada no grau das funções de forma e derivadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o erro de truncamento na integração Gauss-Legendre",
                                  "subSteps": [
                                    "Estudar a fórmula do erro de truncamento para polinômios: E = (f^{(2n)}(ξ))/( (2n)! ) * ∫ w(x) (x-x1)...(x-xn)^2 dx",
                                    "Analisar condições de exatidão: n+1 pontos integram exatamente polinômios até grau 2n+1",
                                    "Diferenciar integração exata de aproximada para funções racionais",
                                    "Revisar tabelas de pontos e pesos de Gauss para ordens 1x1, 2x2, 3x3",
                                    "Exemplificar com polinômio de grau 3 usando 2 pontos"
                                  ],
                                  "verification": "Resolver manualmente erro para polinômio cúbico e confirmar exatidão com 2 pontos",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta, tabela de Gauss-Legendre (PDF ou software como MATLAB)",
                                  "tips": "Memorize que para grau p, precisa de ceil((p+1)/2) pontos",
                                  "learningObjective": "Entender como o erro depende da derivada de ordem 2n+1 da integranda",
                                  "commonMistakes": "Confundir grau da função com ordem de derivação necessária"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar funções de forma e derivadas em elementos isoparamétricos 2D",
                                  "subSteps": [
                                    "Definir funções de forma N_i(ξ,η) para quadrilateral bilinear: N1=(1-ξ)(1-η)/4",
                                    "Calcular derivadas ∂N_i/∂ξ e ∂N_i/∂η, notando que são lineares ou constantes",
                                    "Mapear para coordenadas reais via Jacobiana J(ξ,η)",
                                    "Listar integrandas típicas: ∫ N_i N_j detJ dξ dη para massa; B^T D B para rigidez",
                                    "Classificar como polinômios em ξ,η ou racionais se detJ não polinomial"
                                  ],
                                  "verification": "Esboçar funções de forma e derivadas para elemento 4-nós e confirmar graus",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Diagrama de elemento isoparamétrico, software como FreeCAD ou papel",
                                  "tips": "Sempre expresse em coordenadas naturais ξ,η antes de analisar grau",
                                  "learningObjective": "Reconhecer graus polinomiais das funções de forma (1) e derivadas (0 ou 1)",
                                  "commonMistakes": "Analisar em coordenadas x,y reais em vez de ξ,η"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar grau polinomial das integrandas na matriz de rigidez",
                                  "subSteps": [
                                    "Para K = ∫ B^T D B detJ dξ dη, identificar B ~ derivadas de N",
                                    "Calcular grau: para bilinear, ∂N/∂ξ grau 1 em η, detJ grau 2 → total grau 4 em produto",
                                    "Considerar D constante (linear elástica) vs. não-linear",
                                    "Para funções racionais (ex: detJ com singularidades), estimar grau efetivo",
                                    "Somar graus em cada direção ξ e η separadamente"
                                  ],
                                  "verification": "Computar graus para elemento bilinear e trilinear, listar em tabela",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Planilha Excel ou MATLAB para simbolismo, livro de Bathe 'Finite Element Procedures'",
                                  "tips": "Use regra: grau total = grau(B) + grau(D) + grau(detJ); grau(B)=1 para bilinear",
                                  "learningObjective": "Calcular precisamente o grau máximo da integranda para escolher Gauss",
                                  "commonMistakes": "Ignorar contribuições de detJ ou assumir D não afeta grau"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Selecionar ordem de Gauss e avaliar convergência",
                                  "subSteps": [
                                    "Escolher n tal que 2n+1 >= grau máximo (ex: 2x2 para grau 3-5)",
                                    "Implementar integração numérica em código simples para malha 1 elemento",
                                    "Refinar ordem (1x1 → 3x3) e plotar norma do erro vs. ordem",
                                    "Analisar convergência: erro ~ O(h^{2n+1}) ou exponencial para polinômios",
                                    "Testar com malha refinada para confirmar independência de h"
                                  ],
                                  "verification": "Comparar K exato (analítico) vs. numérico; erro < 1e-12 para ordem adequada",
                                  "estimatedTime": "90 minutos",
                                  "materials": "MATLAB/Python com numpy/scipy, código template para FEM 2D",
                                  "tips": "Comece com 2x2 para linear; use 3x3 para quadrático ou incompressível",
                                  "learningObjective": "Escolher ordem ótima baseada em grau, balanceando precisão e custo",
                                  "commonMistakes": "Usar ordem insuficiente perto de singularidades, causando não-convergência"
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar precisão em exemplo prático e analisar sensibilidade",
                                  "subSteps": [
                                    "Montar matriz de rigidez para placa sob tração uniaxial",
                                    "Comparar deslocamentos com solução analítica",
                                    "Variar ordem de Gauss e medir ||u_num - u_exato||",
                                    "Estudar impacto de distorção do elemento em detJ racional",
                                    "Documentar tabela de erros e recomendações"
                                  ],
                                  "verification": "Gráfico de log(erros) vs. ordem mostrando platô em exatidão",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Código FEM pronto (ex: GitHub SfePy), solver analítico simples",
                                  "tips": "Monitore tempo de CPU; ordem alta só se necessário",
                                  "learningObjective": "Avaliar trade-off precisão vs. eficiência computacional",
                                  "commonMistakes": "Não normalizar erro (use norma relativa)"
                                }
                              ],
                              "practicalExample": "Em um elemento quadrilateral bilinear para análise linear elástica 2D, funções de forma grau 1, derivadas grau 0-1, detJ grau 2, D constante → integranda grau 4. Use 3x3 Gauss (exato até grau 5). Compute K e compare com integração analítica: erro < 1e-14.",
                              "finalVerifications": [
                                "Erro de truncamento calculado < 1e-10 para ordem escolhida",
                                "Convergência confirmada com refinamento de ordem (erro decresce até máquina)",
                                "Matriz de rigidez simétrica e positiva definida",
                                "Deslocamentos coincidem com analítico em 6 dígitos",
                                "Tempo de integração < 10% do tempo total FEM",
                                "Teste com elemento distorcido: erro ainda baixo"
                              ],
                              "assessmentCriteria": [
                                "Correta identificação de graus polinomiais (100% precisão)",
                                "Seleção justificada de ordem Gauss com base em 2n+1 >= grau",
                                "Análise quantitativa de erros com tabelas/gráficos",
                                "Explicação clara de convergência para polinômiais vs. racionais",
                                "Recomendações práticas para problemas reais (ex: 2x2 padrão linear)",
                                "Código reproduzível e documentado"
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Quadratura e análise de erro",
                                "Programação Científica: Implementação em Python/MATLAB",
                                "Física Computacional: Modelagem de rigidez em sólidos",
                                "Otimização: Balancear precisão e custo computacional"
                              ],
                              "realWorldApplication": "Em simulações FEM de estruturas mecânicas como vigas de pontes ou fuselagens de aviões, escolher 2x2 Gauss reduz tempo de cálculo em 80% sem perda de precisão, permitindo análises rápidas em otimização de design."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.2.4.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "34.2.4.3",
                        "name": "Avaliação de Integrais em Matrizes de Elemento",
                        "description": "Aplicação prática da integração numérica para computar matrizes de rigidez [k^e] = ∫∫ [B]^T [D] [B] t |J| dξ dη e vetores de carga em elementos quadriláteros isoparamétricos.",
                        "specificSkills": [
                          {
                            "id": "34.2.4.3.1",
                            "name": "Montar matriz [B] das derivadas das funções de forma",
                            "description": "Derivar [B] = [∂N/∂x ∂N/∂y] usando J^{-1}, para elemento em estado plano, e integrá-la numericamente com Gauss 2x2.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir funções de forma e pontos de integração Gauss 2x2",
                                  "subSteps": [
                                    "Escreva as funções de forma bilinear para elemento quadrilateral de 4 nós: N1 = (1-ξ)(1-η)/4, N2 = (1+ξ)(1-η)/4, N3 = (1+ξ)(1+η)/4, N4 = (1-ξ)(1+η)/4.",
                                    "Identifique os pontos de Gauss 2x2: (±1/√3, ±1/√3) ≈ (±0.577, ±0.577), com peso de integração w=1 para cada ponto.",
                                    "Liste as coordenadas dos nós do elemento em estado plano (x_i, y_i) para i=1 a 4.",
                                    "Calcule as funções de forma N_i em um ponto de Gauss específico.",
                                    "Verifique a soma das funções de forma: ∑N_i = 1."
                                  ],
                                  "verification": "Confirme que ∑N_i(ξ,η) = 1 em todos os pontos de Gauss e que os valores estão corretos para interpolação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel quadriculado, calculadora científica, tabela de pontos Gauss, referência de livro de Elementos Finitos (ex: Bathe).",
                                  "tips": "Use ξ=η=0 (centro) para teste rápido: cada N_i=0.25.",
                                  "learningObjective": "Compreender a representação isoparamétrica e a regra de Gauss-Legendre para integração precisa.",
                                  "commonMistakes": "Esquecer o fator /4 nas funções bilineares ou usar pontos Gauss errados (ex: confundir com 1x1)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular derivadas locais das funções de forma e matriz Jacobiana",
                                  "subSteps": [
                                    "Compute ∂N_i/∂ξ e ∂N_i/∂η para cada i=1 a 4 no ponto de Gauss escolhido.",
                                    "Forme o vetor de derivadas locais: [∂N/∂ξ] = [∂N1/∂ξ, ∂N2/∂ξ, ..., ∂N4/∂ξ]^T e similar para ∂N/∂η.",
                                    "Calcule os termos da Jacobiana: J_{11} = ∑ (∂N_i/∂ξ * x_i), J_{12} = ∑ (∂N_i/∂ξ * y_i), J_{21} = ∑ (∂N_i/∂η * x_i), J_{22} = ∑ (∂N_i/∂η * y_i).",
                                    "Verifique o determinante det(J) > 0 para elemento bem formado.",
                                    "Repita para todos os 4 pontos de Gauss."
                                  ],
                                  "verification": "Matriz J é simétrica e positiva definida; det(J) ≠ 0 e valores condizem com geometria do elemento.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Planilha Excel ou MATLAB para somas, coordenadas dos nós anotadas.",
                                  "tips": "Anote derivadas: ∂N1/∂ξ = -(1-η)/4, etc., para evitar recálculos.",
                                  "learningObjective": "Dominar o mapeamento isoparamétrico via Jacobiana para derivadas locais.",
                                  "commonMistakes": "Índices errados nos nós (ex: N1 com ξ negativo) ou esquecer soma ponderada por coordenadas nodais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Obter inversa da Jacobiana e derivadas globais",
                                  "subSteps": [
                                    "Calcule J^{-1} = (1/det(J)) * [J_{22}, -J_{12}; -J_{21}, J_{11}].",
                                    "Compute ∂N_i/∂x = (∂N_i/∂ξ * J^{-1}_{11}) + (∂N_i/∂η * J^{-1}_{21}).",
                                    "Compute ∂N_i/∂y = (∂N_i/∂ξ * J^{-1}_{12}) + (∂N_i/∂η * J^{-1}_{22}).",
                                    "Forme os vetores [∂N/∂x] e [∂N/∂y] para todos os nós.",
                                    "Valide com transformação chain rule: ∂/∂x = J^{-1} * ∂/∂ξ."
                                  ],
                                  "verification": "Verifique se as derivadas globais interpolam corretamente o gradiente da geometria (ex: ∂x/∂x=1, ∂y/∂x=0).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Calculadora matricial ou software simbólico (SymPy/MATLAB).",
                                  "tips": "det(J) = J11*J22 - J12*J21; memorize fórmula para 2x2.",
                                  "learningObjective": "Aplicar regra da cadeia para transformar derivadas locais em globais.",
                                  "commonMistakes": "Inverter linhas/colunas de J^{-1} ou sinal errado no determinante."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar matriz [B] e realizar integração numérica com Gauss 2x2",
                                  "subSteps": [
                                    "Monte [B] = [ ∂N1/∂x  0     ∂N2/∂x  0     ∂N3/∂x  0     ∂N4/∂x  0    ;  0     ∂N1/∂y  0     ∂N2/∂y  0     ∂N3/∂y  0     ∂N4/∂y ; ∂N1/∂y ∂N1/∂x ∂N2/∂y ∂N2/∂x ∂N3/∂y ∂N3/∂x ∂N4/∂y ∂N4/∂x ].",
                                    "Avalie [B] em cada um dos 4 pontos de Gauss.",
                                    "Integre numericamente: ∫[B]^T [D] [B] dΩ ≈ ∑_{k=1}^4 w_k det(J_k) [B_k]^T [D] [B_k], onde w_k=1.",
                                    "Some as contribuições ponderadas por det(J_k).",
                                    "Compare com integral analítica se elemento simples."
                                  ],
                                  "verification": "Matriz integrada [k_e] simétrica positiva definida; valores condizem com rigidez esperada.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Software numérico (MATLAB/Python com NumPy), exemplo de matriz [D] elástica.",
                                  "tips": "Estrutura de [B] 3x8 para plano tensão/deformação; use loop sobre pontos Gauss.",
                                  "learningObjective": "Construir operador de deformação [B] e aplicar quadratura numérica para matrizes de elemento.",
                                  "commonMistakes": "Ordem errada em [B] (esquecer cisalhamento γ=∂u/∂y + ∂v/∂x) ou multiplicar por w incorreto."
                                }
                              ],
                              "practicalExample": "Para um quadrado unitário com nós (0,0), (1,0), (1,1), (0,1), no ponto Gauss (0.577,0.577): calcule J ≈ [[0.789,0.211],[0.211,0.789]], J^{-1} ≈ [[0.789,-0.211],[-0.211,0.789]]/det, derive ∂N/∂x,∂N/∂y, monte [B], integre para [k_e] com E=1, ν=0.",
                              "finalVerifications": [
                                "Matriz [B] tem dimensões 3x8 com zeros corretos e derivadas alternadas.",
                                "det(J) positivo e consistente em todos pontos Gauss.",
                                "Soma das contribuições de Gauss reproduz integral exata para funções polinomiais até grau 3.",
                                "Gradiente geométrico verificado: [∂N/∂x] · x_nos = identidade.",
                                "Matriz resultante simétrica e energia positiva."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas derivadas (erro <1% vs analítico).",
                                "Correta inversão Jacobiana e chain rule aplicada.",
                                "Estrutura exata de [B] para estado plano.",
                                "Integração Gauss converge (comparar 2x2 vs 3x3).",
                                "Explicação conceitual clara do mapeamento isoparamétrico.",
                                "Implementação numérica sem erros de indexação."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Inversão de matrizes e produtos.",
                                "Cálculo Multivariável: Regra da cadeia e gradientes.",
                                "Programação: Loops numéricos em Python/MATLAB para automação.",
                                "Física/Mecânica: Deformações ε_x=∂u/∂x ligadas a [B]."
                              ],
                              "realWorldApplication": "Em simulações FEM de estruturas planas (ex: ANSYS/Abaqus), [B] é essencial para calcular matrizes de rigidez de elementos isoparamétricos em análises de tensão em placas, pontes ou componentes automotivos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.2.4.1.3",
                              "34.2.4.2.2"
                            ]
                          },
                          {
                            "id": "34.2.4.3.2",
                            "name": "Calcular matriz de rigidez por quadratura Gauss",
                            "description": "Implementar soma sobre pontos de Gauss: k^e_{mn} ≈ Σ Σ w_i w_j [B(ξ_i,η_j)]^T [D] [B(ξ_i,η_j)] t |J(ξ_i,η_j)|, para malha com elementos distorcidos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar dados do elemento e pontos de quadratura Gauss",
                                  "subSteps": [
                                    "Identifique as coordenadas dos nós do elemento isoparamétrico (ξ, η de -1 a 1 para quadrilateral).",
                                    "Defina a matriz de propriedades do material [D] (ex: para plano tensão/strain) e espessura t.",
                                    "Selecione o esquema de quadratura Gauss (ex: 2x2 pontos: (±1/√3, ±1/√3) com pesos w=1). Liste pontos (ξ_i, η_j) e pesos (w_i, w_j)."
                                  ],
                                  "verification": "Verifique se todos os dados estão corretamente listados em uma tabela ou array, sem erros de digitação nas coordenadas ou propriedades.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Folha de coordenadas do elemento, tabela de pontos Gauss padrão, calculadora ou software como MATLAB/Python.",
                                  "tips": "Use 2x2 Gauss para quadrilaterais bilineares como ponto de partida; memorize posições e pesos para eficiência.",
                                  "learningObjective": "Preparar inputs necessários para integração numérica precisa em elementos distorcidos.",
                                  "commonMistakes": "Confundir ordem dos nós (sentido anti-horário), usar pesos errados para ordem de Gauss."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular funções de forma, derivadas e Jacobiano em cada ponto Gauss",
                                  "subSteps": [
                                    "Para cada ponto (ξ_i, η_j), calcule funções de forma N_k(ξ,η) para k=1 a 4 (bilinear: N1=(1-ξ)(1-η)/4, etc.).",
                                    "Compute derivadas das funções de forma: dN/dξ e dN/dη em forma de vetor [dN/dξ; dN/dη].",
                                    "Forme matriz Jacobiana J = [∂x/∂ξ ∂y/∂ξ; ∂x/∂η ∂y/∂η] usando coordenadas x,y dos nós e chain rule; calcule det(J)."
                                  ],
                                  "verification": "Confirme det(J) > 0 em todos os pontos (elemento não invertido) e derivadas consistentes com simetria.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Matriz de nós [x y], funções de forma bilineares, calculadora matricial.",
                                  "tips": "Automatize com loop em código para múltiplos pontos; plote ξ-η para visualizar.",
                                  "learningObjective": "Dominar mapeamento isoparamétrico e garantir Jacobiano positivo para distorções.",
                                  "commonMistakes": "Erro no chain rule para J (esquecer multiplicar por dN), det(J) negativo por ordem de nós errada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Montar matriz B e calcular integrando local em cada ponto Gauss",
                                  "subSteps": [
                                    "Inverse J para obter dξ/dx, dη/dx, etc.; compute derivadas cartesianas [B] = [∂N/∂x; ∂N/∂y] para cada nó.",
                                    "Forme matriz de deformação [B(ξ_i,η_j)] completa (3x8 para plano tensão, 2D).",
                                    "Avalie termo local: [B]^T [D] [B] * t * |det(J)| * w_i * w_j."
                                  ],
                                  "verification": "Verifique se [B] tem dimensões corretas e termo local é simétrico positivo semi-definido.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Matriz [D] constitutiva, inversora de matriz 2x2, software para multiplicações matriciais.",
                                  "tips": "Mantenha [B] como bloco por nó para eficiência; use sympy ou numpy para verificação simbólica.",
                                  "learningObjective": "Construir corretamente a matriz de deformação em coordenadas globais via isoparamétrico.",
                                  "commonMistakes": "Esquecer fator t ou |J|, erro na inversão de J para elementos distorcidos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Somar contribuições e formar matriz de rigidez Ke",
                                  "subSteps": [
                                    "Inicialize Ke como matriz 8x8 zero (para 4 nós, 2 DOF/nó).",
                                    "Para cada i,j: Ke += termo local para índices m,n correspondentes aos nós.",
                                    "Arredonde e verifique simetria: Ke ≈ Ke^T."
                                  ],
                                  "verification": "Ke simétrica com diagonal positiva; compare com caso não-distorcido se aplicável.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Matriz zero inicial, loop de soma.",
                                  "tips": "Implemente em código vetorizado para evitar erros de indexação; cheque norma de Frobenius.",
                                  "learningObjective": "Finalizar integração numérica aproximando integral exata via Gauss.",
                                  "commonMistakes": "Indexação errada de DOF (ux,uy por nó), esquecer soma externa sobre i,j."
                                }
                              ],
                              "practicalExample": "Para um quadrilateral distorcido com nós: (0,0), (2,0), (2.5,1.5), (0.5,1); [D]=E/(1-ν²)*[[1 ν 0],[ν 1 0],[0 0 (1-ν)/2]]; t=1; use 2x2 Gauss. Compute Ke[1,1] ≈ 1500 N/m após soma.",
                              "finalVerifications": [
                                "Matriz Ke é simétrica (Ke - Ke^T < 1e-10).",
                                "Elementos diagonais positivos (rigidez física).",
                                "Soma das contribuições de todos pontos Gauss converge para valor esperado.",
                                "Comparação com integração exata ou software FEA (erro <5%).",
                                "det(J) >0 em todos pontos, sem inversão de elemento.",
                                "Valores de Ke escalam corretamente com t e propriedades [D]."
                              ],
                              "assessmentCriteria": [
                                "Precisão da matriz B em pelo menos 3 pontos Gauss (erro <1%).",
                                "Correta soma das contribuições (verificação de simetria absoluta).",
                                "Tratamento adequado de distorções (Jacobiano variável).",
                                "Eficiência computacional (tempo de execução em código).",
                                "Explicação clara do processo em relatório.",
                                "Aplicação a malha real sem crashes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Quadratura Gauss e aproximação de integrais.",
                                "Programação Computacional: Loops matriciais em Python/MATLAB para FEA.",
                                "Física dos Materiais: Matriz [D] constitutiva elástica.",
                                "Geometria Computacional: Mapeamento isoparamétrico e Jacobianas."
                              ],
                              "realWorldApplication": "Em software FEA como ANSYS ou Abaqus, essa matriz Ke é montada para cada elemento distorcido em simulações de estruturas aeronáuticas ou automotivas, permitindo análise precisa de tensões em malhas irregulares de CAD."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.2.4.3.1"
                            ]
                          },
                          {
                            "id": "34.2.4.3.3",
                            "name": "Comparar integração exata vs numérica",
                            "description": "Resolver integral analítica para quadrilátero retangular e comparar com Gauss 1x1, 2x2, 3x3, avaliando erro e recomendando esquema ótimo para problemas 2D.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular a integral exata analiticamente para um quadrilátero retangular",
                                  "subSteps": [
                                    "Defina o domínio isoparamétrico do quadrilátero retangular: ξ ∈ [-1, 1], η ∈ [-1, 1].",
                                    "Escolha uma função integranda representativa, como f(ξ, η) = ξ² η², comum em matrizes de elementos finitos para testar precisão.",
                                    "Compute a integral analítica: ∫_{-1}^1 ∫_{-1}^1 ξ² η² dξ dη = (∫_{-1}^1 ξ² dξ) × (∫_{-1}^1 η² dη) = (2/3) × (2/3) = 4/9 ≈ 0.4444.",
                                    "Verifique a separabilidade da função e calcule os integrais univariados explicitamente.",
                                    "Documente o resultado exato e o método usado (integração por partes ou tabelas de integrais)."
                                  ],
                                  "verification": "Confirme que o valor exato é 4/9 comparando com cálculo manual ou software simbólico como SymPy.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e lápis, calculadora, software simbólico (SymPy ou Mathematica).",
                                  "tips": "Use simetria do domínio para simplificar cálculos.",
                                  "learningObjective": "Dominar o cálculo analítico de integrais duplas separáveis em domínios retangulares.",
                                  "commonMistakes": "Esquecer limites de integração ou confundir dξ dη com Jacobiano (aqui Jacobiano=1 para isoparamétrico retangular)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar e revisar esquemas de Gauss-Legendre 1x1, 2x2 e 3x3",
                                  "subSteps": [
                                    "Liste os pontos de Gauss e pesos para 1 ponto: (0,0) com peso 2×2=4.",
                                    "Para 2×2: pontos (±1/√3, ±1/√3), peso por direção 1, total 1×1=1 por ponto (4 pontos).",
                                    "Para 3×3: pontos (-√(3/5), 0, √(3/5)), pesos (5/9, 8/9, 5/9) por direção, compute produtos para 9 pontos.",
                                    "Crie uma tabela resumindo pontos (ξ_i, η_j) e pesos w_i w_j.",
                                    "Valide os dados com tabelas padrão de quadratura Gauss-Legendre."
                                  ],
                                  "verification": "Some os pesos totais: deve ser 4 para todos os esquemas (área do domínio).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Tabela de pontos/pesos Gauss (livro ou online), planilha Excel ou papel.",
                                  "tips": "Memorize pesos para 2x2: todos pontos têm peso 1.",
                                  "learningObjective": "Entender a precisão polinomial de cada esquema (1x1: até grau 1; 2x2: grau 3; 3x3: grau 5).",
                                  "commonMistakes": "Confundir pontos de Gauss com Legendre ou usar pesos errados para dimensões separadas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e computar integrais numéricas para cada esquema",
                                  "subSteps": [
                                    "Escreva um script em Python/MATLAB para somar f(ξ_i, η_j) * w_i * w_j sobre todos os pontos.",
                                    "Compute para 1x1: 1* f(0,0)*4 = 0.",
                                    "Para 2x2: some 4 termos, cada ≈ (1/3)^2 = 1/9 ≈0.111, total 4/9.",
                                    "Para 3x3: compute 9 termos, confirme convergência para exato.",
                                    "Registre os valores aproximados: 1x1=0, 2x2=4/9, 3x3=4/9."
                                  ],
                                  "verification": "Execute o código e compare saídas com valores manuais calculados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com NumPy, MATLAB ou similar; código template para quadratura.",
                                  "tips": "Vetorize o código para eficiência em esquemas maiores.",
                                  "learningObjective": "Aplicar quadratura numérica em código para integrais 2D.",
                                  "commonMistakes": "Não multiplicar pesos separadamente (w_ξ * w_η) ou avaliar f errado."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar resultados, avaliar erros e recomendar esquema ótimo",
                                  "subSteps": [
                                    "Calcule erros relativos: |approx - exata| / |exata| para cada esquema.",
                                    "Plote erros vs número de pontos (1,4,9) e observe convergência.",
                                    "Analise custo-benefício: flops ≈ número de pontos × custo f.",
                                    "Recomende 2x2 para problemas 2D bilineares (exato para grau ≤3, comum em FEM).",
                                    "Discuta quando usar 3x3 (funções não-lineares ou elementos distorcidos)."
                                  ],
                                  "verification": "Erro 1x1=100%, 2x2=0%, 3x3=0%; recomendação justificada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Gráfico em Matplotlib/Python, relatório em Word/LaTeX.",
                                  "tips": "Use log-scale para erros em plots de convergência.",
                                  "learningObjective": "Avaliar trade-off precisão vs custo computacional em FEM.",
                                  "commonMistakes": "Ignorar normalização no erro relativo ou superestimar 1x1."
                                }
                              ],
                              "practicalExample": "Para um elemento quadrilateral bilinear 2D com função ξ² η² (representando termos quadráticos em matriz de rigidez), exata=4/9. 1x1 dá 0 (erro 100%), 2x2 e 3x3 dão 4/9 (exato), mostrando 2x2 ótimo para eficiência.",
                              "finalVerifications": [
                                "Integral exata calculada corretamente como 4/9.",
                                "Tabelas de Gauss com pontos/pesos precisos.",
                                "Códigos executam sem erros e reproduzem valores esperados.",
                                "Erros relativos computados e plotados corretamente.",
                                "Recomendação de 2x2 justificada por convergência e custo.",
                                "Relatório resume comparações quantitativamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão do cálculo analítico (integral exata correta).",
                                "Correção na implementação de quadratura Gauss (pesos/pontos).",
                                "Análise quantitativa de erros (relativos e absolutos).",
                                "Qualidade do plot de convergência e interpretação.",
                                "Recomendação fundamentada em contexto FEM 2D.",
                                "Clareza e completude do relatório."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Teoria de quadratura e erro de truncamento.",
                                "Programação Computacional: Implementação numérica eficiente.",
                                "Física/Mecânica dos Sólidos: Aplicação em matrizes de rigidez FEM.",
                                "Otimização: Trade-off precisão vs custo computacional."
                              ],
                              "realWorldApplication": "Em simulações FEM para análise estrutural (ex: ponte ou carroceria), escolher 2x2 Gauss otimiza tempo de cálculo sem perda de precisão para elementos lineares, reduzindo horas de simulação em software como ANSYS ou Abaqus."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.2.4.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.5",
                    "name": "Elementos de Placa em Flexão",
                    "description": "Formulação de elementos finitos para modelagem da flexão de placas delgadas usando teoria de Kirchhoff.",
                    "individualConcepts": [
                      {
                        "id": "34.2.3.1",
                        "name": "Teoria de Kirchhoff para Placas Delgadas",
                        "description": "Fundamentos da teoria clássica de placas delgadas de Kirchhoff, incluindo hipóteses cinemáticas, relações constitutivas para momentos e curvaturas, e equações de equilíbrio governantes para flexão.",
                        "specificSkills": [
                          {
                            "id": "34.2.3.1.1",
                            "name": "Identificar hipóteses da teoria de Kirchhoff",
                            "description": "Explicar as hipóteses fundamentais da teoria de Kirchhoff, como normal permanece normal após deformação, ausência de cisalhamento transversal e comportamento linear elástico para placas delgadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o contexto da teoria de flexão de placas",
                                  "subSteps": [
                                    "Revise os conceitos básicos de mecânica das placas delgadas, incluindo diferenças entre placas espessas e delgadas.",
                                    "Estude a geometria típica de placas (espessura h << dimensões planas).",
                                    "Identifique problemas comuns de flexão em elementos finitos 2D.",
                                    "Analise a necessidade de hipóteses simplificadoras em modelos analíticos.",
                                    "Compare brevemente com teoria de vigas para analogia."
                                  ],
                                  "verification": "Resuma em 3 frases o que distingue placas delgadas e por que hipóteses são necessárias.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Elementos Finitos (ex: Zienkiewicz), notas de aula sobre placas"
                                  ],
                                  "tips": "Use diagramas esquemáticos para visualizar deformações.",
                                  "learningObjective": "Entender o papel das hipóteses na simplificação de equações de equilíbrio.",
                                  "commonMistakes": "Confundir placas delgadas com membranas (sem flexão)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar as hipóteses fundamentais da teoria de Kirchhoff",
                                  "subSteps": [
                                    "Liste a hipótese 1: Normais à superfície média permanecem normais após deformação (ausência de cisalhamento transversal).",
                                    "Liste a hipótese 2: Normais permanecem retas e inextensíveis (plano permanece plano).",
                                    "Liste a hipótese 3: Comportamento linear elástico do material.",
                                    "Liste a hipótese 4: Deformações pequenas e deslocamentos transversais pequenos comparados à espessura.",
                                    "Liste a hipótese 5: Ausência de cargas in-plane significativas."
                                  ],
                                  "verification": "Escreva as 5 hipóteses principais com uma frase explicativa cada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Artigo ou capítulo sobre teoria de Kirchhoff, quadro branco para listar"
                                  ],
                                  "tips": "Associe cada hipótese a um diagrama de deformação.",
                                  "learningObjective": "Memorizar e descrever precisamente cada hipótese fundamental.",
                                  "commonMistakes": "Omitir a hipótese de linearidade elástica ou confundir com cisalhamento em placas espessas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar implicações matemáticas e limitações das hipóteses",
                                  "subSteps": [
                                    "Derive qualitativamente a equação bi-harmônica da teoria de Kirchhoff a partir das hipóteses.",
                                    "Discuta como a ausência de cisalhamento simplifica para 1 DOF por nó (apenas w).",
                                    "Identifique limitações: precisão para h/L > 1/10, bordas livres.",
                                    "Compare com teoria de Mindlin-Reissner (inclui cisalhamento).",
                                    "Calcule erro aproximado para uma placa cantilever simples."
                                  ],
                                  "verification": "Explique em um parágrafo como as hipóteses levam à equação ∇⁴w = q/D.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software simbólico como Mathematica ou papel para derivação, exemplos numéricos"
                                  ],
                                  "tips": "Use aproximações analíticas para validar limitações.",
                                  "learningObjective": "Conectar hipóteses a formulações matemáticas e condições de validade.",
                                  "commonMistakes": "Ignorar que Kirchhoff falha em bordas com momentos de cisalhamento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar identificação de hipóteses em um problema prático",
                                  "subSteps": [
                                    "Selecione um problema de placa em flexão e verifique validade de cada hipótese.",
                                    "Classifique se a placa é 'delgada' baseado em h/L < 1/20.",
                                    "Simule numericamente (manual ou software) violação de uma hipótese.",
                                    "Documente quando usar Kirchhoff vs. outras teorias.",
                                    "Crie um checklist para identificação futura."
                                  ],
                                  "verification": "Preencha um checklist para um problema dado, justificando cada hipótese.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplo de problema de placa (ex: simply supported square plate), FEM software básico"
                                  ],
                                  "tips": "Comece com casos analíticos exatos para comparação.",
                                  "learningObjective": "Aplicar critérios de identificação em contextos reais de elementos finitos.",
                                  "commonMistakes": "Aplicar Kirchhoff a placas espessas sem verificação geométrica."
                                }
                              ],
                              "practicalExample": "Em uma placa quadrada simply supported de aço com h=2mm, L=200mm sob carga uniforme q=1kPa: verifique h/L=0.01<0.05 (delgada), material elástico (E=200GPa, nu=0.3), sem cisalhamento transversal assumido, derive deflexão máxima w=D/q *constante.",
                              "finalVerifications": [
                                "Liste corretamente todas as 5 hipóteses principais sem omissões.",
                                "Explique a implicação da normal permanecendo normal (reduz DOFs).",
                                "Identifique corretamente 3 limitações da teoria.",
                                "Classifique validade para um problema dado (delgada ou espessa).",
                                "Compare Kirchhoff vs. Mindlin em um caso simples.",
                                "Crie um diagrama ilustrando deformação conforme hipóteses."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição das hipóteses (100% cobertura).",
                                "Compreensão de implicações matemáticas (derivação qualitativa).",
                                "Identificação correta de limitações e condições de uso.",
                                "Aplicação prática em exemplo com justificativa quantitativa.",
                                "Uso de diagramas e checklists para clareza.",
                                "Ausência de confusões com teorias de cisalhamento."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações diferenciais parciais (bi-harmônica).",
                                "Física: Mecânica do contínuo e teoria de elasticidade.",
                                "Engenharia Civil: Análise de lajes e pisos.",
                                "Computação: Implementação em software FEM (ex: ANSYS).",
                                "Materiais: Propriedades elásticas isotrópicas."
                              ],
                              "realWorldApplication": "Projeto de skins de aeronaves ou painéis automotivos delgados, onde simulações FEM com Kirchhoff reduzem tempo computacional para otimizar rigidez flexural sem cisalhamento dominante."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.2.3.1.2",
                            "name": "Derivar relações constitutivas para momentos e curvaturas",
                            "description": "Derivar as equações constitutivas que relacionam os momentos fletores (Mx, My, Mxy) às curvaturas (κx, κy, κxy) usando a lei de Hooke generalizada para isotropicidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar hipóteses da teoria de Kirchhoff e deformações cinemáticas",
                                  "subSteps": [
                                    "Estude as hipóteses de Kirchhoff para placas delgadas: seções retas permanecem retas e normais à superfície média após deformação.",
                                    "Defina as curvaturas κx = -∂²w/∂x², κy = -∂²w/∂y², κxy = -∂²w/∂x∂y, onde w é o deslocamento transversal.",
                                    "Estabeleça as deformações axiais através da espessura: εx = -z κx, εy = -z κy, γxy = -2z κxy.",
                                    "Confirme que deformações normais na direção z são desprezíveis (εz ≈ 0).",
                                    "Desenhe um diagrama esquemático de uma seção de placa mostrando deformações lineares."
                                  ],
                                  "verification": "Desenhe e rotule corretamente o diagrama de deformações e liste as 3 hipóteses principais de Kirchhoff sem erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Teoria de Placas (ex: Timoshenko), caderno para diagramas, calculadora"
                                  ],
                                  "tips": "Visualize a placa como uma viga em 2D para intuitar as curvaturas.",
                                  "learningObjective": "Compreender as relações cinemáticas entre deslocamentos e curvaturas na teoria de Kirchhoff.",
                                  "commonMistakes": [
                                    "Confundir κxy com γxy/2",
                                    "Esquecer o sinal negativo nas deformações",
                                    "Ignorar a linearidade em z"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a lei de Hooke generalizada para materiais isotrópicos em plano-estresse",
                                  "subSteps": [
                                    "Lembre a relação tensão-deformação 2D para isotrópicos em plano-estresse: σx = [E/(1-ν²)](εx + ν εy), σy = [E/(1-ν²)](εy + ν εx), τxy = [E/(2(1+ν))] γxy.",
                                    "Substitua as deformações εx = -z κx, etc., nas equações de Hooke.",
                                    "Simplifique as expressões para σx(z), σy(z), τxy(z), destacando dependência linear em z.",
                                    "Defina os fatores: D = Eh³/12(1-ν²) como rigidez flexural (antecipando integração).",
                                    "Verifique dimensionalmente: tensões devem ter unidades de força/área."
                                  ],
                                  "verification": "Escreva as 3 equações de tensão corretas em termos de curvaturas e z, com fatores E/(1-ν²) e G = E/2(1+ν).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Tabela de propriedades de materiais isotrópicos, software simbólico como SymPy ou Mathematica"
                                  ],
                                  "tips": "Use a forma matricial desde o início para facilitar: {σ} = [C] {ε}, onde [C] é a matriz de compliance invertida.",
                                  "learningObjective": "Derivar tensões em função das curvaturas usando Hooke 2D.",
                                  "commonMistakes": [
                                    "Usar plano-deformação em vez de plano-estresse",
                                    "Esquecer fator (1-ν²) no denominador",
                                    "Confundir G com E/2(1+ν)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir momentos fletores como integrais de tensões através da espessura",
                                  "subSteps": [
                                    "Defina Mx = ∫_{-h/2}^{h/2} σx z dz, My = ∫ σy z dz, Mxy = ∫ τxy z dz.",
                                    "Substitua as expressões de σx(z), etc., nas integrais.",
                                    "Integre term a term, usando simetria e limites de -h/2 a h/2.",
                                    "Obtenha Mx = D (κx + ν κy), My = D (κy + ν κx), Mxy = D(1-ν)/2 κxy.",
                                    "Escreva na forma matricial: {M} = [D] {κ}."
                                  ],
                                  "verification": "Complete as integrais e confira que resultam nas equações padrão de momentos-curvaturas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Folha de cálculo para integrais, SymPy para verificação simbólica"
                                  ],
                                  "tips": "Integre por partes ou reconheça que ∫ z² dz = 2(h³/12) = h³/6, ajustando para D.",
                                  "learningObjective": "Transformar relações locais de tensão-deformação em relações globais de momento-curvatura.",
                                  "commonMistakes": [
                                    "Limites errados de integração (ex: 0 a h)",
                                    "Esquecer multiplicar por largura b=1 implícita",
                                    "Erro no coeficiente de torção (1-ν)/2"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e generalizar as relações constitutivas",
                                  "subSteps": [
                                    "Escreva a matriz constitutiva completa [D] = D [[1, ν, 0], [ν, 1, 0], [0, 0, (1-ν)/2]].",
                                    "Verifique casos limites: uniaxial (κy=0 → Mx = D κx), torção pura (κx=κy=0 → Mxy = D(1-ν)/2 κxy).",
                                    "Discuta implicações da isotropia: propriedades iguais em x e y.",
                                    "Compare com literatura (ex: equações de Timoshenko).",
                                    "Discuta extensões para anisotrópicos (breve)."
                                  ],
                                  "verification": "A matriz [D] deve ser simétrica e positiva definida para ν < 0.5.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Referência: Timoshenko 'Theory of Plates and Shells', notas de aula"
                                  ],
                                  "tips": "Teste numericamente com E=200 GPa, ν=0.3, h=1mm para um caso simples.",
                                  "learningObjective": "Consolidar as equações finais e entender propriedades da matriz constitutiva.",
                                  "commonMistakes": [
                                    "Matriz não simétrica",
                                    "Coeficiente torcional errado como D/2",
                                    "Confundir D com EI de vigas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma placa retangular de aço (E=200 GPa, ν=0.3, h=5mm) sob curvatura κx=0.001 m⁻¹, κy=0, κxy=0, calcule Mx = D (0.001) onde D=Eh³/12(1-ν²) ≈ 1043 Nm, resultando Mx ≈ 1.043 Nm/m. Verifique com integral numérica das tensões.",
                              "finalVerifications": [
                                "As equações Mx = D(κx + ν κy), etc., estão corretas e na forma matricial.",
                                "Matriz [D] é simétrica com elementos D11=D22=D, D12=νD, D33=D(1-ν)/2.",
                                "D = Eh³/12(1-ν²) é explicitamente definido.",
                                "Casos limites (uniaxial, torção) produzem resultados esperados.",
                                "Dimensões verificadas: momentos em N.m/m, curvaturas em 1/m.",
                                "Comparação com referência padrão (Timoshenko) coincide."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações e integrais (sem erros algébricos).",
                                "Correta aplicação da lei de Hooke 2D para plano-estresse.",
                                "Clareza na apresentação matricial das relações constitutivas.",
                                "Validação com casos limites e dimensionalidade.",
                                "Compreensão conceitual das hipóteses de Kirchhoff.",
                                "Uso apropriado de símbolos e definição de D."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo integral e álgebra matricial (tensores de segunda ordem).",
                                "Física: Mecânica do contínuo e teoria da elasticidade linear.",
                                "Computação: Implementação em código FEM (ex: matriz de rigidez de elementos de placa).",
                                "Materiais: Propriedades isotrópicas e cálculo de rigidez flexural."
                              ],
                              "realWorldApplication": "Essas relações são fundamentais na análise de elementos finitos para placas em estruturas aeroespaciais (asas de aviões), automotivas (capôs) e civis (pisos de pontes), permitindo simulações precisas de flexão em softwares como ANSYS ou Abaqus para otimizar designs contra falhas por flexão."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.2.3.1.3",
                            "name": "Formular equações de equilíbrio em flexão",
                            "description": "Estabelecer as equações diferenciais de equilíbrio para placas em flexão, incluindo a equação bi-harmônica ∇⁴w = q/D, onde w é o deslocamento transversal e D o módulo de flexão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os fundamentos da teoria de Kirchhoff para placas delgadas",
                                  "subSteps": [
                                    "Estudar as hipóteses da teoria de Kirchhoff: retas normais permanecem retas e normais após deformação.",
                                    "Entender a definição de deslocamento transversal w(x,y) e rotações associadas.",
                                    "Analisar a geometria da placa: espessura h pequena em relação às dimensões planas.",
                                    "Revisar notação: coordenadas x,y no plano médio, z transversal.",
                                    "Identificar simplificações: ausência de cisalhamento transversal."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito as 5 hipóteses principais da teoria de Kirchhoff.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Timoshenko e Woinowsky-Krieger 'Theory of Plates and Shells'",
                                    "Folha de papel e caneta para anotações",
                                    "Vídeo introdutório sobre teoria de placas (YouTube ou Khan Academy)"
                                  ],
                                  "tips": "Desenhe esquemas da placa antes e depois da deformação para visualizar melhor.",
                                  "learningObjective": "Compreender as premissas cinemáticas que justificam a teoria de Kirchhoff.",
                                  "commonMistakes": [
                                    "Confundir com teoria de Mindlin-Reissner que inclui cisalhamento",
                                    "Ignorar que h << dimensões planas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir deformações e curvaturas na placa",
                                  "subSteps": [
                                    "Expressar deformações ε_x, ε_y, γ_xy em termos de w: ε_x = -z ∂²w/∂x², etc.",
                                    "Derivar curvaturas κ_x = -∂²w/∂x², κ_y = -∂²w/∂y², κ_xy = -2∂²w/∂x∂y.",
                                    "Calcular o vetor de curvatura e relacioná-lo com o tensor de deformação.",
                                    "Verificar dimensionalmente as expressões para consistência.",
                                    "Praticar com uma função w simples, como w = sin(πx/a)sin(πy/b)."
                                  ],
                                  "verification": "Derivar corretamente as expressões de curvatura para uma w dada e plotar.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de cálculo simbólico como Mathematica ou SymPy",
                                    "Caderno de exercícios",
                                    "Referência: Notas de aula sobre elementos finitos 2D"
                                  ],
                                  "tips": "Use o sinal negativo corretamente: curvatura é negativa da segunda derivada.",
                                  "learningObjective": "Relacionar o deslocamento w com as curvaturas de forma precisa.",
                                  "commonMistakes": [
                                    "Esquecer o fator 2 em κ_xy",
                                    "Confundir deformação com curvatura"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer as relações constitutivas para momentos",
                                  "subSteps": [
                                    "Recordar a lei de Hooke plana para placas isotrópicas: σ_x = (E/(1-ν²))(ε_x + ν ε_y), etc.",
                                    "Integrar tensões ao longo da espessura para obter momentos: M_x = ∫ σ_x z dz = -D (κ_x + ν κ_y).",
                                    "Derivar expressões para M_x, M_y, M_xy em termos de curvaturas e propriedades D = Eh³/12(1-ν²).",
                                    "Verificar simetria e ortogonalidade das relações.",
                                    "Calcular D numericamente para um material exemplo (aço, E=200GPa, ν=0.3, h=0.01m)."
                                  ],
                                  "verification": "Escrever as três equações de momentos corretas e calcular D para um caso dado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Tabela de propriedades mecânicas de materiais",
                                    "Calculadora ou Excel",
                                    "Livro de resistência dos materiais"
                                  ],
                                  "tips": "Lembre-se: D é o módulo de flexão, análogo ao EI em vigas.",
                                  "learningObjective": "Conectar comportamento material com esforços internos (momentos).",
                                  "commonMistakes": [
                                    "Erro no fator (1-ν²) ou na potência de h",
                                    "Confundir M_xy com torção"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular as equações de equilíbrio diferencial",
                                  "subSteps": [
                                    "Considerar elemento diferencial dx dy, forças q e reações de cisalhamento Q_x, Q_y.",
                                    "Escrever equilíbrio de forças verticais: ∂Q_x/∂x + ∂Q_y/∂y + q = 0.",
                                    "Relacionar Q_x = ∂M_x/∂x + ∂M_xy/∂y, similar para Q_y.",
                                    "Substituir momentos em termos de w e derivar ∇⁴w = q/D.",
                                    "Verificar por diferenciação: mostrar que leva à equação bi-harmônica."
                                  ],
                                  "verification": "Derivar passo a passo ∇⁴w = q/D a partir do equilíbrio, sem erros.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Papel milimetrado para desenhar elemento diferencial",
                                    "SymPy para verificação simbólica",
                                    "Artigo original de Kirchhoff (opcional)"
                                  ],
                                  "tips": "Desenhe o elemento diferencial com todas as forças e momentos atuantes.",
                                  "learningObjective": "Derivar a equação governante unificando cinemática, constitutivo e equilíbrio.",
                                  "commonMistakes": [
                                    "Erro nos sinais das derivadas de momentos para Q",
                                    "Esquecer termos mistos em M_xy"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e interpretar a equação bi-harmônica",
                                  "subSteps": [
                                    "Explicar o operador ∇⁴ = Δ(Δw), onde Δ é laplaciano.",
                                    "Discutir condições de contorno: simplesmente apoiada, engastada, livre.",
                                    "Analisar dimensionalmente: [∇⁴w] = 1/length⁴ * length = 1/length³, compatível com q/D.",
                                    "Comparar com equação de viga: d⁴w/dx⁴ = q/EI.",
                                    "Resolver numericamente um caso simples para validar."
                                  ],
                                  "verification": "Interpretar fisicamente cada termo e aplicar a um exemplo com C.C.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software MATLAB ou Python para resolver ∇⁴w = const",
                                    "Exemplos resolvidos de livros"
                                  ],
                                  "tips": "∇⁴w governa flexão pura; para placas espessas use Mindlin.",
                                  "learningObjective": "Interpretar e validar a equação final no contexto de EF.",
                                  "commonMistakes": [
                                    "Confundir ∇⁴ com ∇²",
                                    "Ignorar dependência de D"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma placa retangular de 1m x 1m, h=5cm, aço (E=200GPa, ν=0.3), simplesmente apoiada nas bordas com q=10kN/m² uniforme, formule a equação ∇⁴w = q/D com D≈5.2e6 Nm, e discuta como resolver via séries de Fourier.",
                              "finalVerifications": [
                                "Derivação completa e correta de ∇⁴w = q/D a partir das hipóteses iniciais.",
                                "Cálculo preciso do módulo de flexão D para material dado.",
                                "Explicação das hipóteses de Kirchhoff e limitações.",
                                "Aplicação correta a um exemplo com condições de contorno.",
                                "Identificação de erros comuns na derivação.",
                                "Interpretação física dos termos da equação."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação das expressões (sem erros algébricos).",
                                "Compreensão conceitual das relações cinemáticas e constitutivas.",
                                "Correta aplicação das equações de equilíbrio no elemento diferencial.",
                                "Capacidade de verificar dimensionalmente e interpretar resultados.",
                                "Clareza na apresentação escrita ou oral da derivação.",
                                "Integração com contexto de elementos finitos 2D."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações diferenciais parciais elípticas e operadores diferenciais.",
                                "Física: Mecânica dos sólidos contínuos e teoria da elasticidade.",
                                "Engenharia Civil: Análise de lajes e pisos em estruturas.",
                                "Computação: Implementação em métodos numéricos como elementos finitos.",
                                "Materiais: Propriedades elásticas e influência da espessura."
                              ],
                              "realWorldApplication": "Essencial no projeto de lajes de concreto armado em edifícios, painéis sanduíche em aviões, membranas flexíveis em turbinas eólicas e carrocerias de veículos, onde a análise precisa de flexão garante segurança e otimização de material."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "34.2.3.2",
                        "name": "Formulação Variacional para Elementos de Placa",
                        "description": "Desenvolvimento da formulação fraca baseada no princípio dos trabalhos virtuais ou energia potencial total para a flexão de placas, preparando para o método dos elementos finitos.",
                        "specificSkills": [
                          {
                            "id": "34.2.3.2.1",
                            "name": "Aplicar princípio da energia potencial total",
                            "description": "Formular a energia potencial total Π = U + V, onde U é a energia de deformação em termos de curvaturas e V o trabalho das cargas, para problemas de flexão de placas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Princípio da Energia Potencial Total em Flexão de Placas",
                                  "subSteps": [
                                    "Revise a teoria de placas de Kirchhoff e hipóteses de deformação transversal.",
                                    "Estude o princípio variacional: a solução minimiza a energia potencial total Π.",
                                    "Identifique componentes: U (energia interna de deformação) e V (energia externa das cargas).",
                                    "Discuta diferenças entre energia potencial e complemento de energia.",
                                    "Anote equação geral Π = U + V para problemas elásticos lineares."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito os componentes de Π e cite uma referência teórica.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Elementos Finitos (ex: Zienkiewicz & Taylor), notas de aula, caderno.",
                                  "tips": "Foque nas hipóteses de placa fina; ignore cisalhamento transversal inicialmente.",
                                  "learningObjective": "Entender conceitualmente Π como funcional a ser minimizado na formulação variacional.",
                                  "commonMistakes": "Confundir U com energia cinética ou ignorar linearidade elástica."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a Energia de Deformação U em Termos de Curvaturas",
                                  "subSteps": [
                                    "Lembre as curvaturas κ_xx = -∂²w/∂x², κ_yy = -∂²w/∂y², κ_xy = -∂²w/∂x∂y.",
                                    "Escreva tensões momentos M_xx, M_yy, M_xy em termos de curvaturas via relações constitutivas.",
                                    "Integre a densidade de energia de deformação sobre a espessura da placa.",
                                    "Obtenha U = (1/2) ∫∫ (D/2) (κ_xx² + κ_yy² + 2ν κ_xx κ_yy + 2(1-ν) κ_xy²) dA.",
                                    "Verifique unidades e simetria da matriz de rigidez D."
                                  ],
                                  "verification": "Derive U para uma curvatura uniaxial e compare com fórmula padrão.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora simbólica (ex: Mathematica ou papel), tabela de propriedades de materiais.",
                                  "tips": "Use coordenadas normais para simplificar; D = Eh³/12(1-ν²).",
                                  "learningObjective": "Derivar expressão quadrática de U baseada em curvaturas de Kirchhoff.",
                                  "commonMistakes": "Esquecer fator 1/2 na energia ou sinal negativo nas curvaturas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular o Trabalho das Cargas V",
                                  "subSteps": [
                                    "Classifique cargas: distribuídas q(x,y), concentradas ou de borda.",
                                    "Escreva V = - ∫∫ q(x,y) w(x,y) dA para cargas transversais distribuídas.",
                                    "Inclua cargas de borda: V_border = - ∫ Q_n w ds, onde Q_n é força cortante.",
                                    "Considere cargas concentradas: V_point = - ∑ P_i w(x_i,y_i).",
                                    "Confirme sinal negativo: V representa trabalho virtual negativo das cargas."
                                  ],
                                  "verification": "Calcule V para uma carga uniforme em placa retangular e verifique dimensionalidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Caderno para esboços, software de desenho vetorial opcional.",
                                  "tips": "Integre por partes se necessário para consistência com condições de contorno.",
                                  "learningObjective": "Expressar V como funcional linear da deflexão w.",
                                  "commonMistakes": "Usar sinal positivo em V ou esquecer integração sobre área/ contorno."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar U e V na Energia Potencial Total Π",
                                  "subSteps": [
                                    "Escreva Π[w] = U[w] + V[w] explicitamente com expressões derivadas.",
                                    "Verifique estacionariedade: δΠ = 0 leva à equação de equilíbrio da placa.",
                                    "Discuta condições de contorno naturais e essenciais na minimização.",
                                    "Simplifique para casos isotrópicos e homogêneos.",
                                    "Teste com deflexão conhecida (ex: placa simplesmente apoiada)."
                                  ],
                                  "verification": "Escreva Π completa para um problema toy e derive equação diferencial via Euler-Lagrange.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Papel milimetrado, referência à equação bi-harmônica ∇⁴w = q/D.",
                                  "tips": "Mantenha w como variável independente; Π é funcional de w.",
                                  "learningObjective": "Formular Π completa e entender sua minimização como critério de solução.",
                                  "commonMistakes": "Inverter U e V ou omitir termos de Poisson ν."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar Π em um Problema Simples de Flexão de Placa",
                                  "subSteps": [
                                    "Escolha placa retangular a x b, bordas apoiadas, carga q constante.",
                                    "Aproxime w por série de Fourier ou polinômio assumido.",
                                    "Calcule U e V numericamente para a aproximação.",
                                    "Minimize Π variando coeficientes da aproximação.",
                                    "Compare deflexão máxima com solução exata."
                                  ],
                                  "verification": "Obtenha coeficientes minimizando Π e confira erro <5% vs. analítico.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Software MATLAB/Python para otimização, ou cálculo manual para 2 termos.",
                                  "tips": "Comece com uma termo de aproximação sin(aπx/a)sin(bπy/b).",
                                  "learningObjective": "Implementar Π em Rayleigh-Ritz para validar formulação.",
                                  "commonMistakes": "Violar condições de contorno na aproximação w."
                                }
                              ],
                              "practicalExample": "Para uma placa quadrada de 1m x 1m, espessura h=0.01m, E=200GPa, ν=0.3, carga uniforme q=1kN/m², bordas simplesmente apoiadas: formule Π usando w = ∑∑ c_{mn} sin(mπx) sin(nπy), compute U e V, e resolva para c_{11} minimizando Π.",
                              "finalVerifications": [
                                "Formulação correta de curvaturas κ e matriz D.",
                                "Expressão exata de U quadrática em κ.",
                                "Cálculo preciso de V para cargas dadas.",
                                "Π completa leva a δΠ=0 consistente com ∇⁴w=q/D.",
                                "Aplicação numérica converge para solução conhecida.",
                                "Tratamento correto de condições de contorno."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de U e V (sem erros algébricos).",
                                "Compreensão conceitual: explicação clara de minimização variacional.",
                                "Capacidade de aplicar em exemplo numérico com erro <10%.",
                                "Identificação e correção de erros comuns em curvaturas ou sinais.",
                                "Integração de termos de Poisson e cisalhamento torsional.",
                                "Eficiência no tempo: completar em <4 horas totais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e equações diferenciais parciais.",
                                "Física: Teoria da elasticidade linear e princípio dos trabalhos virtuais.",
                                "Engenharia Civil: Análise de lajes e pisos em edifícios.",
                                "Computação: Implementação em código FEM (ex: FEniCS ou Abaqus scripting)."
                              ],
                              "realWorldApplication": "Na análise de elementos finitos para projetar lajes de concreto em edifícios, asas de aeronaves compostas ou painéis solares flexíveis, onde a formulação variacional de Π permite discretização eficiente em malhas finitas para prever deflexões e tensões sob cargas reais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.2.3.1.2"
                            ]
                          },
                          {
                            "id": "34.2.3.2.2",
                            "name": "Usar método de Rayleigh-Ritz para aproximação",
                            "description": "Implementar o método de Rayleigh-Ritz minimizando Π com funções de aproximação admissíveis para o deslocamento w, levando à discretização em graus de liberdade nodais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Princípio do Método Rayleigh-Ritz e a Formulação Variacional",
                                  "subSteps": [
                                    "Revise o problema de flexão de placa em 2D e o princípio de mínimos potenciais totais (Π = U - V).",
                                    "Identifique as condições de contorno e admissibilidade das funções de aproximação para o deslocamento w.",
                                    "Estude a expressão do funcional de energia Π para elementos de placa, incluindo termos de deformação e cargas.",
                                    "Verifique a estacionariedade de Π: δΠ = 0 para variações admissíveis.",
                                    "Anote os graus de liberdade nodais (ex: w_i em nós)."
                                  ],
                                  "verification": "Resuma em um parágrafo o princípio e escreva a expressão de Π para uma placa simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Elementos Finitos (ex: Zienkiewicz), notas de aula, calculadora.",
                                  "tips": "Comece com um problema 1D simples (viga) para analogia antes de 2D.",
                                  "learningObjective": "Compreender a base variacional e admissibilidade das funções aproximadas.",
                                  "commonMistakes": "Confundir funções admissíveis com funções exatas; ignorar condições essenciais de contorno."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e Definir Funções de Aproximação Admissíveis",
                                  "subSteps": [
                                    "Escolha funções polinomiais ou modais que satisfaçam condições geométricas (ex: w = Σ c_i φ_i(x,y)).",
                                    "Para um elemento retangular, use polinômios bicúbicos completos com 12 termos.",
                                    "Defina os graus de liberdade nodais: valores de w, rotações ∂w/∂x, ∂w/∂y em cada nó.",
                                    "Garanta completude, rigidez e continuidade entre elementos.",
                                    "Teste admissibilidade plotando as funções φ_i."
                                  ],
                                  "verification": "Liste 3 funções φ_i e verifique se satisfazem C1 continuidade em uma malha.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software MATLAB ou Python (SymPy para simbólico), papel milimetrado.",
                                  "tips": "Use funções de Lagrange ou Hermite para nós com derivadas.",
                                  "learningObjective": "Selecionar funções que garantam convergência e precisão.",
                                  "commonMistakes": "Escolher funções que violam condições de contorno essenciais; polinômios incompletos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Expressar o Deslocamento Aproximado e Calcular o Funcional Π",
                                  "subSteps": [
                                    "Escreva w(x,y) ≈ Σ q_j φ_j(x,y), onde q_j são graus de liberdade generalizados.",
                                    "Compute a energia de deformação U = (1/2) ∫ B^T D B dA, com operadores de curvatura.",
                                    "Calcule o trabalho das cargas V = ∫ p w dA + cargas de momento.",
                                    "Substitua w aproximado em Π(q) = U(q) - V(q).",
                                    "Simplifique expressões analiticamente ou numericamente via integração de Gauss."
                                  ],
                                  "verification": "Derive Π(q) para um elemento com 4 DOFs e confira termos quadráticos.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "MATLAB para integração numérica, tabela de pontos de Gauss.",
                                  "tips": "Use coordenadas naturais do elemento para simplificar integrais.",
                                  "learningObjective": "Formular Π em termos dos parâmetros livres q.",
                                  "commonMistakes": "Erros em operadores diferenciais (ex: confundir κ_xx com ∂²w/∂x²); integração incorreta."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Minimizar Π e Montar o Sistema de Equações",
                                  "subSteps": [
                                    "Compute ∂Π/∂q_i = 0 para cada i, resultando em K q = F.",
                                    "Forme a matriz de rigidez [K]_{ij} = ∂²Π/∂q_i ∂q_j = ∫ B^T D B dA.",
                                    "Calcule o vetor de forças F_i = ∂V/∂q_i.",
                                    "Monte a matriz global por superposição para múltiplos elementos.",
                                    "Resolva o sistema linear K q = F."
                                  ],
                                  "verification": "Confira simetria e positiva definitividade de K; resolva para q e plote w.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "MATLAB ou Python (NumPy/SciPy) para solver linear.",
                                  "tips": "Implemente uma função para computar [B] em cada ponto de Gauss.",
                                  "learningObjective": "Derivar e resolver o sistema discreto Rayleigh-Ritz.",
                                  "commonMistakes": "Assinaturas erradas em derivadas; não impor condições de contorno no K reduzido."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Interpretar Resultados",
                                  "subSteps": [
                                    "Compare com solução exata ou EF comercial para uma placa carregada uniformemente.",
                                    "Analise convergência refinando a malha ou ordem polinomial.",
                                    "Calcule tensões/momenta via relações constitutivas.",
                                    "Avalie sensibilidade a escolha de funções.",
                                    "Documente limitações (ex: cisalhamento transverse ignorado)."
                                  ],
                                  "verification": "Erro <5% em deslocamento central vs. analítico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software ANSYS ou similar para benchmark.",
                                  "tips": "Use malhas h e p refinamento para estudo de convergência.",
                                  "learningObjective": "Avaliar precisão e robustez da aproximação.",
                                  "commonMistakes": "Ignorar efeitos de cisalhamento; superestimar precisão sem validação."
                                }
                              ],
                              "practicalExample": "Para uma placa quadrada simplesmente apoiada (a x a = 1m), espessura h=0.01m, E=210GPa, ν=0.3, carga uniforme q=1kN/m²: use 1 elemento bicúbico, compute w_max central e compare com solução de Navier (erro ~2%).",
                              "finalVerifications": [
                                "Matriz K é simétrica e definida positiva.",
                                "Condições de contorno essenciais impostas corretamente em q.",
                                "Deslocamentos w interpolados satisfazem admissibilidade.",
                                "Energia Π minimizada (verificar δΠ ≈ 0).",
                                "Convergência observada com refinamento de malha.",
                                "Tensões computadas coerentes com teoria de Kirchhoff."
                              ],
                              "assessmentCriteria": [
                                "Correção na formulação de Π e derivadas (80% peso).",
                                "Escolha adequada de funções φ_i e admissibilidade.",
                                "Implementação numérica precisa do solver Kq=F.",
                                "Análise de erros e convergência documentada.",
                                "Interpretação física dos resultados.",
                                "Clareza na documentação e código."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Resolução de sistemas simétricos positivos definidos.",
                                "Cálculo Variacional: Princípio de Hamilton e mínimos estacionários.",
                                "Programação Numérica: Integração de Gauss e assembly de matrizes.",
                                "Física da Elasticidade: Teoria de placas de Kirchhoff-Love."
                              ],
                              "realWorldApplication": "Análise de flexão em asas de aeronaves, decks de pontes e painéis automotivos, onde simulações EF via Rayleigh-Ritz otimizam design leve e resistente."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.2.3.1.3"
                            ]
                          },
                          {
                            "id": "34.2.3.2.3",
                            "name": "Formular versão fraca via Galerkin",
                            "description": "Derivar a forma integral fraca ∫ B^T D B dw dΩ = ∫ N^T q dΩ usando funções de teste para elementos de placa, garantindo conformidade C1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a formulação forte do problema de flexão de placas e princípios do método Galerkin",
                                  "subSteps": [
                                    "Estude a equação diferencial forte para placas de Kirchhoff: D ∇⁴ w = q, onde w é o deslocamento transversal, D é a rigidez flexural e q é a carga distribuída.",
                                    "Revise os princípios do método dos pesos de Galerkin: multiplicar a equação forte por uma função de teste v e integrar sobre o domínio Ω.",
                                    "Identifique as condições de contorno essenciais (C1: continuidade de w e ∂w/∂n) e naturais.",
                                    "Anote os operadores diferenciais envolvidos: bi-harmônico ∇⁴w.",
                                    "Discuta por que a forma forte requer funções C1 para convergência."
                                  ],
                                  "verification": "Escreva a equação forte e explique verbalmente os princípios de Galerkin para um colega.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Livro 'Finite Element Procedures' de K.J. Bathe (Capítulo 8), notas de aula sobre teoria de placas, calculadora simbólica como SymPy.",
                                  "tips": "Comece sempre pela física do problema para intuitivamente entender a matemática.",
                                  "learningObjective": "Compreender a base física e matemática necessária para derivar a forma fraca.",
                                  "commonMistakes": "Confundir operadores laplaciano (∇²) com bi-harmônico (∇⁴); ignorar continuidade C1 desde o início."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar funções de aproximação e teste com conformidade C1",
                                  "subSteps": [
                                    "Escolha funções de forma N_i para w^h = Σ N_i w_i, garantindo C1 (contínuas em w e gradientes).",
                                    "Para elementos de placa: use polinômios completos de grau 3 (ex: 12 nós para quadrilátero) ou elementos conforme como ACM (Andalusis Conforming Membrane).",
                                    "Defina funções de teste v = N_j, iguais às de aproximação (Galerkin).",
                                    "Defina a matriz de curvatura B, onde κ = B w_e, com κ_x = ∂²w/∂x², etc.",
                                    "Verifique numericamente a continuidade C1 em nós compartilhados entre elementos.",
                                    "Liste operadores diferenciais: B contém segundas derivadas mistas."
                                  ],
                                  "verification": "Desenhe um elemento de placa e confirme que as funções N_i satisfazem C1 em interfaces.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Livro 'The Finite Element Method' de Zienkiewicz (Vol. 2, Capítulo 11), software FEA como ANSYS para visualização, papel e lápis para esboços.",
                                  "tips": "Use elementos de referência e mapeamento isoparamétrico para simplificar.",
                                  "learningObjective": "Selecionar funções adequadas que garantam convergência ótima no método dos elementos finitos.",
                                  "commonMistakes": "Escolher funções C0 (como em membranas), levando a locking ou não-conformidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a forma integral fraca via integração por partes",
                                  "subSteps": [
                                    "Multiplique a equação forte por v e integre: ∫_Ω v D ∇⁴ w dΩ = ∫_Ω v q dΩ.",
                                    "Aplique o teorema da integração por partes duas vezes para reduzir a ordem: ∫ D (∇²v ∇²w - mistos) dΩ + termos de contorno.",
                                    "Obtenha a forma bilinear simétrica: a(w,v) = ∫_Ω D ∇²w · ∇²v dΩ = l(v) = ∫_Ω q v dΩ + contornos.",
                                    "Para elementos: substitua w^h e v^h, resultando em ∫ B^T D B w_e dΩ = ∫ N^T q dΩ.",
                                    "Inclua espessura t se D = E t^3 / 12(1-ν²): ∫_Ω t B^T D B dw dΩ.",
                                    "Discuta termos de contorno (momentos e forças cortantes)."
                                  ],
                                  "verification": "Derive a equação fraca em papel e confirme que ela coincide com a forma padrão de Hughes ou Bathe.",
                                  "estimatedTime": "2 horas",
                                  "materials": "SymPy ou Mathematica para manipulação simbólica, quadro branco para derivações passo a passo.",
                                  "tips": "Faça integração por partes sistematicamente: primeiro em x, depois em y, agrupando termos.",
                                  "learningObjective": "Transformar a PDE forte em uma forma variacional fraca estável numericamente.",
                                  "commonMistakes": "Erros de sinal na integração por partes; esquecer termos de contorno naturais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discretizar e formular a equação matricial do elemento",
                                  "subSteps": [
                                    "Defina K_e = ∫_Ω B^T D B t dΩ e F_e = ∫_Ω N^T q t dΩ.",
                                    "Escolha gauss points para integração numérica (3x3 para quadriláteros).",
                                    "Implemente computação de B em coordenadas locais.",
                                    "Monte o sistema global via montagem de elementos.",
                                    "Verifique propriedades: K_e simétrica positiva definida para D isotrópico.",
                                    "Teste com um problema simples (placa simply supported)."
                                  ],
                                  "verification": "Compute K_e para um elemento unitário e resolva um exemplo analítico conhecido.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "MATLAB ou Python com NumPy/SciPy para protótipo, exemplos de código de Bathe.",
                                  "tips": "Use Jacobiano para transformação de coordenadas curvilíneas.",
                                  "learningObjective": "Obter a formulação pronta para implementação computacional em FEA.",
                                  "commonMistakes": "Integração numérica insuficiente causando erro; inversão errada de D para anisotrópico."
                                }
                              ],
                              "practicalExample": "Para um elemento retangular 2x2 de placa fina com D isotrópico, carga q=1 N/m² e espessura t=0.01m, derive K_e (12x12 para 12 DOFs C1) usando 3x3 Gauss quadrature, resultando em ∫ B^T D B t dx dy = F_e com F_e ≈ [0.133 q A, ...] para área A=4, e resolva para deflexão central w≈0.00413m comparado ao analítico.",
                              "finalVerifications": [
                                "A forma bilinear a(w,v) é simétrica e coerciva para estabilidade.",
                                "Conformidade C1 confirmada: w e ∂w/∂n contínuos entre elementos.",
                                "Termos de contorno corretamente identificados (M_n e Q_n).",
                                "Matriz K_e simétrica e positiva semi-definida.",
                                "Recuperação de solução exata no limite h→0.",
                                "Ausência de termos espúrios (ex: shear locking evitado por C1)."
                              ],
                              "assessmentCriteria": [
                                "Precisão da derivação da forma fraca (sem erros de integração por partes).",
                                "Correta definição de B com segundas derivadas.",
                                "Garantia explícita de continuidade C1 nas funções escolhidas.",
                                "Formulação matricial coerente com literatura padrão.",
                                "Inclusão de termos de carga e contorno.",
                                "Capacidade de implementar numericamente um exemplo simples."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Variacional e Análise Funcional (Matemática Avançada)",
                                "Teoria da Elasticidade e Mecânica dos Sólidos (Física/Engenharia)",
                                "Métodos Numéricos e Programação Científica (Computação)",
                                "Análise Estrutural (Engenharia Civil/Aeroespacial)"
                              ],
                              "realWorldApplication": "Essa formulação é essencial para simular a flexão de placas em projetos de aviões (casco de fuselagem), carros (painéis de carroceria), pontes (lajes) e eletrônicos (placas de circuito flexíveis), permitindo otimização de peso e resistência via software FEA como NASTRAN ou Abaqus."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.2.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "34.2.3.3",
                        "name": "Elemento Finito Conforme para Flexão de Placas",
                        "description": "Construção de elementos finitos específicos para placas, incluindo funções de interpolação C1 contínuas, matrizes de rigidez e tratamento de condições de contorno.",
                        "specificSkills": [
                          {
                            "id": "34.2.3.3.1",
                            "name": "Definir funções de interpolação C1 para elementos de placa",
                            "description": "Construir funções de forma Hermite bicúbicas para elementos retangulares de 12 DOFs (w, ∂w/∂x, ∂w/∂y por nó) ou triangulares conformes, garantindo continuidade de w e derivadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender requisitos de continuidade C1 para elementos de placa em flexão",
                                  "subSteps": [
                                    "Revise a equação bi-harmônica governante para flexão de placas finas (teoria de Kirchhoff).",
                                    "Identifique graus de liberdade (DOFs): deslocamento transversal w e derivadas ∂w/∂x, ∂w/∂y em cada nó.",
                                    "Explique por que continuidade C1 (w, ∂w/∂ξ, ∂w/∂η contínuos nas bordas) é necessária para convergência.",
                                    "Compare com continuidade C0 insuficiente para elementos de placa.",
                                    "Estude exemplos de não-conformidade e seus efeitos em soluções FEM."
                                  ],
                                  "verification": "Resuma em um diagrama os DOFs por nó e condições de continuidade exigidas.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro de Zienkiewicz 'The Finite Element Method', notas de aula sobre teoria de placas, software MATLAB para visualização.",
                                  "tips": "Use analogia com vigas: assim como funções Hermite para vigas precisam de continuidade C1, placas precisam em 2D.",
                                  "learningObjective": "Compreender a necessidade matemática e física de interpolação C1 em elementos de placa.",
                                  "commonMistakes": "Confundir C0 (apenas w contínuo) com C1; ignorar derivadas mistas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar funções de interpolação Hermite bicúbicas para elementos retangulares",
                                  "subSteps": [
                                    "Assuma elemento retangular com 4 nós, 12 DOFs totais (3 por nó).",
                                    "Construa polinômio bicúbico completo: w(ξ,η) = a1 + a2ξ + ... + a16ξ³η³ (16 termos).",
                                    "Aplique condições de contorno nos DOFs dos 4 nós para resolver sistema 12x16, reduzindo a 12 funções de forma independentes.",
                                    "Expresse funções de forma N_i^w, N_i^x, N_i^y para cada DOF.",
                                    "Implemente em código simbólico (ex: SymPy) para gerar expressões explícitas."
                                  ],
                                  "verification": "Verifique que cada função de forma satisfaz unidade em seu DOF e zero nos outros 11 DOFs.",
                                  "estimatedTime": "4 horas",
                                  "materials": "SymPy ou Mathematica para álgebra simbólica, papel e lápis para derivação manual.",
                                  "tips": "Normalize coordenadas isoparamétricas ξ,η ∈ [-1,1]; comece com 1D Hermite e estenda para 2D.",
                                  "learningObjective": "Derivar e expressar funções Hermite bicúbicas que garantem C1 em elementos retangulares.",
                                  "commonMistakes": "Erros no sistema de equações (substituição incorreta de DOFs); esquecer termos mistos ξ²η."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar funções de interpolação conformes para elementos triangulares",
                                  "subSteps": [
                                    "Identifique configuração: triângulo com 3 nós, mas precisa de DOFs adicionais para C1 (tipicamente 12 DOFs com midside).",
                                    "Estude funções de Morley (não-conformes aproximadas) vs. verdadeiramente conformes (ex: elementos com 18 DOFs).",
                                    "Deriva polinômios completos de grau 3 em triângulo: 10 termos para w, mais para derivadas.",
                                    "Use mapeamento conforme de triângulo referência para físico.",
                                    "Compare complexidade com retangulares."
                                  ],
                                  "verification": "Desenhe malha e confirme continuidade de w e gradientes normais nas arestas compartilhadas.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Artigos sobre elementos triangulares C1 (ex: de Cook ou Bell), software FEniCS para teste.",
                                  "tips": "Para simplicidade inicial, foque em elementos triangulares lineares não-conformes e evolua para conformes.",
                                  "learningObjective": "Diferenciar e derivar interpoladores C1 em geometrias triangulares.",
                                  "commonMistakes": "Assumir DOFs apenas nos vértices (insuficiente para C1); confundir com elementos de tensão plana."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar continuidade C1 e implementar avaliação numérica",
                                  "subSteps": [
                                    "Teste continuidade de w, ∂w/∂x, ∂w/∂y ao longo de bordas entre elementos adjacentes.",
                                    "Calcule matriz de rigidez [K] para um patch de elementos e verifique simetria/positividade.",
                                    "Implemente em código FEM simples para problema de placa cantilever.",
                                    "Compare solução com analítica (ex: placa simplesmente apoiada).",
                                    "Analise convergência com refinamento de malha."
                                  ],
                                  "verification": "Gráficos de w e derivadas contínuas em interface de elementos; erro <5% vs. solução exata.",
                                  "estimatedTime": "3 horas",
                                  "materials": "MATLAB ou Python com NumPy/SciPy, código base de FEM 2D.",
                                  "tips": "Use plot de contorno para visualizar descontinuidades; debugue DOFs normalizando funções.",
                                  "learningObjective": "Validar numericamente a conformidade C1 das funções interpoladoras.",
                                  "commonMistakes": "Erro de indexação em vetores de DOFs; não mapear derivadas corretamente para coordenadas globais."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e documentar funções para uso em solver FEM",
                                  "subSteps": [
                                    "Compile expressões finais das funções de forma em tabela (para retangular e triangular).",
                                    "Derive derivadas analíticas necessárias para [B] matrix (curvatura).",
                                    "Escreva rotina para montagem de elemento em código.",
                                    "Teste com benchmark: flexão de placa quadrada.",
                                    "Documente limitações (ex: locking em elementos finos)."
                                  ],
                                  "verification": "Código roda sem erros e reproduz solução conhecida de literatura.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Editor de código (VSCode), repositórios GitHub de FEM codes.",
                                  "tips": "Armazene funções como lambdas em Python para eficiência.",
                                  "learningObjective": "Preparar interpoladores C1 para integração em um solver FEM completo.",
                                  "commonMistakes": "Derivadas numéricas imprecisas; ignorar transformação de coordenadas."
                                }
                              ],
                              "practicalExample": "Para um elemento retangular [-1,1]x[-1,1] com DOFs w1=1, ∂w1/∂ξ=0, ∂w1/∂η=0 nos outros nós zero, compute w(0,0) usando funções Hermite bicúbicas; resultado deve ser 1/16 para função de forma central.",
                              "finalVerifications": [
                                "Funções satisfazem todos 12 DOFs unitários e zero nos demais.",
                                "w e gradientes ∂w/∂n contínuos em bordas compartilhadas.",
                                "Matriz [K] simétrica positiva definida para problema padrão.",
                                "Convergência ótima observada em refinamento h.",
                                "Solução coincide com analítica em benchmark simples.",
                                "Derivadas analíticas coincidem com numéricas (erro <1e-10)."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática das funções derivadas (100% match com referências).",
                                "Evidência de verificação de continuidade C1 em pelo menos 2 casos.",
                                "Implementação funcional em código com testes.",
                                "Explicação clara de DOFs e condições de contorno.",
                                "Análise de erros comuns e como evitá-los.",
                                "Conexão com teoria de convergência FEM."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Polinômios multivariados e sistemas lineares.",
                                "Programação: Álgebra simbólica e desenvolvimento numérico.",
                                "Física: Teoria de elasticidade de placas (Kirchhoff-Love).",
                                "Engenharia Civil: Análise de lajes e pisos.",
                                "Computação Científica: Otimização de malhas e solvers iterativos."
                              ],
                              "realWorldApplication": "Desenvolvimento de software FEM para análise de flexão em estruturas como asas de aeronaves, painéis de carroceria automotiva, pisos de edifícios e membranas em dispositivos MEMS, garantindo precisão em simulações de engenharia estrutural."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.2.3.2.2"
                            ]
                          },
                          {
                            "id": "34.2.3.3.2",
                            "name": "Montar matriz de rigidez do elemento",
                            "description": "Calcular a matriz de rigidez [k] = ∫ [B]^T [D] [B] t dΩ, onde [B] contém derivadas segundas das funções de forma e [D] a matriz constitutiva de flexão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir geometria do elemento e funções de forma",
                                  "subSteps": [
                                    "Escolha o tipo de elemento finito conforme para flexão de placas (ex: quadrilátero de 4 nós).",
                                    "Defina as coordenadas naturais (ξ, η) no domínio de referência [-1,1] x [-1,1].",
                                    "Escreva as funções de forma N_i(ξ, η) para cada nó i=1 a 4, garantindo interpolação conforme.",
                                    "Calcule as derivadas primeiras das funções de forma em relação a ξ e η.",
                                    "Mapeie para coordenadas físicas (x,y) usando funções de transformação isoparamétricas."
                                  ],
                                  "verification": "Verifique se as funções de forma somam 1 em qualquer ponto e são 1 no nó correspondente e 0 nos outros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Elementos Finitos (ex: Zienkiewicz)",
                                    "Software MATLAB ou Python para plotar funções"
                                  ],
                                  "tips": "Use simetria do elemento quadrado para simplificar cálculos iniciais.",
                                  "learningObjective": "Compreender e formular funções de forma conformes para elementos de placa.",
                                  "commonMistakes": [
                                    "Confundir funções de forma com as de viga (1D)",
                                    "Esquecer normalização ∂N/∂ξ + ∂N/∂η = 0 em bordas",
                                    "Ignorar mapeamento isoparamétrico para elementos distorcidos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a matriz de curvatura [B]",
                                  "subSteps": [
                                    "Lembre que para flexão de placas, os graus de liberdade são w, θ_x = ∂w/∂x, θ_y = ∂w/∂y por nó.",
                                    "Calcule segundas derivadas: κ_xx = ∂²w/∂x², κ_yy = ∂²w/∂y², κ_xy = ∂²w/∂x∂y.",
                                    "Expresse derivadas em coordenadas naturais usando Jacobiana [J]: ∂/∂x = (∂ξ/∂x)∂/∂ξ + (∂η/∂x)∂/∂η.",
                                    "Monte [B] como matriz 3x12 (para 4 nós), onde cada coluna contém contribuições de um DOF para as curvaturas.",
                                    "Avalie [B] em pontos de integração Gauss."
                                  ],
                                  "verification": "Confirme que [B] tem dimensões corretas (3x ndof) e que em pontos nodais, apenas o DOF local contribui.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Calculadora simbólica (SymPy ou Mathematica)",
                                    "Folhas de derivadas da Jacobiana pré-computadas",
                                    "Código MATLAB para [B] numérica"
                                  ],
                                  "tips": "Use regra da cadeia rigorosamente para derivadas mistas; teste em elemento unitário.",
                                  "learningObjective": "Derivar a matriz [B] contendo segundas derivadas das funções de forma.",
                                  "commonMistakes": [
                                    "Usar derivadas primeiras em vez de segundas",
                                    "Inverter termos da Jacobiana",
                                    "Esquecer fator de espessura t na integral"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir a matriz constitutiva [D] para flexão",
                                  "subSteps": [
                                    "Assuma material isotrópico com módulo E, Poisson ν e espessura t.",
                                    "Formule [D] 3x3: D11 = D22 = E t^3 / (12(1-ν²)), D12 = ν D11, D33 = (1-ν)D11/2.",
                                    "Inclua efeitos de cisalhamento se for placa de Kirchhoff-Mindlin (mas foque em Kirchhoff fina).",
                                    "Verifique simetria e positividade de [D].",
                                    "Ajuste para ortotrópico se necessário, definindo termos D_ij."
                                  ],
                                  "verification": "Calcule determinante de [D] >0 e trace positivo para estabilidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de propriedades de materiais",
                                    "Planilha Excel para [D]",
                                    "Referência teórica de placas (Timoshenko)"
                                  ],
                                  "tips": "Memorize fórmula padrão para isotrópico; derive de teoria de placas clássica.",
                                  "learningObjective": "Construir [D] baseada nas propriedades do material e geometria.",
                                  "commonMistakes": [
                                    "Confundir com [D] de tensão plano para membranas",
                                    "Usar t em vez de t^3",
                                    "Ignorar fator 1-ν²"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular e computar a integral da matriz de rigidez [k]",
                                  "subSteps": [
                                    "Escreva [k] = ∫ [B]^T [D] [B] t det(J) dξ dη sobre [-1,1]^2.",
                                    "Escolha pontos de Gauss (2x2 ou 3x3 para precisão).",
                                    "Avalie [B], [D], det(J) em cada ponto Gauss com pesos w_i w_j.",
                                    "Some contribuições: k += [B]^T [D] [B] t det(J) w_i w_j.",
                                    "Armazene matriz simétrica 12x12, aplicando penalização se necessário para rigidez."
                                  ],
                                  "verification": "Verifique simetria de [k] (k_ij = k_ji) e autovalores positivos.",
                                  "estimatedTime": "1 hora 30 minutos",
                                  "materials": [
                                    "Tabela de pontos/pesos Gauss",
                                    "Código Python/MATLAB para integração numérica",
                                    "Elemento de teste com solução analítica"
                                  ],
                                  "tips": "Use 2x2 Gauss para quadriláteros regulares; vetorize computação em software.",
                                  "learningObjective": "Realizar integração numérica para montar [k] completa.",
                                  "commonMistakes": [
                                    "Esquecer det(J) ou t na integral",
                                    "Usar pontos Gauss inadequados levando a lock",
                                    "Não simetrizar [k] numericamente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e interpretar a matriz [k]",
                                  "subSteps": [
                                    "Compare com fórmula analítica para elemento retangular simples.",
                                    "Calcule rigidez axial/bending separadamente.",
                                    "Teste patch test: soma de [k] em malha deve reproduzir solução exata.",
                                    "Analise condição numérica (cond([k])).",
                                    "Documente [k] para montagem global."
                                  ],
                                  "verification": "Autovalores mínimos >0 e norma Frobenius razoável.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software FEA (ex: Abaqus viewer para comparação)",
                                    "Solução analítica de placa cantilever"
                                  ],
                                  "tips": "Sempre normalize unidades (N/m para rigidez em flexão).",
                                  "learningObjective": "Validar correção da matriz [k] montada.",
                                  "commonMistakes": [
                                    "Ignorar singularidades em DOFs rotacionais",
                                    "Comparar com elementos de viga",
                                    "Não checar simetria final"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma placa fina isotrópica (E=210 GPa, ν=0.3, t=0.01m) em elemento quadrado de 1x1m com 4 nós: compute [k] 12x12 usando 2x2 Gauss. Resultado típico: termos diagonais ~1e6 N.m para bending, off-diagonais acoplados ~1e5.",
                              "finalVerifications": [
                                "Matriz [k] é simétrica e definida positiva semi-definida.",
                                "[k] tem dimensões corretas (ndof x ndof, ex: 12x12).",
                                "Integral converge com refinamento Gauss (erro <1%).",
                                "Patch test passa: deformação unitária constante reproduzida.",
                                "Comparação com analítica para retângulo: erro <0.5%.",
                                "Condição numérica cond([k]) < 1e6."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de [B] (derivadas segundas corretas: 100%).",
                                "Correção de [D] para material dado (fórmula exata).",
                                "Implementação numérica da integral sem erros de indexação.",
                                "Validações quantitativas realizadas e documentadas.",
                                "Interpretação física dos termos de [k] (bending vs shear).",
                                "Eficiência computacional (tempo <5s em MATLAB para um elemento)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo multivariável e integração numérica Gauss.",
                                "Programação: Implementação matricial em Python/MATLAB com NumPy.",
                                "Física: Teoria de elasticidade linear e placas de Kirchhoff.",
                                "Engenharia de Materiais: Propriedades anisotrópicas em [D].",
                                "Computação Científica: Condicionamento matricial e solvers."
                              ],
                              "realWorldApplication": "Usado em software FEA como ANSYS para simular flexão de painéis aeronáuticos, cascos de navios ou lajes de edifícios, prevendo deformações e tensões sob cargas distribuídas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.2.3.2.3"
                            ]
                          },
                          {
                            "id": "34.2.3.3.3",
                            "name": "Tratar condições de contorno em placas",
                            "description": "Aplicar condições essenciais (w=0, θ=0) e naturais (momentos, forças cortantes) em elementos de placa, incluindo apoios simplesmente apoiados e engastados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de condições de contorno em placas",
                                  "subSteps": [
                                    "Estude a teoria da flexão de placas finas segundo Kirchhoff, identificando variáveis primárias (deslocamento w e rotação θ).",
                                    "Diferencie condições essenciais (cinemáticas: w=0, θ=0) de condições naturais (estáticas: momentos M e forças cortantes Q).",
                                    "Revise os tipos de apoios: simplesmente apoiado (w=0, M livre) e engastado (w=0, θ=0).",
                                    "Analise equações de equilíbrio para placas: ∇⁴w = q/D, onde D é a rigidez flexural.",
                                    "Desenhe diagramas esquemáticos de uma placa com diferentes apoios."
                                  ],
                                  "verification": "Resuma em um diagrama as condições essenciais e naturais para apoios simplesmente apoiado e engastado.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro de Elementos Finitos (ex: Zienkiewicz), notas de aula, software de desenho (Draw.io).",
                                  "tips": "Use analogias com vigas para visualizar: apoio simples como articulado, engastado como fixo.",
                                  "learningObjective": "Identificar e classificar corretamente condições de contorno em placas.",
                                  "commonMistakes": "Confundir condições essenciais com naturais; ignorar que θ é derivada de w."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar condições essenciais em elementos de placa",
                                  "subSteps": [
                                    "Implemente w=0 em nós de borda apoiada via restrição direta de graus de liberdade (GLs).",
                                    "Calcule e imponha θ=0 (∂w/∂n=0) para bordas engastadas, usando aproximações conforme no elemento finito.",
                                    "Monte a matriz de rigidez K considerando penalidades ou Lagrange multipliers para essenciais.",
                                    "Teste em um elemento quadrilateral conforme (ex: 12 nós para Kirchhoff).",
                                    "Verifique simetria e convergência da solução."
                                  ],
                                  "verification": "Execute uma simulação simples e confirme que deslocamentos em bordas atendem w=0 e θ=0 onde aplicável.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Software FEA (ANSYS, Abaqus ou código MATLAB/Python), exemplos de malha de placa.",
                                  "tips": "Para θ=0, use nós laterais para aproximar a derivada normal.",
                                  "learningObjective": "Impor corretamente restrições cinemáticas em malhas de elementos finitos.",
                                  "commonMistakes": "Não penalizar adequadamente GLs rotacionais, levando a modos rígidos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar condições naturais (momentos e forças cortantes)",
                                  "subSteps": [
                                    "Defina momentos Mn = -D(∂²w/∂n² + ν ∂²w/∂s²) e Qn = -D ∂(∇²w)/∂n para bordas livres ou carregadas.",
                                    "Incorpore em vetor de carga F via integração de contorno: ∫ N^T * t ds, onde t inclui Mn e Qn.",
                                    "Ajuste para apoios simplesmente apoiados: imponha Mn=0 implicitamente via ausência de restrição.",
                                    "Simule uma borda com cisalhamento aplicado e valide forças reativas.",
                                    "Compare resultados analíticos (série de Navier) com numéricos."
                                  ],
                                  "verification": "Gere relatório mostrando momentos e cortantes coincidentes com solução exata em pelo menos 5%.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Código FEA personalizado ou bibliotecas (FEniCS), tabelas de soluções analíticas para placas.",
                                  "tips": "Naturalizações são automáticas em métodos fracos; foque na formulação variacional.",
                                  "learningObjective": "Integrar cargas de contorno estáticas no sistema global K u = F.",
                                  "commonMistakes": "Esquecer fatores ν (Poisson) nos momentos ou sinal errado em Qn."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e validar condições mistas para apoios específicos",
                                  "subSteps": [
                                    "Monte malha para placa retangular simplesmente apoiada em duas bordas e engastada nas outras.",
                                    "Aplique cargas distribuídas q(x,y) e resolva o sistema.",
                                    "Extraia reações: somar Qn em apoios simples, verificar equilíbrio global.",
                                    "Refine malha e avalie convergência em norma L2 para w.",
                                    "Documente em relatório com gráficos de contorno de w, M e Q."
                                  ],
                                  "verification": "Solução converge monotonicamente e equilibra forças/momentos totais.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Software FEA avançado, Python com NumPy/SciPy para pós-processamento.",
                                  "tips": "Use malhas não-uniformes perto de cantos para singularidades.",
                                  "learningObjective": "Combinar essenciais e naturais em problemas reais de placas.",
                                  "commonMistakes": "Violações de continuidade entre elementos em θ."
                                }
                              ],
                              "practicalExample": "Analise uma laje de piso retangular (2m x 1m, D=1e6 Nm) simplesmente apoiada nas bordas longas e engastada nas curtas, sob carga uniforme q=10 kN/m². Imponha w=0 e θ=0 nas engastadas, w=0 nas simples; extraia momentos máximos e valide com solução de Timoshenko.",
                              "finalVerifications": [
                                "Deslocamentos w=0 exatos em todos nós de apoio essencial.",
                                "Rotações θ aproximadas a 0 em engastes (erro <1%).",
                                "Momentos Mn e cortantes Qn coincidem com equilíbrio estático.",
                                "Convergência observada com refinamento de malha.",
                                "Ausência de modos rígidos (determinante K >0).",
                                "Gráficos de contorno mostram comportamento físico realista."
                              ],
                              "assessmentCriteria": [
                                "Precisão na imposição de condições essenciais (erro <0.1%).",
                                "Correta integração de naturais no vetor F (equilíbrio global).",
                                "Eficiência computacional (tempo de solução <5 min para 1000 nós).",
                                "Relatório claro com validações analíticas.",
                                "Tratamento adequado de singularidades em cantos.",
                                "Capacidade de generalizar para geometrias irregulares."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações diferenciais parciais e métodos variacionais (Princípio Virtual de Trabalho).",
                                "Programação: Implementação numérica de matrizes esparsas e solvers lineares.",
                                "Física: Teoria da elasticidade linear e equilíbrio estático.",
                                "Engenharia Civil: Projeto de lajes e análise estrutural."
                              ],
                              "realWorldApplication": "No projeto de lajes de edifícios, pontes e asas de aviões, onde condições de contorno definem reações em apoios, evitando colapsos por subestimação de momentos em engastes ou cortantes em apoios simples."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "34.2.3.3.1"
                            ]
                          },
                          {
                            "id": "34.2.3.3.4",
                            "name": "Implementar integração numérica para elementos",
                            "description": "Usar quadratura de Gauss 2D (ex: 3x3 pontos) para integrar termos não-lineares na matriz de rigidez de elementos de placa isoparamétricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos da quadratura de Gauss 2D",
                                  "subSteps": [
                                    "Estude a teoria da integração numérica em 2D usando produto de Gauss-Legendre 1D.",
                                    "Identifique pontos de Gauss e pesos para n=3 em 1D (ξ, η de -1 a 1).",
                                    "Entenda o produto tensorial para formar a grade 3x3 em 2D.",
                                    "Revise o Jacobiano para mapeamento isoparamétrico de elementos de placa.",
                                    "Anote fórmulas chave: ∫f dΩ ≈ Σ w_i w_j f(ξ_i, η_j) |J|."
                                  ],
                                  "verification": "Resuma em um diagrama os 9 pontos de Gauss 2D com pesos e escreva a fórmula geral.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Livro de Elementos Finitos (ex: Zienkiewicz), tabela de pontos/pesos Gauss online, caderno para anotações.",
                                  "tips": "Use tabelas prontas de pontos Gauss para evitar cálculos manuais iniciais.",
                                  "learningObjective": "Compreender como a quadratura de Gauss 2D aproxima integrais em domínios isoparamétricos.",
                                  "commonMistakes": "Confundir pontos 1D com 2D; esquecer o Jacobiano no mapeamento."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir pontos, pesos e funções de forma para elemento isoparamétrico",
                                  "subSteps": [
                                    "Liste os 9 pontos Gauss 2D: combinações de ξ_i = {-√(3/5), 0, √(3/5)} e pesos w_i ≈ {5/9, 8/9, 5/9}.",
                                    "Implemente funções de forma N_i(ξ,η) para elemento quadrilateral 4-nós (bilinear).",
                                    "Calcule derivadas ∂N_i/∂ξ e ∂N_i/∂η em cada ponto Gauss.",
                                    "Defina coordenadas nodais de um elemento de placa exemplo (ex: quadrado unitário).",
                                    "Teste funções de forma: Σ N_i = 1 em todos pontos."
                                  ],
                                  "verification": "Codifique um script simples que imprima N_i e derivadas nos 9 pontos; verifique soma N_i=1.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python/MATLAB com NumPy/SciPy, tabela Gauss (Wikipedia ou handout).",
                                  "tips": "Vetorize cálculos em código para eficiência com loops sobre pontos Gauss.",
                                  "learningObjective": "Preparar dados de integração numérica específicos para elementos de placa.",
                                  "commonMistakes": "Erros nos pesos (usar 1D diretamente); derivadas incorretas de N_i."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Jacobiano e matriz B em pontos Gauss",
                                  "subSteps": [
                                    "Monte matriz Jacobiana J = [∂x/∂ξ ∂x/∂η; ∂y/∂ξ ∂y/∂η] usando derivadas de forma e coords nodais.",
                                    "Compute det(J) e inverta J para derivadas cartesianas em cada ponto Gauss.",
                                    "Forme matriz de deformação B para flexão de placas (incluindo curvaturas κ = [∂²w/∂x², etc.]).",
                                    "Inclua termos não-lineares se aplicável (ex: espessura variável).",
                                    "Verifique det(J) > 0 e positivo em todos pontos."
                                  ],
                                  "verification": "Imprima det(J) e ||B|| para cada ponto; deve ser consistente e positivo.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Código do Step 2, referências FEM para matriz B em placas (Mindlin/Thin plate).",
                                  "tips": "Use sympy para derivadas simbólicas iniciais antes de numérico.",
                                  "learningObjective": "Transformar derivadas isoparamétricas em físicas via Jacobiano.",
                                  "commonMistakes": "Jacobiano singular (elemento distorcido); confundir B de membrana com flexão."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar matriz de rigidez via integração Gauss",
                                  "subSteps": [
                                    "Defina matriz de material D para placa isotrópica (E, ν, t).",
                                    "Para cada ponto Gauss: K_e += w_i w_j |det(J)| B^T D B.",
                                    "Some contribuições dos 9 pontos para obter K_e completa.",
                                    "Incorpore termos não-lineares (ex: geometria não-linear via updated Lagrangian).",
                                    "Aplique condições de contorno essenciais pós-montagem."
                                  ],
                                  "verification": "Compare K_e com solução analítica para placa unitária; erro <1%.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Código anterior, propriedades placa exemplo (E=210e9 Pa, ν=0.3, t=0.01m).",
                                  "tips": "Estruture código em função ke_gauss(element_nodes, D, ngp=3).",
                                  "learningObjective": "Implementar integral numérica para termos não-lineares na matriz de rigidez.",
                                  "commonMistakes": "Esquecer w_i w_j ou |det(J)|; soma errada de contribuições."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e validar implementação",
                                  "subSteps": [
                                    "Aplique carga/distribuição conhecida em malha simples de 1 elemento.",
                                    "Resolva Ku=f e compare deslocamentos com solução exata (ex: placa simply supported).",
                                    "Teste convergência variando ngp (2x2 vs 3x3).",
                                    "Analise erro em energia ou norma L2.",
                                    "Documente código com comentários e exemplo reprodutível."
                                  ],
                                  "verification": "Erro relativo < 0.5% para caso benchmark; plots de deformed shape.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Solver linear (numpy.linalg.solve), mesh simples (1-4 elementos).",
                                  "tips": "Use casos de benchmark padrão de literatura FEM para placas.",
                                  "learningObjective": "Validar precisão da integração numérica em contexto real.",
                                  "commonMistakes": "Não tratar singularidade em K; unidades inconsistentes."
                                }
                              ],
                              "practicalExample": "Para um elemento quadrilateral 4-nós representando uma placa fina simply supported sob carga uniforme q=1 kN/m², use Gauss 3x3 para computar K_e. Coordenadas nodais: (0,0), (1,0), (1,1), (0,1). Resultado: K_e[1,1] ≈ 1.3e6 N/m (verificar com analítico).",
                              "finalVerifications": [
                                "Matriz K_e simétrica e semi-definida positiva.",
                                "Soma de contribuições Gauss reproduz integral exata para funções polinomiais até grau 5.",
                                "Erro de integração <0.1% comparado a 5x5 Gauss.",
                                "Deslocamento central de placa benchmark coincide com teoria de Kirchhoff.",
                                "Código roda sem erros para malha 2x2 elementos.",
                                "Documentação inclui fórmula e tabela de pontos/pesos."
                              ],
                              "assessmentCriteria": [
                                "Precisão da integração: erro <1% vs analítico.",
                                "Correção da matriz B e Jacobiano em todos pontos Gauss.",
                                "Eficiência computacional: tempo <1s para 100 elementos.",
                                "Robustez: lida com elementos distorcidos (det(J)>0).",
                                "Clareza do código: funções modulares e comentadas.",
                                "Validação: pelo menos 2 benchmarks com plots.",
                                "Tratamento de não-linearidades explícito."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Quadratura e análise de erro de truncamento.",
                                "Programação: Vetorização em Python/MATLAB para FEM.",
                                "Física: Teoria de placas (Kirchhoff/Mindlin).",
                                "Engenharia Computacional: Otimização de malhas e solvers.",
                                "Estatística: Análise de convergência e h/p-refinamento."
                              ],
                              "realWorldApplication": "Em simulações FEM de estruturas aeronáuticas (ex: painéis de asas), onde integração Gauss 2D acelera montagem de K para milhões de DOFs em placas curvas/composites, permitindo otimização de peso e fadiga."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.2.3.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.5",
                "name": "Sólidos 3D",
                "description": "Elementos tetraédricos e hexaédricos para análise de sólidos tridimensionais.",
                "totalSkills": 58,
                "atomicTopics": [
                  {
                    "id": "10.1.5.1",
                    "name": "Elemento Tetraédrico de 4 Nós",
                    "description": "Geometria, funções de interpolação lineares e formulação básica para análise de sólidos 3D.",
                    "individualConcepts": [
                      {
                        "id": "34.3.1.1",
                        "name": "Geometria do Elemento Tetraédrico de 4 Nós",
                        "description": "Descrição da configuração geométrica do elemento tetraédrico com 4 nós, incluindo posições dos nós, conectividade e propriedades volumétricas básicas.",
                        "specificSkills": [
                          {
                            "id": "34.3.1.1.1",
                            "name": "Identificar nós e conectividade",
                            "description": "Reconhecer os 4 nós do elemento tetraédrico, suas coordenadas locais (ξ, η, ζ) e a conectividade das arestas e faces.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a geometria básica do elemento tetraédrico",
                                  "subSteps": [
                                    "Estude a forma 3D de um tetraedro como uma pirâmide triangular com 4 faces triangulares.",
                                    "Visualize o tetraedro no espaço cartesiano com vértices conectados por arestas.",
                                    "Identifique que possui exatamente 4 nós (vértices), 6 arestas e 4 faces.",
                                    "Revise as propriedades topológicas: cada nó conecta-se a 3 arestas.",
                                    "Desenhe um esboço 3D simples do tetraedro rotulando os elementos básicos."
                                  ],
                                  "verification": "Desenhe e rotule corretamente um tetraedro identificando 4 nós, 6 arestas e 4 faces sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Visualizador 3D online (ex: GeoGebra)"
                                  ],
                                  "tips": "Use uma perspectiva isométrica para melhor visualização 3D.",
                                  "learningObjective": "Entender a estrutura topológica fundamental do tetraedro.",
                                  "commonMistakes": [
                                    "Confundir com pirâmide quadrada (5 faces)",
                                    "Contar incorretamente o número de arestas (não 12)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar os 4 nós e suas coordenadas locais (ξ, η, ζ)",
                                  "subSteps": [
                                    "Aprenda as coordenadas locais padrão: Nó 1 (0,0,0), Nó 2 (1,0,0), Nó 3 (0,1,0), Nó 4 (0,0,1).",
                                    "Memorize que ξ varia ao longo da aresta 1-2, η ao longo 1-3, ζ ao longo 1-4.",
                                    "Plote essas coordenadas em um sistema ξ-η-ζ.",
                                    "Verifique que a soma ξ + η + ζ ≤ 1 dentro do elemento.",
                                    "Rotule um diagrama com as coordenadas exatas de cada nó."
                                  ],
                                  "verification": "Liste corretamente as coordenadas (ξ, η, ζ) para os 4 nós sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama de coordenadas locais impresso",
                                    "Software de plotagem (ex: MATLAB ou Python Matplotlib)"
                                  ],
                                  "tips": "Lembre-se: nó 1 é a origem, e os outros estão nos eixos unitários locais.",
                                  "learningObjective": "Dominar as posições exatas dos nós no sistema de coordenadas naturais.",
                                  "commonMistakes": [
                                    "Usar coordenadas globais em vez de locais",
                                    "Confundir ordem dos nós (ex: inverter η e ζ)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar a conectividade das arestas",
                                  "subSteps": [
                                    "Liste as 6 arestas: 1-2, 1-3, 1-4, 2-3, 2-4, 3-4.",
                                    "Desenhe cada aresta conectando os nós correspondentes.",
                                    "Verifique que cada nó tem grau 3 (conectado a 3 arestas).",
                                    "Crie uma tabela de conectividade nodal para arestas.",
                                    "Simule interpolação linear ao longo de uma aresta exemplo."
                                  ],
                                  "verification": "Enumere todas as 6 arestas corretamente e confirme grau nodal de 3 para cada nó.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de conectividade em branco",
                                    "Ferramenta de desenho vetorial (ex: Inkscape)"
                                  ],
                                  "tips": "Use convenção de numeração crescente para arestas (nó menor primeiro).",
                                  "learningObjective": "Mapear todas as conexões de arestas entre nós.",
                                  "commonMistakes": [
                                    "Omitir arestas como 2-3",
                                    "Duplicar conexões simétricas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar a conectividade das faces",
                                  "subSteps": [
                                    "Identifique as 4 faces triangulares: Face 1 (1-2-3), Face 2 (1-2-4), Face 3 (1-3-4), Face 4 (2-3-4).",
                                    "Desenhe cada face destacando suas 3 arestas e 3 nós.",
                                    "Crie uma tabela de conectividade para faces.",
                                    "Verifique que cada face é plana e compartilha arestas com outras.",
                                    "Teste consistência: toda aresta pertence a exatamente 2 faces."
                                  ],
                                  "verification": "Liste corretamente as 4 faces com seus nós e confirme compartilhamento de arestas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Modelo físico de tetraedro (ou impresso)",
                                    "Planilha para tabelas de conectividade"
                                  ],
                                  "tips": "A face oposta ao nó 1 é 2-3-4; generalize para outras.",
                                  "learningObjective": "Compreender a topologia superficial do elemento.",
                                  "commonMistakes": [
                                    "Incluir nós errados em faces (ex: face 1-2-3-4)",
                                    "Confundir faces adjacentes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um software de EF como ANSYS, defina um elemento tetraédrico com nós: 1(0,0,0), 2(1,0,0), 3(0,1,0), 4(0,0,1). Verifique conectividade: arestas [1-2,1-3,1-4,2-3,2-4,3-4]; faces [1-2-3,1-2-4,1-3-4,2-3-4].",
                              "finalVerifications": [
                                "Corretamente nomear e localizar os 4 nós com coordenadas (ξ,η,ζ).",
                                "Listar todas as 6 arestas sem omissões ou duplicatas.",
                                "Identificar as 4 faces triangulares com nós corretos.",
                                "Confirmar que cada nó conecta a 3 arestas e cada aresta a 2 faces.",
                                "Desenhar diagrama completo sem erros topológicos.",
                                "Explicar verbalmente a conectividade em 1 minuto."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas coordenadas locais dos nós (100% correto).",
                                "Completude da lista de arestas e faces (todas listadas).",
                                "Correta representação gráfica da conectividade.",
                                "Compreensão conceitual via explicação (sem hesitação).",
                                "Identificação de erros comuns evitados.",
                                "Tempo de execução dentro do estimado (eficiência)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Geometria analítica e vetores em 3D.",
                                "Programação: Estruturas de dados para malhas (grafos, listas de conectividade).",
                                "Física: Topologia em mecânica dos sólidos e deformações.",
                                "Informática: Algoritmos de geração de malhas tetraédricas."
                              ],
                              "realWorldApplication": "Em simulações de elementos finitos (FEA) para análise estrutural em engenharia mecânica, como prever tensões em peças automotivas ou aeroespaciais, onde a conectividade correta garante precisão na interpolação de campos (deslocamentos, tensões) dentro do elemento."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.3.1.1.2",
                            "name": "Calcular o volume do elemento",
                            "description": "Aplicar a fórmula do volume para um tetraedro definido por 4 pontos no espaço 3D, usando o determinante da matriz de coordenadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e validar os quatro vértices do tetraedro",
                                  "subSteps": [
                                    "Receba as coordenadas dos quatro pontos no espaço 3D: denote-os como A(x₁,y₁,z₁), B(x₂,y₂,z₂), C(x₃,y₃,z₃) e D(x₄,y₄,z₄).",
                                    "Verifique visualmente ou plotando se os pontos não são coplanares (um tetraedro válido requer volume não nulo).",
                                    "Escolha um vértice de referência, tipicamente A, como origem para os vetores.",
                                    "Registre as coordenadas em uma tabela organizada para evitar erros de transcrição.",
                                    "Opcionalmente, utilize software de visualização 3D para confirmar a formação do tetraedro."
                                  ],
                                  "verification": "Lista de coordenadas confirmada e pontos confirmados como não coplanares via cálculo preliminar de volume escalar triplo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Coordenadas dos pontos fornecidas",
                                    "Papel quadriculado ou planilha Excel",
                                    "Software de plotagem 3D (ex: GeoGebra, MATLAB)"
                                  ],
                                  "tips": "Sempre liste os pontos em ordem consistente (A,B,C,D) para evitar confusões na matriz.",
                                  "learningObjective": "Compreender a geometria espacial dos vértices e validar a configuração do tetraedro.",
                                  "commonMistakes": [
                                    "Usar pontos coplanares, resultando em volume zero",
                                    "Trocar coordenadas entre pontos",
                                    "Ignorar unidades de comprimento (ex: metros vs. mm)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a matriz de vetores para o determinante",
                                  "subSteps": [
                                    "Calcule os vetores posicionais a partir do vértice de referência A: vetor AB = (x₂-x₁, y₂-y₁, z₂-z₁), AC = (x₃-x₁, y₃-y₁, z₃-z₁), AD = (x₄-x₁, y₄-y₁, z₄-z₁).",
                                    "Forme a matriz M 3x3 com essas diferenças como colunas: M = [[ABx, ACx, ADx], [ABy, ACy, ADy], [ABz, ACz, ADz]].",
                                    "Confirme que a matriz está corretamente transposta (colunas vs. linhas).",
                                    "Anote a matriz explicitamente para revisão.",
                                    "Verifique se os vetores são linearmente independentes (pré-condição para det ≠ 0)."
                                  ],
                                  "verification": "Matriz M 3x3 formada corretamente, com elementos numéricos exatos e vetores independentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico (ex: SymPy, Mathematica)",
                                    "Papel para anotações matriciais"
                                  ],
                                  "tips": "Use A como referência para simplificar; qualquer vértice serve, mas mantenha consistência.",
                                  "learningObjective": "Dominar a construção da matriz jacobiana equivalente para elementos tetraédricos.",
                                  "commonMistakes": [
                                    "Usar linhas em vez de colunas na matriz",
                                    "Erro aritmético nas subtrações de coordenadas",
                                    "Confundir vetores com coordenadas absolutas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o determinante da matriz",
                                  "subSteps": [
                                    "Aplique a fórmula de determinante para matriz 3x3: det(M) = ABx*(ACy*ADz - ACz*ADy) - ACx*(ABy*ADz - ABz*ADy) + ADx*(ABy*ACz - ABz*ACy).",
                                    "Compute cada termo passo a passo, respeitando sinais (+/-).",
                                    "Use expansão por cofatores ou regra de Sarrus para verificação cruzada.",
                                    "Registre o valor exato do determinante, incluindo sinal.",
                                    "Confirme o cálculo com uma ferramenta computacional se disponível."
                                  ],
                                  "verification": "Valor do det(M) calculado duas vezes com concordância exata.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora gráfica",
                                    "Tabela de fórmula de determinante impressa",
                                    "Software como MATLAB ou Python (NumPy)"
                                  ],
                                  "tips": "Expanda sempre pela primeira linha para minimizar erros; pratique com matriz identidade primeiro.",
                                  "learningObjective": "Executar cálculo preciso de determinantes 3x3 no contexto geométrico.",
                                  "commonMistakes": [
                                    "Erros de sinal nos termos do determinante",
                                    "Esquecer fator de permutação em expansões",
                                    "Arredondamento prematuro em cálculos decimais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a fórmula final do volume e validar",
                                  "subSteps": [
                                    "Calcule o volume absoluto: V = (1/6) * |det(M)|.",
                                    "Tome o valor absoluto para garantir volume positivo.",
                                    "Verifique unidades: se coordenadas em metros, V em m³.",
                                    "Compare com volume conhecido para tetraedro regular (ex: lado a, V = (a³ √2)/12).",
                                    "Documente o resultado final com todas as casas decimais relevantes."
                                  ],
                                  "verification": "Volume V computado, positivo, com unidades corretas e consistente com verificação alternativa.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Fórmula anotada: V = |det(M)| / 6",
                                    "Calculadora para divisão e módulo"
                                  ],
                                  "tips": "O fator 1/6 vem da integração sobre o simplex unitário; memorize sua origem em MEF.",
                                  "learningObjective": "Finalizar o cálculo de volume e relacioná-lo à integração em elementos finitos.",
                                  "commonMistakes": [
                                    "Esquecer o 1/6 ou o valor absoluto",
                                    "Ignorar unidades no volume final",
                                    "Confundir com fórmula de pirâmide (1/3 base*altura)"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere vértices: A(0,0,0), B(1,0,0), C(0,1,0), D(0,0,1). Vetores: AB=(1,0,0), AC=(0,1,0), AD=(0,0,1). Matriz M = [[1,0,0],[0,1,0],[0,0,1]]. det(M)=1. Volume V = |1|/6 = 1/6 unidades cúbicas. Este é um tetraedro unitário padrão.",
                              "finalVerifications": [
                                "Matriz M construída corretamente com vetores posicionais.",
                                "Determinante calculado com precisão numérica exata.",
                                "Volume V = |det(M)|/6 positivo e com unidades consistentes.",
                                "Verificação cruzada com fórmula alternativa (ex: produto misto AB·(AC×AD)/6).",
                                "Configuração geométrica válida (não coplanar).",
                                "Documentação completa do processo."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática total no determinante e volume (obrigatório).",
                                "Clareza na construção da matriz e subtrações vetoriais.",
                                "Eficiência: cálculo manual + verificação computacional.",
                                "Compreensão conceitual: explicar origem da fórmula 1/6.",
                                "Aplicação contextual: relacionar ao papel em MEF.",
                                "Tratamento de erros: identificação e correção de não-coplanaridade."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Cálculo de determinantes e independência linear de vetores.",
                                "Geometria Analítica: Representação de sólidos 3D e volumes poliédricos.",
                                "Programação Computacional: Implementação em Python/NumPy para automação em MEF.",
                                "Física Aplicada: Cálculo de volumes em mecânica dos continua e dinâmica de fluidos.",
                                "Cálculo Numérico: Integração exata em elementos simplex."
                              ],
                              "realWorldApplication": "No método dos elementos finitos (MEF) para engenharia mecânica, o volume do tetraedro é crucial para computar matrizes de rigidez, massas inerciais e integrações de cargas em simulações de estruturas complexas, como análise de tensões em peças aeronáuticas, barragens ou implantes biomédicos, garantindo precisão em softwares como ANSYS ou Abaqus."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.3.1.1.3",
                            "name": "Mapear geometria local para global",
                            "description": "Realizar o mapeamento isoparamétrico da geometria do tetraedro de referência para o elemento real no domínio físico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o Tetraedro de Referência e Coordenadas Locais",
                                  "subSteps": [
                                    "Identifique o tetraedro de referência padrão com vértices em (0,0,0), (1,0,0), (0,1,0) e (0,0,1).",
                                    "Descreva o sistema de coordenadas naturais isoparamétricas (ξ, η, ζ) onde ξ + η + ζ ≤ 1 e ξ,η,ζ ≥ 0.",
                                    "Visualize o domínio local usando diagramas ou software de plotagem.",
                                    "Liste as propriedades geométricas chave: volume unitário e funções baricêntricas.",
                                    "Confirme que todos os pontos internos satisfazem as restrições de coordenadas."
                                  ],
                                  "verification": "Desenhe ou plote o tetraedro de referência e verifique se os vértices estão corretamente posicionados com ξ+η+ζ=1 nos nós.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e lápis, software como MATLAB/GeoGebra/Paraview para visualização 3D.",
                                  "tips": "Use cores diferentes para cada eixo (ξ vermelho, η azul, ζ verde) para melhor visualização.",
                                  "learningObjective": "Compreender o domínio local isoparamétrico e suas coordenadas baricêntricas.",
                                  "commonMistakes": "Confundir coordenadas cartesianas com baricêntricas; assumir volume não unitário."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar as Funções de Forma Lineares",
                                  "subSteps": [
                                    "Defina N1 = 1 - ξ - η - ζ, N2 = ξ, N3 = η, N4 = ζ para os quatro nós.",
                                    "Verifique que Ni=1 no nó i e Ni=0 nos outros nós.",
                                    "Plote as funções de forma em seções 2D (fixando ζ=0) para entender o comportamento linear.",
                                    "Confirme a propriedade de partição da unidade: Σ Ni = 1 para qualquer ponto interno.",
                                    "Teste em pontos Gauss específicos, como centro (0.25,0.25,0.25)."
                                  ],
                                  "verification": "Calcule Σ Ni em 3 pontos aleatórios internos; deve ser exatamente 1.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora simbólica (SymPy/MATLAB), planilha para testes numéricos.",
                                  "tips": "Lembre-se: funções baricêntricas são intuitivas como 'pesos' nos vértices.",
                                  "learningObjective": "Dominar as funções de forma lineares do tetraedro de 4 nós.",
                                  "commonMistakes": "Erros em fórmulas: trocar N1 com N2; esquecer normalização."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular o Mapeamento Isoparamétrico para Coordenadas Globais",
                                  "subSteps": [
                                    "Escreva as equações: x(ξ,η,ζ) = Σ Ni xi, y = Σ Ni yi, z = Σ Ni zi, onde (xi,yi,zi) são coordenadas reais dos nós.",
                                    "Substitua as Ni nas equações para obter expressões explícitas lineares.",
                                    "Mapeie os quatro nós de referência para os nós reais e confirme identidade.",
                                    "Escolha um ponto interno local (ex: centro) e compute sua imagem global.",
                                    "Verifique linearidade: mapeamento deve ser afim em 3D."
                                  ],
                                  "verification": "Os quatro nós mapeados devem coincidir exatamente com as coordenadas reais fornecidas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Coordenadas de um tetraedro real exemplo, software de álgebra simbólica.",
                                  "tips": "Expanda Σ Ni xi = (1-ξ-η-ζ)x1 + ξ x2 + η x3 + ζ x4 para clareza.",
                                  "learningObjective": "Construir e validar o mapeamento geométrico isoparamétrico.",
                                  "commonMistakes": "Índices errados de nós; não expandir corretamente as somas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Computar o Jacobiano e Verificar o Mapeamento",
                                  "subSteps": [
                                    "Calcule as derivadas parciais: ∂x/∂ξ = -x1 + x2, etc., formando a matriz Jacobiana J (3x3).",
                                    "Monte J explicitamente: colunas são diferenças de coordenadas entre nós.",
                                    "Compute det(J) em pontos internos; deve ser positivo e constante para tetraedros lineares.",
                                    "Integre sobre o elemento local usando pontos Gauss para validar volume real.",
                                    "Teste invertibilidade: resolva ξ,η,ζ dado x,y,z em um ponto conhecido."
                                  ],
                                  "verification": "det(J) constante e >0; volume computado = (1/6)|det(J)|.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "MATLAB/Python (NumPy/SciPy) para matrizes e determinantes.",
                                  "tips": "Para tetraedros lineares, J é constante; simplifica cálculos.",
                                  "learningObjective": "Avaliar a qualidade do mapeamento via Jacobiano.",
                                  "commonMistakes": "Derivadas incorretas; det(J)=0 indica elemento degenerado."
                                }
                              ],
                              "practicalExample": "Dado tetraedro real com nós: N1(0,0,0), N2(1,0,0), N3(0,1,0), N4(0,0,1). Ponto local centro (0.25,0.25,0.25) mapeia para (0.25,0.25,0.25). Jacobiano J = [[-1,1,0,0],[0,-1,1,0],[0,0,-1,1]] wait, corrigido para diferenças: J constante com det(J)=1/6.",
                              "finalVerifications": [
                                "Nós de referência mapeiam corretamente para nós reais.",
                                "Σ Ni = 1 em pontos testados.",
                                "det(J) > 0 e constante em todo domínio.",
                                "Ponto Gauss mapeado produz coordenadas esperadas.",
                                "Volume do elemento real = |det(J)| / 6.",
                                "Mapeamento inverso recupera coordenadas locais com erro <1e-10."
                              ],
                              "assessmentCriteria": [
                                "Precisão das funções de forma (erro <1e-12 em partição da unidade).",
                                "Correção das equações de mapeamento (verificação nodal).",
                                "Cálculo exato do Jacobiano e seu determinante.",
                                "Validação numérica com pelo menos 4 pontos internos.",
                                "Explicação clara da linearidade e propriedades afins.",
                                "Identificação de degenerescências potenciais (det(J)=0)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes Jacobianas), geometria diferencial.",
                                "Programação: Implementação em Python/MATLAB para automação de MEF.",
                                "Física: Integração numérica em volumes para equações de equilíbrio.",
                                "Engenharia de Software: Desenvolvimento de solvers de elementos finitos."
                              ],
                              "realWorldApplication": "Em simulações de análise estrutural (ex: crash-test de veículos), o mapeamento permite discretizar malhas complexas de tetraedros reais a partir de templates locais, computando tensões e deformações em softwares como ANSYS ou Abaqus."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "34.3.1.2",
                        "name": "Funções de Interpolação Lineares",
                        "description": "Definição e propriedades das funções de forma lineares para o elemento tetraédrico de 4 nós, usadas para interpolação de campos escalares e vetoriais.",
                        "specificSkills": [
                          {
                            "id": "34.3.1.2.1",
                            "name": "Definir funções de forma N_i",
                            "description": "Escrever as expressões das funções de interpolação linear N1, N2, N3, N4 em coordenadas naturais (L1 a L4) ou baricêntricas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de funções de forma em elementos finitos",
                                  "subSteps": [
                                    "Revise o papel das funções de forma na aproximação de campos dentro de um elemento finito.",
                                    "Identifique que funções de forma interpolam valores nos nós para pontos internos.",
                                    "Estude as propriedades essenciais: N_i(ξ_j) = δ_ij (interpolação), soma N_i = 1 (partição da unidade).",
                                    "Discuta o contexto do elemento tetraédrico de 4 nós em 3D.",
                                    "Anote exemplos de funções de forma em elementos 1D e 2D para comparação."
                                  ],
                                  "verification": "Escreva um resumo de 3-5 frases explicando funções de forma e liste suas propriedades chave.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de Elementos Finitos (capítulo sobre shape functions)",
                                    "Papel e caneta",
                                    "Acesso a slides ou vídeo introdutório sobre MEF"
                                  ],
                                  "tips": "Comece com elementos simples como barra 1D (N1=1-ξ, N2=ξ) para construir intuição.",
                                  "learningObjective": "Entender o propósito e propriedades fundamentais das funções de forma.",
                                  "commonMistakes": [
                                    "Confundir funções de forma com funções de base polinomiais sem propriedades de interpolação.",
                                    "Ignorar a partição da unidade, essencial para consistência."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender coordenadas baricêntricas (naturais) para o tetraedro",
                                  "subSteps": [
                                    "Defina coordenadas baricêntricas L1, L2, L3, L4 como pesos volumétricos normalizados.",
                                    "Aprenda que L_i = V_i / V, onde V_i é volume do sub-tetraedro oposto ao nó i.",
                                    "Verifique restrições: L1 + L2 + L3 + L4 = 1 e L_i ≥ 0 dentro do elemento.",
                                    "Pratique convertendo coordenadas cartesianas (x,y,z) para baricêntricas usando determinante de volumes.",
                                    "Desenhe um tetraedro e rotule os nós 1-4 com suas coordenadas baricêntricas (ex: nó1: L1=1, outros=0)."
                                  ],
                                  "verification": "Calcule L1-L4 para o centro do tetraedro (deve ser 0.25 cada) e confirme soma=1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico (SymPy/MATLAB)",
                                    "Diagrama de tetraedro impresso",
                                    "Folha de fórmulas de volume tetraédrico"
                                  ],
                                  "tips": "Use a fórmula de volume V = (1/6)|det(M)| onde M tem colunas (P-P1, P2-P1, P3-P1).",
                                  "learningObjective": "Dominar coordenadas baricêntricas como sistema natural para tetraedros.",
                                  "commonMistakes": [
                                    "Esquecer o fator 1/6 no volume.",
                                    "Não normalizar corretamente os pesos volumétricos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar e escrever as expressões das funções de forma N_i",
                                  "subSteps": [
                                    "Estabeleça que para interpolação linear em tetraedro, N_i = L_i.",
                                    "Escreva explicitamente: N1 = L1, N2 = L2, N3 = L3, N4 = L4.",
                                    "Verifique interpolação: em nó1 (L1=1, outros=0), N1=1, N2=N3=N4=0.",
                                    "Confirme partição: soma N_i = soma L_i = 1.",
                                    "Expresse em termos de coordenadas locais se necessário, mas foque em baricêntricas."
                                  ],
                                  "verification": "Escreva as 4 equações N_i = L_i e teste em um nó (ex: nó2 dá N2=1, outros=0).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para derivação",
                                    "Exemplo de tetraedro com coordenadas dos nós"
                                  ],
                                  "tips": "Lembre-se: simplicidade linear significa N_i diretamente igual a L_i, sem polinômios adicionais.",
                                  "learningObjective": "Escrever corretamente as expressões N1 a N4 em coordenadas baricêntricas.",
                                  "commonMistakes": [
                                    "Inventar polinômios complexos; são puramente lineares N_i = L_i.",
                                    "Confundir com coordenadas isoparamétricas de cubo."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e aplicar as funções de forma",
                                  "subSteps": [
                                    "Calcule gradiente de N_i: ∇N_i = ∇L_i, usando derivadas parciais.",
                                    "Teste consistência em pontos internos: ex, centro (L_i=0.25), todas N_i=0.25.",
                                    "Implemente uma interpolação simples: u = sum u_i N_i.",
                                    "Compare com elementos triangulares 2D (N_i = A_i / A).",
                                    "Discuta limitações: exata para lineares, aproximada para quadráticos."
                                  ],
                                  "verification": "Interpola um campo linear u(x,y,z) nos 4 nós e verifica exatidão no centro.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software como MATLAB/Python para plotar N_i",
                                    "Exercício numérico com nós específicos"
                                  ],
                                  "tips": "Use nós padrão: (0,0,0), (1,0,0), (0,1,0), (0,0,1) para cálculos simples.",
                                  "learningObjective": "Validar propriedades e usar N_i em interpolação básica.",
                                  "commonMistakes": [
                                    "Não verificar partição da unidade numericamente.",
                                    "Ignorar que ∇N_i é constante em lineares."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um tetraedro com nós: 1=(0,0,0), 2=(1,0,0), 3=(0,1,0), 4=(0,0,1). Para ponto P=(0.25,0.25,0.25), calcule L1-L4 usando volumes sub-tetraédricos, obtenha L_i=0.25 cada, assim N1=N2=N3=N4=0.25. Interpole temperatura u=100N1 + 200N2 + 300N3 + 400N4 = 275 no centro.",
                              "finalVerifications": [
                                "Escreve corretamente N1 = L1, N2 = L2, N3 = L3, N4 = L4.",
                                "Confirma soma N_i = 1 em pelo menos 3 pontos internos.",
                                "Verifica interpolação unitária nos 4 nós.",
                                "Calcula ∇N1 corretamente para um tetraedro específico.",
                                "Interpola um campo escalar linear com exatidão.",
                                "Explica verbalmente o papel das coordenadas baricêntricas."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas expressões N_i (100% correto).",
                                "Demonstração de propriedades (interpolação e partição) com cálculos.",
                                "Uso correto de coordenadas baricêntricas em exemplos numéricos.",
                                "Identificação de erros comuns e como evitá-los.",
                                "Aplicação em interpolação prática sem falhas.",
                                "Clareza na derivação e verificações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (sistemas baricêntricos) e cálculo vetorial (gradientes).",
                                "Programação: Implementação em Python/MATLAB para MEF (bibliotecas como FEniCS).",
                                "Física: Modelagem de campos contínuos em mecânica dos sólidos e fluidos.",
                                "Geometria Computacional: Volumes e determinantes em 3D."
                              ],
                              "realWorldApplication": "Em simulações de análise estrutural (ex: tensão em peças automotivas via ANSYS), as funções N_i interpolam deslocamentos nos tetraedros da malha, permitindo prever deformações precisas em protótipos virtuais antes da fabricação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.3.1.2.2",
                            "name": "Verificar propriedades das funções de forma",
                            "description": "Demonstrar que as funções N_i somam 1 (partição da unidade) e são 1 em seu nó correspondente e 0 nos outros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender as coordenadas baricêntricas e definição das funções de forma N_i",
                                  "subSteps": [
                                    "Revise a definição de coordenadas baricêntricas para um tetraedro com 4 nós.",
                                    "Escreva as expressões explícitas para N_i em termos das coordenadas baricêntricas L_i.",
                                    "Identifique os nós do tetraedro: nó 1 (0,0,0), nó 2 (1,0,0), nó 3 (0,1,0), nó 4 (0,0,1).",
                                    "Derive a fórmula geral de N_i = L_i.",
                                    "Confirme que as coordenadas baricêntricas satisfazem L1 + L2 + L3 + L4 = 1 por construção."
                                  ],
                                  "verification": "Escreva as fórmulas de N1 a N4 corretamente e verifique sum L_i =1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, calculadora, livro de elementos finitos ou notas de aula.",
                                  "tips": "Use a representação matricial para resolver o sistema de coordenadas baricêntricas.",
                                  "learningObjective": "Compreender a base matemática das funções de forma lineares em tetraedros.",
                                  "commonMistakes": "Confundir coordenadas baricêntricas com coordenadas cartesianas; esquecer a normalização sum=1."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar a propriedade nodal: N_i = 1 no nó i e 0 nos outros nós",
                                  "subSteps": [
                                    "Avalie N1 no nó 1: substitua coordenadas (0,0,0) e calcule L1=1, L2=L3=L4=0.",
                                    "Repita para N1 nos nós 2,3,4: confirme N1=0.",
                                    "Faça o mesmo para N2, N3 e N4 em todos os nós.",
                                    "Registre os valores em uma tabela nodal.",
                                    "Discuta por que isso garante interpolação exata nos nós."
                                  ],
                                  "verification": "Tabela completa mostrando N_i(nó j) = δ_ij (delta de Kronecker).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Planilha Excel ou papel quadriculado para tabela.",
                                  "tips": "Visualize o tetraedro para intuitivamente entender o comportamento.",
                                  "learningObjective": "Demonstrar a interpolação nodal exata das funções de forma.",
                                  "commonMistakes": "Erros de cálculo nas substituições de coordenadas; inverter índices dos nós."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a partição da unidade: sum_{i=1}^4 N_i = 1 em qualquer ponto",
                                  "subSteps": [
                                    "Lembre que N_i = L_i por definição.",
                                    "Mostre analiticamente que sum L_i =1 para qualquer ponto dentro do tetraedro.",
                                    "Escolha um ponto interno, ex: baricentro (0.25,0.25,0.25,0.25) e calcule sum N_i.",
                                    "Teste em um ponto arbitrário, resolvendo o sistema para L_i.",
                                    "Generalize para qualquer configuração de tetraedro afim."
                                  ],
                                  "verification": "Cálculo numérico em pelo menos 2 pontos mostrando sum=1 com precisão 1e-10.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software Python/MATLAB para resolver sistemas lineares.",
                                  "tips": "Use a propriedade afim das coordenadas baricêntricas para prova geral.",
                                  "learningObjective": "Provar a consistência da aproximação como partição da unidade.",
                                  "commonMistakes": "Não normalizar corretamente o sistema; testar só nos nós."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificação combinada e análise de consistência",
                                  "subSteps": [
                                    "Combine propriedades: mostre que u_h = sum u_i N_i reproduz valores nodais exatamente.",
                                    "Calcule gradiente das N_i e discuta suavidade.",
                                    "Implemente numericamente em código para um tetraedro exemplo.",
                                    "Compare resultados analíticos vs numéricos.",
                                    "Discuta implicações para convergência no método dos elementos finitos."
                                  ],
                                  "verification": "Código rodando corretamente e output confirmando propriedades.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com NumPy ou MATLAB.",
                                  "tips": "Comece com código simples antes de generalizar.",
                                  "learningObjective": "Integrar propriedades em contexto de interpolação FEM.",
                                  "commonMistakes": "Erros de indexação no código; não considerar pontos fora do elemento."
                                }
                              ],
                              "practicalExample": "Para tetraedro com nós A(0,0,0), B(1,0,0), C(0,1,0), D(0,0,1), no ponto P(0.25,0.25,0.25): resolva [x;y;z;1] = [A;B;C;D] * [L1;L2;L3;L4], obtenha L=(0.75,0.25,0,0)? Não, baricentro é (0.25 cada), sum=1, N1(P)=0.25 etc. Verifique N_A(P)=0.25, etc., sum=1; N_A(A)=1, N_A(B)=0.",
                              "finalVerifications": [
                                "N_i = 1 no nó i e 0 nos outros para i=1 a 4.",
                                "sum_{i=1}^4 N_i = 1 em pelo menos 3 pontos distintos (nós, baricentro, arbitrário).",
                                "Tabela nodal completa com valores corretos.",
                                "Prova analítica da partição da unidade.",
                                "Implementação numérica sem erros.",
                                "Reprodução exata de função nodal interpolada."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações e cálculos.",
                                "Completude da verificação em múltiplos pontos.",
                                "Clareza na documentação de passos e tabelas.",
                                "Correção no código numérico (se aplicável).",
                                "Compreensão das implicações para FEM.",
                                "Identificação e correção de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e geometria baricêntrica.",
                                "Programação: Implementação numérica de solvers lineares.",
                                "Física: Interpolação de campos escalares em mecânica dos sólidos.",
                                "Engenharia de Computação: Otimização em software FEM."
                              ],
                              "realWorldApplication": "Garante consistência na aproximação de deslocamentos, tensões e temperaturas em simulações FEM de estruturas mecânicas, como análise de crash de veículos ou fadiga em turbinas, evitando erros de discretização."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.3.1.2.3",
                            "name": "Derivar gradientes das funções de forma",
                            "description": "Calcular os gradientes ∇N_i em coordenadas locais e transformá-los para o sistema global usando a matriz Jacobiana.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir as funções de forma em coordenadas locais para o tetraedro de 4 nós",
                                  "subSteps": [
                                    "Identifique as coordenadas locais naturais (ξ, η, ζ) para o elemento tetraédrico, onde 0 ≤ ξ,η,ζ ≤ 1 e ξ + η + ζ ≤ 1.",
                                    "Escreva as funções de interpolação lineares: N₁(ξ,η,ζ) = ξ, N₂ = η, N₃ = ζ, N₄ = 1 - ξ - η - ζ.",
                                    "Verifique as propriedades das funções de forma: N_i = 1 no nó i e N_i = 0 nos outros nós.",
                                    "Desenhe o tetraedro no espaço local e rotule os nós (1: (0,0,0), 2: (1,0,0), 3: (0,1,0), 4: (0,0,1)).",
                                    "Confirme a partição da unidade: ∑ N_i = 1 em todo o domínio."
                                  ],
                                  "verification": "As funções N_i satisfazem N_i(nó j) = δ_{ij} e somam 1 em pontos internos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, software de visualização como ParaView ou GeoGebra.",
                                  "tips": "Use um ponto de Gauss interno (ex: ξ=η=ζ=1/4) para testar rapidamente.",
                                  "learningObjective": "Compreender a representação linear das funções de forma no espaço local.",
                                  "commonMistakes": "Confundir coordenadas locais com globais; esquecer que N₄ é complementar."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os gradientes das funções de forma em coordenadas locais",
                                  "subSteps": [
                                    "Compute as derivadas parciais para cada N_i: ∂N₁/∂ξ=1, ∂N₁/∂η=0, ∂N₁/∂ζ=0; similar para N₂ e N₃.",
                                    "Para N₄: ∂N₄/∂ξ=-1, ∂N₄/∂η=-1, ∂N₄/∂ζ=-1.",
                                    "Forme os vetores gradiente locais: ∇N₁ = [1, 0, 0]^T, ∇N₂ = [0,1,0]^T, etc., ∇N₄ = [-1,-1,-1]^T.",
                                    "Avalie em um ponto específico, como o baricentro (ξ=η=ζ=1/4).",
                                    "Armazene os gradientes em uma matriz 3x4 para todos os nós."
                                  ],
                                  "verification": "Gradientes são constantes (lineares) e somam zero: ∑ ∇N_i = 0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora simbólica (SymPy ou Mathematica), planilha Excel para valores numéricos.",
                                  "tips": "Lembre que derivadas são constantes devido à linearidade.",
                                  "learningObjective": "Dominar o cálculo analítico de gradientes no sistema local.",
                                  "commonMistakes": "Erros de sinal nas derivadas de N₄; não vetorizar corretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e inverter a matriz Jacobiana do mapeamento local-global",
                                  "subSteps": [
                                    "Defina as coordenadas globais dos nós: x₁,y₁,z₁ etc. para os 4 nós.",
                                    "Forme a Jacobiana J(3x3): colunas são [∂x/∂ξ, ∂x/∂η, ∂x/∂ζ]^T etc., usando J = ∑ (x_i ∇N_i local).",
                                    "Calcule det(J) para verificar não-singularidade (volume do elemento >0).",
                                    "Inverta J para obter J^{-1}, então compute J^{-T} = (J^{-1})^T.",
                                    "Avalie J em um ponto de integração (ex: baricentro)."
                                  ],
                                  "verification": "det(J) ≠ 0 e J^{-T} transforma corretamente vetores conhecidos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software numérico (MATLAB, Python com NumPy), notas das coordenadas dos nós.",
                                  "tips": "Use fórmula explícita para tetraedro: J_{ij} = ∑_k x_{k,j} ∂N_k / ∂ξ_i.",
                                  "learningObjective": "Entender o papel da Jacobiana na transformação de derivadas.",
                                  "commonMistakes": "Confundir J com J^{-1}; esquecer transposição para gradientes (contravariante)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Transformar gradientes locais para o sistema global",
                                  "subSteps": [
                                    "Aplique a transformação: ∇N_i^{global} = J^{-T} ∇N_i^{local} para cada i=1..4.",
                                    "Verifique a propriedade: ∑ ∇N_i^{global} = 0 (rigidez da interpolação).",
                                    "Implemente numericamente com coordenadas exemplo e compare analiticamente.",
                                    "Discuta variação: gradientes globais variam no elemento devido a J(ξ,η,ζ).",
                                    "Salve resultados para uso em strains (ε = ∑ ∇N_i u_i)."
                                  ],
                                  "verification": "Gradientes globais reproduzem o campo linear exato e somam zero.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código Python/MATLAB pronto, exemplo de malha tetraédrica.",
                                  "tips": "Teste com tetraedro regular para simetria.",
                                  "learningObjective": "Aplicar transformação covariante de gradientes via Jacobiana.",
                                  "commonMistakes": "Usar J em vez de J^{-T}; ignorar dependência pontual de J."
                                }
                              ],
                              "practicalExample": "Considere um tetraedro com nós: 1(0,0,0), 2(1,0,0), 3(0,1,0), 4(0,0,1). No baricentro (1/4,1/4,1/4), ∇N₁^{local}=[1,0,0]^T. J = [[1,0,0],[0,1,0],[0,0,1]], J^{-T}=I, logo ∇N₁^{global}=[1,0,0]^T. Para nó distorcido, ajuste coordenadas e recompute.",
                              "finalVerifications": [
                                "Gradientes locais são corretos e constantes para cada N_i.",
                                "Matriz Jacobiana é não-singular com det(J)>0.",
                                "Transformação ∇^{global} = J^{-T} ∇^{local} aplicada a todos os 4 gradientes.",
                                "Soma dos gradientes globais é o vetor nulo.",
                                "Resultados numéricos coincidem com analíticos em exemplo simples.",
                                "Gradientes globais variam corretamente com posição no elemento."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de derivadas parciais locais (100% correto).",
                                "Construção correta da Jacobiana a partir de coordenadas nodais.",
                                "Uso apropriado de J^{-T} na transformação (não J ou J^{-1}).",
                                "Verificação de propriedades geométricas (soma zero, partição unidade).",
                                "Eficiência computacional em implementação numérica.",
                                "Interpretação física correta dos gradientes em contexto FEM."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo vetorial multivariado e álgebra linear (inversas, transposições).",
                                "Programação: Implementação em Python/NumPy para automação FEM.",
                                "Física: Aplicação em cálculo de deformações ε = B u, onde B contém ∇N_i.",
                                "Engenharia Civil: Modelagem de estruturas 3D com malhas tetraédricas.",
                                "Computação Gráfica: Interpolação em meshes volumétricas."
                              ],
                              "realWorldApplication": "Em simulações FEM de análise estrutural (ex: ponte ou turbina), os gradientes das funções de forma são essenciais para computar campos de tensão e deformação dentro de elementos tetraédricos, permitindo prever falhas em componentes mecânicos sob carga."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "34.3.1.3",
                        "name": "Formulação Básica para Análise de Sólidos 3D",
                        "description": "Desenvolvimento da matriz de rigidez elementar e vetor de forças usando o método dos elementos finitos para problemas de elasticidade em sólidos 3D.",
                        "specificSkills": [
                          {
                            "id": "34.3.1.3.1",
                            "name": "Montar a matriz [B] de deformação",
                            "description": "Construir a matriz de derivadas de deformação [B] a partir dos gradientes das funções de forma para o elemento tetraédrico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir funções de forma e derivadas locais para o tetraedro",
                                  "subSteps": [
                                    "Identifique as coordenadas naturais (ξ, η, ζ) para o elemento tetraédrico de 4 nós.",
                                    "Escreva as funções de forma lineares: N₁ = 1 - ξ - η - ζ, N₂ = ξ, N₃ = η, N₄ = ζ.",
                                    "Calcule as derivadas parciais locais: ∂Nᵢ/∂ξ, ∂Nᵢ/∂η, ∂Nᵢ/∂ζ para cada i=1 a 4.",
                                    "Verifique que as funções de forma somam 1 e são lineares.",
                                    "Liste as matrizes de derivadas locais [∂N/∂ξ], [∂N/∂η], [∂N/∂ζ]."
                                  ],
                                  "verification": "Confirme que ∑Nᵢ = 1 e derivadas são constantes (valores 0, 1 ou -1).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou software como MATLAB/SymPy",
                                    "Referência: Livro de Bathe ou Zienkiewicz sobre elementos finitos"
                                  ],
                                  "tips": "Use coordenadas baricêntricas para simplicidade; memorize padrões de derivadas.",
                                  "learningObjective": "Compreender a parametrização isoparamétrica do tetraedro linear.",
                                  "commonMistakes": [
                                    "Confundir ordem dos nós (N₁ oposto ao nó 1)",
                                    "Esquecer o sinal negativo em N₁"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a matriz Jacobiana no ponto de interesse",
                                  "subSteps": [
                                    "Defina as coordenadas globais dos 4 nós: (xᵢ, yᵢ, zᵢ) para i=1 a 4.",
                                    "Monte a matriz Jacobiana J = [∂x/∂ξ ∂x/∂η ∂x/∂ζ; ∂y/∂ξ ... ; ∂z/∂ξ ...] usando funções de forma.",
                                    "Escolha um ponto de Gauss (ex: centro do elemento ξ=η=ζ=0.25 para integração).",
                                    "Inverta a Jacobiana: J⁻¹.",
                                    "Verifique det(J) > 0 para orientação positiva."
                                  ],
                                  "verification": "det(J) ≠ 0 e J⁻¹ computada corretamente (teste com produto J * J⁻¹ ≈ I).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora matricial ou Python/NumPy",
                                    "Coordenadas exemplo de tetraedro"
                                  ],
                                  "tips": "Para tetraedro regular, J é diagonal ou simples; numérico é mais fácil.",
                                  "learningObjective": "Mapear derivadas locais para globais via transformação Jacobiana.",
                                  "commonMistakes": [
                                    "Ordem errada das colunas/linhas em J",
                                    "Inversão incorreta para 3x3"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar gradientes das funções de forma em coordenadas globais",
                                  "subSteps": [
                                    "Use J⁻¹ para obter ∂Nᵢ/∂x = (∂Nᵢ/∂ξ * ∂ξ/∂x + ∂Nᵢ/∂η * ∂η/∂x + ∂Nᵢ/∂ζ * ∂ζ/∂x).",
                                    "Calcule os vetores gradiente ∇Nᵢ = [∂Nᵢ/∂x, ∂Nᵢ/∂y, ∂Nᵢ/∂z]ᵀ para cada nó i.",
                                    "Organize em matrizes [∂N/∂x] (4x1), [∂N/∂y], [∂N/∂z].",
                                    "Verifique consistência somando gradientes para modos rígidos.",
                                    "Armazene para uso na matriz [B]."
                                  ],
                                  "verification": "∇Nᵢ · r = 1 para nós i e 0 para outros (teste interpolação).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software simbólico como Mathematica ou código NumPy pronto"
                                  ],
                                  "tips": "Implemente como função reutilizável; evite cálculos manuais longos.",
                                  "learningObjective": "Transformar derivadas locais em gradientes físicos globais.",
                                  "commonMistakes": [
                                    "Erro na multiplicação matricial J⁻¹ * derivadas locais",
                                    "Confundir transposta"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar e verificar a matriz [B] de deformação completa",
                                  "subSteps": [
                                    "Estruture [B] (6x12): linhas para εₓₓ, εᵧᵧ, εzz, γₓᵧ, γₓz, γᵧz.",
                                    "Preencha: para εₓₓ: [∂N₁/∂x 0 ... ∂N₄/∂x 0]; similar para diagonais e cisalhantes (2*∂N/∂y para γₓᵧ).",
                                    "Associe DOFs: u₁,v₁,w₁,u₂,... (12 colunas).",
                                    "Verifique propriedades: rank([B])=6, nulidade para modos rígidos.",
                                    "Teste com deslocamento rígido: [B] u_rígido = 0."
                                  ],
                                  "verification": "Dimensões 6x12 corretas; [B] * u_translação = zero vector.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha Excel ou MATLAB para matriz final",
                                    "Exemplo numérico completo"
                                  ],
                                  "tips": "Use padrão block: [∂N/∂x | 0 | 0; 0 | ∂N/∂y | 0; ... ; ∂N/∂y ∂N/∂x 0; ...].",
                                  "learningObjective": "Construir [B] que relaciona deformadas a deslocamentos nodais.",
                                  "commonMistakes": [
                                    "Fator 1/2 em γ (não em [B], só em energia)",
                                    "Ordem errada de DOFs nodais"
                                  ]
                                }
                              ],
                              "practicalExample": "Para tetraedro com nós: (0,0,0), (1,0,0), (0,1,0), (0,0,1). No centro (ξ=η=ζ=1/4), compute J, J⁻¹, gradientes e [B] numérica (ex: ∂N₁/∂x ≈ -1, etc.), resultando em [B] 6x12 com valores como [[-1,0,0,1,0,0,0,0,0,0,0,0], ...].",
                              "finalVerifications": [
                                "Matriz [B] tem dimensões exatas 6 linhas x 12 colunas.",
                                "Gradientes somam zero: ∑ ∂Nᵢ/∂x = 0, similar para y,z.",
                                "[B] aplicada a deslocamento de translação rígida resulta em vetor deformada nulo.",
                                "Det(J) positivo e valores de gradiente consistentes com geometria.",
                                "Verificação de rotação rígida: deformadas zero.",
                                "Rank de [B] é 6 (espaço deformada)."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos gradientes globais (erro < 1e-6 numérico).",
                                "Correta estrutura block da matriz [B] para componentes normais/cisalhantes.",
                                "Verificação de propriedades de invariância rígida.",
                                "Eficiência no uso da Jacobiana (sem redundâncias).",
                                "Clareza na documentação dos cálculos intermediários.",
                                "Capacidade de generalizar para outros pontos de Gauss."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (inversão Jacobiana, gradientes vetoriais).",
                                "Física: Mecânica dos sólidos (teoria de deformações infinitesimal).",
                                "Programação: Implementação numérica em Python/NumPy para automação.",
                                "Geometria Computacional: Mapeamento isoparamétrico 3D."
                              ],
                              "realWorldApplication": "Em software FEA como ANSYS ou Abaqus, a matriz [B] é essencial para calcular deformações em simulações de estruturas 3D como pontes, aviões ou implantes médicos, permitindo prever falhas por tensão em peças complexas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.3.1.3.2",
                            "name": "Calcular a matriz de rigidez elementar",
                            "description": "Integrar numericamente a matriz de rigidez [k] = ∫ [B]^T [D] [B] dV usando pontos de Gauss para o tetraedro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a geometria do elemento tetraédrico e funções de forma",
                                  "subSteps": [
                                    "Especificar as coordenadas dos 4 nós do tetraedro no espaço 3D (ex: nó1=(0,0,0), nó2=(1,0,0), nó3=(0,1,0), nó4=(0,0,1)).",
                                    "Derivar as funções de forma lineares N_i(ξ,η,ζ) em coordenadas naturais (ξ,η,ζ) para tetraedro: N1=1-ξ-η-ζ, N2=ξ, N3=η, N4=ζ.",
                                    "Verificar que a soma das funções de forma é 1 em qualquer ponto interno: ∑N_i = 1.",
                                    "Calcular as derivadas parciais das funções de forma em relação a ξ,η,ζ.",
                                    "Documentar a geometria em uma tabela ou diagrama."
                                  ],
                                  "verification": "Confirme que ∑N_i = 1 no baricentro (ξ=η=ζ=0.25) e derivadas estão corretas comparando com referências padrão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel quadriculado, calculadora científica, software de visualização 3D como ParaView ou MATLAB.",
                                  "tips": "Use coordenadas isoparamétricas padrão para evitar erros de mapeamento.",
                                  "learningObjective": "Entender a parametrização do tetraedro e suas funções de forma lineares.",
                                  "commonMistakes": "Confundir coordenadas globais com naturais; esquecer que funções de forma devem somar 1."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a matriz Jacobiana [J] e seu determinante",
                                  "subSteps": [
                                    "Montar a matriz Jacobiana [J] = [∂x/∂ξ ∂x/∂η ∂x/∂ζ; ∂y/∂ξ ...; ∂z/∂ξ ...] usando derivadas das N_i multiplicadas pelas coordenadas dos nós.",
                                    "Computar det([J]) em pontos de interesse para garantir elemento não-degenerado (det>0).",
                                    "Inverter [J] para obter derivadas espaciais: [∂/∂x ∂/∂y ∂/∂z] = [J]^{-1} [∂/∂ξ ∂/∂η ∂/∂ζ].",
                                    "Verificar det([J]) constante para tetraedro linear (6V, onde V é volume).",
                                    "Armazenar [J]^{-1} para uso posterior."
                                  ],
                                  "verification": "Calcule det([J]) e confirme positivo e consistente com volume do tetraedro: V=det([J])/6.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB ou Python (NumPy/SciPy) para inversão matricial, papel para cálculo manual.",
                                  "tips": "Para tetraedros regulares, det([J]) é constante; teste com elemento unitário.",
                                  "learningObjective": "Dominar o mapeamento isoparamétrico e cálculo da Jacobiana.",
                                  "commonMistakes": "Inverter ordem das derivadas; não verificar sinal de det([J]) (elemento invertido)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar pontos de Gauss e pesos para integração no tetraedro",
                                  "subSteps": [
                                    "Selecionar esquema de Gauss: para precisão linear, use 1 ponto no baricentro (ξ=η=ζ=0.25, peso w=1/6). Para quadrático, 4-5 pontos.",
                                    "Listar coordenadas naturais e pesos: ex. ponto1=(0.25,0.25,0.25), w=1/6.",
                                    "Calcular o fator de integração local: w * det([J]) para cada ponto.",
                                    "Verificar convergência: integral de 1 deve dar volume V.",
                                    "Preparar tabela de pontos de Gauss."
                                  ],
                                  "verification": "Integre função constante 1: ∑ w_i * det([J]) ≈ 6V (exato para 1 ponto).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Tabela de pontos de Gauss para tetraedro (referência: livros de Bathe ou Zienkiewicz), Excel ou Python.",
                                  "tips": "Comece com 1 ponto para simplicidade; aumente para precisão.",
                                  "learningObjective": "Aplicar quadratura de Gauss em 3D para tetraedros.",
                                  "commonMistakes": "Usar pesos errados (não 1/6 para baricentro); ignorar det([J])."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir a matriz de deformação [B] e a matriz de material [D]",
                                  "subSteps": [
                                    "Em cada ponto de Gauss, calcular derivadas das funções de forma no espaço: ∂N_i/∂x, ∂N_i/∂y, ∂N_i/∂z usando [J]^{-1}.",
                                    "Montar [B] (3x12 para deslocamentos 3D, 4 nós): colunas com [∂N_i/∂x 0 0; 0 ∂N_i/∂y 0; 0 0 ∂N_i/∂z; ...] para cada nó.",
                                    "Definir [D] para material isotrópico: [D] = E/(1+ν)/(1-2ν) * matriz padrão com λ e μ.",
                                    "Verificar simetria e propriedades de [B] e [D].",
                                    "Computar [B]^T [D] [B] em cada ponto."
                                  ],
                                  "verification": "Confirme que [B] tem dimensões corretas (3x12) e [D] (6x6) para strain 3D.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python (NumPy para matrizes), ou MATLAB; propriedades do material (E=210GPa, ν=0.3 para aço).",
                                  "tips": "Automatize com loops em código para múltiplos pontos.",
                                  "learningObjective": "Formular matrizes [B] e [D] para elementos sólidos 3D.",
                                  "commonMistakes": "Erro no strain-displacement: esquecer termos de cisalhamento; [D] errada para 3D."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar numericamente e montar a matriz de rigidez [k]",
                                  "subSteps": [
                                    "Para cada ponto Gauss: calcular K_gauss = [B]^T [D] [B] * det([J]) * w.",
                                    "Somar K_element = ∑ K_gauss sobre todos pontos.",
                                    "Verificar simetria de [k] (12x12) e positividez semi-definida.",
                                    "Escalonar unidades (N/m) e comparar com analítico se possível.",
                                    "Exportar [k] para análise modal ou estática."
                                  ],
                                  "verification": "k deve ser simétrica (tol=1e-10), trace(k)>0, e rígida para compressão volumétrica.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código Python/MATLAB completo, debugger para matrizes.",
                                  "tips": "Use np.dot e np.sum para eficiência; teste com elemento regular.",
                                  "learningObjective": "Executar integração de Gauss para montar [k] elementar.",
                                  "commonMistakes": "Esquecer det([J])*w; não somar corretamente; perda de simetria por erros numéricos."
                                }
                              ],
                              "practicalExample": "Para um tetraedro com nós (0,0,0), (1,0,0), (0,1,0), (0,0,1), aço (E=200GPa, ν=0.3), usando 1 ponto Gauss: det(J)=1/6, [k] resulta em matriz 12x12 com diagonais ~1e11 N/m, simétrica, pronta para montagem global.",
                              "finalVerifications": [
                                "Matriz [k] é simétrica com tolerância <1e-10.",
                                "Determinantes principais positivos (semi-definida positiva).",
                                "Integral de volume coincide com 6*det(J).",
                                "Componentes de rigidez na direção dos nós são positivas e realistas.",
                                "Simulação de tração unitária produz deslocamentos coerentes.",
                                "Comparação com solução analítica para tetraedro regular (erro <1%)."
                              ],
                              "assessmentCriteria": [
                                "Precisão da Jacobiana e det(J) (erro <0.1%).",
                                "Correção da matriz [B] em baricentro (verificação manual).",
                                "Implementação correta de Gauss (convergência com mais pontos).",
                                "Simetria e condicionamento de [k] (cond(k)<1e12).",
                                "Eficiência computacional (tempo <1s para 5 pontos em Python).",
                                "Capacidade de generalizar para tetraedro irregular."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Integração numérica multidimensional e álgebra linear.",
                                "Programação: Implementação numérica em Python/MATLAB com vetores e matrizes.",
                                "Física: Teoria da elasticidade linear e deformações 3D.",
                                "Computação Científica: Otimização de quadratura para FEM.",
                                "Engenharia de Software: Validação e testes unitários em simulações."
                              ],
                              "realWorldApplication": "Em software FEM como ANSYS ou Abaqus, essa matriz [k] é usada para simular tensões em peças automotivas complexas, como cabeçotes de motor fundidos em malhas tetraédricas, otimizando design para fadiga e vibrações."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.3.1.3.3",
                            "name": "Determinar o vetor de forças nodais",
                            "description": "Calcular o vetor de forças {f} elementar devido a cargas volumétricas ou de superfície para análise estática.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de forças distribuídas em elementos finitos",
                                  "subSteps": [
                                    "Revise as funções de forma lineares para o elemento tetraédrico de 4 nós (N_i = L_i, coordenadas baricêntricas).",
                                    "Entenda a diferença entre cargas volumétricas (body forces, ρb) e cargas de superfície (tração t).",
                                    "Aprenda a expressão geral do vetor de forças nodais: {f} = ∫_V N^T ρ b dV + ∫_S N^T t dS.",
                                    "Estude a discretização: para cargas constantes, simplificações como f_i = (V/4) ρ b para body forces uniformes.",
                                    "Pratique esboçando um tetraedro e labelando nós e volumes."
                                  ],
                                  "verification": "Escreva as funções de forma para um tetraedro e derive a fórmula simplificada para body force uniforme.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Elementos Finitos (ex: Zienkiewicz), papel e lápis, calculadora"
                                  ],
                                  "tips": "Visualize o tetraedro em 3D usando software gratuito como Gmsh para melhor intuição.",
                                  "learningObjective": "Dominar a base teórica para cálculo de forças nodais em elementos 3D.",
                                  "commonMistakes": [
                                    "Confundir funções de forma com interpolação de deslocamentos",
                                    "Ignorar a orientação das coordenadas baricêntricas",
                                    "Esquecer a transposição N^T"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o vetor de forças nodais para cargas volumétricas",
                                  "subSteps": [
                                    "Defina as cargas volumétricas: ρ (densidade) e b (vetor de aceleração corporal, ex: gravidade).",
                                    "Escreva a integral: f_vol = ∫_V N^T ρ b dV.",
                                    "Para tetraedro linear e cargas constantes: f_i = ρ b (V / 4) para cada nó i.",
                                    "Calcule o volume V do tetraedro: V = (1/6) |det(J)| onde J é a matriz jacobiana.",
                                    "Implemente numericamente em uma planilha ou código simples para um exemplo dado."
                                  ],
                                  "verification": "Compute f_vol para um tetraedro com V=1, ρ=1000 kg/m³, b={0,0,-9.81} e confirme soma das forças = ρ b V.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software MATLAB/Python ou Excel, coordenadas de nós exemplo"
                                  ],
                                  "tips": "Sempre normalize pelo volume para verificar equilíbrio estático total.",
                                  "learningObjective": "Calcular precisamente forças nodais de body loads em elementos tetraédricos.",
                                  "commonMistakes": [
                                    "Erro no cálculo de volume (fator 1/6)",
                                    "Não multiplicar por ρ antes de b",
                                    "Assumir distribuição não-uniforme sem integração Gauss"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o vetor de forças nodais para cargas de superfície",
                                  "subSteps": [
                                    "Identifique a face do tetraedro afetada (ex: face triangular com 3 nós).",
                                    "Escreva a integral: f_surf = ∫_S N^T t dS, onde N são funções de forma na face.",
                                    "Para tração constante t: f_i = t (A / 3) para nós da face i, zero para nó oposto.",
                                    "Calcule a área A da face triangular: A = (1/2) || (P2 - P1) × (P3 - P1) ||.",
                                    "Some f_surf ao vetor total {f} considerando múltiplas faces."
                                  ],
                                  "verification": "Para uma face com A=0.5 m², t={100,0,0} N/m², confirme f para nós da face = {100/3 * A, 0, 0} cada.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Mesmos do step 2, diagramas de faces tetraédricas"
                                  ],
                                  "tips": "Use vetores normais para direção correta de t; teste com cargas opostas para equilíbrio.",
                                  "learningObjective": "Aplicar integração superficial para trações em elementos finitos.",
                                  "commonMistakes": [
                                    "Dividir área por 4 em vez de 3 para face triangular",
                                    "Aplicar t ao nó oposto",
                                    "Ignorar projeção na direção normal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar o vetor de forças total e verificar consistência",
                                  "subSteps": [
                                    "Combine f_total = f_vol + f_surf para todas as contribuições.",
                                    "Verifique equilíbrio global: soma f_total deve igualar forças externas totais.",
                                    "Implemente em código para automação (ex: função em Python).",
                                    "Teste com caso conhecido: tetraedro sob gravidade pura.",
                                    "Analise sensibilidade a malha (refine e compare)."
                                  ],
                                  "verification": "Código ou cálculo manual produz f_total com soma_z = m*g para gravidade.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Python/MATLAB com NumPy, exemplos de malha tetraédrica"
                                  ],
                                  "tips": "Debugue imprimindo volumes e áreas intermediários.",
                                  "learningObjective": "Integrar cargas distribuídas em vetor nodal coerente para análise estática.",
                                  "commonMistakes": [
                                    "Duplicar contribuições de faces compartilhadas",
                                    "Erro de sinal em b ou t",
                                    "Não zerar componentes não-afetadas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um tetraedro com nós (0,0,0), (1,0,0), (0,1,0), (0,0,1); V≈0.1667 m³, ρ=7800 kg/m³, b={0,0,-9.81}, t={0,0,100} na face base (nós 1,2,3). Calcule f_vol ≈ {0,0,-20.1} por nó; f_surf base ≈ {0,0,16.67} para nós 1,2,3; f_total variando por nó.",
                              "finalVerifications": [
                                "Deriva corretamente fórmulas simplificadas para f_vol e f_surf.",
                                "Calcula volume e área com precisão <1% erro.",
                                "Verifica equilíbrio global soma(f) = total load.",
                                "Implementa código que reproduz resultados manuais.",
                                "Identifica e corrige erros em casos com cargas mistas.",
                                "Explica impacto em análise estática de sólidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas integrais (90%+ correto).",
                                "Correta aplicação de funções de forma e simplificações.",
                                "Verificação de equilíbrio e consistência física.",
                                "Clareza na implementação numérica e documentação.",
                                "Capacidade de generalizar para cargas não-constantes.",
                                "Tempo de execução eficiente em exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo vetorial, integrais em 3D e determinantes.",
                                "Física: Estática de sólidos, forças distribuídas e equilíbrio.",
                                "Computação: Programação numérica e integração Gauss.",
                                "Engenharia Civil: Análise de estruturas sob cargas volumétricas.",
                                "Materiais: Relação com propriedades densidade e comportamento sob gravidade."
                              ],
                              "realWorldApplication": "Em simulações FEM de componentes mecânicos como tanques de combustível (cargas volumétricas por fluido) ou placas sob pressão (cargas superficiais), prevendo tensões e deformações em projetos de aviões, carros ou pontes para garantir segurança estrutural."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.3.1.3.4",
                            "name": "Aplicar condições de contorno elementares",
                            "description": "Implementar restrições de deslocamento nos graus de liberdade do elemento tetraédrico de 4 nós (3 DOF por nó).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir geometria e graus de liberdade do elemento tetraédrico",
                                  "subSteps": [
                                    "Identifique os 4 nós do elemento tetraédrico e suas coordenadas (x,y,z).",
                                    "Liste os 12 graus de liberdade (DOF): 3 por nó (ux, uy, uz para nós 1 a 4).",
                                    "Desenhe o elemento e rotule os DOFs claramente.",
                                    "Calcule o vetor de deslocamentos locais {d} com 12 entradas.",
                                    "Verifique a conectividade nodal padrão (nó1, nó2, nó3, nó4)."
                                  ],
                                  "verification": "Confirme que o diagrama mostra 12 DOFs corretamente rotulados e vetor {d} dimensionado 12x1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, software de visualização 3D como ParaView ou MATLAB.",
                                  "tips": "Use convenção consistente: DOFs ordenados como u1x,u1y,u1z,u2x,...u4z.",
                                  "learningObjective": "Compreender a estrutura de DOFs para restrições precisas.",
                                  "commonMistakes": "Confundir ordem dos DOFs ou ignorar que são 3D (não 2D)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e especificar condições de contorno elementares",
                                  "subSteps": [
                                    "Determine as restrições baseadas no problema físico (ex: fixação em uma face).",
                                    "Selecione DOFs a restringir (ex: todos 3 DOFs de um nó fixo = 0).",
                                    "Crie uma lista booleana ou máscara para DOFs livres vs. restritos (12 entradas).",
                                    "Defina valores conhecidos para DOFs restritos (geralmente 0 para deslocamentos fixos).",
                                    "Documente a face ou nó afetado (ex: face 1-2-3 fixada)."
                                  ],
                                  "verification": "Máscara de DOFs mostra exatamente quais são restritos (ex: primeiros 3 = true para fixo).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Planilha ou código simples em Python/MATLAB para máscara.",
                                  "tips": "Priorize faces triangulares para fixação realista em sólidos 3D.",
                                  "learningObjective": "Selecionar DOFs relevantes para condições físicas realistas.",
                                  "commonMistakes": "Restringir DOFs errados, como rigidez em vez de deslocamento."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar restrições na matriz de rigidez local",
                                  "subSteps": [
                                    "Monte a matriz de rigidez local [k] 12x12 sem restrições.",
                                    "Remova ou penalize linhas/colunas dos DOFs restritos (método de eliminação).",
                                    "Atualize o vetor de força {f} incorporando valores conhecidos dos DOFs restritos.",
                                    "Aplique multiplicador de penalidade se método de penalidade for usado (ex: 1e12 * [k]).",
                                    "Reduza [k] e {f} para DOFs livres apenas."
                                  ],
                                  "verification": "[k_reduzida] tem dimensão (12 - n_restritos) x (12 - n_restritos) e é simétrica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "MATLAB/Python com NumPy, exemplo de [k] pré-calculado para tetraedro.",
                                  "tips": "Teste com fixação total de 1 nó: reduza para 9x9.",
                                  "learningObjective": "Modificar equações de equilíbrio [k]{d} = {f} para DOFs conhecidos.",
                                  "commonMistakes": "Não zerar linhas/colunas corretamente, levando a singularidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar implementação e preparar para montagem global",
                                  "subSteps": [
                                    "Resolva sistema reduzido para DOFs livres e recupere DOFs restritos.",
                                    "Calcule deslocamentos e verifique se DOFs restritos = valores impostos.",
                                    "Cheque equilíbrio de forças nos nós restritos.",
                                    "Compare com caso sem restrições para validar impacto.",
                                    "Mapeie DOFs locais para globais para montagem."
                                  ],
                                  "verification": "Deslocamentos restritos exatos (ex: 0) e forças equilibradas (erro < 1e-6).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código FEM básico, solver linear (ex: mldivide em MATLAB).",
                                  "tips": "Use casos simples como carga uniaxial para teste rápido.",
                                  "learningObjective": "Garantir consistência numérica das restrições elementares.",
                                  "commonMistakes": "Esquecer de expandir DOFs livres para full {d} no pós-processamento."
                                }
                              ],
                              "practicalExample": "Para um tetraedro com nós em (0,0,0), (1,0,0), (0,1,0), (0,0,1), fixe o nó 1 (base) com ux=uy=uz=0. Restrinja DOFs 1-3 na [k] 12x12, reduza para 9x9, aplique carga em nó 4 e resolva: verifique se nó 1 permanece fixo.",
                              "finalVerifications": [
                                "Máscara de DOFs corresponde à condição física especificada.",
                                "Matriz reduzida é positiva definida e simétrica.",
                                "Deslocamentos nos DOFs restritos igualam valores impostos (erro < 1e-10).",
                                "Forças reativas nos nós fixos equilibram a carga aplicada.",
                                "Solução converge sem warnings de singularidade.",
                                "Resultados consistentes com teoria estática rígida."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e ordenação dos 12 DOFs.",
                                "Correta redução da matriz de rigidez (dimensão e simetria).",
                                "Implementação numérica sem erros de indexação.",
                                "Validação quantitativa de deslocamentos restritos.",
                                "Explicação clara do impacto físico das restrições.",
                                "Eficiência computacional (tempo de solução razoável)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (modificação de sistemas lineares, eliminação gaussiana).",
                                "Programação: Manipulação de arrays multidimensionais e indexação esparsa.",
                                "Física: Mecânica dos sólidos (equilíbrio estático, reações de apoio).",
                                "Computação Científica: Métodos numéricos para PDEs elípticas.",
                                "Engenharia de Software: Modularidade em códigos FEM."
                              ],
                              "realWorldApplication": "Em análise estrutural de fundações de pontes ou peças de motores aeronáuticos, onde bases são fixas (ux=uy=uz=0), garantindo simulações precisas de deformações sob carga sem movimento espúrio."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.2",
                    "name": "Elemento Tetraédrico de Ordem Superior",
                    "description": "Elementos tetraédricos com 10 nós, funções de forma quadráticas e aplicações em malhas refinadas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.2.1",
                        "name": "Geometria do Elemento Tetraédrico de 10 Nós",
                        "description": "Configuração nodal do elemento tetraédrico quadrático, composto por 4 nós nos vértices e 6 nós nos pontos médios das arestas, permitindo modelagem precisa de deformações em sólidos 3D.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.1.1",
                            "name": "Identificar posições dos nós",
                            "description": "Localizar e numerar os 10 nós do elemento tetraédrico de ordem superior, diferenciando nós vertex (1-4) dos nós de aresta (5-10), com base na conectividade padrão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a geometria básica do tetraedro de 4 nós",
                                  "subSteps": [
                                    "Visualize um tetraedro como uma pirâmide triangular com 4 faces equiláteras.",
                                    "Identifique os 4 vértices principais (nós 1, 2, 3, 4) que definem as extremidades das 6 arestas.",
                                    "Desenhe ou esboce o tetraedro em 3D, marcando apenas os nós vertex.",
                                    "Confirme que cada nó vertex está conectado a 3 arestas.",
                                    "Liste as coordenadas típicas: nó 1 (0,0,0), nó 2 (1,0,0), nó 3 (0.5, √3/2, 0), nó 4 (0.5, √3/6, √6/3)."
                                  ],
                                  "verification": "Esboço completo com 4 nós vertex corretamente posicionados e conectados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis ou software de desenho 3D como GeoGebra",
                                    "Diagrama de referência do tetraedro linear"
                                  ],
                                  "tips": "Use uma visão isométrica para melhor visualização 3D.",
                                  "learningObjective": "Compreender a estrutura fundamental do tetraedro de 4 nós.",
                                  "commonMistakes": "Confundir faces com arestas ou posicionar vértices incorretamente em coordenadas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir e localizar os nós de aresta (nós 5-10)",
                                  "subSteps": [
                                    "Identifique as 6 arestas do tetraedro: entre nós 1-2, 1-3, 1-4, 2-3, 2-4, 3-4.",
                                    "Coloque um nó de aresta no ponto médio de cada aresta: nó 5 (meio 1-2), nó 6 (meio 1-3), etc.",
                                    "Calcule coordenadas médias para cada nó de aresta usando fórmulas de ponto médio.",
                                    "Marque visualmente os nós 5-10 no esboço, diferenciando-os dos vertex por cor ou símbolo.",
                                    "Verifique que cada nó de aresta está conectado a exatamente 2 nós vertex e compartilhado por 3 faces."
                                  ],
                                  "verification": "Todos os 6 nós de aresta posicionados corretamente nos pontos médios das arestas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Esboço do Step 1",
                                    "Calculadora ou planilha para coordenadas",
                                    "Tabela de conectividade padrão"
                                  ],
                                  "tips": "Rotule as arestas primeiro para evitar confusão na numeração.",
                                  "learningObjective": "Localizar precisamente os nós de aresta em relação aos vertex.",
                                  "commonMistakes": "Colocar nós de aresta em posições erradas, como vértices, ou numerar fora de sequência padrão."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Numerar todos os 10 nós seguindo a conectividade padrão",
                                  "subSteps": [
                                    "Adote a convenção padrão: nós 1-4 (vertex), nós 5-10 (arestas em ordem: 1-2,1-3,1-4,2-3,2-4,3-4).",
                                    "Anote a lista de conectividade: cada nó e suas conexões vizinhas.",
                                    "Desenhe linhas de conectividade completa, mostrando que cada face tem 6 nós (4 vertex + 2 por aresta).",
                                    "Compare com um diagrama de referência de elemento tetraédrico de 10 nós.",
                                    "Rotule o diagrama final com números 1-10 e legendas (vertex vs. aresta)."
                                  ],
                                  "verification": "Diagrama numerado corretamente com conectividade padrão confirmada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama do Step 2",
                                    "Tabela de conectividade padrão do tetraedro 10-nós",
                                    "Software MEF como Gmsh para visualização"
                                  ],
                                  "tips": "Sempre comece numerando vertex em ordem clockwise vista de fora.",
                                  "learningObjective": "Aplicar numeração padrão para compatibilidade em análises FEA.",
                                  "commonMistakes": "Numerar nós de aresta fora da sequência convencional ou inverter pares de arestas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e validar as posições dos nós",
                                  "subSteps": [
                                    "Calcule distâncias entre nós conectados para confirmar posições geométricas.",
                                    "Verifique a topologia: 10 nós, 6 arestas com midpoints, 4 faces triangulares quadráticas.",
                                    "Simule em software: importe geometria e cheque numeração de nós.",
                                    "Identifique diferenças entre tetraedro linear (4 nós) e quadrático (10 nós).",
                                    "Documente um relatório resumido com diagrama final e lista de posições."
                                  ],
                                  "verification": "Validação bem-sucedida sem discrepâncias na conectividade ou geometria.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Software de MEF (ex: Gmsh, ANSYS)",
                                    "Relatório template"
                                  ],
                                  "tips": "Use zoom e rotação 3D no software para inspecionar cada aresta.",
                                  "learningObjective": "Validar conhecimento através de verificações práticas e computacionais.",
                                  "commonMistakes": "Ignorar assimetrias em coordenadas ou falhar em validar com software."
                                }
                              ],
                              "practicalExample": "Em um software de elementos finitos como ANSYS, crie um tetraedro com coordenadas padrão, gere a malha quadrática de 10 nós e confirme que os nós 1-4 estão nos vértices e 5-10 nos midpoints das arestas, exportando o diagrama numerado.",
                              "finalVerifications": [
                                "Pode esboçar e numerar corretamente os 10 nós sem referência?",
                                "Diferencia verbalmente nós vertex de nós de aresta com exemplos de conectividade?",
                                "Calcula coordenadas de pelo menos 3 nós de aresta corretamente?",
                                "Valida a conectividade padrão em um diagrama ou software?",
                                "Explica a importância da numeração padrão em simulações FEA?",
                                "Identifica erros comuns em diagramas de outros alunos?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização e numeração dos 10 nós (90% correto).",
                                "Compreensão clara da diferenciação vertex vs. aresta.",
                                "Uso correto de coordenadas e conectividade padrão.",
                                "Qualidade do esboço ou modelo 3D (claro e rotulado).",
                                "Capacidade de validação independente via cálculo ou software.",
                                "Explicação coerente da geometria em relatório.",
                                "Tempo de execução dentro do estimado com eficiência."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Geometria analítica e vetores para coordenadas de pontos médios.",
                                "Programação: Geração de malhas em Python com bibliotecas como MeshPy ou Gmsh API.",
                                "Física: Aplicação em mecânica dos sólidos para deformações 3D.",
                                "Desenho Técnico: Representações 3D e projeções isométricas."
                              ],
                              "realWorldApplication": "Em análises de elementos finitos (FEA) para engenharia mecânica, como simulação de tensões em peças automotivas ou aeroespaciais, onde a correta identificação de nós em elementos tetraédricos de 10 nós garante precisão na malha quadrática para modelar gradientes de tensão suaves."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.2",
                            "name": "Descrever mapeamento isoparamétrico",
                            "description": "Explicar o mapeamento das coordenadas locais (baricêntricas ξ, η, ζ) para coordenadas globais (x, y, z) utilizando funções de forma, garantindo representação quadrática da geometria.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender coordenadas locais baricêntricas no tetraedro",
                                  "subSteps": [
                                    "Defina coordenadas baricêntricas (ξ, η, ζ) como pesos normalizados associados aos vértices do tetraedro, onde ξ + η + ζ ≤ 1.",
                                    "Explique que no domínio de referência, o tetraedro padrão tem vértices em (0,0,0), (1,0,0), (0,1,0), (0,0,1).",
                                    "Descreva a relação com coordenadas naturais: o quarto peso é 1 - ξ - η - ζ.",
                                    "Visualize o domínio usando diagramas 2D/3D para simplicidade.",
                                    "Pratique convertendo pontos cartesianos locais para baricêntricos."
                                  ],
                                  "verification": "Desenhe o tetraedro de referência e rotule corretamente as coordenadas baricêntricas em pelo menos 3 pontos internos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel quadriculado, lápis, calculadora, software de visualização como GeoGebra ou MATLAB.",
                                  "tips": "Use animações online para visualizar o tetraedro para melhor intuição espacial.",
                                  "learningObjective": "Dominar a representação baricêntrica no domínio de referência do tetraedro.",
                                  "commonMistakes": "Confundir baricêntricas com cartesianas; esquecer que somam a 1."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar nós e funções de forma para elemento de 10 nós",
                                  "subSteps": [
                                    "Liste os 10 nós: 4 vértices (1-4), 6 nós de aresta médios (5-10).",
                                    "Derive funções de forma lineares para vértices: N_i = L_i(ξ,η,ζ), onde L_i são baricêntricas.",
                                    "Defina funções quadráticas para nós de aresta: N_i = 4 L_j L_k (1 - L_j - L_k) para aresta j-k.",
                                    "Verifique que funções de forma somam a 1 e são 1 no nó próprio, 0 nos outros.",
                                    "Plote funções de forma ao longo de uma aresta para validar quadraticidade."
                                  ],
                                  "verification": "Escreva explicitamente as 10 funções de forma e verifique N_i(nó_j) = δ_ij para i,j=1..10.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Folha de fórmulas, MATLAB ou Python (SymPy para simplificação simbólica), livro de elementos finitos.",
                                  "tips": "Memorize padrões: lineares nos vértices, bubbled quadráticas nas arestas.",
                                  "learningObjective": "Construir e validar funções de forma Lagrangeanas quadráticas para tetraedro de 10 nós.",
                                  "commonMistakes": "Erros nos coeficientes quadráticos (ex: 4 vs 2); não normalizar para soma=1."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular o mapeamento isoparamétrico para coordenadas globais",
                                  "subSteps": [
                                    "Estabeleça a equação: x(ξ,η,ζ) = Σ_{i=1}^{10} N_i(ξ,η,ζ) x_i, similar para y e z.",
                                    "Explique que x_i são coordenadas globais dos nós físicos.",
                                    "Mostre que para vértices, é linear; com nós médios, torna-se quadrático ao longo das arestas.",
                                    "Derive o Jacobiano J = ∂(x,y,z)/∂(ξ,η,ζ) para transformação.",
                                    "Implemente numericamente para um tetraedro distorcido."
                                  ],
                                  "verification": "Calcule posição global de um ponto baricêntrico médio e confirme interpolação quadrática em arestas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Computador com MATLAB/Python, coordenadas de exemplo de 10 nós.",
                                  "tips": "Use expansão em série de Taylor para provar exatidão quadrática.",
                                  "learningObjective": "Derivar e expressar matematicamente o mapeamento isoparamétrico.",
                                  "commonMistakes": "Omitir nós médios, levando a mapeamento apenas linear; confundir domínio local com global."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar representação quadrática da geometria e propriedades",
                                  "subSteps": [
                                    "Demonstre que curvas são representadas exatamente como quadráticas nas arestas.",
                                    "Verifique isomorfismo: mapeamento 1-1 no interior, invertível via Jacobiano não-singular.",
                                    "Analise distorções: elementos muito distorcidos podem degradar precisão.",
                                    "Compare com mapeamento linear (4 nós) para mostrar melhoria.",
                                    "Teste com software FEA (ex: Abaqus) visualizando malha mapeada."
                                  ],
                                  "verification": "Gere gráfico de uma aresta curva mapeada e confirme 3 pontos colineares só no linear.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software FEA como FreeFEM ou Gmsh, exemplos de malhas tetraédricas.",
                                  "tips": "Monitore det(J) > 0 para evitar inversões.",
                                  "learningObjective": "Garantir que o mapeamento capture geometria quadrática com propriedades numéricas adequadas.",
                                  "commonMistakes": "Ignorar Jacobiano, levando a falhas em integração; superestimar exatidão (não cúbica)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar e sintetizar o mapeamento em contexto FEA",
                                  "subSteps": [
                                    "Integre o mapeamento em cálculo de integrais de Gauss-Legendre no domínio local.",
                                    "Discuta uso em gradientes: ∇u = J^{-T} ∇_local u.",
                                    "Resolva um problema simples: tensão em tetraedro curvo.",
                                    "Documente limitações: não captura superfícies lisas perfeitamente.",
                                    "Resuma vantagens: melhor precisão geométrica vs lineares."
                                  ],
                                  "verification": "Implemente código que mapeie 5 pontos e compute volume do elemento corretamente.",
                                  "estimatedTime": "55 minutos",
                                  "materials": "Python/MATLAB com NumPy/SciPy, tutorial de FEA.",
                                  "tips": "Comece com 2D (triângulo) para debug antes de 3D.",
                                  "learningObjective": "Aplicar mapeamento isoparamétrico em pipeline completo de elementos finitos.",
                                  "commonMistakes": "Erros de indexação nos nós; não transformar derivadas corretamente."
                                }
                              ],
                              "practicalExample": "Considere um tetraedro com vértices: 1=(0,0,0), 2=(1,0,0), 3=(0,1,0), 4=(0,0,1); nós médios de aresta 1-2=(0.5,0,0), etc. Para ponto local (ξ=0.5, η=0.25, ζ=0.125), calcule funções N_i e obtenha x≈0.5, y≈0.25, z≈0.125, confirmando interpolação quadrática suave ao longo da aresta 1-2.",
                              "finalVerifications": [
                                "Deriva corretamente as 10 funções de forma baricêntricas quadráticas.",
                                "Escreve a equação de mapeamento x=Σ N_i x_i com precisão.",
                                "Calcula Jacobiano para um elemento distorcido sem singularidades.",
                                "Explica por que garante representação quadrática nas arestas.",
                                "Implementa numericamente e visualiza mapeamento em software.",
                                "Discute limitações como distorção excessiva."
                              ],
                              "assessmentCriteria": [
                                "Precisão das funções de forma (correção matemática: 100%).",
                                "Clareza na derivação do mapeamento e Jacobiano.",
                                "Validação numérica com exemplos concretos.",
                                "Explicação de propriedades quadráticas vs lineares.",
                                "Integração conceitual em FEA (gradientes, integração).",
                                "Identificação de erros comuns e soluções."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra polinomial e funções de interpolação Lagrangeana.",
                                "Programação: Implementação numérica em Python/MATLAB para automação.",
                                "Física: Modelagem de deformações em sólidos elásticos.",
                                "Geometria Computacional: Malhas e transformações afins.",
                                "Engenharia de Software: Verificação e validação em simulações."
                              ],
                              "realWorldApplication": "Em análises de elementos finitos (FEA) para simular tensões em peças automotivas complexas com geometria curva, como cabeçotes de motor, onde tetraédros de 10 nós capturam curvas de arestas com precisão quadrática, reduzindo erros em malhas adaptativas em softwares como ANSYS ou Abaqus."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.3",
                            "name": "Esboçar o elemento em 3D",
                            "description": "Desenhar o tetraedro de 10 nós, destacando arestas e posições nodais, para visualização de malhas tetraédricas em softwares de elementos finitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a geometria básica do tetraedro de 10 nós",
                                  "subSteps": [
                                    "Revise a estrutura: 4 vértices principais, 6 arestas com nós intermediários (meio de cada aresta).",
                                    "Identifique posições nodais: nós 1-4 nos vértices, nós 5-10 nos pontos médios das arestas.",
                                    "Estude projeções 3D comuns, como vista isométrica ou perspectiva.",
                                    "Anote convenções de numeração padrão para elementos tetraédricos de 10 nós.",
                                    "Esboce um tetraedro simples de 4 nós para aquecimento."
                                  ],
                                  "verification": "Lista completa de 10 nós com posições corretas anotada em um rascunho.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel quadriculado, lápis, borracha, tabela de numeração nodal de referência.",
                                  "tips": "Use coordenadas cartesianas (ex: vértice 1 em (0,0,0)) para precisão inicial.",
                                  "learningObjective": "Dominar a topologia e numeração dos nós no tetraedro de 10 nós.",
                                  "commonMistakes": "Confundir nós de aresta com nós faciais; sempre verificar contagem total de 10 nós."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenhar a estrutura esquelética 3D do tetraedro",
                                  "subSteps": [
                                    "Posicione os 4 vértices principais em projeção 3D (ex: base triangular no plano XY, ápice em Z).",
                                    "Conecte as arestas principais com linhas retas, garantindo proporções iguais.",
                                    "Ajuste ângulos para simular profundidade (use sombreamento leve para 3D).",
                                    "Verifique simetria: todas as arestas devem ter comprimento visual igual.",
                                    "Adicione eixos de referência (X, Y, Z) para orientação espacial."
                                  ],
                                  "verification": "Estrutura 3D básica com 4 vértices e 6 arestas conectadas corretamente, sem distorções.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel quadriculado, lápis HB e 2B, régua, compasso para círculos de proporção.",
                                  "tips": "Comece com uma base equilátera e eleve o ápice perpendicularmente para evitar deformações.",
                                  "learningObjective": "Criar uma representação 3D precisa da geometria tetraédrica básica.",
                                  "commonMistakes": "Arestas de comprimentos desiguais; meça visualmente com régua."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Marcar e destacar as posições dos nós de aresta",
                                  "subSteps": [
                                    "Localize o ponto médio exato de cada uma das 6 arestas e marque com círculos pequenos.",
                                    "Numere os nós sequencialmente: 1-4 vértices, 5-10 médios das arestas.",
                                    "Destaque nós com cores diferentes (ex: vértices em vermelho, arestas em azul).",
                                    "Adicione setas ou legendas indicando direções nodais para softwares de EF.",
                                    "Reforce linhas das arestas para enfatizar conectividade nodal."
                                  ],
                                  "verification": "Todos os 10 nós numerados e posicionados corretamente, com destaques visíveis.",
                                  "estimatedTime": "12 minutos",
                                  "materials": "Canetas coloridas (vermelho, azul), lápis, papel quadriculado.",
                                  "tips": "Use midpoints precisos: divida cada aresta em metades iguais com régua.",
                                  "learningObjective": "Posicionar e numerar precisamente os nós intermediários em representação 3D.",
                                  "commonMistakes": "Deslocamento dos nós médios; sempre bissecte arestas com régua."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Refinar o esboço para visualização em softwares de EF",
                                  "subSteps": [
                                    "Rotacione mentalmente o desenho em múltiplas vistas (frontal, lateral, isométrica).",
                                    "Adicione anotações: coordenadas nodais aproximadas e labels de arestas.",
                                    "Compare com imagens de referência de malhas tetraédricas em softwares como ANSYS ou Abaqus.",
                                    "Sombreie faces para realçar volume 3D e teste legibilidade.",
                                    "Digitalize ou trace o esboço para importação em software de desenho vetorial."
                                  ],
                                  "verification": "Esboço final legível, com múltiplas vistas e pronto para referência em simulações EF.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel quadriculado, canetas coloridas, imagens de referência impressas, scanner opcional.",
                                  "tips": "Pratique rotações em papel transparente sobreposto para dinamicidade.",
                                  "learningObjective": "Preparar o esboço para integração com ferramentas de análise de elementos finitos.",
                                  "commonMistakes": "Falta de profundidade 3D; use hachuras para indicar faces ocultas."
                                }
                              ],
                              "practicalExample": "Esboce um tetraedro de 10 nós representando a malha de um suporte de motor em uma simulação de tensão em software como ANSYS, destacando nós críticos nas arestas para refinar a malha.",
                              "finalVerifications": [
                                "Todos os 10 nós estão corretamente posicionados e numerados.",
                                "Arestas são simétricas e conectam nós adequadamente em 3D.",
                                "Destaques visuais (cores, labels) facilitam identificação nodal.",
                                "Projeção 3D transmite volume e profundidade realisticamente.",
                                "Anotações incluem coordenadas e referências para softwares EF.",
                                "Sem erros de contagem ou posicionamento nodal."
                              ],
                              "assessmentCriteria": [
                                "Precisão geométrica: posições nodais exatas (90%).",
                                "Qualidade visual 3D: profundidade e proporções corretas (85%).",
                                "Clareza de numeração e destaques: legibilidade total (95%).",
                                "Completude: todos elementos (nós, arestas, labels) presentes (100%).",
                                "Relevância para EF: anotações úteis para malhas (90%).",
                                "Criatividade na representação: rotações e sombreamento eficaz (80%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Geometria analítica e vetores 3D para coordenadas nodais.",
                                "Desenho Técnico: Projeções ortográficas e isométricas.",
                                "Computação: Visualização 3D em softwares como Blender ou MATLAB.",
                                "Física: Compreensão de deformações em malhas tetraédricas.",
                                "Design Gráfico: Uso de cores e sombreamento para clareza."
                              ],
                              "realWorldApplication": "Em engenharia mecânica, esse esboço auxilia engenheiros a validar malhas tetraédricas de 10 nós em simulações de elementos finitos para análise de fadiga em componentes aeroespaciais, como asas de turbinas, garantindo precisão na discretização da geometria complexa."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.2",
                        "name": "Funções de Forma Quadráticas",
                        "description": "Polinômios quadráticos completos em três variáveis para interpolação de deslocamentos, tensão e deformações no elemento tetraédrico de 10 nós, satisfazendo partição da unidade e propriedade delta.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.2.1",
                            "name": "Derivar funções de forma para nós vertex",
                            "description": "Obter as funções de forma quadráticas para os 4 nós vertex em coordenadas baricêntricas, como N1 = ξ(2ξ - 1), e verificar soma unitária.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar coordenadas baricêntricas em tetraedro",
                                  "subSteps": [
                                    "Defina as coordenadas baricêntricas L1, L2, L3, L4 para os quatro vértices de um tetraedro.",
                                    "Explique a propriedade fundamental: L1 + L2 + L3 + L4 = 1 em qualquer ponto interno.",
                                    "Calcule as coordenadas baricêntricas para um ponto genérico usando volumes de sub-tetraedros.",
                                    "Verifique que Li = 1 no vértice i e Li = 0 nos outros vértices.",
                                    "Discuta a interpretação geométrica e vantagens em elementos finitos."
                                  ],
                                  "verification": "Escreva as equações das coordenadas baricêntricas e demonstre a soma unitária com um exemplo numérico.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Diagrama de tetraedro",
                                    "Referência: Livro de Elementos Finitos (ex: Zienkiewicz)"
                                  ],
                                  "tips": [
                                    "Visualize o tetraedro com vértices em (0,0,0), (1,0,0), (0,1,0), (0,0,1) para simplicidade.",
                                    "Use a fórmula de volume V_i / V_total para Li."
                                  ],
                                  "learningObjective": "Compreender as coordenadas baricêntricas como base para funções de forma em simplices 3D.",
                                  "commonMistakes": [
                                    "Confundir com coordenadas cartesianas",
                                    "Esquecer que são não-negativas internamente",
                                    "Ignorar a dependência linear entre as Li"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar funções de forma quadráticas em 1D para analogia",
                                  "subSteps": [
                                    "Lembre as funções de Lagrange lineares em 1D: N1 = ξ, N2 = 1 - ξ.",
                                    "Para ordem quadrática em 1D (3 nós), derive funções para nós endpoints: N1 = ξ(2ξ - 1).",
                                    "Verifique propriedades: N1(0)=1, N1(1)=0, N1(0.5)= -0.125 (mas soma com midside =1).",
                                    "Generalize: para nós vertex, forma bubbled: L(2L - 1).",
                                    "Compare com função nodal padrão de Lagrange."
                                  ],
                                  "verification": "Escreva N1(ξ) = ξ(2ξ - 1) e verifique valores nos nós 1,2 e midside.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráfico de funções 1D",
                                    "Software de plotagem como MATLAB ou Python (opcional)",
                                    "Papel para derivação"
                                  ],
                                  "tips": [
                                    "Comece resolvendo o sistema para interpolação em 3 pontos.",
                                    "Note que funções vertex vão abaixo de zero fora do elemento."
                                  ],
                                  "learningObjective": "Estabelecer a forma base das funções de forma para vértices em elementos de ordem superior via analogia 1D.",
                                  "commonMistakes": [
                                    "Usar forma linear em vez de quadrática",
                                    "Esquecer o fator (2ξ - 1)",
                                    "Não verificar interpolar 1 no nó próprio"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Generalizar para simplices 2D e 3D (triângulo e tetraedro)",
                                  "subSteps": [
                                    "Em triângulo (2D), funções lineares: Ni = Li; quadráticas vertex: Ni = Li(2Li - 1).",
                                    "Verifique partição da unidade: soma Ni + midsides = 1.",
                                    "Estenda para tetraedro 3D: cada função vertex é independente nas suas Li, Ni = Li(2Li - 1).",
                                    "Explique por que isso funciona em baricêntricas: propriedades afins preservadas.",
                                    "Discuta hierarquia de funções de forma em elementos finitos."
                                  ],
                                  "verification": "Demonstre que para triângulo, N1 + N2 + N3 = 3L1L2 + 3L1L3 + ... mas soma com mids =1; generalize para 3D.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagramas de triângulo e tetraedro",
                                    "Tabela de funções de forma padrão",
                                    "Calculadora simbólica (ex: SymPy)"
                                  ],
                                  "tips": [
                                    "Use simetria: todas funções vertex têm a mesma forma, trocando Li.",
                                    "Teste em baricentro: Li=1/4, Ni=1/4*(1/2 -1)= -1/8, soma 4*(-1/8)=-1/2 + mids=1."
                                  ],
                                  "learningObjective": "Generalizar a derivação de funções de forma quadráticas para nós vertex em dimensões superiores usando coordenadas baricêntricas.",
                                  "commonMistakes": [
                                    "Assumir produto tensorial como em hexaedros",
                                    "Ignorar que em simplices é função univariada em Li",
                                    "Confundir vertex com midside"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar explicitamente as 4 funções para tetraedro e verificar",
                                  "subSteps": [
                                    "Escreva N1 = L1 (2 L1 - 1), N2 = L2 (2 L2 - 1), etc. para i=1 a 4.",
                                    "Verifique Ni=1 quando Li=1 (outros Lj=0): 1*(2-1)=1.",
                                    "Verifique Ni=0 quando Li=0: 0*(0-1)=0.",
                                    "Calcule soma dos 4 Ni: ∑ Li(2Li -1) = 2∑Li² - ∑Li = 2∑Li² -1.",
                                    "Note que soma completa inclui midsides para =1, mas foque em vertex."
                                  ],
                                  "verification": "Liste as 4 funções e avalie em vértices e baricentro.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de cálculos",
                                    "Exemplo numérico com Li específicas"
                                  ],
                                  "tips": [
                                    "Expanda ∑ Li(2Li -1) = 2∑Li² -1; recorde que midsides compensam para unidade.",
                                    "Use substituição Li para testes rápidos."
                                  ],
                                  "learningObjective": "Obter as expressões explícitas das funções de forma quadráticas para os 4 nós vertex.",
                                  "commonMistakes": [
                                    "Escrever forma linear Ni=Li",
                                    "Erro no fator: usar (2Li +1)",
                                    "Não testar nos nós"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar partição da unidade e propriedades finais",
                                  "subSteps": [
                                    "Discuta soma das funções vertex + midsides =1 em todo domínio.",
                                    "Para apenas vertex: mostre soma Ni_vertex = 2∑Li² -1 ≠1 geralmente.",
                                    "Verifique consistência afim e continuidade C0.",
                                    "Compare com implementações numéricas ou tabelas padrão.",
                                    "Resuma vantagens para precisão em MEF quadrático."
                                  ],
                                  "verification": "Prove ou numéricamente confirme soma unitária completa e propriedades nodais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela de funções de forma tetraedro quadrático",
                                    "Software FEA viewer (opcional)"
                                  ],
                                  "tips": [
                                    "Foquem em propriedades nodais primeiro, depois partição.",
                                    "Use ponto gauss para teste numérico."
                                  ],
                                  "learningObjective": "Confirmar que as funções derivadas satisfazem as propriedades essenciais de partição da unidade e interpolação nodal.",
                                  "commonMistakes": [
                                    "Achar que soma apenas vertex=1",
                                    "Ignorar midsides no contexto quadrático",
                                    "Não verificar valores negativos permitidos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um tetraedro com vértices A(0,0,0), B(1,0,0), C(0,1,0), D(0,0,1), em ponto P com coordenadas baricêntricas L=(0.4, 0.3, 0.2, 0.1), calcule N1 = 0.4*(0.8 - 1) = 0.4*(-0.2) = -0.08; similarmente N2=-0.045, N3=-0.02, N4=-0.005; soma vertex ≈ -0.15 (midsides somam +1.15 para total 1). Verifique em vértice A: L=(1,0,0,0), N1=1*(2-1)=1, outros=0.",
                              "finalVerifications": [
                                "N1 = L1(2L1 - 1), e similar para N2, N3, N4 corretamente derivadas.",
                                "Ni = 1 no vértice i e Ni = 0 nos outros três vértices.",
                                "Soma das quatro funções vertex calculada como 2∑Li² - 1.",
                                "Propriedades nodais verificadas em pelo menos três pontos internos.",
                                "Explicação da partição da unidade considerando midsides.",
                                "Consistência com literatura padrão de elementos finitos."
                              ],
                              "assessmentCriteria": [
                                "Precisão das fórmulas derivadas (100% match com N_i = L_i (2L_i - 1)).",
                                "Correta verificação de propriedades nodais em vértices e pontos internos.",
                                "Demonstração da soma das funções e discussão de partição unitária.",
                                "Uso correto de coordenadas baricêntricas em exemplos numéricos.",
                                "Clareza na generalização de 1D para 3D.",
                                "Identificação de erros comuns e dicas práticas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Polinômios de Lagrange e interpolação em simplices.",
                                "Programação: Implementação de funções de forma em códigos FEA (ex: FEniCS, deal.II).",
                                "Física: Aplicação em equações diferenciais parciais para mecânica dos sólidos.",
                                "Geometria Computacional: Malhamento tetraédrico e coordenadas baricêntricas.",
                                "Engenharia de Software: Verificação numérica e testes unitários em simulações."
                              ],
                              "realWorldApplication": "Essas funções são essenciais em softwares de análise por elementos finitos (ex: ANSYS, Abaqus) para modelar tensões e deformações em peças mecânicas complexas com malhas tetraédricas quadráticas, melhorando precisão em simulações de fadiga, crash-test automotivo e otimização topológica de estruturas aeroespaciais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.2",
                            "name": "Derivar funções de forma para nós de aresta",
                            "description": "Calcular funções de forma para os 6 nós de mid-aresta, como N5 = 4ξ(1-ξ)η(1-η), e avaliar em pontos específicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar coordenadas baricêntricas e funções de forma lineares para tetraedro",
                                  "subSteps": [
                                    "Defina as coordenadas baricêntricas λ1, λ2, λ3, λ4 onde ∑λi = 1 e λi ≥ 0.",
                                    "Liste as funções de forma lineares para os 4 nós vértices: Ni = λi.",
                                    "Verifique que Ni = 1 no vértice i e 0 nos outros vértices.",
                                    "Desenhe o tetraedro referencial e marque as arestas e mid-nós.",
                                    "Calcule exemplos numéricos em vértices para confirmar."
                                  ],
                                  "verification": "Confirme que todas funções lineares somam 1 em qualquer ponto interno e são unitárias nos vértices respectivos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel, lápis, tabela de coordenadas baricêntricas, software como MATLAB ou Python para plotagem opcional.",
                                  "tips": "Use um tetraedro unitário com vértices em (0,0,0), (1,0,0), (0,1,0), (0,0,1) para visualização.",
                                  "learningObjective": "Compreender a base linear para construir funções quadráticas nos nós mid-aresta.",
                                  "commonMistakes": "Esquecer que ∑λi = 1 ou confundir com coordenadas cartesianas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a função de forma para um nó mid-aresta específico",
                                  "subSteps": [
                                    "Escolha a aresta entre vértices 1 e 2 (nó 5 no mid-point).",
                                    "Proponha a forma quadrática N5 = 4 λ1 λ2, baseada na interpolação Lagrangeana.",
                                    "Verifique N5 = 1 no mid-point (λ1=λ2=0.5, outros=0).",
                                    "Confirme N5 = 0 nos 4 vértices.",
                                    "Teste em um ponto interno da aresta, ex: λ1=0.6, λ2=0.4."
                                  ],
                                  "verification": "N5 deve ser exatamente 1 no mid-nó da aresta escolhida e 0 em todos os vértices.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora, planilha Excel ou SymPy para simplificação simbólica.",
                                  "tips": "O fator 4 vem da normalização: máximo de λ1λ2=0.25 em λ1=λ2=0.5, então 4*0.25=1.",
                                  "learningObjective": "Derivar e validar a função de forma quadrática para um nó mid-aresta usando princípios Lagrangeanos.",
                                  "commonMistakes": "Usar 2λ1λ2 em vez de 4λ1λ2, levando a máximo de 0.5."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Generalizar funções de forma para todos os 6 nós mid-aresta",
                                  "subSteps": [
                                    "Liste as 6 arestas: (1-2), (1-3), (1-4), (2-3), (2-4), (3-4).",
                                    "Escreva Nj = 4 λi λk para cada par (i,k). Ex: N6=4λ1λ3, N7=4λ1λ4, etc.",
                                    "Verifique a partição da unidade: soma de todas Ni lineares + sum Nj mid = 1.",
                                    "Confirme que cada Nj = 0 nos vértices e nos mid-nós de outras arestas.",
                                    "Documente as funções em uma tabela."
                                  ],
                                  "verification": "Soma de todas 10 funções (4 lineares + 6 quadráticas) = 1 em pontos de Gauss ou mid-nós.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Tabela impressa de nós, software FEM como FEniCS para validação numérica opcional.",
                                  "tips": "Numere consistentemente os nós mid-aresta conforme convenção padrão (ex: 5 a 10).",
                                  "learningObjective": "Estender a derivação para todos nós mid-aresta, garantindo consistência.",
                                  "commonMistakes": "Duplicar pares de arestas ou esquecer o fator 4 em alguma função."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar funções em pontos específicos e verificar propriedades",
                                  "subSteps": [
                                    "Escolha pontos de integração Gauss-Legendre para tetraedro quadrático.",
                                    "Calcule todas Nj em um ponto Gauss, ex: λ=(0.25,0.25,0.25,0.25).",
                                    "Verifique continuidade C0 e derivadas zero nos nós para consistência.",
                                    "Compare com funções conhecidas em literatura (ex: Zienkiewicz).",
                                    "Plote as funções ao longo de uma aresta usando software."
                                  ],
                                  "verification": "Cada função é 1 apenas no seu nó, 0 nos outros 9 nós, e soma total =1.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com NumPy/Matplotlib para avaliação e plotagem.",
                                  "tips": "Use coordenadas exatas para pontos mid: (0.5,0.5,0,0) para aresta 1-2.",
                                  "learningObjective": "Aplicar e validar as funções derivadas em cenários computacionais reais.",
                                  "commonMistakes": "Erro numérico em avaliações decimais; use frações exatas."
                                }
                              ],
                              "practicalExample": "Para o nó mid-aresta 5 (entre vértices 1 e 2) em tetraedro com vértices A(0,0,0), B(1,0,0), C(0,1,0), D(0,0,1): N5 = 4 λA λB. No mid-point M(0.5,0,0,0.5? wait, baricêntrico λA=0.5, λB=0.5, λC=0, λD=0: N5=4*0.5*0.5=1. Avalie em ponto Gauss interno: λ=(1/4 cada), N5=4*(1/4)*(1/4)=1/4.",
                              "finalVerifications": [
                                "Cada função mid-aresta é 1 no seu mid-nó e 0 nos outros 9 nós.",
                                "Soma de todas 10 funções de forma = 1 em qualquer ponto do elemento.",
                                "Funções são simétricas e contínuas ao longo das arestas.",
                                "Derivadas são consistentes com ordem quadrática.",
                                "Valores em pontos de Gauss somam corretamente para integração numérica.",
                                "Nenhuma função excede 1 ou vai negativa no domínio."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação do fator 4λiλj (100% correto).",
                                "Correta identificação e listagem de todas 6 funções.",
                                "Validações numéricas em pelo menos 3 pontos por função.",
                                "Explicação clara da normalização e propriedades Lagrangeanas.",
                                "Uso correto de coordenadas baricêntricas sem erros de soma.",
                                "Visualizações ou plots confirmando o comportamento."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Polinômios de Lagrange e interpolação multivariável.",
                                "Programação: Implementação em código FEM (Python/FEAP).",
                                "Física: Aplicação em mecânica dos sólidos e tensão deformação.",
                                "Geometria Computacional: Mapeamento isoparamétrico 3D."
                              ],
                              "realWorldApplication": "Em análises de elementos finitos para simulação de estruturas mecânicas complexas, como turbinas ou chassis de veículos, onde elementos tetraédricos quadráticos capturam gradientes precisos de tensão em malhas não-struturadas, reduzindo erros em 20-50% comparado a lineares."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.3",
                            "name": "Calcular derivadas das funções de forma",
                            "description": "Determinar as derivadas parciais ∂N/∂ξ, ∂N/∂η, ∂N/∂ζ para formação da matriz [B] na formulação do elemento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e listar as funções de forma quadráticas do elemento tetraédrico",
                                  "subSteps": [
                                    "Identifique os 10 nós do tetraedro quadrático (4 vértices, 6 nós de aresta).",
                                    "Escreva as funções de forma N_i(ξ, η, ζ) para cada nó, usando coordenadas naturais (ξ, η, ζ ∈ [0,1], ξ+η+ζ ≤1).",
                                    "Exemplo para nó vértice 1: N1 = ξ²(2ξ - 3) + termos de correção; consulte tabela padrão.",
                                    "Verifique que Σ N_i = 1 em todo domínio.",
                                    "Anote funções para nós de aresta, ex: N5 (meio aresta 1-2) = 4ξ(1-ξ)η(1-η-ζ)."
                                  ],
                                  "verification": "Confirme que todas funções somam 1 em pontos de teste (ex: centro ξ=η=ζ=1/4) e N_i=1 no nó i, 0 nos outros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, tabela de funções de forma de livro de Elementos Finitos (ex: Zienkiewicz), software SymPy ou Mathematica para simbólico.",
                                  "tips": "Use notação consistente: ξ para aresta 1-4, η para 2-4, ζ para 3-4.",
                                  "learningObjective": "Dominar a expressão exata das funções de forma quadráticas em coordenadas naturais.",
                                  "commonMistakes": "Confundir ordem das coordenadas ou usar funções lineares em vez de quadráticas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular derivadas parciais ∂N_i/∂ξ para todas funções de forma",
                                  "subSteps": [
                                    "Para cada N_i, aplique regra da derivada parcial tratando η e ζ como constantes.",
                                    "Exemplo para N1 (vértice): ∂N1/∂ξ = derivada polinomial em ξ, η, ζ.",
                                    "Compute explicitamente para vértices e nós de aresta, simplificando expressões.",
                                    "Registre em tabela: coluna para cada N_i, expressão ∂N_i/∂ξ.",
                                    "Teste em ponto específico, ex: Gauss point (ξ=0.25, η=0.25, ζ=0.25)."
                                  ],
                                  "verification": "Verifique que ∂N_i/∂ξ = 0 no nó i se i não depende primariamente de ξ; soma das derivadas deve satisfazer propriedades geométricas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora simbólica (SymPy/MATLAB), folha de funções de Step 1.",
                                  "tips": "Fatore expressões comuns como (1-ξ-η-ζ) para simplificar.",
                                  "learningObjective": "Aplicar derivação parcial corretamente em multivariáveis polinomiais.",
                                  "commonMistakes": "Esquecer de derivar termos cruzados ou sinal errado em binômios."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular derivadas parciais ∂N_i/∂η e ∂N_i/∂ζ",
                                  "subSteps": [
                                    "Repita processo de Step 2 para ∂/∂η, fixando ξ e ζ.",
                                    "Para ∂/∂ζ, note simetria com η em alguns casos.",
                                    "Crie tabelas separadas para cada derivada parcial.",
                                    "Compare simetrias: derivadas devem refletir geometria tetraédrica.",
                                    "Avalie numericamente em 1-2 pontos de integração Gauss-Legendre 3D."
                                  ],
                                  "verification": "Confirme ortogonalidade aproximada ou propriedades LAPLACE em pontos internos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Mesmos do Step 2, software para plotar derivadas (ex: MATLAB meshgrid).",
                                  "tips": "Use substituição simbólica para evitar erros aritméticos manuais.",
                                  "learningObjective": "Estender derivação para todas direções coordenadas naturais.",
                                  "commonMistakes": "Tratar variáveis como independentes incorretamente devido a constraint ξ+η+ζ≤1."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formar a matriz [B] e realizar verificações iniciais",
                                  "subSteps": [
                                    "Monte [B] = [∂N/∂ξ, ∂N/∂η, ∂N/∂ζ] em formato 3x(n_dof), onde n_dof=30 para deslocamentos 3D.",
                                    "Para ponto de Gauss específico, substitua valores ξ,η,ζ nas derivadas.",
                                    "Verifique rank e propriedades: [B] deve capturar deformações volumétricas.",
                                    "Transforme para coordenadas globais usando Jacobiana J (∂(x,y,z)/∂(ξ,η,ζ)).",
                                    "Teste rigidez: integre [B]^T D [B] det(J) para elemento simples."
                                  ],
                                  "verification": " [B] deve ser consistente: derivadas unitárias ao longo direções nodais.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software FEM (ex: código MATLAB custom ou FEniCS), Jacobiana do elemento.",
                                  "tips": "Implemente em script para automação; debugue com elementos lineares conhecidos.",
                                  "learningObjective": "Integrar derivadas em matriz de deformação padrão EF.",
                                  "commonMistakes": "Erro na ordenação de nós ou transposição incorreta de [B]."
                                }
                              ],
                              "practicalExample": "Para tetraedro 10-nós, no ponto Gauss (ξ=1/4, η=1/4, ζ=1/4), compute ∂N1/∂ξ = 2ξ-1 + termos = valor numérico ~ -0.5; monte [B] 3x30 com todas derivadas e verifique com software que ε = [B] u reproduz deformação conhecida.",
                              "finalVerifications": [
                                "Soma das derivadas parciais ∂N_i/∂ξ + ∂N_i/∂η + ∂N_i/∂ζ = 0 para todo i (rigidez volumétrica).",
                                "No nó j, ∂N_i/∂ξ = 0 para i≠j em direções apropriadas.",
                                "Valores numéricos em pontos Gauss coincidem com implementação numérica (erro <1e-6).",
                                "Matriz [B] gera deformações físicas realistas em teste de tração uniaxial.",
                                "Consistência com elemento linear degenerado.",
                                "Integração numérica de rigidez converge para malha refinada."
                              ],
                              "assessmentCriteria": [
                                "Precisão das expressões derivadas (simbólica e numérica).",
                                "Completude: todas 10 funções cobertas para 3 derivadas.",
                                "Correção na montagem de [B] (dimensões e ordenação).",
                                "Eficiência: simplificações aplicadas corretamente.",
                                "Validações realizadas em múltiplos pontos.",
                                "Clareza na documentação de cálculos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo multivariável e polinômios de Lagrange.",
                                "Programação: Implementação simbólica/numérica em Python/MATLAB.",
                                "Física: Teoria da elasticidade e deformações em sólidos.",
                                "Computação Científica: Integração numérica Gauss e mapeamento isoparamétrico."
                              ],
                              "realWorldApplication": "Em simulações FEM de software como ANSYS ou Abaqus para análise de tensões em peças automotivas complexas (ex: cabeçote de motor), onde elementos tetraédricos quadráticos capturam gradientes precisos de deformação em geometrias irregulares, otimizando design e evitando falhas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.4",
                            "name": "Verificar propriedades das funções",
                            "description": "Confirmar que as funções de forma satisfazem Ni(ponto j) = δij e ∑Ni = 1 em todo o domínio do elemento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os nós e funções de forma do elemento tetraédrico quadrático",
                                  "subSteps": [
                                    "Liste os 10 nós do elemento tetraédrico quadrático: 4 vértices e 6 nós médios das arestas.",
                                    "Defina as coordenadas naturais (L1, L2, L3, L4) onde ∑Li = 1 e Li ≥ 0.",
                                    "Escreva as expressões das 10 funções de forma Ni em termos de coordenadas naturais (Ni para vértices: Li(2Li - 1), para mids: 4Li(1-Li)Lj).",
                                    "Verifique a consistência das funções com referências bibliográficas padrão (ex: Zienkiewicz).",
                                    "Crie uma tabela resumindo nós, coordenadas e Ni associadas."
                                  ],
                                  "verification": "Tabela completa com 10 nós e funções Ni corretas, sem erros tipográficos nas fórmulas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Elementos Finitos (Zienkiewicz ou Bathe), software MATLAB ou Python para plotagem opcional.",
                                  "tips": "Use coordenadas baricêntricas para simplificar; memorize padrões para vértices e mids.",
                                  "learningObjective": "Compreender a geometria e parametrização do elemento tetraédrico quadrático.",
                                  "commonMistakes": "Confundir nós mids com faces; fórmulas erradas para funções quadráticas (ex: usar lineares)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar propriedade de Kronecker: Ni(ponto j) = δij nos nós",
                                  "subSteps": [
                                    "Para cada nó j=1 a 10, compute Ni(pj) para todos i=1 a 10.",
                                    "Confirme Ni(pj) = 1 se i=j, e 0 caso contrário.",
                                    "Use substituição direta nas fórmulas de Ni nas coordenadas do nó j.",
                                    "Registre resultados em matriz 10x10 onde diagonal=1 e off-diagonal=0.",
                                    "Analise numericamente com precisão de 1e-12 para flutuações."
                                  ],
                                  "verification": "Matriz identidade confirmada com todos valores exatos ou dentro de tolerância numérica.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Planilha Excel, MATLAB ou Python (SymPy para simbólico).",
                                  "tips": "Comece pelos vértices (mais simples), depois mids; use simbólico para exatidão.",
                                  "learningObjective": "Validar a propriedade de interpolação nodal das funções de forma.",
                                  "commonMistakes": "Erro nas coordenadas mids (ex: média errada); arredondamento prematuro sem simbólico."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar partição da unidade: ∑Ni = 1 em pontos representativos",
                                  "subSteps": [
                                    "Selecione pontos: 10 nós, centros de faces (4), centro do elemento, pontos Gauss (ex: 5 pontos).",
                                    "Para cada ponto, compute soma ∑_{i=1}^{10} Ni(ponto).",
                                    "Use coordenadas naturais para avaliação.",
                                    "Compare com 1.0 em todos pontos, tolerância 1e-12.",
                                    "Plote ∑Ni em malha para visualização qualitativa."
                                  ],
                                  "verification": "Soma =1 em todos pontos testados, com tabela de resultados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software FEA (ex: FreeFEM, Gmsh) ou Python com NumPy/MeshPy.",
                                  "tips": "Pontos Gauss garantem representatividade; plote para detectar anomalias.",
                                  "learningObjective": "Garantir consistência afim das funções de forma em todo domínio.",
                                  "commonMistakes": "Poucos pontos testados; ignorar flutuações numéricas em mids."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Confirmar propriedades em todo domínio e documentar",
                                  "subSteps": [
                                    "Demonstre analiticamente que ∑Ni =1 por construção polinomial (grau ≤2).",
                                    "Teste numericamente em 50+ pontos aleatórios no tetraedro.",
                                    "Verifique derivadas se aplicável (consistência).",
                                    "Compile relatório com tabelas, plots e conclusões.",
                                    "Discuta implicações para integração numérica em FEA."
                                  ],
                                  "verification": "Relatório completo com provas/numéricos confirmando propriedades globais.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Python (SciPy para integração), relatório LaTeX ou Word.",
                                  "tips": "Use teorema de partição para prova; monte Carlo para cobertura.",
                                  "learningObjective": "Integrar verificações para validação completa das funções.",
                                  "commonMistakes": "Assumir sem prova analítica; testes insuficientes em bordas."
                                }
                              ],
                              "practicalExample": "Considere tetraedro com vértices (0,0,0), (1,0,0), (0,1,0), (0,0,1). Para nó médio aresta 1-2 em (0.5,0,0), N5(ponto5)=1, outras Ni=0; soma Ni=1 no centro (0.25,0.25,0.25,0.25).",
                              "finalVerifications": [
                                "Matriz de Kronecker confirmada (δij exata).",
                                "Soma Ni=1 em todos 10 nós e 5+ pontos internos.",
                                "Soma Ni=1 em pontos Gauss padrão para quadrático.",
                                "Sem discrepâncias numéricas >1e-12.",
                                "Plot de ∑Ni mostra plano unitário no domínio.",
                                "Funções consistentes com literatura (ex: Cook's membrane test)."
                              ],
                              "assessmentCriteria": [
                                "Precisão das funções Ni (100% corretas).",
                                "Cobertura de pontos de verificação (mín. 20 pontos).",
                                "Uso de métodos analíticos e numéricos combinados.",
                                "Clareza na documentação e tabelas.",
                                "Identificação e correção de erros potenciais.",
                                "Tempo respeitado com eficiência."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (propriedades matriciais), Polinômios multivariados.",
                                "Programação: Implementação numérica em Python/MATLAB para automação.",
                                "Física: Consistência em mecânica dos sólidos (campos contínuos).",
                                "Estatística: Análise de erro numérico e tolerâncias."
                              ],
                              "realWorldApplication": "Em software FEA como ANSYS ou Abaqus, validar funções de forma garante precisão em simulações de tensão em estruturas aeroespaciais, evitando erros de interpolação que levam a falhas preditivas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.3",
                        "name": "Formulação, Integração e Aplicações",
                        "description": "Montagem das matrizes de rigidez, massa e carga usando integração numérica de Gauss no tetraedro, com ênfase em aplicações para análise de tensão em malhas adaptativas e refinadas.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.3.1",
                            "name": "Implementar integração numérica",
                            "description": "Selecionar e aplicar pontos de Gauss de 5 ou 6 pontos para tetraedro, calculando pesos e coordenadas para integrais de volume no elemento de 10 nós.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar teoria de integração numérica para elementos tetraédricos",
                                  "subSteps": [
                                    "Estudar as bases da integração numérica em elementos finitos 3D, focando em quadratura de Gauss-Lobatto para tetraedros.",
                                    "Compreender a necessidade de 5 ou 6 pontos de Gauss para precisão em elementos de 10 nós (grau polinomial 3).",
                                    "Analisar a transformação de coordenadas do elemento de referência para o elemento real via Jacobiano.",
                                    "Derivar a fórmula geral da integral de volume: ∫ f dV ≈ Σ w_i * f(ξ_i) * |det J(ξ_i)|.",
                                    "Identificar regras de integração exatas para polinômios de grau até 4 em tetraedros."
                                  ],
                                  "verification": "Resumir em um diagrama ou nota os requisitos de precisão para elemento de 10 nós e listar 3 referências chave.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'The Finite Element Method' de Zienkiewicz",
                                    "Artigos sobre quadratura tetraédrica (ex: Felippa)",
                                    "Notebook Jupyter para anotações"
                                  ],
                                  "tips": "Use diagramas do tetraedro de referência para visualizar pontos de Gauss.",
                                  "learningObjective": "Compreender os fundamentos teóricos da integração numérica em tetraedros para elementos de ordem superior.",
                                  "commonMistakes": "Confundir pontos de Gauss para triângulos 2D com tetraedros 3D; ignorar o grau de precisão necessário."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e obter coordenadas/pesos de pontos de Gauss de 5 ou 6 pontos",
                                  "subSteps": [
                                    "Consultar tabelas padrão para 5 pontos de Gauss em tetraedro (ex: esquema de Grundmann-Möller ou Dunavant adaptado).",
                                    "Para 6 pontos, obter coordenadas baricêntricas e pesos (ex: ξ1=(0.071,0.071,0.071,0.788), w1=0.1125).",
                                    "Implementar uma função em Python/MATLAB para retornar arrays de coordenadas [ξ,η,ζ,τ] e pesos [w].",
                                    "Verificar simetria e soma de pesos ≈1 para integral de volume unitário.",
                                    "Testar integral de função constante (deve dar volume=1 no domínio de referência)."
                                  ],
                                  "verification": "Executar código que integra f=1 e obtém resultado próximo a 1/V_tet_ref (1/6 para tetraedro padrão).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Tabelas de pontos Gauss tetraédricos (PDFs online)",
                                    "Python com NumPy/SciPy ou MATLAB",
                                    "Código template para FEM básico"
                                  ],
                                  "tips": "Salve as tabelas em um módulo reutilizável para evitar reescrita.",
                                  "learningObjective": "Selecionar esquemas de Gauss apropriados e codificar acesso a coordenadas/pesos.",
                                  "commonMistakes": "Usar pesos errados de fontes não confiáveis; esquecer normalização baricêntrica (ξ+η+ζ+τ=1)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar cálculo da integral de volume no elemento de 10 nós",
                                  "subSteps": [
                                    "Definir funções de forma N_i(ξ) para tetraedro de 10 nós (4 vértices + 6 arestas médios).",
                                    "Calcular Jacobiana J em cada ponto Gauss: derivadas das funções de forma mapeadas para nós reais.",
                                    "Para cada ponto i: avaliar f(ξ_i) * w_i * det(J(ξ_i)) e somar.",
                                    "Integrar uma função teste como rigidez ou massa no elemento.",
                                    "Otimizar para vetorização (evitar loops em Python)."
                                  ],
                                  "verification": "Comparar integral numérica de polinômio conhecido (ex: x^2 + y^2 + z^2) com solução analítica (<1% erro).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código base de FEM para tetraedro 10-nós",
                                    "Software: Python (FEniCS/NumPy) ou MATLAB",
                                    "Documentação de funções de forma"
                                  ],
                                  "tips": "Use det(J) com sinal positivo; teste com tetraedro unitário primeiro.",
                                  "learningObjective": "Codificar a avaliação da integral numérica considerando mapeamento isoparamétrico.",
                                  "commonMistakes": "Erro no cálculo de det(J) (singularidades); funções de forma incorretas para nós de aresta."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e otimizar a implementação",
                                  "subSteps": [
                                    "Testar com malha simples de 1 elemento deformado e comparar com analítico.",
                                    "Analisar convergência variando número de pontos Gauss (5 vs 6).",
                                    "Profilear tempo de execução e otimizar (ex: pré-computar J se possível).",
                                    "Documentar código com comentários e exemplos de uso.",
                                    "Integrar em solver FEM básico para uma carga distribuída."
                                  ],
                                  "verification": "Erro de integração <0.1% para funções polinomiais de grau 3; tempo <1ms por elemento.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Malha teste .msh (Gmsh)",
                                    "Solver FEM simples",
                                    "Ferramentas de profiling (timeit em Python)"
                                  ],
                                  "tips": "Use asserts para checks automáticos de precisão.",
                                  "learningObjective": "Garantir robustez e eficiência da implementação numérica.",
                                  "commonMistakes": "Não testar elementos distorcidos; ignorar overhead computacional em malhas grandes."
                                }
                              ],
                              "practicalExample": "Implemente a integral de uma carga volumétrica f(x,y,z)=x*y*z em um tetraedro de 10 nós com vértices (0,0,0),(1,0,0),(0,1,0),(0,0,1) e nós medios nas arestas. Use 5 pontos Gauss, calcule a força nodal resultante e valide contra integral analítica (1/120).",
                              "finalVerifications": [
                                "Código integra f=1 corretamente no domínio de referência (resultado=1).",
                                "Det(J) positivo e consistente em todos pontos Gauss.",
                                "Erro <0.5% em teste polinomial de grau 3.",
                                "Função modular e testável independentemente.",
                                "Documentação inclui tabelas de Gauss usadas.",
                                "Convergência confirmada com 6 pontos vs 5."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erro <1% em testes padrão.",
                                "Correção teórica: uso apropriado de 5/6 pontos para grau 3.",
                                "Eficiência: vetorizado, sem loops desnecessários.",
                                "Robustez: funciona em elementos distorcidos sem singularidades.",
                                "Clareza: código comentado e funções bem nomeadas.",
                                "Validação: testes unitários incluídos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Quadratura de Gauss e análise de erro.",
                                "Programação Computacional: Vetorização e otimização em Python/MATLAB.",
                                "Álgebra Linear: Cálculo de Jacobianas e determinantes.",
                                "Física/Engenharia: Aplicação em equações diferenciais parciais (EDP)."
                              ],
                              "realWorldApplication": "Em simulações FEM para análise estrutural de peças automotivas ou aeroespaciais, onde tetraedros de 10 nós modelam geometrias complexas com alta precisão, calculando matrizes de rigidez/massa para predizer deformações sob cargas reais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.3.2",
                            "name": "Montar matriz de rigidez local",
                            "description": "Calcular a matriz [k] = ∫ [B]^T [D] [B] dV para o elemento tetraédrico, considerando equações constitutivas lineares elásticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir Geometria e Funções de Interpolação do Elemento Tetraédrico",
                                  "subSteps": [
                                    "Identifique as coordenadas dos nós do tetraédrico de ordem superior (ex: 10 nós para ordem 2).",
                                    "Derive as funções de shape N_i em coordenadas baricêntricas (L1, L2, L3, L4).",
                                    "Calcule as derivadas das funções de shape em relação às coordenadas locais (ξ, η, ζ).",
                                    "Construa o vetor de posições nodais X para mapear do espaço local para global.",
                                    "Verifique a normalização das funções de shape (∑ N_i = 1)."
                                  ],
                                  "verification": "Confirme que as funções de shape somam 1 em pontos internos e interpolam corretamente nos nós.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Elementos Finitos (ex: Zienkiewicz), software MATLAB ou Python com NumPy/SciPy",
                                    "Folha de coordenadas baricêntricas para tetraédricos"
                                  ],
                                  "tips": "Use coordenadas baricêntricas para simplicidade em tetraédricos; memorize fórmulas para ordens baixa e alta.",
                                  "learningObjective": "Compreender e implementar funções de interpolação para elementos tetraédricos de ordem superior.",
                                  "commonMistakes": [
                                    "Confundir derivadas parciais com totais",
                                    "Esquecer mapeamento isoparamétrico para ordem superior"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Matriz de Derivadas [B] e Propriedades Constitutivas [D]",
                                  "subSteps": [
                                    "Calcule o Jacobiano J = ∂(x,y,z)/∂(ξ,η,ζ) usando funções de shape.",
                                    "Obtenha as derivadas globais das funções de shape: ∂N_i/∂x = [J^{-1}] ∂N_i/∂ξ_local.",
                                    "Monte a matriz [B] para cada grau de liberdade (ε_x, ε_y, ε_z, γ_xy, γ_xz, γ_yz).",
                                    "Defina a matriz [D] para material isotrópico linear elástico: D = E/(1+ν)/(1-2ν) * matriz de Lamé.",
                                    "Verifique simetria e dimensionalidade de [B] (6x ndof, onde ndof=3*nós)."
                                  ],
                                  "verification": "Teste [B] em um ponto Gauss: derivadas devem coincidir com geometria conhecida.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Tabela de constantes elásticas (E, ν)",
                                    "Código Python para Jacobiano simbólico (SymPy)",
                                    "Exemplo de [D] para aço"
                                  ],
                                  "tips": "Inverta J analiticamente para tetraédricos lineares; use decomposição QR para ordem superior.",
                                  "learningObjective": "Dominar a formação de [B] e [D] para análise elástica 3D.",
                                  "commonMistakes": [
                                    "Erro na inversão do Jacobiano",
                                    "Índices errados em [B] para shear strains"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Esquema de Integração Numérica",
                                  "subSteps": [
                                    "Escolha pontos e pesos de Gauss-Lobatto para tetraédricos (ex: 5 pontos para precisão ordem 2).",
                                    "Liste coordenadas locais e pesos w_i para cada ponto de integração.",
                                    "Calcule o determinante |J| em cada ponto Gauss.",
                                    "Prepare o integrando [B]^T [D] [B] * |J| para soma ponderada.",
                                    "Valide o esquema integrando volume unitário (deve dar 1/6 para tetra linear)."
                                  ],
                                  "verification": "Integre função teste 1 dV = volume do elemento.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Tabelas de quadratura tetraédrica (online ou livro Bathe)",
                                    "Script MATLAB para pontos Gauss"
                                  ],
                                  "tips": "Use 4-14 pontos dependendo da ordem; evite superintegração desnecessária.",
                                  "learningObjective": "Aplicar integração numérica exata/reduzida em volumes 3D.",
                                  "commonMistakes": [
                                    "Pontos Gauss errados para não-simples",
                                    "Esquecer multiplicar por w_i * |J|"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Realizar Integração e Montar Matriz de Rigidez [k]",
                                  "subSteps": [
                                    "Inicialize [k] como matriz zero (ndof x ndof).",
                                    "Para cada ponto Gauss: compute [B_g]^T [D] [B_g] * w_i * |J|, some a [k].",
                                    "Implemente em loop ou vetorizado para eficiência.",
                                    "Aplique condições de contorno locais se necessário (não para [k] local).",
                                    "Verifique propriedades: [k] simétrica positiva definida, trace([k]) > 0."
                                  ],
                                  "verification": "Compare com solução analítica para tetraédrico linear unitário.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código template em Python (FEniCS ou custom)",
                                    "Exemplo numérico validado"
                                  ],
                                  "tips": "Vetorize com NumPy para speed; debugue com elemento simples primeiro.",
                                  "learningObjective": "Executar a integração completa e validar a matriz de rigidez.",
                                  "commonMistakes": [
                                    "Acúmulo incorreto em loop",
                                    "Não zerar [k] inicial"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um tetraédrico linear com nós (0,0,0), (1,0,0), (0,1,0), (0,0,1), E=200 GPa, ν=0.3: compute [k] 12x12 usando 1 ponto Gauss no baricentro. Resultado esperado: diagonal dominante com k_ii ~ 1e10, simétrica.",
                              "finalVerifications": [
                                "Matriz [k] é simétrica (k_ij = k_ji).",
                                "Eigenvalores todos positivos (teste com np.linalg.eigvals).",
                                "Integração de volume teste = V_elemento.",
                                "Energia de deformação ∫ u^T k u > 0 para u não-nulo.",
                                "Comparação com software FEA (ex: Abaqus) < 1% erro.",
                                "Dimensionalmente consistente (unidades N/m)."
                              ],
                              "assessmentCriteria": [
                                "Precisão da matriz [B] em pontos Gauss (erro < 1e-6).",
                                "Correção da integração numérica (erro volume < 0.1%).",
                                "Simetria e positividade de [k] confirmadas.",
                                "Eficiência computacional (tempo < 1s para ordem 2).",
                                "Documentação clara dos passos e validações.",
                                "Generalização para ordem superior demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo vetorial, integração numérica multidimensional.",
                                "Programação: Implementação numérica em Python/MATLAB, otimização de loops.",
                                "Física: Mecânica dos sólidos, teoria da elasticidade linear.",
                                "Engenharia de Computação: Paralelização para malhas grandes."
                              ],
                              "realWorldApplication": "Usado em simulações FEA de componentes automotivos (chassi), aeroespaciais (asas) e biomecânicos (próteses ósseas), permitindo análise de tensões em geometrias complexas meshadas com tetraédricos para precisão em sólidos irregulares."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.3.3",
                            "name": "Aplicar em malhas refinadas",
                            "description": "Demonstrar o uso de elementos tetraédricos de 10 nós em malhas h-refinadas para melhorar convergência em problemas de sólidos 3D com singularidades.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o problema físico com singularidade em sólidos 3D",
                                  "subSteps": [
                                    "Definir geometria 3D com singularidade, como uma placa com furo ou entalhe.",
                                    "Aplicar condições de contorno e cargas relevantes (ex: tração uniaxial).",
                                    "Identificar localização da singularidade (ex: borda do furo).",
                                    "Especificar propriedades do material isotrópico linear elástico.",
                                    "Exportar geometria para software de malha."
                                  ],
                                  "verification": "Geometria e condições de contorno validadas visualmente no pré-processador.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Software CAD (SolidWorks/FreeCAD), propriedades de materiais padrão.",
                                  "tips": "Escolha singularidades clássicas para benchmark, como Kirsch's problem.",
                                  "learningObjective": "Compreender como singularidades afetam soluções analíticas e numéricas em FEM.",
                                  "commonMistakes": "Ignorar simetria para reduzir modelo, levando a tempos de computação desnecessários."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Gerar malha inicial e implementar refinamento h com elementos tetraédricos de 10 nós",
                                  "subSteps": [
                                    "Gerar malha tetraédrica uniforme inicial usando algoritmo Delaunay.",
                                    "Selecionar elemento tetraédrico de 10 nós (Q2 equivalente) no mesher.",
                                    "Implementar critério de refinamento h adaptativo baseado em erro estimado (ex: gradiente de tensão).",
                                    "Refinar localmente próximo à singularidade com 2-3 níveis de h-refinamento.",
                                    "Verificar qualidade da malha (Jacobiano > 0.4, aspect ratio < 5)."
                                  ],
                                  "verification": "Malha refinada exibe densidade maior na singularidade; relatório de qualidade gerado.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Gmsh ou Salome para meshing, script Python para automação.",
                                  "tips": "Use campos de tamanho de elemento decrescente para refinamento suave.",
                                  "learningObjective": "Dominar geração de malhas h-refinadas com elementos de alta ordem para captura de gradientes.",
                                  "commonMistakes": "Refinamento global excessivo, aumentando DOFs desnecessariamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar e executar análise FEM com elementos de 10 nós",
                                  "subSteps": [
                                    "Importar malha refinada para solver FEM.",
                                    "Definir integração numérica Gauss de ordem adequada (5 pontos para Q2).",
                                    "Aplicar formulação de deslocamento para problema elástico linear.",
                                    "Executar solução estática e pós-processar campos de tensão/deslocamento.",
                                    "Plotar curvas de convergência vs. número de elementos."
                                  ],
                                  "verification": "Solução converge monotonicamente; tensão na singularidade finite mas elevada.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Code_Aster, FEniCS ou CalculiX; Python/MATLAB para pós-processamento.",
                                  "tips": "Monitore condição da matriz de rigidez para evitar ill-conditioning em alta ordem.",
                                  "learningObjective": "Aplicar elementos de 10 nós em refinamento h para aceleração de convergência.",
                                  "commonMistakes": "Usar integração de baixa ordem, causando locking ou erros de integração."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar convergência e validar resultados",
                                  "subSteps": [
                                    "Comparar tensão na singularidade com solução de referência analítica/numérica.",
                                    "Calcular taxa de convergência (erro L2 vs. h^{-p}, p≈2 para Q2).",
                                    "Avaliar melhoria em relação a malha não-refinada.",
                                    "Documentar gráficos de convergência e mapas de tensão.",
                                    "Ajustar refinamento iterativamente se necessário."
                                  ],
                                  "verification": "Taxa de convergência próxima de 2; erro < 5% em ponto crítico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Paraview para visualização, Excel/Python para plots de convergência.",
                                  "tips": "Use norma de energia para métrica de erro robusta.",
                                  "learningObjective": "Interpretar e quantificar benefícios do h-refinamento com alta ordem em singularidades.",
                                  "commonMistakes": "Confundir convergência em tensão vs. deslocamento (tensão converge mais devagar)."
                                }
                              ],
                              "practicalExample": "Analisar tensão em uma placa infinita com furo circular sob tração uniaxial: refinar malha h ao redor do furo usando tetraédricos de 10 nós, alcançando tensão hoop de ~3σ (solução analítica Kirsch) com 50% menos DOFs que malha linear uniforme.",
                              "finalVerifications": [
                                "Malha refinada captura gradiente de tensão na singularidade sem oscilações.",
                                "Curva de convergência mostra ordem 2 em norma L2.",
                                "Resultados coincidem com benchmark dentro de 3%.",
                                "Tempo de computação reduzido vs. malha equivalente sem refinamento.",
                                "Qualidade da malha mantida (skewness < 0.9).",
                                "Nenhum erro de integração ou singularidade na matriz."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração da singularidade e refinamento local (30%).",
                                "Correta implementação de elementos de 10 nós e análise de convergência (25%).",
                                "Interpretação quantitativa de resultados vs. referência (20%).",
                                "Eficiência computacional demonstrada (15%).",
                                "Relatório claro com gráficos e conclusões (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise numérica, estimadores de erro a posteriori.",
                                "Programação: Scripts para automação de meshing e solvers FEM.",
                                "Física: Mecânica dos sólidos, teoria de singularidades em fraturas.",
                                "Computação: Paralelismo em solvers FEM para malhas grandes."
                              ],
                              "realWorldApplication": "Otimização de malhas em simulações de fadiga em turbinas eólicas ou chassis automotivos, reduzindo tempo de simulação em 40-60% enquanto mantém precisão em concentrações de tensão críticas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.3",
                    "name": "Elemento Hexaédrico de 8 Nós",
                    "description": "Geometria, funções de interpolação lineares e montagem da matriz de rigidez para sólidos 3D.",
                    "individualConcepts": [
                      {
                        "id": "34.3.1.1",
                        "name": "Geometria do Elemento Hexaédrico de 8 Nós",
                        "description": "Descrição da configuração geométrica do elemento hexaédrico com 8 nós nos vértices, incluindo o elemento mestre em coordenadas naturais e o mapeamento isoparamétrico para a geometria física.",
                        "specificSkills": [
                          {
                            "id": "34.3.1.1.1",
                            "name": "Identificar a posição dos 8 nós e coordenadas locais",
                            "description": "Localizar os 8 nós do elemento hexaédrico de 8 nós no domínio mestre (ξ, η, ζ ∈ [-1,1]) e descrever suas posições padrão: ( ±1, ±1, ±1 ).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Domínio Mestre do Elemento Hexaédrico",
                                  "subSteps": [
                                    "Revise a definição do domínio mestre para elementos finitos 3D: um cubo unitário onde ξ, η, ζ variam de -1 a 1.",
                                    "Identifique que o domínio mestre é independente da geometria física real do elemento.",
                                    "Desenhe um esboço simples de um cubo com eixos ξ, η, ζ rotulados de -1 a 1.",
                                    "Explique verbalmente ou por escrito o propósito do domínio mestre no método dos elementos finitos.",
                                    "Compare com domínios 1D ([-1,1]) e 2D (quadrilátero [-1,1]x[-1,1]) para reforçar o conceito."
                                  ],
                                  "verification": "Desenhe e rotule corretamente o cubo mestre com limites de coordenadas; explique seu papel em 1-2 frases.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou software de desenho como GeoGebra ou SketchUp",
                                    "Referência: Livro de Elementos Finitos (ex: Zienkiewicz)"
                                  ],
                                  "tips": "Comece visualizando um cubo familiar como uma sala de aula para associar as coordenadas.",
                                  "learningObjective": "Entender o espaço de referência padronizado para mapeamento isoparamétrico em elementos hexaédricos.",
                                  "commonMistakes": [
                                    "Confundir domínio mestre com geometria física",
                                    "Usar limites [0,1] em vez de [-1,1]"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar as Combinações de Coordenadas para os Vértices",
                                  "subSteps": [
                                    "Liste todas as combinações possíveis de ±1 para ξ, η e ζ (2 opções por direção: 2^3 = 8 combinações).",
                                    "Crie uma tabela com colunas ξ, η, ζ e escreva as 8 linhas sistematicamente.",
                                    "Agrupe por sinal: todos positivos, mistos, etc., para organizar.",
                                    "Verifique matematicamente que cada vértice está nos limites extremos do domínio.",
                                    "Pratique gerando a lista sem olhar para referências."
                                  ],
                                  "verification": "Produza uma tabela completa com 8 combinações únicas de (±1, ±1, ±1) sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Planilha Excel ou papel quadriculado",
                                    "Calculadora para validação rápida"
                                  ],
                                  "tips": "Use o método binário: 000 para todos -1, 111 para todos +1, e preencha os intermediários.",
                                  "learningObjective": "Dominar a geração sistemática das coordenadas locais dos nós nos vértices do cubo mestre.",
                                  "commonMistakes": [
                                    "Omitir combinações como (-1,+1,-1)",
                                    "Repetir coordenadas ou listar menos de 8"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Numerar e Localizar os 8 Nós Especificamente",
                                  "subSteps": [
                                    "Atribua numeração padrão aos nós (ex: nó 1 em (-1,-1,-1), nó 8 em (+1,+1,+1), seguindo convenção comum).",
                                    "Marque cada nó no esboço do cubo com seu número e coordenadas.",
                                    "Descreva a conectividade: cada nó é vértice compartilhado por faces adjacentes.",
                                    "Liste os nós em ordem: comece pelo canto 'origem' e circule sistematicamente.",
                                    "Confirme com uma convenção de numeração de referência (ex: diagrama de hexa8)."
                                  ],
                                  "verification": "Rotule um diagrama do cubo com todos os 8 nós numerados e coordenadas corretas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama impresso ou digital de cubo hexaédrico",
                                    "Marcadores coloridos para nós"
                                  ],
                                  "tips": "Use convenção clockwise vista de fora para faces, garantindo consistência.",
                                  "learningObjective": "Associar números de nós padrão às suas coordenadas locais no domínio mestre.",
                                  "commonMistakes": [
                                    "Numeração inconsistente com literatura padrão",
                                    "Confundir ordem de ξ,η,ζ"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Visualizar e Verificar as Posições dos Nós",
                                  "subSteps": [
                                    "Construa um modelo 3D simples usando software ou blocos para representar o cubo e nós.",
                                    "Simule o mapeamento: associe cada nó mestre a um vértice físico distorcido.",
                                    "Teste quiz interno: feche o material e liste os 8 nós de memória.",
                                    "Discuta variações: confirme que posições são fixas independentemente da malha física.",
                                    "Crie um fluxograma resumindo domínio → combinações → nós numerados."
                                  ],
                                  "verification": "Responda corretamente a perguntas sobre posições de 3 nós aleatórios e desenhe o cubo completo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software como MATLAB/Octave para plot 3D ou Python com Matplotlib",
                                    "Blocos de montar ou impressora 3D opcional"
                                  ],
                                  "tips": "Gire o cubo mentalmente para visualizar todos os ângulos e confirmar posições.",
                                  "learningObjective": "Visualizar espacialmente e memorizar as posições dos 8 nós para uso em derivações futuras.",
                                  "commonMistakes": [
                                    "Visualizar como pirâmide em vez de cubo",
                                    "Ignorar simetria simétrica do domínio"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um software de elementos finitos como ANSYS, ao criar uma malha hexaédrica, visualize o elemento mestre: nó 1 em (-1,-1,-1) mapeia para o vértice inferior esquerdo da peça física; desenhe e liste as coordenadas para confirmar antes de gerar a malha.",
                              "finalVerifications": [
                                "Lista corretamente as 8 coordenadas (±1, ±1, ±1) sem omissões ou erros.",
                                "Desenha e rotula um cubo mestre com todos os nós numerados.",
                                "Explica o papel das coordenadas locais no mapeamento isoparamétrico.",
                                "Identifica rapidamente a posição de qualquer nó específico (ex: nó 5).",
                                "Diferencia domínio mestre de geometria global.",
                                "Gera a lista de nós de memória em menos de 1 minuto."
                              ],
                              "assessmentCriteria": [
                                "Precisão na listagem de coordenadas (100% correto).",
                                "Clareza no diagrama visual (todos nós visíveis e rotulados).",
                                "Compreensão conceitual demonstrada em explicação escrita/oral.",
                                "Velocidade e confiança na enumeração e localização.",
                                "Aplicação correta em exemplo prático de mapeamento.",
                                "Identificação de erros comuns em pares de coordenadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sistemas de coordenadas cartesianas 3D e combinações cartesianas (produto cartesiano).",
                                "Programação: Geração de malhas em Python/MATLAB com loops para nós (±1 combinações).",
                                "Geometria Computacional: Vértices de poliedros regulares e topologia de grafos.",
                                "Física: Sistemas de referência em mecânica clássica e relatividade.",
                                "Design Gráfico: Modelagem 3D em Blender para visualização de domínios paramétricos."
                              ],
                              "realWorldApplication": "Na análise de elementos finitos para simulação de estruturas como aviões ou pontes, identificar corretamente os nós do hexaédrico 8-nós garante mapeamento preciso de funções de interpolação, evitando erros em tensões e deformações computadas em softwares como Abaqus ou COMSOL."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.3.1.1.2",
                            "name": "Descrever o mapeamento isoparamétrico",
                            "description": "Explicar o mapeamento bilineares de interpolação das coordenadas do elemento mestre (ξ, η, ζ) para as coordenadas físicas (x, y, z) usando funções de forma.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Elemento Mestre e Coordenadas Naturais",
                                  "subSteps": [
                                    "Defina o elemento hexaédrico de 8 nós no domínio referência: um cubo unitário com vértices em (±1, ±1, ±1).",
                                    "Identifique as coordenadas naturais (ξ, η, ζ) que variam de -1 a 1 em cada direção.",
                                    "Desenhe o elemento mestre e marque os 8 nós com suas posições (ξ_i, η_i, ζ_i).",
                                    "Explique a vantagem do domínio referência: padronização para integração numérica e derivação de funções.",
                                    "Compare com elementos físicos arbitrários para destacar a necessidade de mapeamento."
                                  ],
                                  "verification": "Desenhe corretamente o cubo mestre com nós rotulados e liste coordenadas de pelo menos 4 nós opostos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis ou software de desenho vetorial (ex: GeoGebra)",
                                    "Livro de Elementos Finitos (ex: Zienkiewicz)"
                                  ],
                                  "tips": "Use simetria do cubo para memorizar posições dos nós; visualize em 3D girando o modelo mentalmente.",
                                  "learningObjective": "Dominar a geometria do elemento referência e seu sistema de coordenadas naturais.",
                                  "commonMistakes": [
                                    "Confundir limites de ξ,η,ζ como 0-1 em vez de -1 a 1",
                                    "Errar posições nodais, como colocar nó 1 em (1,1,1) mas esquecer consistência",
                                    "Ignorar que é um cubo unitário centrado na origem"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar as Funções de Forma Bilineares para 8 Nós",
                                  "subSteps": [
                                    "Lembre funções de Lagrange bilineares em 1D: N1 = (1-ξ)/2, N2 = (1+ξ)/2.",
                                    "Estenda para 3D: produto tensorial N_i(ξ,η,ζ) = N_ξ(ξ) * N_η(η) * N_ζ(ζ), onde índices correspondem a combinações de ±1.",
                                    "Escreva explicitamente N1 = (1-ξ)(1-η)(1-ζ)/8 para nó (-1,-1,-1).",
                                    "Verifique propriedades: soma Ni=1 em todo domínio, Ni=1 no nó i e 0 nos outros.",
                                    "Implemente uma tabela com todas 8 funções para referência rápida."
                                  ],
                                  "verification": "Escreva e verifique soma das 8 funções em pontos como centro (0,0,0) e nó 1; deve ser 1.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Calculadora ou Mathematica/MATLAB para verificação simbólica",
                                    "Planilha para tabulação de funções"
                                  ],
                                  "tips": "Use notação compacta com fatores (1±ξ)/2; memorize padrão para nós pares/ímpares.",
                                  "learningObjective": "Construir e validar funções de forma N_i(ξ,η,ζ) para interpolação isoparamétrica.",
                                  "commonMistakes": [
                                    "Fator de normalização errado (não /8)",
                                    "Confundir produto tensorial com soma",
                                    "Falhar na verificação de partição da unidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular as Equações de Mapeamento Isoparamétrico",
                                  "subSteps": [
                                    "Escreva x(ξ,η,ζ) = Σ_{i=1}^8 N_i(ξ,η,ζ) x_i, similar para y e z.",
                                    "Explique interpolação: coordenadas físicas são interpoladas pelas mesmas funções que campos (isoparamétrico).",
                                    "Discuta mapeamento bijetivo: interior do mestre para interior do elemento físico.",
                                    "Derive Jacobiano J = ∂(x,y,z)/∂(ξ,η,ζ) para transformação de integrais.",
                                    "Calcule J em um ponto simples, como centro, para entender det(J) >0."
                                  ],
                                  "verification": "Escreva as 3 equações de mapeamento e compute x em um nó para um elemento físico dado.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": [
                                    "Software FEA como FreeFEM ou código Python simples para plotar mapeamento",
                                    "Papel quadriculado para derivação manual"
                                  ],
                                  "tips": "Comece com 2D quadrilateral para intuição antes de 3D; foque em det(J) para orientação.",
                                  "learningObjective": "Aplicar funções de forma para mapear (ξ,η,ζ) → (x,y,z) com precisão.",
                                  "commonMistakes": [
                                    "Usar funções lineares em vez de bilineares",
                                    "Esquecer que é isoparamétrico (mesmas Ni para geometria e campos)",
                                    "Invertar sinal no Jacobiano"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Propriedades e Limitações do Mapeamento",
                                  "subSteps": [
                                    "Descreva distorção: elementos retos mapeiam para curvos; bom para geometrias complexas.",
                                    "Discuta ordem de precisão: quadrática em curvatura para 8 nós lineares.",
                                    "Explique degenerescência: se nós coplanares, det(J)=0 → malha inválida.",
                                    "Compare com mapeamento sub/isoparamétrico/superparamétrico.",
                                    "Planeje mitigação: usar mais nós ou elementos de alta ordem."
                                  ],
                                  "verification": "Identifique em diagrama se um mapeamento dado é válido (det(J)>0 em gauss points).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exemplos de malhas FEA de tutoriais ANSYS/ABAQUS",
                                    "Artigo sobre isoparametric elements"
                                  ],
                                  "tips": "Visualize com software: distorça nós e cheque det(J); evite ângulos ruins.",
                                  "learningObjective": "Avaliar validade e limitações do mapeamento isoparamétrico em prática.",
                                  "commonMistakes": [
                                    "Confundir isoparamétrico com conforme",
                                    "Ignorar impacto de det(J) em precisão numérica",
                                    "Achar que mapeia curvas exatamente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Implementar e Verificar Numericamente",
                                  "subSteps": [
                                    "Escreva código Python/MATLAB para computar (x,y,z) dado (ξ,η,ζ) e nós.",
                                    "Avalie em pontos de Gauss (ex: ±1/√3).",
                                    "Plote superfície do elemento físico de um mestre.",
                                    "Teste com elemento distorcido e cheque continuidade entre elementos.",
                                    "Compare com solução analítica para cubo simples."
                                  ],
                                  "verification": "Código roda sem erro e mapeia corretamente 8 nós para posições físicas dadas.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": [
                                    "Python com NumPy/Matplotlib ou MATLAB",
                                    "Template de código FEA básico"
                                  ],
                                  "tips": "Vetorize funções Ni para eficiência; debugue com print de Ni no centro.",
                                  "learningObjective": "Implementar mapeamento computacionalmente para validação.",
                                  "commonMistakes": [
                                    "Índices de nós errados no array",
                                    "Erro numérico em produtos próximos a 1",
                                    "Não normalizar funções Ni"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um hexaédrico físico com nós: nó1(-1,0,0), nó2(1,0,0), etc., formando um prisma distorcido. Para ponto mestre (0,0,0), compute x = Σ Ni(0,0,0) xi = (1/8)(x1+...+x8). Plote em Python para visualizar mapeamento de cubo unitário para prisma irregular.",
                              "finalVerifications": [
                                "Escreve corretamente as 8 funções de forma N_i(ξ,η,ζ).",
                                "Formula equações de mapeamento x,y,z com precisão.",
                                "Calcula Jacobiano em pelo menos 2 pontos e verifica det(J)>0.",
                                "Identifica degenerescência em exemplo dado.",
                                "Implementa código que mapeia e plota elemento físico.",
                                "Explica diferenças isoparamétrico vs. outros mapeamentos."
                              ],
                              "assessmentCriteria": [
                                "Precisão das funções de forma (30%)",
                                "Correção das equações de mapeamento e Jacobiano (25%)",
                                "Análise de propriedades e limitações (20%)",
                                "Implementação numérica funcional (15%)",
                                "Clareza na descrição verbal e diagramas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Interpolação de Lagrange e produtos tensorais.",
                                "Programação: Implementação numérica em Python/MATLAB para visualização 3D.",
                                "Física: Transformações de coordenadas em mecânica dos sólidos.",
                                "Computação Gráfica: Mapeamentos paramétricos em modelagem 3D."
                              ],
                              "realWorldApplication": "Em simulações FEA de componentes mecânicos como turbinas ou chassis de veículos, o mapeamento isoparamétrico permite analisar tensões em geometrias complexas e irregulares, otimizando design sem remalhar manualmente."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.3.1.1.3",
                            "name": "Calcular o Jacobiano da transformação",
                            "description": "Derivar a matriz Jacobiana J que relaciona as derivadas parciais das coordenadas físicas com as naturais, e computar seu determinante para mudança de variável na integração.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir coordenadas naturais e funções de forma do elemento hexaédrico de 8 nós",
                                  "subSteps": [
                                    "Identifique o domínio das coordenadas naturais: ξ, η, ζ ∈ [-1, 1].",
                                    "Liste os 8 nós e suas coordenadas naturais: ex. nó 1: (-1,-1,-1), nó 2: (1,-1,-1), etc.",
                                    "Escreva as funções de forma N_i(ξ,η,ζ) = (1/8)(1 + ξ_i ξ)(1 + η_i η)(1 + ζ_i ζ), onde ξ_i = ±1 conforme o nó.",
                                    "Verifique que ∑ N_i = 1 em qualquer ponto interno.",
                                    "Desenhe o elemento mestre para visualização."
                                  ],
                                  "verification": "Confirme que as funções de forma interpolam corretamente os nós e somam 1 no centro (0,0,0).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de funções de forma de elementos finitos",
                                    "Software de visualização como ParaView (opcional)"
                                  ],
                                  "tips": "Memorize o padrão bilinear-trilinear das funções de forma para hexaédricos.",
                                  "learningObjective": "Compreender a parametrização isoparamétrica do elemento.",
                                  "commonMistakes": [
                                    "Confundir coordenadas de nós (ex. nó 1 como (1,1,1))",
                                    "Esquecer o fator 1/8",
                                    "Não verificar a partição da unidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Expressar coordenadas físicas em termos das naturais",
                                  "subSteps": [
                                    "Atribua coordenadas físicas (x_i, y_i, z_i) aos 8 nós do elemento real.",
                                    "Escreva x(ξ,η,ζ) = ∑_{i=1}^8 N_i(ξ,η,ζ) x_i, e аналогично para y e z.",
                                    "Expanda explicitamente x(ξ,η,ζ) substituindo as N_i.",
                                    "Escolha um ponto de Gauss específico (ex. centro) e compute x,y,z numéricamente.",
                                    "Verifique isoparametricidade: nos nós, x = x_i."
                                  ],
                                  "verification": "Substitua ξ=ξ_i etc. e confirme que x(ξ_i)=x_i para todos os nós.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Coordenadas dos nós do elemento real",
                                    "Calculadora ou MATLAB para expansão simbólica"
                                  ],
                                  "tips": "Use sympy ou Mathematica para expansão algébrica se manual for tedioso.",
                                  "learningObjective": "Mapear o elemento real para o mestre via interpolação.",
                                  "commonMistakes": [
                                    "Erro de indexação nos nós",
                                    "Confundir soma com produto nas funções de forma"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular derivadas parciais das funções de forma e coordenadas",
                                  "subSteps": [
                                    "Compute ∂N_i/∂ξ = (1/8) ξ_i (1 + η_i η)(1 + ζ_i ζ), аналогично para ∂/∂η e ∂/∂ζ.",
                                    "Em um ponto (ξ,η,ζ), calcule ∂x/∂ξ = ∑ ∂N_i/∂ξ * x_i, e todas as 9 derivadas.",
                                    "Forme vetores coluna: [∂x/∂ξ, ∂x/∂η, ∂x/∂ζ]^T etc. para clareza.",
                                    "Avalie em um ponto de Gauss (ex. (0,0,0)) para teste.",
                                    "Use regra da cadeia para derivadas compostas se necessário."
                                  ],
                                  "verification": "No centro (0,0,0), ∂N_i/∂ξ deve ser ±1/4 para nós apropriados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha com derivadas analíticas das N_i",
                                    "Software simbólico como SymPy"
                                  ],
                                  "tips": "Derive ∂N_i/∂ξ tratando η,ζ como constantes.",
                                  "learningObjective": "Dominar cálculo das derivadas parciais na parametrização.",
                                  "commonMistakes": [
                                    "Derivar produto incorretamente (esquecer fatores)",
                                    "Sinal errado nos ±1"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar a matriz Jacobiana J e calcular seu determinante",
                                  "subSteps": [
                                    "Monte J = [ ∂x/∂ξ  ∂y/∂ξ  ∂z/∂ξ ; ∂x/∂η ... ; ∂x/∂ζ ... ].",
                                    "Verifique que J é invertível (det(J) ≠ 0).",
                                    "Compute det(J) = ∂x/∂ξ (∂y/∂η ∂z/∂ζ - ∂y/∂ζ ∂z/∂η) - ... (fórmula 3x3).",
                                    "Avalie det(J) em pontos de Gauss e confirme positivo para orientação correta.",
                                    "Implemente numericamente para validação."
                                  ],
                                  "verification": "det(J) deve ser positivo e variar suavemente no elemento.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Fórmula de determinante 3x3",
                                    "MATLAB ou Python para verificação numérica"
                                  ],
                                  "tips": "Use expansão por cofatores; evite fórmula geral para 3x3.",
                                  "learningObjective": "Construir e avaliar o Jacobiano para integração.",
                                  "commonMistakes": [
                                    "Ordem errada das linhas/colunas de J",
                                    "Sinal invertido no det(J)"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar o Jacobiano na mudança de variável para integração",
                                  "subSteps": [
                                    "Lembre que ∫_elemento f dV = ∫_{-1}^1 ∫ f |det(J)| dξ dη dζ.",
                                    "Compute |det(J)| em pontos de Gauss e pese pela regra de quadratura.",
                                    "Exemplo: para integração rígida, use 1 ponto no centro.",
                                    "Verifique volume do elemento: V ≈ ∑ w_g |det(J_g)| onde w_g pesos Gauss.",
                                    "Compare com volume analítico do hexaédrico.",
                                    "verification]: "
                                  ]
                                },
                                "estimatedTime\": \"20 minutos\na",
                                "materials\": [\"Tabela de pontos e pesos de Gauss 2x2x2\", \"Código FEA simples\"],\n",
                                "tips\": \"Sempre use |det(J)| para evitar negativos.\",\n",
                                "learningObjective\": \"Integrar usando transformação isoparamétrica.\",\n",
                                "commonMistakes\": [\"Esquecer |det(J)|\", \"Pontos de Gauss errados\"]\n"
                              ]
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "34.3.1.2",
                        "name": "Funções de Interpolação Lineares",
                        "description": "Definição e propriedades das funções de forma lineares trilineares para o deslocamento e geometria no elemento hexaédrico de 8 nós.",
                        "specificSkills": [
                          {
                            "id": "34.3.1.2.1",
                            "name": "Escrever as funções de forma N_i",
                            "description": "Formular as funções de interpolação lineares para cada nó i=1 a 8: N_i(ξ,η,ζ) = (1 ± ξ)(1 ± η)(1 ± ζ)/8, verificando que somam 1 e são 1 no nó próprio e 0 nos outros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender coordenadas naturais e posições dos nós no hexaédrico de 8 nós",
                                  "subSteps": [
                                    "Defina o domínio de referência: cubo com ξ, η, ζ variando de -1 a +1.",
                                    "Liste as coordenadas dos 8 nós: Nó 1 (-1,-1,-1), Nó 2 (+1,-1,-1), Nó 3 (+1,+1,-1), Nó 4 (-1,+1,-1), Nó 5 (-1,-1,+1), Nó 6 (+1,-1,+1), Nó 7 (+1,+1,+1), Nó 8 (-1,+1,+1).",
                                    "Desenhe o cubo de referência e marque os nós numerados.",
                                    "Explique o papel das funções de forma: aproximar campos dentro do elemento.",
                                    "Discuta interpolação linear: produto de funções 1D lineares."
                                  ],
                                  "verification": "Desenho do cubo com nós corretamente posicionados e numerados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado ou software de desenho (GeoGebra/MATLAB)",
                                    "Referência de livro de Elementos Finitos (ex: Bathe ou Zienkiewicz)"
                                  ],
                                  "tips": [
                                    "Use convenção padrão de numeração para evitar confusão.",
                                    "Visualize o cubo como uma célula unitária para clareza."
                                  ],
                                  "learningObjective": "Identificar corretamente as posições dos nós em coordenadas naturais.",
                                  "commonMistakes": [
                                    "Numeração errada dos nós (ex: confundir ordem)",
                                    "Esquecer que vão de -1 a +1, não 0 a 1."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Recordar e derivar funções de interpolação lineares em 1D e estender para 3D",
                                  "subSteps": [
                                    "Em 1D: N1(ξ) = (1 - ξ)/2, N2(ξ) = (1 + ξ)/2; verifique N1(-1)=1, N1(+1)=0, soma=1.",
                                    "Em 2D (quadrilátero): N_i(ξ,η) = [(1±ξ)/2] * [(1±η)/2].",
                                    "Generalize para 3D: N_i(ξ,η,ζ) = [(1±ξ)/2] * [(1±η)/2] * [(1±ζ)/2].",
                                    "Note o fator /8 = /2^3 para normalização.",
                                    "Escreva a forma genérica: produto de fatores lineares binários para cada direção."
                                  ],
                                  "verification": "Escreva e verifique funções 1D/2D em seus nós; generalize corretamente para 3D.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de papel para derivações",
                                    "Calculadora para verificações numéricas"
                                  ],
                                  "tips": [
                                    "Sempre verifique partição da unidade em pontos simples como centro (0,0,0).",
                                    "Use ± baseado na posição do nó: - para coordenada -1, + para +1."
                                  ],
                                  "learningObjective": "Derivar a estrutura produto das funções lineares em múltiplas dimensões.",
                                  "commonMistakes": [
                                    "Fator errado (/4 em vez de /8 em 3D)",
                                    "Confundir (1-ξ)/2 com (1-ξ) sem normalizar."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escrever explicitamente as 8 funções N_i(ξ,η,ζ)",
                                  "subSteps": [
                                    "Para Nó 1 (-,-,-): N1 = (1-ξ)(1-η)(1-ζ)/8.",
                                    "Nó 2 (+,-,-): N2 = (1+ξ)(1-η)(1-ζ)/8.",
                                    "Nó 3 (+++,-): N3 = (1+ξ)(1+η)(1-ζ)/8.",
                                    "Nó 4 (-,+,-): N4 = (1-ξ)(1+η)(1-ζ)/8.",
                                    "Continue para Nós 5-8 trocando ζ por (1+ζ).",
                                    "Escreva todas as 8 em uma tabela organizada."
                                  ],
                                  "verification": "Lista completa das 8 funções com sinais corretos para cada coordenada.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela impressa ou Excel para organizar N_i vs coordenadas dos nós"
                                  ],
                                  "tips": [
                                    "Crie uma tabela: colunas para ξ,η,ζ fatores; linha por nó.",
                                    "Copie padrões de 2D e estenda."
                                  ],
                                  "learningObjective": "Formular corretamente todas as funções de forma lineares para os 8 nós.",
                                  "commonMistakes": [
                                    "Sinais errados nos fatores (ex: usar + para nó em -1)",
                                    "Fator /8 esquecido ou errado."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar propriedades: partição da unidade e condições de interpolação",
                                  "subSteps": [
                                    "Verifique soma N1+...+N8 =1 em pelo menos 3 pontos: (-1,-1,-1), (0,0,0), (+1,+1,+1).",
                                    "Para cada nó j, confirme N_i(nó j) = δ_ij (1 se i=j, 0 caso contrário).",
                                    "Teste numericamente em um ponto interno, ex: (0,0,0): cada Ni=1/8.",
                                    "Analiticamente: mostre que o produto expande para 1.",
                                    "Discuta implicações: reprodutibilidade de constantes e lineares."
                                  ],
                                  "verification": "Tabela de verificações com valores numéricos/exatos mostrando soma=1 e δ_ij.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Software simbólico (SymPy/MATLAB) ou calculadora",
                                    "Papel para expansões algébricas"
                                  ],
                                  "tips": [
                                    "No centro (0,0,0), todos os (1±0)=1, então 1*1*1/8=1/8 cada.",
                                    "Automatize soma com código simples se possível."
                                  ],
                                  "learningObjective": "Demonstrar que as funções satisfazem as propriedades essenciais de interpolação.",
                                  "commonMistakes": [
                                    "Erro aritmético em somas",
                                    "Não testar em múltiplos pontos ou confundir nós."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o elemento com nós numerados padrão. Calcule o campo u(ξ,η,ζ) = Σ u_i N_i em um ponto gaussiano como (0.577,0,0). Atribua u1=1, outros=0; verifique u≈N1(0.577,0,0)=(1-0.577)(1-0)(1-0)/8≈0.105.",
                              "finalVerifications": [
                                "Todas as 8 funções N_i escritas corretamente com fatores e sinais apropriados.",
                                "Soma das N_i = 1 verificada em pelo menos 3 pontos distintos.",
                                "Cada N_i = 1 no seu próprio nó e 0 nos outros 7 nós.",
                                "Tabela ou código confirma propriedades em pontos internos.",
                                "Expansão algébrica mostra partição da unidade.",
                                "Sem erros tipográficos ou aritméticos nas fórmulas."
                              ],
                              "assessmentCriteria": [
                                "Precisão das fórmulas N_i (100% correto para todos os 8 nós).",
                                "Demonstração explícita da soma =1 em múltiplos pontos.",
                                "Verificação completa das condições δ_ij para todos os nós.",
                                "Clareza na derivação do produto 1D para 3D.",
                                "Uso correto de coordenadas naturais (-1 a +1).",
                                "Inclusão de pelo menos um exemplo numérico prático."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Polinômios de Lagrange e propriedades de bases.",
                                "Programação: Implementação em código FEM (MATLAB/Python-FEniCS).",
                                "Física: Aproximação de campos contínuos (tensões, deslocamentos).",
                                "Geometria Computacional: Mapeamentos isoparamétricos.",
                                "Estatística: Pontos de Gauss para integração numérica."
                              ],
                              "realWorldApplication": "Essas funções são usadas em softwares FEM como ANSYS ou Abaqus para simular tensões em peças mecânicas complexas, como turbinas ou chassis de veículos, permitindo predizer falhas sob carga real."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.3.1.2.2",
                            "name": "Calcular derivadas das funções de forma",
                            "description": "Obter as derivadas parciais ∂N_i/∂ξ, ∂N_i/∂η, ∂N_i/∂ζ em pontos de integração, necessárias para as matrizes de deformação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar funções de interpolação lineares para elemento hexaédrico de 8 nós",
                                  "subSteps": [
                                    "Identifique as coordenadas naturais (ξ, η, ζ) que variam de -1 a 1 no domínio do elemento.",
                                    "Liste as 8 funções de forma N_i(ξ, η, ζ), como N_1 = (1-ξ)(1-η)(1-ζ)/8.",
                                    "Verifique a propriedade de partição da unidade: ∑ N_i = 1 em qualquer ponto interno.",
                                    "Confirme interpolação em nós: N_i = 1 no nó i e 0 nos outros.",
                                    "Anote os pontos de integração de Gauss 2x2x2: (±1/√3, ±1/√3, ±1/√3)."
                                  ],
                                  "verification": "Confirme que todas as N_i estão corretamente escritas e somam 1 em (0,0,0).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Folha de papel, calculadora, tabela de funções de forma padrão para hexa8.",
                                  "tips": "Use uma tabela para organizar as 8 funções e evite erros de sinal nos termos (1±ξ).",
                                  "learningObjective": "Dominar a expressão exata das funções de forma lineares em coordenadas naturais.",
                                  "commonMistakes": "Esquecer o fator 1/8 ou inverter sinais nos termos lineares."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar as derivadas parciais ∂N_i/∂ξ, ∂N_i/∂η, ∂N_i/∂ζ simbolicamente",
                                  "subSteps": [
                                    "Expanda cada N_i como produto de três termos lineares em ξ, η, ζ.",
                                    "Aplique a regra do produto para ∂N_i/∂ξ: derive apenas o fator ξ, mantendo η e ζ constantes.",
                                    "Repita para ∂N_i/∂η e ∂N_i/∂ζ, ajustando o fator derivado.",
                                    "Simplifique as expressões resultantes, cancelando fatores comuns.",
                                    "Escreva as derivadas em forma compacta, como ∂N_1/∂ξ = -(1-η)(1-ζ)/8."
                                  ],
                                  "verification": "Verifique que ∂N_i/∂ξ no nó i tem o valor esperado e zero nos nós independentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel para derivações simbólicas, software simbólico como SymPy (opcional).",
                                  "tips": "Derive uma função representativa primeiro (ex: N_1) e generalize o padrão para os outros nós.",
                                  "learningObjective": "Aplicar derivação parcial corretamente em funções multivariáveis lineares.",
                                  "commonMistakes": "Derivar fatores errados ou esquecer a regra do produto em expansões."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar derivadas nos pontos de integração de Gauss",
                                  "subSteps": [
                                    "Selecione um ponto Gauss, ex: GP1 = (1/√3, 1/√3, 1/√3).",
                                    "Substitua ξ=1/√3, η=1/√3, ζ=1/√3 em cada ∂N_i/∂ξ, ∂N_i/∂η, ∂N_i/∂ζ.",
                                    "Calcule numericamente para todos os 8 nós e as 3 derivadas (24 valores totais por GP).",
                                    "Repita para os outros 7 pontos Gauss, organizando em uma matriz [∂N/∂ξ η ζ]_{8x3}.",
                                    "Arredonde para precisão numérica adequada (ex: 4 casas decimais)."
                                  ],
                                  "verification": "Confirme que ∑ ∂N_i/∂ξ = 0 em cada GP (propriedade geométrica).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Calculadora científica, planilha Excel ou MATLAB para avaliações numéricas.",
                                  "tips": "Use simetria dos pontos Gauss para acelerar cálculos em nós opostos.",
                                  "learningObjective": "Avaliar derivadas em pontos específicos com alta precisão numérica.",
                                  "commonMistakes": "Erro de sinal ao substituir valores negativos de Gauss ou arredondamento precoce."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Organizar derivadas para formação da matriz de deformação B",
                                  "subSteps": [
                                    "Relembre a matriz B: contém [∂N_i/∂X ∂N_i/∂Y ∂N_i/∂Z] transformadas via Jacobiana.",
                                    "Agrupe as derivadas em formato para um nó: [∂u/∂X = ∑ (∂N_i/∂ξ * J^{-1}_{11} + ...)] mas foque em ∂N/∂ξηζ.",
                                    "Monte a matriz de derivadas [dN/dξ] 3x24 para todos nós e GPs.",
                                    "Verifique consistência com Jacobiana em um exemplo simples.",
                                    "Documente os valores para uso em código FEM."
                                  ],
                                  "verification": "Teste em elemento unitário: derivadas devem refletir geometria conhecida.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código MATLAB/Python para montar B, referência de Jacobiana.",
                                  "tips": "Salve valores em tabela para reutilização em integrações numéricas.",
                                  "learningObjective": "Integrar derivadas de forma em estruturas matriciais para FEM.",
                                  "commonMistakes": "Confundir ordem de nós ou derivadas na matriz B."
                                }
                              ],
                              "practicalExample": "Para o nó 1 (ξ=-1,η=-1,ζ=-1) no ponto Gauss (1/√3,1/√3,1/√3): ∂N1/∂ξ = -(1-1/√3)(1-1/√3)/8 ≈ -0.1481; similar para η,ζ. Use para B em viga cantilever.",
                              "finalVerifications": [
                                "∑_{i=1}^8 ∂N_i/∂ξ = 0 em todos os 8 GPs.",
                                "Valores simétricos para nós opostos coincidem em magnitude.",
                                "Derivadas em nós: ∂N_i/∂ξ = ±1/8 ou 0 conforme esperado.",
                                "Precisão numérica < 10^{-4} erro relativo.",
                                "Matriz [dN/dξ η ζ] 24x3 montada corretamente.",
                                "Consistência com software FEM padrão (ex: Abaqus valores)."
                              ],
                              "assessmentCriteria": [
                                "Exatidão simbólica das derivadas parciais (100% match com fórmula padrão).",
                                "Precisão numérica nas avaliações de Gauss (erro < 0.1%).",
                                "Correta verificação de propriedades geométricas (soma zero).",
                                "Organização clara em matrizes para B.",
                                "Tempo de execução dentro do estimado com zero erros graves.",
                                "Capacidade de generalizar para outros elementos."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Diferencial: Derivação parcial e regra da cadeia.",
                                "Álgebra Linear: Matrizes Jacobiana e B em FEM.",
                                "Programação Numérica: Implementação em Python/MATLAB.",
                                "Física: Cinemática em deformações contínuas."
                              ],
                              "realWorldApplication": "Essas derivadas são essenciais para análise de tensões em estruturas 3D complexas, como chassis de aviões ou turbinas, usando software FEM como ANSYS para prever falhas sob carga."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.3.1.2.3",
                            "name": "Avaliar funções em pontos de Gauss",
                            "description": "Avaliar funções de forma e suas derivadas nos 2×2×2 pontos de Gauss padrão para integração numérica no elemento mestre.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os pontos de Gauss padrão no elemento mestre hexaédrico",
                                  "subSteps": [
                                    "Revise a definição do elemento mestre [-1,1]^3 para o hexaedro de 8 nós.",
                                    "Determine os pesos e posições dos pontos de Gauss para integração de ordem 2 em 1D: ξ_g = ±1/√3 ≈ ±0.57735, peso w=1.",
                                    "Gere a grade 2×2×2: todas as combinações de (ξ_g, η_g, ζ_g) resultando em 8 pontos.",
                                    "Liste as coordenadas exatas e aproximadas numéricas dos 8 pontos.",
                                    "Confirme que os pesos de integração são w=1 em cada direção, totalizando 8 para o volume."
                                  ],
                                  "verification": "Lista completa dos 8 pontos com coordenadas e pesos corretos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de referência de pontos de Gauss, calculadora ou software como MATLAB/Python.",
                                  "tips": "Use simetria para evitar cálculos repetitivos; memorize 1/√3 ≈ 0.577.",
                                  "learningObjective": "Compreender a localização e propriedades dos pontos de Gauss 2×2×2.",
                                  "commonMistakes": "Confundir com pontos de Gauss-Lobatto (que incluem bordas); usar ordem errada (ex: 3 pontos)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir as funções de forma lineares para o hexaedro de 8 nós",
                                  "subSteps": [
                                    "Numere os nós do elemento mestre: 1=(−1,−1,−1), 2=(1,−1,−1), ..., 8=(1,1,1).",
                                    "Escreva a função de forma genérica: N_i(ξ,η,ζ) = (1/8)(1+ξ_i ξ)(1+η_i η)(1+ζ_i ζ), onde ξ_i=±1.",
                                    "Expanda explicitamente N1 a N8 para referência.",
                                    "Verifique que N_i=1 no nó i e 0 nos outros nós.",
                                    "Confirme a propriedade de partição da unidade: Σ N_i =1 para todo (ξ,η,ζ)."
                                  ],
                                  "verification": "Funções N_i corretas e verificadas em pelo menos um ponto interno.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Diagrama do elemento hex8, papel para derivações.",
                                  "tips": "Agrupe termos por nó para facilitar; teste em centro (0,0,0): todas N_i=1/8.",
                                  "learningObjective": "Dominar a expressão analítica das funções de forma lineares trilineares.",
                                  "commonMistakes": "Fator 1/8 errado (deve ser 1/8, não 1/2); inverter sinais dos nós."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar funções de forma N_i nos 8 pontos de Gauss",
                                  "subSteps": [
                                    "Selecione um ponto de Gauss, ex: (ξ_g, ξ_g, ξ_g) onde ξ_g=1/√3.",
                                    "Substitua nas 8 funções N_i e compute valores numéricos/exatos.",
                                    "Repita para todos os 8 pontos, usando simetria (pontos simétricos têm N_i semelhantes).",
                                    "Armazene em tabela: linhas=pontos Gauss, colunas=N1 a N8.",
                                    "Verifique soma Σ N_i =1 em cada ponto (erro <1e-10)."
                                  ],
                                  "verification": "Tabela completa com valores corretos e somas unitárias.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilha Excel ou script Python para cálculos matriciais.",
                                  "tips": "Implemente em código para automação; exatidão com frações racionais.",
                                  "learningObjective": "Calcular eficientemente N_i em pontos de integração numérica.",
                                  "commonMistakes": "Erro de sinal em ξ_i ao substituir; arredondamento precoce."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular derivadas das funções de forma nos pontos de Gauss",
                                  "subSteps": [
                                    "Derive analiticamente: dN_i/dξ = (1/8) ξ_i (1+η_i η)(1+ζ_i ζ), e similares para d/dη, d/dζ.",
                                    "Avalie dN_i/dξ, dN_i/dη, dN_i/dζ em cada um dos 8 pontos de Gauss.",
                                    "Organize em matrizes: para cada ponto, [dN/dξ; dN/dη; dN/dζ] (8x3 matriz por ponto).",
                                    "Verifique ortogonalidade ou propriedades conhecidas em pontos simétricos.",
                                    "Compare com software FEM padrão para validação."
                                  ],
                                  "verification": "Matrizes de derivadas corretas para todos pontos, com checks numéricos.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Software simbólico (SymPy) ou código numérico, referência FEM.",
                                  "tips": "Derive uma vez e substitua; use produto rule com cuidado.",
                                  "learningObjective": "Obter gradientes das funções de forma para computação de matriz B.",
                                  "commonMistakes": "Esquecer fator 1/8 nas derivadas; derivar incorretamente produtos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e integrar no contexto de integração numérica",
                                  "subSteps": [
                                    "Compute integral de teste: ∫ N_i dV ≈ Σ N_i(ξ_g) * w * detJ (assuma J=1).",
                                    "Verifique precisão para polinômios lineares (deve ser exata).",
                                    "Analise estabilidade: verifique se gradientes são simétricos esperados.",
                                    "Documente todos valores em formato reutilizável (JSON/CSV).",
                                    "Discuta impacto em elementos distorcidos (mapeamento isoparamétrico)."
                                  ],
                                  "verification": "Integrais de teste exatas e documentação completa.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código FEM simples ou calculadora matricial.",
                                  "tips": "Foco em detJ=1 para mestre; expanda depois.",
                                  "learningObjective": "Aplicar avaliações em fluxo FEM real.",
                                  "commonMistakes": "Ignorar pesos de Gauss; confundir com coordenadas globais."
                                }
                              ],
                              "practicalExample": "Para o ponto de Gauss (0.577, 0.577, 0.577), N1 = (1/8)(1-0.577)^3 ≈ 0.0140, N2=(1/8)(1+0.577)(1-0.577)^2 ≈ 0.118, etc., com soma=1. Derivada dN1/dξ=(1/8)(-1)(1-0.577 η)(1-0.577 ζ) no ponto ≈ -0.206.",
                              "finalVerifications": [
                                "Soma das N_i = 1 em todos os 8 pontos de Gauss (erro < 1e-12).",
                                "N_i = 0 nos nós opostos em cada avaliação.",
                                "Gradientes dN_i/dξ simétricos para pontos simétricos.",
                                "Integral numérica de 1 sobre domínio = 8 (volume do mestre).",
                                "Comparação com biblioteca FEM (ex: FEniCS) idêntica.",
                                "Derivadas não nulas dentro do domínio."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica/exata nas avaliações (>6 dígitos).",
                                "Correta derivação analítica das funções e gradientes.",
                                "Eficiência computacional (uso de simetria).",
                                "Validação completa com somas e integrais.",
                                "Clareza na documentação/tabulação.",
                                "Compreensão de contexto FEM (matriz B)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Quadratura de Gauss e polinômios ortogonais.",
                                "Programação: Implementação em Python/MATLAB para automação FEM.",
                                "Física Computacional: Integração em simulações de PDEs elípticas.",
                                "Geometria Computacional: Mapeamentos isoparamétricos."
                              ],
                              "realWorldApplication": "Em software de Elementos Finitos como ANSYS ou Abaqus, essas avaliações são usadas para montar matrizes de rigidez em análises estruturais de sólidos 3D, como simulação de tensões em peças automotivas ou aeroespaciais, garantindo precisão na integração numérica sem singularidades."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "34.3.1.3",
                        "name": "Montagem da Matriz de Rigidez",
                        "description": "Formulação e cálculo da matriz de rigidez local [k] para o elemento hexaédrico sob hipótese de deformação linear, incluindo matrizes [B], [D] e integração.",
                        "specificSkills": [
                          {
                            "id": "34.3.1.3.1",
                            "name": "Construir a matriz de deformação [B]",
                            "description": "Montar a matriz [B] (6×24 para 3D) relacionando as derivadas dos deslocamentos nodais às componentes de deformação ε = [B] u, usando derivadas das funções de forma transformadas pelo Jacobiano.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir funções de forma e derivadas em coordenadas naturais",
                                  "subSteps": [
                                    "Liste os 8 nós do elemento hexaédrico e suas coordenadas naturais (r,s,t): (-1,-1,-1), (1,-1,-1), etc.",
                                    "Escreva as funções de forma N_i(r,s,t) para i=1 a 8: N1 = (1-r)(1-s)(1-t)/8, etc.",
                                    "Calcule as derivadas parciais ∂N_i/∂r, ∂N_i/∂s, ∂N_i/∂t para cada i em um ponto de Gauss específico (ex: centro r=s=t=0).",
                                    "Organize as derivadas em matrizes [∂N/∂r], [∂N/∂s], [∂N/∂t] de dimensão 1x8.",
                                    "Verifique simetria e propriedades das funções de forma (soma Ni=1, interpolação nos nós)."
                                  ],
                                  "verification": "Confirme que as derivadas em nós são zero exceto no nó correspondente (1 ou -1 conforme direção).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis ou software simbólico como Mathematica/MATLAB Symbolic Toolbox",
                                    "Referência: Livro 'Finite Element Procedures' de Bathe"
                                  ],
                                  "tips": "Use a notação compacta e memorize o padrão trilinear para evitar erros de sinal.",
                                  "learningObjective": "Dominar as funções de forma isoparamétricas e suas derivadas iniciais.",
                                  "commonMistakes": [
                                    "Confundir ordem dos nós (1-8 padrão)",
                                    "Erros de sinal nas derivadas parciais",
                                    "Esquecer o fator 1/8 nas Ni"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a matriz Jacobiana [J] no ponto de integração",
                                  "subSteps": [
                                    "Defina as coordenadas globais x,y,z em termos das Ni: x = Σ Ni xi, etc., para os 8 nós com coordenadas (xi,yi,zi).",
                                    "Compute os elementos da Jacobiana 3x3: J11=∂x/∂r=Σ(∂Ni/∂r)xi, J12=∂y/∂r=Σ(∂Ni/∂r)yi, etc.",
                                    "Preencha a matriz [J] completa com as 9 entradas usando as derivadas do step 1.",
                                    "Calcule o determinante det[J] para verificar se o elemento não está degenerado (det[J]>0).",
                                    "Inverta [J]^{-1} simbolicamente ou numericamente para o próximo step."
                                  ],
                                  "verification": "Verifique det[J] ≠ 0 e que [J][J]^{-1} = [I] identidade.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "MATLAB ou Python com NumPy/SciPy para cálculo matricial",
                                    "Coordenadas exemplo de um cubo unitário"
                                  ],
                                  "tips": "Para elementos regulares como cubo, [J] é diagonal e simples; teste com isso primeiro.",
                                  "learningObjective": "Entender a transformação isoparamétrica via Jacobiano.",
                                  "commonMistakes": [
                                    "Ordem errada das derivadas ao montar [J]",
                                    "Inversão incorreta de matriz 3x3",
                                    "Ignorar det[J] negativo indicando inversão"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Obter derivadas das funções de forma em coordenadas globais",
                                  "subSteps": [
                                    "Use [J]^{-1} para transformar: ∂N/∂x = (∂N/∂r) J11^{-1} + (∂N/∂s) J21^{-1} + (∂N/∂t) J31^{-1}, e similares para ∂N/∂y, ∂N/∂z.",
                                    "Para cada Ni, compute o vetor de gradiente global [∂Ni/∂x, ∂Ni/∂y, ∂Ni/∂z].",
                                    "Monte matrizes 8x3 com todas as derivadas globais para x,y,z por nó.",
                                    "Verifique dimensionalidade: deve resultar em derivadas consistentes com geometria.",
                                    "Salve essas derivadas para montagem de [B]."
                                  ],
                                  "verification": "Integre as derivadas ao longo do elemento para checar consistência (ex: ∫∂N/∂x dV = 0 para rigidez).",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Planilha Excel ou código Python para automação",
                                    "Exemplo numérico com nós conhecidos"
                                  ],
                                  "tips": "Implemente uma função para [J]^{-1} * derivadas locais para eficiência.",
                                  "learningObjective": "Aplicar chain rule para derivadas globais via Jacobiano.",
                                  "commonMistakes": [
                                    "Multiplicar pela Jacobiana ao invés da inversa",
                                    "Índices errados nas linhas/colunas de [J]^{-1}",
                                    "Esquecer transposição em código"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar a matriz de deformação [B] completa (6x24)",
                                  "subSteps": [
                                    "Para εxx: linha 1 de [B] = [∂N1/∂x, 0,0, ∂N2/∂x,0,0, ..., ∂N8/∂x,0,0] (apenas DOFs ux por nó).",
                                    "Para εyy: linha 2 = [0, ∂N1/∂y,0, 0,∂N2/∂y,0, ...].",
                                    "Para εzz: linha 3 similar com ∂N/∂z nos uz.",
                                    "Para γxy (linha 4): ∂N/∂y nos ux e ∂N/∂x nos uy, ex: [∂N1/∂y, ∂N1/∂x, 0, ...].",
                                    "Complete γxz (linha 5) e γyz (linha 6) analogamente; verifique 6 linhas x 24 colunas.",
                                    "Confirme ε = [B] u com u vetor 24x1 de deslocamentos nodais."
                                  ],
                                  "verification": "Multiplique [B] por vetor u unitário em um DOF e cheque se produz deformação esperada.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "MATLAB script para montar [B]",
                                    "Teoria de elasticidade referência"
                                  ],
                                  "tips": "Use padrão block para cada nó: 3x3 bloco com derivadas nos off-diagonais para cisalhamentos.",
                                  "learningObjective": "Construir [B] relacionando deformações a deslocamentos nodais.",
                                  "commonMistakes": [
                                    "Fator 1/2 nos cisalhamentos (γ=2εxy, mas [B] usa γ diretamente)",
                                    "Ordem errada de DOFs (ux,uy,uz por nó)",
                                    "Dimensões incorretas (não 6x24)"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um elemento hexaédrico cubo unitário centrado na origem com nós em (±0.5,±0.5,±0.5). No ponto Gauss r=s=t=0, compute [J]=diag(0.125,0.125,0.125), derivadas globais ∂Ni/∂x=∂Ni/∂r / 0.125, e monte [B] completa, verificando εxx=∂u/∂x correto.",
                              "finalVerifications": [
                                "Derivadas locais corretas para todas Ni em ponto Gauss.",
                                "Jacobiana invertível com det[J]>0.",
                                "Derivadas globais consistentes com geometria do elemento.",
                                "[B] tem exatas dimensões 6x24 e estrutura block por nó.",
                                "Teste: [B]{u} produz deformações físicas válidas para u conhecido.",
                                "Simetria e propriedades de partição de unidade preservadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas derivadas (erro <1% numérico).",
                                "Correta transformação via Jacobiano.",
                                "Montagem sem erros de indexação em [B].",
                                "Verificação de dimensionalidade e multiplicação.",
                                "Explicação clara do processo passo-a-passo.",
                                "Eficiência no uso de ferramentas computacionais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo multivariável e álgebra linear (Jacobianas, inversas).",
                                "Programação: Implementação numérica em Python/MATLAB para automação.",
                                "Física: Teoria da elasticidade e cinemática de deformação.",
                                "Computação Científica: Integração numérica em pontos Gauss.",
                                "Engenharia de Software: Modularidade em códigos FEA."
                              ],
                              "realWorldApplication": "Em simulações FEA com ANSYS ou Abaqus, [B] é essencial para calcular tensões em estruturas complexas como pontes, aviões ou implantes médicos, permitindo prever falhas sob carga real."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.3.1.3.2",
                            "name": "Aplicar as equações constitutivas [D]",
                            "description": "Definir a matriz de material [D] para material isotrópico linear elástico em termos de E e ν, e incorporá-la na expressão da rigidez.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender as equações constitutivas para materiais isotrópicos lineares elásticos",
                                  "subSteps": [
                                    "Revise a relação tensão-deformação geral σ = [D] ε para materiais lineares elásticos.",
                                    "Identifique os componentes da tensão (σ_xx, σ_yy, etc.) e deformação (ε_xx, ε_yy, γ_xy, etc.) em 3D.",
                                    "Lembre-se das propriedades de isotropia: dependência apenas de E e ν.",
                                    "Escreva a forma hookeana generalizada para 3D com 6 componentes.",
                                    "Confirme que há 21 constantes elásticas independentes reduzidas para 2 em isotropia."
                                  ],
                                  "verification": "Liste corretamente os 6 componentes de tensão e deformação e a dependência de E e ν.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Livro-texto de mecânica dos sólidos",
                                    "Calculadora"
                                  ],
                                  "tips": [
                                    "Use notação de Voigt para vetores de tensão e deformação.",
                                    "Visualize um cubo deformado para entender os componentes."
                                  ],
                                  "learningObjective": "Compreender a base teórica das equações constitutivas em 3D para isotropia.",
                                  "commonMistakes": [
                                    "Confundir coeficiente de Poisson ν com outros parâmetros.",
                                    "Esquecer termos de cisalhamento γ_xy = 2ε_xy."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a matriz de material [D] em termos de E e ν",
                                  "subSteps": [
                                    "Escreva as equações de Hooke para tensões normais: σ_xx = λ(θ) + 2μ ε_xx, onde λ e μ são constantes de Lamé.",
                                    "Expresse λ e μ em termos de E e ν: λ = E ν / ((1+ν)(1-2ν)), μ = E / (2(1+ν)).",
                                    "Monte a matriz 6x6 [D] completa, incluindo termos de cisalhamento.",
                                    "Verifique a simetria da matriz e os valores na diagonal.",
                                    "Substitua valores numéricos exemplo: E=200 GPa, ν=0.3, e compute [D]."
                                  ],
                                  "verification": "A matriz [D] resultante deve ser simétrica e coincidir com a fórmula padrão para isotropia.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Calculadora científica",
                                    "Software como MATLAB ou Python (opcional)",
                                    "Tabela de fórmulas de elasticidade"
                                  ],
                                  "tips": [
                                    "Memorize as expressões de λ e μ para agilizar.",
                                    "Use frações exatas antes de aproximar numericamente."
                                  ],
                                  "learningObjective": "Derivar explicitamente a matriz [D] a partir de E e ν.",
                                  "commonMistakes": [
                                    "Erro no denominador de λ (esquecer 1-2ν).",
                                    "Confundir μ com G (mas G=μ)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar [D] na expressão da matriz de rigidez local do elemento hexaédrico",
                                  "subSteps": [
                                    "Lembre a fórmula da rigidez local: [k] = ∫ [B]^T [D] [B] dV.",
                                    "Identifique a matriz de deformação [B] para o elemento hexaédrico de 8 nós (20 DOFs em 3D).",
                                    "Substitua [D] na integral e discuta a integração numérica (Gauss).",
                                    "Escreva a forma explícita para um ponto de Gauss: [k_gp] = w [B]^T [D] [B] |J|.",
                                    "Some contribuições de todos os pontos de Gauss para [k] final."
                                  ],
                                  "verification": "Confirme que [k] tem dimensões 24x24 (8 nós x 3 DOFs) e é simétrica positiva definida.",
                                  "estimatedTime": "60 minutes",
                                  "materials": [
                                    "Código de exemplo em Python/MATLAB para [B]",
                                    "Papel milimetrado para esboços",
                                    "Referência de elementos finitos"
                                  ],
                                  "tips": [
                                    "Comece com elemento 2D para intuitar antes de 3D.",
                                    "Verifique unidades: [D] em Pa, [k] em N/m."
                                  ],
                                  "learningObjective": "Integrar [D] corretamente na montagem da rigidez do elemento.",
                                  "commonMistakes": [
                                    "Esquecer o determinante do Jacobiano |J|.",
                                    "Dimensões erradas em [B] (deve mapear para 6 strains)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e testar a implementação da matriz de rigidez",
                                  "subSteps": [
                                    "Compute [k] para um cubo unitário com E=1, ν=0 e compare com analítico.",
                                    "Aplique deslocamentos unitários e verifique forças reativas via [k] u = f.",
                                    "Teste com caso conhecido: tração uniaxial em barra.",
                                    "Analise sensibilidade variando E e ν.",
                                    "Documente o processo em um relatório curto."
                                  ],
                                  "verification": "Resultados numéricos coincidem com soluções analíticas dentro de 1% de erro.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Software FEA como ANSYS ou código próprio",
                                    "Dados de benchmark"
                                  ],
                                  "tips": [
                                    "Use ν=0 para simplificar e isolar erros.",
                                    "Plot [k] para visualizar simetria."
                                  ],
                                  "learningObjective": "Validar numericamente a aplicação de [D] na rigidez.",
                                  "commonMistakes": [
                                    "Integração Gauss insuficiente (use 2x2x2 pontos).",
                                    "Não zerar [k] antes de somar GPs."
                                  ]
                                }
                              ],
                              "practicalExample": "Para um elemento hexaédrico unitário com E=210 GPa (aço), ν=0.3, compute [D], derive [B] no centro, calcule [k_gp] em um ponto Gauss e some para [k] total. Aplique u=1mm em um nó e verifique rigidez efetiva.",
                              "finalVerifications": [
                                "Matriz [D] é simétrica com D11 = E(1-ν)/((1+ν)(1-2ν)).",
                                "[k] resultante é simétrica e positiva semi-definida.",
                                "Para ν=0, [D] diagonaliza corretamente.",
                                "Energia de deformação ∫ ε^T [D] ε dV >0 para modos não-rígidos.",
                                "Comparação com software comercial dentro de 0.5%.",
                                "Valores de cisalhamento G = E/(2(1+ν)) corretos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de [D] (fórmulas exatas).",
                                "Correta integração de [D] em [k] com [B] e Jacobiano.",
                                "Validação numérica com casos teste.",
                                "Clareza na documentação de passos e fórmulas.",
                                "Tratamento de erros comuns como unidades e simetria.",
                                "Eficiência computacional na montagem."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra matricial e integração numérica (quadraturas de Gauss).",
                                "Física: Mecânica dos sólidos e teoria da elasticidade.",
                                "Computação: Programação numérica em Python/MATLAB para FEA.",
                                "Engenharia de Materiais: Propriedades E e ν de diferentes materiais."
                              ],
                              "realWorldApplication": "Em análises FEA de estruturas aeronáuticas, como fuselagem de aviões, onde [D] modela comportamento elástico de ligas de alumínio sob cargas complexas, prevendo deformações e falhas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.3.1.3.3",
                            "name": "Realizar integração numérica da matriz [k]",
                            "description": "Calcular a matriz de rigidez local [k] = ∑_G w_G [B]_G^T [D] [B]_G det(J)_G, usando 8 pontos de Gauss 2×2×2 com pesos w=1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os dados de entrada: pontos de Gauss, coordenadas dos nós e matriz de material [D]",
                                  "subSteps": [
                                    "Liste os 8 pontos de Gauss no domínio natural ξ, η, ζ ∈ {-1/√3, +1/√3} para a regra de integração 2×2×2.",
                                    "Atribua pesos w_G = 1 para todos os 8 pontos.",
                                    "Defina as coordenadas globais (x_i, y_i, z_i) dos 8 nós do elemento hexaédrico.",
                                    "Calcule a matriz de constitutiva [D] 6×6 para material isotrópico usando E (módulo de Young) e ν (coeficiente de Poisson): D(1,1) = E(1-ν)/((1+ν)(1-2ν)), etc."
                                  ],
                                  "verification": "Verifique se há exatamente 8 pontos com coordenadas corretas (±0.577) e w=1; confirme dimensões de [D] como 6×6 e simetria.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Folha de coordenadas dos nós do elemento",
                                    "Propriedades do material (E, ν)",
                                    "Calculadora ou software (Python/MATLAB)"
                                  ],
                                  "tips": "Use ξ_g = [-1,1,-1,1,-1,1,-1,1]/√3 sistematicamente para evitar erros de listagem.",
                                  "learningObjective": "Entender a configuração da quadratura de Gauss 3D e preparar matrizes constitutivas para integração numérica em EF.",
                                  "commonMistakes": "Esquecer combinações de sinais nos pontos de Gauss; usar fórmula errada para [D] (ex: confundir 2D com 3D)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Para cada ponto Gauss G, calcular as derivadas das funções de forma e a matriz Jacobiana [J]",
                                  "subSteps": [
                                    "Avalie as funções de forma N_i(ξ_g, η_g, ζ_g) e suas derivadas parciais ∂N_i/∂ξ, ∂N_i/∂η, ∂N_i/∂ζ para i=1 a 8.",
                                    "Monte a matriz Jacobiana 3×3: J = [∑ ∂N_i/∂ξ x_i, ∑ ∂N_i/∂ξ y_i, ∑ ∂N_i/∂ξ z_i; ... para η e ζ].",
                                    "Calcule det(J_G) usando determinante de 3×3.",
                                    "Inverta [J] para obter derivadas globais (opcional para [B], mas verifique det(J) > 0).",
                                    "Repita para todos os 8 pontos G."
                                  ],
                                  "verification": "Confirme det(J_G) > 0 para todos G (elemento não distorcido); dimensões [J]=3×3.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Funções de forma hexaédrico: N_i = (1±ξ)(1±η)(1±ζ)/8",
                                    "Script de programação para loop sobre G",
                                    "Matriz de nós"
                                  ],
                                  "tips": "Implemente em loop for G=1:8 para automação; armazene det(J_G) em vetor.",
                                  "learningObjective": "Dominar o mapeamento isoparamétrico e cálculo de Jacobiana em elementos 3D.",
                                  "commonMistakes": "Erro no sinal das funções de forma (±); calcular det(J)=0 (elemento colapsado); esquecer soma sobre nós nas colunas de J."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a matriz de deformação [B]_G para cada ponto Gauss G",
                                  "subSteps": [
                                    "Calcule derivadas globais das funções de forma: ∂N_i/∂x = ∑ (∂N_i/∂r) [J^{-1}]_{r x}, onde r=ξ,η,ζ.",
                                    "Monte [B]_G 6×24: linhas para ε_x,ε_y,ε_z,γ_xy,γ_yz,γ_zx; colunas para u,v,w de cada nó.",
                                    "Exemplo: B(1,3(i-1)+1) = ∂N_i/∂x para deslocamento x do nó i.",
                                    "Verifique simetria e zeros apropriados em [B].",
                                    "Repita para todos os 8 pontos."
                                  ],
                                  "verification": "Dimensões [B]_G = 6×24; norma de [B] condizente com tamanho do elemento.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "[J^{-1}] de step anterior",
                                    "Template de montagem [B] para hexa8",
                                    "Software para operações matriciais"
                                  ],
                                  "tips": "Use vetores de derivadas globais para eficiência; visualize [B] esparsa.",
                                  "learningObjective": "Construir corretamente a matriz strain-displacement [B] em coordenadas globais.",
                                  "commonMistakes": "Ordem errada dos DOFs em colunas (u1,v1,w1,u2,...); não multiplicar por [J^{-1}] corretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular as contribuições locais e somar para obter a matriz de rigidez [k]",
                                  "subSteps": [
                                    "Para cada G, compute [k]_G = w_G [B]_G^T [D] [B]_G det(J_G).",
                                    "Inicialize [k] = zeros(24,24) e some [k] += [k]_G para G=1 a 8.",
                                    "Verifique simetria de [k] (k = (k + k')/2).",
                                    "Escalone [k] se necessário para DOFs.",
                                    "Salve ou plote [k]."
                                  ],
                                  "verification": "[k] 24×24 simétrica com diagonais positivas; traço([k]) > 0.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "[B]_G, [D], det(J_G), w_G de passos anteriores",
                                    "Software para multiplicação matricial eficiente"
                                  ],
                                  "tips": "Use operações matriciais vetorizadas para velocidade; confira com elemento analítico conhecido.",
                                  "learningObjective": "Executar a integração numérica Gauss-Legendre para montar [k] local.",
                                  "commonMistakes": "Esquecer fator w_G ou det(J_G); soma errada (não zerar [k] inicial); perda de simetria por erros numéricos."
                                }
                              ],
                              "practicalExample": "Para um cubo unitário hexaédrico com nós em (0/1,0/1,0/1), E=210 GPa, ν=0.3, os pontos Gauss estão em ±0.577. Após soma, [k]_{11} ≈ 1.40e10 N/m (diagonal u_x do nó 1), matriz totalmente simétrica e positiva definida.",
                              "finalVerifications": [
                                "Matriz [k] é simétrica: |k - k^T| < 1e-10.",
                                "Todos elementos diagonais de [k] positivos.",
                                "Determinante de sub-blocos de [k] positivo (rígida).",
                                "Traço([k]) condizente com rigidez volumétrica E*Volume.",
                                "Comparação com solução analítica para cubo: erro <1%.",
                                "Execução sem erros numéricos (NaN ou Inf)."
                              ],
                              "assessmentCriteria": [
                                "Pontos de Gauss e pesos corretos (8 pontos, w=1).",
                                "Cálculo preciso de det(J_G) >0 para todos G.",
                                "Dimensões corretas: [B] 6×24, [k] 24×24.",
                                "Simetria e positividade de [k] mantidas.",
                                "Eficiência computacional: tempo <1s para 8 pontos em script.",
                                "Código reproduzível e comentado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Quadratura de Gauss-Legendre e determinantes.",
                                "Programação: Loops, arrays multidim e álgebra linear numérica.",
                                "Física: Elasticidade linear isotrópica e teorema trabalho-conjugado.",
                                "Engenharia Computacional: Implementação de solvers FEA."
                              ],
                              "realWorldApplication": "Essa integração é o cerne da montagem de matrizes de rigidez em softwares FEA como ANSYS ou Abaqus para análise de estruturas 3D complexas, como chassis de veículos, turbinas eólicas ou próteses ortopédicas sob cargas reais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.3.1.3.4",
                            "name": "Discutir montagem global",
                            "description": "Explicar como somar as matrizes locais [k] nas posições globais correspondentes aos graus de liberdade dos nós, considerando condições de contorno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o mapeamento nodal local-global",
                                  "subSteps": [
                                    "Identifique os 8 nós do elemento hexaédrico local e seus graus de liberdade (3 por nó: ux, uy, uz).",
                                    "Mapeie cada nó local para o número global correspondente na malha.",
                                    "Crie uma tabela de conectividade que relacione índices locais (1-8) aos globais (ex: nó 1 local -> nó 5 global).",
                                    "Verifique se o mapeamento respeita a topologia da malha inteira.",
                                    "Anote os graus de liberdade globais para cada nó (ex: nó global 5: DoFs 13-15)."
                                  ],
                                  "verification": "Tabela de mapeamento completa e sem erros de indexação, validada manualmente ou por código simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis, diagrama da malha de elementos, software como MATLAB ou Python (NumPy).",
                                  "tips": "Use convenção consistente de numeração nodal (anti-horário ou clockwise) para evitar confusões.",
                                  "learningObjective": "Dominar o mapeamento entre elementos locais e estrutura global.",
                                  "commonMistakes": "Confundir nós locais com globais; ignorar múltiplos DoFs por nó."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar a matriz de rigidez global",
                                  "subSteps": [
                                    "Determine o número total de nós na malha e calcule o tamanho da matriz global (N x N, onde N = total DoFs).",
                                    "Crie uma matriz global zerada com as dimensões corretas.",
                                    "Defina índices de linhas/colunas baseados nos DoFs globais (ex: para nó i, DoFs 3(i-1)+1 a 3i).",
                                    "Salve a matriz em formato esparso se aplicável para eficiência.",
                                    "Confirme simetria e inicialização zero em todas as posições."
                                  ],
                                  "verification": "Matriz global criada com dimensões exatas (ex: 24x24 para 8 nós) e todos elementos zero.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Planilha Excel ou software MEF (ANSYS APDL, código Python/MATLAB).",
                                  "tips": "Use estruturas esparsas desde o início para malhas grandes e economizar memória.",
                                  "learningObjective": "Preparar adequadamente a estrutura de dados para montagem eficiente.",
                                  "commonMistakes": "Erro no cálculo de DoFs totais; inicializar com valores não-zero."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Somar contribuições das matrizes locais [k]",
                                  "subSteps": [
                                    "Para cada elemento e, pegue sua matriz local [k^e] (8x8 para deslocamentos, 24x24 para DoFs).",
                                    "Use a tabela de conectividade para mapear cada entrada k^e_ij para K_global[map(i), map(j)].",
                                    "Some as contribuições: K_global[p,q] += k^e[i,j] para todos i,j.",
                                    "Repita para todos elementos, acumulando sobreposições em nós compartilhados.",
                                    "Monitore o processo com prints ou logs para um elemento teste."
                                  ],
                                  "verification": "Comparar soma em posições compartilhadas entre dois elementos; deve acumular corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código de loop em Python/MATLAB, matrizes locais pré-calculadas.",
                                  "tips": "Implemente em loop sobre elementos para automação; teste com malha de 2 elementos primeiro.",
                                  "learningObjective": "Executar a montagem global por superposição de contribuições locais.",
                                  "commonMistakes": "Índices off-by-one no mapeamento; esquecer de expandir para DoFs vetoriais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incorporar condições de contorno na matriz global",
                                  "subSteps": [
                                    "Identifique DoFs restritos (ex: nós fixos: ux=uy=uz=0).",
                                    "Modifique linhas/colunas correspondentes: defina diagonal como 1 e off-diagonal como 0 (método penalty simples).",
                                    "Ou remova linhas/colunas restritas para reduzir sistema (método direto).",
                                    "Atualize vetor de cargas {F} removendo ou ajustando entradas restritas.",
                                    "Verifique se as restrições preservam simetria e positividade definida.",
                                    "Salve matriz final com condições aplicadas."
                                  ],
                                  "verification": "Simular deslocamentos conhecidos e confirmar que DoFs restritos são zero.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código MEF com função de BCs, exemplos de problemas com apoios.",
                                  "tips": "Use método penalty com fator alto (1e12) para simplicidade em códigos iniciais.",
                                  "learningObjective": "Aplicar corretamente restrições de contorno na montagem global.",
                                  "commonMistakes": "Aplicar BCs antes da montagem (perde contribuições); inconsistência entre K e F."
                                }
                              ],
                              "practicalExample": "Considere uma malha 1D simplificada com 2 barras (análoga a hexa): Elemento 1: nós 1-2, k1 = [[2,-1],[-1,1]]; Elemento 2: nós 2-3, k2 = [[1,-1],[-1,2]]. Mapeamento: nó1->1, nó2->2, nó3->3. Global inicial [[0,0,0],[0,0,0],[0,0,0]]. Após soma: [[2, -1, 0], [-1, 2, -1], [0, -1, 2]]. Com BC nó1 fixo: linha1/col1 ajustada para [[1,0,0], [0,2,-1], [0,-1,2]].",
                              "finalVerifications": [
                                "Matriz global simétrica e com dimensões corretas (N_total_Dofs x N_total_Dofs).",
                                "Posições compartilhadas entre elementos acumulam somas corretas de [k^e].",
                                "DoFs com condições de contorno têm diagonal unitária e zeros off-diagonal.",
                                "Número de não-zeros condiz com conectividade da malha.",
                                "Teste de consistência: multiplicar K por vetor de deslocamentos unitário dá forças esperadas.",
                                "Comparação com solução analítica para malha pequena."
                              ],
                              "assessmentCriteria": [
                                "Precisão no mapeamento nodal (sem erros de indexação).",
                                "Correta acumulação de contribuições em nós compartilhados.",
                                "Aplicação adequada de condições de contorno sem alterar outras entradas.",
                                "Eficiência computacional (uso de esparsidade).",
                                "Capacidade de debugar erros comuns via verificações.",
                                "Explicação clara do processo em relatório ou código comentado.",
                                "Validação numérica com exemplo prático."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra Linear (montagem de matrizes esparsas, operações de soma).",
                                "Programação: Estruturas de dados (arrays multidim, loops indexados), NumPy/MATLAB.",
                                "Física: Mecânica dos Sólidos (equilíbrio estático, rigidez estrutural).",
                                "Computação Científica: Algoritmos de MEF e solvers lineares.",
                                "Engenharia de Software: Modularidade em códigos de simulação."
                              ],
                              "realWorldApplication": "Na análise estrutural de componentes aeronáuticos ou civis, como fuselagem de aviões ou vigas de pontes, onde a montagem global permite simular deformações e tensões em malhas complexas com milhares de elementos, otimizando design e segurança."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.4",
                    "name": "Elemento Hexaédrico de 20 Nós",
                    "description": "Elementos hexaédricos com funções quadráticas, mapeamento isoparamétrico e integração numérica.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.4.1",
                        "name": "Geometria do Elemento Hexaédrico de 20 Nós",
                        "description": "Compreensão da configuração espacial e topológica do elemento hexaédrico com 20 nós, composto por 8 nós nos vértices, 12 nós no meio das arestas, permitindo representação quadrática da geometria e campos.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.1.1",
                            "name": "Identificar e numerar os 20 nós do elemento",
                            "description": "Localizar precisamente os 20 nós do hexaédrico de 20 nós, incluindo os 8 nós de canto (vértices), os 12 nós mid-side nas arestas, e descrever a numeração padrão conforme convenções como a de Cook ou Reddy.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a geometria básica do elemento hexaédrico de 20 nós",
                                  "subSteps": [
                                    "Visualize um hexaédro como um paralelepípedo com 6 faces quadrilaterais, 12 arestas e 8 vértices.",
                                    "Identifique que o elemento de 20 nós inclui 8 nós nos vértices e 12 nós localizados no meio de cada aresta (mid-side nodes).",
                                    "Estude coordenadas locais típicas: vértices em (±1, ±1, ±1), mid-side em posições médias das arestas.",
                                    "Desenhe um esboço 3D simples do hexaédro rotacionando em diferentes ângulos.",
                                    "Compare com elementos de ordem inferior, como hexa8, para destacar a adição dos nós mid-side."
                                  ],
                                  "verification": "Desenhe ou anote corretamente a distribuição: 8 vértices + 12 mid-side = 20 nós totais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Diagrama 3D de hexa20 (impresso ou digital), software de visualização como ParaView ou FreeCAD.",
                                  "tips": "Use cores diferentes para vértices (vermelho) e mid-side (azul) no diagrama para facilitar distinção.",
                                  "learningObjective": "Entender a topologia nodal do hexaédrico de 20 nós.",
                                  "commonMistakes": "Confundir com tetraedros ou ignorar que mid-side são exatamente no centro das arestas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e numerar os 8 nós de vértice (cantos)",
                                  "subSteps": [
                                    "Localize os 8 vértices usando convenção padrão: nó 1 em (-1,-1,-1), nó 2 em (1,-1,-1), etc., seguindo rotação anti-horária nas faces.",
                                    "Trace as faces: face inferior (nós 1-4), superior (5-8), conectando arestas.",
                                    "Numere sequencialmente: 1-4 na base, 5-8 no topo, priorizando direção ξ, η, ζ.",
                                    "Verifique conectividade: cada vértice conecta 3 arestas.",
                                    "Rotacione o modelo mentalmente para confirmar visibilidade de todos os 8."
                                  ],
                                  "verification": "Liste coordenadas e números dos 8 vértices sem erros em uma tabela.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Tabela de numeração padrão (Cook ou Reddy), régua e papel para esboço.",
                                  "tips": "Sempre comece pela origem (-1,-1,-1) como nó 1 para padronizar.",
                                  "learningObjective": "Dominar a numeração dos nós de canto conforme convenções FEA.",
                                  "commonMistakes": "Numerar em ordem horária em vez de anti-horária nas faces."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Localizar e numerar os 12 nós mid-side nas arestas",
                                  "subSteps": [
                                    "Identifique as 12 arestas: 4 na base, 4 no topo, 4 verticais.",
                                    "Posicione mid-side no centro: ex., nó 9 na aresta 1-2 em (0,-1,-1).",
                                    "Siga sequência: nós 9-12 nas arestas da base (1-2,2-3,3-4,4-1), 13-16 no topo, 17-20 verticais.",
                                    "Confira convenção Reddy/Cook: mid-side numerados após vértices, seguindo arestas em ordem.",
                                    "Marque cada mid-side com seta no diagrama para evitar omissões."
                                  ],
                                  "verification": "Anote números e coordenadas exatas dos 12 mid-side nodes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Diagrama detalhado com arestas destacadas, calculadora para coordenadas médias.",
                                  "tips": "Numere mid-side imediatamente após os vértices conectados para manter sequência lógica.",
                                  "learningObjective": "Posicionar precisamente os nós intermediários nas arestas.",
                                  "commonMistakes": "Colocar mid-side em faces ao invés de arestas ou pular arestas verticais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e memorizar a numeração padrão completa (Cook/Reddy)",
                                  "subSteps": [
                                    "Estude tabela padrão: vértices 1-8, mid-side 9-20 em ordem de arestas.",
                                    "Copie a numeração completa em um diagrama rotacionável.",
                                    "Compare com referências: convenção Cook (base-y-z), Reddy (similar com variações locais).",
                                    "Teste recitando números para 5 nós aleatórios.",
                                    "Crie mnemônico: 'Base 1-4 verts +4 mids=9-12; topo similar; verticais fecham'."
                                  ],
                                  "verification": "Numerar todos os 20 nós de memória em menos de 2 minutos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Tabela de referência Cook/Reddy (PDF ou imagem), flashcards digitais.",
                                  "tips": "Use apps como Anki para flashcards com imagens 3D rotativas.",
                                  "learningObjective": "Internalizar a convenção de numeração para uso em meshing FEA.",
                                  "commonMistakes": "Confundir convenções entre autores ou inverter ordem de faces."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar numeração em exemplos variados",
                                  "subSteps": [
                                    "Numere um hexa20 distorcido (não cúbico) mantendo topologia nodal.",
                                    "Use software para visualizar e rotular nós.",
                                    "Compare sua numeração com modelo padrão.",
                                    "Identifique nós em corte seccional (ex: face ξ=1).",
                                    "Repita com 3 geometrias diferentes."
                                  ],
                                  "verification": "Numerar corretamente 20 nós em 2 exemplos independentes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software FEA como Abaqus/ANSYS viewer ou Gmsh para meshing.",
                                  "tips": "Salve imagens numeradas para portfólio de aprendizado.",
                                  "learningObjective": "Aplicar numeração em contextos reais de simulação.",
                                  "commonMistakes": "Alterar numeração em elementos distorcidos, ignorando topologia isoparamétrica."
                                }
                              ],
                              "practicalExample": "Em um cubo unitário de análise de tensão, numere: vértice 1 (-1,-1,-1), 2 (1,-1,-1), ..., 5 (-1,-1,1); mid-side 9 (0,-1,-1) na aresta 1-2. Use no mesher Gmsh para gerar malha hexa20 e visualize nós rotulados.",
                              "finalVerifications": [
                                "Lista completa e correta dos 20 nós com coordenadas locais.",
                                "Diagrama desenhado com todos os nós numerados e rotulado.",
                                "Recitação verbal da numeração padrão sem consulta.",
                                "Identificação correta de nós em diagrama sem rótulos.",
                                "Numeração aplicada em software FEA sem erros.",
                                "Comparação com convenções Cook/Reddy: 100% match."
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização de todos os 20 nós (100% correto).",
                                "Uso correto da convenção padrão (Cook ou Reddy).",
                                "Descrição clara de coordenadas isoparamétricas.",
                                "Capacidade de numerar de memória em <2 min.",
                                "Aplicação em exemplo prático sem assistência.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Geometria analítica e coordenadas paramétricas.",
                                "Programação: Geração de malhas em Python (meshio) ou MATLAB.",
                                "Física: Topologia em mecânica dos sólidos contínuos.",
                                "Design Computacional: Modelagem CAD para meshing."
                              ],
                              "realWorldApplication": "Em simulações FEA de componentes aeronáuticos, como asas de turbinas, a numeração correta dos nós hexa20 garante interpolação precisa de deslocamentos e tensões, evitando erros em análises de fadiga e otimização estrutural."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.2",
                            "name": "Descrever a topologia e conectividade do elemento",
                            "description": "Explicar a conectividade nodal do elemento hexaédrico de 20 nós, incluindo como os nós se conectam para formar faces quadriláteras de 8 nós e o volume completo, destacando a capacidade de distorção geométrica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a estrutura nodal básica do hexaédrico linear de 8 nós",
                                  "subSteps": [
                                    "Identifique os 8 nós de vértice (cantos) em um paralelepípedo retangular.",
                                    "Desenhe um cubo e rotule os nós de 1 a 8 seguindo a convenção padrão (ex: 1 em (0,0,0), 2 em (1,0,0), etc.).",
                                    "Liste as 6 faces quadrilaterais formadas por esses nós.",
                                    "Explique como os nós se conectam via arestas (12 arestas totais).",
                                    "Visualize o volume completo formado pelos 8 nós."
                                  ],
                                  "verification": "Desenhe e rotule corretamente um hexaédrico de 8 nós, identificando todas as faces e arestas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software de visualização como ParaView ou FreeCAD",
                                    "Diagrama de referência de hex8"
                                  ],
                                  "tips": "Use coordenadas locais (ξ, η, ζ) de -1 a 1 para padronizar as posições nodais.",
                                  "learningObjective": "Compreender a topologia fundamental do elemento hexaédrico linear como base para o de 20 nós.",
                                  "commonMistakes": [
                                    "Confundir numeração nodal padrão",
                                    "Ignorar orientação consistente das faces"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir os 12 nós intermediários nas arestas",
                                  "subSteps": [
                                    "Identifique as 12 arestas do hexaédrico de 8 nós.",
                                    "Adicione um nó médio em cada aresta (posição em ξ=0, η=0 ou ζ=0, conforme a aresta).",
                                    "Rotule esses nós de 9 a 20 seguindo convenções padrão (ex: nó 9 médio da aresta 1-2).",
                                    "Verifique que o total é 20 nós: 8 vértices + 12 mids.",
                                    "Desenhe o elemento atualizado destacando as arestas com nós mids."
                                  ],
                                  "verification": "Liste e posicione corretamente os 12 nós mids em um diagrama rotulado.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de mesh como Gmsh",
                                    "Tabela de numeração nodal hex20",
                                    "Vídeos tutoriais sobre elementos quadráticos"
                                  ],
                                  "tips": "Mantenha a numeração consistente: mids seguem a ordem das arestas conectando vértices pares.",
                                  "learningObjective": "Dominar a localização e numeração dos nós de aresta intermediários.",
                                  "commonMistakes": [
                                    "Colocar nós mids incorretamente em faces ao invés de arestas",
                                    "Erro na contagem total de nós"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever a conectividade das faces quadrilaterais de 8 nós",
                                  "subSteps": [
                                    "Selecione uma face (ex: face inferior: nós 1,2,3,4 corners + mids 9,10,11,12).",
                                    "Explique a conectividade: cada face forma um quad8 com 4 corners e 4 mids nas bordas.",
                                    "Repita para todas as 6 faces, listando os nós conectados em ordem clockwise/counterclockwise.",
                                    "Desenhe uma face expandida mostrando como mids curvam as bordas.",
                                    "Discuta interpolação quadrática nas faces."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito a conectividade nodal completa de pelo menos 3 faces diferentes.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Diagramas de faces hex20",
                                    "Calculadora para funções de forma",
                                    "Livro de elementos finitos (ex: Bathe)"
                                  ],
                                  "tips": "Use convenção de rotação consistente para listagem nodal em faces.",
                                  "learningObjective": "Explicar como os 20 nós se conectam para formar 6 faces quadráticas deformáveis.",
                                  "commonMistakes": [
                                    "Esquecer mids em faces opostas",
                                    "Inverter ordem nodal causando orientação errada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar a conectividade volumétrica completa e distorção geométrica",
                                  "subSteps": [
                                    "Liste todos os 20 nós e suas coordenadas paramétricas (ξ,η,ζ).",
                                    "Descreva como faces se conectam via arestas compartilhadas para formar o volume.",
                                    "Explique capacidade de distorção: mids permitem modelar curvaturas e irregularidades sem distorção excessiva.",
                                    "Simule uma distorção (ex: torção) e observe mapeamento isoparamétrico.",
                                    "Compare com hex8 para destacar melhorias em precisão."
                                  ],
                                  "verification": "Crie um diagrama 3D completo do hex20 com todas conexões e descreva distorção em um parágrafo.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software FEA como Abaqus/ANSYS viewer",
                                    "Modelos 3D imprimíveis ou STL de hex20",
                                    "Artigos sobre elementos isoparamétricos"
                                  ],
                                  "tips": "Visualize em 3D rotacionando o modelo para confirmar conectividades.",
                                  "learningObjective": "Descrever integralmente a topologia 3D e capacidade de deformação do elemento.",
                                  "commonMistakes": [
                                    "Subestimar papel dos mids na distorção volumétrica",
                                    "Confundir com elementos de 27 nós (com centro)"
                                  ]
                                }
                              ],
                              "practicalExample": "Usando Gmsh, crie uma malha com um único elemento hex20, visualize os nós numerados, distorça as coordenadas dos nós mids para simular uma viga torcida e exporte uma imagem rotulada mostrando faces de 8 nós conectadas.",
                              "finalVerifications": [
                                "Pode rotular corretamente todos os 20 nós em um diagrama 3D.",
                                "Lista a conectividade nodal de qualquer face escolhida.",
                                "Explica verbalmente como mids permitem distorção sem perda de qualidade.",
                                "Compara hex20 vs hex8 em termos de topologia.",
                                "Desenha uma representação isoparamétrica distorcida.",
                                "Identifica arestas compartilhadas entre faces adjacentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na numeração e posicionamento nodal (20/20 nós corretos).",
                                "Clareza na descrição de conectividade de faces (todas 6 faces mapeadas).",
                                "Compreensão demonstrada de distorção geométrica via exemplo prático.",
                                "Uso correto de terminologia (nodal, isoparamétrico, mids de aresta).",
                                "Capacidade de visualização 3D e explicação volumétrica.",
                                "Identificação de pelo menos 3 vantagens topológicas do hex20."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Geometria paramétrica e funções de interpolação quadráticas.",
                                "Programação: Geração de malhas em bibliotecas como Gmsh API ou FEniCS.",
                                "Física: Modelagem de deformações em sólidos elásticos.",
                                "Design Computacional: Topologia em CAD para simulações FEA."
                              ],
                              "realWorldApplication": "Em análises de elementos finitos para estruturas aeroespaciais, como painéis de asas deformados, onde o hex20 modela precisamente curvaturas e torções sem malhas excessivamente refinadas, otimizando simulações em software como NASTRAN."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.3",
                            "name": "Visualizar o elemento no domínio físico e pai",
                            "description": "Representar graficamente o hexaédrico de 20 nós em sua forma retangular ideal e distorcida, comparando com o cubo pai no espaço isoparamétrico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o domínio pai: Cubo isoparamétrico",
                                  "subSteps": [
                                    "Defina as coordenadas isoparamétricas (ξ, η, ζ) variando de -1 a 1.",
                                    "Desenhe o cubo unitário com 8 vértices nos cantos (±1, ±1, ±1).",
                                    "Identifique os 12 nós intermediários nas arestas para o hexaédrico de 20 nós.",
                                    "Marque os 8 nós nas faces (midpoints).",
                                    "Explique o papel do mapeamento isoparamétrico."
                                  ],
                                  "verification": "Desenho completo do cubo com todos os 20 nós numerados corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel quadriculado, lápis, régua, software de desenho como GeoGebra ou SketchUp.",
                                  "tips": "Use cores diferentes para vértices, arestas e faces para clareza.",
                                  "learningObjective": "Compreender a geometria padrão do domínio pai e localização dos nós.",
                                  "commonMistakes": "Confundir nós de aresta com nós de face; esquecer variação de -1 a 1."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Representar graficamente o hexaédrico retangular ideal no domínio físico",
                                  "subSteps": [
                                    "Mapeie os nós do cubo pai para um paralelepípedo retangular (ex: dimensões 2x1x3).",
                                    "Posicione os 8 vértices nos cantos retangulares.",
                                    "Adicione nós intermediários nas arestas (midpoints).",
                                    "Coloque nós centrais nas faces.",
                                    "Desenhe todas as arestas e faces conectadas."
                                  ],
                                  "verification": "Diagrama mostra mapeamento 1:1 com dimensões retangulares preservadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel, lápis, software CAD como FreeCAD ou MATLAB para plotagem.",
                                  "tips": "Mantenha ângulos retos para 'ideal'; use escala uniforme.",
                                  "learningObjective": "Visualizar transformação bilinear do domínio pai para forma ideal física.",
                                  "commonMistakes": "Distorcer acidentalmente o retângulo; numerar nós incorretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Representar o hexaédrico distorcido no domínio físico",
                                  "subSteps": [
                                    "Escolha uma distorção realista (ex: cisalhamento em uma direção).",
                                    "Mapeie nós do cubo pai para posições distorcidas no espaço físico.",
                                    "Ajuste posições de nós de aresta e face para manter conectividade.",
                                    "Desenhe faces não-planas e arestas curvas se aplicável.",
                                    "Compare visualmente com a forma ideal."
                                  ],
                                  "verification": "Diagrama distorcido mantém topologia de 20 nós, mas formas irregulares.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de visualização 3D como ParaView ou Blender; papel para esboço.",
                                  "tips": "Use vetores para mostrar deslocamentos de nós; evite sobreposições.",
                                  "learningObjective": "Entender como distorções afetam a geometria física sem alterar domínio pai.",
                                  "commonMistakes": "Perder conectividade de nós; exagerar distorção além do limite jacobiano."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar domínios pai e físico e destacar diferenças",
                                  "subSteps": [
                                    "Desenhe side-by-side: cubo pai, ideal físico e distorcido.",
                                    "Use setas para mapear cada nó correspondente.",
                                    "Calcule e anote funções de interpolação para pelo menos uma direção.",
                                    "Discuta impacto na integração numérica (Jacobiano).",
                                    "Crie uma tabela resumindo coordenadas."
                                  ],
                                  "verification": "Gráfico comparativo com legendas e mapeamentos corretos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Planilha Excel para tabela; software de plotagem como Python Matplotlib.",
                                  "tips": "Inclua zoom em regiões críticas como arestas distorcidas.",
                                  "learningObjective": "Comparar visualmente domínios e compreender mapeamento isoparamétrico.",
                                  "commonMistakes": "Ignorar inversão de orientação; mapear nós errados."
                                }
                              ],
                              "practicalExample": "Em uma simulação de tensão em uma viga de motor automotivo, visualize o hexaédrico de 20 nós mapeando o cubo pai para a geometria distorcida da peça fundida, permitindo análise precisa de deformações.",
                              "finalVerifications": [
                                "Pode desenhar o cubo pai com 20 nós corretos.",
                                "Representa hexaédrico ideal retangular sem distorções.",
                                "Cria representação distorcida mantendo topologia.",
                                "Compara domínios com mapeamento nodal preciso.",
                                "Explica verbalmente diferenças geométricas.",
                                "Identifica potenciais problemas de qualidade do elemento."
                              ],
                              "assessmentCriteria": [
                                "Precisão na localização e numeração dos 20 nós (30%).",
                                "Clareza gráfica e legibilidade dos desenhos (25%).",
                                "Correção do mapeamento isoparamétrico (20%).",
                                "Compreensão de distorções e impactos (15%).",
                                "Uso efetivo de ferramentas e anotações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Geometria analítica e transformações afins.",
                                "Computação: Visualização 3D e programação em Python/MATLAB para plots.",
                                "Física: Mecânica dos sólidos e deformações.",
                                "Desenho Técnico: Projeções ortográficas e CAD."
                              ],
                              "realWorldApplication": "Na engenharia mecânica, essa visualização é essencial para mesh de qualidade em análises FEA de componentes como turbinas ou chassis veiculares, garantindo simulações precisas de tensões e evitando erros de distorção excessiva."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.2",
                        "name": "Funções de Interpolação Quadráticas",
                        "description": "Definição e propriedades das funções de forma (shape functions) de segunda ordem para interpolação de geometria e variáveis de campo no elemento hexaédrico de 20 nós, baseadas em polinômios de Lagrange.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.2.1",
                            "name": "Derivar funções de forma para nós de canto",
                            "description": "Obter as funções de forma quadráticas N_i(r,s,t) para os 8 nós de canto usando produtos de funções 1D de Lagrange de segunda ordem: (1-ξ)(1-η)(1-ζ)/4 adaptado para quadrático.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Derivar funções de Lagrange 1D quadráticas para nós de canto",
                                  "subSteps": [
                                    "Identificar os nós do elemento 1D quadrático: ξ = -1 (canto esquerdo), ξ = 0 (meio), ξ = +1 (canto direito).",
                                    "Aplicar a fórmula geral de Lagrange para o nó ξ = -1: L_{-1}(ξ) = [(ξ - 0)(ξ - 1)] / [(-1 - 0)(-1 - 1)] = ξ(ξ - 1)/2.",
                                    "Derivar para o nó ξ = +1: L_{+1}(ξ) = [(ξ + 1)(ξ - 0)] / [(1 + 1)(1 - 0)] = ξ(ξ + 1)/2.",
                                    "Verificar: L_{-1}(-1) = 1, L_{-1}(0) = 0, L_{-1}(1) = 0; similar para L_{+1}.",
                                    "Notar que essas são funções quadráticas específicas para cantos, zerando no nó médio."
                                  ],
                                  "verification": "Escrever corretamente L_{-1}(ξ) = ξ(ξ - 1)/2 e L_{+1}(ξ) = ξ(ξ + 1)/2, com verificações numéricas nos três nós.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora",
                                    "Referência de Elementos Finitos (capítulo de funções de forma)"
                                  ],
                                  "tips": "Use a fórmula geral de Lagrange passo a passo para evitar erros aritméticos nos denominadores.",
                                  "learningObjective": "Compreender e derivar funções de base Lagrange quadráticas 1D para nós de canto.",
                                  "commonMistakes": [
                                    "Confundir numerador com diferenças erradas.",
                                    "Esquecer o sinal negativo nos denominadores.",
                                    "Não verificar valores nos nós."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir função de forma 3D para um nó de canto específico",
                                  "subSteps": [
                                    "Escolher o nó de canto ( -1, -1, -1 ) e definir N_1(r, s, t) = L_{-1}(r) × L_{-1}(s) × L_{-1}(t).",
                                    "Substituir: N_1(r, s, t) = [r(r - 1)/2] × [s(s - 1)/2] × [t(t - 1)/2] = [r(r - 1) s(s - 1) t(t - 1)] / 8.",
                                    "Relacionar com a forma dada: adaptar (1 - r)(1 - s)(1 - t)/4 observando que é equivalente após expansão para quadrático.",
                                    "Expandir ou simplificar a expressão para forma polinomial explícita se necessário.",
                                    "Verificar no nó próprio: N_1(-1, -1, -1) = 1."
                                  ],
                                  "verification": "Derivar e anotar N_1(r, s, t) corretamente, confirmando N_1(-1, -1, -1) = 1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora",
                                    "Software simbólico como Mathematica ou SymPy (opcional)"
                                  ],
                                  "tips": "Mantenha as coordenadas naturais ξ, η, ζ ≡ r, s, t para consistência.",
                                  "learningObjective": "Aplicar produto tensorial para gerar funções de forma 3D a partir de 1D.",
                                  "commonMistakes": [
                                    "Erro no fator 1/8 (confundir com linear /8 sem quadrático).",
                                    "Não combinar corretamente os termos quadráticos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar propriedades da função para o nó específico",
                                  "subSteps": [
                                    "Testar em outros nós de canto, ex.: N_1(1, -1, -1) = L_{+1}(-1 no r? Espera L_{-1}(1) = 1(0)/2 = 0.",
                                    "Verificar em nós midside, ex.: r=0, s=-1, t=-1: L_{-1}(0)=0.",
                                    "Confirmar grau polinomial: grau 2 em cada variável (produto de quadráticas).",
                                    "Verificar partição de unidade parcial (com outras funções).",
                                    "Plotar ou tabular valores em pontos Gauss para inspeção visual."
                                  ],
                                  "verification": "Tabela com valores em pelo menos 4 outros nós mostrando 0, e confirmação do grau 2.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora",
                                    "Planilha Excel para tabulação"
                                  ],
                                  "tips": "Crie uma tabela de coordenadas vs. N_1 para visualização rápida.",
                                  "learningObjective": "Validar funções de forma quanto a interpolação delta e consistência.",
                                  "commonMistakes": [
                                    "Achar que vale 1 em midsides.",
                                    "Ignorar fator de normalização."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Generalizar para os 8 nós de canto",
                                  "subSteps": [
                                    "Identificar combinações de sinais para 8 cantos: todos ±1 em (r,s,t).",
                                    "Definir N_i com sinais apropriados: para cada direção, usar L_{-1} ou L_{+1} conforme posição do nó.",
                                    "Exemplo para (1,1,1): N_8 = L_{+1}(r) L_{+1}(s) L_{+1}(t) = [r(r+1)/2]^3 / algo wait 1/8 r(r+1)s(s+1)t(t+1).",
                                    "Escrever forma geral: N_i = (1/8) ∏ [u(u - σ_i)/2 ] onde σ_i = ±1 por direção, adaptando.",
                                    "Verificar soma ou propriedade em um ponto interno."
                                  ],
                                  "verification": "Listar as 8 funções N_i com formas corretas e verificar uma em nó próprio/outro.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Tabela de nós do hex20"
                                  ],
                                  "tips": "Use notação com ξ_i = ±1 para generalizar: produto sobre direções.",
                                  "learningObjective": "Estender derivação para todos os nós de canto via padrões de sinais.",
                                  "commonMistakes": [
                                    "Inverter sinais para L_{+1} vs L_{-1}.",
                                    "Perder o /8 no produto."
                                  ]
                                }
                              ],
                              "practicalExample": "Para o nó 1 em (-1,-1,-1), derive N_1(r,s,t) = [r(r-1)s(s-1)t(t-1)]/8. Verifique: N_1(-1,-1,-1)=[(-1)(-2)]^3 /8 = (2)^3 /8=1; N_1(1,-1,-1)=[1(0)...]/8=0. Adapte à forma (1-r)(1-s)(1-t)/4 expandindo quadraticamente para matching.",
                              "finalVerifications": [
                                "Cada N_i avalia 1 em seu nó de canto e 0 nos outros 7 cantos.",
                                "N_i = 0 em todos os 12 nós midside.",
                                "Cada função é polinômio completo de grau 2 em r,s,t.",
                                "Normalização correta com fator 1/8 do produto.",
                                "Consistência com adaptação quadrática da forma linear /4 ou /8."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações 1D e produto 3D.",
                                "Verificações completas de valores nos nós.",
                                "Generalização correta para os 8 nós com sinais apropriados.",
                                "Compreensão da adaptação da forma linear para quadrática.",
                                "Identificação de propriedades essenciais (delta, grau)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Interpolação polinomial e produtos tensorais.",
                                "Programação: Codificação em Python/MATLAB para avaliação de N_i.",
                                "Física: Modelagem de campos escalares (deslocamentos) em sólidos.",
                                "Engenharia de Computação: Integração numérica em elementos finitos."
                              ],
                              "realWorldApplication": "Usadas em análises de elementos finitos para simular tensões e deformações em componentes mecânicos 3D, como turbinas de aviões ou chassis de veículos em softwares como ANSYS, garantindo precisão quadrática na interpolação de campos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.2",
                            "name": "Derivar funções de forma para nós de aresta",
                            "description": "Calcular as funções de forma para os 12 nós mid-side, como 4ξ(1-ξ)(1-η)(1-ζ)/2 para o nó médio da aresta ξ=0.5, garantindo interpolação exata em todos os nós.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar coordenadas nodais e requisitos das funções de forma",
                                  "subSteps": [
                                    "Identificar as coordenadas naturais dos 20 nós do elemento hexaédrico: 8 vértices (±1,±1,±1), 12 nós mid-side (ex: ξ=±1, η=0, ζ=0).",
                                    "Listar os 12 nós mid-side específicos: 4 arestas paralelas a ξ (η,ζ=±1 ou 0? Espera, midsides são mids das 12 arestas: ex. ξ=0, η=±1, ζ=±1; não, para hexa20 serendipity: midsides em faces? Não, hexa20 tem mids em arestas.",
                                    "Confirmar propriedades: N_i(ξ_j,η_j,ζ_j)=δ_ij (Kronecker), partição da unidade ∑N_i=1.",
                                    "Estudar funções lineares e quadráticas 1D para base.",
                                    "Sketch o elemento e label todos os nós mid-side."
                                  ],
                                  "verification": "Lista completa de coordenadas dos 12 nós mid-side e diagrama sketchado com labels corretos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Elementos Finitos (Zienkiewicz ou Bathe)",
                                    "Papel e caneta para sketch",
                                    "Software MATLAB ou Python para coordenadas"
                                  ],
                                  "tips": "Use simetria do cubo para agrupar nós equivalentes por direção (ξ,η,ζ).",
                                  "learningObjective": "Compreender posições exatas e requisitos matemáticos das funções de forma para nós mid-side.",
                                  "commonMistakes": [
                                    "Confundir midside com face centers (hexa27 tem 6 mids faces)",
                                    "Esquecer coordenadas serendipity: mids em arestas só, não faces internas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar função de forma 1D quadrática para nó mid-side",
                                  "subSteps": [
                                    "Recordar polinômio quadrático 1D: N(ξ) = a + bξ + cξ².",
                                    "Impor condições: N(-1)=0, N(1)=0, N(0)=1 para nó mid ξ=0.",
                                    "Resolver sistema: leva a N(ξ)= (1/2)(1-ξ²).",
                                    "Verificar para ξ=±1:0, ξ=0:1.",
                                    "Generalizar para mids em ξ=±1? Não, mids são internos nas arestas."
                                  ],
                                  "verification": "Função 1D N_mid(ξ) = 0.5(1-ξ²) testada nos 3 pontos nodais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora simbólica (SymPy ou Mathematica)",
                                    "Folha de equações"
                                  ],
                                  "tips": "Sempre imponha condições nos nós Kronecker sequencialmente para evitar erros algébricos.",
                                  "learningObjective": "Dominar derivação de funções de forma mid-side em 1D como base para 3D.",
                                  "commonMistakes": [
                                    "Usar Lagrange completo de 3 pontos sem simplificar para serendipity",
                                    "Normalização errada: soma não 1 com lineares."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estender para funções 3D mid-side em arestas paralelas a ξ",
                                  "subSteps": [
                                    "Para nó mid-side em aresta ξ-dir, ex: ξ=0, η=1, ζ=1: N = 4ξ(1-ξ)(1-η)(1-ζ)/2? Ajustar exemplo dado.",
                                    "Forma geral: N^{ξ-mid} = [1D mid ξ] * [1D linear η no fim] * [1D linear ζ no fim].",
                                    "Exemplo dado corrigir: para mid ξ=0.5? Padrão é ξ=0 para mid em [-1,1].",
                                    "Derivar para 4 nós: ξ-dir mids em combinações η=±1,ζ=±1 com ξ=0.",
                                    "Simplificar: N = 0.5(1-ξ²) * 0.5(1±η) * 0.5(1±ζ)."
                                  ],
                                  "verification": "Calcular N em seu nó=1, em vértices adj=0, outros mids=0.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software simbólico para expandir polinômios",
                                    "Tabela de funções lineares 1D"
                                  ],
                                  "tips": "Multiplique funções 1D separáveis: mid-only na dir da aresta, linear nas transversais.",
                                  "learningObjective": "Construir funções 3D mid-side usando produto tensorial para arestas ξ.",
                                  "commonMistakes": [
                                    "Incluir termo quadrático nas dirs transversais (isso seria face mid)",
                                    "Fator errado: use 1/2 para linear (1+ξ), 1/2(1-ξ²) mid."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar funções para arestas paralelas a η e ζ por simetria",
                                  "subSteps": [
                                    "Ciclar coordenadas: para η-dir mids (η=0, ξ=±1,ζ=±1): N=0.5(1-η²)*0.5(1±ξ)*0.5(1±ζ).",
                                    "Similar para ζ-dir: 4 grupos de 4 nós cada, total 12.",
                                    "Escrever fórmulas explícitas para todos 12, ex: nó (0,1,1): 0.5(1-ξ²)*0.5(1+η)*0.5(1+ζ).",
                                    "Verificar normalização local em cada aresta.",
                                    "Tabular todas as 12 funções."
                                  ],
                                  "verification": "Tabela com 12 funções, cada uma testada em pelo menos 5 pontos nodais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha Excel ou LaTeX para tabela",
                                    "Código Python para verify"
                                  ],
                                  "tips": "Use permutações cíclicas ξ→η→ζ para evitar rederivação manual.",
                                  "learningObjective": "Generalizar derivação por simetria para todas direções de arestas.",
                                  "commonMistakes": [
                                    "Assinaturas erradas nos termos lineares (±)",
                                    "Confundir ordem: mid sempre na dir variável da aresta."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar interpolação exata em todos os 20 nós",
                                  "subSteps": [
                                    "Testar cada uma das 12 funções nos 20 nós: deve ser 0 em todos exceto seu próprio.",
                                    "Verificar partição da unidade: soma todas N_vertex + N_midside =1 em qualquer ponto Gauss ou nó.",
                                    "Plotar superfícies das funções em software.",
                                    "Comparar com referências literárias (ex: Cook membrane ou Bathe).",
                                    "Documentar desvios zero."
                                  ],
                                  "verification": "Relatório com testes numéricos/symbolicos mostrando δ_ij para todas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB/Octave script para avaliação em grid",
                                    "Referência: 'Finite Element Procedures' Bathe"
                                  ],
                                  "tips": "Automatize verificações com loop sobre nós para eficiência.",
                                  "learningObjective": "Validar rigorosamente as funções derivadas para uso em MEF.",
                                  "commonMistakes": [
                                    "Não testar em nós não-adjacentes",
                                    "Ignorar soma=1 requer todas funções incluindo vértices."
                                  ]
                                }
                              ],
                              "practicalExample": "Para o nó mid-side em ξ=0, η=1, ζ=1: derive N = ½(1-ξ²) × ½(1+η) × ½(1+ζ). Verifique: no nó (0,1,1): ½(1-0)×½(2)×½(2)=1; em vértice (-1,1,1): ½(1-1)×...=0; em mid adjacente η=0: ½(1+0)=0.5 mas ajustado total 0.",
                              "finalVerifications": [
                                "Cada função mid-side =1 em seu nó e =0 nos outros 19 nós.",
                                "Soma de todas 20 funções de forma =1 em vértices, mids e pontos internos.",
                                "Gradientes consistentes com quadrático ao longo da aresta.",
                                "Simetria preservada sob reflexões do cubo.",
                                "Coincide com fórmulas padrão em literatura MEF.",
                                "Avaliação em pontos de Gauss de ordem 2 exata."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica nas expressões derivadas (sem erros de fator).",
                                "Completude: todas 12 funções listadas corretamente.",
                                "Validações numéricas/symbolicas em ≥80% dos nós.",
                                "Uso correto de produto tensorial 1D→3D.",
                                "Clareza na documentação e tabela final.",
                                "Identificação de simetrias para eficiência."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Interpolação de Lagrange e polinômios ortogonais.",
                                "Programação: Implementação em códigos FEA (Abaqus UMAT ou FEniCS).",
                                "Álgebra Linear: Bases nodais e matriz de conectividade.",
                                "Física: Aproximação de campos em mecânica dos sólidos.",
                                "Visualização: Plot 3D de superfícies N_i em Paraview."
                              ],
                              "realWorldApplication": "Essas funções são essenciais em análises FEA de estruturas 3D como vigas, placas e cascas, garantindo interpolação quadrática precisa de deslocamentos e tensões ao longo das arestas, melhorando precisão em simulações de crash automotivo ou análise de turbinas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.4.2.3",
                            "name": "Verificar propriedades das funções de forma",
                            "description": "Demonstrar que as funções N_i satisfazem partição da unidade (∑N_i=1), δ_i (N_i=1 no nó i, 0 nos outros) e continuidade C0 entre elementos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o elemento hexaédrico de 20 nós e suas funções de forma quadráticas",
                                  "subSteps": [
                                    "Identifique a geometria padrão do elemento hexaédrico de 20 nós em coordenadas naturais (ξ, η, ζ) ∈ [-1,1]³.",
                                    "Liste os 20 nós e suas coordenadas associadas (8 vértices, 12 arestas).",
                                    "Escreva as funções de forma N_i(ξ,η,ζ) baseadas em polinômios de Lagrange quadráticos para cada tipo de nó.",
                                    "Implemente ou derive uma função para avaliar N_i em pontos arbitrários.",
                                    "Valide a configuração comparando com referências padrão de literatura em MEF."
                                  ],
                                  "verification": "Confirme que as funções N_i estão corretamente definidas para todos os 20 nós e coincidem com fórmulas padrão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Elementos Finitos (ex: Zienkiewicz)",
                                    "Software MATLAB/Python com sympy ou numpy",
                                    "Papel quadriculado para esboços"
                                  ],
                                  "tips": "Use coordenadas naturais para simplificar; comece pelos nós vértices antes das arestas.",
                                  "learningObjective": "Dominar a definição e representação das funções de interpolação quadráticas para hexaédrico 20 nós.",
                                  "commonMistakes": "Confundir ordem dos nós ou esquecer termos quadráticos nas funções de Lagrange."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar a propriedade de partição da unidade (∑N_i = 1)",
                                  "subSteps": [
                                    "Selecione pontos de avaliação representativos: centro do elemento (0,0,0), Gauss points e nós.",
                                    "Calcule a soma ∑_{i=1}^{20} N_i(ξ,η,ζ) analiticamente ou numericamente em cada ponto.",
                                    "Derive ou prove que a soma resulta em 1 para qualquer ponto no domínio [-1,1]³ devido à base de Lagrange completa.",
                                    "Implemente um script para avaliar a soma em uma malha de pontos e plote o erro |∑N_i - 1|.",
                                    "Analise numericamente a precisão (erro < 10^{-10})."
                                  ],
                                  "verification": "A soma ∑N_i deve ser exatamente 1 (ou com erro numérico desprezível) em todos os pontos testados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "MATLAB/Python/Jupyter Notebook",
                                    "Documentação de funções de forma hexa20",
                                    "Calculadora simbólica (SymPy)"
                                  ],
                                  "tips": "Aproveite simetria do elemento para reduzir cálculos; use expansão em série de polinômios.",
                                  "learningObjective": "Demonstrar que as funções de forma reproduzem campos constantes corretamente.",
                                  "commonMistakes": "Erro de arredondamento em computação numérica; não testar pontos suficientes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a propriedade delta de Kronecker (δ_i: N_i=1 no nó i, 0 nos outros)",
                                  "subSteps": [
                                    "Para cada nó j=1 a 20, avalie N_i(ξ_j,η_j,ζ_j) para todos i=1 a 20.",
                                    "Confirme N_j(ξ_j,η_j,ζ_j) = 1 e N_i(ξ_j,η_j,ζ_j) = 0 para i ≠ j.",
                                    "Faça isso analiticamente para um subconjunto (ex: vértices) e numericamente para todos.",
                                    "Crie uma matriz de interpolação e verifique se é identidade nas coordenadas nodais.",
                                    "Documente resultados em tabela para todos os nós."
                                  ],
                                  "verification": "Matriz de avaliação nos nós deve ser a identidade 20x20.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Planilha Excel ou Pandas para tabela",
                                    "Código Python para automação",
                                    "Referência nodal do elemento"
                                  ],
                                  "tips": "Automatize com loop sobre nós; foque em nós de aresta que têm funções mais complexas.",
                                  "learningObjective": "Entender como funções de forma interpolam valores nodais exatamente.",
                                  "commonMistakes": "Índices errados de nós; confundir nós de vértice com mid-side."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar continuidade C0 entre elementos adjacentes",
                                  "subSteps": [
                                    "Monte dois elementos hexa20 adjacentes compartilhando uma face (4 nós vértices + 8 mid-side).",
                                    "Avalie funções de forma na face compartilhada de ambos os lados em pontos coincidentes.",
                                    "Confirme que N_i coincide nos nós compartilhados e é contínua (mesmo valor) ao longo da face.",
                                    "Verifique derivadas normais podem ser descontínuas (característica C0).",
                                    "Teste numericamente em malha simples e discuta implicações para convergência MEF."
                                  ],
                                  "verification": "Valores de N_i idênticos na interface de ambos os elementos; plot de continuidade.",
                                  "estimatedTime": "55 minutos",
                                  "materials": [
                                    "Software FEA como Gmsh/FreeFEM para visualização",
                                    "Python com meshio",
                                    "Diagrama de malha adjacente"
                                  ],
                                  "tips": "Use uma face simples (ξ=1) para testes iniciais; visualize com contour plots.",
                                  "learningObjective": "Compreender a continuidade inter-elementar essencial para MEF C0.",
                                  "commonMistakes": "Não alinhar nós corretamente na interface; assumir C1 indevidamente."
                                }
                              ],
                              "practicalExample": "Em um hexaédrico de 20 nós padronizado, no centro (0,0,0), calcule ∑N_i: devido à partição, deve ser 1. No nó 1 (ξ=1,η=1,ζ=1), N_1=1 e demais=0. Na face compartilhada com elemento adjacente, N_5 (mid-side) deve coincidir em ambos.",
                              "finalVerifications": [
                                "Soma ∑N_i =1 em 10 pontos arbitrários com erro <10^{-12}.",
                                "Propriedade delta confirmada para todos 20 nós via tabela ou matriz identidade.",
                                "Continuidade C0 verificada em face adjacente com plot de valores coincidentes.",
                                "Relatório escrito explicando provas analíticas para partição e delta.",
                                "Script numérico reproduzível para todas verificações.",
                                "Discussão de erros numéricos observados e causas."
                              ],
                              "assessmentCriteria": [
                                "Precisão e correção dos cálculos analíticos e numéricos (peso 30%).",
                                "Completude das verificações em todos os aspectos (partição, delta, C0) (25%).",
                                "Clareza na documentação, tabelas e plots (20%).",
                                "Uso adequado de ferramentas computacionais (15%).",
                                "Análise de erros comuns e implicações em MEF (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de polinômios de Lagrange e bases completas.",
                                "Programação: Implementação numérica em Python/MATLAB para validação.",
                                "Física: Aproximação de campos contínuos em mecânica dos sólidos.",
                                "Computação Gráfica: Interpolação em malhas 3D para visualização.",
                                "Estatística: Análise de erros numéricos em simulações."
                              ],
                              "realWorldApplication": "Garante a consistência e convergência em simulações de Elementos Finitos para análise de tensões em peças automotivas ou aeroespaciais, evitando erros em predições de deformações e falhas estruturais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.2.1",
                              "10.1.5.4.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.3",
                        "name": "Mapeamento Isoparamétrico",
                        "description": "Transformação do elemento pai cúbico [-1,1]^3 para o hexaédrico físico arbitrógeno de 20 nós, incluindo cálculo do Jacobiano para derivadas e integração.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.3.1",
                            "name": "Definir o mapeamento de coordenadas",
                            "description": "Escrever x(r,s,t) = ∑ N_i(r,s,t) x_i, similar para y e z, onde N_i são funções quadráticas, mapeando o cubo pai para o hexaédrico distorcido.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o cubo pai e coordenadas isoparamétricas",
                                  "subSteps": [
                                    "Revise as coordenadas naturais (r, s, t) variando de -1 a 1 no domínio do cubo pai.",
                                    "Desenhe o cubo unitário [-1,1]^3 e marque os vértices principais.",
                                    "Explique como o cubo pai serve como referência para mapeamento isoparamétrico.",
                                    "Identifique vantagens do domínio isoparamétrico sobre coordenadas reais.",
                                    "Liste as propriedades desejadas do mapeamento: bijetivo, suave e invertível."
                                  ],
                                  "verification": "Desenhe corretamente o cubo pai com coordenadas e liste 3 propriedades chave.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel, lápis, livro de elementos finitos (capítulo de isoparamétricos).",
                                  "tips": "Use um cubo físico ou software como GeoGebra para visualizar o domínio.",
                                  "learningObjective": "Compreender o papel do cubo pai no mapeamento isoparamétrico.",
                                  "commonMistakes": "Confundir limites (-1 a 1) com (0 a 1); ignorar a necessidade de invertibilidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar nós e funções de forma N_i para hexaédrico de 20 nós",
                                  "subSteps": [
                                    "Liste os 20 nós: 8 vértices, 12 arestas (meio) e nenhum face/centro para ser quadratico completo.",
                                    "Derive ou memorize funções de forma quadráticas N_i(r,s,t) para vértices (ex: N1 = (1-r)(1-s)(1-t)/8 * (r+s+t-1) ajustado).",
                                    "Escreva expressões para nós de aresta, como meio de aresta paralela a r.",
                                    "Verifique que soma N_i(r,s,t) = 1 para todo (r,s,t) no cubo pai.",
                                    "Plote 2-3 funções N_i em seções 2D para intuição."
                                  ],
                                  "verification": "Escreva corretamente pelo menos 4 funções N_i e confirme partição da unidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Tabela de funções de forma de referência, MATLAB/Mathematica para plotagem.",
                                  "tips": "Comece com elemento serendípito de 20 nós; use simetria para derivar N_i.",
                                  "learningObjective": "Dominar funções de interpolação quadráticas para 20 nós.",
                                  "commonMistakes": "Usar funções lineares (8 nós) em vez de quadráticas; erro em coeficientes binomiais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir expressões de mapeamento x(r,s,t), y(r,s,t), z(r,s,t)",
                                  "subSteps": [
                                    "Escreva x(r,s,t) = ∑_{i=1}^{20} N_i(r,s,t) * x_i, similar para y e z.",
                                    "Substitua coordenadas reais dos 20 nós do hexaédrico distorcido.",
                                    "Expanda a soma explicitamente para 2-3 termos iniciais e indique o padrão.",
                                    "Discuta como distorções (ex: cisalhamento) afetam o mapeamento.",
                                    "Implemente em pseudocódigo uma função que computa (x,y,z) dado (r,s,t)."
                                  ],
                                  "verification": "Escreva as três equações completas e compute um ponto de teste (ex: centro).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Coordenadas exemplo de um hexaédrico distorcido, editor de texto ou Python.",
                                  "tips": "Use vetor de nós X = [x1,...,x20] e N(r,s,t) vetor para notação matricial: x = N · X.",
                                  "learningObjective": "Formular o mapeamento isoparamétrico explicitamente.",
                                  "commonMistakes": "Índices errados nos nós; esquecer soma sobre todos 20 nós."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar propriedades do mapeamento",
                                  "subSteps": [
                                    "Confirme que nos vértices do cubo pai, mapeia para nós corretos do hexaédrico.",
                                    "Verifique partição da unidade: ∑ N_i =1 implica consistência.",
                                    "Calcule Jacobiano J = ∂(x,y,z)/∂(r,s,t) em pontos chave e cheque det(J) >0.",
                                    "Teste interpolação em pontos de Gauss para precisão.",
                                    "Compare mapeamento com elemento linear para discutir melhorias quadráticas."
                                  ],
                                  "verification": "Gere tabela com 5 pontos: (r,s,t), N_i, (x,y,z) computados e Jacobiano.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Calculadora simbólica ou script Python para derivadas.",
                                  "tips": "Foquem em det(J) para garantir orientação positiva e não-singularidade.",
                                  "learningObjective": "Validar o mapeamento quanto a propriedades numéricas essenciais.",
                                  "commonMistakes": "Ignorar Jacobiano zero (elemento colapsado); testes insuficientes."
                                }
                              ],
                              "practicalExample": "Para um hexaédrico distorcido com vértice1 em (0,0,0), vértice2 em (1,0,0), ..., nó10 (meio aresta) em (0.5,0.1,0), compute x(0,0,0)=0, x(1,0,0)=1 e x(0.5,0,0)≈0.5 ajustado pela distorção usando soma N_i x_i.",
                              "finalVerifications": [
                                "Equações x,y,z escritas corretamente com ∑ N_i.",
                                "Funções N_i somam a 1 em 3 pontos teste.",
                                "Mapeamento correto em todos 8 vértices.",
                                "Jacobiano com det>0 em centro e Gauss points.",
                                "Implementação computacional reproduz coordenadas nodais.",
                                "Explicação verbal do processo em 1 minuto."
                              ],
                              "assessmentCriteria": [
                                "Precisão das funções de forma N_i (100% match com referências).",
                                "Correção das expressões de mapeamento (sem erros de indexação).",
                                "Validação numérica completa (pontos e Jacobiano).",
                                "Clareza na derivação e explicação.",
                                "Criatividade em exemplo prático personalizado.",
                                "Profundidade nas verificações de propriedades."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Polinômios multivariados e funções de base Lagrange.",
                                "Programação: Implementação em FEA codes como deal.II ou Abaqus UMAT.",
                                "Física: Geometria diferencial em mecânica dos sólidos.",
                                "Engenharia Civil: Modelagem de estruturas irregulares.",
                                "Visualização: Ferramentas como Paraview para plotar mapeamentos."
                              ],
                              "realWorldApplication": "Em análises FEA de peças automotivas distorcidas (ex: cabeçote de motor), o mapeamento isoparamétrico quadrático permite mesh adaptativa precisa, reduzindo erros de discretização em simulações de tensão sob carga."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.2.3"
                            ]
                          },
                          {
                            "id": "10.1.5.4.3.2",
                            "name": "Calcular a matriz Jacobiana",
                            "description": "Computar J = ∂(x,y,z)/∂(r,s,t) com elementos J_{ij} = ∂x_i / ∂ξ_j usando derivadas das funções de forma, e seu determinante |J| para mudança de volume.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar funções de forma e coordenadas isoparamétricas",
                                  "subSteps": [
                                    "Identifique as coordenadas naturais (r, s, t) no domínio [-1,1]^3 para o elemento hexaédrico de 20 nós.",
                                    "Liste as funções de forma N_i(r,s,t) para cada um dos 20 nós, usando polinômios de Lagrange de ordem 2.",
                                    "Mapeie as coordenadas globais (x,y,z) como soma das coordenadas nodais ponderadas pelas funções de forma: x = Σ N_i x_i."
                                  ],
                                  "verification": "Confirme que as funções de forma somam 1 em qualquer ponto e são 1 nos nós correspondentes e 0 nos outros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta, tabela de funções de forma para hexaédrico 20 nós (de livro de Elementos Finitos), software como MATLAB para plotar.",
                                  "tips": "Comece com elementos de menor ordem (8 nós) para visualizar antes de ir para 20 nós.",
                                  "learningObjective": "Compreender o mapeamento isoparamétrico e como as funções de forma interpolam coordenadas.",
                                  "commonMistakes": "Confundir nós corner com nós midside; verificar interpolação unitária."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular derivadas parciais das funções de forma",
                                  "subSteps": [
                                    "Compute ∂N_i/∂r, ∂N_i/∂s, ∂N_i/∂t analiticamente para cada função de forma no ponto de interesse (ex: ponto de Gauss).",
                                    "Organize as derivadas em uma matriz [∂N/∂ξ] de dimensão 20x3, onde ξ = [r,s,t].",
                                    "Valide as derivadas numéricamente diferenciando as funções de forma em pontos próximos."
                                  ],
                                  "verification": "Verifique se as derivadas são zero nos nós onde N_i=0 e não-zero no nó i.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Fórmulas analíticas de derivadas (documento ou livro), calculadora simbólica como SymPy ou Mathematica.",
                                  "tips": "Use simetria do elemento para reduzir cálculos repetitivos.",
                                  "learningObjective": "Dominar o cálculo de derivadas parciais das funções de forma em coordenadas locais.",
                                  "commonMistakes": "Erros de sinal nas derivadas de polinômios quadráticos; sempre derive termo a termo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a matriz Jacobiana J",
                                  "subSteps": [
                                    "Defina J como a matriz 3x3 com J_{ij} = ∂x_i / ∂ξ_j, onde x_1=x, x_2=y, x_3=z e ξ_1=r, ξ_2=s, ξ_3=t.",
                                    "Calcule cada elemento: ∂x/∂r = Σ (∂N_k/∂r) x_k, e аналогично para outros.",
                                    "Multiplique a matriz de coordenadas nodais [X] (3x20) pela matriz de derivadas [∂N/∂ξ]^T (3x20).",
                                    "Avalie J em um ponto específico, como centro do elemento."
                                  ],
                                  "verification": "Confirme que J é invertível (det(J) ≠ 0) e que as colunas representam vetores base locais.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Coordenadas nodais de um elemento exemplo, MATLAB ou Python (NumPy) para multiplicação matricial.",
                                  "tips": "Implemente em código para automatizar; debugue com elementos regulares onde J é diagonal.",
                                  "learningObjective": "Construir corretamente a matriz de transformação Jacobiana a partir de derivadas.",
                                  "commonMistakes": "Inverter dimensões das matrizes; lembrar transposição correta de [∂N/∂ξ]."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular determinante |J| e interpretar",
                                  "subSteps": [
                                    "Compute det(J) analiticamente ou numericamente para o ponto de integração.",
                                    "Interprete |J| como o fator de escala de volume: dV = |J| dr ds dt.",
                                    "Verifique se |J| > 0 em todo o elemento para evitar inversão.",
                                    "Integre uma propriedade simples (ex: volume total) usando |J| em pontos de Gauss."
                                  ],
                                  "verification": "O volume computado deve coincidir com o volume geométrico conhecido do elemento.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Função det() em MATLAB/Python, pesos e pontos de Gauss para hexaédrico.",
                                  "tips": "Para elementos distorcidos, |J| varia; plote para visualizar.",
                                  "learningObjective": "Calcular e usar |J| para transformações de integrais em FEM.",
                                  "commonMistakes": "Esquecer o valor absoluto em |J|; det(J)<0 indica problema de orientação."
                                }
                              ],
                              "practicalExample": "Para um elemento hexaédrico 20 nós cúbico unitário com nós em posições padrão, no centro (r=s=t=0), compute J (deve ser identidade/2 para ordem 2) e |J|=1/8, confirmando volume total ∫|J|dξ=1.",
                              "finalVerifications": [
                                "Matriz J 3x3 com elementos corretos das derivadas parciais.",
                                "det(J) positivo e consistente com geometria.",
                                "Cálculo reproduz volume exato do elemento.",
                                "Derivadas validadas numericamente.",
                                "J invertível em todos pontos de Gauss.",
                                "Integração de teste (ex: ∫1 dV = volume) converge corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica dos elementos de J (erro <1e-6).",
                                "Correta interpretação de |J| como jacobiano de volume.",
                                "Manipulação matricial sem erros dimensionais.",
                                "Validação com caso analítico conhecido.",
                                "Eficiência computacional em código implementado.",
                                "Explicação clara do processo em relatório."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Vetorial: Derivadas parciais e transformações de coordenadas.",
                                "Álgebra Linear: Multiplicação matricial e determinantes.",
                                "Programação Numérica: Implementação em Python/MATLAB para FEM.",
                                "Geometria Computacional: Mapeamentos paramétricos em CAD."
                              ],
                              "realWorldApplication": "Em simulações de análise estrutural por Elementos Finitos (ex: ANSYS), a Jacobiana é essencial para integrar tensões e deformações em elementos distorcidos, garantindo precisão em peças automotivas ou aeroespaciais complexas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.5.4.3.3",
                            "name": "Avaliar derivadas no espaço físico",
                            "description": "Transformar gradientes locais ∂/∂r para globais usando J^{-1}, como {∂N/∂x} = J^{-T} {∂N/∂r}, essencial para tensões e matriz B.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Mapeamento Isoparamétrico e Espaços Local e Físico",
                                  "subSteps": [
                                    "Revise as coordenadas no espaço natural (r, s, t) para elemento hexaédrico de 20 nós.",
                                    "Identifique as funções de forma N_i(r,s,t) para nós de Lagrange serendípicos.",
                                    "Defina o mapeamento x = Σ N_i x_i, y = Σ N_i y_i, z = Σ N_i z_i.",
                                    "Diferencie conceitualmente entre derivadas locais ∂/∂r e globais ∂/∂x.",
                                    "Esboce um elemento hexaédrico mostrando nós e domínio paramétrico [-1,1]^3."
                                  ],
                                  "verification": "Desenhe o mapeamento e liste 4 funções de forma principais corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel, lápis, tabela de funções de forma para hexa20, software visualizador como Gmsh.",
                                  "tips": "Comece com 2D quadrilateral para intuição antes de 3D.",
                                  "learningObjective": "Compreender a relação geométrica entre espaços paramétrico e físico.",
                                  "commonMistakes": "Confundir nós corner com midside; assumir mapeamento linear."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Matriz Jacobiana J",
                                  "subSteps": [
                                    "Compute J = [∂x/∂r ∂x/∂s ∂x/∂t; ∂y/∂r ... ; ∂z/∂r ...] = Σ (∂N_i/∂r x_i ; etc.).",
                                    "Avalie ∂N_i/∂r, ∂N_i/∂s, ∂N_i/∂t no ponto de Gauss desejado.",
                                    "Monte a matriz 3x3 J para um ponto específico (ex: centro do elemento).",
                                    "Verifique det(J) > 0 para orientação positiva.",
                                    "Inverta J numericamente ou simbolicamente para J^{-1}."
                                  ],
                                  "verification": "Calcule J e J^{-1} para um elemento de teste; confira det(J) ≈ volume local.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora matricial, MATLAB/Python com NumPy/SciPy, notas de ponto de Gauss.",
                                  "tips": "Use pontos de Gauss para precisão; armazene J por ponto de integração.",
                                  "learningObjective": "Dominar o cálculo da Jacobiana como base para transformação de derivadas.",
                                  "commonMistakes": "Erros em derivadas de N_i de ordem alta; esquecer termos para midside nodes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar Derivadas Locais das Funções de Forma",
                                  "subSteps": [
                                    "Liste ∂N/∂r, ∂N/∂s, ∂N/∂t como vetor coluna para todos 20 nós.",
                                    "Avalie no ponto de Gauss usando polinômios Lagrange.",
                                    "Exemplo: para nó corner, derive produto de termos lineares/cúbicos.",
                                    "Armazene como matriz [20x3] de derivadas locais.",
                                    "Teste normalização: Σ ∂N_i/∂r = 0 em domínio paramétrico."
                                  ],
                                  "verification": "Verifique soma das derivadas = 0 e valores coerentes com simetria.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Tabela pré-computada de derivadas N para hexa20, código script para automação.",
                                  "tips": "Implemente função em código para evitar cálculos manuais repetitivos.",
                                  "learningObjective": "Calcular com precisão gradientes no espaço paramétrico.",
                                  "commonMistakes": "Derivadas incorretas para nós parasitas; não usar coordenadas locais corretas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Transformar para Derivadas Globais e Formar Matriz B",
                                  "subSteps": [
                                    "Aplique {∂N/∂x} = J^{-T} {∂N/∂r}, onde {∂N/∂r} = [∂N/∂r; ∂N/∂s; ∂N/∂t].",
                                    "Compute J^{-T} = (J^{-1})^T.",
                                    "Extraia ∂N_i/∂x, ∂N_i/∂y, ∂N_i/∂z para cada nó i.",
                                    "Monte matriz B (strain-displacement) com blocos [∂N/∂x 0 0; ... ; ∂N/∂z ∂N/∂y ∂N/∂x].",
                                    "Valide com deformação conhecida em elemento regular."
                                  ],
                                  "verification": "Compare ∂u/∂x computado com gradiente analítico em malha uniforme.",
                                  "estimatedTime": "70 minutos",
                                  "materials": "Código MEF (ABAQUS/MATLAB), exemplo de malha com solução analítica.",
                                  "tips": "Use transposta correta: J^{-T} para cova/contravariante em MEF.",
                                  "learningObjective": "Executar transformação chain-rule corretamente para gradientes físicos.",
                                  "commonMistakes": "Usar J^{-1} ao invés de J^{-T}; inverter ordem das derivadas."
                                }
                              ],
                              "practicalExample": "Para um hexa20 com nós em cubo unitário, no centro (r=s=t=0), compute J identidade, ∂N_corner/∂r=0.125, então ∂N/∂x=J^{-T}∂N/∂r direto; forme B e aplique deslocamento linear u=x/2, verifique ε_xx=0.5.",
                              "finalVerifications": [
                                "Derivadas globais reproduzem gradiente conhecido em patch teste.",
                                "det(J) positivo e volume integrado correto.",
                                "Matriz B simétrica para elemento regular.",
                                "Convergência de tensão em refinamento h.",
                                "Invariância sob rotação rígida (gradientes zero).",
                                "Correspondência com software comercial em benchmark."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica das derivadas < 1e-10 erro relativo.",
                                "Cálculo correto de J^{-T} vs J^{-1}.",
                                "Substeps executados com submissão de código/debug.",
                                "Explicação verbal da transformação chain-rule.",
                                "Aplicação bem-sucedida na matriz B para ε voigt.",
                                "Identificação e correção de 2 erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Inversão e transposta de matrizes.",
                                "Cálculo Vetorial: Teorema da função inversa e chain rule multivariável.",
                                "Programação Numérica: Implementação eficiente em loops vetoriais.",
                                "Geometria Computacional: Mapeamentos diferenciais em CAD/FEM."
                              ],
                              "realWorldApplication": "Em análise de tensões de pontes ou turbinas, transforma derivadas locais em globais para matriz B precisa, permitindo simulação de deformações reais e predição de falhas estruturais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.3.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.4",
                        "name": "Integração Numérica",
                        "description": "Aplicação da quadratura de Gauss-Legendre 3D para calcular integrais de volume no elemento, como matriz de rigidez K = ∫ B^T D B |J| dV ≈ ∑ w_i B^T D B |J|_i.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.4.1",
                            "name": "Selecionar esquema de integração Gauss",
                            "description": "Escolher pontos e pesos de Gauss para 1D (2 pontos para linear, 3 para quadrático), estendendo para 3D com produto tensorial (2x2x2 reduced ou 3x3x3 full para precisão).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos da Quadratura Gauss em 1D",
                                  "subSteps": [
                                    "Estudar polinômios de Legendre e sua ortogonalidade no intervalo [-1,1]",
                                    "Explicar como pontos e pesos Gauss são raízes e integrais de polinômios de Legendre deslocados",
                                    "Demonstrar exatidão para polinômios de grau até 2n-1 com n pontos",
                                    "Comparar precisão com regras como trapezoidal e Simpson para funções polinomiais",
                                    "Calcular manualmente pontos/pesos para n=1 (ponto médio)"
                                  ],
                                  "verification": "Derivar ou citar corretamente pontos e pesos para Gauss de 1 ponto e verificar integral exata de x^2",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Tabela de pontos/pesos Gauss (até n=5)",
                                    "Software MATLAB/Python para plotar funções Legendre",
                                    "Livro de métodos numéricos (ex: Burden & Faires)"
                                  ],
                                  "tips": "Sempre normalize para [-1,1] mapeando o elemento real; memorize pesos para n=2,3",
                                  "learningObjective": "Dominar teoria base da quadratura Gauss e sua superioridade para polinômios",
                                  "commonMistakes": [
                                    "Confundir Gauss-Legendre com Gauss-Lobatto (que inclui endpoints)",
                                    "Esquecer mapeamento jacobiano para intervalos arbitrários"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar Esquemas Gauss para Elementos Lineares e Quadráticos em 1D",
                                  "subSteps": [
                                    "Identificar: 2 pontos para elementos lineares (exato até grau 3)",
                                    "Listar pontos/pesos: ξ=[±0.57735], w=[1,1] para n=2",
                                    "Para quadráticos: 3 pontos, ξ=[0, ±0.77460], w=[0.88889, 0.55556, 0.55556]",
                                    "Implementar integral numérica de função teste (ex: x^2 + x^4) e comparar erro",
                                    "Avaliar custo computacional: n pontos vs precisão"
                                  ],
                                  "verification": "Calcular integral de polinômio grau 4 com n=2 (erro zero até grau 3) e n=3 (exato)",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Planilha Excel ou Jupyter Notebook para cálculos",
                                    "Código Python com numpy para quadratura",
                                    "Tabela Gauss padrão"
                                  ],
                                  "tips": "Use sympy para verificar exatidão simbólica; priorize n mínimo para ordem do elemento",
                                  "learningObjective": "Escolher n pontos baseado na ordem polinomial do elemento (n=(p+1)/2 arredondado)",
                                  "commonMistakes": [
                                    "Usar n=1 para quadráticos (sub-integração, erro alto)",
                                    "Inverter pontos/pesos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estender para 3D via Produto Tensorial",
                                  "subSteps": [
                                    "Explicar produto tensorial: I_3D = I_x ⊗ I_y ⊗ I_z com pontos (ξ_i, η_j, ζ_k) e w= w_i * w_j * w_k",
                                    "Para reduced 2x2x2: 8 pontos, exato para lineares (hexa8)",
                                    "Para full 3x3x3: 27 pontos, exato para quadráticos (hexa20)",
                                    "Calcular número total de pontos e jacobiano médio",
                                    "Implementar em código simples para volume de cubo unitário"
                                  ],
                                  "verification": "Listar coordenadas e pesos para um ponto do produto 2x2x2 e verificar soma pesos=8 (volume)",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código FEniCS ou deal.II tutorial",
                                    "Papel para esboçar grid 2x2x2",
                                    "Documentação elementos finitos"
                                  ],
                                  "tips": "Reduced integration (2x2x2) economiza mas risco de hourglass em quadráticos; use selective para híbrido",
                                  "learningObjective": "Construir esquema 3D a partir de 1D e entender multiplicação de pontos/pesos",
                                  "commonMistakes": [
                                    "Esquecer multiplicar pesos no produto tensorial",
                                    "Usar full para lineares (desnecessário)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Selecionar Esquema para Hexaédrico de 20 Nós",
                                  "subSteps": [
                                    "Analisar ordem: hexa20 é quadrático completo (grau 2 em cada direção)",
                                    "Escolher 3x3x3 full (27 pts) para exatidão em tensores de tensão rígidos",
                                    "Comparar com reduced 2x2x2 (8 pts) + 3x3x3 selective em pontos de tensão",
                                    "Avaliar trade-off: precisão vs tempo (27 vs 8 avaliações)",
                                    "Testar em benchmark: deformação de viga cantilever"
                                  ],
                                  "verification": "Justificar escolha de 3x3x3 para hexa20 e citar referência (ex: Zienkiewicz)",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software ANSYS/Abaqus demo",
                                    "Artigo sobre integration schemes in FEM",
                                    "Código open-source como FreeFEM"
                                  ],
                                  "tips": "Para não-lineares, inicie com reduced e refine; verifique locking/volumétrico",
                                  "learningObjective": "Aplicar regra de seleção baseada em ordem do elemento e tipo de análise",
                                  "commonMistakes": [
                                    "Always usar reduced sem checar hourglass modes",
                                    "Ignorar anisotropia em malhas distorcidas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Otimizar Esquema de Integração",
                                  "subSteps": [
                                    "Implementar esquema em código FEM simples para hexa20",
                                    "Comparar resultados com solução analítica (patch test)",
                                    "Analisar convergência: h-refine vs p-refine com diferentes n",
                                    "Ajustar para problemas específicos (ex: incompressível: 2x2x2)",
                                    "Documentar escolha em relatório"
                                  ],
                                  "verification": "Rodar simulação e confirmar erro <1% em benchmark conhecido",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "GitHub repo FEM 3D",
                                    "Benchmark problems (ex: Cook's membrane)",
                                    "Profiler para tempo CPU"
                                  ],
                                  "tips": "Monitore condição da matriz de rigidez; use Gauss-Lobatto para isogeométricos",
                                  "learningObjective": "Validar seleção através de testes numéricos e otimizar",
                                  "commonMistakes": [
                                    "Não testar com malhas distorcidas",
                                    "Over-integration desnecessária"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um elemento hexa20 modelando uma placa sob tração uniaxial, selecione 3x3x3 Gauss para integrar B^T D B precisamente, calculando tensão no centro: pontos incluem (0,0,0) w≈0.1128^3, resultando em deslocamentos convergentes com erro <0.1% vs analítico.",
                              "finalVerifications": [
                                "Listar corretamente pontos/pesos 2-pt e 3-pt em 1D",
                                "Construir grid 2x2x2 e 3x3x3 com pesos multiplicados",
                                "Justificar 3x3x3 para hexa20 quadrático",
                                "Implementar e rodar integral numérica com erro zero para polinômio grau 5 em 3D",
                                "Identificar quando usar reduced vs full",
                                "Passar patch test em código FEM simples"
                              ],
                              "assessmentCriteria": [
                                "Precisão na citação de pontos/pesos (erro <0.01%)",
                                "Correta extensão tensorial sem erros de multiplicação",
                                "Justificativa baseada em ordem polinomial e estabilidade",
                                "Análise de trade-offs custo-benefício quantitativa",
                                "Validação prática via código ou cálculo manual",
                                "Identificação de pitfalls como hourglass/locking"
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Polinômios ortogonais e métodos de quadratura",
                                "Programação: Implementação em Python/MATLAB para FEM",
                                "Física Computacional: Integração em equações diferenciais parciais",
                                "Otimização: Balancear precisão vs custo computacional",
                                "Estatística: Análise de erro e convergência numérica"
                              ],
                              "realWorldApplication": "Em simulações FEM de turbinas aeronáuticas (ANSYS), selecionar 3x3x3 Gauss em hexa20 para prever tensões precisas em pás sob fadiga, evitando falhas catastróficas e otimizando design para leveza e durabilidade."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.3.3"
                            ]
                          },
                          {
                            "id": "10.1.5.4.4.2",
                            "name": "Listar pontos e pesos de Gauss 3D",
                            "description": "Tabular coordenadas (r_i,s_i,t_i) e pesos w_i para esquemas 2x2x2 (8 pontos) e 3x3x3 (27 pontos), com pesos 1D: ±√(1/3), 1 para 2-pt; etc.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Pontos e Pesos de Gauss-Legendre em 1D para 2 e 3 Pontos",
                                  "subSteps": [
                                    "Memorize ou derive as localizações ξ_i e pesos w_i para regra de 2 pontos: ξ = ±√(1/3) ≈ ±0.57735, w=1.",
                                    "Para 3 pontos: ξ = 0 com w=8/9 ≈0.88889; ξ=±√(0.6)≈±0.77460 com w=5/9≈0.55556.",
                                    "Verifique a precisão exata para polinômios até grau 2n-1.",
                                    "Escreva as fórmulas analíticas para √(1/3) e √(3/5).",
                                    "Pratique computando pesos normalizados para intervalo [-1,1]."
                                  ],
                                  "verification": "Liste corretamente as 2 e 3 localizações e pesos em 1D com precisão de 5 casas decimais.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Tabela padrão de Gauss-Legendre 1D",
                                    "Calculadora científica",
                                    "Papel para anotações"
                                  ],
                                  "tips": [
                                    "Use √(1/3) exato ao invés de aproximar cedo; memorize os valores para 3 pontos como padrão MEF."
                                  ],
                                  "learningObjective": "Dominar os pontos e pesos fundamentais de Gauss 1D usados em 3D.",
                                  "commonMistakes": [
                                    "Confundir pesos de 2 e 3 pontos; esquecer normalização para [-1,1]; usar aproximações numéricas sem exatas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Produto Tensorial para Gauss 3D",
                                  "subSteps": [
                                    "Aprenda que pontos 3D são produtos cartesianos: (r_i, s_j, t_k) onde cada é de Gauss 1D.",
                                    "Para NxNxN, total N^3 pontos; peso w_i = w_r * w_s * w_t.",
                                    "Confirme que para hexaedro isoparamétrico [-1,1]^3, isso integra exatamente polinômios até grau 2N-1 por direção.",
                                    "Desenhe diagrama de tensor para 2x2x2 mostrando 8 combinações.",
                                    "Calcule um peso exemplo: para todos centros, w=(8/9)^3."
                                  ],
                                  "verification": "Explique e demonstre como gerar pontos 3D a partir de 1D com pelo menos um exemplo numérico.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Diagrama de produto tensorial",
                                    "Software como MATLAB ou Python para visualizar (opcional)",
                                    "Folha de cálculo"
                                  ],
                                  "tips": [
                                    "Pense em grades separadas em r,s,t; liste sistematicamente i,j,k de 1 a N."
                                  ],
                                  "learningObjective": "Compreender como estender Gauss 1D para 3D via produto tensorial.",
                                  "commonMistakes": [
                                    "Esquecer multiplicar pesos; confundir com Gauss-Lobatto (que usa nós nos extremos)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Listar Pontos e Pesos para Esquema 2x2x2 (8 Pontos)",
                                  "subSteps": [
                                    "Liste as 2 localizações 1D: g1= -√(1/3), g2= +√(1/3); w1=w2=1.",
                                    "Gere todas 8 combinações: para cada (i,j,k) em {1,2}^3, ponto=(g_i, g_j, g_k), w=w_i*w_j*w_k=1.",
                                    "Tabule em formato: | r | s | t | w | com valores numéricos e exatos.",
                                    "Verifique simetria: todos pesos=1, pontos simétricos em octantes.",
                                    "Some pesos: deve ser 8 para integral de 1 sobre volume unitário."
                                  ],
                                  "verification": "Produza tabela completa com 8 linhas, exatas e numéricas, sem erros.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Planilha Excel ou LaTeX para tabela",
                                    "Calculadora para √(1/3)≈0.57735"
                                  ],
                                  "tips": [
                                    "Ordene por coordenada r crescente, depois s, t; use notação (±a,±a,±a)."
                                  ],
                                  "learningObjective": "Gerar e tabular precisamente os 8 pontos Gauss 2x2x2.",
                                  "commonMistakes": [
                                    "Pontos duplicados; pesos errados como 0.5; esquecer sinais em combinações."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Listar Pontos e Pesos para Esquema 3x3x3 (27 Pontos)",
                                  "subSteps": [
                                    "Liste 1D 3 pts: g1=-√(3/5)≈-0.7746 w=5/9; g2=0 w=8/9; g3=+√(3/5) w=5/9.",
                                    "Gere 27 combinações sistematicamente: loop triplo i,j,k=1..3.",
                                    "Calcule pesos: 27 únicos, e.g., todos extremos (5/9)^3≈0.1715; centro (8/9)^3≈0.7023.",
                                    "Crie tabela organizada por camadas (r fixo), com colunas r,s,t,w.",
                                    "Verifique soma pesos=  (2*(5/9)+8/9)^3 = 2^3=8."
                                  ],
                                  "verification": "Tabela com 27 entradas corretas, incluindo pelo menos 5 pesos distintos calculados.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Script Python simples para gerar tabela (opcional)",
                                    "Grande folha para tabular manualmente"
                                  ],
                                  "tips": [
                                    "Agrupe por tipo: 1 centro, 12 faces, 12 arestas, 6 vértices? Não, Gauss interno; use ID ijk."
                                  ],
                                  "learningObjective": "Dominar geração e tabulação dos 27 pontos Gauss 3x3x3.",
                                  "commonMistakes": [
                                    "Erro em √(3/5)=√0.6≈0.7746; pesos não multiplicados; soma pesos ≠8."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Tabular Completo, Verificar e Documentar",
                                  "subSteps": [
                                    "Compile tabelas finais em um documento: seções para 2x2x2 e 3x3x3.",
                                    "Inclua valores exatos (√) e numéricos (5 decimais).",
                                    "Valide integrando função teste f=1 (soma w=8) e f=r^2+s^2+t^2 (conhecido).",
                                    "Compare com referências padrão de MEF (e.g., livros Zienkiewicz).",
                                    "Prepare para uso em código FEA."
                                  ],
                                  "verification": "Documento com tabelas validadas, soma pesos=8 para ambos esquemas.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Referência MEF (PDF ou livro)",
                                    "Python/MATLAB para validação integral"
                                  ],
                                  "tips": [
                                    "Sempre normalize para det(J)=1 inicialmente; exporte para CSV."
                                  ],
                                  "learningObjective": "Consolidar conhecimento em tabelas prontas para uso em simulações FEA.",
                                  "commonMistakes": [
                                    "Inconsistência numérica; omitir verificação de soma pesos."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um elemento hexaédrico de 20 nós, use pontos 2x2x2 para integrar matriz de rigidez K = ∫ B^T D B det(J) dV, avaliando em 8 pontos Gauss com pesos w_i para aproximar precisamente sem quadratura excessiva.",
                              "finalVerifications": [
                                "Tabelas listam exatamente 8 pontos para 2x2x2 e 27 para 3x3x3 com coordenadas corretas.",
                                "Todos pesos somam 8 para ambos esquemas.",
                                "Valores exatos incluem ±√(1/3), ±√(3/5), frações 5/9,8/9.",
                                "Simetria preservada: pontos refletem em planos r=0,s=0,t=0.",
                                "Numéricos precisos a 5 decimais (e.g., 0.57735, 0.77460).",
                                "Pelo menos uma integral teste (f=1) validada."
                              ],
                              "assessmentCriteria": [
                                "Precisão das localizações 1D propagadas para 3D (100% correto).",
                                "Cálculo correto de pesos produto (sem erros de multiplicação).",
                                "Organização clara da tabela (colunas, ordenação lógica).",
                                "Inclusão de valores exatos e numéricos.",
                                "Verificação de soma pesos e simetria demonstrada.",
                                "Explicação conceitual do produto tensorial.",
                                "Ausência de erros comuns como confusão com Lobatto."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Derivação de quadratura Gauss-Legendre.",
                                "Programação: Implementar em Python/MATLAB para gerar pontos dinamicamente.",
                                "Física Computacional: Aplicação em equações diferenciais parciais via MEF.",
                                "Estatística: Quadratura para integração Monte Carlo vs. determinística.",
                                "Geometria Computacional: Mapeamento isoparamétrico de hexaedros."
                              ],
                              "realWorldApplication": "Em software FEA como ANSYS ou Abaqus, esses pontos e pesos são hardcoded para integração eficiente em análise de tensão/fluido em estruturas 3D complexas, como turbinas ou chassis automotivos, reduzindo tempo computacional enquanto mantém precisão."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.4.1"
                            ]
                          },
                          {
                            "id": "10.1.5.4.4.3",
                            "name": "Montar matriz de rigidez via integração numérica",
                            "description": "Implementar soma sobre pontos de Gauss: K_e += w_g B_g^T D B_g det(J_g), onde B_g inclui derivadas transformadas, para análise de sólidos 3D elásticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar geometria do elemento e pontos de Gauss",
                                  "subSteps": [
                                    "Defina as coordenadas dos 20 nós do elemento hexaédrico em coordenadas globais.",
                                    "Liste os pontos de Gauss padrão (ex: 2x2x2 Gauss-Legendre) com pesos w_g correspondentes.",
                                    "Implemente funções para mapear funções de forma N_i(ξ,η,ζ) e suas derivadas parciais em coordenadas isoparamétricas.",
                                    "Calcule a matriz Jacobiana J_g = ∂x/∂ξ para cada ponto Gauss g.",
                                    "Verifique det(J_g) > 0 para todos os pontos."
                                  ],
                                  "verification": "Confirme que det(J_g) é positiva e finita para todos os pontos Gauss; visualize o mapeamento isoparamétrico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de programação (Python com NumPy/SciPy ou MATLAB), coordenadas de nós de exemplo, tabela de pontos Gauss.",
                                  "tips": "Use pontos Gauss de ordem 2 para simplicidade inicial; armazene J_g^{-1} para derivadas transformadas.",
                                  "learningObjective": "Compreender o mapeamento isoparamétrico e preparar dados para integração.",
                                  "commonMistakes": "Esquecer de inverter a Jacobiana; usar pontos Gauss inadequados para hexaédrico de 20 nós."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular matriz de derivadas B_g com transformações",
                                  "subSteps": [
                                    "Compute derivadas das funções de forma em coordenadas isoparamétricas: ∂N_i/∂ξ, ∂N_i/∂η, ∂N_i/∂ζ.",
                                    "Transforme para derivadas globais: [∂N/∂x, ∂N/∂y, ∂N/∂z]^T = J_g^{-1} * [∂N/∂ξ, ∂N/∂η, ∂N/∂ζ]^T.",
                                    "Monte a matriz B_g (6x60 para 3D elástico, 20 nós): organize strains ε = B u_e.",
                                    "Inclua termos para deformações normais e cisalhamento.",
                                    "Valide B_g multiplicando por vetor de deslocamentos unitário."
                                  ],
                                  "verification": "B_g deve satisfazer propriedades de equilíbrio rígido (B_g * rigid_mode = 0).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código do Step 1, documentação de elementos finitos (ex: Bathe ou Zienkiewicz).",
                                  "tips": "Vetorize computações para eficiência; debugue com elemento não-distorto primeiro.",
                                  "learningObjective": "Dominar a construção da matriz B_g via chain rule com Jacobiana.",
                                  "commonMistakes": "Erro na ordenação dos nós ou confusão entre derivadas locais/globais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir propriedades do material e matriz constitutiva D",
                                  "subSteps": [
                                    "Especifique módulo de Young E, coeficiente de Poisson ν e densidade para sólido elástico isotrópico.",
                                    "Compute constantes de Lamé λ e μ.",
                                    "Monte matriz D (6x6) para strains voigt: σ = D ε.",
                                    "Verifique simetria e positivos definitos de D.",
                                    "Ajuste para condições planares se aplicável, mas foque em 3D."
                                  ],
                                  "verification": "D deve ser simétrica e trace(D) > 0; teste com strain uniaxial.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Tabelas de propriedades de materiais, fórmula de D para isotrópico.",
                                  "tips": "Use fórmula fechada: D_ii = λ + 2μ para normais, D_ij=λ para i≠j normais.",
                                  "learningObjective": "Entender relação constitutiva linear elástica em 3D.",
                                  "commonMistakes": "Usar fórmula 2D em 3D; inverter E e ν incorretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Realizar integração numérica e somar contribuições para K_e",
                                  "subSteps": [
                                    "Inicialize K_e como matriz 60x60 zero.",
                                    "Para cada ponto g: compute integrando = w_g * B_g^T * D * B_g * det(J_g).",
                                    "Some à K_e: K_e += integrando.",
                                    "Garanta simetria final de K_e.",
                                    "Escalone unidades se necessário."
                                  ],
                                  "verification": "K_e simétrica, positivos semi-definida; teste patch test.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código dos steps anteriores, loop sobre Gauss points.",
                                  "tips": "Use BLAS/LAPACK para multiplicações eficientes; monitore overflow em det(J_g).",
                                  "learningObjective": "Implementar a soma de Gauss para matriz de rigidez elementar.",
                                  "commonMistakes": "Esquecer w_g ou det(J_g); não rank-update para simetria."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e testar a matriz de rigidez montada",
                                  "subSteps": [
                                    "Aplique modos rígidos: K_e * rigid_displ = 0.",
                                    "Teste constante de strain: compare com solução analítica.",
                                    "Visualize deformações sob carga simples.",
                                    "Compare com software comercial (ex: Abaqus).",
                                    "Analise tempo de computação e convergência."
                                  ],
                                  "verification": "Passa em patch test e testes de rigidez zero.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código completo, casos de teste padrão.",
                                  "tips": "Salve K_e em formato sparse para grandes elementos.",
                                  "learningObjective": "Garantir robustez da implementação via verificações.",
                                  "commonMistakes": "Ignorar modos rígidos; testes inadequados para distorções."
                                }
                              ],
                              "practicalExample": "Para um hexaédrico de 20 nós com nós em grade unitária (0-1 em x,y,z), use 2x2x2 Gauss points. Com E=210 GPa, ν=0.3, compute K_e e aplique deslocamento u=1 no nó 1, verifique reação nos outros nós para equilíbrio.",
                              "finalVerifications": [
                                "K_e é simétrica e esparsa com ~600 não-zeros.",
                                "Passa teste de modos rígidos (6 graus de liberdade nulos).",
                                "Convergência com refinamento de Gauss points.",
                                "Energia de deformação positiva para cargas.",
                                "Comparação <1% com solução analítica para cubo unitário.",
                                "Tempo de execução <1s para elemento único."
                              ],
                              "assessmentCriteria": [
                                "Precisão da Jacobiana e det(J_g) (erro <1e-10).",
                                "Corretude de B_g via equilíbrio rígido.",
                                "Simetria exata de K_e pós-integração.",
                                "Passagem em patch test constante de strain.",
                                "Eficiência computacional (vetorização usada).",
                                "Documentação clara do código."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Integração numérica de Gauss-Legendre e álgebra linear.",
                                "Programação: Vetorização em NumPy/MATLAB e manipulação de tensores.",
                                "Física: Teoria da elasticidade linear e equilíbrio.",
                                "Computação Científica: Métodos numéricos em PDEs elípticas."
                              ],
                              "realWorldApplication": "Usado em simulações FEA para análise de estruturas complexas como chassis automotivos, turbinas eólicas ou implantes biomecânicos, permitindo prever deformações sob cargas reais com precisão de engenharia."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.4.4.2",
                              "10.1.5.4.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.5",
                    "name": "Montagem Global de Malhas 3D",
                    "description": "Assemblagem de matrizes globais e condições de contorno para análises de sólidos tridimensionais.",
                    "individualConcepts": [
                      {
                        "id": "34.3.1",
                        "name": "Cálculo das Matrizes Elementares para Sólidos 3D",
                        "description": "Derivação das matrizes de rigidez elementar [K_e] e de massa [M_e] para elementos tetraédricos e hexaédricos, considerando funções de interpolação e integração numérica em domínios tridimensionais.",
                        "specificSkills": [
                          {
                            "id": "34.3.1.1",
                            "name": "Funções de Forma em Elementos 3D",
                            "description": "Definir e calcular funções de forma lineares (4 nós tetraédrico, 8 nós hexaédrico) e quadráticas (10 nós tetraédrico, 20 nós hexaédrico), incluindo transformação isoparamétrica via coordenadas naturais ξ, η, ζ.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender coordenadas naturais e propriedades das funções de forma em 3D",
                                  "subSteps": [
                                    "Definir funções de forma como funções de interpolação que satisfazem Ni(xj) = δij nos nós do elemento.",
                                    "Explicar coordenadas naturais ξ, η, ζ: para hexaedro [-1,1]^3, para tetraedro [0,1]^3 com L1 + L2 + L3 + L4 = 1.",
                                    "Discutir propriedades: partição da unidade (∑Ni=1), continuidade entre elementos e hierarquia linear/quadrática.",
                                    "Identificar diferenças entre elementos tetraédricos e hexaédricos.",
                                    "Revisar Lagrange vs. serendípico para funções quadráticas."
                                  ],
                                  "verification": "Resumir em um diagrama as coordenadas naturais e listar propriedades chave das funções de forma.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Livro-texto de Elementos Finitos (ex: Bathe ou Zienkiewicz)",
                                    "Papel e lápis para esboços",
                                    "Software de visualização 3D como ParaView"
                                  ],
                                  "tips": "Visualize o domínio isoparamétrico com software para fixar o conceito.",
                                  "learningObjective": "Entender o papel das coordenadas naturais e propriedades fundamentais das funções de forma em elementos 3D.",
                                  "commonMistakes": [
                                    "Confundir coordenadas naturais com globais",
                                    "Esquecer partição da unidade",
                                    "Ignorar diferenças entre tetraedro e hexaedro"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar funções de forma lineares para tetraedro (4 nós) e hexaedro (8 nós)",
                                  "subSteps": [
                                    "Para tetraedro: Ni = Li = 1 - ξ - η - ζ para nó 1, e permutações cíclicas para os outros nós.",
                                    "Verificar partição da unidade: L1 + L2 + L3 + L4 = 1.",
                                    "Para hexaedro: Ni = (1 ± ξ)(1 ± η)(1 ± ζ)/8, com sinais apropriados por nó.",
                                    "Calcular explicitamente N1 a N4 para tetraedro em um ponto exemplo (ξ=0.25, η=0.25, ζ=0.25).",
                                    "Calcular N1 a N8 para hexaedro em ponto central (ξ=η=ζ=0)."
                                  ],
                                  "verification": "Calcular ∑Ni em pontos nos para ambos elementos e confirmar =1.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Planilha Excel ou MATLAB para cálculos simbólicos",
                                    "Notas de aula sobre MEF"
                                  ],
                                  "tips": "Use simetria dos nós para derivar fórmulas rapidamente.",
                                  "learningObjective": "Derivar e calcular funções lineares para elementos tetraédricos e hexaédricos.",
                                  "commonMistakes": [
                                    "Erros nos sinais para hexaedro",
                                    "Não normalizar corretamente no tetraedro",
                                    "Confundir ordem dos nós"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar funções de forma quadráticas para tetraedro (10 nós) e hexaedro (20 nós)",
                                  "subSteps": [
                                    "Para tetraedro 10-nós: usar funções hierárquicas Li(1 - 2ξ - 2η - 2ζ) para nós de aresta, etc.",
                                    "Listar nós: 4 vértices, 6 meio-aresta.",
                                    "Para hexaedro 20-nós: Ni para vértices como lineares, para meio-face (1-ξ²)(1±η)(1±ζ)/4, meio-aresta (1±ξ)(1-η²)(1-ζ²)/4.",
                                    "Calcular funções em um ponto intermediário para ambos.",
                                    "Verificar interpolação nos nós: Ni(nó j) = δij."
                                  ],
                                  "verification": "Implementar em código simples e testar interpolação de um campo linear.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "MATLAB ou Python com SymPy para derivação simbólica",
                                    "Diagramas de nós de elementos 3D"
                                  ],
                                  "tips": "Memorize padrões: vértice, aresta, face para hierarquia.",
                                  "learningObjective": "Dominar derivação de funções quadráticas em elementos 3D complexos.",
                                  "commonMistakes": [
                                    "Erros na contagem de nós (10 vs 20)",
                                    "Fórmulas incorretas para nós de face/aresta",
                                    "Não verificar δij"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar transformação isoparamétrica via coordenadas naturais",
                                  "subSteps": [
                                    "Definir mapeamento: x = ∑Ni(ξ,η,ζ) xi, onde xi são coordenadas globais dos nós.",
                                    "Derivar Jacobiano J = ∂(x,y,z)/∂(ξ,η,ζ) para elementos lineares e quadráticos.",
                                    "Calcular transformação para um tetraedro exemplo com coordenadas nos conhecidas.",
                                    "Resolver para ξ,η,ζ dados x,y,z (inversão numérica aproximada).",
                                    "Verificar consistência: mapeamento ida/volta."
                                  ],
                                  "verification": "Computar posição global de um ponto isoparamétrico e vice-versa com erro <1e-6.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Software FEM como FreeFEM ou código MATLAB customizado",
                                    "Exemplos numéricos de malhas 3D"
                                  ],
                                  "tips": "Use expansão em série de Taylor para inversão aproximada.",
                                  "learningObjective": "Implementar e verificar transformação isoparamétrica em elementos 3D.",
                                  "commonMistakes": [
                                    "Jacobiano singular em pontos ruins",
                                    "Confundir derivadas parciais",
                                    "Não computar determinante |J|"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e integrar funções de forma em cálculos elementares",
                                  "subSteps": [
                                    "Integrar funções de forma para matriz de rigidez: ∫ B^T D B |J| dξ dη dζ.",
                                    "Implementar Gauss-Legendre para quadratura 3D.",
                                    "Testar em elemento simples: recuperar solução analítica.",
                                    "Comparar lineares vs. quadráticas em precisão.",
                                    "Documentar código ou planilha para reutilização."
                                  ],
                                  "verification": "Montar Ke para elemento unitário e validar contra referências.",
                                  "estimatedTime": "2-4 horas",
                                  "materials": [
                                    "Código Python/MATLAB para integração numérica",
                                    "Referências analíticas de elementos padrão"
                                  ],
                                  "tips": "Comece com 2x2x2 pontos de Gauss para lineares.",
                                  "learningObjective": "Aplicar funções de forma em montagem de matrizes elementares.",
                                  "commonMistakes": [
                                    "Pontos/pesos de Gauss errados",
                                    "Esquecer |J| na integral",
                                    "Índices de nós trocados"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um hexaedro linear 8-nós com nós em (±1,±1,±1). Calcule as funções de forma no ponto isoparamétrico (ξ=0.5, η=0, ζ=0) e mapeie para coordenadas globais assumindo xi = posição nodal. Verifique ∑Ni=1 e posição interpolada.",
                              "finalVerifications": [
                                "Derivar corretamente todas as funções lineares e quadráticas para tetra e hexa.",
                                "Calcular transformação isoparamétrica com Jacobiano não-singular.",
                                "Verificar partição da unidade em 5 pontos aleatórios por elemento.",
                                "Implementar código que interpola um campo escalar corretamente.",
                                "Comparar resultados lineares vs. quadráticos em um exemplo de tensão.",
                                "Explicar verbalmente o papel no MEF."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações (100% correto).",
                                "Compreensão conceitual via explicações claras.",
                                "Habilidade em cálculos numéricos sem erros.",
                                "Criatividade em verificações e exemplos.",
                                "Integração correta com Jacobiano e integração.",
                                "Eficiência no uso de ferramentas computacionais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Polinômios de Lagrange e interpolação multivariável.",
                                "Programação: Implementação numérica em Python/MATLAB para FEM.",
                                "Física: Aproximação de deslocamentos e tensões em sólidos deformáveis.",
                                "Geometria Computacional: Mapeamentos e Jacobianos em CAD.",
                                "Engenharia de Software: Desenvolvimento de solvers FEM."
                              ],
                              "realWorldApplication": "Essas funções são fundamentais em softwares de simulação FEM como ANSYS ou Abaqus para modelar deformações em estruturas mecânicas complexas, como chassis de aviões, turbinas eólicas ou implantes biomédicos, permitindo análises precisas de tensão e otimização de design."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.3.1.2",
                            "name": "Matriz de Derivadas [B] e Jacobiano",
                            "description": "Computar a matriz [B] das derivadas das funções de forma em coordenadas globais X,Y,Z, utilizando o Jacobiano da transformação e sua inversa para elementos tetraédricos e hexaédricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Coordenadas Isoparamétricas e Transformação para Elementos 3D",
                                  "subSteps": [
                                    "Revise coordenadas naturais (ξ, η, ζ) para elementos tetraédricos (0 a 1) e hexaédricos (-1 a 1).",
                                    "Defina funções de interpolação N_i para nós dos elementos (4 nós para tetra, 8 para hexa).",
                                    "Expresse coordenadas globais X,Y,Z como função das locais via N_i e posições nodais x_i.",
                                    "Identifique a matriz de transformação geométrica J = ∂(X,Y,Z)/∂(ξ,η,ζ).",
                                    "Pratique mapeamento manual para um tetraedro simples."
                                  ],
                                  "verification": "Desenhe o mapeamento de um elemento tetraédrico e liste funções N_i corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Elementos Finitos (ex: Bathe), papel e lápis, software MATLAB/Octave para plotagem.",
                                  "tips": "Use diagramas para visualizar o mapeamento de referência para real.",
                                  "learningObjective": "Compreender a transformação isoparamétrica fundamental em FEM 3D.",
                                  "commonMistakes": "Confundir limites de coordenadas (tetra 0-1 vs hexa -1 a 1); ignorar dependência não-linear em elementos de alta ordem."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Matriz Jacobiana J",
                                  "subSteps": [
                                    "Compute derivadas parciais das funções de interpolação: ∂N_i/∂ξ, ∂N_i/∂η, ∂N_i/∂ζ.",
                                    "Forme J como matriz 3x3: colunas são ∇(ξ,η,ζ)X, ∇Y, ∇Z.",
                                    "Avalie J em pontos de Gauss (ex: 1 ponto interno para linear).",
                                    "Verifique det(J) > 0 para elemento bem formado (sem inversão).",
                                    "Implemente em código para um hexaedro com nós conhecidos."
                                  ],
                                  "verification": "Calcule J para um tetraedro unitário e confirme det(J) positivo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora simbólica (SymPy/Python), exemplos de malha 3D.",
                                  "tips": "Use expansão em série para derivadas de N_i em elementos bilineares.",
                                  "learningObjective": "Dominar o cálculo analítico e numérico da Jacobiana em sólidos 3D.",
                                  "commonMistakes": "Erros em derivadas de N_i (ex: esquecer fatores 1/8 em hexa); avaliar fora do domínio."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Computar a Inversa do Jacobiano e Derivadas Globais",
                                  "subSteps": [
                                    "Inverta J para obter ∂(ξ,η,ζ)/∂(X,Y,Z).",
                                    "Use regra da cadeia: {∂/∂X, ∂/∂Y, ∂/∂Z} = J^{-T} {∂/∂ξ, ∂/∂η, ∂/∂ζ}.",
                                    "Calcule ∇N_i global = J^{-1} ∇N_i local.",
                                    "Armazene como matriz de derivadas globais para todos nós.",
                                    "Teste numericamente com ponto de Gauss específico."
                                  ],
                                  "verification": "Verifique que ∇u global · dr global = ∇u local · dr local para campo u testado.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "MATLAB/Python com NumPy para inversão matricial, exemplos numéricos.",
                                  "tips": "Use decomposição LU para inversão estável em código.",
                                  "learningObjective": "Aplicar transformação de gradientes via Jacobiano inverso.",
                                  "commonMistakes": "Usar J^{-1} em vez de J^{-T} para gradientes; instabilidade numérica em J mal-condicionada."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar a Matriz de Derivadas [B]",
                                  "subSteps": [
                                    "Estruture [B] 6x(ndofs) com blocos para ε_xx = ∂u/∂X, γ_xy = ∂u/∂Y + ∂v/∂X, etc.",
                                    "Preencha [B] com ∇N_i globais para cada grau de liberdade (u,v,w).",
                                    "Diferencie para tetra (linear) vs hexa (bilinear, full integration).",
                                    "Integre [B]^T D [B] para rigidez, mas foque em [B].",
                                    "Valide com elemento conhecido (ex: det([B]) consistente)."
                                  ],
                                  "verification": "Construa [B] completa para tetraedro e multiplique por vetor de deslocamentos para tensões.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Código FEM open-source (ex: FEniCS tutorial), planilha Excel para verificação.",
                                  "tips": "Padronize ordem de strains: [ε_xx, ε_yy, ε_zz, γ_xy, γ_yz, γ_zx].",
                                  "learningObjective": "Construir matriz [B] padrão para análise de tensão em sólidos FEM.",
                                  "commonMistakes": "Ordem errada de componentes de strain; esquecer simetria em γ=2ε."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar e Verificar em Exemplos Práticos",
                                  "subSteps": [
                                    "Resolva para tetraedro com malha simples sob tração uniaxial.",
                                    "Compare [B] tetra vs hexa em mesma geometria.",
                                    "Analise sensibilidade a distorção (det(J) baixo).",
                                    "Implemente loop em código para múltiplos pontos de Gauss.",
                                    "Documente diferenças entre elementos lineares e quadráticos."
                                  ],
                                  "verification": "Simule deformação e confirme strains esperados (ex: ε_xx=1% uniaxial).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software ANSYS/ABAQUS student ou código Python custom.",
                                  "tips": "Use quadratura reduzida para hexa para evitar lock.",
                                  "learningObjective": "Integrar conceitos em simulações reais de FEM 3D.",
                                  "commonMistakes": "Ignorar pontos de Gauss múltiplos; não checar orthogonais em J."
                                }
                              ],
                              "practicalExample": "Para um tetraedro com nós (0,0,0), (1,0,0), (0,1,0), (0,0,1), em ponto Gauss (0.25,0.25,0.25), calcule J = [[0.75,0,0],[0,0.75,0],[0,0,0.75]], J^{-1} identidade escalada, ∇N1 = [-0.75, -0.75, -0.75], monte [B] e compute strains para u=(0.01,0,0) em todos nós.",
                              "finalVerifications": [
                                "Cálculo correto de J e det(J)>0 para ambos elementos.",
                                "Gradientes globais batem com analíticos em casos simples.",
                                "[B] produz strains simétricos e corretos para deformação pura.",
                                "Código roda sem erros para malha 3D distorcida.",
                                "Comparação com software comercial dentro de 1% de erro.",
                                "Documentação inclui fórmulas e plots de J."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica em det(J) e inversa (<1e-10 erro).",
                                "Correta distinção tetra/hexa em funções N_i e [B].",
                                "Eficiência computacional (tempo <1s por elemento).",
                                "Tratamento de casos singulares (J det=0).",
                                "Clareza na derivação da cadeia para ∇ global.",
                                "Validação cruzada com pelo menos 3 exemplos."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Inversão matricial e decomposições.",
                                "Cálculo Vetorial: Regra da cadeia multivariable.",
                                "Programação Numérica: Integração Gauss e loops vetoriais.",
                                "Física: Cinemática de deformação em continuum.",
                                "Geometria Computacional: Mapeamentos diferenciais."
                              ],
                              "realWorldApplication": "Em simulações FEM para análise estrutural de peças automotivas (ex: chassi sob crash), turbinas eólicas ou implantes médicos, onde [B] e Jacobiano garantem precisão em strains para prever falhas materiais em geometrias complexas 3D."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.3.1.3",
                            "name": "Integração Numérica em Volume 3D",
                            "description": "Aplicar quadratura de Gauss-Legendre em 3D com 2x2x2 ou 3x3x3 pontos para integrar termos da matriz de rigidez [K_e = ∫ B^T D B det(J) dV] em elementos isoparamétricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Quadratura Gauss-Legendre em 1D e Extensão para 3D",
                                  "subSteps": [
                                    "Estude os polinômios de Legendre e suas raízes/nós de Gauss para n=2 e n=3.",
                                    "Memorize pesos e posições dos nós para Gauss-Legendre 2-pontos e 3-pontos em [-1,1].",
                                    "Entenda o produto tensorial para estender de 1D para 3D: pontos (ξ_i, η_j, ζ_k) e pesos w_i * w_j * w_k.",
                                    "Derive a fórmula de integração numérica em 3D: ∑ w_{ijk} f(ξ_i, η_j, ζ_k).",
                                    "Pratique com integral simples em cubo unitário para validar."
                                  ],
                                  "verification": "Resolva integral analítica ∫_{-1}^1 ∫_{-1}^1 ∫_{-1}^1 1 dξ dη dζ = 8 e compare com Gauss 2x2x2 (erro <1e-12).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Tabela de nós/pesos Gauss-Legendre (Wikipedia ou livro de elementos finitos)",
                                    "Calculadora ou Python/MATLAB para testes",
                                    "Livro: Zienkiewicz 'Finite Element Method' capítulo de integração"
                                  ],
                                  "tips": "Sempre normalize o domínio para [-1,1]; use tabelas pré-computadas para evitar erros de cálculo.",
                                  "learningObjective": "Compreender como a quadratura Gauss-Legendre garante exatidão para polinômios até grau 2n-1 em 3D.",
                                  "commonMistakes": [
                                    "Confundir nós com pesos",
                                    "Esquecer o produto tensorial de pesos em 3D",
                                    "Usar intervalos errados (ex: [0,1] ao invés de [-1,1])"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Elemento Isoparamétrico 3D e Mapeamento Jacobiano",
                                  "subSteps": [
                                    "Descreva um hexaedro 8-nós (Q8) com funções de interpolação N_i(ξ,η,ζ).",
                                    "Calcule a matriz Jacobiana J = ∂(x,y,z)/∂(ξ,η,ζ) usando derivadas das funções de forma.",
                                    "Implemente det(J) em cada ponto de Gauss; verifique positividade para elementos válidos.",
                                    "Mapeie coordenadas físicas x = ∑ N_i x_i para pontos Gauss no domínio parental.",
                                    "Teste com elemento cubo unitário: det(J) constante = 1/8."
                                  ],
                                  "verification": "Para cubo [-0.5,0.5]^3, confirme det(J)=1 em todos pontos Gauss 2x2x2.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código template em Python (NumPy) para Jacobiana",
                                    "Diagrama de hexaedro isoparamétrico",
                                    "Software FEA como FreeFEM ou código próprio"
                                  ],
                                  "tips": "Use diferenças finitas iniciais para depurar derivadas analíticas de N_i.",
                                  "learningObjective": "Dominar o mapeamento isoparamétrico e seu papel na transformação dV = det(J) dξ dη dζ.",
                                  "commonMistakes": [
                                    "Invertar ordem de derivadas em J",
                                    "Esquecer det(J) no integrando",
                                    "Elementos distorcidos com det(J)<0 (invertido)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Pontos e Pesos Gauss para 2x2x2 e 3x3x3",
                                  "subSteps": [
                                    "Liste nós/pesos 2-pt: ξ={±0.57735}, w=1.0; 3-pt: ξ={0, ±0.7746}, w={0.8889, 0.5556}.",
                                    "Gere grade 2x2x2 (8 pts) e 3x3x3 (27 pts) via produto cartesiano.",
                                    "Escreva loop triplo ou vetorial para somar sobre i,j,k.",
                                    "Valide soma pesos * det(J) ≈ volume elemento para integral de 1.",
                                    "Compare precisão: 2x2x2 exato para lineares, 3x3x3 para quadráticos."
                                  ],
                                  "verification": "Integre volume de cubo: soma w_ijk * det(J) = 1.0 (erro <1e-14).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Tabela impressa de Gauss 2/3 pts",
                                    "Script Python/MATLAB com meshgrid para pts",
                                    "Documentação ANSYS/ABAQUS sobre quadratura default"
                                  ],
                                  "tips": "Índices de pts: armazene em arrays 3D para eficiência computacional.",
                                  "learningObjective": "Selecionar esquema Gauss ótimo (2x2x2 para lineares, 3x3x3 para rigidez quadrática).",
                                  "commonMistakes": [
                                    "Pesos errados para 3-pt (w0=0.8889 não 1)",
                                    "Grade 2x2x2 tem 8 pts, não 27",
                                    "Ignorar simetria para otimizar loops"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Matriz de Rigidez K_e nos Pontos Gauss",
                                  "subSteps": [
                                    "Compute matriz de derivadas B (∂N/∂x etc.) via J^{-1} * ∂N/∂(ξ,η,ζ).",
                                    "Defina matriz constitutiva D (isotrópica: λ, μ ou E, ν).",
                                    "Calcule termo integrando: B^T D B * det(J) * w_ijk para cada pt.",
                                    "Some contribuições: K_e[do fs, do fs] += termo para todos pts e graus liberdade.",
                                    "Implemente em código para elemento único."
                                  ],
                                  "verification": "K_e simétrica positiva definida; trace(K_e) >0; compare com analítica para beam simples.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Código FEA base (ex: GitHub 'finite-element-python')",
                                    "Propriedades elásticas padrão (E=210e9 Pa, ν=0.3 aço)",
                                    "Debugger para matrizes (print shapes/dims)"
                                  ],
                                  "tips": "Vetorialize B^T D B com einsum ou kron para velocidade.",
                                  "learningObjective": "Integrar precisamente [K_e = ∫ B^T D B det(J) dV] via Gauss full.",
                                  "commonMistakes": [
                                    "Erro em inversa J (use solve não inv)",
                                    "Índices errados em B (3x8 para Q8)",
                                    "D errada (confundir plano-estresse com 3D)"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Otimizar a Integração Numérica",
                                  "subSteps": [
                                    "Teste convergência: compare 2x2x2 vs 3x3x3 em elemento distorcido.",
                                    "Analise erro: integre polinômio conhecido (ex: x^2 y z) vs exato.",
                                    "Otimize: reduza pts em simetria ou full/reduced integration.",
                                    "Valide com benchmark FEA: deslocamento cantilever beam.",
                                    "Documente escolha de n_gauss baseada em precisão vs custo."
                                  ],
                                  "verification": "Erro norma K_e <1e-10 vs referência analítica ou software comercial.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Benchmark problems (ex: NASA FEA tests)",
                                    "MATLAB/Octave para referência",
                                    "Profiler código para tempo/pts"
                                  ],
                                  "tips": "Use cond(K_e) para checar locking em incompressíveis.",
                                  "learningObjective": "Avaliar robustez da integração em malhas reais.",
                                  "commonMistakes": [
                                    "Over-integration desnecessário (aumenta custo)",
                                    "Ignorar det(J) variável",
                                    "Testes só em cubo (falha em distorções)"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um hexaedro 8-nós representando um cubo de aço 1m^3 (E=200GPa, ν=0.3), use Gauss 2x2x2 para computar K_e. Para carga unitária em nó1, some contribuições: em pt Gauss central, det(J)=0.125, B derivadas ~1, termo ~ D * w=1. Resultado: K_e 24x24 simétrica, usada em montagem global.",
                              "finalVerifications": [
                                "Soma pesos Gauss * det(J) equals volume elemento exato.",
                                "K_e é simétrica e positiva semi-definida.",
                                "Convergência: ||K_e^{3x3x3} - K_e^{2x2x2}|| / ||K_e|| < 1e-8.",
                                "Deslocamentos de teste (cantilever) coincidem com analítico dentro 1%.",
                                "Sem NaNs ou negativos em det(J).",
                                "Tempo execução razoável (<1s por elemento em laptop)."
                              ],
                              "assessmentCriteria": [
                                "Precisão da integração: erro <1e-10 para polinômios grau <=5.",
                                "Correta implementação de B via Jacobiana invertida.",
                                "Eficiência: uso otimizado de loops vetoriais.",
                                "Validação múltipla: analítica, convergência, benchmark.",
                                "Código modular e comentado para reutilização.",
                                "Escolha justificada de esquema Gauss (2x2x2 vs 3x3x3)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: métodos espectrais e quadratura de precisão alta.",
                                "Programação: vetorialização NumPy/MATLAB, otimização laços.",
                                "Física/Engenharia: mecânica dos sólidos, teoria elasticidade linear.",
                                "Computação Científica: FEA solvers (deal.II, FEniCS).",
                                "Estatística: análise erro integração numérica."
                              ],
                              "realWorldApplication": "Em simulações FEA de estruturas aeronáuticas (ex: fuselagem Airbus), essa integração computa K_e para milhões de elementos 3D, prevendo tensões sob carga para certificação FAA, reduzindo testes físicos caros."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "34.3.2",
                        "name": "Processo de Montagem Global da Malha 3D",
                        "description": "Assemblagem da matriz global de rigidez [K] e vetor de carga [F] a partir das contribuições elementares, utilizando a conectividade nodal e gerenciando graus de liberdade múltiplos por nó.",
                        "specificSkills": [
                          {
                            "id": "34.3.2.1",
                            "name": "Tabela de Conectividade e Mapeamento de DOFs",
                            "description": "Interpretar a conectividade de nós da malha 3D para mapear os 3 DOFs por nó (ux, uy, uz) locais do elemento para índices globais, evitando sobreposições.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Conectividade da Malha 3D",
                                  "subSteps": [
                                    "Identifique os nós da malha 3D e numerados sequencialmente.",
                                    "Liste os elementos (ex: tetraedros) e seus nós conectados.",
                                    "Desenhe ou visualize a malha para observar topologia.",
                                    "Anote o número total de nós (N) e elementos (E).",
                                    "Calcule DOFs totais globais: 3N (ux, uy, uz por nó)."
                                  ],
                                  "verification": "Verifique se a lista de conectividade para cada elemento corresponde à malha visual.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel, lápis, software de visualização de malha (ex: Gmsh, Paraview).",
                                  "tips": "Comece com malhas simples como cubos divididos em 8 tetraedros.",
                                  "learningObjective": "Entender como a conectividade define a topologia da malha.",
                                  "commonMistakes": "Confundir ordem local de nós com numeração global."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir DOFs Locais por Elemento",
                                  "subSteps": [
                                    "Para cada elemento, liste os 3 DOFs por nó local: ux_i, uy_i, uz_i para i=1 a número de nós.",
                                    "Exemplo para tetraedro (4 nós): 12 DOFs locais (3x4).",
                                    "Atribua índices locais sequenciais: 1=ux1, 2=uy1, 3=uz1, ..., 12=uz4.",
                                    "Documente em uma tabela local por elemento.",
                                    "Repita para todos os elementos."
                                  ],
                                  "verification": "Confirme que cada elemento tem exatamente 3 x nós DOFs locais numerados corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Planilha Excel ou tabela em papel.",
                                  "tips": "Use convenção consistente: sempre X-Y-Z por nó.",
                                  "learningObjective": "Mapear DOFs locais dentro de cada elemento finito.",
                                  "commonMistakes": "Pular DOFs ou numerar incorretamente a sequência local."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear DOFs Locais para Globais via Conectividade",
                                  "subSteps": [
                                    "Para cada nó local do elemento, encontre seu ID global via tabela de conectividade.",
                                    "Calcule índice global: para nó global j, DOFs são 3(j-1)+1=ux, +2=uy, +3=uz.",
                                    "Crie coluna na tabela: local index -> global index.",
                                    "Preencha para todos DOFs do elemento.",
                                    "Repita para todos elementos, montando a tabela completa."
                                  ],
                                  "verification": "Todos os mapeamentos locais apontam para DOFs globais únicos sem duplicatas no elemento.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Tabela de conectividade impressa, calculadora.",
                                  "tips": "Automatize com fórmula: global = 3*(node_global-1) + dof_local (1,2,3).",
                                  "learningObjective": "Transformar índices locais em globais usando conectividade.",
                                  "commonMistakes": "Erro de 1-based vs 0-based indexing ou off-by-one em cálculos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Evitar Sobreposições na Tabela Global",
                                  "subSteps": [
                                    "Compile todos mapeamentos em uma lista global única.",
                                    "Verifique duplicatas: cada DOF global deve aparecer apenas uma vez por nó compartilhado.",
                                    "Identifique sobreposições e corrija conectividade se necessário.",
                                    "Gere vetor de DOFs globais ordenados.",
                                    "Valide total: len(tabela) == 3N sem gaps ou overlaps."
                                  ],
                                  "verification": "Execute check: set de DOFs globais únicos tem tamanho 3N.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Script Python simples ou Excel para unique check.",
                                  "tips": "Use conjuntos (sets) em programação para detecção rápida de duplicatas.",
                                  "learningObjective": "Garantir unicidade dos DOFs globais na montagem.",
                                  "commonMistakes": "Ignorar nós compartilhados entre elementos, causando múltiplos índices."
                                }
                              ],
                              "practicalExample": "Considere uma malha com 4 nós (1,2,3,4) formando um tetraedro (elemento 1: nós 1,2,3,4). DOFs locais: 1-3(nó1),4-6(nó2),etc. Globais: nó1:1-3, nó2:4-6, nó3:7-9, nó4:10-12. Tabela: local1->global1, local2->global2, ..., local12->global12. Adicione elemento 2 (nós1,2,5,6): mapeia corretamente sem overlap em nós1,2.",
                              "finalVerifications": [
                                "Tabela de conectividade lista nós corretos por elemento.",
                                "Cada DOF local mapeia para DOF global único via fórmula 3*(node-1)+dof.",
                                "Nenhum DOF global aparece mais de uma vez por nó.",
                                "Total de entradas únicas = 3 x número de nós.",
                                "Visualização da malha confirma conectividade.",
                                "Teste com software FEA (ex: montar K global sem erros)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na fórmula de mapeamento local-global (100% correto).",
                                "Detecção e resolução de sobreposições (zero duplicatas).",
                                "Tabela completa e organizada para todos elementos.",
                                "Explicação clara do processo em relatório.",
                                "Aplicação correta em exemplo prático com malha de 8+ nós.",
                                "Tempo de execução eficiente sem erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (vetores de índices, matrizes de localização).",
                                "Programação: Implementação em Python/MATLAB para automação de montagem.",
                                "Física: Compreensão de deslocamentos em sólidos deformáveis.",
                                "Ciência da Computação: Estruturas de dados (arrays, dicionários para nós)."
                              ],
                              "realWorldApplication": "Em software FEA como ANSYS ou Abaqus, essa tabela é usada para montar a matriz de rigidez global K a partir de elementos locais, essencial para simulações de estruturas como pontes, aviões ou implantes médicos sob cargas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.3.2.2",
                            "name": "Algoritmo de Assemblagem Global",
                            "description": "Implementar o loop sobre elementos para somar [K_e] e [F_e] nas posições globais correspondentes, utilizando armazenamento disperso (CSR ou perfil) para eficiência em malhas grandes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar Estruturas de Dados e Conectividade da Malha",
                                  "subSteps": [
                                    "Carregue a malha 3D, incluindo nós (coordenadas x,y,z) e elementos (conectividade nodal).",
                                    "Defina o número total de graus de liberdade (DOFs) globais: num_DOFs = num_nodes * DOFs_por_no (ex: 3 para deslocamentos 3D).",
                                    "Crie mapeamento de DOFs locais para globais usando a tabela de conectividade de cada elemento.",
                                    "Inicialize matriz K_global como matriz densa vazia (num_DOFs x num_DOFs) e vetor F_global como zero (num_DOFs).",
                                    "Gere índices locais para cada elemento (ex: para tetraedro 4-nós: DOFs 1-12)."
                                  ],
                                  "verification": "Verifique se o mapeamento local-global está correto comparando índices manuais para um elemento de teste.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python 3",
                                    "NumPy",
                                    "Arquivo de malha .msh ou similar"
                                  ],
                                  "tips": "Armazene conectividade como array numpy para acesso rápido; use funções como np.ravel_multi_index para mapeamento.",
                                  "learningObjective": "Compreender o mapeamento de DOFs locais para globais em malhas 3D.",
                                  "commonMistakes": [
                                    "Índices base-1 em vez de base-0",
                                    "Esquecer multiplicar DOFs_por_no na contagem global",
                                    "Ignorar condições de contorno no mapeamento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Assemblagem Densa Básica",
                                  "subSteps": [
                                    "Para cada elemento e na malha: calcule K_e (matriz de rigidez local) e F_e (vetor de forças locais) usando fórmulas de elementos finitos 3D.",
                                    "Use um loop duplo sobre DOFs locais i,j: K_global[map[i], map[j]] += K_e[i,j]; F_global[map[i]] += F_e[i].",
                                    "Aplique condições de contorno essenciais zerando linhas/colunas correspondentes em K_global e fixando F_global.",
                                    "Teste com uma malha pequena (ex: 2 elementos tetraedros) e verifique simetria de K_global.",
                                    "Meça tempo de execução para validar baseline densa."
                                  ],
                                  "verification": "Some todos os K_e e compare com K_global; verifique se norma de F_global bate com soma esperada.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "NumPy",
                                    "Funções de elementos finitos (ex: shape functions para tetraedros)"
                                  ],
                                  "tips": "Use broadcasting numpy para somas eficientes; imprima K_global para malha pequena para debug visual.",
                                  "learningObjective": "Implementar corretamente o loop de assemblagem global denso para validação conceitual.",
                                  "commonMistakes": [
                                    "Não somar corretamente em posições sobrepostas",
                                    "Erro em índices locais durante mapeamento",
                                    "Aplicar BCs após assemblagem levando a inconsistências"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir Armazenamento Disperso com Formato CSR",
                                  "subSteps": [
                                    "Reinicie K_global como csr_matrix vazia do SciPy (shape=(num_DOFs, num_DOFs), dtype=float).",
                                    "Para F_global, use coo_vector ou array disperso, mas vetor padrão é eficiente; foque em K.",
                                    "Estude formato CSR: colete índices de linha (row_ptr), coluna (col_ind) e valores (data) durante pré-processamento.",
                                    "Pré-calcule envelope de perfil ou lista de não-zeros por linha para estimar tamanho CSR.",
                                    "Converta K_densa para CSR usando tocsr() para validar contra versão densa."
                                  ],
                                  "verification": "Compare nnz (não-zeros) da CSR com contagem esperada; verifique K_csr.data.sum() == K_densa.sum().",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "SciPy.sparse (csr_matrix, coo_matrix)",
                                    "NumPy"
                                  ],
                                  "tips": "Use coo_matrix primeiro para construção incremental, depois converta para csr; evite densificar.",
                                  "learningObjective": "Dominar representação dispersa CSR para matrizes esparsas de grandes malhas.",
                                  "commonMistakes": [
                                    "Índices não ordenados em CSR",
                                    "Sobrestimar nnz levando a alocação excessiva",
                                    "Perder simetria ao construir unilateral"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Loop de Assemblagem Dispersa Eficiente",
                                  "subSteps": [
                                    "Inicialize coo_matrix vazia para K_global.",
                                    "Para cada elemento: calcule K_e e F_e; para cada i,j não-zero em K_e, append row=map[i], col=map[j], data=K_e[i,j] em listas COO.",
                                    "Da mesma forma para F: append map[i], F_e[i].",
                                    "Após loop, construa K_global = coo_matrix((data, (row, col)), shape).tocsr(); aplique BCs com eliminar_zeros ou diagonal.",
                                    "Teste performance em malha grande (10k+ elementos): compare tempo vs. denso."
                                  ],
                                  "verification": "Resolva Ku=f com sparse solver (ex: spsolve) e compare solução com versão densa para malha pequena.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "SciPy.sparse.linalg",
                                    "Malha de teste grande (ex: gerada por Gmsh)"
                                  ],
                                  "tips": "Use listas pré-alocadas com tamanho estimado (num_elements * nnz_por_elemento); profile com %timeit.",
                                  "learningObjective": "Executar assemblagem global escalável para malhas grandes usando disperso.",
                                  "commonMistakes": [
                                    "Explodir memória com listas COO muito grandes",
                                    "Índices duplicados não somados corretamente",
                                    "Ignorar ordenação em CSR final"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma malha 3D de um cubo dividido em 8 tetraedros (32 nós, 96 DOFs). Calcule K_e para cada tet com módulo E=210e9, nu=0.3. Assemblagem densa: 30s; dispersa CSR (nnz~5k): 0.5s. Verifique deslocamento central sob carga unitária.",
                              "finalVerifications": [
                                "K_global é simétrica e positiva definida (eigenvalues >0 para submatrizes).",
                                "Soma de todos K_e trace(K_e) == trace(K_global).",
                                "F_global soma elementos == soma total de forças nodais.",
                                "Performance: tempo assemblagem O(nnz) vs O(N^2) para N=10k DOFs.",
                                "Solução Ku=f converge e bate com analítica para patch test.",
                                "CSR tem nnz < 1% de size total para malhas reais."
                              ],
                              "assessmentCriteria": [
                                "Correção: erro norma <1e-10 vs. referência densa.",
                                "Eficiência: speedup >10x para malhas >1k elementos.",
                                "Escalabilidade: tempo linear com num_elementos.",
                                "Robustez: lida com BCs e malhas não-struturadas.",
                                "Código limpo: modular com funções separadas para map, assemble.",
                                "Documentação: comentários explicam CSR e mapeamento."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra Linear Esarsa e métodos iterativos (CG, GMRES).",
                                "Programação: Otimização NumPy/SciPy para computação científica.",
                                "Engenharia de Software: Gerenciamento de memória em simulações HPC.",
                                "Física: Mecânica dos Sólidos e equilíbrio estático.",
                                "Ciência de Dados: Processamento de malhas e grafos esparsos."
                              ],
                              "realWorldApplication": "Em simulações FEM de estruturas aeronáuticas (ex: asa de avião com milhões de DOFs), permite análise eficiente em clusters computacionais, reduzindo tempo de engenharia de dias para horas em otimização topológica."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.3.2.3",
                            "name": "Verificação da Montagem Global",
                            "description": "Diagnosticar simetria, positivo-definitividade e balanceamento de [K] global, comparando com casos analíticos simples como cubo unitário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o Modelo de Referência: Cubo Unitário",
                                  "subSteps": [
                                    "Definir geometria: cubo de lado 1 com vértices em (0,0,0) a (1,1,1).",
                                    "Escolher malha simples: 1 elemento hexaédrico com 8 nós.",
                                    "Aplicar condições de contorno: fixar um face em todas as direções (deslocamentos zero).",
                                    "Especificar propriedades do material: módulo de elasticidade E=1, Poisson ν=0.3.",
                                    "Gerar malha e numerar nós consistentemente."
                                  ],
                                  "verification": "Confirmar que a malha tem 8 nós e 1 elemento, com nós numerados de 1 a 8.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de EF (ex: Abaqus, ANSYS ou código Python com FEniCS), caderno para anotações analíticas.",
                                  "tips": "Use uma malha uniforme para facilitar cálculos manuais.",
                                  "learningObjective": "Entender a configuração básica de um problema analítico simples em sólidos 3D.",
                                  "commonMistakes": "Numerar nós incorretamente, levando a erros na conectividade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Montar a Matriz de Rigidez Global [K]",
                                  "subSteps": [
                                    "Calcular matrizes [k] elementares para o hexaédrico usando funções de interpolação bilineares.",
                                    "Mapear graus de liberdade: 3 por nó (ux, uy, uz), total 24 GLs antes de contornos.",
                                    "Aplicar montagem global somando contribuições elementares nas posições corretas.",
                                    "Impor condições de contorno: remover ou penalizar GLs fixos.",
                                    "Exportar ou imprimir [K] global resultante."
                                  ],
                                  "verification": "[K] tem dimensões corretas (ex: 18x18 após fixar 6 GLs de uma face).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código EF ou planilha para montagem manual, fórmula analítica de [k] para hexaédrico.",
                                  "tips": "Implemente em script para automação e reutilização.",
                                  "learningObjective": "Dominar o processo de montagem global em malhas 3D.",
                                  "commonMistakes": "Erros na transformação local-global ou duplicação de contribuições."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar Simetria da Matriz [K] Global",
                                  "subSteps": [
                                    "Extrair [K] como matriz densa ou esparsa.",
                                    "Comparar K[i,j] == K[j,i] para todos i,j usando tolerância 1e-10.",
                                    "Visualizar matriz com heatmaps para inspecionar padrões simétricos.",
                                    "Calcular norma da diferença |K - K^T| e confirmar < 1e-12.",
                                    "Documentar qualquer assimetria encontrada."
                                  ],
                                  "verification": "Norma ||K - K^T|| / ||K|| < 1e-10.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python com NumPy/SciPy/Matplotlib, ou MATLAB.",
                                  "tips": "Use funções built-in como np.allclose(K, K.T).",
                                  "learningObjective": "Identificar e diagnosticar violações de simetria em [K].",
                                  "commonMistakes": "Ignorar erros de arredondamento em computações numéricas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Positivo-Definitividade e Balanceamento",
                                  "subSteps": [
                                    "Computar autovalores de [K] e confirmar todos > 0 (tolerância 1e-10).",
                                    "Verificar balanceamento: soma de cada linha/coluna ≈ 0 para GLs livres (equilíbrio nodal).",
                                    "Comparar rigidez nodal com analítica: deslocamento sob carga unitária.",
                                    "Executar análise estática simples e validar deslocamentos esperados.",
                                    "Analisar condição numérica (cond(K))."
                                  ],
                                  "verification": "Autovalores mínimos > 0 e soma linhas < 1e-10 para nós livres.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Bibliotecas SciPy.linalg.eigvals, fórmula analítica para cubo.",
                                  "tips": "Para positivo-definitivo, teste Cholesky decomposition sem falha.",
                                  "learningObjective": "Avaliar propriedades espectrais e de equilíbrio de [K].",
                                  "commonMistakes": "Não aplicar contornos corretamente, levando a autovalores zero."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar com Solução Analítica e Concluir Diagnóstico",
                                  "subSteps": [
                                    "Calcular solução analítica: rigidez para cubo sob tração uniaxial.",
                                    "Comparar elementos de [K] ou respostas nodais com analítica (erro < 1%).",
                                    "Identificar discrepâncias e rastrear causas (malha, integração, etc.).",
                                    "Gerar relatório com métricas de erro.",
                                    "Arquivar para casos futuros."
                                  ],
                                  "verification": "Erro relativo entre [K]_num e [K]_analítico < 0.5%.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Referências analíticas (Livro de Bathe ou Zienkiewicz), planilha de comparação.",
                                  "tips": "Mantenha soluções analíticas em script para automação.",
                                  "learningObjective": "Integrar verificações com benchmarks analíticos.",
                                  "commonMistakes": "Usar geometria errada no cálculo analítico."
                                }
                              ],
                              "practicalExample": "Para um cubo unitário com 1 elemento hexaédrico fixo na face x=0 e carga unitária em x=1 no centro, [K] global 18x18 deve ter simetria perfeita, autovalores positivos (mínimo ~0.1), linhas balanceadas em nós livres, e rigidez nodal coincidente com E/A/L analítica (~1.0).",
                              "finalVerifications": [
                                "[K] é simétrica com tolerância numérica.",
                                "Todos autovalores de [K] são positivos.",
                                "Somas de linhas/colunas são zero em GLs livres.",
                                "Resultados coincidem com analítica em <1% erro.",
                                "Decomposição Cholesky converge sem pivoteamento.",
                                "Condição numérica cond(K) < 1e6."
                              ],
                              "assessmentCriteria": [
                                "Precisão na montagem: erro <0.1% vs analítico.",
                                "Detecção correta de propriedades (simetria, PD).",
                                "Uso adequado de ferramentas computacionais.",
                                "Relatório claro com evidências visuais e métricas.",
                                "Identificação de pelo menos 2 erros comuns simulados.",
                                "Tempo total dentro de 2.5 horas."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: autovalores, simetria de matrizes.",
                                "Programação Numérica: manipulação de matrizes esparsas.",
                                "Física: princípios de equilíbrio e elasticidade.",
                                "Estatística: análise de erros e tolerâncias numéricas."
                              ],
                              "realWorldApplication": "Em simulações de estruturas aeronáuticas ou automotivas, essa verificação previne erros catastróficos em análises de fadiga ou crash-test, garantindo que modelos EF predigam deformações reais com precisão, economizando milhões em protótipos físicos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "34.3.3",
                        "name": "Imposição de Condições de Contorno em 3D",
                        "description": "Aplicação de condições de contorno essenciais (Dirichlet) e naturais (Neumann) na matriz global montada, garantindo solvibilidade para análises estáticas de sólidos tridimensionais.",
                        "specificSkills": [
                          {
                            "id": "34.3.3.1",
                            "name": "Condições Essenciais Dirichlet",
                            "description": "Eliminar ou penalizar DOFs prescritos (deslocamentos conhecidos) modificando linhas/colunas de [K] e ajustando [F], usando métodos de grande número ou partição.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar DOFs prescritos e preparar matrizes [K] e [F]",
                                  "subSteps": [
                                    "Liste todos os nós e DOFs na malha 3D com condições essenciais Dirichlet (deslocamentos conhecidos, ex: u=0).",
                                    "Atribua índices aos DOFs livres e prescritos na matriz global de rigidez [K].",
                                    "Copie a matriz [K] e vetor [F] originais para modificação.",
                                    "Registre os valores conhecidos dos deslocamentos prescritos.",
                                    "Verifique a dimensionalidade: [K] é NxN onde N=total DOFs."
                                  ],
                                  "verification": "Confirme que DOFs prescritos estão identificados e matrizes preparadas sem alterações iniciais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Malha 3D com condições de contorno definidas",
                                    "Matriz de rigidez global [K]",
                                    "Vetor de forças [F]",
                                    "Planilha ou software como MATLAB/Python"
                                  ],
                                  "tips": "Use uma tabela para mapear nós → DOFs livres/prescritos para evitar confusão.",
                                  "learningObjective": "Compreender e catalogar DOFs sujeitos a condições Dirichlet na montagem global.",
                                  "commonMistakes": [
                                    "Confundir DOFs livres com prescritos",
                                    "Ignorar todos os 3 DOFs por nó em sólidos 3D (ux, uy, uz)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar método de eliminação (partição) para DOFs prescritos",
                                  "subSteps": [
                                    "Particione [K] em submatrizes: K_ll (livres-livres), K_lp (livres-prescritos), K_pl, K_pp.",
                                    "Elimine linhas e colunas correspondentes aos DOFs prescritos, retendo apenas K_ll reduzida.",
                                    "Ajuste [F] removendo entradas prescritas e adicionando contribuição -K_lp * u_p aos DOFs livres.",
                                    "Monte o sistema reduzido: K_ll * u_l = F_l ajustado.",
                                    "Verifique simetria e positiva definitude da K reduzida."
                                  ],
                                  "verification": "Resolva sistema reduzido e confirme que DOFs prescritos são zero ou valores conhecidos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Matrizes particionadas [K]",
                                    "Valores u_p conhecidos",
                                    "Solver linear (ex: lu() no MATLAB)"
                                  ],
                                  "tips": "Implemente partição via índices booleanos para automação em código.",
                                  "learningObjective": "Dominar a redução dimensional via eliminação direta de DOFs prescritos.",
                                  "commonMistakes": [
                                    "Esquecer termo -K_lp * u_p no vetor de forças",
                                    "Não preservar simetria da matriz"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar método de penalização por grande número",
                                  "subSteps": [
                                    "Escolha um fator de penalização α grande (ex: 10^12 * trace(K)/N).",
                                    "Para cada DOF prescrito i com u_i = g: adicione α à diagonal K_ii e α*g a F_i.",
                                    "Mantenha tamanho total de [K] e [F]; resolva sistema completo K * u = F.",
                                    "Extraia solução: DOFs livres da solução total; prescritos devem aproximar g.",
                                    "Teste sensibilidade variando α e monitore convergência."
                                  ],
                                  "verification": "Solução prescrita deve satisfazer |u_i - g| < 10^-6; compare com método de eliminação.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "[K] e [F] originais",
                                    "Valor α calculado",
                                    "Solver iterativo para matrizes grandes"
                                  ],
                                  "tips": "Use α = 1e10-1e15; normalize por rigidez média para estabilidade numérica.",
                                  "learningObjective": "Implementar penalização mantendo estrutura esparsa da matriz global.",
                                  "commonMistakes": [
                                    "α muito pequeno (subestima condição)",
                                    "α muito grande (il-condicionamento numérico)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar métodos, ajustar montagem global e verificar",
                                  "subSteps": [
                                    "Compare soluções de eliminação vs. penalização em norma L2 e tempo computacional.",
                                    "Integre método escolhido na montagem global de malhas 3D (após assembly de elementos).",
                                    "Aplique em malha completa: imponha múltiplas condições Dirichlet em faces/nós.",
                                    "Valide com caso analítico simples (ex: bloco rígido com fixação).",
                                    "Documente pipeline: montagem → BCs → solve → post-process."
                                  ],
                                  "verification": "Soluções coincidem dentro de tolerância 1e-8; DOFs prescritos exatos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código completo de EF 3D",
                                    "Malha teste com BCs conhecidas",
                                    "Ferramentas de plotagem (ex: Paraview)"
                                  ],
                                  "tips": "Prefira eliminação para precisão; penalização para simplicidade em código.",
                                  "learningObjective": "Integrar imposição de Dirichlet na workflow de análise EF 3D.",
                                  "commonMistakes": [
                                    "Aplicar BCs antes da montagem global",
                                    "Ignorar reordenação de DOFs para bandwidth mínimo"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma malha 3D de uma placa quadrada (10x10x1 elementos hexaédricos), fixe ux=uy=uz=0 na face inferior (nós z=0). Identifique ~30 DOFs prescritos. Use eliminação: reduza [K] de 121x121 para ~91x91, ajuste F. Ou penalize com α=1e12. Solução: deslocamentos nulos na base, deformação sob carga superior.",
                              "finalVerifications": [
                                "Pode particionar [K] corretamente e montar K_reduzida.",
                                "Implementa penalização com α adequado sem il-condicionamento.",
                                "Ajusta [F] com contribuições de DOFs prescritos.",
                                "Verifica que soluções satisfazem condições Dirichlet exatamente.",
                                "Compara métodos em precisão e eficiência para malha 3D.",
                                "Integra BCs na montagem global sem erros dimensionais."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Erro em DOFs prescritos < 1e-10.",
                                "Eficiência: Tempo de solve < 10% do total sem BCs.",
                                "Correção numérica: Condicionamento de [K] < 1e15.",
                                "Implementação: Código reproduzível e comentado.",
                                "Validação: Coincidência com solução analítica em 95%.",
                                "Generalidade: Funciona para múltiplas BCs não-homogêneas."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Particionamento e manipulação de matrizes esparsas.",
                                "Programação Numérica: Solvers lineares e tratamento de BCs em FEA.",
                                "Física Computacional: Condições de contorno em PDEs elípticas.",
                                "Engenharia de Software: Modularidade em códigos EF (ex: FEniCS, deal.II)."
                              ],
                              "realWorldApplication": "Em simulações FEA de turbinas eólicas (ANSYS/Abaqus), fixar base da torre com Dirichlet u=0 simula apoio rígido, prevendo tensões sob vento dinâmico para certificação estrutural."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.3.3.2",
                            "name": "Condições Naturais Neumann e Trações",
                            "description": "Incorporar trações superficiais e pressões distribuídas no vetor [F] global via integração de superfície ∫ N^T t dS nos elementos de contorno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Condições de Contorno Neumann e Trações Superficiais",
                                  "subSteps": [
                                    "Revise o princípio virtual de trabalho e sua relação com condições de contorno naturais.",
                                    "Diferencie condições essenciais (Dirichlet) de naturais (Neumann).",
                                    "Estude trações superficiais (t) e pressões distribuídas como vetores de força por unidade de área.",
                                    "Analise a integral de contorno ∫ N^T t dS na formulação fraca.",
                                    "Identifique elementos de contorno em malhas 3D."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como trações contribuem para o vetor F sem deslocamentos impostos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Elementos Finitos (ex: Zienkiewicz), notas de aula sobre formulação variacional.",
                                  "tips": "Desenhe um elemento de contorno simples para visualizar a tração normal e tangencial.",
                                  "learningObjective": "Dominar os conceitos teóricos de condições Neumann em EF.",
                                  "commonMistakes": "Confundir trações com forças nodais puntiformes; sempre lembrar que são distribuídas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Contribuição Matemática das Trações no Vetor de Força Global",
                                  "subSteps": [
                                    "Parta da formulação fraca: ∫_V δu^T (∇·σ) dV + ∫_S δu^T t dS = 0.",
                                    "Expresse δu = N δU_e e t como função nos elementos de contorno.",
                                    "Derive F_e = ∫_S N^T t dS para o vetor nodal de força elementar.",
                                    "Considere casos especiais: tração constante, pressão hidrostática (t = -p n).",
                                    "Verifique dimensionalidade: força por nó."
                                  ],
                                  "verification": "Derive a equação F_e em papel e confira com referência padrão.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Caderno para derivações, software simbólico como SymPy ou Mathematica.",
                                  "tips": "Use coordenadas locais do elemento para simplificar a matriz N.",
                                  "learningObjective": "Derivar analiticamente a contribuição das trações em EF.",
                                  "commonMistakes": "Esquecer o transposto N^T; tração t deve ser vetor 3D consistente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Discretizar e Integrar Numericamente em Elementos de Contorno 3D",
                                  "subSteps": [
                                    "Selecione tipo de elemento de contorno (ex: triângulo 3-nós ou quad 4-nós em superfícies 3D).",
                                    "Mapeie isoparamétrico: x(ξ,η) = ∑ N_i ξ_i.",
                                    "Calcule Jacobiano J = ∂(x,y,z)/∂(ξ,η) e dS = ||J|| dξ dη.",
                                    "Implemente quadratura gaussiana (2x2 pontos típicos) para ∫ N^T t ||J|| dξ dη.",
                                    "Trate trações variáveis: t(ξ,η)."
                                  ],
                                  "verification": "Compute F_e para um elemento teste e compare com solução analítica.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "MATLAB/Python com NumPy/SciPy, malha de teste em .msh (Gmsh).",
                                  "tips": "Inicie com tração constante para depurar antes de distribuída.",
                                  "learningObjective": "Realizar integração numérica precisa em contornos curvos.",
                                  "commonMistakes": "Erro no Jacobiano de superfície (deve ser 2D em 3D); verifique det(J) > 0."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar o Vetor Global F e Impor no Sistema de EF",
                                  "subSteps": [
                                    "Assemble F_global += L_e^T F_e para cada elemento de contorno (L_e: conectividade).",
                                    "Combine com forças volumétricas e pontuais existentes.",
                                    "Resolva K U = F_global considerando condições Dirichlet.",
                                    "Valide simetria e equilíbrio global: ∑F = 0 em estrutura estática.",
                                    "Teste sensibilidade a malha de contorno."
                                  ],
                                  "verification": "Execute simulação completa e verifique deslocamentos esperados em benchmark.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Código EF custom (Python/FEniCS) ou FEA software (Abaqus/Code_Aster).",
                                  "tips": "Use sparse matrices para eficiência em malhas grandes.",
                                  "learningObjective": "Integrar corretamente contribuições de contorno no solver global.",
                                  "commonMistakes": "Duplicar forças em nós compartilhados; sempre zerar F antes da montagem."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Validar a Implementação",
                                  "subSteps": [
                                    "Crie caso teste: cubo sob pressão uniforme na face.",
                                    "Compare com solução analítica (ex: expansão uniforme).",
                                    "Analise convergência h-refinamento na malha de contorno.",
                                    "Teste trações obliquas e variáveis.",
                                    "Documente erros L2 em normas de força e deslocamento."
                                  ],
                                  "verification": "Erro < 1% em benchmark padrão confirma acurácia.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Benchmark problems de EF (ex: deal.II tutorials), plotter (Matplotlib/Paraview).",
                                  "tips": "Monitore condição numérica de K durante montagem.",
                                  "learningObjective": "Garantir robustez e precisão da implementação.",
                                  "commonMistakes": "Ignorar orientação da normal superficial; defina consistente com malha."
                                }
                              ],
                              "practicalExample": "Em uma análise de tensão de uma placa pressurizada: aplique p=1 MPa na face superior via ∫ N^T (-p n) dS, monte em F_global e resolva para deformação elástica, validando com strain gauge experimental.",
                              "finalVerifications": [
                                "Vetor F_global equilibra forças totais aplicadas.",
                                "Deslocamentos convergem monotonicamente com refinamento de malha.",
                                "Norma L2 do erro em F_e < 0.5% vs. analítico.",
                                "Teste passa para tração constante, linear e quadrática.",
                                "Sem forças espúrias em nós internos.",
                                "Equilíbrio nodal verificado: soma forças = 0."
                              ],
                              "assessmentCriteria": [
                                "Derivação matemática correta da integral de tração (100% precisão).",
                                "Implementação numérica com erro <1% em benchmark 3D.",
                                "Montagem global sem vazamentos ou duplicatas de forças.",
                                "Tratamento robusto de superfícies curvas e malhas não-estruturadas.",
                                "Documentação clara de código e validações.",
                                "Explicação fluida dos conceitos em avaliação oral."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Integração numérica e análise variacional.",
                                "Física: Mecânica dos sólidos e princípios de equilíbrio.",
                                "Programação: Algoritmos de montagem matricial e CFD-like boundary.",
                                "Engenharia Civil: Análise de barragens sob pressão hidrostática.",
                                "Computação Científica: Paralelização de integrações de superfície."
                              ],
                              "realWorldApplication": "Simulação de cargas de vento/terremoto em edifícios via trações distribuídas em EF, otimizando design estrutural em software como ANSYS para segurança sísmica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.3.3.3",
                            "name": "Condições Mistas e Simetria",
                            "description": "Combinar condições Dirichlet e Neumann em malhas 3D com simetria, verificando reações e rigidez equivalente pós-aplicação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparação da Malha 3D e Identificação de Simetria",
                                  "subSteps": [
                                    "Importar ou gerar malha 3D no software de elementos finitos (ex: ANSYS, Abaqus).",
                                    "Analisar geometria para identificar planos de simetria (ex: quarter-model para simetria octante).",
                                    "Aplicar cortes de simetria na malha, reduzindo o modelo completo.",
                                    "Verificar qualidade da malha pós-corte (aspect ratio, skewness).",
                                    "Definir nós e elementos nos planos de simetria para condições de contorno."
                                  ],
                                  "verification": "Malha reduzida exibe simetria perfeita e passa em checks de qualidade (Jacobiano > 0.4).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software FEA (ANSYS/Abaqus)",
                                    "Geometria CAD 3D",
                                    "Guia de simetria em FEA"
                                  ],
                                  "tips": "Sempre visualize a malha em 3D rotacionando para confirmar simetria visual.",
                                  "learningObjective": "Compreender como simetria reduz o tamanho computacional sem perda de precisão.",
                                  "commonMistakes": [
                                    "Ignorar desalinhamento de nós nos planos de simetria",
                                    "Usar malha não uniforme nos cortes",
                                    "Esquecer de verificar elementos duplicados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definição e Imposição de Condições Mistas (Dirichlet e Neumann)",
                                  "subSteps": [
                                    "Identificar superfícies para Dirichlet (deslocamentos prescritos, ex: u=0 em faces fixas).",
                                    "Definir cargas Neumann (trações ou pressões em superfícies livres).",
                                    "Aplicar condições nos planos de simetria: Dirichlet para deslocamentos normais (u_n=0) e Neumann para cisalhamento (t_s=0).",
                                    "Combinar mistas: Dirichlet em suportes, Neumann em cargas, ajustando para simetria.",
                                    "Validar aplicação via preview de contornos no software."
                                  ],
                                  "verification": "Todas condições aplicadas corretamente, sem sobreposições ou conflitos nos nós de simetria.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Manual do software FEA para BCs",
                                    "Exemplos de problemas simétricos",
                                    "Planilhas de verificação de BCs"
                                  ],
                                  "tips": "Use grupos de nós/seleções para facilitar aplicação em malhas grandes.",
                                  "learningObjective": "Dominar combinação de Dirichlet (essencial) e Neumann (natural) em contextos simétricos 3D.",
                                  "commonMistakes": [
                                    "Confundir normal/tangencial em simetria",
                                    "Aplicar Dirichlet em cargas livres",
                                    "Esquecer simetria em trações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Montagem Global, Resolução e Análise Inicial",
                                  "subSteps": [
                                    "Montar matriz de rigidez global [K] considerando BCs mistas.",
                                    "Aplicar solver linear estático, monitorando convergência.",
                                    "Extrair deslocamentos, tensões e reações nos nós de contorno.",
                                    "Verificar simetria nos resultados (ex: deslocamentos simétricos nos planos).",
                                    "Comparar rigidez equivalente do modelo reduzido vs. full-model (se disponível)."
                                  ],
                                  "verification": "Convergência alcançada (<1e-6), simetria nos resultados confirmada por espelhamento visual.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Solver FEA configurado",
                                    "Benchmark de modelo full vs. quarter",
                                    "Ferramentas de pós-processamento"
                                  ],
                                  "tips": "Ative logging de iterações para debug de não-convergência.",
                                  "learningObjective": "Executar montagem e resolução de sistemas com BCs mistas e simetria.",
                                  "commonMistakes": [
                                    "Solver inadequado para não-linearidades",
                                    "Ignorar reações em nós Dirichlet",
                                    "Não escalar resultados para modelo full"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificação de Reações, Rigidez Equivalente e Validação Final",
                                  "subSteps": [
                                    "Calcular reações nos suportes Dirichlet e comparar com equilíbrio global.",
                                    "Determinar rigidez equivalente (K_eq = F/δ) para o modelo simétrico.",
                                    "Escalar resultados para modelo completo e validar contra teoria analítica (ex: viga cantilever).",
                                    "Analisar sensibilidade a refinamento de malha nos planos de simetria.",
                                    "Documentar relatório com gráficos de reações e contornos simétricos."
                                  ],
                                  "verification": "Reações em equilíbrio (∑F=0, ∑M=0), K_eq converge com refinamento (<5% erro).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Teoria de elasticidade (Timoshenko)",
                                    "Scripts Python/MATLAB para pós-análise",
                                    "Templates de relatório FEA"
                                  ],
                                  "tips": "Use energy norms para validar rigidez além de deslocamentos.",
                                  "learningObjective": "Avaliar precisão de modelos simétricos com BCs mistas via reações e rigidez.",
                                  "commonMistakes": [
                                    "Não escalar reações para full-model",
                                    "Confundir rigidez local/global",
                                    "Omitir checks de equilíbrio"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma placa retangular 3D com simetria quarter-model: faces de simetria com u_x=0 e t_y=t_z=0; face inferior fixada (Dirichlet u=0); carga pressão uniforme na face superior (Neumann). Verifique reações nos suportes e rigidez equivalente comparando com solução analítica de placa.",
                              "finalVerifications": [
                                "Malha simétrica reduzida sem distorções.",
                                "BCs mistas aplicadas corretamente nos planos de simetria.",
                                "Resultados exibem simetria perfeita (deslocamentos/tensões).",
                                "Reações em equilíbrio estático global.",
                                "Rigidez equivalente converge com mesh refinement.",
                                "Erro <2% vs. benchmark analítico."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e aplicação de simetria (90% redução computacional).",
                                "Correta combinação de Dirichlet/Neumann sem conflitos.",
                                "Convergência do solver e validação de equilíbrio.",
                                "Análise quantitativa de reações e K_eq.",
                                "Relatório completo com visualizações e métricas de erro.",
                                "Tempo de simulação otimizado pela simetria."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes de rigidez simétricas).",
                                "Física: Mecânica dos sólidos (equilíbrio, teorema dos trabalhos virtuais).",
                                "Programação: Scripts APDL/Python para automação de BCs.",
                                "Design: CAD para geração de geometrias simétricas."
                              ],
                              "realWorldApplication": "Otimização de simulações FEA em design de turbinas aeronáuticas, onde quarter-models com BCs mistas reduzem tempo de análise de dias para horas, permitindo iterações rápidas em rigidez estrutural sob cargas assimétricas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.6",
                    "name": "Integração Numérica em Elementos 3D",
                    "description": "Pontos e pesos de Gauss para integração em tetraédricos e hexaédricos na formulação do MEF.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.6.1",
                        "name": "Integração Numérica em Elementos Tetraédricos",
                        "description": "Conceitos fundamentais sobre pontos e pesos de Gauss para integração numérica em elementos tetraédricos de 4 e 10 nós, aplicados à formulação do Método dos Elementos Finitos (MEF) para sólidos 3D, incluindo o cálculo de matrizes de rigidez e vetores de carga.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.6.1.1",
                            "name": "Identificar pontos e pesos de Gauss para tetraédro linear",
                            "description": "Listar e descrever os 1 ponto de Gauss (bariocêntrico) e seu peso (1/4) para integração exata em tetraédros de 4 nós (ordem 1), justificando sua precisão para funções polinomiais de grau até 1 na formulação isoparamétrica do MEF.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o tetraédro de referência isoparamétrico",
                                  "subSteps": [
                                    "Estudar as coordenadas dos quatro nós do tetraédro master: N1(0,0,0), N2(1,0,0), N3(0,1,0), N4(0,0,1)",
                                    "Definir as funções de forma lineares: N1 = 1 - ξ - η - ζ, N2 = ξ, N3 = η, N4 = ζ",
                                    "Calcular o volume do elemento master: V = 1/6",
                                    "Visualizar o domínio de integração: ξ ≥ 0, η ≥ 0, ζ ≥ 0, ξ + η + ζ ≤ 1",
                                    "Mapear para coordenadas bariocêntricas: λi = Ni"
                                  ],
                                  "verification": "Desenhar o tetraédro e listar corretamente as coordenadas e funções de forma",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro-texto de MEF (ex: Zienkiewicz)",
                                    "Papel e lápis ou software GeoGebra/Paraview"
                                  ],
                                  "tips": "Use coordenadas bariocêntricas para simplicidade: soma λi = 1",
                                  "learningObjective": "Dominar a geometria e funções de interpolação do tetraédro linear",
                                  "commonMistakes": [
                                    "Confundir nós com hexaédro",
                                    "Esquecer restrições ξ + η + ζ ≤ 1",
                                    "Erro no cálculo do volume"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar princípios de integração numérica em MEF 3D",
                                  "subSteps": [
                                    "Recordar a fórmula de integração isoparamétrica: ∫_Ω f dΩ ≈ ∑ w_i f(ξ_i) |J(ξ_i)|",
                                    "Explicar necessidade de quadratura exata para polinômios de grau ≤ 1 (constantes e lineares)",
                                    "Comparar com Gauss 1D/2D: 1 ponto para ordem 1",
                                    "Discutir extensão para simplices 3D (tetraédros)",
                                    "Verificar que para grau 1, 1 ponto basta por simetria bariocêntrica"
                                  ],
                                  "verification": "Escrever a fórmula geral e explicar por que 1 ponto é suficiente para P1",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre MEF",
                                    "Tabela de pontos Gauss 1D/2D"
                                  ],
                                  "tips": "Lembre-se: precisão exata requer integração exata de monomiais até grau p",
                                  "learningObjective": "Entender o papel da quadratura numérica na formulação variacional do MEF",
                                  "commonMistakes": [
                                    "Confundir peso com detJ",
                                    "Ignorar o jacobiano",
                                    "Achar que precisa mais pontos para lineares"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar o ponto e peso de Gauss para tetraédro linear",
                                  "subSteps": [
                                    "Localizar o ponto Gauss bariocêntrico: λ1 = λ2 = λ3 = λ4 = 1/4 (ξ = η = ζ = 1/4)",
                                    "Confirmar que é o centro de massa do tetraédro",
                                    "Determinar o peso: w = 1/4 (normalizado para o master element considerando convenção isoparamétrica)",
                                    "Verificar soma de pesos: única ponto, w = Vol_master ajustado (1/4 em convenção dada)",
                                    "Listar explicitamente: Ponto (1/4, 1/4, 1/4), peso 1/4"
                                  ],
                                  "verification": "Escrever as coordenadas exatas e o peso, justificando simetria",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela de quadratura para tetraédros (referência Hughes ou Bathe)",
                                    "Calculadora simbólica como SymPy"
                                  ],
                                  "tips": "Use simetria do simplex para derivar: média das coordenadas nodais",
                                  "learningObjective": "Memorizar e justificar o esquema de Gauss ordem 1 para tetra P1",
                                  "commonMistakes": [
                                    "Usar 1/6 em vez de 1/4 (confusão de volume)",
                                    "Ponto errado como (0.5,0.5,0.5)",
                                    "Esquecer coordenadas naturais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificar precisão para funções polinomiais de grau até 1",
                                  "subSteps": [
                                    "Testar integração de 1: w * 1 = 1/4 (ajustado por |J| para Vol físico)",
                                    "Verificar monomiais lineares: ξ, η, ζ (média no centro = 1/4, exato por simetria)",
                                    "Demonstrar erro zero para P1 via ortogonalidade ou cálculo direto",
                                    "Comparar com subordem: mais pontos desnecessários para grau 1",
                                    "Discutir limitações: inexato para grau 2+"
                                  ],
                                  "verification": "Calcular ∫1 dV e ∫ξ dV analiticamente e numericamente, confirmar igualdade",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "SymPy ou MATLAB para integrais simbólicas",
                                    "Folha de cálculo"
                                  ],
                                  "tips": "Compute Vol = ∫ dξdηdζ = 1/6 analiticamente para validar convenção",
                                  "learningObjective": "Comprovar exatidão do esquema para base linear no MEF",
                                  "commonMistakes": [
                                    "Não considerar |J| constante em lineares",
                                    "Erro em integrais analíticas",
                                    "Achar exato para quadráticos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um tetraédro físico com nós em posições reais, compute a matriz de rigidez [K] para equação de Poisson usando 1 ponto Gauss (1/4,1/4,1/4) com w=1/4 * |J|. Verifique contra solução analítica para carga constante, confirmando exatidão.",
                              "finalVerifications": [
                                "Listar corretamente o ponto Gauss: (1/4, 1/4, 1/4) em coordenadas naturais",
                                "Identificar peso como 1/4 e explicar normalização",
                                "Desenhar tetraédro master com ponto marcado",
                                "Calcular integral de 1 e ξ numericamente e comparar com analítico",
                                "Justificar em 2 frases por que é exato para P1",
                                "Mencionar limitações para ordens superiores"
                              ],
                              "assessmentCriteria": [
                                "Correção da localização do ponto bariocêntrico (100%)",
                                "Valor preciso do peso e justificativa (1/4)",
                                "Explicação clara da exatidão para polinômios grau ≤1",
                                "Uso correto de funções de forma e jacobiano",
                                "Demonstração prática via cálculo simples",
                                "Ausência de confusão com outros elementos (triângulo/hexa)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Quadratura de Gauss e teoria de erros",
                                "Programação: Implementação em Python/Fortran para solvers MEF",
                                "Geometria Computacional: Geração de malhas tetraédricas",
                                "Física: Simulações de deformação em sólidos elásticos"
                              ],
                              "realWorldApplication": "Na análise estrutural de componentes mecânicos complexos, como turbinas ou chassis de veículos, usando malhas tetraédricas em softwares como ANSYS ou Code_Aster para integração precisa de tensões e deformações em elementos lineares, otimizando tempo computacional."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.6.1.2",
                            "name": "Aplicar integração em tetraédro quadrático",
                            "description": "Determinar os 4 ou 5 pontos de Gauss e pesos correspondentes para tetraédros de 10 nós (ordem 2), calculando integrais numéricas como ∫ B^T D B det(J) dV para montagem da matriz de rigidez em problemas de elasticidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a geometria e funções de forma do tetraédro quadrático de 10 nós",
                                  "subSteps": [
                                    "Revise a topologia do tetraédro com 10 nós: 4 nós vertex e 6 nós de aresta midside.",
                                    "Estude as funções de forma quadráticas N_i(ξ,η,ζ) em coordenadas baricêntricas ou isoparamétricas.",
                                    "Derive as derivadas das funções de forma ∂N_i/∂ξ, ∂N_i/∂η, ∂N_i/∂ζ.",
                                    "Implemente uma função para avaliar N_i e suas derivadas em um ponto dado.",
                                    "Teste em pontos conhecidos como vértices e centro."
                                  ],
                                  "verification": "Implemente e teste código que avalia corretamente N_i=1 em nós correspondentes e 0 nos outros.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação de elementos finitos (ex: Zienkiewicz livro), MATLAB/Python com NumPy/SciPy"
                                  ],
                                  "tips": "Use coordenadas baricêntricas para simplicidade inicial: L1 + L2 + L3 + L4 = 1.",
                                  "learningObjective": "Dominar avaliação de funções de forma e derivadas no domínio de referência.",
                                  "commonMistakes": [
                                    "Confundir nós midside com funções lineares",
                                    "Erros em derivadas parciais",
                                    "Normalização incorreta das coordenadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e listar os 5 pontos de Gauss e pesos para tetraédro ordem 2",
                                  "subSteps": [
                                    "Consulte tabelas padrão de quadratura para tetraédros: 5 pontos para integração exata até grau 2.",
                                    "Liste coordenadas: ex. (0.25,0.25,0.25,0.25) peso 0.2887; outros 4 pontos simétricos como (0.6291,0.0597,... ) etc.",
                                    "Verifique soma de pesos = 1 (volume do tetra referência).",
                                    "Implemente array com pontos [ξ,η,ζ] e vetor de pesos w_i.",
                                    "Teste integral de função constante 1 ≈ 1."
                                  ],
                                  "verification": "Código computa ∫1 dV ≈ 1 com erro < 1e-12.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Tabelas de pontos Gauss (ex: Dunavant ou Felippa online), código Python"
                                  ],
                                  "tips": "Memorize ou codifique os 5 pontos exatos; use simetria tetraédrica.",
                                  "learningObjective": "Selecionar e implementar esquema de quadratura apropriado para ordem 2.",
                                  "commonMistakes": [
                                    "Usar 4 pontos lineares em vez de 5 quadráticos",
                                    "Pesos errados somando ≠1",
                                    "Coordenadas fora do tetra (L_i <0)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o jacobiano J e det(J) nos pontos de Gauss",
                                  "subSteps": [
                                    "Mapeie coordenadas físicas x,y,z dos 10 nós para domínio referência via x = Σ N_i x_i.",
                                    "Compute matriz Jacobiana J = [∂x/∂ξ ∂x/∂η ∂x/∂ζ; ...] usando derivadas de N_i e coords nodais.",
                                    "Calcule det(J) em cada ponto Gauss (deve ser positivo).",
                                    "Inverta J para obter derivadas físicas ∂N_i/∂x = (J^{-1})^T ∂N_i/∂ξ etc.",
                                    "Armazene det(J)_k e B_k (matriz de derivadas de strains) para cada ponto k."
                                  ],
                                  "verification": "det(J) consistente e positivo; teste mapeamento forward/backward.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Software FEM básico ou código custom, exemplo de malha tetra"
                                  ],
                                  "tips": "Use LU ou QR para inversão estável; verifique det(J)>0 para orientação correta.",
                                  "learningObjective": "Executar transformação isoparamétrica corretamente.",
                                  "commonMistakes": [
                                    "Jacobiano singular por nós mal posicionados",
                                    "Inversão errada de J",
                                    "Esquecer transposta em derivadas físicas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar a matriz de rigidez usando integração numérica",
                                  "subSteps": [
                                    "Defina matriz constitutiva D para material isotrópico (elasticidade linear).",
                                    "Em cada ponto Gauss k: compute B_k^T D B_k * det(J)_k * w_k.",
                                    "Some sobre os 5 pontos: K = Σ B^T D B det(J) w.",
                                    "Implemente loop sobre pontos Gauss e acumule 6x6 matriz K (para 3D strains).",
                                    "Verifique simetria e positivos definitos de K."
                                  ],
                                  "verification": "K simétrica, trace(K)>0, e converge para solução analítica em caso simples.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Código dos steps anteriores, propriedades elásticas exemplo (E=210GPa, nu=0.3)"
                                  ],
                                  "tips": "Vetorize computação para eficiência; normalize unidades.",
                                  "learningObjective": "Aplicar quadratura para montar integrais de matrizes em FEM.",
                                  "commonMistakes": [
                                    "Índices errados em B (voigt notation)",
                                    "Esquecer det(J) ou w_k",
                                    "D não consistente com strains"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e testar a implementação completa",
                                  "subSteps": [
                                    "Crie tetra malha simples (ex: unitário regular).",
                                    "Compare K numérica com analítica ou software referência.",
                                    "Teste integral de funções polinomiais grau ≤2 exata.",
                                    "Analise convergência variando ordem quadratura.",
                                    "Documente código e resultados."
                                  ],
                                  "verification": "Erro em K < 1e-10 vs referência.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Mesh simples .msh, Gmsh/MATLAB para referência"
                                  ],
                                  "tips": "Use patch test para validação FEM.",
                                  "learningObjective": "Verificar robustez da integração numérica.",
                                  "commonMistakes": [
                                    "Malha distorcida causando ill-conditioning",
                                    "Comparação com elemento linear",
                                    "Ignorar normalização de volume"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um tetraédro unitário com nós em (0,0,0), (1,0,0), (0,1,0), (0,0,1) e midsides, usando D para aço (E=200GPa, ν=0.3), compute K_element e verifique diagonal K_xx ≈ 1.23e11 N/m.",
                              "finalVerifications": [
                                "Lista corretamente os 5 pontos Gauss e pesos somando 1.",
                                "det(J) positivo e consistente em todos pontos.",
                                "Matriz K simétrica e positiva definida.",
                                "Integral de polinômio grau 2 exata (erro <1e-12).",
                                "Código roda para tetra arbitrário sem crashes.",
                                "Comparação com referência <1% erro."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos pontos/weights de Gauss (erro <1e-14).",
                                "Correção no cálculo de J, det(J) e derivadas físicas.",
                                "Implementação eficiente da soma quadratura.",
                                "Validação com testes numéricos/analíticos.",
                                "Clareza e modularidade do código.",
                                "Tratamento de casos edge (tetra degenerado)."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Métodos de quadratura e erro de truncamento.",
                                "Programação Computacional: Vetorização e solvers lineares.",
                                "Mecânica dos Sólidos: Teoria de elasticidade linear.",
                                "Geometria Computacional: Mapeamentos isoparamétricos.",
                                "Física Computacional: Simulações multiphysics."
                              ],
                              "realWorldApplication": "Em simulações FEM de estruturas complexas como turbinas aeronáuticas ou implantes médicos, onde tetraédros quadráticos capturam deformações não-lineares com precisão, montando matrizes de rigidez para análise de tensões em software como Abaqus ou Code_Aster."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.6.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.6.1.3",
                            "name": "Calcular integrais em formulação MEF com tetraédros",
                            "description": "Implementar a regra de Gauss em coordenadas bariocêntricas para avaliar integrais de volume em elementos tetraédricos, considerando o Jacobiano e funções de forma, com exemplos numéricos para verificação de precisão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender coordenadas bariocêntricas e funções de forma em tetraédros",
                                  "subSteps": [
                                    "Defina coordenadas bariocêntricas (λ1, λ2, λ3, λ4) para um tetraédro com vértices Vi.",
                                    "Verifique que ∑λi = 1 e λi ≥ 0 dentro do elemento.",
                                    "Derive funções de forma lineares Ni(λ) = λi para i=1 a 4.",
                                    "Calcule posição de um ponto x(λ) = ∑λi Vi.",
                                    "Plote um tetraédro simples para visualizar as coordenadas."
                                  ],
                                  "verification": "Resolva exercícios onde pontos internos são expressos em coordenadas bariocêntricas com precisão < 1e-6.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de MEF (ex: Zienkiewicz), software de plotagem (Matlab/Octave/Python com Matplotlib)"
                                  ],
                                  "tips": "Use um tetraédro unitário com vértices (0,0,0), (1,0,0), (0,1,0), (0,0,1) para simplificar cálculos iniciais.",
                                  "learningObjective": "Dominar representação de pontos e funções de forma em coordenadas bariocêntricas.",
                                  "commonMistakes": [
                                    "Confundir ordem dos vértices",
                                    "Esquecer normalização ∑λi=1",
                                    "Usar coordenadas cartesianas diretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar regra de Gauss em coordenadas bariocêntricas para integração 3D",
                                  "subSteps": [
                                    "Revise integral de volume em tetraédro: ∫_T f(x) dV = 6V_T ∫_S f(λ) dλ, onde S é o simplex padrão e V_T é volume do tetraédro.",
                                    "Liste pontos e pesos de Gauss para integração em simplex 3D (ex: 1 ponto: λ=(1/4,1/4,1/4,1/4), w=1; 4 pontos ordem 2).",
                                    "Implemente fórmula de integração numérica: ∑ w_k f(λ_k) * |J|.",
                                    "Teste com f(λ)=1 para recuperar volume exato.",
                                    "Compare precisão para polinômios de grau 1 e 2."
                                  ],
                                  "verification": "Calcule integral de f=1 e compare com volume analítico (erro < 1e-10).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Tabelas de pontos Gauss para simplex (referências online ou livro Bathe), calculadora ou script Python"
                                  ],
                                  "tips": "Memorize pelo menos esquemas de 1, 4 e 5 pontos para uso imediato em MEF.",
                                  "learningObjective": "Aplicar corretamente pontos e pesos de Gauss no simplex bariocêntrico.",
                                  "commonMistakes": [
                                    "Usar pesos errados para 3D",
                                    "Aplicar Gauss cartesiano sem transformação",
                                    "Ignorar fator 6V_T"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar e calcular o Jacobiano do mapeamento isoparamétrico",
                                  "subSteps": [
                                    "Defina mapeamento x(λ) = ∑ λi Xi, onde Xi são coordenadas dos nós.",
                                    "Calcule Jacobiana J = ∂x/∂λ (matriz 3x4 com colunas ∂x/∂λi).",
                                    "Compute determinante |det J| usando fórmula para tetraédros: 6V_T (constante!).",
                                    "Inclua |det J| na integral: ∫_T f dV ≈ 6V_T ∑ w_k f(λ_k).",
                                    "Verifique para tetraédro distorcido que |det J| é constante para elementos lineares."
                                  ],
                                  "verification": "Para tetraédro dado, calcule V_T analiticamente e via |det J|/6, com igualdade exata.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Software simbólico (SymPy ou Mathematica) para derivadas, exemplos de malhas tetraédricas"
                                  ],
                                  "tips": "Para lineares, |J| é constante; foque nisso antes de quadráticos.",
                                  "learningObjective": "Integrar Jacobiano corretamente na transformação de referência para elemento real.",
                                  "commonMistakes": [
                                    "Confundir J com inversa",
                                    "Calcular det(J) como em 2D",
                                    "Esquecer fator 6 em V_T = |det J|/6"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar cálculo de integral e verificar com exemplos numéricos",
                                  "subSteps": [
                                    "Escolha função teste ex: f(x,y,z)=x*y*z em tetraédro específico.",
                                    "Calcule integral exata analiticamente.",
                                    "Implemente numérico com 1, 4 e 5 pontos Gauss.",
                                    "Compare erros e analise convergência.",
                                    "Teste com função de forma N1 para rigidez local."
                                  ],
                                  "verification": "Erro numérico < 1e-8 para polinômios grau ≤ ordem de Gauss.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python/Matlab com NumPy/SciPy, código template para MEF"
                                  ],
                                  "tips": "Automatize em loop para múltiplos pontos Gauss; plote erros vs. ordem.",
                                  "learningObjective": "Executar e validar integrais numéricas em MEF tetraédrico.",
                                  "commonMistakes": [
                                    "Pontos Gauss fora do simplex",
                                    "Sinal errado no Jacobiano",
                                    "Escala errada de volume"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar em contexto MEF: integral para matriz de rigidez local",
                                  "subSteps": [
                                    "Defina problema: ∫_T B^T D B det J dV para elemento tetraédrico.",
                                    "Monte matrizes B (gradientes de forma) em pontos Gauss.",
                                    "Calcule contribuições e some.",
                                    "Compare com solução analítica para caso simples.",
                                    "Discuta impacto de precisão na análise global."
                                  ],
                                  "verification": "Matriz de rigidez converge para analítica com refinamento de Gauss.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código MEF básico, propriedades elásticas exemplo (E=210GPa, nu=0.3)"
                                  ],
                                  "tips": "Use simetria para verificar matriz final (K^T = K).",
                                  "learningObjective": "Conectar integração numérica à formulação MEF prática.",
                                  "commonMistakes": [
                                    "Gradientes errados em 3D",
                                    "Não linearizar B corretamente",
                                    "Ignorar simetria"
                                  ]
                                }
                              ],
                              "practicalExample": "Calcule ∫_T x dV sobre tetraédro com vértices (0,0,0), (1,0,0), (0,1,0), (0,0,1). Exata: 1/24. Numérico com 1 ponto Gauss: λ=(0.25)^4, x=0.25, V_T=1/6, approx=0.25*(1/6)=0.04167 (erro ~2.8%). Com 4 pontos: erro <1e-10.",
                              "finalVerifications": [
                                "Calcular volume de tetraédro arbitrário via Gauss com erro zero para lineares.",
                                "Implementar integral de função quadrática com precisão máquina.",
                                "Montar matriz [B] em ponto Gauss e verificar gradientes.",
                                "Comparar tempo computacional vs. precisão para diferentes ordens Gauss.",
                                "Debugar código que falha em tetraédros distorcidos.",
                                "Explicar verbalmente transformação Gauss-bariocêntrico."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erro <1e-8 em testes padrão.",
                                "Correção teórica: derivação de |J| e fatores exatos.",
                                "Implementação codificada: código funcional e comentado.",
                                "Análise de erros: identificação de fontes e mitigação.",
                                "Eficiência: escolha ótima de pontos Gauss por custo-benefício.",
                                "Generalização: aplica a elementos não-regulares."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Quadratura de Gauss e análise de erro.",
                                "Programação: Implementação vetorial em Python/MATLAB para MEF.",
                                "Física/Engenharia: Modelagem de deformações em sólidos 3D.",
                                "Geometria Computacional: Geração e qualidade de malhas tetraédricas.",
                                "Otimização: Escolha de esquemas Gauss para precisão vs. custo."
                              ],
                              "realWorldApplication": "Em simulações MEF de estruturas mecânicas (ex: análise de tensão em peças automotivas ou aeroespaciais), essa integração numérica é essencial para montar matrizes de rigidez locais em malhas tetraédricas, permitindo predições precisas de falhas sob cargas complexas, como em CFD para fluxos turbulentos ou otimização topológica."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.6.1.1",
                              "10.1.5.6.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.6.2",
                        "name": "Integração Numérica em Elementos Hexaédricos",
                        "description": "Pontos e pesos de Gauss-Legendre em coordenadas naturais para integração em elementos hexaédricos de 8 e 20 nós, utilizando produto tensorial de regras 1D para formulação isoparamétrica no MEF de sólidos 3D.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.6.2.1",
                            "name": "Pontos e pesos de Gauss-Legendre 1D para hexaédricos",
                            "description": "Memorizar e aplicar os pontos e pesos padrão de Gauss-Legendre (2x2x2 para ordem 1, 3x3x3 para ordem 2) no intervalo [-1,1] para integração exata de polinômios até grau 5 em cada direção em elementos hexaédricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos da quadratura de Gauss-Legendre 1D",
                                  "subSteps": [
                                    "Estude o conceito de quadratura numérica e sua importância para integração exata de polinômios.",
                                    "Aprenda que Gauss-Legendre usa nós (pontos) e pesos otimizados para o intervalo [-1,1].",
                                    "Entenda a regra: n pontos integram exatamente polinômios até grau 2n-1.",
                                    "Revise o mapeamento de elementos finitos para o domínio de referência [-1,1].",
                                    "Pratique o produto tensorial para estender 1D a 3D em hexaédricos."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como a quadratura Gauss garante exatidão até grau 5 com 3 pontos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Elementos Finitos (capítulo de integração numérica)",
                                    "Tabela de pontos Gauss-Legendre",
                                    "Papel e calculadora"
                                  ],
                                  "tips": "Visualize os pontos como raízes dos polinômios de Legendre para melhor retenção.",
                                  "learningObjective": "Dominar os princípios teóricos da quadratura Gauss-Legendre e sua aplicação em FEM.",
                                  "commonMistakes": [
                                    "Confundir com quadratura trapezoidal ou Simpson.",
                                    "Esquecer o intervalo padrão [-1,1]."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar pontos e pesos para ordem 1 (2 pontos por direção, 2x2x2=8 pontos totais)",
                                  "subSteps": [
                                    "Liste os pontos: ξ₁ = -√(1/3) ≈ -0.5774, ξ₂ = +0.5774.",
                                    "Memorize os pesos: w₁ = w₂ = 1.0.",
                                    "Verifique exatidão: integra exatamente polinômios até grau 3 (2*2-1).",
                                    "Pratique recitação 5 vezes em voz alta.",
                                    "Escreva em tabela para um hexaédrico: 8 combinações tensorais."
                                  ],
                                  "verification": "Recite os 2 pontos e pesos com precisão de 4 casas decimais sem consultar tabela.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Flashcards com valores",
                                    "Planilha Excel para tabela tensorial"
                                  ],
                                  "tips": "Use mnemônica: '√1/3 ≈ 0.577, pesos iguais a 1 como unidade'.",
                                  "learningObjective": "Memorizar com precisão os valores para integração de baixa ordem em hexaédricos.",
                                  "commonMistakes": [
                                    "Trocar sinal dos pontos.",
                                    "Usar pesos errados como 0.5."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Memorizar pontos e pesos para ordem 2 (3 pontos por direção, 3x3x3=27 pontos totais)",
                                  "subSteps": [
                                    "Liste os pontos: ξ₁ ≈ -0.7746, ξ₂ = 0, ξ₃ ≈ +0.7746.",
                                    "Memorize os pesos: w₁ = w₃ ≈ 0.5556, w₂ ≈ 0.8889.",
                                    "Confirme exatidão até grau 5 (2*3-1), ideal para hexaédricos.",
                                    "Construa tabela tensorial manualmente para 27 pontos.",
                                    "Repita recitação e escrita 7 vezes."
                                  ],
                                  "verification": "Escreva a tabela completa de 3 pontos/pesos e compute soma de pesos = 2 (para ∫_{-1}^1 1 dx).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Flashcards avançados",
                                    "Software Python/MATLAB para validação"
                                  ],
                                  "tips": "Lembre: centro em 0 com peso ~8/9, laterais ~5/9.",
                                  "learningObjective": "Fixar valores de alta precisão para integração precisa em FEM 3D.",
                                  "commonMistakes": [
                                    "Inverter pesos do centro e laterais.",
                                    "Arredondar incorretamente (use 0.7746, 0.5556, 0.8889)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar pontos e pesos em integração numérica de hexaédricos",
                                  "subSteps": [
                                    "Implemente fórmula de integração: ∫ f dΩ ≈ Σ w_i w_j w_k f(ξ_i,η_j,ζ_k) * |J|.",
                                    "Teste com polinômio de grau 5 em cada direção usando 3x3x3.",
                                    "Compare resultado numérico com analítico para verificar exatidão.",
                                    "Aplique em exemplo 2D primeiro, depois 3D.",
                                    "Automatize em código simples para validação."
                                  ],
                                  "verification": "Compute integral de x^5 em [-1,1] com 3 pontos e confirme erro zero.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código Python/MATLAB template",
                                    "Elemento hexaédrico de referência"
                                  ],
                                  "tips": "Sempre normalize pesos para somar 2 em 1D.",
                                  "learningObjective": "Aplicar corretamente em contextos de elementos finitos 3D.",
                                  "commonMistakes": [
                                    "Esquecer jacobiano |J|.",
                                    "Não usar produto tensorial corretamente."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um elemento hexaédrico de referência [-1,1]^3, compute a integral de f(ξ,η,ζ) = ξ^4 η^3 ζ^2 usando 3x3x3 pontos Gauss-Legendre. Verifique que resulta em valor exato 2*(2/5)*(2/4)*(2/3) = 0.2667 após normalização.",
                              "finalVerifications": [
                                "Recitar pontos/pesos de 2 e 3 pontos sem erros.",
                                "Montar tabela tensorial 2x2x2 e 3x3x3 corretamente.",
                                "Integrar polinômio grau 5 com erro <1e-10.",
                                "Explicar extensão de 1D para 3D via produto tensorial.",
                                "Implementar em código e validar soma de pesos = 8 para volume unitário.",
                                "Identificar quando usar ordem 1 vs 2 em FEM."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos valores memorizados (erro <0.001).",
                                "Correta construção de grids tensorais 3D.",
                                "Exatidão em integrações de teste (erro numérico zero para polinômios adequados).",
                                "Compreensão teórica demonstrada em explicação.",
                                "Eficiência na aplicação prática (tempo e código limpo).",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Polinômios de Legendre e ortogonalidade.",
                                "Programação: Implementação em Python/MATLAB para FEM.",
                                "Física Computacional: Integração em simulações de mecânica dos sólidos.",
                                "Engenharia de Materiais: Análise de tensões em estruturas 3D.",
                                "Estatística: Métodos de quadratura em Monte Carlo."
                              ],
                              "realWorldApplication": "Na simulação de elementos finitos para análise estrutural de peças aeronáuticas ou automotivas, onde a integração precisa em hexaédricos garante precisão em campos de tensão e deformação sem malha excessivamente refinada."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.6.2.2",
                            "name": "Produto tensorial para integração 3D em hexaédricos",
                            "description": "Construir a tabela de pontos de Gauss 3D (ex: 8 pontos para 2x2x2) e pesos como produto de regras 1D, calculando o somatório ∑ w_i f(ξ_i,η_i,ζ_i) |det(J)| para integrais em elementos de 8 nós.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Pontos de Gauss em 1D e Regras de Integração Numérica",
                                  "subSteps": [
                                    "Estude a integração numérica de Gauss-Legendre em 1D: fórmula ∫_{-1}^1 f(ξ) dξ ≈ ∑ w_i f(ξ_i).",
                                    "Memorize posições e pesos para n=2 pontos: ξ = ±1/√3 ≈ ±0.577, w=1 cada.",
                                    "Derive ou liste tabelas para n=1,2,3 pontos de Gauss 1D.",
                                    "Implemente um exemplo simples em Python ou MATLAB para integrar polinômios exatos.",
                                    "Verifique precisão comparando com integral analítica."
                                  ],
                                  "verification": "Implementar código que integra x^3 em [-1,1] com erro <1e-10.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Tabela de pontos de Gauss 1D (Wikipedia ou livro de FEM)",
                                    "Python/MATLAB com numpy/scipy",
                                    "Livro: 'The Finite Element Method' de Zienkiewicz (cap. integração)"
                                  ],
                                  "tips": "Comece com n=1 para intuition, Gauss é exato para 2n-1 ordem.",
                                  "learningObjective": "Dominar regras de Gauss 1D como base para produtos tensorais.",
                                  "commonMistakes": [
                                    "Confundir ξ com abscissas de Newton-Cotes",
                                    "Esquecer normalização em [-1,1]",
                                    "Usar pesos errados para ordem errada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir Produto Tensorial para 2D e Estender Conceito a 3D",
                                  "subSteps": [
                                    "Entenda produto tensorial em 2D: pontos (ξ_i, η_j), pesos w_i * w_j para quadriláteros.",
                                    "Construa manualmente tabela 2x2 para 2D: 4 pontos, pesos 1x1=1.",
                                    "Estenda para 3D: pontos (ξ_i, η_j, ζ_k), pesos w_i w_j w_k para hexaédricos.",
                                    "Liste coordenadas e pesos para 2x2x2: 8 pontos nos octantes.",
                                    "Desenhe diagrama do cubo de referência [-1,1]^3 com pontos marcados."
                                  ],
                                  "verification": "Tabela escrita corretamente com 8 pontos e pesos todos=1.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel e lápis para tabela",
                                    "Software de plotagem como Matplotlib para visualizar pontos",
                                    "Notas de aula sobre isoparamétricos"
                                  ],
                                  "tips": "Pense em grades cartesianas: produto direto de vetores 1D.",
                                  "learningObjective": "Compreender separabilidade da integração em coordenadas locais.",
                                  "commonMistakes": [
                                    "Inverter índices i,j,k",
                                    "Esquecer multiplicação de pesos",
                                    "Confundir com mapeamento global"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear para Elemento Hexaédrico e Calcular Jacobiano",
                                  "subSteps": [
                                    "Revise mapeamento isoparamétrico: x = ∑ N_i(ξ,η,ζ) x_i para 8 nós.",
                                    "Calcule Jacobiana J = ∂(x,y,z)/∂(ξ,η,ζ), det(J) em cada ponto Gauss.",
                                    "Para hexa unitário, demonstre det(J)=1 constante.",
                                    "Implemente função para computar det(J) em pontos arbitrários.",
                                    "Teste com elemento distorcido: mova um nó e recalcule."
                                  ],
                                  "verification": "Código computa det(J) corretamente para cubo unitário (det=1).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código base em Python (NumPy para derivadas)",
                                    "Matrizes de forma bilinear 3D para hexa8",
                                    "Ferramenta symbolic como SymPy para derivar N_i"
                                  ],
                                  "tips": "Use vetores de forma N = [1-ξ-η-ζ+ξη+ξζ+ηζ-ξηζ, ...] para 8 nós.",
                                  "learningObjective": "Integrar pontos Gauss com transformação geométrica via |det(J)|.",
                                  "commonMistakes": [
                                    "Derivadas erradas de funções de forma",
                                    "Determinante de matriz 3x3 mal calculado",
                                    "Esquecer multiplicar por |det(J)| no somatório"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Somatório de Integração e Validar",
                                  "subSteps": [
                                    "Escreva fórmula completa: ∫_Ω f dΩ ≈ ∑ w_i f(ξ_i,η_i,ζ_i) |det(J_i)|.",
                                    "Escolha f teste: constante=1 (deve dar volume=8 para cubo [-1,1]^3).",
                                    "Implemente loop sobre 8 pontos, some termos.",
                                    "Teste funções polinomiais até ordem 3 (exato com 2 pts/dim).",
                                    "Compare com analítico e analise erro para ordem alta."
                                  ],
                                  "verification": "Integração de 1 dá volume exato; x^2+y^2+z^2 com erro <1e-12.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python completo",
                                    "Jupyter notebook para plots de erro",
                                    "Referência: Hughes 'The Finite Element Method'"
                                  ],
                                  "tips": "Vetorize com meshgrid para eficiência em código.",
                                  "learningObjective": "Aplicar integral numérica em FEM 3D com precisão.",
                                  "commonMistakes": [
                                    "Loop errado nos índices tensorais",
                                    "Sinais errados em det(J)",
                                    "Normalização de domínio físico esquecida"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um elemento hexaédrico unitário mapeado de [-1,1]^3, integre f=1 + x*y*z usando 2x2x2 Gauss. Tabela: pontos como (±0.577,±0.577,±0.577) todas combinações, w=1. Como det(J)=1, somatório= ∑ f_i *1 = volume 8 + termo zero por simetria.",
                              "finalVerifications": [
                                "Tabela 2x2x2 construída corretamente com 8 pontos e pesos.",
                                "Código integra constante=1 dando volume exato do elemento.",
                                "det(J) calculado para elemento distorcido sem singularidades.",
                                "Erro de integração para polinômio cúbico <1e-10.",
                                "Visualização de pontos Gauss no cubo de referência.",
                                "Comparação com regra 1x1x1 mostrando ganho de precisão."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção da tabela tensorial (100% pontos/pesos corretos).",
                                "Correta implementação de Jacobiana e det(J) (teste unitário passa).",
                                "Eficiência do código: vetorizado, sem loops desnecessários.",
                                "Validação com múltiplas funções teste (exato até ordem 3).",
                                "Explicação clara do processo em relatório ou comentários.",
                                "Tratamento de casos edge: det(J)=0 ou negativo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Quadratura Gauss-Legendre e análise de erro.",
                                "Programação: Vetorização NumPy, computação científica.",
                                "Física/Engenharia: Análise de tensões em sólidos via FEM.",
                                "Geometria Computacional: Mapeamentos isoparamétricos.",
                                "Otimização: Escolha de ordens de Gauss para precisão vs custo."
                              ],
                              "realWorldApplication": "Em simulações FEM de estruturas mecânicas (ex: análise de tensão em peças automotivas com ANSYS/Abaqus), o produto tensorial permite integração eficiente em milhões de hexaédricos para prever falhas sob carga."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.6.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.6.2.3",
                            "name": "Montagem de matrizes MEF com integração em hexaédricos",
                            "description": "Aplicar integração numérica reduzida ou total em hexaédricos para problemas de tensão em sólidos 3D, resolvendo exemplos com distorção e verificando convergência e precisão em relação a soluções analíticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão de geometria e funções de forma em elementos hexaédricos",
                                  "subSteps": [
                                    "Estude a parametrização isoparamétrica do hexaédrico 8-nós (Q8) no espaço ξ, η, ζ de -1 a 1.",
                                    "Derive as funções de forma Ni(ξ,η,ζ) para cada nó.",
                                    "Calcule o Jacobiano J para mapeamento do elemento pai para o real, considerando distorções.",
                                    "Implemente cálculo de J em código para um elemento distorcido.",
                                    "Verifique isoparametria para elementos regulares e distorcidos."
                                  ],
                                  "verification": "Implemente e plote as funções de forma em software; confirme que somam 1 em pontos internos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Finite Element Procedures' de Bathe (cap. 5)",
                                    "Python/MATLAB com NumPy/SciPy",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use coordenadas naturais para evitar confusões; teste com elemento cúbico unitário primeiro.",
                                  "learningObjective": "Compreender a base geométrica para integração precisa em hexaédricos.",
                                  "commonMistakes": [
                                    "Confundir ordem das funções de forma (bilinear vs trilinear)",
                                    "Ignorar det(J) negativo em elementos distorcidos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Seleção e configuração de pontos de Gauss para integração numérica",
                                  "subSteps": [
                                    "Defina pontos de Gauss e pesos para integração total (2x2x2) e reduzida (1x1x1 ou 2x2x2 seletiva) em 3D.",
                                    "Compare precisão e custo computacional entre esquemas para problemas lineares elásticos.",
                                    "Implemente rotina para calcular valores de Ni, ∇Ni no espaço isoparamétrico nos pontos de Gauss.",
                                    "Transforme ∇Ni para espaço global usando inversa do Jacobiano.",
                                    "Teste exatidão da integração para polinômios conhecidos (ex: constante, linear)."
                                  ],
                                  "verification": "Integre analiticamente volume do elemento e compare com numérico; erro < 1e-10.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Tabela de pontos de Gauss 3D (Wikipedia ou livro Zienkiewicz)",
                                    "Código Python para quadratura Gauss-Legendre"
                                  ],
                                  "tips": "Para integração reduzida, use 1 ponto central em elementos lineares para rigidez exata.",
                                  "learningObjective": "Escolher esquema ótimo de integração baseado no problema.",
                                  "commonMistakes": [
                                    "Usar pesos errados para 3D (produto dos 1D)",
                                    "Esquecer transformação de gradientes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Montagem da matriz de rigidez elementar com integração numérica",
                                  "subSteps": [
                                    "Formule a matriz B (derivadas de deslocamentos) em cada ponto de Gauss.",
                                    "Calcule tensões/caixiais D para material isotrópico linear elástico.",
                                    "Integre K_e = ∑ [B^T D B * det(J) * w] sobre pontos de Gauss.",
                                    "Monte matriz para elemento único distorcido e compare total vs reduzida.",
                                    "Expanda para malha com múltiplos elementos, aplicando condições de contorno."
                                  ],
                                  "verification": "Para elemento unitário não distorcido, K_e deve coincidir com fórmula analítica.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Software FEniCS ou código próprio em Python",
                                    "Exemplo de malha hexaédrica simples"
                                  ],
                                  "tips": "Vetorize loops em código para eficiência; normalize unidades consistentemente.",
                                  "learningObjective": "Implementar montagem numérica da matriz MEF para sólidos 3D.",
                                  "commonMistakes": [
                                    "Erro no cálculo de B (simétrica vs assimétrica)",
                                    "Fator det(J) fora da soma"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolução numérica, verificação de convergência e precisão",
                                  "subSteps": [
                                    "Aplique condições de contorno e resolva K u = F para deslocamentos.",
                                    "Calcule tensões/deformações pós-processamento nos pontos de Gauss.",
                                    "Refine malha (h-refinamento) e compare com solução analítica (ex: tração uniaxial).",
                                    "Avalie norma de erro L2 em deslocamentos e tensões vs analítica.",
                                    "Analise impacto de distorção elementar na precisão e convergência."
                                  ],
                                  "verification": "Gráfico de log(error) vs log(1/h) mostra convergência de ordem 2.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Solução analítica para cubo em tração",
                                    "Biblioteca para solver linear (SciPy sparse)"
                                  ],
                                  "tips": "Use malha estruturada inicialmente; monitore condição numérica de K.",
                                  "learningObjective": "Validar implementação através de convergência e precisão.",
                                  "commonMistakes": [
                                    "Condições de contorno rígidas causando singularidade",
                                    "Escala errada em erros relativos"
                                  ]
                                }
                              ],
                              "practicalExample": "Analise tensão em um cubo de 1m³ de aço (E=200GPa, ν=0.3) sob tração uniaxial σ=100MPa na face z=1m. Use malha 2x2x2 hexaédricos com integração reduzida 1x1x1, distorça um elemento movendo nó em 10%, resolva u_z e compare ε_zz = u_z/z com analítica 5e-4. Refine para 4x4x4 e verifique convergência.",
                              "finalVerifications": [
                                "Matriz K_e montada numericamente coincide com analítica para elemento regular (erro <1%).",
                                "Solução numérica reproduz deformação analítica com erro <5% em malha grosseira.",
                                "Convergência observada de ordem ~2 em norma L2 de deslocamentos.",
                                "Integração reduzida economiza 70% tempo sem perda de precisão em linear.",
                                "Distorção <20% não afeta precisão significativamente.",
                                "Tensões nos pontos de Gauss são consistentes e simétricas."
                              ],
                              "assessmentCriteria": [
                                "Correção na implementação de pontos de Gauss e Jacobiano (teste unitário).",
                                "Eficiência computacional: tempo de montagem escalável com nº elementos.",
                                "Análise de convergência documentada com gráficos.",
                                "Comparação quantitativa total vs reduzida (precisão e custo).",
                                "Tratamento adequado de distorções elementares.",
                                "Código limpo, comentado e reproduzível."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Quadratura Gauss e análise de erro de integração.",
                                "Programação Científica: Vetorização e solvers esparsos em Python/MATLAB.",
                                "Física/Mecânica: Teoria de elasticidade linear e soluções exatas.",
                                "Computação de Alto Desempenho: Paralelização para malhas grandes.",
                                "Engenharia de Software: Validação e verificação numérica (VV&V)."
                              ],
                              "realWorldApplication": "Simulação de tensões em componentes estruturais complexos como fuselagens de aviões, chassis de veículos ou barragens, permitindo otimização de design, previsão de falhas e redução de protótipos físicos em indústrias aeroespacial, automotiva e civil."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.6.2.1",
                              "10.1.5.6.2.2"
                            ]
                          },
                          {
                            "id": "10.1.5.6.2.4",
                            "name": "Comparar integrações em tetraédricos vs. hexaédricos",
                            "description": "Analisar diferenças entre regras de Gauss bariocêntricas (tetraédricos) e tensorial (hexaédricos), avaliando eficiência computacional e precisão em malhas 3D para formulações do MEF.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Integração Numérica em Elementos Tetraédricos",
                                  "subSteps": [
                                    "Estudar as coordenadas bariocêntricas para tetraédricos e sua relação com o volume do elemento.",
                                    "Listar regras de Gauss bariocêntricas comuns (ex: 1, 4, 5 pontos) com pesos e posições.",
                                    "Derivar a fórmula de integração quadratura para funções polinomiais em 3D.",
                                    "Implementar uma função simples em Python para calcular integrais em tetraédricos unitários.",
                                    "Testar com funções monomiais para verificar precisão de ordem."
                                  ],
                                  "verification": "Código Python produz resultados corretos para integrais conhecidas de funções monomiais até ordem 3.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Notebook Jupyter, biblioteca NumPy/SciPy, referência: Zienkiewicz 'Finite Element Method' Cap. 3.",
                                  "tips": "Use visualizações 3D (Matplotlib) para plotar pontos de Gauss dentro do tetraédrico.",
                                  "learningObjective": "Compreender a base matemática da integração bariocêntrica em tetraédricos.",
                                  "commonMistakes": "Confundir coordenadas bariocêntricas com cartesianas; ignorar normalização dos pesos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar Fundamentos de Integração Numérica em Elementos Hexaédricos",
                                  "subSteps": [
                                    "Explicar o mapeamento isoparamétrico de hexaédrico para cubo referência [-1,1]^3.",
                                    "Descrever regras de Gauss-Legendre tensorais (ex: 2x2x2, 3x3x3 pontos) e produto de 1D.",
                                    "Calcular Jacobiano do mapeamento e seu impacto na integração.",
                                    "Codificar em Python a avaliação de integrais em hexaédricos distorcidos.",
                                    "Comparar numericamente com integrais analíticas para validação."
                                  ],
                                  "verification": "Implementação computa integral exata para polinômios até grau igual ao número de pontos.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Notebook Jupyter, NumPy/SciPy, PDF de Hughes 'Finite Element Method' Cap. 4.",
                                  "tips": "Decupe o produto tensorial em loops aninhados para clareza no código.",
                                  "learningObjective": "Dominar a integração tensorial separável em hexaédricos.",
                                  "commonMistakes": "Esquecer o determinante do Jacobiano; usar pontos Gauss sem transformação para o elemento real."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Formulações Matemáticas das Regras de Integração",
                                  "subSteps": [
                                    "Tabular número de pontos, grau de precisão e pesos para regras equivalentes (ex: 5 pts tet vs 2^3 hex).",
                                    "Analisar invariância geométrica: bariocêntrica vs dependente de distorção em hex.",
                                    "Derivar condições de exatidão para polinômios completos em 3D.",
                                    "Calcular custo FLOPs por elemento para cada método.",
                                    "Plotar comparações em tabela/gráfico usando Pandas/Matplotlib."
                                  ],
                                  "verification": "Tabela compara corretamente pelo menos 4 regras, com graus de precisão validados.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Excel ou Pandas para tabelas, referências teóricas de livros MEF.",
                                  "tips": "Foquem em regras de mesma precisão para comparação justa.",
                                  "learningObjective": "Identificar diferenças algébricas e geométricas entre métodos.",
                                  "commonMistakes": "Comparar regras de precisões diferentes; negligenciar custo de transformação Jacobiana."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Eficiência Computacional e Precisão em Malhas 3D",
                                  "subSteps": [
                                    "Gerar malhas 3D simples (tet e hex) com Gmsh ou MeshPy.",
                                    "Implementar solver MEF trivial (ex: Laplace) usando ambas integrações.",
                                    "Medir tempo de CPU e erro L2 para malhas refinadas (h-refinamento).",
                                    "Analisar convergência: ordem log-log plot de erro vs tempo.",
                                    "Discutir trade-offs: tets mais flexíveis mas mais pontos vs hex eficientes."
                                  ],
                                  "verification": "Gráficos mostram convergência ótima e hex mais rápido em malhas regulares.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Gmsh/MeshPy para malhas, FEniCS ou código custom Python, timer (timeit).",
                                  "tips": "Use malhas com 100-1000 elementos para testes rápidos.",
                                  "learningObjective": "Quantificar vantagens/desvantagens em cenários reais de MEF.",
                                  "commonMistakes": "Malhas não refinadas uniformemente; ignorar overhead de montagem da matriz."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar Comparação e Recomendações",
                                  "subSteps": [
                                    "Resumir prós/contras: precisão, custo, adaptabilidade a geometrias.",
                                    "Discutir casos ideais: hex para estruturas regulares, tet para complexas.",
                                    "Revisar literatura (ex: papers sobre full vs reduced integration).",
                                    "Preparar relatório com tabelas, gráficos e conclusões.",
                                    "Testar sensibilidade a distorções em elementos hex."
                                  ],
                                  "verification": "Relatório de 1-2 páginas com evidências quantitativas e qualitativas.",
                                  "estimatedTime": "1 hora",
                                  "materials": "LaTeX ou Markdown para relatório, dados dos passos anteriores.",
                                  "tips": "Inclua citações para robustez acadêmica.",
                                  "learningObjective": "Formular juízo crítico baseado em análise.",
                                  "commonMistakes": "Viés para um método sem dados; generalizar de testes isolados."
                                }
                              ],
                              "practicalExample": "Em uma análise de tensão em uma viga cantilever com geometria irregular, use malha tetraédrica com 5-pt Gauss bariocêntrico vs hexaédrica mapeada com 2x2x2 tensorial: hex leva 40% menos tempo com precisão similar em regiões regulares, mas tet captura melhor singularidades nas bordas.",
                              "finalVerifications": [
                                "Explicar verbalmente diferenças em regras de Gauss para tet/hex.",
                                "Executar código que compara tempo/erro em malha fornecida.",
                                "Identificar quando usar cada método em problema dado.",
                                "Plotar convergência correta de ambos.",
                                "Listar 3 trade-offs computacionais com justificativa.",
                                "Relatório sintetiza análise sem erros factuais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição matemática (90% correto).",
                                "Análise quantitativa com dados numéricos (gráficos/tabelas).",
                                "Profundidade da comparação eficiência/precisão.",
                                "Clareza no código e verificações.",
                                "Juízo crítico em recomendações.",
                                "Conexão com MEF prático."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Quadratura e análise de erro.",
                                "Programação Científica: Implementação eficiente em Python/FEniCS.",
                                "Física Computacional: Modelagem MEF em sólidos.",
                                "Otimização: Trade-offs custo-benefício em HPC.",
                                "Geometria Computacional: Geração e qualidade de malhas."
                              ],
                              "realWorldApplication": "Em simulações CAE como ANSYS ou Abaqus para design automotivo/aeroespacial, escolher tet para geometrias orgânicas (ex: crash-test) e hex para eficiência em turbinas, otimizando tempo de simulação de dias para horas sem perda de precisão."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.6.1.3",
                              "10.1.5.6.2.3"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.6",
                "name": "Problemas de Campo Escalar",
                "description": "Aplicações em transferência de calor, torção, escoamento potencial, escoamento compressível não viscoso e acústica.",
                "totalSkills": 48,
                "atomicTopics": [
                  {
                    "id": "10.1.6.1",
                    "name": "Transferência de Calor",
                    "description": "Aplicação do método dos elementos finitos em problemas de condução e difusão de calor governados por equações de campo escalar.",
                    "individualConcepts": [
                      {
                        "id": "34.4.1.1",
                        "name": "Equação Governante para Transferência de Calor",
                        "description": "Apresenta a equação diferencial parcial que governa os problemas de condução e difusão de calor, incluindo formas estacionária (equação de Poisson) e transitória, com fontes de calor e condições de contorno.",
                        "specificSkills": [
                          {
                            "id": "34.4.1.1.1",
                            "name": "Identificar a equação de condução de calor",
                            "description": "Reconhecer e escrever a equação geral de transferência de calor em termos de campo escalar T (temperatura), incluindo termos de difusão, convecção, fonte e transitoriedade, no formato -∇·(k∇T) + ρc ∂T/∂t = Q.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos da transferência de calor",
                                  "subSteps": [
                                    "Estude os três modos principais de transferência de calor: condução, convecção e radiação.",
                                    "Revise as propriedades termofísicas envolvidas: condutividade térmica k, densidade ρ, calor específico c e fonte de calor Q.",
                                    "Entenda o conceito de campo escalar T (temperatura) e suas derivadas em espaços tridimensionais.",
                                    "Analise exemplos simples de problemas térmicos estacionários e transientes.",
                                    "Diferencie difusão (condução), advecção (convecção) e geração de calor."
                                  ],
                                  "verification": "Resuma em um parágrafo os modos de transferência e propriedades chave, sem erros conceituais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Transferência de Calor (Incropera), vídeo introdutório no YouTube sobre modos de calor.",
                                  "tips": "Use diagramas para visualizar cada modo de transferência.",
                                  "learningObjective": "Identificar e descrever os componentes básicos da transferência de calor.",
                                  "commonMistakes": "Confundir convecção com condução ou ignorar a radiação em contextos iniciais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o balanço de energia em um volume de controle",
                                  "subSteps": [
                                    "Defina um volume de controle infinitesimal dV em um meio contínuo.",
                                    "Escreva o balanço de energia: taxa de energia armazenada = entrada - saída + geração.",
                                    "Expresse a taxa de armazenamento como ρc ∂T/∂t dV.",
                                    "Descreva os fluxos de calor por condução usando a lei de Fourier: q = -k ∇T.",
                                    "Inclua termos de convecção (ρc u · ∇T) e fonte volumétrica Q."
                                  ],
                                  "verification": "Esboce o balanço de energia para um volume dV e liste todos os termos corretamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Folha de papel para esboços, software de desenho vetorial como Draw.io, notas de aula sobre balanço de conservação.",
                                  "tips": "Sempre comece pelo princípio da conservação de energia para evitar erros.",
                                  "learningObjective": "Formular o balanço integral de energia que leva à equação diferencial.",
                                  "commonMistakes": "Esquecer o sinal negativo no fluxo de condução ou confundir ∂T/∂t com gradiente espacial."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a equação geral de transferência de calor",
                                  "subSteps": [
                                    "Divida o balanço pelo volume dV para obter a forma diferencial.",
                                    "Expresse a divergência do fluxo de condução: ∇ · (k ∇T).",
                                    "Inclua o termo transiente ρc ∂T/∂t e a convecção ρc (u · ∇T).",
                                    "Adicione a fonte Q e reorganize para: -∇·(k∇T) + ρc ∂T/∂t + ρc (u · ∇T) = Q.",
                                    "Simplifique para casos sem convecção se aplicável."
                                  ],
                                  "verification": "Derive a equação passo a passo em um caderno, chegando ao formato exato -∇·(k∇T) + ρc ∂T/∂t = Q.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Caderno de derivadas, calculadora simbólica como Wolfram Alpha para verificar divergências.",
                                  "tips": "Use o teorema da divergência para passar do fluxo superficial para o volume.",
                                  "learningObjective": "Derivar a equação governante a partir do balanço de energia.",
                                  "commonMistakes": "Erro no sinal do termo difusivo ou omissão do termo convectivo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e interpretar cada termo da equação",
                                  "subSteps": [
                                    "Identifique -∇·(k∇T) como termo de difusão/condução.",
                                    "Explique ρc ∂T/∂t como termo transiente/armazenamento.",
                                    "Descreva Q como fonte/geração de calor.",
                                    "Compare com casos estacionários (∂T/∂t = 0) e sem fonte (Q=0).",
                                    "Escreva a equação 5 vezes de memória, variando condições."
                                  ],
                                  "verification": "Rotule cada termo em uma equação impressa e explique seu significado físico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Equação impressa ou digital, flashcards com termos.",
                                  "tips": "Associe cada termo a um fenômeno físico real para fixar.",
                                  "learningObjective": "Reconhecer e nomear corretamente todos os termos na equação.",
                                  "commonMistakes": "Confundir convecção com transitoriedade ou inverter sinais."
                                }
                              ],
                              "practicalExample": "Em um dissipador de calor de um processador de computador, a equação -∇·(k∇T) + ρc ∂T/∂t = Q descreve como o calor gerado (Q pelo chip) difunde pelo material (k∇T) e varia no tempo (∂T/∂t) até estabilizar.",
                              "finalVerifications": [
                                "Escreve a equação completa sem consultar notas.",
                                "Identifica corretamente os 4 termos principais (difusão, transitoriedade, convecção, fonte).",
                                "Explica o significado físico de cada termo em uma frase.",
                                "Simplifica a equação para caso estacionário sem fonte.",
                                "Distingue de equações semelhantes como Navier-Stokes.",
                                "Resolve um problema simples: dada k constante, escreve ∇·(k∇T)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na escrita da equação (100% dos termos corretos).",
                                "Compreensão conceitual demonstrada em explicações verbais.",
                                "Capacidade de derivar de memória pelo menos 80% dos passos.",
                                "Identificação correta de termos em contextos variados.",
                                "Aplicação em exemplos reais sem erros.",
                                "Tempo de resposta inferior a 5 minutos para escrita."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo vetorial (gradiente, divergência).",
                                "Física: Termodinâmica e leis de conservação.",
                                "Engenharia de Materiais: Propriedades termofísicas variáveis.",
                                "Computação: Implementação numérica em métodos de elementos finitos."
                              ],
                              "realWorldApplication": "Usada em simulações de elementos finitos para projetar trocadores de calor em aviões, sistemas de refrigeração em data centers e análise térmica de baterias em veículos elétricos, otimizando eficiência energética e prevenindo falhas por superaquecimento."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.4.1.1.2",
                            "name": "Aplicar condições de contorno",
                            "description": "Definir e implementar condições de contorno essenciais (Dirichlet: T fixa) e naturais (Neumann: fluxo de calor q = -k∇T·n e Robin: convecção h(T - T∞)) em problemas de calor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos e Formulações Matemáticas das Condições de Contorno",
                                  "subSteps": [
                                    "Revisar a equação governante da transferência de calor: ∇·(k ∇T) = 0 (estado estacionário).",
                                    "Estudar condição Dirichlet: T = T_fixa em Γ_D.",
                                    "Estudar condição Neumann: q = -k ∇T · n = q_especificado em Γ_N.",
                                    "Estudar condição Robin: -k ∇T · n = h (T - T_∞) em Γ_R.",
                                    "Derivar as formas fracas integradas para MEF usando teste de Galerkin."
                                  ],
                                  "verification": "Escrever as três formulações matemáticas corretas e explicar diferenças em um relatório curto.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Análise de Elementos Finitos' de Bathe",
                                    "Notas de aula sobre MEF para calor",
                                    "Software de desenho para diagramas (ex: Draw.io)"
                                  ],
                                  "tips": "Use analogias físicas: Dirichlet como termômetro fixo, Neumann como isolamento, Robin como vento resfriando.",
                                  "learningObjective": "Formular precisamente as condições de contorno matemáticas e suas interpretações físicas.",
                                  "commonMistakes": [
                                    "Confundir o sinal do fluxo Neumann (sempre verificar normal externa)",
                                    "Esquecer que Robin é mista (afeta matriz e vetor)",
                                    "Ignorar unidades consistentes (W/m² para q e h)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Condições de Dirichlet em um Modelo de Elementos Finitos",
                                  "subSteps": [
                                    "Discretizar um domínio simples 1D (barra) com malha uniforme.",
                                    "Montar matriz de rigidez K e vetor f para o problema sem BCs.",
                                    "Identificar graus de liberdade (nós) na fronteira Dirichlet.",
                                    "Impor valores fixos: substituir linhas/colunas de K por zeros (exceto diagonal=1), f correspondente = T_fixa.",
                                    "Resolver Ku = f e plotar solução."
                                  ],
                                  "verification": "Verificar que T nos nós Dirichlet é exatamente o valor imposto (erro < 1e-10).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB ou Python com NumPy/SciPy",
                                    "Código template para MEF 1D",
                                    "Planilha para malha"
                                  ],
                                  "tips": "Sempre salve o vetor de solução original para comparações; use penalização para casos complexos.",
                                  "learningObjective": "Aplicar penalização ou modificação direta para impor Dirichlet essencial em MEF.",
                                  "commonMistakes": [
                                    "Não zerar linhas inteiras da matriz (leva a singularidade)",
                                    "Esquecer de ajustar o lado direito f adequadamente",
                                    "Malha não refinada na fronteira"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Condições de Neumann e Integrá-las ao Modelo",
                                  "subSteps": [
                                    "Estender o modelo 1D para incluir fronteira Neumann.",
                                    "Calcular contribuição de Neumann: ∫_Γ_N q · φ_i dΓ adicionado a f_i.",
                                    "Para q=0 (isolamento), confirmar que não altera f.",
                                    "Para fluxo não-nulo, computar integral numericamente (Gauss-Legendre).",
                                    "Resolver e validar contra solução analítica (ex: barra com fluxo constante)."
                                  ],
                                  "verification": "Comparar fluxo calculado -k dT/dx na fronteira com q imposto (erro < 1%).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com SciPy para integração",
                                    "Tabela de pontos Gauss",
                                    "Solução analítica impressa"
                                  ],
                                  "tips": "Neumann é natural: só afeta o vetor f, não modifica K.",
                                  "learningObjective": "Incorporar contribuições de fluxo Neumann no vetor de carregamento de forma precisa.",
                                  "commonMistakes": [
                                    "Erro no sinal da normal n (externa ao domínio)",
                                    "Integral mal computada em elementos curvos",
                                    "Confundir com Dirichlet (Neumann não fixa T)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Condições de Robin e Validar Problema Completo",
                                  "subSteps": [
                                    "Adicionar fronteira Robin ao modelo 1D ou 2D simples.",
                                    "Calcular contribuições: ∫_Γ_R h T_∞ φ_i dΓ para f_i e ∫_Γ_R h φ_i φ_j dΓ para K_ij.",
                                    "Montar sistema completo com todas BCs mistas.",
                                    "Resolver, plotar contornos de T e calcular gradientes.",
                                    "Sensitividade: variar h e observar impacto."
                                  ],
                                  "verification": "Verificar balanço energético: fluxo total entra = sai (erro < 0.5%).",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "FEniCS ou FreeFEM para 2D",
                                    "Código Python estendido",
                                    "Gráficos de referência analítica"
                                  ],
                                  "tips": "Robin modela convecção real; teste com h→∞ (aproxima Dirichlet).",
                                  "learningObjective": "Integrar BCs Robin mistas, afetando tanto rigidez quanto carregamento.",
                                  "commonMistakes": [
                                    "Esquecer termo de acoplamento em K para Robin",
                                    "h com unidades erradas (W/m²K)",
                                    "Não normalizar integral de superfície"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Otimizar a Implementação em Problema Realista",
                                  "subSteps": [
                                    "Aplicar a um problema 2D: placa com BCs mistas.",
                                    "Refinar malha e estudar convergência (erro L2 < 1%).",
                                    "Implementar pós-processamento: mapas de T, fluxos, hotspots.",
                                    "Documentar código com comentários sobre cada BC.",
                                    "Testar casos limite (h=0 Neumann, h=∞ Dirichlet)."
                                  ],
                                  "verification": "Convergência confirmada e resultados físicos plausíveis (ex: gradientes suaves).",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Solver MEF (ANSYS Student ou código próprio)",
                                    "Dados de benchmark de literatura"
                                  ],
                                  "tips": "Use malha adaptativa perto de singularidades (cantos).",
                                  "learningObjective": "Validar implementação completa com análise de convergência e física.",
                                  "commonMistakes": [
                                    "Malha grosseira leva a oscilações",
                                    "Ignorar não-linearidades em h variável",
                                    "Falta de normalização em domínios não-unitários"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule a distribuição de temperatura em uma placa retangular de aço (k=50 W/mK) com: borda esquerda a 100°C (Dirichlet), borda direita isolada (Neumann q=0), borda superior com convecção h=25 W/m²K para T_∞=20°C (Robin), e borda inferior simétrica. Use malha 20x10 elementos, resolva estacionário e plote contornos de T e vetores de fluxo.",
                              "finalVerifications": [
                                "Todas formulações matemáticas corretas para Dirichlet, Neumann e Robin.",
                                "Implementação numérica reproduz valores impostos em fronteiras (erro numérico <1e-8).",
                                "Balanço global de energia: ∫ q dΓ = 0 para problemas estacionários fechados.",
                                "Convergência com refinamento de malha (erro L2 diminui monotonicamente).",
                                "Resultados físicos coerentes: gradientes nulos em isolantes, hotspots corretos.",
                                "Código modular e comentado, executável sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão das formulações teóricas (100% correto).",
                                "Correta montagem de K e f para cada tipo de BC (verificação matricial).",
                                "Eficiência numérica: tempo de solução <5s para malha 1000 DOFs.",
                                "Qualidade de visualizações: contornos claros, escalas adequadas.",
                                "Análise de erros: identificação e quantificação de fontes.",
                                "Documentação: explicação clara de passos e escolhas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de funções de Sobolev e formulações variacionais fracas.",
                                "Física: Lei de Fourier para condução e lei de Newton para convecção.",
                                "Computação: Algoritmos de solvers lineares esparsos (ex: GMRES).",
                                "Engenharia Civil: Análise térmica em barragens e fundações.",
                                "Química: Simulação de difusão em reatores catalíticos."
                              ],
                              "realWorldApplication": "No design de dissipadores de calor para CPUs (Dirichlet em base, Robin em aletas), isolamento térmico de edifícios (Neumann em paredes isoladas), ou simulação de fornos industriais (Robin para convecção forçada), garantindo eficiência energética e prevenção de falhas por sobreaquecimento."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.4.1.1.3",
                            "name": "Simplificar para casos estacionário e 1D",
                            "description": "Derivar e resolver analiticamente casos simples como barra 1D com geração de calor uniforme, identificando perfis de temperatura linear e parabólico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a equação governante geral de transferência de calor",
                                  "subSteps": [
                                    "Escreva a equação de transferência de calor em 3D transitória: ρc ∂T/∂t = ∇·(k ∇T) + q̇",
                                    "Identifique os termos: capacitância térmica, condução, geração de calor",
                                    "Discuta as hipóteses de Fourier para isotropia e k constante",
                                    "Pratique reescrevendo em coordenadas cartesianas",
                                    "Compare com formas em coordenadas cilíndricas/esféricas para contexto"
                                  ],
                                  "verification": "Capacidade de derivar a equação geral de memória e explicar cada termo verbalmente",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro-texto de transferência de calor (ex: Incropera)",
                                    "Papel e caneta"
                                  ],
                                  "tips": "Use analogia com conservação de energia para memorizar termos",
                                  "learningObjective": "Compreender a forma geral da equação de calor e seus componentes físicos",
                                  "commonMistakes": "Confundir ∇·(k ∇T) com k ∇²T quando k varia; assumir k sempre constante"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar simplificações para regime estacionário e 1D",
                                  "subSteps": [
                                    "Defina estacionário: ∂T/∂t = 0, resultando em ∇·(k ∇T) + q̇ = 0",
                                    "Simplifique para 1D em x: d/dx (k dT/dx) + q̇ = 0",
                                    "Assuma k constante: k d²T/dx² + q̇ = 0",
                                    "Discuta condições de contorno: Dirichlet (T fixa), Neumann (fluxo fixo)",
                                    "Verifique dimensionalmente a equação simplificada"
                                  ],
                                  "verification": "Derivar corretamente a equação 1D estacionária a partir da geral em menos de 5 minutos",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora para verificações numéricas"
                                  ],
                                  "tips": "Sempre anote as hipóteses feitas (ex: sem convecção, 1D) para rastrear erros",
                                  "learningObjective": "Dominar as simplificações matemáticas e físicas para casos estacionário e 1D",
                                  "commonMistakes": "Esquecer o sinal de q̇ ou inverter derivadas em 1D; ignorar variações de k"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular o problema da barra 1D com geração uniforme",
                                  "subSteps": [
                                    "Defina geometria: barra de comprimento L, seção transversal A constante",
                                    "Especifique q̇ uniforme e k constante",
                                    "Aplique condições de contorno: ex. T(0)=T1, T(L)=T2 (Dirichlet)",
                                    "Integre a EDO: d²T/dx² = -q̇/k → T(x) = -(q̇/(2k)) x² + C1 x + C2",
                                    "Aplique C.C. para encontrar C1 e C2"
                                  ],
                                  "verification": "Escrever a solução geral T(x) com constantes indeterminadas corretamente",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software simbólico como Mathematica ou SymPy (opcional)"
                                  ],
                                  "tips": "Integre duas vezes e aplique C.C. sistematicamente: primeiro para C2, depois C1",
                                  "learningObjective": "Configurar e preparar a solução analítica para barra com geração",
                                  "commonMistakes": "Erro no fator 2 na integração parabólica; condições de contorno trocadas"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver analiticamente e identificar perfis de temperatura",
                                  "subSteps": [
                                    "Caso sem geração (q̇=0): T(x) linear entre T1 e T2",
                                    "Caso com q̇ uniforme: T(x) parabólico, máximo no meio se T1=T2",
                                    "Plote graficamente ambos perfis para L=1m, k=10 W/mK, q̇=1000 W/m³, T(0)=T(L)=100°C",
                                    "Calcule gradientes e fluxos: q''(x) = -k dT/dx",
                                    "Compare com intuição física: geração aquece interior"
                                  ],
                                  "verification": "Derivar e plotar perfis corretos, identificando linear (sem q̇) vs. parabólico (com q̇)",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Excel ou Python/MATLAB para plotagem"
                                  ],
                                  "tips": "Verifique solução plugando na EDO original: deve satisfazer ∇·q + q̇=0",
                                  "learningObjective": "Resolver EDO analiticamente e interpretar perfis físicos",
                                  "commonMistakes": "Sinal errado no parabólico (concavidade para baixo); confundir linear com casos sem geração"
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e generalizar para outros casos simples",
                                  "subSteps": [
                                    "Teste caso Neumann: dT/dx(0)=0, T(L)=T2 → perfil ajustado",
                                    "Discuta limitações: 1D válido se Bi<<1 ou geometria esguia",
                                    "Compare solução analítica com numérica grosseira (2 nós)",
                                    "Gere variações: q̇ linear, k variável",
                                    "Documente em relatório curto"
                                  ],
                                  "verification": "Gerar solução para caso Neumann e discutir validade 1D",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Planilha para validação numérica"
                                  ],
                                  "tips": "Use não-dimensionalização (θ=T-Tref, ξ=x/L) para generalizar",
                                  "learningObjective": "Estender conhecimento para variações e validações",
                                  "commonMistakes": "Aplicar C.C. erradas em Neumann; ignorar efeitos 2D em barras grossas"
                                }
                              ],
                              "practicalExample": "Considere uma barra de aço de 0.5m (k=50 W/mK) com geração uniforme q̇=2000 W/m³ devido a resistências internas. Bordas mantidas em 20°C. Derive T(x)=20 + (q̇/(2k))(L²/4 - x²), plotando o perfil parabólico com máximo 45°C no centro. Calcule fluxo máximo na borda.",
                              "finalVerifications": [
                                "Derivação correta da EDO 1D estacionária de memória",
                                "Solução analítica exata para barra com q̇ uniforme e C.C. Dirichlet",
                                "Identificação precisa: linear sem q̇, parabólico com q̇",
                                "Gráfico qualitativo correto dos perfis",
                                "Cálculo de gradiente e fluxo em pelo menos um ponto",
                                "Explicação física da forma parabólica"
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação e integração (40%)",
                                "Correta aplicação e resolução de condições de contorno (20%)",
                                "Interpretação física dos perfis de temperatura (20%)",
                                "Uso de unidades consistentes e verificações dimensionais (10%)",
                                "Clareza na documentação e gráficos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Solução de EDOs lineares de 2ª ordem",
                                "Física: Lei de Fourier e balanço energético",
                                "Programação: Implementação em Python/SymPy para soluções simbólicas",
                                "Engenharia de Materiais: Propriedades térmicas (k, ρ, c)",
                                "Análise Numérica: Preparação para Método dos Elementos Finitos"
                              ],
                              "realWorldApplication": "Projeto de dissipadores de calor em eletrônicos (perfil parabólico devido a Joule heating), reatores nucleares (geração uniforme de calor fissionável), ou isolantes em tubulações industriais para prever gradientes e evitar hotspots."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "34.4.1.2",
                        "name": "Formulação Variacional e Método de Galerkin",
                        "description": "Descreve a transformação da equação forte para a forma fraca via integração por partes, aplicando o método de Galerkin para problemas de campo escalar em transferência de calor.",
                        "specificSkills": [
                          {
                            "id": "34.4.1.2.1",
                            "name": "Derivar a forma fraca da equação",
                            "description": "Realizar integração por partes na equação de Poisson para obter ∫∇v·k∇T dV = ∫v Q dV + ∫v q dS, onde v são funções teste.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a equação forte de Poisson para transferência de calor",
                                  "subSteps": [
                                    "Identifique a equação diferencial forte: -∇·(k ∇T) = Q em Ω, onde T é temperatura, k condutividade térmica, Q fonte de calor.",
                                    "Defina as condições de contorno: Dirichlet (T = g em Γ_D) e Neumann (-k ∇T · n = q em Γ_N).",
                                    "Explique o significado físico: equilíbrio estacionário de calor.",
                                    "Esboce um domínio Ω simples com fronteiras Γ_D e Γ_N.",
                                    "Verifique unidades: consistência dimensional de cada termo."
                                  ],
                                  "verification": "Escreva a equação forte completa com condições de contorno e explique fisicamente em 2-3 frases.",
                                  "estimatedTime": "20 min",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de Elementos Finitos (cap. Formulação Variacional)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Comece pelo caso 1D para intuição: d/dx (k dT/dx) = -Q.",
                                  "learningObjective": "Dominar a formulação forte e suas condições de contorno.",
                                  "commonMistakes": [
                                    "Confundir sinal da equação (∇· ou -∇·)",
                                    "Ignorar distinção entre Γ_D e Γ_N",
                                    "Esquecer vetor normal n na Neumann"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir funções teste e formular o problema primal",
                                  "subSteps": [
                                    "Escolha funções teste v ∈ H¹_0(Ω), ou seja, v=0 em Γ_D, suaves o suficiente.",
                                    "Multiplique a equação forte por v e integre em Ω: ∫_Ω v (-∇·(k ∇T)) dV = ∫_Ω v Q dV.",
                                    "Defina o espaço de funções apropriado para Galerkin.",
                                    "Escreva a equação integral inicial sem integração por partes.",
                                    "Verifique simetria e propriedades de v."
                                  ],
                                  "verification": "Escreva a integral fraca inicial e confirme que v satisfaz condições essenciais.",
                                  "estimatedTime": "25 min",
                                  "materials": [
                                    "Caderno de matemática",
                                    "Software simbólico como SymPy ou Mathematica para verificação opcional"
                                  ],
                                  "tips": "Lembre: funções teste testam a equação em pontos fracos.",
                                  "learningObjective": "Formular o problema de forma integral multiplicando por funções teste.",
                                  "commonMistakes": [
                                    "Não impor v=0 em Γ_D",
                                    "Usar integração errada inicialmente",
                                    "Confundir T e v"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar integração por partes no termo diferencial",
                                  "subSteps": [
                                    "Use identidade: ∫_Ω v ∇·(k ∇T) dV = ∫_∂Ω v (k ∇T · n) dS - ∫_Ω ∇v · (k ∇T) dV.",
                                    "Substitua na equação: ∫_Ω ∇v · k ∇T dV - ∫_∂Ω v (k ∇T · n) dS = ∫_Ω v Q dV.",
                                    "Inverta sinais para forma padrão: ∫_Ω ∇v · k ∇T dV = ∫_Ω v Q dV + ∫_∂Ω v (k ∇T · n) dS.",
                                    "Aplique condições de contorno: em Γ_N, k ∇T · n = -q; em Γ_D, v=0.",
                                    "Simplifique: ∫_Ω ∇v · k ∇T dV = ∫_Ω v Q dV + ∫_Γ_N v q dS."
                                  ],
                                  "verification": "Derive passo a passo a identidade de integração por partes e aplique às fronteiras.",
                                  "estimatedTime": "30 min",
                                  "materials": [
                                    "Folha com domínio esboçado",
                                    "Tabela de identidades vetoriais",
                                    "Calculadora simbólica"
                                  ],
                                  "tips": "Pratique em 1D: ∫ v (d/dx (k T')) dx = [v k T'] - ∫ v' k T'.",
                                  "learningObjective": "Executar integração por partes corretamente em forma vetorial.",
                                  "commonMistakes": [
                                    "Sinal errado no termo de contorno",
                                    "Esquecer o menos no Neumann (-k ∇T · n = q)",
                                    "Integrar por partes no Q"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Escrever e verificar a forma fraca final",
                                  "subSteps": [
                                    "Enuncie a forma fraca: Encontre T ∈ H¹_g(Ω) tal que ∀ v ∈ H¹_0(Ω), ∫_Ω ∇v · k ∇T dV = ∫_Ω v Q dV + ∫_Γ_N v q dS.",
                                    "Confirme consistência: T forte satisfaz a fraca.",
                                    "Discuta propriedades: bilinear a(u,v) = ∫ ∇v · k ∇T, linear l(v).",
                                    "Verifique coercividade e continuidade para existência (opcional intro).",
                                    "Teste com função T conhecida simples."
                                  ],
                                  "verification": "Escreva a forma fraca completa e teste com T=constante ou linear.",
                                  "estimatedTime": "20 min",
                                  "materials": [
                                    "Resumo de espaços de Sobolev básicos",
                                    "Exemplo numérico 1D"
                                  ],
                                  "tips": "Sempre especifique os espaços de funções!",
                                  "learningObjective": "Consolidar a derivação da forma fraca de Galerkin.",
                                  "commonMistakes": [
                                    "Deixar ∫_Γ_D no final",
                                    "Trocar ∇v e ∇T",
                                    "Omitir espaços funcionais"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar com exemplo prático e generalizações",
                                  "subSteps": [
                                    "Resolva um caso 1D: k=1, Ω=[0,1], Q=0, T(0)=0, q=1 em x=1.",
                                    "Derive forma fraca e encontre T exata: T=x.",
                                    "Generalize para k variável ou 2D.",
                                    "Compare com discretização FEM básica.",
                                    "Documente o processo em um fluxograma."
                                  ],
                                  "verification": "Derive e resolva o exemplo 1D, confirmando resultado.",
                                  "estimatedTime": "25 min",
                                  "materials": [
                                    "Python/MATLAB para plot opcional",
                                    "Papel milimetrado"
                                  ],
                                  "tips": "Use exemplos numéricos para fixar intuição.",
                                  "learningObjective": "Aplicar derivação em contexto concreto e estender.",
                                  "commonMistakes": [
                                    "Erro aritmético no exemplo",
                                    "Não verificar consistência",
                                    "Ignorar generalizações"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere transferência de calor 1D em barra de comprimento L=1, k=1 constante, Q=0, T(0)=0 (Dirichlet), fluxo q=1 em x=1 (Neumann). Equação forte: -d²T/dx²=0. Forma fraca: ∫₀¹ (d v/dx)(d T/dx) dx = ∫₀¹ v(1) *1 dx, levando a T(x)=x.",
                              "finalVerifications": [
                                "Derive corretamente a integração por partes sem erros de sinal.",
                                "Incorpore condições de contorno adequadamente (v=0 em Γ_D).",
                                "Especifique espaços funcionais H¹_g(Ω) e H¹_0(Ω).",
                                "Teste consistência com solução forte conhecida.",
                                "Explique verbalmente o processo em 5 minutos.",
                                "Resolva exemplo 1D e verifique numericamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da identidade de Green (integração por partes).",
                                "Correta aplicação de condições de contorno mistas.",
                                "Clareza na escrita da forma bilinear a(u,v) e linear l(v).",
                                "Compreensão conceitual: diferença entre forma forte e fraca.",
                                "Capacidade de validar com exemplo concreto.",
                                "Identificação de erros comuns e correções."
                              ],
                              "crossCurricularConnections": [
                                "Física: Leis de Fourier e conservação de energia.",
                                "Programação: Implementação em FEM (bibliotecas como FEniCS).",
                                "Análise Numérica: Estabilidade e converência de Galerkin.",
                                "Matemática Pura: Espaços de Sobolev e Teoria da Distribuição.",
                                "Engenharia: Simulações CFD e otimização térmica."
                              ],
                              "realWorldApplication": "Em simulações de elementos finitos para análise térmica em motores aeronáuticos, onde se modela distribuição de temperatura em pás de turbina sob cargas térmicas variáveis, permitindo otimizar refrigeração e prevenir falhas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.4.1.1.1"
                            ]
                          },
                          {
                            "id": "34.4.1.2.2",
                            "name": "Aplicar princípio de Galerkin",
                            "description": "Escolher funções teste v = funções de interpolação N_i e aproximar T^h = ∑ T_j N_j, levando à forma matricial do problema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Derivar a forma variacional do problema de transferência de calor",
                                  "subSteps": [
                                    "Identifique o problema governante: -∇·(k ∇T) = f em Ω, com condições de contorno essenciais e naturais.",
                                    "Multiplique a equação pela função teste v (suave, v=0 em contornos essenciais) e integre em Ω.",
                                    "Aplique integração por partes para obter a forma fraca: ∫_Ω ∇v · k ∇T dΩ = ∫_Ω v f dΩ + termos de contorno naturais.",
                                    "Verifique consistência dimensional e propriedades de coercividade.",
                                    "Escreva explicitamente para o caso isotérmico k constante."
                                  ],
                                  "verification": "Escreva a forma variacional correta em um papel ou software simbólico como SymPy.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre formulação variacional",
                                    "Papel e caneta ou Mathematica/SymPy",
                                    "Livro de Elementos Finitos (ex: Zienkiewicz)"
                                  ],
                                  "tips": "Sempre inclua condições de contorno na forma fraca para evitar inconsistências.",
                                  "learningObjective": "Compreender a transição da forma forte para a fraca, base do método de Galerkin.",
                                  "commonMistakes": [
                                    "Esquecer integração por partes",
                                    "Não zerar v em contornos essenciais",
                                    "Ignorar termos de contorno naturais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar funções de interpolação como base e teste",
                                  "subSteps": [
                                    "Defina uma malha finita com nós e elementos (ex: lineares em 1D ou triangulares em 2D).",
                                    "Escolha funções de interpolação N_i: peça-wise polinomiais contínuos (ex: lineares N_i(x) = 1 em nó i, 0 nos outros).",
                                    "Defina funções teste v_i = N_i para o método de Galerkin (ortogonalidade Bubnov-Galerkin).",
                                    "Verifique propriedades: partição da unidade ∑ N_i = 1, suporte local aos elementos.",
                                    "Liste os graus de liberdade (DOFs) associados aos nós livres."
                                  ],
                                  "verification": "Desenhe a malha e plote/escreva explicitamente 2-3 funções N_i para um elemento simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software de plotagem como MATLAB ou Python (Matplotlib)",
                                    "Papel milimetrado",
                                    "Exemplos de malhas de livros texto"
                                  ],
                                  "tips": "Comece com malhas uniformes em 1D para simplicidade antes de generalizar.",
                                  "learningObjective": "Dominar a escolha de espaços de funções finitos compatíveis com a formulação variacional.",
                                  "commonMistakes": [
                                    "Funções descontínuas entre elementos",
                                    "Confundir funções base com teste em métodos não-Galerkin",
                                    "Sobrecarregar malha com nós desnecessários"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a aproximação da solução e substituir na forma variacional",
                                  "subSteps": [
                                    "Aproxime T^h(x) = ∑_{j=1}^N T_j N_j(x), onde T_j são coeficientes desconhecidos.",
                                    "Substitua T^h por T na forma fraca: ∫ ∇v · k ∇T^h dΩ = ∫ v f dΩ.",
                                    "Expanda ∇T^h = ∑ T_j ∇N_j.",
                                    "Mantenha v genérica por enquanto.",
                                    "Identifique os termos bilineares a(v, T^h) e lineares l(v)."
                                  ],
                                  "verification": "Escreva a expressão expandida T^h e ∇T^h para um elemento com 2 nós.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Caderno de exercícios",
                                    "Calculadora simbólica ou LaTeX para equações",
                                    "Exemplos resolvidos de 1D"
                                  ],
                                  "tips": "Use índices i,j para clareza: evite confusão entre somatórios.",
                                  "learningObjective": "Aplicar a discretização trial na equação variacional.",
                                  "commonMistakes": [
                                    "Erro no gradiente: ∇(∑ T_j N_j) ≠ ∑ T_j ∇N_j incorreto",
                                    "Esquecer somatório sobre todos DOFs",
                                    "Não distinguir trial vs test"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar princípio de Galerkin e montar a forma matricial",
                                  "subSteps": [
                                    "Projete a equação residual: para cada i, set v = N_i, obtendo a(v_i, T^h) = l(v_i).",
                                    "Forme o sistema: ∑_j [∫ ∇N_i · k ∇N_j dΩ] T_j = ∫ N_i f dΩ + contornos, ou K T = F.",
                                    "Compute elementos da matriz de rigidez K_ij por elemento e assemble globalmente.",
                                    "Incorpore condições essenciais impondo T_j fixos nos nós Dirichlet.",
                                    "Verifique simetria de K para k simétrico e problemas elípticos."
                                  ],
                                  "verification": "Monte K e F para uma malha de 2 elementos 1D e resolva manualmente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "MATLAB/Python com bibliotecas como FEniCS ou código próprio",
                                    "Planilha Excel para montagem manual",
                                    "Exercícios de livros como Hughes 'The Finite Element Method'"
                                  ],
                                  "tips": "Use gauss quadrature para integrais numéricas em elementos complexos.",
                                  "learningObjective": "Derivar o sistema linear matricial a partir da projeção Galerkin.",
                                  "commonMistakes": [
                                    "Assembly incorreto: duplicar elementos compartilhados",
                                    "Não tratar BCs essenciais corretamente",
                                    "Assumir k variável sem ajustar K_ij"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma barra 1D de L=1m, k=1 W/mK, f=0, T(0)=0°C, T(1)=100°C, divida em 2 elementos uniformes com funções lineares. As funções N1(x)=1-x/h, N2(x)=x/h em [0,h=0.5]. Forma variacional leva a K = [1/h  -1/h; -1/h 1/h] por elemento. Assembly global: K = (1/0.5)[2 -1; -1 1], F ajustado para BCs, solução T=[0,100] nos nós, perfil linear.",
                              "finalVerifications": [
                                "A matriz K é simétrica e positiva definida para problemas elípticos.",
                                "Solução reproduz condições de contorno essenciais exatamente.",
                                "Energia variacional é estacionária: δΠ(T^h)=0.",
                                "Convergência observada refinando malha (erro O(h^2) para lineares).",
                                "Verificação de massa: ∫ T^h dx próximo ao exato.",
                                "Teste de consistência: solução trivial para f=0 e BCs homogêneas."
                              ],
                              "assessmentCriteria": [
                                "Correção na derivação da forma fraca (sem erros de sinal ou integração).",
                                "Escolha adequada de funções teste iguais às base (Galerkin puro).",
                                "Montagem precisa da matriz K e vetor F com assembly correto.",
                                "Tratamento apropriado de condições de contorno.",
                                "Interpretação física da solução (ex: fluxo de calor contínuo).",
                                "Eficiência computacional demonstrada (escala com DOFs)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: resolução de sistemas K T = F via Gauss ou iterativos.",
                                "Física: Lei de Fourier para condução de calor e conservação de energia.",
                                "Programação Numérica: Implementação em Python/MATLAB para automação.",
                                "Cálculo Variacional: Princípio da energia mínima em problemas elípticos."
                              ],
                              "realWorldApplication": "Simulação de distribuição térmica em placas de circuito impresso (PCBs) para evitar superaquecimento, otimização de aletas em trocadores de calor automotivos, ou análise de isolamento térmico em estruturas aeroespaciais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.4.1.1.2"
                            ]
                          },
                          {
                            "id": "34.4.1.2.3",
                            "name": "Comparar com Rayleigh-Ritz",
                            "description": "Explicar a equivalência entre métodos de Galerkin e Rayleigh-Ritz para problemas simétricos auto-adjuntos como condução de calor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Formulação Variacional do Problema de Condução de Calor Estacionária",
                                  "subSteps": [
                                    "Derive a equação governante para condução de calor estacionária: -∇·(k∇T) = f em Ω, com condições de contorno.",
                                    "Formule o princípio variacional usando o funcional de energia total Π(T) = ∫Ω (1/2 k |∇T|^2 - f T) dΩ - termos de contorno.",
                                    "Verifique que o problema é simétrico auto-adjunto confirmando que o operador bilinear a(u,v) = ∫ k ∇u·∇v é simétrico e coercivo.",
                                    "Escreva a forma fraca: Encontre T em H^1(Ω) tal que a(T,v) = L(v) para todo v em H^1_0(Ω).",
                                    "Discuta por que simetria auto-adjunta permite formulações minimizadoras."
                                  ],
                                  "verification": "Escreva o funcional Π e a forma bilinear a(u,v); confirme simetria a(u,v)=a(v,u).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Elementos Finitos (ex: Zienkiewicz), papel e caneta, software simbólico como Mathematica ou SymPy.",
                                  "tips": "Comece com o caso 1D para simplicidade antes de generalizar para 2D/3D.",
                                  "learningObjective": "Compreender a base variacional que permite a equivalência entre métodos.",
                                  "commonMistakes": "Confundir condições de Dirichlet com Neumann ao formular L(v); ignorar simetria do operador."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o Método de Galerkin para Aproximação",
                                  "subSteps": [
                                    "Escolha funções base {φ_i} que satisfaçam condições essenciais de contorno.",
                                    "Aproxime T_h = ∑ u_j φ_j; teste com funções ψ_k = φ_k.",
                                    "Monte o sistema linear K u = F, onde K_ij = a(φ_j, φ_i), F_i = L(φ_i).",
                                    "Resolva o sistema e discuta propriedades: K é simétrica positiva definida devido à auto-adjunção.",
                                    "Implemente numericamente em 1D com 3 elementos para validar."
                                  ],
                                  "verification": "Gere a matriz K simétrica e resolva para um problema teste; verifique norma residual < 1e-6.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB/Python com NumPy/SciPy, código template para EF 1D.",
                                  "tips": "Use integração numérica Gauss para eficiência em elementos maiores.",
                                  "learningObjective": "Dominar a discritização Galerkin e suas propriedades matriciais.",
                                  "commonMistakes": "Usar funções teste diferentes das base sem necessidade; esquecer tratamento de contornos essenciais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular o Método de Rayleigh-Ritz e Derivar a Equivalência",
                                  "subSteps": [
                                    "Defina T_h = ∑ u_j φ_j no espaço de trial {φ_i} finito-dimensional.",
                                    "Minimize Π(T_h): ∂Π/∂u_i = 0 leva a K u = F com K_ij = ∂²Π/∂u_i∂u_j.",
                                    "Mostre que ∂²Π/∂u_i∂u_j = a(φ_j, φ_i), idêntico ao Galerkin.",
                                    "Prove teorema: Para problemas simétricos auto-adjuntos, stationary point de Π coincide com solução Galerkin.",
                                    "Compare taxas de convergência: Ambas O(h^{p+1}) para elementos polinomiais grau p."
                                  ],
                                  "verification": "Derive explicitamente K_ij de ambos métodos e confirme igualdade; resolva exemplo idêntico.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Papel e caneta para derivação, Jupyter notebook para verificação simbólica.",
                                  "tips": "Use variação de parâmetros para derivar ∂Π/∂u_i visualmente.",
                                  "learningObjective": "Estabelecer equivalência matemática rigorosa.",
                                  "commonMistakes": "Assumir equivalência sem simetria; confundir trial/test functions em Galerkin geral."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Comparar Numericamente em um Exemplo Prático",
                                  "subSteps": [
                                    "Configure problema 1D: d²T/dx² = -1, T(0)=0, T(1)=0; k=1.",
                                    "Use 2 elementos lineares; compute T_h via Galerkin e Ritz.",
                                    "Compare soluções exata T=x(1-x)/2, erro L2 e energia.",
                                    "Analise sensibilidade a malha e escolha de bases.",
                                    "Discuta extensões para problemas não-simétricos onde diferem."
                                  ],
                                  "verification": "Erros < 5% e matrizes K idênticas até precisão máquina.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Código Python/MATLAB pronto, plotador como Matplotlib.",
                                  "tips": "Plote soluções para visualização intuitiva da equivalência.",
                                  "learningObjective": "Validar teoricamente através de implementação prática.",
                                  "commonMistakes": "Erro de indexação em montagem de K; ignorar normalização de bases."
                                }
                              ],
                              "practicalExample": "Para condução de calor 1D em barra de comprimento 1 com fonte uniforme f=1, condições T(0)=T(1)=0: ambos métodos com 2 elementos lineares geram K = [[2, -1], [-1, 2]] e F=[1/6, 1/6], solução u=[1/12, 1/12], T_h(0.5)=1/8 vs exata 1/8.",
                              "finalVerifications": [
                                "Derivação correta do funcional Π e forma bilinear simétrica.",
                                "Matrizes K e vetores F idênticos entre Galerkin e Ritz.",
                                "Solução numérica converge monotonicamente para exata.",
                                "Explicação verbal clara da equivalência via stationary de Π.",
                                "Identificação correta de condições para não-equivalência (não-simétricos)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação da equivalência (90%+ correto).",
                                "Clareza na explicação de propriedades simétricas auto-adjuntas.",
                                "Implementação numérica sem erros e com validação.",
                                "Análise de erros e convergência adequada.",
                                "Uso correto de terminologia (trial/test functions, coercividade)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Funcional e Álgebra Linear (espaços de Sobolev, autovalores).",
                                "Física: Transferência de Termo e Equações Diferenciais Parciais.",
                                "Computação: Programação Numérica e Solução de Sistemas Lineares.",
                                "Engenharia: Simulação de Processos Térmicos em Materiais."
                              ],
                              "realWorldApplication": "Em análise térmica de componentes aeroespaciais (ex: painéis de turbina), usa-se EF para prever distribuições de temperatura; equivalência permite escolher Ritz para otimização variacional eficiente em software como ANSYS."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "34.4.1.3",
                        "name": "Montagem e Solução no Método dos Elementos Finitos",
                        "description": "Detalha a discretização do domínio, montagem das matrizes de condutância e capacidade, vetor de carga e resolução do sistema para problemas de calor.",
                        "specificSkills": [
                          {
                            "id": "34.4.1.3.1",
                            "name": "Montar matriz de elemento para condução",
                            "description": "Calcular a matriz de condutância [k^e] = ∫ [B]^T k [B] dV para elementos 1D e 2D lineares, usando funções de forma e derivadas [B].",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar funções de forma e derivadas para elementos lineares 1D e 2D",
                                  "subSteps": [
                                    "Estude as funções de forma lineares para elemento 1D de dois nós: N1 = (1 - ξ)/2, N2 = (1 + ξ)/2, onde ξ varia de -1 a 1.",
                                    "Calcule as derivadas das funções de forma em relação à coordenada natural ξ: dN1/dξ = -1/2, dN2/dξ = 1/2.",
                                    "Para 2D triangular linear, defina funções de forma: N1 = 1 - ξ - η, N2 = ξ, N3 = η, em coordenadas área.",
                                    "Derive as derivadas parciais: ∂N1/∂ξ = -1, ∂N1/∂η = -1; ∂N2/∂ξ = 1, ∂N2/∂η = 0; etc.",
                                    "Transforme derivadas para coordenadas globais usando matriz Jacobiana J."
                                  ],
                                  "verification": "Liste corretamente todas as funções de forma e suas derivadas para 1D e 2D em um papel ou software.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Elementos Finitos (ex: Logan ou Zienkiewicz)",
                                    "Papel e calculadora",
                                    "Software como MATLAB ou Python (SymPy para simbólico)"
                                  ],
                                  "tips": "Use coordenadas naturais para simplificar; memorize padrões para lineares.",
                                  "learningObjective": "Dominar funções de forma e matriz de derivadas [B] como base para a matriz de condutância.",
                                  "commonMistakes": [
                                    "Confundir derivadas em ξ vs. x global",
                                    "Esquecer transformação Jacobiana em 2D",
                                    "Usar funções quadráticas por engano"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir matriz de derivadas [B] para elemento 1D linear",
                                  "subSteps": [
                                    "Defina a gradiente de temperatura aproximada: ∇T = [B] {T^e}, onde [B] contém derivadas das funções de forma.",
                                    "Para 1D: [B] = (1/|J|) * [-1/2, 1/2]^T, com J = dx/dξ = L/2 para comprimento L.",
                                    "Escreva [B] explicitamente: B = [-1/L, 1/L]^T para barra de comprimento L.",
                                    "Verifique que [B] tem dimensão 1x2 para 1D (uma derivada espacial).",
                                    "Teste com valores numéricos: L=2, ξ=0, confirme B = [-0.5, 0.5]."
                                  ],
                                  "verification": "Compute [B] para um elemento 1D de L=1 e confirme simetria e normalização.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha Excel ou Jupyter Notebook",
                                    "Papel quadriculado"
                                  ],
                                  "tips": "Sempre divida pelo Jacobiano para derivadas globais; visualize geometricamente.",
                                  "learningObjective": "Construir corretamente a matriz [B] que relaciona gradientes às temperaturas nodais.",
                                  "commonMistakes": [
                                    "Não inverter Jacobiano corretamente",
                                    "Confundir ordem das colunas em [B]",
                                    "Ignorar sinal das derivadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Montar e integrar matriz de condutância [k^e] para 1D",
                                  "subSteps": [
                                    "Escreva a fórmula: [k^e] = ∫ [B]^T k [B] dV, onde k é condutividade, dV = A dx para seção A.",
                                    "Para 1D linear uniforme: [k^e] = (k A / L) * [1, -1; -1, 1].",
                                    "Integre analiticamente: como [B] constante, ∫ dV = A L.",
                                    "Implemente numericamente com Gauss-Legendre (2 pontos para linear).",
                                    "Calcule para exemplo: k=10, A=1, L=1, obtenha [k^e] = 10*[1,-1;-1,1]."
                                  ],
                                  "verification": "A matriz resultante deve ser simétrica positiva definida com zeros na diagonal off se k=0.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB/Python script para integração",
                                    "Tabela de pesos Gauss"
                                  ],
                                  "tips": "Para exatos lineares, integração analítica basta; use simbólico para validar.",
                                  "learningObjective": "Calcular [k^e] completa para elemento 1D via integração.",
                                  "commonMistakes": [
                                    "Esquecer área A em dV",
                                    "Erro de sinal em [B]^T [B]",
                                    "Integração numérica com poucos pontos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estender para elementos 2D lineares e calcular [k^e]",
                                  "subSteps": [
                                    "Para triângulo linear: [B] 2x3 com ∂N/∂x e ∂N/∂y usando J^{-T}.",
                                    "Compute [B]^T k [B], assuma k isotrópico/escalar primeiro: k I.",
                                    "dV = t det(J) dξ dη, t=espessura; integre sobre ξ,η [-1,1] ou área.",
                                    "Fórmula explícita: [k^e]_{ij} = k t / (4 Area) * ∫ (∇Ni · ∇Nj) dA.",
                                    "Exemplo numérico: triângulo equilátero lado=1, k=1, compute todos 6 termos."
                                  ],
                                  "verification": "Confirme simetria [k^e] = [k^e]^T e trace positivo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software FEA simbólico (ex: FEniCS trial)",
                                    "Papel para esboço geométrico"
                                  ],
                                  "tips": "Use isoparamétrico para precisão; valide com fórmula fechada conhecida.",
                                  "learningObjective": "Generalizar montagem de [k^e] para 2D lineares.",
                                  "commonMistakes": [
                                    "Erro na inversa Jacobiana",
                                    "Confundir ∇ em local vs global",
                                    "Fator espessura esquecido"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e implementar código para automação",
                                  "subSteps": [
                                    "Escreva função Python/MATLAB: input(nós, k, geom) -> [k^e].",
                                    "Teste com malha simples 1D e 2D conhecida.",
                                    "Compare analítico vs numérico (erro <1e-6).",
                                    "Analise propriedades: simetria, diagonally dominante.",
                                    "Documente código com comentários nas fórmulas."
                                  ],
                                  "verification": "Código roda sem erros e reproduz exemplo 1D/2D exatos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Exemplos de código FEA online"
                                  ],
                                  "tips": "Vetorize operações para eficiência; use classes para elementos.",
                                  "learningObjective": "Automatizar montagem para uso em solvers FEA.",
                                  "commonMistakes": [
                                    "Índices nodais errados",
                                    "Unidades inconsistentes",
                                    "Não checar det(J)>0"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma barra 1D de comprimento L=0.1m, seção A=0.01m², k=50 W/mK: [k^e] = (50*0.01/0.1) * [[1,-1],[-1,1]] = 5 * [[1,-1],[-1,1]]. Para triângulo 2D equilátero lado a=0.1m, Area≈0.00433m², t=0.01m, k=50: cada diagonal [k^e]_{ii} ≈ 50*0.01*(cot(60°)/ (4*0.00433)) ≈ 1.44, off-diag -0.72.",
                              "finalVerifications": [
                                "Matriz [k^e] é simétrica: k_ij = k_ji.",
                                "Elementos diagonais positivos, soma linha ≈0 para Neumann homogêneo.",
                                "Para k uniforme, trace([k^e]) = k ∫ |∇N|^2 dV correto.",
                                "Implementação numérica converge para analítica com refinamento Gauss.",
                                "Propriedade de partição: soma [k^e] sobre elementos dá contribuições nodais consistentes.",
                                "Verificação energética: q = {T}^T [k^e] {T} >0 para {T}≠0."
                              ],
                              "assessmentCriteria": [
                                "Precisão da matriz [B]: erro <1% em derivadas.",
                                "Correção da integração: coincide com fórmula fechada.",
                                "Simetria e positividade semi-definida de [k^e].",
                                "Generalização correta de 1D para 2D.",
                                "Código funcional e eficiente para malha teste.",
                                "Explicação clara de cada passo em relatório."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo integral numérico (Gauss-quadratura), álgebra linear (matrizes).",
                                "Física: Lei de Fourier para condução de calor, gradientes vetoriais.",
                                "Programação: Implementação numérica em Python/MATLAB, vetores e funções.",
                                "Engenharia de Materiais: Propriedades térmicas k variando por material."
                              ],
                              "realWorldApplication": "Em simulações FEA de transferência de calor em estruturas mecânicas, como dissipadores de calor em eletrônicos, isolamento térmico de tubulações industriais ou análise de tensões térmicas em motores, onde [k^e] é montado para resolver ∇·(k ∇T)=0 numericamente."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.4.1.2.1"
                            ]
                          },
                          {
                            "id": "34.4.1.3.2",
                            "name": "Construir vetor de carga e condições de contorno",
                            "description": "Assemblar {f^e} = ∫ N^T Q dV + ∫ N^T h T∞ dS e impor condições essenciais via penalidade ou eliminação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o vetor de carga elementar e identificar contribuições",
                                  "subSteps": [
                                    "Revise a equação do vetor de carga: {f^e} = ∫_V N^T Q dV + ∫_S N^T h T∞ dS.",
                                    "Identifique Q como taxa de geração de calor volumétrica (W/m³).",
                                    "Identifique h como coeficiente de convecção (W/m²K) e T∞ como temperatura ambiente.",
                                    "Liste as funções de forma N para o elemento (ex: linear para 1D, bilinear para 2D).",
                                    "Defina os domínios de integração: volume V do elemento e superfície S exposta."
                                  ],
                                  "verification": "Escreva a equação anotada com símbolos definidos e domínios corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de MEF (ex: Zienkiewicz), caderno, malha elementar simples.",
                                  "tips": "Comece com elementos 1D para simplicidade antes de 2D/3D.",
                                  "learningObjective": "Compreender os componentes físicos e matemáticos do vetor de carga.",
                                  "commonMistakes": "Confundir Q com fonte de calor superficial ou ignorar unidades inconsistentes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a contribuição volumétrica ∫_V N^T Q dV",
                                  "subSteps": [
                                    "Assuma Q constante ou defina sua variação (ex: Q(x) = Q0 sin(πx/L)).",
                                    "Expresse N^T como vetor de funções de forma transpostas.",
                                    "Use integração exata ou gaussiana numérica para computar a integral.",
                                    "Multiplique pelo Jacobiano |J| se em coordenadas isoparamétricas.",
                                    "Calcule para cada grau de liberdade (nós) do elemento."
                                  ],
                                  "verification": "Compare resultado com fórmula analítica para elemento linear 1D.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software MATLAB/Python com funções de integração, exemplo de malha.",
                                  "tips": "Use pontos de Gauss para precisão; teste com Q=constante primeiro.",
                                  "learningObjective": "Dominar integração volumétrica no espaço elementar.",
                                  "commonMistakes": "Esquecer o Jacobiano em elementos curvos ou normalizar incorretamente N."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a contribuição superficial ∫_S N^T h T∞ dS",
                                  "subSteps": [
                                    "Identifique faces do elemento expostas à convecção.",
                                    "Defina h e T∞ constantes ou variáveis na superfície.",
                                    "Integre N^T sobre a superfície S, usando comprimento/areia ds.",
                                    "Aplique mapeamento isoparamétrico para superfícies curvas.",
                                    "Some à contribuição volumétrica para obter {f^e} completo."
                                  ],
                                  "verification": "Verifique simetria e soma total igual a carga física esperada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código FEniCS ou código customizado, diagrama da malha.",
                                  "tips": "Visualize a superfície com ferramentas como Paraview para confirmação.",
                                  "learningObjective": "Aplicar integração superficial em condições de contorno de convecção.",
                                  "commonMistakes": "Integrar sobre todo o volume em vez de superfície ou inverter h e T∞."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Assemblar vetor global e impor condições de contorno essenciais",
                                  "subSteps": [
                                    "Assemble {f^e} em {f} global usando conectividade nodal.",
                                    "Identifique nós com BCs essenciais (ex: T = T_dirichlet).",
                                    "Aplique método de eliminação: modifique linhas/colunas da matriz rígida.",
                                    "Ou use penalidade: adicione α ∫ N^T N dV à [K] e α T_dir à {f}.",
                                    "Verifique equilíbrio: some cargas e compare com balanço energético."
                                  ],
                                  "verification": "Execute solver e cheque resíduos de equilíbrio < 1e-6.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Solver MEF completo (ex: código Python com NumPy/SciPy).",
                                  "tips": "Prefira eliminação para precisão; penalidade requer tuning de α grande.",
                                  "learningObjective": "Implementar montagem global e tratamento de BCs Dirichlet.",
                                  "commonMistakes": "Duplicar cargas em nós compartilhados ou aplicar penalidade muito baixa."
                                }
                              ],
                              "practicalExample": "Para uma barra 1D de comprimento L=1m, k=1 W/mK, h=10 W/m²K, T∞=0°C, Q=100 W/m³, malha com 2 elementos lineares. Calcule {f^e} para elemento 1: contribuição vol = [50, 50]^T, superf = [5, 5]^T (aprox), imponha T(0)=100°C via eliminação.",
                              "finalVerifications": [
                                "Vetor {f} assemblado tem dimensões corretas (n_dof x 1).",
                                "Soma de cargas volumétricas igual a ∫_Ω Q dV total.",
                                "BCs essenciais modificam corretamente {f} e [K].",
                                "Solução T satisfaz BCs Dirichlet com erro <1e-10.",
                                "Perfil de temperatura físico (decrescente de T_dir a convecção).",
                                "Balanço energético: entrada Q + convecção = condução."
                              ],
                              "assessmentCriteria": [
                                "Correção das integrais volumétrica e superficial (erro <5%).",
                                "Assemblagem global sem sobreposição de cargas nodais.",
                                "Implementação precisa de BCs (eliminação ou penalidade funcional).",
                                "Código reproduzível e comentado.",
                                "Validação com solução analítica para caso 1D.",
                                "Eficiência computacional (tempo <1s para 100 elementos)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Integração numérica (Gauss-Legendre), álgebra linear (montagem de vetores).",
                                "Física: Leis de Fourier e Newton para transferência de calor.",
                                "Programação: Implementação numérica em Python/MATLAB com vetores/matrices.",
                                "Engenharia: Validação com simulações CFD/CAE industriais."
                              ],
                              "realWorldApplication": "Simulação de dissipação térmica em chips eletrônicos (ex: prever hotspots em CPUs via ANSYS, evitando falhas por superaquecimento) ou análise de trocadores de calor em indústrias automotivas/aeroespaciais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.4.1.1.2"
                            ]
                          },
                          {
                            "id": "34.4.1.3.3",
                            "name": "Resolver sistema para caso estacionário e transitório",
                            "description": "Resolver [K]{T} = {F} via decomposição LU ou iterativos, e para transitório usar [C]{dT/dt} + [K]{T} = {F} com método θ ou implícito.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e resolver sistema estacionário com decomposição LU",
                                  "subSteps": [
                                    "Revise a montagem de [K]{T} = {F} a partir das matrizes de elemento para transferência de calor.",
                                    "Aplique condições de contorno essenciais, modificando [K] e {F}.",
                                    "Realize decomposição LU: fatorize [K] = [L][U].",
                                    "Resolva [L]{y} = {F} por substituição frontal.",
                                    "Resolva [U]{T} = {y} por substituição reversa."
                                  ],
                                  "verification": "Verifique se [K][T] ≈ {F} com norma residual < 1e-6.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": "Software MATLAB/Python (NumPy/SciPy), malha de exemplo 1D/2D, calculadora.",
                                  "tips": "Use pivotamento parcial para estabilidade numérica em [K] mal-condicionada.",
                                  "learningObjective": "Dominar decomposição LU para sistemas lineares simétricos positivos definidos.",
                                  "commonMistakes": "Esquecer de aplicar condições de contorno Dirichlet; ignorar simetria de [K]."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Resolver sistema estacionário com métodos iterativos",
                                  "subSteps": [
                                    "Escolha método iterativo (ex: Gauss-Seidel ou Conjugado Gradiente) baseado em propriedades de [K].",
                                    "Inicialize vetor {T}^{(0)} (ex: zeros ou chute físico).",
                                    "Itere até convergência: atualize {T}^{(k+1)} e compute residual.",
                                    "Monitore norma do residual ||[K]{T} - {F}|| / ||{F}|| < tol.",
                                    "Compare solução com LU para validar."
                                  ],
                                  "verification": "Número de iterações < 100 e residual < 1e-8.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": "Código Python customizado ou SciPy solvers (cg, gs), malha de teste.",
                                  "tips": "Pré-condicione [K] com diagonal para aceleração em malhas grandes.",
                                  "learningObjective": "Aplicar iterativos eficientes para matrizes esparsas grandes.",
                                  "commonMistakes": "Inicialização ruim levando a divergência; tolerância muito frouxa."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular e discretizar sistema transitório com método θ",
                                  "subSteps": [
                                    "Escreva equação [C]{dT/dt} + [K]{T} = {F}(t).",
                                    "Discretize tempo: Δt fixo, θ entre 0 (explícito) e 1 (implícito).",
                                    "Aplique scheme θ: [[C]/Δt + θ[K]] {T}^{n+1} = {F}^{n+1} - [[C]/Δt - (1-θ)[K]] {T}^n.",
                                    "Monte matriz efetiva [K_θ] e vetor {F_θ} para cada passo de tempo.",
                                    "Defina passos totais N_t e condições iniciais {T}^0."
                                  ],
                                  "verification": "Estabilidade para θ ≥ 0.5; energia térmica conservada aproximadamente.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": "Script Python para loop temporal, dados de {F}(t) transitórios.",
                                  "tips": "Use θ=0.5 (Crank-Nicolson) para precisão e estabilidade.",
                                  "learningObjective": "Entender discretização temporal implícita/explícita.",
                                  "commonMistakes": "Δt muito grande causando oscilações; erro em montagem de [K_θ]."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver sistema transitório e validar soluções",
                                  "subSteps": [
                                    "Para cada n=1 a N_t, resolva [K_θ]{T}^{n+1} = {F_θ} com LU ou iterativo.",
                                    "Armazene histórico {T}(t) e plote evolução temporal/espacial.",
                                    "Compare com solução estacionária no limite t→∞.",
                                    "Analise sensibilidade a Δt e θ.",
                                    "Valide com balanço energético global."
                                  ],
                                  "verification": "Solução converge para estacionária; máximo |dT/dt| → 0.",
                                  "estimatedTime": "60-90 minutos",
                                  "materials": "Matplotlib para plots, malha com fonte transitória.",
                                  "tips": "Reaproveite fatorização LU de [K_θ] se constante.",
                                  "learningObjective": "Integrar solvers lineares em simulações dinâmicas.",
                                  "commonMistakes": "Acúmulo de erros numéricos em loops longos; plot sem normalização."
                                }
                              ],
                              "practicalExample": "Simule transferência de calor em uma barra 1D de 1m, k=1 W/mK, ρc=1 J/m³K, T(0)=100°C, T(1)=0°C, pulso de calor {F}(t)=sin(πt) nos primeiros 10s. Resolva estacionário com LU (T máx ~50°C), então transitório com θ=0.5, Δt=0.1s, observe resfriamento.",
                              "finalVerifications": [
                                "Residual do sistema estacionário < 1e-10.",
                                "Convergência iterativa em <50 iterações.",
                                "Solução transitória estável sem oscilações (θ≥0.5).",
                                "Limite t→∞ matches estacionária.",
                                "Balanço de energia: ∫{F} dt ≈ variação em ∫ρc T dV.",
                                "Plots mostram gradiente físico (quente-frio)."
                              ],
                              "assessmentCriteria": [
                                "Correta fatorização LU com pivotamento.",
                                "Eficiência iterativa vs direto (tempo CPU).",
                                "Precisão temporal: erro <1% vs solução analítica 1D.",
                                "Implementação escalável para malhas >100 nós.",
                                "Validação cruzada estacionário-transitório.",
                                "Código limpo com comentários e testes."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposições e iterativos para SPD.",
                                "Cálculo Numérico: Esquemas de diferenças finitas no tempo.",
                                "Programação: Otimização de loops e solvers esparsos (SciPy sparse).",
                                "Física: Conservação de energia em equações diferenciais parabólicas."
                              ],
                              "realWorldApplication": "Simulação de resfriamento transitório em blocos de motor automotivo, prevendo hotspots para design de sistemas de refrigeração e evitando falhas térmicas em veículos elétricos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.4.1.3.1"
                            ]
                          },
                          {
                            "id": "34.4.1.3.4",
                            "name": "Implementar em malha simples 1D/2D",
                            "description": "Montar manualmente o sistema global para uma barra ou placa discretizada, verificando equilíbrio energético.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a geometria, malha e propriedades do problema",
                                  "subSteps": [
                                    "Escolha o domínio: barra 1D (comprimento L) ou placa 2D (largura x altura).",
                                    "Discretize em elementos finitos simples: 2-4 elementos lineares para 1D ou triangulares para 2D.",
                                    "Defina nós e conectividade: liste coordenadas dos nós e quais nós pertencem a cada elemento.",
                                    "Especifique propriedades: condutividade térmica k, capacidade térmica ρc, espessura (para 2D), condições iniciais.",
                                    "Identifique condições de contorno: temperaturas fixas, fluxos de calor."
                                  ],
                                  "verification": "Verifique se a malha cobre o domínio sem sobreposições e todos os nós estão numerados corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel milimetrado ou software de desenho simples (ex: GeoGebra), calculadora"
                                  ],
                                  "tips": "Comece com malha uniforme para simplicidade; desenhe à mão para visualização.",
                                  "learningObjective": "Compreender a discretização do domínio contínuo em elementos finitos.",
                                  "commonMistakes": "Esquecer nós compartilhados entre elementos ou malha irregular sem justificativa."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular matrizes e vetores elementares locais",
                                  "subSteps": [
                                    "Para cada elemento, derive a função de interpolação (linear para 1D/2D simples).",
                                    "Calcule a matriz de rigidez local [k^e] = ∫ [B]^T k [B] dV (analiticamente para elementos simples).",
                                    "Compute o vetor de carga local {f^e} devido a fontes internas ou convecção.",
                                    "Para 1D: [k^e] = (k A / le) * [1 -1; -1 1], onde le é comprimento do elemento.",
                                    "Para 2D: use fórmulas para triângulos lineares, integrando sobre área."
                                  ],
                                  "verification": "Confirme que as matrizes são simétricas e positivas definidas; some linhas para checar soma zero em ausência de fontes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Fórmulas de MEF anotadas, planilha Excel ou papel para cálculos matriciais"
                                  ],
                                  "tips": "Use comprimentos/áreas exatos; memorize fórmulas padrão para elementos lineares.",
                                  "learningObjective": "Dominar o cálculo local das contribuições elementares no MEF para transferência de calor.",
                                  "commonMistakes": "Erro no sinal das off-diagonais ou esquecer fator de espessura em 2D."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Montar o sistema global por assemblagem",
                                  "subSteps": [
                                    "Inicialize matriz global [K] e vetor {F} com zeros (tamanho n_nós x n_nós).",
                                    "Para cada elemento, some [k^e] nas posições dos graus de liberdade globais correspondentes.",
                                    "Some {f^e} no vetor global {F} nos nós apropriados.",
                                    "Verifique conectividade: cada entrada global deve acumular contribuições de elementos adjacentes.",
                                    "Escreva o sistema [K]{T} = {F} explicitamente para malha pequena."
                                  ],
                                  "verification": "Cheque se linhas de nós internos somam aproximadamente zero (equilíbrio local sem fontes).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Matriz em branco (tabela), lápis e borracha"
                                  ],
                                  "tips": "Use convenção de numeração de nós da esquerda para direita; rotule graus de liberdade claramente.",
                                  "learningObjective": "Aprender o processo de assemblagem que garante conservatividade no MEF.",
                                  "commonMistakes": "Assemblar em posições erradas de nós ou duplicar contribuições."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar condições de contorno e resolver o sistema",
                                  "subSteps": [
                                    "Modifique [K] e {F} para temperaturas Dirichlet: remova linhas/colunas e ajuste {F}.",
                                    "Inclua fluxos de Neumann em {F} nos nós de contorno.",
                                    "Resolva [K_red]{T_red} = {F_red} por eliminação gaussiana ou inversa manual.",
                                    "Preencha temperaturas fixas nos graus de liberdade conhecidos.",
                                    "Calcule fluxos nos elementos para verificação."
                                  ],
                                  "verification": "Confirme que temperaturas nos nós de Dirichlet são exatas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora matricial ou software como MATLAB/Octave para sistemas pequenos"
                                  ],
                                  "tips": "Para sistemas 3x3 ou menores, resolva à mão; pratique penalização para Dirichlet.",
                                  "learningObjective": "Aplicar corretamente condições de contorno no MEF estacionário.",
                                  "commonMistakes": "Esquecer de modificar ambas [K] e {F} ou inverter método de imposição."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar equilíbrio energético global",
                                  "subSteps": [
                                    "Calcule calor armazenado: ∫ ρc T dV ≈ soma elementar.",
                                    "Fluxo de entrada: soma de fluxos de contorno e fontes.",
                                    "Fluxo condutivo entre elementos: verifique soma zero em nós internos.",
                                    "Cheque balanço: entrada = saída + armazenado (para estacionário, armazenado=0).",
                                    "Compare com solução analítica exata se disponível."
                                  ],
                                  "verification": "Erro de equilíbrio < 1% do fluxo total.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Resultados do passo anterior, fórmula de solução analítica"
                                  ],
                                  "tips": "Use precisão de 4 casas decimais; plote temperaturas para inspeção visual.",
                                  "learningObjective": "Validar a solução MEF pela conservação de energia.",
                                  "commonMistakes": "Ignorar fluxos em contornos ou erros de arredondamento em somas."
                                }
                              ],
                              "practicalExample": "Para uma barra 1D de L=1m, k=10 W/mK, dividida em 2 elementos de 0.5m, T(0)=0°C, fluxo q(1m)=100 W/m²: calcule [K] = [[20, -10, 0], [-10, 20, -10], [0, -10, 10]], {F}=[0,0,50], resolva T=[0, 50, 100]°C, verifique balanço q_entrada=100W/m² = fluxo condutivo total.",
                              "finalVerifications": [
                                "Matriz global simétrica e soma de linhas zero em nós sem fontes.",
                                "Solução satisfaz condições de contorno exatamente.",
                                "Balanço energético: erro <0.1%.",
                                "Temperaturas contínuas e monotonicamente crescentes (para aquecimento).",
                                "Comparação com solução analítica: T(x)= (q/k)x para 1D.",
                                "Fluxos elementares conservam energia localmente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na discretização e conectividade (sem erros topológicos).",
                                "Correção nas matrizes locais (fórmulas exatas).",
                                "Assemblagem sem sobreposições/duplicações.",
                                "Imposição correta de contornos e resolução numérica precisa.",
                                "Verificação energética completa e quantitativa.",
                                "Documentação clara com todos os passos explicitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (montagem e resolução de sistemas).",
                                "Física: Leis de Fourier e conservação de energia em transferência de calor.",
                                "Programação: Implementação numérica de loops de assemblagem em Python/MATLAB.",
                                "Engenharia de Materiais: Propriedades térmicas dependentes do material."
                              ],
                              "realWorldApplication": "Simulação manual inicial para design de isolantes térmicos em tubulações industriais ou perfis de temperatura em placas de dissipadores de calor em eletrônicos, validando antes de códigos computacionais como ANSYS."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.4.1.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.2",
                    "name": "Torção",
                    "description": "Formulação de elementos finitos para análise de torção em prismas e barras usando função de Prandtl como campo escalar.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.2.1",
                        "name": "Função de Prandtl para Torção",
                        "description": "Introdução à função de Prandtl como variável escalar que representa o potencial de tensões de cisalhamento em seções transversais de prismas e barras sob torção pura, permitindo a formulação do problema como um campo escalar harmônico.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.1.1",
                            "name": "Derivar relações entre função de Prandtl e tensões de cisalhamento",
                            "description": "Explicar e derivar matematicamente as expressões τ_xz = ∂φ/∂y e τ_yz = -∂φ/∂x, onde φ é a função de Prandtl, e demonstrar como elas satisfazem o equilíbrio em torção para seções prismáticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos de torção em seções prismáticas",
                                  "subSteps": [
                                    "Estude as equações de equilíbrio estático para torção: ∂τ_xz/∂z + ∂τ_xz/∂x + ∂τ_xz/∂y = 0 e ∂τ_yz/∂z + ∂τ_yz/∂x + ∂τ_yz/∂y = 0, assumindo independência em z.",
                                    "Lembre-se das hipóteses de Saint-Venant: seção transversal rígida, deformação plana, tensões normais desprezíveis.",
                                    "Identifique que para torção pura, τ_xz e τ_yz são as únicas tensões relevantes na seção transversal.",
                                    "Anote as condições de contorno: tensões tangenciais zero na superfície livre.",
                                    "Discuta o momento torçor Mx = ∫(x τ_yz - y τ_xz) dA."
                                  ],
                                  "verification": "Resuma as equações de equilíbrio em um papel e verifique se elas se reduzem a ∂τ_xz/∂x + ∂τ_xz/∂y = 0 e ∂τ_yz/∂x + ∂τ_yz/∂y = 0 para torção.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Resistência dos Materiais (Timoshenko), caderno, calculadora.",
                                  "tips": "Desenhe diagramas da seção transversal para visualizar as tensões.",
                                  "learningObjective": "Compreender as equações de equilíbrio que a função de Prandtl deve satisfazer.",
                                  "commonMistakes": "Esquecer que as derivadas em z são zero; confundir τ_xz com τ_zx."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a função de Prandtl φ",
                                  "subSteps": [
                                    "Defina φ como função de fluxo de tensão (Prandtl stress function) tal que τ_xz = ∂φ/∂y e τ_yz = -∂φ/∂x.",
                                    "Explique que essa escolha garante automaticamente a compatibilidade das tensões.",
                                    "Discuta as propriedades: φ constante na contorno (geralmente zero), ∇²φ = -2Gθ dentro da seção, onde G é módulo de cisalhamento e θ taxa de torção.",
                                    "Verifique dimensionalmente: φ tem unidades de tensão vezes comprimento ao quadrado.",
                                    "Derive brevemente o momento torçor em termos de φ: Mx = 2 ∫φ dA."
                                  ],
                                  "verification": "Escreva as definições de τ_xz e τ_yz em termos de φ e confirme que curl(τ) = 0 é satisfeito.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notas de aula sobre torção, software de desenho vetorial para diagramas.",
                                  "tips": "Use analogia com função de fluxo em fluidos incompressíveis para intuitar.",
                                  "learningObjective": "Entender o papel da função φ em simplificar as equações de equilíbrio.",
                                  "commonMistakes": "Confundir o sinal em τ_yz = -∂φ/∂x; ignorar a equação de Poisson para φ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar matematicamente as relações τ_xz = ∂φ/∂y e τ_yz = -∂φ/∂x",
                                  "subSteps": [
                                    "Comece com as equações de equilíbrio: ∂τ_xz/∂x + ∂τ_xz/∂y = 0 e ∂τ_yz/∂x + ∂τ_yz/∂y = 0.",
                                    "Integre a primeira equação: τ_xz = f(y), mas generalize para τ_xz = ∂φ/∂y assumindo φ(x,y).",
                                    "Para a segunda: τ_yz = -∂φ/∂x para consistência.",
                                    "Verifique: ∂/∂x (∂φ/∂y) + ∂/∂y (∂φ/∂y) = ∂²φ/∂x∂y + ∂²φ/∂y², mas corrija para equilíbrio misto.",
                                    "Mostre que ∂τ_xz/∂x + ∂τ_yz/∂y = ∂²φ/∂x∂y - ∂²φ/∂x∂y = 0, satisfazendo automaticamente."
                                  ],
                                  "verification": "Derive as expressões em papel e substitua nas equações de equilíbrio para provar zero.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel quadriculado, lápis, livro de Elasticidade (Sokolnikoff).",
                                  "tips": "Use notação de cálculo vetorial: τ = ∇ × (φ k), onde k é unitário em z.",
                                  "learningObjective": "Derivar rigorosamente as relações e provar satisfação do equilíbrio.",
                                  "commonMistakes": "Erro no sinal da derivada de τ_yz; falhar em verificar ambas as equações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar satisfação do equilíbrio e aplicações",
                                  "subSteps": [
                                    "Substitua as expressões na integral do momento torçor e simplifique.",
                                    "Discuta condições de contorno: φ=0 na borda para τ tangencial zero.",
                                    "Resolva numericamente para seção circular: φ = (Gθ/2)(R² - x² - y²).",
                                    "Compare tensões derivadas com soluções conhecidas.",
                                    "Explore limitações: válido apenas para seções prismáticas sem furos."
                                  ],
                                  "verification": "Calcule τ para um ponto em seção retangular e verifique equilíbrio numericamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB ou Python para plotar φ e tensões, exemplos resolvidos.",
                                  "tips": "Implemente em código para visualizar linhas de φ constantes.",
                                  "learningObjective": "Aplicar as derivações e validar com exemplos.",
                                  "commonMistakes": "Ignorar a equação de governância ∇²φ = -2Gθ; confundir com função de Airy."
                                }
                              ],
                              "practicalExample": "Para uma seção transversal retangular de 2a x 2b, assuma φ aproximado por série de Fourier. Derive τ_xz = ∂φ/∂y em x=0, y=b/2 e verifique que ∂τ_xz/∂x + ∂τ_yz/∂y = 0 numericamente, calculando o momento torçor e comparando com fórmula exata.",
                              "finalVerifications": [
                                "Deriva corretamente τ_xz = ∂φ/∂y e τ_yz = -∂φ/∂x a partir do equilíbrio.",
                                "Prova que as expressões satisfazem ∂τ_xz/∂x + ∂τ_yz/∂y = 0.",
                                "Calcula o momento torçor Mx = 2 ∫φ dA corretamente.",
                                "Aplica condições de contorno φ=0 na borda.",
                                "Identifica a equação de Poisson ∇²φ = -2Gθ.",
                                "Valida com exemplo simples como seção circular."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação das relações (peso 30%).",
                                "Correta demonstração de satisfação das equações de equilíbrio (25%).",
                                "Clareza na explicação de propriedades de φ e condições de contorno (20%).",
                                "Uso correto de notação e unidades (10%).",
                                "Aplicação em exemplo prático com cálculos numéricos (10%).",
                                "Identificação de limitações e erros comuns (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo vetorial e equações diferenciais de Poisson.",
                                "Física: Mecânica dos sólidos e analogia com fluxo incompressível.",
                                "Engenharia Civil: Análise de torção em vigas e pilares.",
                                "Computação: Métodos numéricos (elementos finitos) para resolver ∇²φ=const."
                              ],
                              "realWorldApplication": "No projeto de eixos de transmissão em turbinas eólicas ou automóveis, onde derivar tensões de cisalhamento via função de Prandtl permite otimizar seções transversais irregulares para maximizar rigidez torcional minimizando peso, evitando falhas por cisalhamento excessivo em componentes aeronáuticos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.2",
                            "name": "Calcular momento torçor e rigidez torcional",
                            "description": "Calcular o momento de torção T = 2 ∫φ dA e a constante de torção J efetiva a partir da função de Prandtl, aplicando em seções simples como circular e retangular.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos da função de Prandtl para torção",
                                  "subSteps": [
                                    "Estude a equação de Prandtl para o potencial de torção φ em seções transversais.",
                                    "Identifique as condições de contorno: φ=0 nas bordas livres.",
                                    "Revise soluções analíticas para seções circulares (φ = (Gθ/2)(R² - r²)) e retangulares.",
                                    "Entenda a relação entre φ e o vetor de tensão de cisalhamento.",
                                    "Anote as hipóteses de Saint-Venant para torção uniforme."
                                  ],
                                  "verification": "Resuma em um parágrafo as condições de contorno e soluções para seções circulares e retangulares.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Resistência dos Materiais (Timoshenko)",
                                    "Notas de aula sobre torção",
                                    "Software de desenho como GeoGebra para visualizar φ"
                                  ],
                                  "tips": "Comece com seções circulares, pois são mais simples, antes de retangulares.",
                                  "learningObjective": "Compreender a função de Prandtl φ como base para cálculos de torção.",
                                  "commonMistakes": [
                                    "Confundir φ com o ângulo de torção θ",
                                    "Ignorar condições de contorno nas bordas",
                                    "Esquecer que φ é zero nas bordas livres"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar e calcular o momento de torção T = 2 ∫φ dA",
                                  "subSteps": [
                                    "Defina a área de integração A sobre a seção transversal.",
                                    "Expresse φ analiticamente para a seção escolhida (circular ou retangular).",
                                    "Configure a integral dupla ∫∫ φ(x,y) dA.",
                                    "Calcule a integral passo a passo, usando coordenadas polares para circulares.",
                                    "Multiplique o resultado por 2 para obter T."
                                  ],
                                  "verification": "Calcule T para uma seção circular de raio R=0.1m e compare com fórmula conhecida T= (π G θ R^4)/2.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora simbólica (Mathematica ou SymPy)",
                                    "Papel milimetrado para esboçar seções",
                                    "Tabelas de integrais indefinidas"
                                  ],
                                  "tips": "Use simetria da seção para simplificar integrais; para circulares, mude para coordenadas polares.",
                                  "learningObjective": "Dominar o cálculo numérico/analítico da integral para T a partir de φ.",
                                  "commonMistakes": [
                                    "Erros em limites de integração",
                                    "Esquecer o fator 2 na fórmula de T",
                                    "Usar coordenadas cartesianas em seções circulares sem necessidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar a constante de torção J efetiva",
                                  "subSteps": [
                                    "Recapitule que J = (2 / θ) ∫φ dA, onde θ é o ângulo de torção por unidade de comprimento.",
                                    "Extraia θ da solução de φ (ex: para circular, θ = (2T)/(G J)).",
                                    "Calcule J = T / (G θ) iterativamente ou diretamente da integral.",
                                    "Compare J calculado com fórmulas padrão: circular J=πR^4/2, retangular aproximada.",
                                    "Calcule a rigidez torcional k = G J."
                                  ],
                                  "verification": "Para seção retangular 0.2m x 0.1m, obtenha J ≈ 0.00141 m^4 e rigidez k para G=80 GPa.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Planilha Excel ou Python para cálculos numéricos",
                                    "Referência: Roark's Formulas for Stress and Strain",
                                    "Gráficos de φ para validação"
                                  ],
                                  "tips": "Para seções retangulares, use séries de Fourier se necessário, mas foque em aproximações para iniciantes.",
                                  "learningObjective": "Calcular J efetiva e rigidez torcional a partir de φ.",
                                  "commonMistakes": [
                                    "Confundir J polar com J torcional",
                                    "Usar θ total em vez de por unidade de comprimento",
                                    "Ignorar material (G) na rigidez"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e validar cálculos em seções simples",
                                  "subSteps": [
                                    "Escolha uma seção circular e retangular com dimensões reais.",
                                    "Calcule T e J para ambas usando os métodos anteriores.",
                                    "Compare resultados com fórmulas tabeladas.",
                                    "Analise sensibilidade: varie dimensões e observe impacto em T e J.",
                                    "Documente discrepâncias e razões (ex: aproximações em retangulares)."
                                  ],
                                  "verification": "Produza tabela comparativa de T e J calculados vs. tabelados com erro <5%.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software FEA como ANSYS Student para validação numérica",
                                    "Tabelas de constantes torcionais",
                                    "Relatório em LaTeX ou Word"
                                  ],
                                  "tips": "Valide com FEA simples para ganhar confiança nos cálculos manuais.",
                                  "learningObjective": "Integrar cálculos de T e J com validação prática.",
                                  "commonMistakes": [
                                    "Não normalizar unidades (SI)",
                                    "Ignorar fator de forma em seções retangulares",
                                    "Comparar sem considerar G"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um eixo circular de raio R=50mm sob torção com φ(r) = (Gθ/2)(R² - r²), calcule T = 2 ∫₀^R ∫₀^{2π} φ(r) r dr dθ = (π G θ R^4)/2 ≈ 15.7 kN.m para G=80 GPa, θ=0.01 rad/m. Então J = π R^4 / 2 = 9.817e-6 m^4 e rigidez k = G J = 785 kN.m²/rad.",
                              "finalVerifications": [
                                "Calcula corretamente T para seção circular com erro <1%.",
                                "Obtém J efetiva para retangular compatível com tabelas (±5%).",
                                "Explica relação entre φ, T e J em diagrama.",
                                "Valida rigidez torcional k = G J com exemplo numérico.",
                                "Identifica limitações para seções não-simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas integrais (90% correto).",
                                "Correta interpretação de φ e condições de contorno.",
                                "Validação comparativa com fórmulas padrão.",
                                "Clareza na documentação de passos e resultados.",
                                "Análise de erros comuns e sensibilidade.",
                                "Aplicação correta de unidades SI."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo integral duplo e coordenadas polares.",
                                "Física: Mecânica dos sólidos e tensões de cisalhamento.",
                                "Computação: Implementação numérica em Python/MATLAB para integrais.",
                                "Engenharia Civil: Torção em vigas e pilares.",
                                "Materiais: Dependência do módulo de cisalhamento G."
                              ],
                              "realWorldApplication": "Projeto de eixos em máquinas rotativas (motores, turbinas), análise de torção em hastes de propulsores aeronáuticos e dimensionamento de perfis metálicos em estruturas para evitar falhas por torção excessiva."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.1.3",
                            "name": "Aplicar condições de contorno na função de Prandtl",
                            "description": "Definir φ = 0 na borda livre da seção transversal e condições para furos internos, ilustrando com exemplos gráficos e numéricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a formulação da função de Prandtl e condições de contorno teóricas",
                                  "subSteps": [
                                    "Estude a equação de Prandtl: ∇²φ = -2Gθ, onde φ é a função de tensão, G é o módulo de cisalhamento e θ é o ângulo de torção por unidade de comprimento.",
                                    "Identifique as condições de contorno padrão: na borda livre externa da seção transversal, φ = 0.",
                                    "Analise condições para furos internos: φ = constante em cada contorno interno fechado, representando linhas de fluxo de cisalhamento.",
                                    "Desenhe um diagrama esquemático de uma seção transversal simples (ex: retangular sólida) destacando as bordas.",
                                    "Compare com literatura: consulte Saint-Venant ou Timoshenko para validação teórica."
                                  ],
                                  "verification": "Resuma em um parágrafo as condições de contorno e desenhe um esboço rotulado da seção.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Mecânica dos Sólidos (Timoshenko), papel e lápis, software de desenho vetorial (opcional).",
                                  "tips": "Use analogia com fluxo incompressível de fluido para visualizar φ como função de potencial.",
                                  "learningObjective": "Compreender a base matemática e física das condições de contorno na função de Prandtl.",
                                  "commonMistakes": "Confundir φ com a função de fluxo de cisalhamento; lembrar que φ=0 apenas na borda externa livre."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar condição φ = 0 na borda livre externa",
                                  "subSteps": [
                                    "Selecione uma seção transversal simples (ex: retangular ou circular sólida).",
                                    "Defina matematicamente: φ(s) = 0 para todo ponto s na fronteira externa ∂A.",
                                    "Implemente em um malha finita: atribua φ=0 nos nós da borda externa.",
                                    "Resolva a equação de Poisson numericamente usando método de diferenças finitas ou EF simples.",
                                    "Plote o contorno de φ para visualizar o comportamento."
                                  ],
                                  "verification": "Gere um gráfico onde φ=0 na borda externa e verifique numericamente em pontos selecionados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software MATLAB/Python (com NumPy/SciPy), malha gerada manualmente ou via Gmsh.",
                                  "tips": "Comece com malhas grosseiras para testes rápidos antes de refinar.",
                                  "learningObjective": "Dominar a imposição da condição Dirichlet φ=0 na borda livre.",
                                  "commonMistakes": "Esquecer de normalizar unidades ou aplicar em bordas internas por engano."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir condições de contorno para furos internos",
                                  "subSteps": [
                                    "Identifique contornos internos: para um furo, defina φ = C_i (constante arbitrária) em ∂A_i.",
                                    "Escolha constantes C_i baseadas em continuidade do fluxo: geralmente C_i = valor médio de φ adjacente.",
                                    "Ajuste para múltiplos furos: cada furo tem sua própria constante, resolvendo sistema para fluxo total zero.",
                                    "Implemente em EF: fixe nós internos em C_i e resolva o sistema global.",
                                    "Valide: calcule o momento de torção T = 2 ∫φ dA e compare com soluções analíticas."
                                  ],
                                  "verification": "Confirme que ∇φ é tangencial aos contornos internos e φ constante neles.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Software FEA (ANSYS, Code_Aster ou Python-FEniCS), geometria com furo (ex: retângulo com círculo interno).",
                                  "tips": "Use simetria para reduzir o domínio e acelerar computação.",
                                  "learningObjective": "Aplicar condições de Neumann implícitas em furos via constantes de φ.",
                                  "commonMistakes": "Definir φ=0 em furos (errado, pois permite fluxo); constantes devem refletir isolamento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ilustrar com exemplos gráficos e numéricos",
                                  "subSteps": [
                                    "Crie gráfico para seção com furo: plote níveis de φ e vetores de cisalhamento.",
                                    "Compare casos: sólido vs. com furo, mostrando redução no momento de torção.",
                                    "Gere exemplo numérico: seção elíptica com furo circular, compute φ max e T.",
                                    "Exporte resultados: gráficos 2D coloridos e tabelas de valores.",
                                    "Documente: anote diferenças percentuais entre casos."
                                  ],
                                  "verification": "Produza pelo menos 3 gráficos e 1 tabela com valores corretos validados.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "MATLAB/Paraview para visualização, calculadora para checks analíticos.",
                                  "tips": "Use colormap 'jet' para contornos claros de φ.",
                                  "learningObjective": "Visualizar e quantificar o impacto das condições de contorno.",
                                  "commonMistakes": "Escalas erradas nos gráficos obscurecendo φ=0 na borda."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e refinar a aplicação em problemas reais",
                                  "subSteps": [
                                    "Teste sensibilidade: varie malha e verifique convergência de φ e T.",
                                    "Compare com soluções exatas (ex: seção circular: φ = (R² - r²)/2 * Gθ).",
                                    "Aplique a seção complexa: I-beam com furos, imponha condições.",
                                    "Calcule propriedades: constante de torção J_eq = 2 ∫φ dA / θ.",
                                    "Registre relatório: inclua código fonte e outputs."
                                  ],
                                  "verification": "Erro <5% em comparação com analítico para caso benchmark.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código fonte reutilizável, benchmarks de literatura.",
                                  "tips": "Automatize com scripts para múltiplas malhas.",
                                  "learningObjective": "Garantir precisão e robustez na aplicação prática.",
                                  "commonMistakes": "Ignorar singularidades em cantos afiados das bordas."
                                }
                              ],
                              "practicalExample": "Em uma seção transversal de um eixo retangular 10x5 cm com furo circular de 2 cm de diâmetro no centro, imponha φ=0 na borda externa e φ=1 na borda do furo. Resolva via EF com malha de 1000 elementos, plote contornos de φ e calcule o momento de torção reduzido em 15% comparado ao sólido.",
                              "finalVerifications": [
                                "φ=0 exatamente em todos os nós da borda livre externa.",
                                "φ constante em cada contorno interno de furo.",
                                "Gradiente de φ perpendicular à borda livre e tangencial aos furos.",
                                "Momento de torção T computado corretamente via integração numérica.",
                                "Convergência demonstrada com refinamento de malha.",
                                "Gráficos mostram distribuição física realista sem anomalias."
                              ],
                              "assessmentCriteria": [
                                "Precisão na imposição das condições de contorno (90%+ acurácia nos nós).",
                                "Qualidade dos gráficos e visualizações (clareza, legendas, escalas).",
                                "Correção numérica dos resultados (erro <10% vs. analítico).",
                                "Documentação completa de passos e código.",
                                "Compreensão demonstrada em explicação oral/escrita.",
                                "Criatividade em extensão a geometrias complexas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Solução de PDEs de Poisson com condições Dirichlet/Neumann.",
                                "Física: Analogia hidrodinâmica na teoria de torção de Saint-Venant.",
                                "Computação: Programação numérica e métodos de elementos finitos.",
                                "Engenharia de Materiais: Impacto de defeitos (furos) na resistência à torção."
                              ],
                              "realWorldApplication": "No projeto de eixos ocos ou tubos em turbinas eólicas, aviões e máquinas-ferramenta, onde furos para lubrificação ou alívio de peso exigem condições de contorno precisas na função de Prandtl para prever fadiga por torção e otimizar dimensões sem excesso de material."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.2",
                        "name": "Formulação Variacional do Problema de Torção",
                        "description": "Formulação do problema de torção como um problema de minimização de energia potencial usando o método de Rayleigh-Ritz ou Galerkin, com a equação de Laplace ∇²φ = -2Gθ para o campo escalar φ.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.2.1",
                            "name": "Derivar a equação governante de Laplace para φ",
                            "description": "Partir das equações de equilíbrio e constitutivas para torção, chegando à equação ∇²φ = -2Gθ, onde G é o módulo de cisalhamento e θ o ângulo de torção unitário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar as equações de equilíbrio para o problema de torção",
                                  "subSteps": [
                                    "Identificar o problema de torção em barras prismáticas com seção transversal constante.",
                                    "Escrever as equações de equilíbrio estático em 2D para tensões de cisalhamento τ_xz e τ_yz, sem acelerações.",
                                    "Estabelecer que ∂τ_xz/∂x + ∂τ_yz/∂y = 0 no plano da seção transversal.",
                                    "Confirmar condições de contorno: tensões nulas na borda da seção."
                                  ],
                                  "verification": "Verificar se as equações de equilíbrio ∂τ_xz/∂x + ∂τ_yz/∂y = 0 estão corretamente escritas e justificadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de mecânica dos sólidos",
                                    "Livro de referência como Timoshenko 'Strength of Materials'",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Lembre-se de que em torção pura, não há tensões normais significativas na seção transversal.",
                                  "learningObjective": "Compreender as condições de equilíbrio que governam o campo de tensões em torção.",
                                  "commonMistakes": "Confundir coordenadas (x,y,z) ou esquecer que o equilíbrio é apenas no plano transversal."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estabelecer as relações constitutivas lineares elásticas",
                                  "subSteps": [
                                    "Recordar a hipótese de deformação para torção: deformação γ_xz = ∂w/∂x + ∂u/∂z, mas simplificar para rotação rígida.",
                                    "Expressar deformações em termos do ângulo de torção θ: γ_xz = -θ y, γ_yz = θ x (aproximação de torção de Sant-Venant).",
                                    "Aplicar a lei de Hooke para materiais isotrópicos: τ_xz = G γ_xz, τ_yz = G γ_yz, onde G é o módulo de cisalhamento.",
                                    "Verificar consistência com o momento de torção total."
                                  ],
                                  "verification": "Confirmar que τ_xz = -G θ y e τ_yz = G θ x derivam corretamente das deformações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de propriedades de materiais",
                                    "Software simbólico como Mathematica ou papel para derivações"
                                  ],
                                  "tips": "Use a convenção de sinal consistente para θ positivo.",
                                  "learningObjective": "Ligar deformações de cisalhamento às tensões via lei constitutiva.",
                                  "commonMistakes": "Inverter os sinais nas expressões de deformação ou confundir G com E (módulo de Young)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir a função de tensão de Prandtl φ",
                                  "subSteps": [
                                    "Definir a função de tensão φ tal que τ_xz = ∂φ/∂y, τ_yz = -∂φ/∂x, satisfazendo automaticamente o equilíbrio.",
                                    "Verificar que essa definição cumpre ∂τ_xz/∂x + ∂τ_yz/∂y = ∂²φ/∂x∂y - ∂²φ/∂y∂x = 0.",
                                    "Discutir condições de contorno: φ = constante (geralmente 0) na borda da seção transversal.",
                                    "Relacionar o momento de torção T = 2 ∫φ dA sobre a seção.",
                                    "Introduzir θ como parâmetro de torção unitária."
                                  ],
                                  "verification": "Testar se a definição de φ satisfaz a equação de equilíbrio por inspeção.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagrama de seção transversal de exemplo (círculo ou elipse)",
                                    "Livro de EF como Zienkiewicz"
                                  ],
                                  "tips": "A função φ é análoga ao potencial de velocidade em fluidos incompressíveis.",
                                  "learningObjective": "Introduzir φ como potencial que simplifica o problema de equilíbrio.",
                                  "commonMistakes": "Confundir os sinais nas derivadas parciais de φ para τ_xz e τ_yz."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Expressar tensões em termos de φ e deformações",
                                  "subSteps": [
                                    "Substituir τ_xz = ∂φ/∂y = G γ_xz = -G θ y.",
                                    "Substituir τ_yz = -∂φ/∂x = G γ_yz = G θ x.",
                                    "Escrever as duas equações: ∂φ/∂y = -G θ y e -∂φ/∂x = G θ x.",
                                    "Diferenciar a primeira em relação a x e a segunda em relação a y para eliminar θ."
                                  ],
                                  "verification": "Verificar consistência dimensional entre φ (unidades de tensão × área) e G θ y.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Cálculo simbólico manual ou SymPy online"
                                  ],
                                  "tips": "Mantenha θ constante ao longo da derivação, pois é unitário.",
                                  "learningObjective": "Conectar a função φ às relações constitutivas.",
                                  "commonMistakes": "Esquecer o sinal negativo em uma das expressões de tensão."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Derivar a equação governante ∇²φ = -2Gθ",
                                  "subSteps": [
                                    "Diferencie ∂φ/∂y = -G θ y em relação a x: ∂²φ/∂x∂y = -G θ ∂y/∂x = 0 (errado, corrija para combinar).",
                                    "Corretamente: ∂/∂x (∂φ/∂y) = ∂/∂x (-G θ y) → ∂²φ/∂x∂y = 0 (mas use a outra).",
                                    "Da primeira: ∂/∂x (∂φ/∂y) = -G θ ∂y/∂x = 0, mas combine: ∂/∂y (-∂φ/∂x) = ∂/∂y (G θ x).",
                                    "Some as diferenciações: ∂²φ/∂x² + ∂²φ/∂y² = ∇²φ = -2 G θ.",
                                    "Confirmar: diferenciando adequadamente, obtém-se ∇²φ = -2 G θ."
                                  ],
                                  "verification": "Resolver ∇²φ = -2 G θ para uma seção circular e verificar φ conhecida.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exemplo analítico de seção circular",
                                    "Ferramenta de plotagem como MATLAB para φ"
                                  ],
                                  "tips": "Use o operador Laplace ∇² = ∂²/∂x² + ∂²/∂y² e some as equações diferenciadas.",
                                  "learningObjective": "Obter a equação diferencial governante para φ.",
                                  "commonMistakes": "Erro no fator 2: derivar corretamente ∂²φ/∂y² + ∂²φ/∂x² = -Gθ (de y) -Gθ (de x) = -2Gθ."
                                }
                              ],
                              "practicalExample": "Para uma seção transversal circular de raio R, resolva ∇²φ = -2Gθ com φ=0 na borda, obtendo φ = (Gθ/2)(r² - R²), e verifique τ_xz = ∂φ/∂y = Gθ (x² + y² - R²)'s derivada apropriada.",
                              "finalVerifications": [
                                "A equação final ∇²φ = -2Gθ é obtida corretamente sem erros de sinal.",
                                "Condições de contorno φ=0 na borda são satisfeitas.",
                                "O momento de torção T = 2 ∫φ dA coincide com fórmulas conhecidas para seções simples.",
                                "Substituição inversa de φ nas tensões recupera τ_xz = -Gθ y e τ_yz = Gθ x.",
                                "Dimensões são consistentes: [φ] = Pa·m², [∇²φ] = Pa/m² = [Gθ].",
                                "Equilíbrio é automaticamente satisfeito pela definição de φ."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação passo a passo (sem erros algébricos).",
                                "Compreensão conceitual: explicar por que φ satisfaz equilíbrio automaticamente.",
                                "Correta ligação entre constitutivas, equilíbrio e equação governante.",
                                "Capacidade de verificar com exemplo numérico ou analítico simples.",
                                "Identificação de erros comuns e condições de validade (torção de Sant-Venant).",
                                "Clareza na apresentação da derivação escrita."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações diferenciais elípticas (Laplace/Poisson) e funções harmônicas.",
                                "Física: Princípio de equilíbrio estático e potencial escalar em mecânica.",
                                "Engenharia Computacional: Base para formulação variacional em Elementos Finitos.",
                                "Materiais: Relações constitutivas lineares e isotrópicas."
                              ],
                              "realWorldApplication": "Essa equação é fundamental para analisar tensões em eixos de transmissão de potência em motores, turbinas e máquinas industriais, permitindo otimizar designs para evitar falhas por torção excessiva."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.2.2",
                            "name": "Formular o funcional de energia para Rayleigh-Ritz",
                            "description": "Escrever o funcional de energia Π = ∫(1/2)(∇φ)² dA - ∫2Gθ φ dA e demonstrar a variação δΠ = 0 levando à equação fraca para Galerkin.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os fundamentos do problema de torção e princípios variacionais",
                                  "subSteps": [
                                    "Estude a equação diferencial governante para torção: ∇²φ = -2Gθ em Ω, com condições de contorno φ=0 em ∂Ω.",
                                    "Revise o princípio de Rayleigh-Ritz: minimizar o funcional de energia total Π para aproximar a solução.",
                                    "Identifique os componentes de energia: energia de deformação interna e trabalho externo devido ao torque.",
                                    "Desenhe a seção transversal de um eixo torcido, rotulando φ como função de Prandtl.",
                                    "Confirme a simetria e propriedades do problema (domínio Ω, contorno ∂Ω)."
                                  ],
                                  "verification": "Resuma verbalmente ou por escrito os princípios variacionais e a equação de torção, garantindo correspondência com referências padrão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Elementos Finitos (ex: Zienkiewicz), caderno, caneta"
                                  ],
                                  "tips": "Use diagramas para visualizar o fluxo de tensões de cisalhamento em torção.",
                                  "learningObjective": "Compreender a base física e matemática do problema de torção para formular corretamente o funcional.",
                                  "commonMistakes": "Confundir φ com função de tensão em vez de fluxo de Prandtl; ignorar condições de contorno."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a expressão do funcional de energia Π",
                                  "subSteps": [
                                    "Expresse a energia de deformação: (1/2) ∫_Ω (∇φ)² dA, derivada da densidade de energia (1/2)G(∇φ)² ajustada.",
                                    "Inclua o termo de trabalho virtual: - ∫_Ω 2Gθ φ dA, representando o torque aplicado.",
                                    "Escreva Π[φ] = ∫_Ω (1/2)(∇φ) · (∇φ) dA - ∫_Ω 2Gθ φ dA.",
                                    "Verifique dimensionalmente: energia tem unidades de torque vezes ângulo.",
                                    "Teste com função de teste simples (ex: φ constante) para checar consistência."
                                  ],
                                  "verification": "Escreva Π explicitamente e confirme que corresponde à forma padrão do problema de torção.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Caderno, calculadora simbólica ou software como SymPy/MATLAB"
                                  ],
                                  "tips": "Lembre-se que Gθ é constante; integre por partes se necessário para validar.",
                                  "learningObjective": "Construir o funcional de energia combinando termos internos e externos corretamente.",
                                  "commonMistakes": "Esquecer o fator 1/2 na energia interna; sinal errado no termo de carga."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a variação δΠ e impor δΠ = 0",
                                  "subSteps": [
                                    "Compute a primeira variação: δΠ = ∫_Ω ∇φ · ∇(δη) dA - ∫_Ω 2Gθ δη dA, para variação η com η=0 em ∂Ω.",
                                    "Integre por partes o primeiro termo: -∫_Ω φ ∇²η dA + ∫_∂Ω (∂φ/∂n) η dΓ, descartando o contorno por η=0.",
                                    "Simplifique para δΠ = ∫_Ω [-∇²φ - 2Gθ] η dA = 0.",
                                    "Conclua que ∇²φ + 2Gθ = 0 em Ω (equação forte), mas foque na forma fraca.",
                                    "Escreva a forma bilinear: a(φ,η) = l(η), onde a(u,v)=∫∇u·∇v dA, l(v)=∫2Gθ v dA."
                                  ],
                                  "verification": "Derive δΠ=0 passo a passo e verifique se recupera a equação de Poisson fraca.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel milimetrado, lápis, referência de cálculo variacional"
                                  ],
                                  "tips": "Use δφ para variação e η admissível; pratique integração por partes em 2D.",
                                  "learningObjective": "Dominar o cálculo variacional para ligar Π à equação governante.",
                                  "commonMistakes": "Erro no sinal da integração por partes; não impor η=0 na fronteira."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Conectar à equação fraca de Galerkin e validar",
                                  "subSteps": [
                                    "Identifique a forma fraca: Encontre φh em Vh tal que ∫∇φh·∇ηh dA = ∫2Gθ ηh dA ∀ ηh em Vh.",
                                    "Discuta Rayleigh-Ritz como caso especial de Galerkin com Vh = espaço de trial/teste.",
                                    "Implemente numericamente para uma malha simples (ex: seção retangular).",
                                    "Compare solução analítica (se disponível) com a variacional.",
                                    "Documente o processo completo em um relatório curto."
                                  ],
                                  "verification": "Resolva um problema teste simples e confirme que a matriz de rigidez surge corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software FEA básico (ex: FEniCS ou MATLAB), computador"
                                  ],
                                  "tips": "Comece com 1 elemento para depurar; normalize Gθ=1.",
                                  "learningObjective": "Aplicar o funcional em contexto Galerkin para método dos elementos finitos.",
                                  "commonMistakes": "Confundir forma forte com fraca; malha inadequada em testes numéricos."
                                }
                              ],
                              "practicalExample": "Para uma barra retangular de torção (largura 2a, altura 2b), defina Ω=[-a,a]x[-b,b], θ=1, G=1. Escreva Π, minimize com funções polinomiais baixas (ex: φ= c(x² - a²)(y² - b²)), resolva para c e compare com solução exata φ ≈ (a² - x²)(b² - y²)/3.",
                              "finalVerifications": [
                                "Π está escrito corretamente com termos de energia interna e externa.",
                                "Derivação de δΠ leva exatamente à forma fraca ∫∇φ·∇η = ∫2Gθ η.",
                                "Condições de contorno essenciais (φ=0 em ∂Ω) são respeitadas.",
                                "Dimensionalidade e unidades de Π coincidem com torque*ângulo.",
                                "Teste numérico simples converge para solução conhecida.",
                                "Relatório resume passos sem erros matemáticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de Π e δΠ (sem erros de sinal ou integração).",
                                "Compreensão conceitual: explicar ligação Rayleigh-Ritz/Galerkin.",
                                "Profundidade dos subpassos: todos detalhados e lógicos.",
                                "Criatividade no exemplo prático e validação numérica.",
                                "Clareza na documentação e avoidance de erros comuns.",
                                "Tempo respeitado e materiais usados eficientemente."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e método dos resíduos ponderados.",
                                "Física: Mecânica dos sólidos e teoria da elasticidade.",
                                "Computação: Programação numérica para integração e montagem de matrizes.",
                                "Engenharia Civil: Análise de vigas torcidas em estruturas."
                              ],
                              "realWorldApplication": "Formulação essencial para software de Elementos Finitos (ANSYS, Abaqus) na análise de torção em eixos de turbinas, hélices de navios e componentes automotivos, otimizando designs para resistir a torques sem falha por cisalhamento."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.3",
                        "name": "Discretização com Elementos Finitos para Torção",
                        "description": "Aplicação de elementos finitos 2D (triangulares e quadriláteros isoparamétricos) na seção transversal para aproximar a função de Prandtl, incluindo montagem de matrizes de rigidez e carga.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.3.1",
                            "name": "Implementar elemento triangular para campo escalar",
                            "description": "Derivar a matriz de rigidez [k] = ∫ [B]^T [B] t dΩ para elemento triangular constante/linear, onde [B] contém derivadas das funções de forma, e vetor de carga {f} = 2Gθ ∫ {N} t dΩ.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir geometria e funções de forma para elemento triangular",
                                  "subSteps": [
                                    "Escolha o tipo de elemento: triangular constante (1 nó) ou linear (3 nós).",
                                    "Defina as coordenadas dos nós: (x1,y1), (x2,y2), (x3,y3).",
                                    "Derive as funções de forma N_i em coordenadas naturais (L1, L2, L3) ou isoparamétricas.",
                                    "Calcule a espessura t e o Jacobiano J para integração.",
                                    "Verifique que soma das funções de forma Ni = 1."
                                  ],
                                  "verification": "Confirme que ∑Ni = 1 em pontos de Gauss e que funções interpolam corretamente nos nós.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel quadriculado, calculadora, software como MATLAB ou Python (NumPy/SciPy).",
                                  "tips": "Use coordenadas área para triângulo linear: Ni = Ai / Atotal.",
                                  "learningObjective": "Entender interpolação do campo escalar φ dentro do elemento.",
                                  "commonMistakes": "Esquecer normalização das funções de forma ou usar coordenadas cartesianas diretamente sem transformação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a matriz de derivadas [B]",
                                  "subSteps": [
                                    "Compute as derivadas das funções de forma: ∂Ni/∂x, ∂Ni/∂y usando Jacobiano.",
                                    "Monte [B] = [ ∂N1/∂x  0 ; 0 ∂N1/∂y ; ∂N2/∂x 0 ; ... ] para campo escalar (∇φ).",
                                    "Avalie [B] nos pontos de integração Gauss (2x2 para linear).",
                                    "Verifique simetria e consistência dimensional.",
                                    "Implemente em código para automação."
                                  ],
                                  "verification": "Teste [B] em um ponto conhecido; derivadas devem coincidir com geometria.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB/Python script, tabela de pontos Gauss, documentação de MEF.",
                                  "tips": "Para triângulo constante, [B] é constante; para linear, varia.",
                                  "learningObjective": "Relacionar gradiente do campo escalar às derivadas das funções de forma.",
                                  "commonMistakes": "Inverter derivadas parciais ou esquecer inversa do Jacobiano."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar e integrar a matriz de rigidez [k]",
                                  "subSteps": [
                                    "Formule [k] = t ∫ [B]^T [B] dΩ sobre o elemento.",
                                    "Use integração numérica Gauss-Legendre (1 ou 2 pontos para constante/linear).",
                                    "Compute pesos e [B]^T [B] em cada ponto de Gauss.",
                                    "Some contribuições: [k] = t ∑ w_i [B_i]^T [B_i] |J_i|.",
                                    "Verifique simetria e positividade de [k]."
                                  ],
                                  "verification": "Matriz [k] deve ser simétrica e [u]^T [k] [u] > 0 para vetores não-nulos.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Código NumPy/MATLAB para integração, exemplos analíticos para validação.",
                                  "tips": "Para triângulo constante, integre analiticamente: área * [B]^T [B].",
                                  "learningObjective": "Implementar formulação variacional para problema de campo escalar.",
                                  "commonMistakes": "Esquecer fator t (espessura) ou determinante do Jacobiano |J|."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular o vetor de carga {f}",
                                  "subSteps": [
                                    "Identifique a carga: {f} = 2 G θ t ∫ {N} dΩ para torção.",
                                    "Integre {N} sobre o elemento usando Gauss: ∑ w_i {N_i} |J_i|.",
                                    "Multiplique por constantes materiais (G: módulo cisalhamento, θ: rotação).",
                                    "Implemente em código e teste com carga uniforme.",
                                    "Verifique dimensionalidade e sinal."
                                  ],
                                  "verification": "Para carga uniforme, {f} proporcional à área nodal.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Mesmo código de integração, propriedades do material (G, θ).",
                                  "tips": "θ é o ângulo de torção por unidade de comprimento.",
                                  "learningObjective": "Incorporar termos de carga no problema de torção via MEF.",
                                  "commonMistakes": "Confundir {N} com [B] ou esquecer o fator 2Gθ."
                                }
                              ],
                              "practicalExample": "Para um triângulo com nós (0,0), (1,0), (0,1), t=1, G=1, θ=1: compute [k] 3x3 simétrica e {f} = [0.1667; 0.1667; 0.1667]*2 usando 1 ponto Gauss, validando com solução analítica.",
                              "finalVerifications": [
                                "Matriz [k] é simétrica e definida positiva.",
                                "Vetor {f} é consistente com distribuição de carga uniforme.",
                                "Energia ∫ ∇φ · ∇φ dΩ = {φ}^T [k] {φ} converge para malha refinada.",
                                "Implementação numérica reproduz solução analítica para triângulo unitário.",
                                "Gradientes em [B] interpolam corretamente nos nós.",
                                "Tempo de computação escalável para múltiplos elementos."
                              ],
                              "assessmentCriteria": [
                                "Precisão da matriz [k] dentro de 1% da analítica.",
                                "Correta implementação de integração numérica sem erros de indexação.",
                                "Código modular e comentado, executável sem falhas.",
                                "Validação com testes unitários para [B] e integrais.",
                                "Compreensão demonstrada via explicação oral da derivação.",
                                "Eficiência: tempo < 1s para 100 elementos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo integral numérico e álgebra linear (matrizes).",
                                "Programação: Implementação numérica em Python/MATLAB com vetores/matrizes.",
                                "Física: Mecânica dos sólidos, equação de Laplace para torção.",
                                "Engenharia Civil: Análise de estruturas 2D semelhantes."
                              ],
                              "realWorldApplication": "Simulação de torção em perfis metálicos não-circulares (ex: eixos em turbinas eólicas ou vigas em pontes), otimizando design contra falhas por cisalhamento usando software CAE como ANSYS ou Abaqus."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2.2"
                            ]
                          },
                          {
                            "id": "10.1.6.2.3.2",
                            "name": "Montar sistema global e aplicar condições de contorno",
                            "description": "Montar a matriz global [K]{φ} = {F} para malha de seção transversal, impor φ=0 nas bordas via penalidade ou eliminação, e resolver para φ nodal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular matrizes elementares [k_e] e vetores {f_e} para todos os elementos",
                                  "subSteps": [
                                    "Identificar nós e conectividade de cada elemento na malha de seção transversal.",
                                    "Para cada elemento, calcular a matriz de rigidez [k_e] usando a fórmula [k_e] = ∫[B]^T [D] [B] dA, onde [B] é a matriz de derivadas e [D] é a matriz constitutiva para torção (G J, com J área polar aproximada).",
                                    "Calcular vetor de força {f_e} se houver cargas distribuídas (geralmente zero para torção pura).",
                                    "Armazenar [k_e] e {f_e} indexados pelos nós locais do elemento.",
                                    "Verificar simetria e positivos definitos das matrizes elementares."
                                  ],
                                  "verification": "Conferir que [k_e] é simétrica e soma das linhas é consistente com propriedades físicas esperadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de EF (MATLAB, Python com NumPy/SciPy), malha gerada previamente, fórmulas de torção anotadas.",
                                  "tips": "Use Gauss quadratura para integração numérica em elementos triangulares ou quadrilaterais.",
                                  "learningObjective": "Dominar o cálculo local de contribuições elementares para problemas de torção.",
                                  "commonMistakes": "Esquecer de mapear coordenadas locais para globais; usar módulo de elasticidade em vez de cisalhamento G."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Montar matriz global [K] e vetor global {F} via assembly",
                                  "subSteps": [
                                    "Inicializar [K] e {F} com zeros, dimensões N_nós x N_nós e N_nós x 1.",
                                    "Para cada elemento, mapear índices locais para globais usando conectividade.",
                                    "Acumular [k_e] nas posições corretas de [K] e {f_e} em {F}.",
                                    "Verificar que cada entrada de [K] é soma exata das contribuições elementares sobrepostas.",
                                    "Aplicar renumeração de nós se necessário para otimizar largura de banda."
                                  ],
                                  "verification": "Verificar que [K] é simétrica e que diagonal é positiva; checar soma de linhas para equilíbrio.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código de assembly (loop sobre elementos), debugger para matrizes esparsas.",
                                  "tips": "Use formato CSR (Compressed Sparse Row) para eficiência em malhas grandes.",
                                  "learningObjective": "Entender o processo de superposição de contribuições elementares no domínio global.",
                                  "commonMistakes": "Índices off-by-one no mapeamento local-global; duplicar contribuições sem zerar inicial."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Impor condições de contorno φ=0 nas bordas",
                                  "subSteps": [
                                    "Identificar nós na borda da seção transversal (φ fixo em 0).",
                                    "Escolher método: eliminação (zerar linhas/colunas e RHS) ou penalidade (adicionar α [I] na diagonal dos nós fixos, com α grande).",
                                    "Para eliminação: zerar linha/coluna do nó i em [K], definir K_ii = 1, F_i = 0.",
                                    "Para penalidade: adicionar α à diagonal K_ii para nós i na borda, sem alterar {F}.",
                                    "Verificar que [K] modificada mantém simetria e condicionamento razoável."
                                  ],
                                  "verification": "Após solução preliminar, confirmar que φ_nodal ≈ 0 nos nós de borda (erro < 1e-6).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Lista de nós de contorno da malha, valor grande para penalidade (ex: 1e12).",
                                  "tips": "Prefira eliminação para precisão; penalidade para simplicidade em códigos genéricos.",
                                  "learningObjective": "Aplicar corretamente métodos de imposição de Dirichlet em sistemas EF.",
                                  "commonMistakes": "Aplicar penalidade muito pequena causando derivação; esquecer simetria ao modificar [K]."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver o sistema [K]{φ} = {F} para φ nodal",
                                  "subSteps": [
                                    "Verificar condicionamento de [K] (cond([K]) < 1e12).",
                                    "Escolher solver: decomposição LU direta para malhas pequenas, iterativo (CG) para grandes.",
                                    "Executar solução {φ} = [K]^{-1} {F}.",
                                    "Calcular resíduos r = [K]{φ} - {F} e verificar ||r|| / ||{F}|| < 1e-8.",
                                    "Visualizar φ nodal como mapa de contorno na seção transversal."
                                  ],
                                  "verification": "Resíduo normatizado < tolerância; φ=0 exato nas bordas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Solver linear (SciPy solve, MATLAB backslash), ferramenta de plot (Matplotlib).",
                                  "tips": "Pré-condicione com diagonal de [K] para solvers iterativos.",
                                  "learningObjective": "Resolver e validar sistemas lineares oriundos de discretização EF.",
                                  "commonMistakes": "Usar solver inadequado para [K] mal condicionada; ignorar resíduos na validação."
                                }
                              ],
                              "practicalExample": "Para uma seção transversal retangular 2x1 m dividida em 4 elementos triangulares, com G=1e10 Pa, monte [K] 9x9 (9 nós), imponha φ=0 nos 4 nós da borda via eliminação, resolva para φ interno. Espere φ máximo ~0.1 rad no centro para torque unitário.",
                              "finalVerifications": [
                                "φ nodal = 0 em todos os nós de borda.",
                                "Matriz global [K] simétrica e positiva definida antes de contornos.",
                                "Resíduo do sistema ||[K]{φ} - {F}|| < 1e-6.",
                                "Visualização de φ mostra variação suave, máxima no interior.",
                                "Energia de deformação ∫ G (∇φ)^2 dA converge com refinamento de malha.",
                                "Comparação com solução analítica para seção circular (erro < 5%)."
                              ],
                              "assessmentCriteria": [
                                "Correção no assembly: contribuições elementares somam corretamente em [K].",
                                "Precisão nas condições de contorno: φ_borda < 1e-10.",
                                "Eficiência computacional: tempo de solução escalável com N_nós.",
                                "Validação numérica: resíduos e testes de convergência documentados.",
                                "Clareza na implementação: código comentado e modular.",
                                "Interpretação física: discussão de φ como função de warping."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: montagem e solução de sistemas esparsos simétricos.",
                                "Programação Numérica: implementação de loops de assembly e solvers.",
                                "Física de Sólidos: teoria de torção de Prandtl e função de tensão φ.",
                                "Geometria Computacional: geração e conectividade de malhas 2D.",
                                "Análise Numérica: métodos de penalidade vs. eliminação."
                              ],
                              "realWorldApplication": "Análise de torção em eixos de turbinas eólicas ou hélices de navios, otimizando design para minimizar peso e tensão máxima, integrando com software CAE como ANSYS para prototipagem virtual."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.3.3",
                            "name": "Calcular resultados pós-processados em torção",
                            "description": "Extrair tensões de cisalhamento, momento torçor e linhas de fluxo a partir de φ interpolado, validando com soluções analíticas para seções conhecidas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar interpolação do potencial de torção φ",
                                  "subSteps": [
                                    "Obtenha os valores de φ nos nós dos elementos finitos a partir da solução do problema.",
                                    "Defina os pontos de interesse (nós, pontos de Gauss ou contorno) para interpolação.",
                                    "Use funções de interpolação (shape functions) para calcular φ em pontos internos.",
                                    "Armazene os valores interpolados em uma malha ou grade para visualização.",
                                    "Verifique consistência das funções de shape para o tipo de elemento usado (ex: quadrilateral)."
                                  ],
                                  "verification": "Confirme que φ interpolado é contínuo entre elementos e satisfaz condições de contorno (φ=0 em bordas fixas).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código de EF (MATLAB/Python), malha de exemplo para torção, documentação de shape functions.",
                                  "tips": "Use interpolação bilinear para elementos quadrilaterais para precisão.",
                                  "learningObjective": "Dominar interpolação de campos escalares em malhas de EF.",
                                  "commonMistakes": "Ignorar derivadas das shape functions ou usar nós errados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular tensões de cisalhamento τ",
                                  "subSteps": [
                                    "Calcule os gradientes ∇φ nos pontos de interesse usando derivadas das shape functions.",
                                    "Aplique a relação τ = G * ∇φ, onde G é o módulo de cisalhamento.",
                                    "Projeite os gradientes em coordenadas locais do elemento se necessário.",
                                    "Mapeie τ para o domínio global e armazene em vetores ou matrizes.",
                                    "Visualize as linhas de tensão de cisalhamento via plot de vetores."
                                  ],
                                  "verification": "Verifique se |τ| é máximo no contorno e zero no centro para seções circulares.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Script de pós-processamento, propriedades do material (G), visualizador (Paraview/MATLAB).",
                                  "tips": "Integre numericamente em pontos de Gauss para precisão em elementos.",
                                  "learningObjective": "Entender relação entre potencial φ e tensões em torção.",
                                  "commonMistakes": "Confundir ∇φ com φ diretamente ou esquecer fator G."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar momento torçor T e linhas de fluxo",
                                  "subSteps": [
                                    "Integre τ sobre a seção: T = 2 * ∫(φ * dA) ou equivalentemente via tensões.",
                                    "Trace linhas de fluxo ortogonais às linhas de tensão (∇φ perpendicular a linhas de fluxo).",
                                    "Use integração numérica (Gauss quadrature) sobre elementos para T.",
                                    "Gere contornos de φ constantes como aproximação de linhas de fluxo.",
                                    "Calcule fator de torção J efetivo: J = T / (G * θ), onde θ é ângulo de torção."
                                  ],
                                  "verification": "Compare T calculado com valor analítico conhecido para a seção.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Ferramentas de integração numérica, seção de teste (ex: retangular).",
                                  "tips": "Para linhas de fluxo, resolva ODE perpendicular a ∇φ.",
                                  "learningObjective": "Calcular grandezas integradas e visualizar fluxo em torção.",
                                  "commonMistakes": "Erro na integração (fator 2 esquecido) ou traçar linhas erradas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar resultados com soluções analíticas",
                                  "subSteps": [
                                    "Selecione seções conhecidas (circular: φ = (r^2 - ρ^2)/2; retangular: série de Saint-Venant).",
                                    "Calcule φ_analítico, τ_analítico e T_analítico para mesmos pontos.",
                                    "Compute erros relativos: |numérico - analítico| / analítico < 5%.",
                                    "Gere gráficos comparativos (φ, τ, T) e analise convergência com refinamento de malha.",
                                    "Documente discrepâncias e sugira melhorias na malha."
                                  ],
                                  "verification": "Erros < 5% para malha refinada e gráficos sobrepostos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Fórmulas analíticas de torção, software de plotagem.",
                                  "tips": "Comece com seção circular para validação simples.",
                                  "learningObjective": "Validar simulações numéricas contra teoria clássica.",
                                  "commonMistakes": "Usar fórmulas erradas ou normalizar incorretamente."
                                }
                              ],
                              "practicalExample": "Para uma seção transversal circular de raio R=1, malha com 100 elementos quadrilaterais. Interpole φ, calcule τ máx = G*θ*R no contorno, T= (π R^4 θ)/2, e valide com erro <2%. Trace linhas de fluxo circulares concêntricas.",
                              "finalVerifications": [
                                "φ interpolado coincide com contornos analíticos.",
                                "Tensões de cisalhamento mostram distribuição correta (máx no contorno).",
                                "Momento torçor T bate com analítico dentro de 5%.",
                                "Linhas de fluxo são ortogonais às isopotenciais.",
                                "Erros diminuem com refinamento de malha.",
                                "Visualizações mostram simetria esperada para seção."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos de ∇φ e τ (erro <5%).",
                                "Correção da integração para T.",
                                "Qualidade das linhas de fluxo traçadas.",
                                "Validação quantitativa com métricas de erro.",
                                "Relatório com gráficos comparativos claros.",
                                "Explicação de discrepâncias e conclusões."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo vetorial, integração numérica e interpolação.",
                                "Programação: Implementação de pós-processamento em Python/MATLAB.",
                                "Física: Mecânica dos sólidos e teoria de torção Saint-Venant.",
                                "Visualização de dados: Uso de ferramentas como Paraview para campos vetoriais."
                              ],
                              "realWorldApplication": "Em projetos de eixos de transmissão em turbinas eólicas ou motores automotivos, onde EF valida tensões em seções complexas irregulares, prevendo falhas por torção e otimizando designs para eficiência energética."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.3.2"
                            ]
                          },
                          {
                            "id": "10.1.6.2.3.4",
                            "name": "Usar elementos isoparamétricos para seções complexas",
                            "description": "Aplicar integração numérica de Gauss em quadriláteros de 4/8 nós para malhas de seções com furos ou contornos irregulares em análise de torção.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Elementos Isoparamétricos e Integração de Gauss",
                                  "subSteps": [
                                    "Estude as coordenadas isoparamétricas (ξ, η) para quadriláteros de 4 e 8 nós.",
                                    "Revise funções de forma N_i(ξ, η) para elementos lineares (4 nós) e quadráticos (8 nós).",
                                    "Aprenda pontos e pesos de Gauss para integração 2D (2x2 para 4 nós, 3x3 para 8 nós).",
                                    "Pratique mapeamento de geometria física para domínio isoparamétrico.",
                                    "Calcule Jacobiano J para transformação diferencial."
                                  ],
                                  "verification": "Resolva exercícios manuais de cálculo de funções de forma e integração em um elemento simples, verificando valores exatos conhecidos.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro de Elementos Finitos (ex: Zienkiewicz), MATLAB ou Python com NumPy/SciPy, planilha para cálculos manuais.",
                                  "tips": "Use diagramas visuais para mapear ξ-η para x-y; visualize com plots 2D.",
                                  "learningObjective": "Dominar mapeamento isoparamétrico e integração numérica para preparar montagem de elementos.",
                                  "commonMistakes": "Confundir ordem de Gauss (2x2 para lineares, 3x3 para quadráticos); ignorar derivadas do Jacobiano."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Geometria e Gerar Malha para Seções Complexas",
                                  "subSteps": [
                                    "Desenhe seção com furos ou contornos irregulares (ex: perfil em C com furo circular).",
                                    "Divida em quadriláteros isoparamétricos: use 4 nós para bordas retas, 8 nós para curvas.",
                                    "Atribua coordenadas nodais precisas, garantindo continuidade entre elementos.",
                                    "Gere malha refinada nas regiões de alta gradiente (próximo a furos).",
                                    "Valide malha: cheque conectividade e qualidade (aspect ratio < 5)."
                                  ],
                                  "verification": "Exporte malha para visualização (GMSH ou MATLAB) e confirme ausência de sobreposições ou gaps.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Software de malhamento (GMSH, FreeCAD), MATLAB para scripts de malha personalizada.",
                                  "tips": "Comece com malha grosseira e refine iterativamente; use elementos 8 nós em contornos para precisão.",
                                  "learningObjective": "Criar malhas adaptadas a geometrias irregulares usando elementos isoparamétricos.",
                                  "commonMistakes": "Malha distorcida causando Jacobiano singular; poucos nós em curvas levando a erros geométricos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Integração Numérica e Montar Matriz de Rigidez para Torção",
                                  "subSteps": [
                                    "Defina equação de torção: ∇²φ = 0, com matriz [B] para gradientes em isoparamétrico.",
                                    "Para cada elemento, loop sobre pontos Gauss: calcule N, B, det(J), integre [k_e] = ∫ B^T B det(J) dξ dη.",
                                    "Some contribuições elementares na matriz global [K], aplicando condições de contorno.",
                                    "Implemente em código para 4/8 nós, usando pesos Gauss adequados.",
                                    "Resolva [K]{φ} = {F} para potencial de torção φ."
                                  ],
                                  "verification": "Compare [k_e] de um elemento teste com solução analítica; cheque simetria e positivo-definido de [K].",
                                  "estimatedTime": "4 horas",
                                  "materials": "MATLAB, Python (com NumPy, SciPy para solver), código template de EF para torção.",
                                  "tips": "Vetorize loops em código para eficiência; debugue imprimindo det(J) em pontos Gauss.",
                                  "learningObjective": "Aplicar integração Gauss em elementos isoparamétricos para montar sistema de torção.",
                                  "commonMistakes": "Pontos/pesos Gauss errados causando integração imprecisa; esquecer det(J) na integral."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Resultados e Validar Solução",
                                  "subSteps": [
                                    "Calcule tensões de cisalhamento τ = G θ ∇φ a partir de φ.",
                                    "Plote contornos de φ e τ na seção; compute torque total T = 2 ∫ φ dA.",
                                    "Refine malha e verifique convergência de T para valor referência.",
                                    "Compare com solução analítica ou FEM comercial para seção similar.",
                                    "Documente erros e ajustes necessários."
                                  ],
                                  "verification": "Erro em T < 5% vs. referência; plots suaves sem oscilações numéricas.",
                                  "estimatedTime": "2 horas",
                                  "materials": "MATLAB para pós-processamento (contourf, quiver), referência de torção em seções conhecidas.",
                                  "tips": "Use malha adaptativa para convergência rápida; normalize resultados por θ.",
                                  "learningObjective": "Interpretar e validar resultados de EF em torção para seções complexas.",
                                  "commonMistakes": "Condições de contorno erradas (φ=0 em borda livre); pós-processamento sem interpolação em nós."
                                }
                              ],
                              "practicalExample": "Analise torção em um eixo com seção transversal em forma de C (altura 10cm, espessura 1cm, furo de 2cm diâmetro). Use malha com 200 elementos isoparamétricos (50% 8 nós nas curvas), compute torque para θ=1 rad/m, valide T ≈ 1500 N·cm vs. analítico aproximado.",
                              "finalVerifications": [
                                "Malha cobre perfeitamente contorno irregular sem distorções excessivas.",
                                "Integração Gauss converge com ordem correta (exata para polinômios adequados).",
                                "Matriz [K] é simétrica e bem-condicionada (cond([K]) < 1e6).",
                                "Torque computado converge monotonicamente com refinamento de malha.",
                                "Campos de φ e τ são fisicamente coerentes (máx. τ na borda, zero no centro).",
                                "Resultados coincidem com software comercial em <3% erro."
                              ],
                              "assessmentCriteria": [
                                "Precisão da geometria mapeada (erro Jacobiano <1%).",
                                "Correta implementação de pontos/pesos Gauss por tipo de elemento.",
                                "Convergência demonstrada em pelo menos 3 níveis de malha.",
                                "Código modular e comentado, executável sem erros.",
                                "Análise qualitativa/quantitativa de resultados com plots.",
                                "Documentação de torque e tensões com unidades corretas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Integração numérica quadratura Gauss-Legendre.",
                                "Programação: Estruturas de dados para malhas (nós, conectividade), solvers lineares.",
                                "Física: Teoria de elasticidade Saint-Venant para torção.",
                                "Engenharia de Software: Validação e verificação numérica (VV&V)."
                              ],
                              "realWorldApplication": "Projeto de eixos torcidos em turbinas eólicas ou hélices de navios com seções otimizadas (furos para leveza), onde EF isoparamétrico permite análise precisa sem simplificações geométricas, reduzindo fadiga e otimizando material."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.3",
                    "name": "Escoamento Potencial",
                    "description": "Modelagem de escoamentos irrotacionais e incompressíveis com potencial de velocidade como variável escalar.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.3.1",
                        "name": "Fundamentos do Escoamento Potencial",
                        "description": "Conceitos físicos básicos do escoamento irrotacional e incompressível, incluindo a definição do potencial de velocidade como variável escalar para modelagem em elementos finitos.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.1.1",
                            "name": "Identificar condições de escoamento irrotacional e incompressível",
                            "description": "Explicar as condições matemáticas rot(v) = 0 (irrotacionalidade) e div(v) = 0 (incompressibilidade), e sua relevância para fluxos potenciais sem viscosidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de escoamento de fluidos",
                                  "subSteps": [
                                    "Revise a definição de campo de velocidade vetorial v em mecânica dos fluidos.",
                                    "Diferencie escoamentos viscosos de invíscidos.",
                                    "Explique o que significa irrotacional (ausência de vórtices) e incompressível (densidade constante).",
                                    "Identifique cenários onde essas aproximações são válidas, como fluxos de alta Reynolds.",
                                    "Discuta limitações, como presença de choques ou separação."
                                  ],
                                  "verification": "Resuma em suas palavras os conceitos e dê um exemplo de fluxo real que os satisfaz.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Mecânica dos Fluidos (ex: White ou Currie)",
                                    "Notas de aula sobre vetores",
                                    "Calculadora simbólica (Wolfram Alpha)"
                                  ],
                                  "tips": "Use analogias visuais: irrotacional como água girando sem redemoinhos, incompressível como fluxo em tubo rígido.",
                                  "learningObjective": "Entender intuitivamente irrotacionalidade e incompressibilidade como pré-requisitos para fluxos potenciais.",
                                  "commonMistakes": [
                                    "Confundir irrotacional com estacionário.",
                                    "Ignorar que incompressibilidade não implica velocidade constante."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar o operador rotacional (curl) e sua condição de irrotacionalidade",
                                  "subSteps": [
                                    "Defina o rotacional de um campo vetorial v: rot(v) = ∇ × v.",
                                    "Escreva a expressão em coordenadas cartesianas: (∂w/∂y - ∂v/∂z, ∂u/∂z - ∂w/∂x, ∂v/∂x - ∂u/∂y).",
                                    "Calcule rot(v) para um campo vetorial simples, como v = (y, -x, 0).",
                                    "Interprete rot(v) = 0 como ausência de rotação local (vorticity zero).",
                                    "Verifique em coordenadas cilíndricas para fluxos simétricos."
                                  ],
                                  "verification": "Compute rot(v) para v = (-y, x, 0) e confirme que é zero.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software de álgebra simbólica (Mathematica ou SymPy)",
                                    "Folha de fórmulas vetoriais",
                                    "Vídeos Khan Academy sobre curl"
                                  ],
                                  "tips": "Lembre-se: curl mede rotação; zero significa que linhas de campo são retas ou curvas sem torção.",
                                  "learningObjective": "Calcular e interpretar rot(v) = 0 como condição matemática de irrotacionalidade.",
                                  "commonMistakes": [
                                    "Erros nos sinais das componentes do curl.",
                                    "Confundir curl com gradiente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar o operador divergência (div) e sua condição de incompressibilidade",
                                  "subSteps": [
                                    "Defina divergência: div(v) = ∇ · v = ∂u/∂x + ∂v/∂y + ∂w/∂z.",
                                    "Relacione com conservação de massa: para ρ constante, div(v) = 0.",
                                    "Calcule div(v) para exemplos como v = (x, y, z) (compressível) vs. v = (-y, x, 0) (incompressível).",
                                    "Discuta aproximação de Boussinesq para fluidos ligeiramente compressíveis.",
                                    "Verifique continuidade em malha finita para validação numérica."
                                  ],
                                  "verification": "Prove que para v = (x+y, x-y, x+y+z), div(v) ≠ 0, e corrija para torná-lo zero.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python para cálculos numéricos",
                                    "Referência: equação de continuidade",
                                    "Apontamentos de análise vetorial"
                                  ],
                                  "tips": "Pense em div(v)>0 como fonte (expansão), <0 como sumidouro (contração).",
                                  "learningObjective": "Aplicar div(v) = 0 como equação de continuidade para fluxos incompressíveis.",
                                  "commonMistakes": [
                                    "Esquecer termos em 3D.",
                                    "Confundir com laplaciano."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar condições para fluxos potenciais e identificar aplicações",
                                  "subSteps": [
                                    "Mostre que rot(v)=0 implica v = ∇φ (função potencial).",
                                    "Combine com div(v)=0 → ∇²φ = 0 (equação de Laplace).",
                                    "Identifique fluxos potenciais: sem viscosidade, 2D/3D aerodinâmica de perfis delgados.",
                                    "Dê exemplos: fluxo uniforme, dipolo, vórtice (irrotacional mas com circulação).",
                                    "Discuta relevância em elementos finitos: simplificação para problemas elípticos."
                                  ],
                                  "verification": "Derive ∇²φ = 0 a partir de rot(v)=div(v)=0 e resolva para φ = x em 1D.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Software FEA (ANSYS ou FreeFEM)",
                                    "Exemplos de fluxos potenciais online",
                                    "Artigo sobre teoria de potencial"
                                  ],
                                  "tips": "Fluxos potenciais são invíscidos e sem separação: ideais para upstream de airfoil.",
                                  "learningObjective": "Reconhecer quando rot(v)=div(v)=0 permite modelagem via potencial escalar.",
                                  "commonMistakes": [
                                    "Achar que todo fluxo irrotacional é potencial (ignorar circulação).",
                                    "Aplicar em regiões com viscosidade dominante."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar identificação em problemas reais",
                                  "subSteps": [
                                    "Analise um campo v dado e verifique rot(v)=div(v)=0 numericamente.",
                                    "Classifique fluxos: ex. fluxo ao redor de cilindro (potencial exceto camada limite).",
                                    "Simule em código simples (Matlab/Python) e plote vorticity.",
                                    "Compare com fluxos reais via PIV (Particle Image Velocimetry) dados.",
                                    "Documente casos onde condições falham (ex: turbulência)."
                                  ],
                                  "verification": "Para v = (U∞(1 - y²/(a²+b²)), U∞(2xy/(a²+b²)), 0), confirme condições e interprete.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "Python com NumPy/Matplotlib",
                                    "Datasets de fluxos experimentais",
                                    "Tutorial CFD online"
                                  ],
                                  "tips": "Use contour plots de vorticity para visualização intuitiva.",
                                  "learningObjective": "Identificar condições em contextos de engenharia mecânica e elementos finitos.",
                                  "commonMistakes": [
                                    "Verificar só em um ponto, não no domínio inteiro.",
                                    "Ignorar coordenadas curvilíneas."
                                  ]
                                }
                              ],
                              "practicalExample": "Dado o campo de velocidade 2D v = (-y, x), compute rot(v) = (0,0,2) ≠ 0 (rotacional, como vórtice rígido) vs. v = (y, -x) com rot(v)=0 e div(v)=0 (potencial, fluxo fonte/sumidouro). Simule em Python e plote streamlines para visualizar irrotacionalidade.",
                              "finalVerifications": [
                                "Deriva corretamente rot(v)=0 e div(v)=0 em 3 componentes cartesianas.",
                                "Explica verbalmente a existência de φ tal que v=∇φ.",
                                "Identifica um fluxo real (ex: ao redor de airfoil) que satisfaz as condições.",
                                "Calcula numericamente em grade 10x10 e confirma zeros dentro de tolerância 1e-6.",
                                "Discute quando aproximar sem viscosidade em EF.",
                                "Distingue de fluxos Navier-Stokes completos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos operadores curl e div (100% correto).",
                                "Interpretação física clara e sem ambiguidades.",
                                "Exemplos práticos relevantes a engenharia (≥2 citados).",
                                "Análise de limitações e erros potenciais.",
                                "Integração com fluxos potenciais e Laplace (derivação completa).",
                                "Criatividade em verificações numéricas/visuais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo vetorial, equações diferenciais elípticas (Laplace).",
                                "Física: Mecânica dos fluidos invíscida, conservação de momento angular.",
                                "Computação: Programação numérica (CFD), análise de gradientes em meshes.",
                                "Engenharia Aeronáutica: Projeto de perfis aerodinâmicos.",
                                "Análise Numérica: Métodos de elementos finitos para problemas de potencial."
                              ],
                              "realWorldApplication": "Em engenharia mecânica, essas condições simplificam simulações de escoamento ao redor de turbinas eólicas ou asas de aviões usando painéis ou EF, reduzindo tempo computacional de horas para minutos, essencial para otimização aerodinâmica em design sustentável."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.2",
                            "name": "Definir o potencial de velocidade φ",
                            "description": "Introduzir o potencial escalar φ tal que v = ∇φ, demonstrando como isso simplifica a modelagem de escoamentos 2D e 3D irrotacionais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender escoamento irrotacional e a necessidade de um potencial",
                                  "subSteps": [
                                    "Revise a definição de rotação (curl) em mecânica dos fluidos: ω = ∇ × v = 0 para irrotacional.",
                                    "Discuta condições onde escoamentos são irrotacionais (ex.: baixa viscosidade, longe de vórtices).",
                                    "Explique por que usar um potencial simplifica: conservativo permite φ tal que v = ∇φ.",
                                    "Compare escoamentos rotacionais vs. irrotacionais em termos de modelagem numérica.",
                                    "Identifique aplicações iniciais em 2D e 3D."
                                  ],
                                  "verification": "Resuma em 3 frases por que escoamentos irrotacionais usam potencial; confira com referência.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Mecânica dos Fluidos (ex.: White), caderno, calculadora.",
                                  "tips": "Visualize com diagramas de campo de velocidades sem curvas fechadas.",
                                  "learningObjective": "Entender a premissa matemática para introduzir o potencial escalar.",
                                  "commonMistakes": "Confundir irrotacional com incompressível; rotação zero não implica divergência zero."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir formalmente o potencial de velocidade φ",
                                  "subSteps": [
                                    "Defina φ como função escalar: v = ∇φ, onde ∇φ = (∂φ/∂x, ∂φ/∂y, ∂φ/∂z).",
                                    "Mostre que ∇ × v = ∇ × (∇φ) = 0, provando irrotacionalidade automática.",
                                    "Discuta unicidade: φ definido até constante; fixe com φ=0 em ponto de referência.",
                                    "Escreva componentes em 2D: u = ∂φ/∂x, v = ∂φ/∂y; em 3D adicione w.",
                                    "Pratique convertendo um campo de velocidade simples em φ."
                                  ],
                                  "verification": "Calcule ∇φ para um φ dado e verifique se matches v conhecido.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel quadriculado, software simbólico (ex.: Mathematica ou SymPy online).",
                                  "tips": "Integre ∂φ/∂x = u ao longo de x para encontrar φ.",
                                  "learningObjective": "Dominar a definição matemática e propriedades do potencial φ.",
                                  "commonMistakes": "Esquecer que φ é definido até constante; não verificar curl zero."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a equação governante para escoamento potencial",
                                  "subSteps": [
                                    "Para incompressível, use ∇·v = 0 → ∇·(∇φ) = ∇²φ = 0 (equação de Laplace).",
                                    "Derive em coordenadas cartesianas: ∂²φ/∂x² + ∂²φ/∂y² + ∂²φ/∂z² = 0.",
                                    "Discuta simplificações: 2D reduz a ∂²φ/∂x² + ∂²φ/∂y² = 0.",
                                    "Compare com equações de Navier-Stokes completas para mostrar redução.",
                                    "Resolva um exemplo analítico simples (ex.: φ = x y para fluxo uniforme)."
                                  ],
                                  "verification": "Verifique se ∇²φ = 0 para sua solução proposta.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora gráfica ou MATLAB para derivadas parciais.",
                                  "tips": "Lembre: Laplace é elíptica, bem-posed com condições de contorno.",
                                  "learningObjective": "Conectar φ à equação de Laplace e simplificações.",
                                  "commonMistakes": "Confundir ∇·v=0 com ∇×v=0; derivar Laplace errado."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar simplificação na modelagem 2D e 3D",
                                  "subSteps": [
                                    "Em 2D: modele fluxo uniforme ou fonte com φ = U x (uniforme).",
                                    "Em 3D: discuta dutos ou esferas com soluções esféricas.",
                                    "Compare complexidade: sem φ, resolve 3 equações; com φ, uma escalar.",
                                    "Implemente BCs: Dirichlet (φ conhecido em contorno) ou Neumann (∂φ/∂n = v_n).",
                                    "Simule numericamente um caso simples para validar."
                                  ],
                                  "verification": "Gere gráfico de linhas de corrente (ψ ortogonal a φ) e valide irrotacional.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Software FEM como FreeFEM ou Python (NumPy/Matplotlib).",
                                  "tips": "Use simetria para reduzir 3D a 2D.",
                                  "learningObjective": "Aplicar φ para simplificar modelagem prática.",
                                  "commonMistakes": "Ignorar condições de contorno; assumir compressível."
                                }
                              ],
                              "practicalExample": "Modelar o escoamento potencial 2D ao redor de um cilindro: φ = U (r + R²/r) cosθ, onde v_θ = -∂φ/∂r = 0 na superfície (condição sem penetração), simplificando análise aerodinâmica sem viscosidade.",
                              "finalVerifications": [
                                "Confirme v = ∇φ e ∇ × v = 0 para exemplo dado.",
                                "Resolva ∇²φ = 0 em malha simples e plote velocidades.",
                                "Verifique conservação de massa: ∇·v = 0.",
                                "Compare solução potencial com Navier-Stokes invíscido.",
                                "Gere linhas de potencial e equipotenciais coerentes.",
                                "Explique redução de DOFs em FEM: 1 eq. escalar vs. vetor."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição v = ∇φ e propriedades (irrotacional, Laplace).",
                                "Correta derivação da equação de Laplace de ∇·v=0.",
                                "Exemplo prático com BCs corretas e verificação numérica.",
                                "Explicação clara de simplificações 2D/3D vs. formulações vetoriais.",
                                "Identificação de limitações (ex.: não captura separação).",
                                "Uso adequado de ferramentas matemáticas e software."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise vetorial (gradiente, Laplace), PDEs elípticas.",
                                "Física: Mecânica dos fluidos conservativos, teoria de potencial eletrostática.",
                                "Computação: Programação numérica (FEM, CFD solvers como OpenFOAM).",
                                "Engenharia Aeronáutica: Perfil de asas em regime invíscido.",
                                "Matemática Computacional: Métodos de elementos finitos para escalares."
                              ],
                              "realWorldApplication": "Design de perfis aerodinâmicos em aviação (cálculo de sustentação via teorema de Kutta-Joukowski), otimização de turbinas eólicas, simulação de fluxo em tubulações hidráulicas e análise preliminar de escoamentos em reatores nucleares."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.3",
                            "name": "Relacionar escoamento potencial com problemas de campo escalar",
                            "description": "Comparar o escoamento potencial com outros problemas escalares como transferência de calor e torção, destacando similaridades na equação de Laplace.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos dos problemas de campo escalar e a equação de Laplace",
                                  "subSteps": [
                                    "Definir campo escalar e suas propriedades principais.",
                                    "Derivar ou recordar a equação de Laplace (∇²φ = 0) para problemas estacionários sem fontes.",
                                    "Explicar tipos de condições de contorno (Dirichlet e Neumann).",
                                    "Identificar exemplos genéricos de problemas escalares.",
                                    "Resolver um problema 1D simples analiticamente."
                                  ],
                                  "verification": "Resolver corretamente um exercício simples de Laplace em 1D e explicar as condições de contorno.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro-texto de Matemática Computacional",
                                    "Caderno e calculadora",
                                    "Software simbólico como Mathematica ou SymPy"
                                  ],
                                  "tips": "Sempre verifique a dimensionalidade do problema antes de aplicar a equação.",
                                  "learningObjective": "Dominar a base matemática comum a todos os problemas de campo escalar.",
                                  "commonMistakes": [
                                    "Confundir equação de Laplace com Poisson (que tem fontes)",
                                    "Ignorar a estacionariedade do problema"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a formulação matemática do escoamento potencial",
                                  "subSteps": [
                                    "Recordar as hipóteses: fluido incompressível, irrotacional e estacionário.",
                                    "Introduzir a função de potencial de velocidade φ, onde v = ∇φ.",
                                    "Derivar ∇²φ = 0 a partir das equações de Navier-Stokes simplificadas.",
                                    "Discutir condições de contorno para escoamento (velocidade normal e tangencial).",
                                    "Calcular linha de corrente e equipotenciais em um exemplo simples."
                                  ],
                                  "verification": "Derivar corretamente a equação de Laplace para φ e aplicar em um perfil simples.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Dinâmica dos Fluidos",
                                    "Software CFD introdutório como Xfoil",
                                    "Papel milimetrado"
                                  ],
                                  "tips": "Visualize o potencial como 'altura' em um mapa topográfico para entender gradientes.",
                                  "learningObjective": "Entender como o escoamento potencial se enquadra na estrutura de Laplace.",
                                  "commonMistakes": [
                                    "Esquecer a irrotacionalidade (curl v = 0)",
                                    "Confundir potencial de velocidade com potencial de pressão"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar outros problemas escalares: transferência de calor e torção",
                                  "subSteps": [
                                    "Para transferência de calor estacionário: derivar ∇²T = 0 e condições de contorno (temperatura e fluxo de calor).",
                                    "Para torção em vigas: introduzir função de tensão de Prandtl ψ, onde ∇²ψ = -2Gθ.",
                                    "Comparar adaptações da Laplace pura (notar Poisson na torção).",
                                    "Resolver numericamente ou analiticamente um caso 2D simples para cada.",
                                    "Listar analogias físicas entre as grandezas (T ~ φ ~ ψ)."
                                  ],
                                  "verification": "Explicar e derivar as equações para calor e torção, resolvendo um exercício básico.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro de Transferência de Calor",
                                    "Livro de Resistência dos Materiais",
                                    "MATLAB ou Python com NumPy"
                                  ],
                                  "tips": "Use analogias elétricas: potencial hidráulico ~ elétrico ~ térmico.",
                                  "learningObjective": "Reconhecer as formulações semelhantes em contextos diferentes.",
                                  "commonMistakes": [
                                    "Aplicar Laplace diretamente na torção sem ajuste para Poisson",
                                    "Misturar condições de contorno entre problemas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar escoamento potencial com problemas escalares e destacar similaridades",
                                  "subSteps": [
                                    "Tabular as equações, variáveis e condições de contorno para os três problemas.",
                                    "Destacar similaridades: todas resolvem ∇²φ = 0 (ou similar), malha única no MEF.",
                                    "Discutir diferenças: fontes de carga, rotação, etc.",
                                    "Implementar uma simulação numérica simples comparativa (ex: MEF em código).",
                                    "Concluir com vantagens da analogia na modelagem computacional."
                                  ],
                                  "verification": "Criar uma tabela comparativa precisa e simular um caso unificado.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Planilha Excel ou LaTeX para tabela",
                                    "Código Python para MEF simples",
                                    "Artigos sobre analogias em MEF"
                                  ],
                                  "tips": "Pense em termos de 'grandeza física' vs. 'matemática': a física varia, a PDE é a mesma.",
                                  "learningObjective": "Estabelecer conexões claras entre escoamento potencial e outros campos escalares.",
                                  "commonMistakes": [
                                    "Superestimar diferenças e ignorar a essência comum da Laplace",
                                    "Não considerar escalas físicas"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule o escoamento potencial ao redor de um aerofólio (φ para velocidade), compare com distribuição de temperatura em uma placa com bordas isotérmicas (T para calor) e função de Prandtl em uma seção transversal de viga retangular (ψ para torção). Use MEF para mesclar as simulações em um código único, alterando apenas condições de contorno.",
                              "finalVerifications": [
                                "Derivar ∇²φ = 0 para escoamento e analogias exatas para calor e torção.",
                                "Explicar verbalmente pelo menos 3 similaridades matemáticas e físicas.",
                                "Criar uma tabela comparativa com equações, variáveis e contornos.",
                                "Resolver um problema numérico híbrido (ex: mesmo domínio para diferentes físicas).",
                                "Identificar quando usar MEF unificado para esses problemas.",
                                "Discutir limitações das analogias (ex: não-estacionário)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação das equações de Laplace para cada contexto (30%).",
                                "Clareza na identificação de similaridades e diferenças (25%).",
                                "Qualidade da tabela ou diagrama comparativo (20%).",
                                "Correção em simulações ou exemplos numéricos (15%).",
                                "Profundidade na discussão de aplicações no MEF (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Numérica e Equações Diferenciais Parciais.",
                                "Física: Eletrostática (potencial elétrico segue Laplace).",
                                "Engenharia Civil: Análise Estrutural (torção em elementos finitos).",
                                "Engenharia Química: Difusão estacionária.",
                                "Computação: Programação de solvers MEF genéricos."
                              ],
                              "realWorldApplication": "Na engenharia, essa relação permite reutilizar códigos MEF para design de turbinas aéreas (escoamento), dissipadores de calor em eletrônicos (transferência térmica) e eixos de transmissão em máquinas (torção), otimizando tempo de desenvolvimento e reduzindo erros em simulações industriais."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.2",
                        "name": "Equação Governante e Formulação Variacional",
                        "description": "Derivação da equação de Laplace ∇²φ = 0 e sua formulação fraca para aplicação do método dos elementos finitos.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.2.1",
                            "name": "Derivar a equação de Laplace para o potencial φ",
                            "description": "Partir das equações de irrotacionalidade e incompressibilidade para obter ∇²φ = 0, incluindo demonstração em coordenadas cartesianas e polares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar as equações de irrotacionalidade e incompressibilidade",
                                  "subSteps": [
                                    "Defina o campo de velocidade v como um vetor em 3D: v = (u, v, w).",
                                    "Escreva a condição de irrotacionalidade: ∇ × v = 0, expandindo os componentes em coordenadas cartesianas.",
                                    "Escreva a condição de incompressibilidade: ∇ · v = 0, também em cartesianas.",
                                    "Discuta o significado físico: ausência de vórtices e conservação de massa.",
                                    "Verifique com um exemplo simples, como fluxo uniforme."
                                  ],
                                  "verification": "Escreva as equações completas de ∇ × v = 0 e ∇ · v = 0 sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de mecânica dos fluidos (ex: Currie ou White), caderno e caneta.",
                                  "tips": "Use notação vetorial para manter a generalidade antes de coordenadas específicas.",
                                  "learningObjective": "Compreender as condições fundamentais para escoamento potencial.",
                                  "commonMistakes": "Confundir irrotacionalidade (rot=0) com incompressibilidade (div=0)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o potencial de velocidade φ e provar irrotacionalidade",
                                  "subSteps": [
                                    "Defina v = ∇φ, onde φ é o potencial escalar.",
                                    "Prove que ∇ × (∇φ) = 0 usando identidade vetorial conhecida.",
                                    "Expanda em coordenadas cartesianas: ∂φ/∂x = u, etc., e mostre que os componentes do rot são zero.",
                                    "Discuta a existência de φ (teorema de Poincaré).",
                                    "Integre um campo v simples para encontrar φ."
                                  ],
                                  "verification": "Derive ∇ × ∇φ = 0 e verifique com componentes cartesianos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Caderno, calculadora simbólica opcional (ex: Mathematica ou papel).",
                                  "tips": "Lembre-se: o gradiente de escalar é sempre irrotacional; isso é chave.",
                                  "learningObjective": "Estabelecer a relação v = ∇φ para campos irrotacionais.",
                                  "commonMistakes": "Esquecer que φ é definido até uma constante aditiva."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a equação de Laplace ∇²φ = 0 a partir da incompressibilidade",
                                  "subSteps": [
                                    "Substitua v = ∇φ na equação de incompressibilidade: ∇ · v = ∇ · (∇φ) = ∇²φ = 0.",
                                    "Justifique a identidade ∇ · ∇φ = ∇²φ (Laplaciano).",
                                    "Discuta propriedades da equação de Laplace (eliptica, soluções harmônicas).",
                                    "Verifique dimensionalmente: φ tem unidades de velocidade × comprimento.",
                                    "Esboce uma solução trivial: φ = constante ou linear."
                                  ],
                                  "verification": "Mostre passo a passo que ∇ · ∇φ = ∇²φ = 0.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de análise vetorial, caderno.",
                                  "tips": "Mantenha a notação vetorial; evite pular identidades.",
                                  "learningObjective": "Obter a equação governante ∇²φ = 0.",
                                  "commonMistakes": "Confundir ∇²φ com outras equações como Poisson (que tem fonte)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar a equação de Laplace em coordenadas cartesianas",
                                  "subSteps": [
                                    "Expanda ∇²φ em cartesianas: ∂²φ/∂x² + ∂²φ/∂y² + ∂²φ/∂z² = 0.",
                                    "Derive os componentes de v: u = ∂φ/∂x, etc., e substitua em ∇ · v.",
                                    "Resolva um exemplo 2D: φ = x y, verifique se satisfaz.",
                                    "Discuta simetria e condições de contorno.",
                                    "Compare com forma geral."
                                  ],
                                  "verification": "Escreva e verifique ∇²φ = 0 para um φ teste.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Papel quadriculado, calculadora.",
                                  "tips": "Use 2D primeiro para simplicidade antes de 3D.",
                                  "learningObjective": "Aplicar Laplace em coordenadas retangulares.",
                                  "commonMistakes": "Erros em derivadas parciais mistas (sinal ou ordem)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Demonstrar a equação de Laplace em coordenadas polares",
                                  "subSteps": [
                                    "Expresse ∇φ em polares: v_r = ∂φ/∂r, v_θ = (1/r) ∂φ/∂θ.",
                                    "Derive ∇ · v em polares: (1/r) ∂(r v_r)/∂r + (1/r) ∂v_θ/∂θ = 0.",
                                    "Substitua para obter ∇²φ = ∂²φ/∂r² + (1/r) ∂φ/∂r + (1/r²) ∂²φ/∂θ² = 0 (2D).",
                                    "Estenda para 3D se aplicável, incluindo z.",
                                    "Teste com φ = r cos θ (dipolo)."
                                  ],
                                  "verification": "Derive a forma polar completa e verifique um exemplo.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Tabela de operadores em polares (livro ou online), caderno.",
                                  "tips": "Pratique a regra da cadeia para gradiente em polares.",
                                  "learningObjective": "Generalizar Laplace para coordenadas cilíndricas/polares.",
                                  "commonMistakes": "Esquecer fatores 1/r na divergência polar."
                                }
                              ],
                              "practicalExample": "Para escoamento ao redor de um cilindro em 2D potencial, defina φ = U (r + R²/r) cos θ, compute ∇²φ em polares e verifique que é zero, recuperando v_r e v_θ sem singularidades.",
                              "finalVerifications": [
                                "Derivar ∇²φ = 0 de ∇ × v = 0 e ∇ · v = 0 sem erros.",
                                "Escrever explicitamente ∇² em cartesianas e polares.",
                                "Verificar um exemplo numérico ou analítico em ambas coordenadas.",
                                "Explicar fisicamente o significado de φ.",
                                "Identificar quando a aproximação potencial falha (ex: viscosidade).",
                                "Resolver um problema simples de Laplace com BCs."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (sem erros algébricos).",
                                "Compreensão conceitual (irrotacional vs incompressível).",
                                "Capacidade de expandir em diferentes coordenadas.",
                                "Uso correto de identidades vetoriais.",
                                "Aplicação em exemplo prático com verificação.",
                                "Clareza na explicação oral/escrita."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações diferenciais parciais elípticas e métodos de separação de variáveis.",
                                "Física: Eletrostática (potencial elétrico obedece Laplace).",
                                "Computação: Implementação numérica via elementos finitos (MEF).",
                                "Engenharia: Aerodinâmica e projeto de perfis aerodinâmicos."
                              ],
                              "realWorldApplication": "Na engenharia aeronáutica, a equação de Laplace modela escoamentos ideais ao redor de asas (teoria de Prandtl-Glauert), permitindo simulações iniciais de sustentação e arrasto sem turbulência, essencial para design de aviões e turbinas eólicas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.3.2.2",
                            "name": "Formular o princípio variacional ou de Galerkin",
                            "description": "Obter a forma fraca ∫∇φ · ∇ψ dΩ = ∫ g ψ dΓ através de integração por partes, preparando para a discretização em MEF.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a equação governante e condições de contorno",
                                  "subSteps": [
                                    "Identifique a equação de Laplace ∇²φ = 0 para escoamento potencial irrotacional.",
                                    "Defina o domínio Ω e as fronteiras Γ = Γ₁ ∪ Γ₂, onde Γ₁ tem condição de Dirichlet (φ conhecida) e Γ₂ tem condição de Neumann (∂φ/∂n = g).",
                                    "Escreva matematicamente as condições de contorno: φ = φ̄ em Γ₁ e ∇φ · n = g em Γ₂.",
                                    "Verifique a regularidade da solução φ ∈ H¹(Ω) (espaço de Sobolev).",
                                    "Anote os termos envolvidos para preparar a multiplicação pela função teste."
                                  ],
                                  "verification": "Confirme que a equação e condições estão corretamente escritas em um papel ou software simbólico como SymPy.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Livro de Elementos Finitos (ex: Zienkiewicz), caderno e caneta, software simbólico opcional"
                                  ],
                                  "tips": "Sempre comece definindo claramente o domínio e fronteiras para evitar confusões posteriores.",
                                  "learningObjective": "Compreender a base matemática do problema de campo escalar antes da formulação variacional.",
                                  "commonMistakes": [
                                    "Confundir condições de Dirichlet e Neumann",
                                    "Ignorar a fronteira Γ₁ na integração"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir funções teste e multiplicar pela equação governante",
                                  "subSteps": [
                                    "Escolha funções teste ψ ∈ H¹₀(Ω), vanish em Γ₁ (espaço de funções com suporte zero na fronteira Dirichlet).",
                                    "Multiplique a equação ∇²φ = 0 por ψ e integre sobre Ω: ∫_Ω ψ ∇²φ dΩ = 0.",
                                    "Expanda o laplaciano: ∇²φ = ∇ · (∇φ).",
                                    "Integre sobre todo o domínio Ω para obter a forma integral inicial.",
                                    "Confirme que isso é válido para soluções fracas (distribuições)."
                                  ],
                                  "verification": "Escreva a integral ∫_Ω ψ ∇²φ dΩ = 0 e verifique dimensionalmente.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Caderno, calculadora simbólica ou Mathematica/MATLAB"
                                  ],
                                  "tips": "Lembre-se: funções teste são arbitrárias e suaves para capturar a solução fraca.",
                                  "learningObjective": "Aplicar o conceito de multiplicação por funções teste no método dos resíduos ponderados.",
                                  "commonMistakes": [
                                    "Usar ψ que não vanish em Γ₁",
                                    "Esquecer que a equação é =0 no domínio"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar integração por partes (teorema de Green)",
                                  "subSteps": [
                                    "Use o primeiro teorema de Green: ∫_Ω ψ ∇²φ dΩ = ∫_∂Ω ψ (∇φ · n) dΓ - ∫_Ω ∇ψ · ∇φ dΩ.",
                                    "Substitua na forma integral: -∫_Ω ∇ψ · ∇φ dΩ + ∫_∂Ω ψ (∇φ · n) dΓ = 0.",
                                    "Separe a fronteira ∂Ω = Γ₁ ∪ Γ₂.",
                                    "Em Γ₁, ψ=0 por construção, então termo vanish.",
                                    "Em Γ₂, ∇φ · n = g, resultando em ∫_Γ₂ g ψ dΓ."
                                  ],
                                  "verification": "Derive explicitamente que ∫_Ω ∇φ · ∇ψ dΩ = ∫_Γ₂ g ψ dΓ.",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "Tabela de identidades vetoriais, caderno"
                                  ],
                                  "tips": "Desenhe o domínio e setas normais para visualizar os termos de contorno.",
                                  "learningObjective": "Dominar a integração por partes para transferir derivadas da solução para a função teste.",
                                  "commonMistakes": [
                                    "Sinal errado no teorema de Green",
                                    "Não zerar termo em Γ₁"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Obter a forma fraca final e discutir propriedades",
                                  "subSteps": [
                                    "Escreva a forma final: Encontre φ ∈ H¹(Ω) tal que φ=φ̄ em Γ₁ e ∫_Ω ∇φ · ∇ψ dΩ = ∫_Γ₂ g ψ dΓ ∀ ψ ∈ H¹₀(Ω).",
                                    "Identifique a forma bilinear a(φ,ψ) = ∫_Ω ∇φ · ∇ψ dΩ e linear l(ψ) = ∫_Γ₂ g ψ dΓ.",
                                    "Verifique coercividade e continuidade para existência/unicidade (Lax-Milgram).",
                                    "Prepare para discretização: φ_h = ∑ φ_i N_i, ψ_h = N_j.",
                                    "Teste com um exemplo numérico simples para validar."
                                  ],
                                  "verification": "Confirme que a forma é simétrica e positiva definida.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Software FEM como FEniCS para teste opcional"
                                  ],
                                  "tips": "Sempre teste com ψ constante para checar consistência.",
                                  "learningObjective": "Formular o princípio variacional/Galerkin pronto para MEF.",
                                  "commonMistakes": [
                                    "Esquecer a restrição φ=φ̄ em Γ₁",
                                    "Não mencionar o espaço de funções"
                                  ]
                                }
                              ],
                              "practicalExample": "Para ∇²φ=0 em um quadrado unitário Ω=[0,1]², φ=0 em três lados, ∂φ/∂n=1 no lado direito. A forma fraca é ∫_Ω ∇φ · ∇ψ dΩ = ∫_{x=1} ψ dΓ, resolvida via MEF com malha triangular.",
                              "finalVerifications": [
                                "Forma fraca escrita corretamente: ∫_Ω ∇φ · ∇ψ dΩ = ∫_Γ₂ g ψ dΓ.",
                                "Termos de contorno incorporados adequadamente (vanish em Γ₁).",
                                "Espaços de funções H¹(Ω) e H¹₀(Ω) mencionados.",
                                "Preparação explícita para discretização via base nodal.",
                                "Verificação com teorema de Green derivado passo a passo.",
                                "Exemplo numérico simples testado e correto."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (sem erros de sinal ou integração).",
                                "Compreensão conceitual de funções teste e forma fraca.",
                                "Correta aplicação de condições de contorno.",
                                "Identificação de forma bilinear e linear.",
                                "Explicação de propriedades (coercividade, continuidade).",
                                "Clareza na preparação para MEF."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise funcional e teoremas de Green.",
                                "Física: Equações diferenciais elípticas em fluidos.",
                                "Computação: Implementação numérica em solvers FEM.",
                                "Engenharia: Simulações de escoamento em aerodinâmica."
                              ],
                              "realWorldApplication": "Em engenharia mecânica/aeroespacial, essa formulação é usada em softwares como ANSYS para simular escoamentos potenciais ao redor de perfis aerodinâmicos, otimizando designs de asas de aviões e turbinas eólicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.3",
                        "name": "Discretização e Implementação em Elementos Finitos",
                        "description": "Aplicação prática do MEF para escoamento potencial, incluindo montagem de matrizes e condições de contorno.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.3.1",
                            "name": "Selecionar elementos finitos para campo escalar",
                            "description": "Escolher elementos triangulares lineares ou quadriláteros isoparamétricos para malhas 2D, definindo funções de forma N_i para aproximar φ^h = ∑ φ_i N_i.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Malhas 2D e Campos Escalares em Elementos Finitos",
                                  "subSteps": [
                                    "Entenda o conceito de malha 2D para problemas de campo escalar como φ (potencial).",
                                    "Revise a aproximação φ^h = ∑ φ_i N_i, onde N_i são funções de forma.",
                                    "Identifique requisitos para elementos finitos em malhas não estruturadas ou estruturadas.",
                                    "Estude geometrias comuns: triângulos e quadriláteros em 2D.",
                                    "Discuta convergência e precisão para problemas de escoamento potencial."
                                  ],
                                  "verification": "Resuma em um diagrama as diferenças entre malhas triangulares e quadrilaterais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Finite Element Procedures' de Bathe (cap. 5), slides de aula sobre EF 2D.",
                                  "tips": "Desenhe malhas manualmente para visualizar.",
                                  "learningObjective": "Compreender a base teórica para seleção de elementos.",
                                  "commonMistakes": "Confundir campo escalar com vetorial; ignorar compatibilidade de malha."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Elementos Triangulares Lineares (T3)",
                                  "subSteps": [
                                    "Defina o elemento T3: 3 nós, funções de forma lineares N_i = (a_i + b_i x + c_i y)/(2A).",
                                    "Calcule funções de forma em coordenadas baricêntricas.",
                                    "Implemente interpolação para φ^h em um triângulo exemplo.",
                                    "Analise propriedades: convergência linear, simplicidade em malhas irregulares.",
                                    "Teste em software: gere malha triangular e plote N_i."
                                  ],
                                  "verification": "Implemente e plote funções de forma N1, N2, N3 em um triângulo unitário.",
                                  "estimatedTime": "1 hora",
                                  "materials": "MATLAB ou Python (FEniCS/MeshPy), template de código para T3.",
                                  "tips": "Use coordenadas canônicas para simplificar cálculos.",
                                  "learningObjective": "Dominar definição e uso de elementos T3 para campos escalares.",
                                  "commonMistakes": "Erros em normalização das funções de forma (soma !=1); malhas distorcidas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar Elementos Quadriláteros Isoparamétricos (Q4)",
                                  "subSteps": [
                                    "Defina Q4: 4 nós, mapeamento isoparamétrico de [-1,1]x[-1,1] para geometria real.",
                                    "Derive funções de forma bilineares: N_i(ξ,η) = (1/4)(1±ξ)(1±η).",
                                    "Calcule jacobiano do mapeamento e verifique invertibilidade.",
                                    "Compare precisão com T3: melhor para malhas retangulares, risco de locking em distorções.",
                                    "Implemente em código: interpole φ^h em um quadrilátero distorcido."
                                  ],
                                  "verification": "Plote N_i em domínio mestre e domínio físico, confirmando partição de unidade.",
                                  "estimatedTime": "1 hora 15 minutos",
                                  "materials": "Software FreeFEM ou Gmsh para geração de malha Q4, notas de derivação.",
                                  "tips": "Verifique det(J) > 0 em todos os pontos para evitar elementos inválidos.",
                                  "learningObjective": "Compreender mapeamento isoparamétrico e funções bilineares em Q4.",
                                  "commonMistakes": "Jacobiano singular em elementos muito distorcidos; confusão ξ/η com x/y."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Desenvolver Critérios de Seleção e Aplicar em Problema de Escoamento Potencial",
                                  "subSteps": [
                                    "Liste critérios: geometria da malha, precisão desejada, custo computacional.",
                                    "Compare T3 vs Q4: T3 para malhas complexas, Q4 para alinhadas com fluxo.",
                                    "Selecione elemento para um domínio exemplo (e.g., airfoil 2D).",
                                    "Defina φ^h explicitamente com N_i escolhidas.",
                                    "Simule escoamento potencial e valide gradiente de φ."
                                  ],
                                  "verification": "Justifique seleção em relatório curto com tabela comparativa.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Exemplo de malha airfoil (Gmsh), solver EF simples em Python.",
                                  "tips": "Priorize T3 para robustez em geometrias irregulares.",
                                  "learningObjective": "Aplicar critérios para selecionar e definir elementos finitos.",
                                  "commonMistakes": "Selecionar Q4 em malhas altamente irregulares sem remapeamento."
                                }
                              ],
                              "practicalExample": "Para simular escoamento potencial em torno de um perfil aerodinâmico 2D: gere malha híbrida com T3 na borda de ataque (curva) e Q4 no campo distante; defina φ^h com N_i triangulares na região curva para capturar gradientes precisos.",
                              "finalVerifications": [
                                "Explicar verbalmente funções de forma para T3 e Q4.",
                                "Gerar e plotar malha 2D com ambos elementos.",
                                "Implementar interpolação φ^h e verificar soma N_i = 1.",
                                "Comparar precisão numérica em teste de convergência.",
                                "Justificar seleção para um problema específico de escoamento.",
                                "Identificar distorções em Q4 via det(J)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de funções de forma (erro <5%).",
                                "Correta implementação de mapeamento isoparamétrico.",
                                "Justificativa lógica de seleção baseada em critérios.",
                                "Qualidade da malha gerada (aspect ratio <5).",
                                "Validação numérica com erro de interpolação <1%.",
                                "Relatório claro com diagramas e comparações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Interpolação polinomial e análise numérica.",
                                "Física: Equações de potencial e gradientes em fluidos.",
                                "Computação: Programação numérica e visualização (Matplotlib/Gmsh).",
                                "Engenharia Aeronáutica: Modelagem de perfis aerodinâmicos."
                              ],
                              "realWorldApplication": "Seleção de elementos T3/Q4 é essencial em simulações CFD para otimizar aerodinâmica de aviões, reduzindo tempo de computação em 30-50% ao escolher adequadamente para malhas de hélices ou turbinas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.2.2"
                            ]
                          },
                          {
                            "id": "10.1.6.3.3.2",
                            "name": "Montar matriz de rigidez e vetor de carga",
                            "description": "Calcular a matriz de rigidez [K]^e = ∫ [B]^T [B] dΩ e vetor {f}^e = ∫ [N]^T g dΓ para um elemento, e assemblar globalmente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar funções de forma [N] e matriz de derivadas [B]",
                                  "subSteps": [
                                    "Defina as funções de forma lineares para um elemento triangular (N1 = 1 - ξ - η, N2 = ξ, N3 = η em coordenadas naturais).",
                                    "Compute as derivadas parciais das funções de forma em relação às coordenadas locais (∂N/∂ξ, ∂N/∂η).",
                                    "Transforme para coordenadas globais usando a matriz Jacobiana J: [B] = [∂N/∂x, ∂N/∂y] = (∂N/∂ξ ∂ξ/∂x + ...).",
                                    "Verifique que det(J) > 0 para elemento bem formado.",
                                    "Esboce um elemento triangular com nós numerados."
                                  ],
                                  "verification": "Derive manualmente [B] para um triângulo com vértices (0,0), (1,0), (0,1) e confirme simetria.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis",
                                    "Livro de Elementos Finitos (ex: Zienkiewicz)",
                                    "Calculadora simbólica (SymPy online)"
                                  ],
                                  "tips": "Sempre normalize coordenadas naturais (ξ, η) entre 0 e 1 para evitar erros de sinal.",
                                  "learningObjective": "Compreender a relação entre funções de forma e suas derivadas na formulação de elementos finitos.",
                                  "commonMistakes": [
                                    "Confundir derivadas locais com globais",
                                    "Esquecer inversa da Jacobiana",
                                    "Índices errados nos nós"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular e calcular a matriz de rigidez [K]^e",
                                  "subSteps": [
                                    "Escreva a integral [K]^e = ∫_Ω [B]^T [B] |det(J)| dΩ, assumindo material unitário.",
                                    "Escolha método de integração numérica: 1 ponto de Gauss para linear (ξ=1/3, η=1/3, peso=1/2).",
                                    "Avalie [B] no ponto de Gauss, compute [B]^T [B], multiplique por peso e |det(J)|.",
                                    "Some contribuições se múltiplos pontos (para quadráticos use 3-7 pontos).",
                                    "Armazene [K]^e 3x3 para elemento triangular linear."
                                  ],
                                  "verification": "Compute [K]^e para triângulo unitário e verifique simetria e diagonal positiva.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Planilha Excel ou MATLAB/Python para Gauss",
                                    "Tabela de pontos de Gauss",
                                    "Notebook Jupyter"
                                  ],
                                  "tips": "Use expansão simbólica inicial antes de numérico para validar.",
                                  "learningObjective": "Dominar o cálculo numérico da matriz de rigidez via integração de Gauss.",
                                  "commonMistakes": [
                                    "Peso de Gauss incorreto (use área total 1/2 para triângulo)",
                                    "Esquecer |det(J)|",
                                    "Matriz não simétrica por erro numérico"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o vetor de carga {f}^e",
                                  "subSteps": [
                                    "Identifique condições de Neumann: g(x,y) na fronteira Γ (ex: fluxo g=1).",
                                    "Parametrize a aresta do elemento (ex: aresta 1-2: N1=1-t, N2=t, N3=0, t=0 a 1).",
                                    "Compute integral de linha {f}^e = ∫_Γ [N]^T g ds, usando Gauss 2 pontos na aresta.",
                                    "Avalie comprimento ds = sqrt((dx/dt)^2 + (dy/dt)^2) dt.",
                                    "Some para todas arestas com g ≠ 0."
                                  ],
                                  "verification": "Para g=1 em uma aresta de comprimento 1, {f} deve distribuir carga igualmente nos nós.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código Python para integração 1D",
                                    "Diagrama do elemento com arestas rotuladas"
                                  ],
                                  "tips": "Integre analiticamente para g constante: f_i = g * L/2 para nós extremos.",
                                  "learningObjective": "Aplicar integração de contorno para vetores de carga em EF.",
                                  "commonMistakes": [
                                    "Usar dΩ em vez de dΓ",
                                    "Índices errados de [N] nas arestas",
                                    "Esquecer ds"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Assemblar matriz global [K] e vetor {F}",
                                  "subSteps": [
                                    "Defina malha: ex: 2 elementos triangulares compartilhando nó.",
                                    "Crie vetor de conectividade (ex: elem1: [1,2,3], elem2: [3,4,5]).",
                                    "Inicialize [K_global] n_dof x n_dof zero, some [K]^e nas posições do conectividade.",
                                    "Repita para {F}: some {f}^e nos graus de liberdade globais.",
                                    "Aplique condições de Dirichlet zerando linhas/colunas de nós fixos."
                                  ],
                                  "verification": "Verifique soma de linhas de [K] para nós internos ≈0 (propriedade de partição de unidade).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Script Python/MATLAB para assembly",
                                    "Diagrama da malha"
                                  ],
                                  "tips": "Use loops indexados por conectividade para evitar erros manuais.",
                                  "learningObjective": "Executar montagem global eficiente de contribuições elementares.",
                                  "commonMistakes": [
                                    "Sobrepor errado DOFs compartilhados",
                                    "Índices off-by-one",
                                    "Esquecer BCs"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e validar a montagem",
                                  "subSteps": [
                                    "Resolva sistema [K]{u} = {F} para potencial φ.",
                                    "Compute gradiente e fluxo para checar conservação.",
                                    "Compare com solução analítica (ex: φ=x em domínio unitário).",
                                    "Analise conduta de malha: refine e veja convergência.",
                                    "Debug: cheque simetria, SPD, normas."
                                  ],
                                  "verification": "Erro L2 < 5% vs analítica para malha grosseira.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Solver linear (SciPy)",
                                    "Solução exata conhecida"
                                  ],
                                  "tips": "Sempre plote malha e solução para inspeção visual.",
                                  "learningObjective": "Validar implementação de EF para problemas escalares.",
                                  "commonMistakes": [
                                    "Solver não convergindo por [K] mal condicionada",
                                    "BCs invertidas",
                                    "Unidades inconsistentes"
                                  ]
                                }
                              ],
                              "practicalExample": "Para escoamento potencial em triângulo unitário (0,0)-(1,0)-(0,1), use funções lineares. g=1 na hipotenusa. Compute [K]^e ≈ [[1.1547, -0.57735, -0.57735], ...], assembe com segundo triângulo adjacente, resolva com φ=0 nos nós base.",
                              "finalVerifications": [
                                "[K] é simétrica e definida positiva (autovalores >0).",
                                "Soma das funções de forma =1 em qualquer ponto interno.",
                                "Vetor {F} reflete integral total de g corretamente.",
                                "Solução converge com refinamento de malha.",
                                "Gradiente perpendicular à isolinhas de φ.",
                                "Conservação de fluxo: ∫ div(grad φ) =0."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos integrais numéricos (<1% erro vs analítico).",
                                "Correta transformação Jacobiana e det(J).",
                                "Assembly global sem vazamentos de DOFs.",
                                "Simetria e propriedades espectrais de [K].",
                                "Validação com caso teste conhecido.",
                                "Eficiência computacional (tempo <1s para 10 elems)."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Numérico: Quadratura de Gauss e integração adaptativa.",
                                "Álgebra Linear: Assembly de matrizes esparsas e solvers iterativos.",
                                "Programação: Implementação em Python (NumPy/SciPy) ou MATLAB.",
                                "Física: Equação de Laplace/Poisson em escoamento irrotacional.",
                                "Geometria Computacional: Mapeamento isoparamétrico."
                              ],
                              "realWorldApplication": "Simulação de escoamento potencial ao redor de perfis aerodinâmicos em design de asas de aviões, otimizando lift/drag via painéis de EF para previsão de velocidades e pressões."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.6.3.3.3",
                            "name": "Aplicar condições de contorno Dirichlet e Neumann",
                            "description": "Impor φ = φ̄ em nós Dirichlet modificando [K] e {f}, e fluxos normais ∂φ/∂n = v_n em Neumann via vetor de carga.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as condições de contorno Dirichlet e Neumann em MEF para campos escalares",
                                  "subSteps": [
                                    "Revise a formulação variacional do problema de campo escalar (ex: escoamento potencial ∇²φ=0).",
                                    "Identifique nós Dirichlet onde φ = φ̄ é prescrito (valor essencial).",
                                    "Identifique nós Neumann onde ∂φ/∂n = v_n é prescrito (fluxo natural).",
                                    "Estude como Dirichlet modifica o sistema global [K]{φ}={f}, enquanto Neumann afeta apenas {f}.",
                                    "Desenhe um malha simples com ambos os tipos de condições."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre Dirichlet e Neumann, com um diagrama de malha anotado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas de aula sobre MEF",
                                    "Livro 'Finite Element Procedures' de K.J. Bathe (capítulo sobre condições de contorno)",
                                    "Papel e caneta para esboços"
                                  ],
                                  "tips": "Lembre-se: Dirichlet impõe valores diretamente; Neumann integra fluxos sobre bordas.",
                                  "learningObjective": "Diferenciar conceitualmente as condições e suas implicações na formulação fraca.",
                                  "commonMistakes": "Confundir Dirichlet (valor) com Neumann (derivada); ignorar que Dirichlet remove graus de liberdade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar condições de contorno Dirichlet modificando [K] e {f}",
                                  "subSteps": [
                                    "Monte a matriz global de rigidez [K] e vetor {f} sem condições de contorno.",
                                    "Para cada nó Dirichlet i com φ_i = φ̄, defina a linha i de [K] como zero exceto K_{ii}=1, e f_i=φ̄.",
                                    "Elimine a coluna i de [K] e subtraia φ̄ * coluna i de {f} para nós acoplados.",
                                    "Implemente isso em código ou planilha para uma malha 1D simples (ex: barra com 5 nós).",
                                    "Verifique simetria e positivos definitos de [K] modificada."
                                  ],
                                  "verification": "Execute o sistema reduzido e confira se φ_i = φ̄ nos nós prescritos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software MATLAB/Python com NumPy/SciPy",
                                    "Exemplo de malha 1D gerada manualmente"
                                  ],
                                  "tips": "Use penalidade (multiplicador grande em K_{ii}) como alternativa para simplicidade inicial.",
                                  "learningObjective": "Modificar corretamente [K] e {f} para impor valores essenciais sem inconsistências.",
                                  "commonMistakes": "Esquecer de zerar a linha e coluna inteiras; não subtrair contribuições acopladas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar condições de contorno Neumann via contribuições ao vetor de carga {f}",
                                  "subSteps": [
                                    "Calcule o comprimento/areia da borda Neumann e o valor médio de v_n.",
                                    "Para cada elemento na borda, integre ∫ v_n * N_i ds no vetor de carga elemental {f^e}.",
                                    "Some {f^e} ao vetor global {f} nos graus de liberdade correspondentes.",
                                    "Implemente para uma malha 2D simples (ex: retângulo com fluxo injetado em uma face).",
                                    "Confira conservação: soma de fluxos Neumann deve igualar integral de fontes."
                                  ],
                                  "verification": "Compare o fluxo total integrado dos resultados com o prescrito.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código Python/MATLAB para montagem de elementos",
                                    "Malha 2D com Gmsh ou similar"
                                  ],
                                  "tips": "Para elementos lineares, ∫ v_n ds ≈ v_n * L_elemento / 2 por nó.",
                                  "learningObjective": "Incorporar fluxos naturais corretamente na montagem global sem alterar [K].",
                                  "commonMistakes": "Esquecer fator de Gauss ou comprimento da borda; somar em nós errados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar condições mistas, resolver sistema e validar resultados",
                                  "subSteps": [
                                    "Combine Dirichlet e Neumann em uma malha mista (ex: canal com velocidades em inlet/outlet).",
                                    "Resolva [K]{φ}={f} usando solver direto (ex: LU decomposition).",
                                    "Calcule fluxos pós-processados e compare com solução analítica.",
                                    "Visualize φ e gradientes com contour plots.",
                                    "Teste sensibilidade variando valores de contorno."
                                  ],
                                  "verification": "Erro L2 < 1% vs. solução exata; recuperação de fluxos em bordas coincide com v_n.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software FEniCS/Python para MEF completo",
                                    "Solução analítica de escoamento potencial"
                                  ],
                                  "tips": "Salve [K] e {f} antes e depois das modificações para depuração.",
                                  "learningObjective": "Aplicar condições mistas em problemas reais e validar numericamente.",
                                  "commonMistakes": "Resolver sistema sem reduzir DOFs Dirichlet; ignorar unidades em fluxos."
                                }
                              ],
                              "practicalExample": "Em um retângulo [0,2]x[0,1] para escoamento potencial: φ=0 em y=0 e y=1 (Dirichlet simétrico), φ=0 em x=0 (inlet), ∂φ/∂x=1 em x=2 (outlet Neumann). Solução esperada: φ=x, fluxo uniforme.",
                              "finalVerifications": [
                                "Nos nós Dirichlet, φ exato = φ̄ (erro < 1e-6).",
                                "Fluxo normal médio em borda Neumann = v_n prescrito.",
                                "Solução converge monotonicamente com refinamento de malha.",
                                "Energia variacional mínima (teste de stationary).",
                                "Gradientes recuperados consistentes com vizinhança.",
                                "Sem NaNs ou singularidades em [K]."
                              ],
                              "assessmentCriteria": [
                                "Correta modificação de [K] e {f} para Dirichlet (simetria preservada).",
                                "Integração precisa de Neumann em {f^e} (conservação de fluxo).",
                                "Solução numérica acurada vs. analítica (erro < 2%).",
                                "Código modular e comentado para reprodutibilidade.",
                                "Interpretação física dos resultados (ex: linhas de fluxo).",
                                "Tratamento robusto de malhas irregulares."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (sistemas lineares, condicionamento de matrizes).",
                                "Programação: Implementação numérica em Python/MATLAB (vetorização).",
                                "Física: Mecânica dos fluidos (escoamento irrotacional, conservação).",
                                "Engenharia Civil: Análise de difusão de calor ou potencial eletrostático.",
                                "Computação Científica: Pós-processamento e visualização (Matplotlib/Paraview)."
                              ],
                              "realWorldApplication": "Simulação de escoamento ao redor de perfis aerodinâmicos em projetos de aviões (CFD potencial), análise térmica em trocadores de calor industriais, ou modelagem de aquíferos em engenharia ambiental com fontes prescritas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.3.2"
                            ]
                          },
                          {
                            "id": "10.1.6.3.3.4",
                            "name": "Resolver e pós-processar resultados",
                            "description": "Resolver [K]{φ} = {f}, calcular velocidades v = ∇φ^h e validar com exemplos como escoamento ao redor de cilindro ou airfoil.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Resolver o sistema linear [K]{φ} = {f}",
                                  "subSteps": [
                                    "Importar a matriz de rigidez [K] e o vetor de forças {f} gerados na discretização.",
                                    "Verificar propriedades da matriz [K]: simetria, esparsidade e condicionamento.",
                                    "Aplicar solver linear direto (ex: LU) ou iterativo (ex: CG) dependendo do tamanho.",
                                    "Extrair a solução nodal {φ} e verificar resíduos ||[K]{φ} - {f}|| < tolerância.",
                                    "Salvar {φ} em formato acessível para pós-processamento."
                                  ],
                                  "verification": "Resíduo do sistema < 1e-6 e ausência de warnings de singularidade.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Software FEM (FEniCS, MATLAB, Python com SciPy)",
                                    "Matriz [K] e vetor {f} do passo de discretização",
                                    "Documentação do solver"
                                  ],
                                  "tips": "Para matrizes grandes, prefira solvers iterativos com pré-condicionadores como ILU.",
                                  "learningObjective": "Dominar a resolução eficiente de sistemas lineares esparsos em problemas de EF.",
                                  "commonMistakes": [
                                    "Ignorar esparsidade levando a alto custo computacional",
                                    "Não verificar condicionamento causando instabilidade numérica"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular velocidades v = ∇φ^h",
                                  "subSteps": [
                                    "Interpolação do potencial φ^h dentro de cada elemento usando funções de forma.",
                                    "Computar derivadas das funções de forma para obter matriz B = ∇N.",
                                    "Calcular gradiente nodal ou gaussiano: v = B {φ}_e por elemento.",
                                    "Projetar velocidades para pontos de interesse (nós, bordas, centroides).",
                                    "Verificar condições de contorno: |v| = 1 em borda livre de entrada/saída."
                                  ],
                                  "verification": "Velocidades na borda livre têm magnitude unitária e direção correta.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código de EF para gradientes",
                                    "Solução {φ} do step 1",
                                    "Malha de elementos"
                                  ],
                                  "tips": "Use pontos de Gauss para integração precisa em elementos curvos.",
                                  "learningObjective": "Implementar cálculo de gradientes em campos escalares discretizados.",
                                  "commonMistakes": [
                                    "Erro na orientação das derivadas locais vs globais",
                                    "Não mapear corretamente do espaço local para global"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Pós-processar resultados visualmente",
                                  "subSteps": [
                                    "Gerar contorno de φ e |v| em todo domínio.",
                                    "Plotar linhas de corrente (streamlines) a partir de v.",
                                    "Calcular coeficiente de pressão Cp = 1 - |v|^2 e plotar ao longo de superfícies.",
                                    "Exportar dados para ferramentas como Paraview ou Matplotlib.",
                                    "Analisar distribuições: stagnation points, separação de fluxo."
                                  ],
                                  "verification": "Visualizações mostram fluxo físico coerente sem anomalias.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Bibliotecas de visualização (Matplotlib, Paraview)",
                                    "Dados de v e φ"
                                  ],
                                  "tips": "Use escalas logarítmicas para velocidades em regiões de baixo gradiente.",
                                  "learningObjective": "Extrair e visualizar insights físicos de soluções numéricas.",
                                  "commonMistakes": [
                                    "Escalas inadequadas ocultando features importantes",
                                    "Streamlines mal espaçados distorcendo percepção"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar resultados com benchmarks",
                                  "subSteps": [
                                    "Comparar Cp ao longo de cilindro/airfoil com soluções analíticas (ex: d'Alembert).",
                                    "Calcular forças integrais (lift/drag) e comparar com literatura.",
                                    "Verificar convergência: refinar malha e observar redução de erro.",
                                    "Analisar sensibilidade a parâmetros (tolerância solver, tipo de elemento).",
                                    "Documentar discrepâncias e causas potenciais."
                                  ],
                                  "verification": "Erro em Cp max < 5% vs analítico; convergência observada.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Dados analíticos de benchmarks (cylinder/airfoil)",
                                    "Ferramentas de comparação (Excel, Python scripts)"
                                  ],
                                  "tips": "Use métricas L2 para quantificar erros globalmente.",
                                  "learningObjective": "Validar simulações numéricas contra referências confiáveis.",
                                  "commonMistakes": [
                                    "Comparação com dados errados",
                                    "Ignorar efeitos 2D vs 3D em validação"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente em Python/FEniCS o escoamento potencial ao redor de um cilindro de raio 1 em malha com 2000 triângulos: resolva [K]{φ}={f}, compute v=∇φ^h, plote Cp(θ) e valide contra fórmula analítica Cp=1-4sin²θ.",
                              "finalVerifications": [
                                "Resíduo do solver < 1e-8",
                                "Magnitude de v=1 na borda livre",
                                "Cp no stagnation point =1",
                                "Streamlines paralelos à entrada/saída",
                                "Erro L2 em Cp < 2% vs analítico",
                                "Tempo total de simulação < 5 min"
                              ],
                              "assessmentCriteria": [
                                "Precisão da solução numérica (erro <3%)",
                                "Eficiência computacional (uso de esparsidade)",
                                "Qualidade das visualizações (clareza e labels)",
                                "Validação quantitativa completa",
                                "Correção física dos resultados",
                                "Documentação de passos e decisões"
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Solvers lineares e análise de erro",
                                "Programação Computacional: Implementação em Python/SciPy",
                                "Física de Fluidos: Teoria de escoamento irrotacional",
                                "Visualização Científica: Ferramentas como Paraview",
                                "Engenharia Computacional: Validação de modelos EF"
                              ],
                              "realWorldApplication": "Design aerodinâmico de perfis de asas em aviação, otimização de turbinas eólicas e simulação de fluxos externos em veículos automotivos para reduzir arrasto."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.3.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.4",
                    "name": "Escoamento Compressível Não Viscoso",
                    "description": "Análise de fluxos supersônicos e potenciais compressíveis sem viscosidade usando equações de campo escalar.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.4.1",
                        "name": "Equações Governamentes para Escoamento Compressível Invíscido",
                        "description": "Apresentação das equações de Euler para fluxos supersônicos sem viscosidade, incluindo conservação de massa, momento e energia, e introdução ao potencial de velocidade para fluxos irrotacionais.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.1.1",
                            "name": "Derivar as equações de Euler",
                            "description": "Derivar as equações diferenciais de conservação de massa, momento e energia para fluxos compressíveis invíscidos, assumindo regime supersônico e ausência de viscosidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estabelecer os Princípios de Conservação em Forma Integral",
                                  "subSteps": [
                                    "Defina um volume de controle fixo V arbitrário no domínio de fluxo compressível.",
                                    "Escreva o balanço integral de massa: d/dt ∫_V ρ dV + ∫_S ρ \\vec{u} · d\\vec{A} = 0.",
                                    "Formule o balanço de momento linear: d/dt ∫_V ρ \\vec{u} dV + ∫_S (ρ \\vec{u} (\\vec{u} · d\\vec{A}) + \\vec{t} · d\\vec{A}) = 0, onde \\vec{t} = -p \\mathbf{I} (inviscido).",
                                    "Escreva o balanço de energia total: d/dt ∫_V ρ E dV + ∫_S ρ E \\vec{u} · d\\vec{A} + ∫_S p \\vec{u} · d\\vec{A} = 0, com E = e + |\\vec{u}|^2/2.",
                                    "Liste as hipóteses: fluxo invíscido, compressível, regime supersônico, sem fontes de massa/momento/energia."
                                  ],
                                  "verification": "Escreva corretamente as três equações integrais de conservação sem erros de notação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de Dinâmica dos Fluidos (ex: Anderson 'Computational Fluid Dynamics')",
                                    "Caderno, caneta e calculadora simbólica opcional (SymPy)"
                                  ],
                                  "tips": "Mantenha notação vetorial consistente (ex: \\vec{u} para velocidade) e defina todas as variáveis claramente.",
                                  "learningObjective": "Compreender as formas integrais das leis de conservação como base para derivações diferenciais.",
                                  "commonMistakes": [
                                    "Incluir termos viscosos prematuramente.",
                                    "Confundir energia total E com energia interna e.",
                                    "Esquecer o termo de pressão no fluxo de energia."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Equação de Conservação de Massa (Continuidade)",
                                  "subSteps": [
                                    "Aplique o teorema da divergência (Gauss) à superfície: ∫_S ρ \\vec{u} · d\\vec{A} = ∫_V ∇·(ρ \\vec{u}) dV.",
                                    "Transforme a equação integral em diferencial: ∂ρ/∂t + ∇·(ρ \\vec{u}) = 0.",
                                    "Verifique para caso estacionário: ∇·(ρ \\vec{u}) = 0.",
                                    "Discuta implicações para fluxo compressível supersônico: variações densidade significativas.",
                                    "Expanda em coordenadas cartesianas para validação: ∂ρ/∂t + ∂(ρ u)/∂x + ∂(ρ v)/∂y + ∂(ρ w)/∂z = 0."
                                  ],
                                  "verification": "Derive e escreva a equação ∂ρ/∂t + ∇·(ρ \\vec{u}) = 0 a partir da integral.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Referência: Capítulo de leis de conservação em livro de fluidos"
                                  ],
                                  "tips": "Visualize o volume de controle encolhendo para um ponto para entender a transição integral-diferencial.",
                                  "learningObjective": "Dominar a derivação da equação de continuidade para fluxos compressíveis.",
                                  "commonMistakes": [
                                    "Esquecer o termo transitório ∂ρ/∂t.",
                                    "Confundir ∇·(ρ \\vec{u}) com ρ ∇·\\vec{u}."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar as Equações de Conservação de Momento",
                                  "subSteps": [
                                    "Aplique o teorema da divergência ao termo convectivo: ∫_S ρ \\vec{u} ⊗ \\vec{u} · d\\vec{A} = ∫_V ∇·(ρ \\vec{u} ⊗ \\vec{u}) dV.",
                                    "Trate o tensor de tensão: para invíscido, ∫_S -p \\mathbf{I} · d\\vec{A} = ∫_V -∇p dV.",
                                    "Obtenha a forma diferencial: ∂(ρ \\vec{u})/∂t + ∇·(ρ \\vec{u} ⊗ \\vec{u} + p \\mathbf{I}) = 0.",
                                    "Expanda para componentes (x,y,z) e verifique ausência de viscosidade.",
                                    "Discuta regime supersônico: inércia domina, ondas acústicas não propagam upstream."
                                  ],
                                  "verification": "Escreva as três equações escalares de momento corretamente sem termos viscosos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software simbólico para vetores (ex: Mathematica)",
                                    "Tabela de identidades vetoriais"
                                  ],
                                  "tips": "Lembre-se que \\vec{u} ⊗ \\vec{u} é o tensor convectivo; pratique com componentes 2D primeiro.",
                                  "learningObjective": "Derivar corretamente as equações de Euler para momento em fluxos invíscidos.",
                                  "commonMistakes": [
                                    "Incluir tensor viscoso τ.",
                                    "Erro na divergência do tensor: ∇·(ρ u u) ≠ ρ u ∇·u."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar a Equação de Conservação de Energia",
                                  "subSteps": [
                                    "Defina energia total por unidade de massa E = e + |\\vec{u}|^2/2, onde e é energia interna.",
                                    "Aplique divergência ao fluxo convectivo: ∫_S ρ E \\vec{u} · d\\vec{A} = ∫_V ∇·(ρ E \\vec{u}) dV.",
                                    "Adicione trabalho de pressão: ∫_S p \\vec{u} · d\\vec{A} = ∫_V ∇·(p \\vec{u}) dV.",
                                    "Obtenha: ∂(ρ E)/∂t + ∇·(ρ E \\vec{u} + p \\vec{u}) = 0.",
                                    "Conecte com termodinâmica: para perfeito gás, e = c_v T, mas mantenha geral para compressível."
                                  ],
                                  "verification": "Derive e valide a equação de energia total em forma conservativa.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Gráficos de energia em fluxos supersônicos",
                                    "Livro de termodinâmica dos fluidos"
                                  ],
                                  "tips": "Verifique dimensionalmente: todos termos têm unidades de energia por volume por tempo.",
                                  "learningObjective": "Compreender a inclusão correta de energia cinética e interna nas equações de Euler.",
                                  "commonMistakes": [
                                    "Esquecer o termo p \\vec{u} (trabalho de pressão).",
                                    "Confundir E com h (entalpia)."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Formular as Equações de Euler Completas e Considerações Supersônicas",
                                  "subSteps": [
                                    "Liste o conjunto fechado: continuidade, momento (3), energia (1) – 5 equações para 5 variáveis (ρ, u,v,w, p ou E).",
                                    "Escreva em forma vetorial conservativa: ∂\\vec{U}/∂t + ∇·\\vec{F} = 0.",
                                    "Discuta regime supersônico: M > 1, hiperbólico, condições de contorno upstream/downstream.",
                                    "Verifique consistência: somar momento · u dá energia mecânica.",
                                    "Teste em 1D: reduza para fluxo supersônico em duto."
                                  ],
                                  "verification": "Escreva o sistema completo de equações de Euler e identifique propriedades hiperbólicas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exemplos numéricos de CFD",
                                    "Artigo sobre fluxos supersônicos"
                                  ],
                                  "tips": "Feche o sistema com equação de estado (ex: gás perfeito p = (γ-1)ρ(e - |u|^2/2)).",
                                  "learningObjective": "Integrar as derivações em um sistema coeso e reconhecer aplicações supersônicas.",
                                  "commonMistakes": [
                                    "Não mencionar fechamento termodinâmico.",
                                    "Confundir regime supersônico com subsônico (elíptico)."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um bocal de Laval para fluxo supersônico 1D, derive as equações de Euler reduzidas: ∂ρ/∂t + ∂(ρu)/∂x = 0; ∂(ρu)/∂t + ∂(ρu² + p)/∂x = 0; ∂(ρE)/∂t + ∂(u(ρE + p))/∂x = 0. Simule numéricamente com M=2 na garganta para validar aceleração a M>1.",
                              "finalVerifications": [
                                "Escreve corretamente o sistema de 5 equações de Euler em forma conservativa.",
                                "Identifica ausência de termos viscosos e difusivos.",
                                "Explica transição integral para diferencial via teorema de Gauss.",
                                "Valida dimensionalmente todas as equações.",
                                "Discute implicações para fluxo supersônico (hiperbólico, ondas de choque).",
                                "Reduz corretamente para caso 1D unidimensional."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na aplicação do teorema da divergência (100%).",
                                "Correta manipulação de tensores e vetores convectivos (90-100%).",
                                "Ausência de termos viscosos ou dissipativos nas derivações (essencial).",
                                "Integração coerente de energia total e fechamento termodinâmico (80-100%).",
                                "Reconhecimento de hipóteses (inviscido, compressível, supersônico) (70-100%).",
                                "Clareza na notação e verificações intermediárias (rubrica qualitativa)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo vetorial, teorema da divergência e equações diferenciais parciais hiperbólicas.",
                                "Física: Termodinâmica de gases compressíveis e conservação de quantidade de movimento.",
                                "Engenharia Aeronáutica: Modelagem de fluxos em asas supersônicas e bocais.",
                                "Computação: Base para métodos de elementos finitos e CFD (ex: solvers de Euler)."
                              ],
                              "realWorldApplication": "As equações de Euler são usadas no design de aeronaves supersônicas como o SR-71 Blackbird, simulando fluxos ao redor de asas delta em M>2 via CFD, prevendo ondas de choque e otimização aerodinâmica para eficiência em voos hipersônicos e reentrada de veículos espaciais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.2",
                            "name": "Introduzir o potencial de velocidade",
                            "description": "Explicar a condição de irrotacionalidade (curl V = 0) e derivar o potencial de velocidade φ tal que V = grad φ para fluxos sem vórtices.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Irrotacionalidade em Fluxos",
                                  "subSteps": [
                                    "Defina o vetor velocidade V em um escoamento.",
                                    "Explique o operador curl (rotacional) e seu significado físico: curl V ≠ 0 indica presença de vórtices.",
                                    "Discuta fluxos irrotacionais onde curl V = 0 em todo o domínio.",
                                    "Relacione irrotacionalidade com ausência de viscosidade em escoamentos invíscidos.",
                                    "Identifique condições iniciais para fluxos compressíveis não viscosos."
                                  ],
                                  "verification": "Resolva exercícios simples calculando curl V para campos vetoriais dados e confirme quando é zero.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Mecânica dos Fluidos (ex: Anderson ou White)",
                                    "Calculadora simbólica (Mathematica/MATLAB)"
                                  ],
                                  "tips": "Visualize curl com setas de rotação em diagramas 2D para intuição física.",
                                  "learningObjective": "Entender que irrotacionalidade implica ausência de rotação local no fluido.",
                                  "commonMistakes": "Confundir curl com divergência; lembrar que curl mede rotação, não expansão."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Propriedades Matemáticas do Gradiente e Potencial Escalar",
                                  "subSteps": [
                                    "Revise a definição do gradiente de um escalar φ: grad φ.",
                                    "Prove que curl(grad φ) = 0 para qualquer escalar φ diferenciável.",
                                    "Discuta o teorema do gradiente: todo campo irrotacional é gradiente de um potencial.",
                                    "Introduza φ tal que V = grad φ, chamado potencial de velocidade.",
                                    "Verifique dimensionalmente: [φ] = velocidade × comprimento."
                                  ],
                                  "verification": "Demonstre analiticamente que curl(grad φ) = 0 usando identidades vetoriais.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Notas de Cálculo Vetorial",
                                    "Software de álgebra simbólica"
                                  ],
                                  "tips": "Use coordenadas cartesianas para derivações iniciais antes de generalizar.",
                                  "learningObjective": "Reconhecer que campos irrotacionais admitem representação por potencial escalar.",
                                  "commonMistakes": "Esquecer que o domínio deve ser simplesmente conexo para existência única de φ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivação Formal do Potencial de Velocidade",
                                  "subSteps": [
                                    "Parta de curl V = 0 e integre V ao longo de um caminho c: Δφ = ∫_c V · dr.",
                                    "Mostre independência do caminho devido a irrotacionalidade (Stokes' theorem).",
                                    "Defina φ(P) = -∫_{P0}^P V · dr + φ(P0), com P0 referência.",
                                    "Derive V = grad φ diferenciando φ.",
                                    "Aplique às equações de Euler para escoamento invíscido compressível."
                                  ],
                                  "verification": "Derive φ para um campo V conhecido irrotacional e verifique V = grad φ numericamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Papel e lápis para derivações",
                                    "MATLAB para validação numérica"
                                  ],
                                  "tips": "Escolha P0 onde φ=0 para simplificar cálculos.",
                                  "learningObjective": "Derivar o potencial φ a partir da condição irrotacional.",
                                  "commonMistakes": "Sinal errado na definição de φ; convenção comum é V = grad φ ou -grad φ, padronize."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicação e Verificação em Fluxos Sem Vórtices",
                                  "subSteps": [
                                    "Substitua V = grad φ nas equações de continuidade e momentum para fluxo compressível.",
                                    "Resolva a equação de Laplace para φ em casos incompressíveis (div V = 0 → ∇²φ = 0).",
                                    "Discuta limitações: não aplica a fluxos com choques ou viscosidade.",
                                    "Implemente numericamente em um solver simples de elementos finitos.",
                                    "Compare soluções potenciais com soluções diretas de V."
                                  ],
                                  "verification": "Simule um fluxo ao redor de um cilindro e confirme curl V ≈ 0 fora da camada limite.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Software FEA como ANSYS ou código Python customizado",
                                    "Exemplos de benchmark em PDF"
                                  ],
                                  "tips": "Comece com 2D para depuração antes de 3D.",
                                  "learningObjective": "Aplicar potencial de velocidade em problemas de escoamento irrotacional.",
                                  "commonMistakes": "Ignorar compressibilidade; para M>0.3, usar equações não-lineares."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integração com Elementos Finitos para Campos Escalares",
                                  "subSteps": [
                                    "Formule o problema variacional para ∇²φ = f usando potencial.",
                                    "Gere malha e funções de forma para discretização.",
                                    "Monte matriz de rigidez K e vetor de carga F para φ.",
                                    "Resolva sistema Kφ = F e recupere V = grad φ.",
                                    "Valide com condições de contorno de Dirichlet/Neumann."
                                  ],
                                  "verification": "Compare solução EF com solução analítica exata para fluxo uniforme.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código de Elementos Finitos em Python (FEniCS ou similar)",
                                    "Tutoriais online de EF"
                                  ],
                                  "tips": "Use malhas estruturadas inicialmente para convergência rápida.",
                                  "learningObjective": "Implementar potencial de velocidade em método de elementos finitos.",
                                  "commonMistakes": "Erros em condições de contorno: φ constante em superfícies impermeáveis."
                                }
                              ],
                              "practicalExample": "Considere um fluxo irrotacional uniforme V = (U, 0, 0). Defina φ = U x, então grad φ = (U, 0, 0) = V e curl V = 0. Em elementos finitos, resolva ∇²φ = 0 com φ = U x na entrada, simulando escoamento em duto.",
                              "finalVerifications": [
                                "Calcule curl(grad φ) e confirme = 0.",
                                "Integre V · dr ao longo de caminhos fechados e verifique = 0.",
                                "Recupere V de φ via gradiente e compare com original.",
                                "Aplique em equação de Bernoulli linearizada.",
                                "Simule numericamente e cheque resíduos de curl V < 1e-6.",
                                "Discuta falhas em domínios multi-conexos (ex: anel)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de V = grad φ (sem erros algébricos).",
                                "Compreensão física de irrotacionalidade vs. solenoidalidade.",
                                "Capacidade de formular problema EF para φ corretamente.",
                                "Validação numérica com erros < 5%.",
                                "Explicação clara de limitações (viscosidade, choques).",
                                "Identificação de aplicações reais em aerodinâmica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Vetorial e Teorema de Stokes.",
                                "Física: Potencial Eletrostático (E = -grad V, análogo).",
                                "Engenharia Aeroespacial: Projeto de perfis aerodinâmicos.",
                                "Computação: Métodos Numéricos e Programação Científica.",
                                "Física Computacional: Simulações de CFD."
                              ],
                              "realWorldApplication": "Em design de aviões, o potencial de velocidade modela fluxo irrotacional ao redor de asas para calcular coeficientes de sustentação sem simular turbulência completa, acelerando iterações em otimização aerodinâmica via elementos finitos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.3",
                            "name": "Linearizar para pequenos distúrbios",
                            "description": "Aplicar a linearização das equações de Euler para perturbações pequenas, obtendo a equação de Prandtl-Glauert para potenciais compressíveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar as Equações de Euler para Escoamento Compressível Invíscido",
                                  "subSteps": [
                                    "Estude as equações de conservação em forma integral e diferencial para massa, momento e energia.",
                                    "Identifique as variáveis primitivas: densidade ρ, velocidade u, pressão p, energia total e.",
                                    "Escreva as equações na forma conservativa e não-conservativa.",
                                    "Discuta as hipóteses: invíscido, compressível, sem choques.",
                                    "Revise a relação de equação de estado para gás perfeito: p = (γ-1)ρe."
                                  ],
                                  "verification": "Escreva corretamente todas as cinco equações de Euler em 3D e explique cada termo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de texto de dinâmica dos fluidos (ex: Anderson 'Fundamentals of Aerodynamics'), caderno de anotações, calculadora simbólica como SymPy.",
                                  "tips": "Use notação vetorial consistente para simplificar derivações futuras.",
                                  "learningObjective": "Compreender a forma matemática completa das equações governantes antes da linearização.",
                                  "commonMistakes": "Confundir equações incompressíveis com compressíveis; esquecer o termo fonte na energia."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Decompor Variáveis em Estado Base e Perturbações Pequenas",
                                  "subSteps": [
                                    "Defina o estado base uniforme: ρ₀, u₀ = (U∞, 0, 0), p₀ constantes.",
                                    "Introduza perturbações: ρ = ρ₀ + ρ', u = u₀ + u', p = p₀ + p', com |ρ'| << ρ₀ etc.",
                                    "Especifique a condição de freestream: perturbações tendem a zero no infinito.",
                                    "Calcule Mach number M∞ = U∞ / a₀, onde a₀ é velocidade do som base.",
                                    "Verifique linearidade: produtos de perturbações são desprezíveis (ordem ε²)."
                                  ],
                                  "verification": "Esboce a decomposição para todas as variáveis e justifique os termos desprezíveis.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel quadriculado, software de álgebra simbólica (MATLAB/SymPy), notas de aula.",
                                  "tips": "Sempre normalize perturbações pela magnitude base para visualizar ordens de grandeza.",
                                  "learningObjective": "Dominar a expansão perturbativa fundamental para linearização.",
                                  "commonMistakes": "Esquecer perturbação na energia interna; assumir u₀ = 0 incorretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Linearização às Equações Individuais",
                                  "subSteps": [
                                    "Linearize a equação de continuidade: ∂ρ'/∂t + u₀ · ∇ρ' + ρ₀ ∇ · u' = 0.",
                                    "Para momento: ρ₀ (∂u'/∂t + u₀ · ∇u') + ρ' u₀ · ∇u₀ + ∇p' = 0 (simplifique para base uniforme).",
                                    "Linearize energia: ∂p'/∂t + u₀ · ∇p' + γ p₀ ∇ · u' = 0.",
                                    "Use isentrópico: p'/p₀ = γ ρ'/ρ₀ para eliminar energia.",
                                    "Verifique consistência entre equações lineares resultantes."
                                  ],
                                  "verification": "Derive as três equações lineares perturbadas e mostre que são consistentes.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Lápis, borracha, quadro branco ou tablet gráfico, referência de aerodinâmica.",
                                  "tips": "Substitua passo a passo e descarte termos quadráticos imediatamente.",
                                  "learningObjective": "Executar linearização term a term nas equações de Euler.",
                                  "commonMistakes": "Manter termos ρ' ∇u₀ quando ∇u₀=0; erro no coeficiente γ na energia."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar a Equação de Prandtl-Glauert para o Potencial de Velocidade",
                                  "subSteps": [
                                    "Introduza potencial φ tal que u' = ∇φ (irrotacionalidade das perturbações).",
                                    "Substitua nas equações lineares para obter ∂²φ/∂t² - 2U∞ ∂²φ/∂x∂t + a² β² ∇²φ = 0, onde β²=1-M∞².",
                                    "Simplifique para estado estacionário: β² (∂²φ/∂x² + ∂²φ/∂y² + ∂²φ/∂z²) = 0.",
                                    "Discuta transformação de Prandtl-Glauert: alongar coordenadas transversais por 1/β.",
                                    "Verifique limite incompressível (M→0, β→1)."
                                  ],
                                  "verification": "Escreva a equação final de Prandtl-Glauert e resolva para um caso simples como placa plana.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software numérico (ex: MATLAB para plotar potencial), exemplos resolvidos de livros.",
                                  "tips": "Lembre-se: a² = γ p₀ / ρ₀; β corrige compressibilidade.",
                                  "learningObjective": "Obter e interpretar a equação unificada para potenciais compressíveis.",
                                  "commonMistakes": "Erro no sinal de convecção; confundir φ com ψ (vórtice)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Aplicar a Linearização em um Exemplo Prático",
                                  "subSteps": [
                                    "Aplique a uma airfoil simétrica em ângulo de ataque pequeno.",
                                    "Calcule coeficiente de pressão Cp usando linearização.",
                                    "Compare com solução incompressível e discuta efeito compressibilidade.",
                                    "Implemente numericamente em grade simples.",
                                    "Analise validade: verifique ||u'|| << U∞."
                                  ],
                                  "verification": "Gere gráfico de Cp vs x/c e compare com teoria exata para M=0.3.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "MATLAB/Python com NumPy/Meshgrid, dados de airfoil (NACA0012).",
                                  "tips": "Use BCs: φ=0 freestream, ∂φ/∂n = U∞ α no corpo.",
                                  "learningObjective": "Aplicar a teoria em um problema realista e validar.",
                                  "commonMistakes": "Condições de contorno erradas; não normalizar perturbações."
                                }
                              ],
                              "practicalExample": "Para uma airfoil NACA0012 em Mach 0.3 e α=2°, linearize as equações de Euler, resolva a equação de Prandtl-Glauert via painéis, e calcule Cp mostrando aumento devido à compressibilidade em pontos de sucção.",
                              "finalVerifications": [
                                "Equações de Euler lineares derivadas corretamente sem termos quadráticos.",
                                "Equação de Prandtl-Glauert escrita na forma potencial com β²=1-M².",
                                "Exemplo numérico converge e perturbações <5% do freestream.",
                                "Transformação Prandtl-Glauert aplicada corretamente para 2D.",
                                "Limite M→0 recupera equação de Laplace incompressível.",
                                "Validação com Cp plotado e discussão de erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na decomposição perturbativa (90% dos termos corretos).",
                                "Derivação completa e sem erros algébricos na linearização.",
                                "Interpretação física correta do papel de β e M∞.",
                                "Implementação numérica funcional com visualizações.",
                                "Análise de validade e limitações da aproximação.",
                                "Clareza na documentação de passos e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise vetorial, expansão em séries de Taylor, equações diferenciais elípticas.",
                                "Física: Termodinâmica de gases ideais, conservação de massa/momento/energia.",
                                "Computação: Programação numérica (FDM/Painel methods), álgebra simbólica.",
                                "Engenharia Aeronáutica: Projeto de perfis, análise transônica.",
                                "Elementos Finitos: Base para discretização de problemas lineares compressíveis."
                              ],
                              "realWorldApplication": "Usado no design preliminar de asas de aviões comerciais (ex: Boeing 737) para prever lift/drag em regimes subsonicos compressíveis, reduzindo custos de CFD full-Euler e tunel de vento."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.2",
                        "name": "Formulação do Potencial Compressível",
                        "description": "Desenvolvimento da equação governante não linear para o potencial compressível em fluxos supersônicos, incluindo relações termodinâmicas para gases perfeitos.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.2.1",
                            "name": "Derivar a equação do potencial compressível",
                            "description": "Partir das equações de Euler irrotacionais e derivar a equação elíptica ou hiperbólica para φ em função do número de Mach local.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar as equações de Euler para escoamento irrotacional",
                                  "subSteps": [
                                    "Lembre-se das equações de conservação de massa e momento para fluidos invíscidos: equação de continuidade e equações de Euler.",
                                    "Especifique para escoamento irrotacional: ∇ × V = 0, onde V é o vetor velocidade.",
                                    "Escreva as equações de Euler em forma conservativa: ∂ρ/∂t + ∇·(ρV) = 0 e ∂(ρV)/∂t + ∇·(ρV ⊗ V) + ∇p = 0.",
                                    "Assuma escoamento estacionário e isentrópico para simplificação.",
                                    "Expresse a equação de estado: p = p(ρ) para gás perfeito, com relação de Bernoulli adaptada."
                                  ],
                                  "verification": "Escreva corretamente as equações de Euler irrotacionais estacionárias em 3D.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Dinâmica dos Fluidos (ex: Anderson), caderno de anotações, calculadora simbólica (Mathematica ou SymPy)"
                                  ],
                                  "tips": "Comece com as formas diferenciais antes de ir para conservativas para clareza conceitual.",
                                  "learningObjective": "Entender as equações fundamentais do escoamento compressível irrotacional.",
                                  "commonMistakes": [
                                    "Confundir viscoso com invíscido",
                                    "Esquecer a condição irrotacional ∇ × V = 0",
                                    "Ignorar a dependência compressível de ρ em V"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o potencial de velocidade φ",
                                  "subSteps": [
                                    "Defina V = ∇φ devido à irrotacionalidade.",
                                    "Substitua V nas equações de continuidade: ∇·(ρ ∇φ) = 0.",
                                    "Para escoamento estacionário, a equação de momento de Euler se reduz à integral de Bernoulli: H = ½|V|² + h(ρ) = constante, onde h é entalpia.",
                                    "Expresse ρ em termos de |∇φ| usando a relação isentrópica.",
                                    "Verifique a consistência dimensional de φ (unidades de velocidade × comprimento)."
                                  ],
                                  "verification": "Derive a forma simplificada ∇·(ρ ∇φ) = 0 a partir da continuidade.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Notas de aula sobre potencial de velocidade",
                                    "Software simbólico para manipulação de vetores",
                                    "Quadro branco para desenhos"
                                  ],
                                  "tips": "Use coordenadas cartesianas inicialmente para evitar confusões com sistemas curvilíneos.",
                                  "learningObjective": "Aplicar a condição irrotacional para introduzir o potencial escalar φ.",
                                  "commonMistakes": [
                                    "Esquecer que ρ depende de |∇φ|",
                                    "Confundir ∇φ com V em não-estacionário",
                                    "Não especificar isentrópico"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a equação elíptica/hiperbólica para φ",
                                  "subSteps": [
                                    "Expanda ρ em série de Taylor ao redor do escoamento de referência: ρ = ρ∞ [1 + (γ-1)/2 M∞² (½|∇φ|² / a∞² - 1/2) + ...] (linearização Prandtl-Glauert).",
                                    "Substitua na continuidade: ∇·(ρ ∇φ) = 0 leva a ∇²φ - (ρ_x / ρ) ∂²φ/∂x² + termos não-lineares = 0.",
                                    "Para forma não-linear completa: ∂/∂x_i (ρ ∂φ/∂x_i) = 0, com ρ = ρ(|∇φ|).",
                                    "Identifique coeficientes da PDE resultante.",
                                    "Discuta linearização para baixos Mach."
                                  ],
                                  "verification": "Escreva a equação ∇·(ρ(|∇φ|) ∇φ) = 0 explicitamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Referência: 'Computational Fluid Dynamics' de Anderson",
                                    "SymPy ou Maple para derivação simbólica",
                                    "Papel milimetrado"
                                  ],
                                  "tips": "Mantenha notação consistente; use índices para generalidade em 3D.",
                                  "learningObjective": "Obter a equação governante para o potencial compressível.",
                                  "commonMistakes": [
                                    "Erro no Jacobiano da divergência",
                                    "Linearizar prematuramente sem justificar",
                                    "Confundir Mach local com Mach livre"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar o caráter da equação baseado no número de Mach local",
                                  "subSteps": [
                                    "Na forma linearizada: (1 - M²) ∂²φ/∂x² + ∂²φ/∂y² + ∂²φ/∂z² = 0.",
                                    "Classifique como elíptica (M < 1, subsonico) ou hiperbólica (M > 1, supersônico).",
                                    "Discuta Mach local M = |V|/a, onde a é velocidade do som local.",
                                    "Verifique limites: M→0 recupera Laplace (incompressível).",
                                    "Discuta implicações para métodos numéricos em EF."
                                  ],
                                  "verification": "Classifique corretamente o tipo da PDE para M=0.8 e M=1.2.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Tabela de classificação de PDEs",
                                    "Exemplos numéricos simples em Python/MATLAB"
                                  ],
                                  "tips": "Visualize com gráficos de onda: elíptico propaga em todas direções, hiperbólico downstream.",
                                  "learningObjective": "Determinar o tipo da equação e suas implicações.",
                                  "commonMistakes": [
                                    "Usar Mach livre em vez de local",
                                    "Confundir elíptico com parabólico",
                                    "Ignorar não-linearidades em altas velocidades"
                                  ]
                                }
                              ],
                              "practicalExample": "Derive a equação para escoamento supersônico sobre um diamante wedge (ângulo 10°), computando numericamente os coeficientes para M∞=2.0 e verificando transição hiperbólica.",
                              "finalVerifications": [
                                "Escreve corretamente ∇·(ρ(|∇φ|) ∇φ) = 0.",
                                "Lineariza para Prandtl-Glauert e identifica fator β = √(1-M²).",
                                "Classifica o tipo da PDE baseado em M local.",
                                "Aplica Bernoulli para ρ em termos de φ.",
                                "Discute validade para escoamento irrotacional compressível."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação passo a passo (sem erros algébricos).",
                                "Correta identificação de hipóteses (irrotacional, invíscido, isentrópico).",
                                "Explicação clara do caráter elíptico/hiperbólico com Mach.",
                                "Uso apropriado de linearização e discussão de não-linearidades.",
                                "Conexão com formulação EF para problemas de campo escalar."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Classificação e solução de PDEs elípticas/hiperbólicas.",
                                "Física: Termodinâmica de gases compressíveis e ondas de choque.",
                                "Computação: Pré-processamento para solvers de EF em CFD.",
                                "Engenharia Aeronáutica: Análise de perfis aerodinâmicos."
                              ],
                              "realWorldApplication": "Desenvolvimento de software para simulação de escoamento transônico em asas de aviões comerciais, otimizando eficiência aerodinâmica em projetos da Boeing ou Airbus."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.1.2"
                            ]
                          },
                          {
                            "id": "10.1.6.4.2.2",
                            "name": "Aplicar condições termodinâmicas",
                            "description": "Incorporar a equação de estado para gases perfeitos e a relação de isentropia para expressar densidade em termos de φ e suas derivadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a equação de estado para gases perfeitos",
                                  "subSteps": [
                                    "Estude a forma da equação de estado: p = ρ R T, onde p é pressão, ρ densidade, R constante específica do gás e T temperatura absoluta.",
                                    "Derive a relação entre pressão e densidade para processos isentrópicos: p / ρ^γ = constante, com γ = Cp/Cv.",
                                    "Identifique as variáveis termodinâmicas relevantes no contexto de escoamento: pressão estática, densidade e entalpia.",
                                    "Pratique convertendo entre unidades consistentes (SI: Pa, kg/m³, J/kg·K).",
                                    "Anote as hipóteses: gás perfeito, calores específicos constantes."
                                  ],
                                  "verification": "Resolva 3 problemas simples de conversão p-ρ-T e confirme resultados com calculadora ou software.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de termodinâmica (ex: Cengel & Boles), calculadora, notas de aula.",
                                  "tips": "Sempre verifique as unidades antes de calcular para evitar erros dimensionais.",
                                  "learningObjective": "Compreender e aplicar a equação de estado ideal para relacionar p, ρ e T.",
                                  "commonMistakes": "Confundir R universal com R específica do gás; usar γ incorreto para ar (γ=1.4)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a relação de isentrópica em escoamentos",
                                  "subSteps": [
                                    "Defina isentropia: ds=0, levando a p ρ^{-γ} = constante.",
                                    "Expresse temperatura e entalpia em termos de ρ: T ~ ρ^{γ-1}, h ~ ρ^{γ-1}.",
                                    "Relacione com velocidade via equação de Bernoulli compressível: h + (1/2)|∇φ|^2 + gz = constante.",
                                    "Integre as relações termodinâmicas ao longo de linhas de corrente.",
                                    "Calcule variações relativas: δρ/ρ = f(Mach, ∇φ)."
                                  ],
                                  "verification": "Derive analiticamente ρ/ρ∞ = [1 + ((γ-1)/2) M∞² ( |∇φ|/a∞² - 1 ) ]^{1/(γ-1)} para escoamento isentrópico.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel e lápis para derivações, software simbólico como Mathematica ou SymPy.",
                                  "tips": "Use aproximações lineares para pequenas perturbações em Mach baixo para validar.",
                                  "learningObjective": "Dominar a relação isentrópica para expressar variáveis termodinâmicas em escoamentos compressíveis.",
                                  "commonMistakes": "Esquecer o fator (γ-1)/2 na equação de Bernoulli compressível; confundir pressão total com estática."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar condições termodinâmicas com o potencial φ",
                                  "subSteps": [
                                    "Defina o potencial de velocidade φ: v = ∇φ para escoamento irrotacional não viscoso.",
                                    "Aplique Bernoulli: ∂φ/∂t + (1/2)|∇φ|² + ∫ dp/ρ + gz = F(t).",
                                    "Substitua dp/ρ usando isentropia: dp/ρ = a² dρ/ρ, onde a² = γ p / ρ.",
                                    "Expresse ρ em termos de φ e ∇φ via linearização ou forma exata para gases perfeitos.",
                                    "Teste com caso simples: φ = U∞ x (1 + ε f(y/x)) para perturbação."
                                  ],
                                  "verification": "Implemente a expressão ρ(φ, ∇φ) em uma planilha ou código Python e plote para um perfil φ dado.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Python com NumPy/Matplotlib, ou MATLAB; referências de EF (ex: Zienkiewicz).",
                                  "tips": "Comece com o caso incompressível (ρ=const) e adicione termos compressíveis gradualmente.",
                                  "learningObjective": "Conectar o potencial φ às condições termodinâmicas para formulação compressível.",
                                  "commonMistakes": "Inverter gradiente (v=∇φ correto); ignorar termos transitórios ∂φ/∂t."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar na formulação de elementos finitos para escoamento compressível",
                                  "subSteps": [
                                    "Formule a equação de campo: ∇·(ρ ∇φ) = 0, com ρ(φ, ∇φ).",
                                    "Linearize ρ para método iterativo: ρ^{n+1} = ρ(φ^n, ∇φ^n).",
                                    "Monte matriz de rigidez elementar ponderada por ρ.",
                                    "Implemente condições de contorno: ρ∞, φ∞ em bordas.",
                                    "Resolva um problema 1D ou 2D simples (ex: canal convergente)."
                                  ],
                                  "verification": "Compare solução numérica com analítica para escoamento em duto; erro <5%.",
                                  "estimatedTime": "120 minutos",
                                  "materials": "Código FEA básico (Gmsh+GetDP ou FEniCS), dados de benchmark.",
                                  "tips": "Use under-relaxation na iteração para convergência: ρ^{n+1} = ω ρ^{new} + (1-ω) ρ^n.",
                                  "learningObjective": "Implementar condições termodinâmicas em simulações EF de potencial compressível.",
                                  "commonMistakes": "Não iterar corretamente ρ-φ; condições de contorno erradas em Mach alto."
                                }
                              ],
                              "practicalExample": "Em um perfil de aerofólio NACA0012 a Mach 0.8, defina φ upstream como U∞x, compute ∇φ via painéis, aplique ρ/ρ∞ = [1 + 0.2 q²/a∞²]^{-2.5} (γ=1.4), e integre na equação de Laplace ponderada para prever coeficiente de pressão Cp.",
                              "finalVerifications": [
                                "Derivação correta de ρ em termos de φ e |∇φ| coincide com literatura padrão.",
                                "Código ou planilha reproduz Bernoulli compressível com erro <1%.",
                                "Solução EF converge monotonicamente com refinamento de malha.",
                                "Valores de ρ variam fisicamente: diminuem em acelerações, aumentam em desacelerações.",
                                "Teste limite incompressível: ρ → const quando Mach → 0.",
                                "Verificação dimensional: todas equações homogêneas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação termodinâmica (equação de estado e isentropia).",
                                "Correta integração de φ em expressões de ρ (incluindo derivadas).",
                                "Implementação numérica funcional e convergente.",
                                "Interpretação física dos resultados (efeitos compressíveis).",
                                "Documentação clara de passos e suposições.",
                                "Eficiência computacional (tempo de iteração razoável)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo vetorial e equações diferenciais parciais (∇·(ρ∇φ)=0).",
                                "Física: Termodinâmica de gases e conservação de energia/momento.",
                                "Computação: Programação numérica e métodos iterativos (Newton-Raphson).",
                                "Engenharia Aeronáutica: Análise de perfis em regime transônico.",
                                "Estatística: Análise de erro e validação de modelos numéricos."
                              ],
                              "realWorldApplication": "Simulação de escoamentos transônicos em asas de aviões comerciais (ex: Boeing 787), otimização de difusores em turbinas a gás, ou previsão de ondas de choque fracas em bocais de foguetes, reduzindo custos de testes em túnel de vento."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.4.2.3",
                            "name": "Analisar comportamento supersônico",
                            "description": "Discutir a transição de elíptico para hiperbólico no regime supersônico e implicações para problemas de contorno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar equações governantes do potencial compressível",
                                  "subSteps": [
                                    "Derivar a equação linearizada do potencial φ para escoamento compressível não viscoso a partir das equações de Euler.",
                                    "Identificar o número de Mach (M) como parâmetro chave e calcular o coeficiente β = √(1 - M²).",
                                    "Classificar a equação diferencial parcial (EDP) como elíptica quando β > 0 (subsonico) e hiperbólica quando β < 0 (supersônico).",
                                    "Resolver numericamente exemplos simples em sub e supersônico usando diferenças finitas.",
                                    "Plotar soluções para visualizar diferenças qualitativas."
                                  ],
                                  "verification": "Capacidade de derivar e classificar corretamente a EDP para M < 1 e M > 1, com plots validados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'Computational Fluid Dynamics' de John D. Anderson",
                                    "MATLAB ou Python com NumPy/SciPy",
                                    "Papel e calculadora para derivações"
                                  ],
                                  "tips": "Comece com aproximações lineares para simplificar; use gráficos de Mach cones para intuição.",
                                  "learningObjective": "Compreender a base matemática das EDPs governantes e sua dependência no regime de fluxo.",
                                  "commonMistakes": [
                                    "Confundir sinal de β (lembre: √(1 - M²) é real só para M < 1)",
                                    "Ignorar normalização das variáveis no potencial φ",
                                    "Não linearizar corretamente as equações de Euler"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar regime subsonico (elíptico)",
                                  "subSteps": [
                                    "Explicar características elípticas: propagação de informação em todas as direções.",
                                    "Discutir condições de contorno: valor de φ especificado em toda a fronteira fechada.",
                                    "Implementar solução em malha cartesiana usando método de diferenças finitas elíptico (ex: Gauss-Seidel).",
                                    "Comparar com solução exata para perfil de NACA em subsonico.",
                                    "Analisar convergência e estabilidade do esquema numérico."
                                  ],
                                  "verification": "Solução numérica converge para solução analítica conhecida com erro < 1%.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software FEniCS ou MATLAB PDE Toolbox",
                                    "Artigos sobre potencial compressível subsonico",
                                    "Computador com solver numérico"
                                  ],
                                  "tips": "Use condições periódicas em domínios infinitos para aproximar fluxo externo.",
                                  "learningObjective": "Dominar formulação e solução de problemas elípticos em EF para fluxo subsonico.",
                                  "commonMistakes": [
                                    "Condições de contorno abertas inadequadas levando a não-convergência",
                                    "Esquemas numéricos instáveis por passos de tempo grandes",
                                    "Não tratar singularidades em bordas de ataque"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar regime supersônico (hiperbólico)",
                                  "subSteps": [
                                    "Explicar características hiperbólicas: propagação downstream ao longo de Mach lines.",
                                    "Discutir condições de contorno: φ especificado apenas upstream; downstream extrapolado.",
                                    "Implementar esquema hiperbólico (ex: upwind differences) para onda de expansão Prandtl-Meyer.",
                                    "Visualizar Mach cones e zonas de influência.",
                                    "Simular descontinuidades fracas e analisar tratamento em EF."
                                  ],
                                  "verification": "Solução captura corretamente Mach lines sem oscilações espúrias.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'Aerodinâmica Supersônica' de Ashley & Landahl",
                                    "Python com Matplotlib para visualização de características",
                                    "Solver EF como SU2"
                                  ],
                                  "tips": "Sempre marchar na direção da característica principal para estabilidade.",
                                  "learningObjective": "Entender propagação de informação unidirecional e condições de contorno marchadas.",
                                  "commonMistakes": [
                                    "Aplicar condições de contorno elípticas em supersônico causando instabilidade",
                                    "Ignorar direção das Mach lines levando a soluções físicas incorretas",
                                    "Não capturar choques com potencial linearizado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir transição e implicações para problemas de contorno em EF",
                                  "subSteps": [
                                    "Analisar transição transônica (M ≈ 1): mudança de tipo de EDP e tratamento híbrido.",
                                    "Comparar requisitos de contorno: elíptico (fechado) vs hiperbólico (aberto/marchado).",
                                    "Implementar malha adaptativa em EF para transições de regime.",
                                    "Avaliar impacto em precisão e custo computacional de simulações mistas.",
                                    "Propor soluções artificiais (ex: relaxação) para regimes mistos."
                                  ],
                                  "verification": "Relatório descreve corretamente mudanças e simula caso transônico com convergência.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "ANSYS Fluent ou OpenFOAM tutoriais de potencial compressível",
                                    "Paper 'Transonic Potential Flow' de Ballhaus",
                                    "Notebook Jupyter para análise"
                                  ],
                                  "tips": "Use número de Mach local para alternar esquemas numéricos automaticamente.",
                                  "learningObjective": "Aplicar conhecimentos em formulações EF robustas para regimes variados.",
                                  "commonMistakes": [
                                    "Tratar todo domínio como elíptico ignorando hiperbolicidade local",
                                    "Malhas não adaptadas causando dispersão em Mach lines",
                                    "Não validar contra soluções exatas transônicas"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule o fluxo supersônico sobre uma cunha em 2D usando método dos elementos finitos com formulação de potencial compressível. Compare solução elíptica/subsonica (M=0.8) com hiperbólica/supersônica (M=2.0), ajustando condições de contorno e visualizando Mach lines para validar a transição.",
                              "finalVerifications": [
                                "Explicar verbalmente a mudança de elíptico para hiperbólico e condições de contorno associadas.",
                                "Gerar plots corretos de linhas de corrente e Mach cones para M>1.",
                                "Implementar e rodar simulação EF convergente para caso supersônico.",
                                "Identificar e corrigir erros em condições de contorno inadequadas.",
                                "Discutir limitações do potencial linearizado em regimes reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na classificação de EDPs baseada em M (100% correto).",
                                "Profundidade na análise de condições de contorno (cobertura completa de implicações).",
                                "Qualidade da implementação numérica (convergência <1% erro).",
                                "Clareza em visualizações e explicações qualitativas.",
                                "Criatividade em tratamento de transições transônicas.",
                                "Referenciação adequada a literatura e validações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Classificação e solução de EDPs elípticas/hiperbólicas.",
                                "Física: Princípios de aerodinâmica compressível e teoria de características.",
                                "Computação: Métodos numéricos em EF e programação científica.",
                                "Engenharia Aeronáutica: Design de perfis supersônicos."
                              ],
                              "realWorldApplication": "No design de aeronaves supersônicas como o Concorde ou mísseis hipersônicos, análise correta do comportamento supersônico garante condições de contorno adequadas em simulações EF, previnindo erros em previsão de ondas de choque e otimização aerodinâmica."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.3",
                        "name": "Discretização pelo Método dos Elementos Finitos",
                        "description": "Aplicação do MEF para resolver numericamente as equações de campo escalar do potencial compressível, incluindo montagem de matrizes e condições de contorno.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.3.1",
                            "name": "Formular a integral fraca",
                            "description": "Obter a forma variacional ou integral fraca da equação do potencial compressível usando o método de Galerkin para problemas de campo escalar.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a equação governante do potencial compressível",
                                  "subSteps": [
                                    "Identifique a equação de continuidade para escoamento irrotacional compressível: div(ρ ∇φ) = 0, onde ρ é a densidade e φ o potencial de velocidade.",
                                    "Expresse ρ em termos de φ usando a equação de estado isentrópica: ρ = ρ₀ (1 + ((γ-1)/2) M∞² (∇φ · ∇φ / a∞² - 1))^{(γ-1)/ (2(γ-1))).",
                                    "Defina o domínio Ω e a fronteira ∂Ω, distinguindo partes com condições de Dirichlet e Neumann.",
                                    "Anote as condições de contorno relevantes: φ = g em Γ_D e ∂φ/∂n = h em Γ_N.",
                                    "Verifique a consistência dimensional dos termos."
                                  ],
                                  "verification": "Escreva a equação completa com todas as variáveis definidas e condições de contorno anotadas corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro-texto de Elementos Finitos (ex: Zienkiewicz), caderno e caneta, software simbólico como SymPy ou Mathematica"
                                  ],
                                  "tips": "Comece com o caso linearizado para ganhar intuição antes do não-linear.",
                                  "learningObjective": "Compreender a forma forte da equação e suas componentes para problemas de escoamento compressível.",
                                  "commonMistakes": [
                                    "Confundir potencial φ com velocidade primitiva",
                                    "Esquecer dependência não-linear de ρ em φ",
                                    "Ignorar condições de contorno iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir funções de teste e formular o produto fraco inicial",
                                  "subSteps": [
                                    "Escolha funções de teste w ∈ H¹(Ω) do espaço de Galerkin (mesmo espaço das funções base).",
                                    "Multiplique a equação div(ρ ∇φ) = 0 por w e integre sobre o domínio: ∫_Ω w div(ρ ∇φ) dΩ = 0.",
                                    "Defina o espaço de funções admissíveis V = {v ∈ H¹(Ω) | v=0 em Γ_D} para funções virtuais.",
                                    "Escreva a forma bilinear inicial: encontrar φ ∈ V_g tal que ∫_Ω w div(ρ ∇φ) dΩ = 0 ∀ w ∈ V.",
                                    "Identifique os termos de volume e prepare para integração por partes."
                                  ],
                                  "verification": "Confirme que a equação residual integrada é zero para qualquer w arbitrária no espaço apropriado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de derivadas do cálculo variacional, calculadora simbólica"
                                  ],
                                  "tips": "Lembre-se que Galerkin implica w e φ no mesmo espaço finito-dimensional posteriormente.",
                                  "learningObjective": "Estabelecer a base do método variacional fraco usando funções de teste.",
                                  "commonMistakes": [
                                    "Usar funções de teste não pertencentes ao espaço correto",
                                    "Esquecer a restrição em Γ_D",
                                    "Integrar sem multiplicar pela função teste"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar integração por partes (teorema da divergência)",
                                  "subSteps": [
                                    "Aplique o teorema da divergência: ∫_Ω w div(ρ ∇φ) dΩ = ∫_∂Ω w (ρ ∇φ · n) dΓ - ∫_Ω ∇w · (ρ ∇φ) dΩ.",
                                    "Substitua para obter: -∫_Ω ρ ∇w · ∇φ dΩ + ∫_∂Ω w (ρ ∂φ/∂n) dΓ = 0.",
                                    "Restrinja o termo de contorno: em Γ_N, ∂φ/∂n = h, então ∫_Γ_N w ρ h dΓ; em Γ_D, w=0.",
                                    "Verifique a simetria da forma bilinear a( w, φ ) = ∫_Ω ρ ∇w · ∇φ dΩ.",
                                    "Anote a não-linearidade devido a ρ(φ)."
                                  ],
                                  "verification": "A forma fraca deve ter termo de volume negativo e termo de contorno positivo, equilibrando a zero.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Tabela de identidades vetoriais, exemplos resolvidos de FEM para Poisson"
                                  ],
                                  "tips": "Visualize com um diagrama: setas de fluxo saindo da fronteira.",
                                  "learningObjective": "Transformar a forma forte em fraca via integração por partes, expondo termos naturais de contorno.",
                                  "commonMistakes": [
                                    "Sinal errado no termo de volume",
                                    "Confundir ∇w · ∇φ com div(∇φ)",
                                    "Aplicar teorema da divergência incorretamente em ρ variável"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incorporar condições de contorno e finalizar a integral fraca",
                                  "subSteps": [
                                    "Inclua condições essenciais (Dirichlet): φ = g em Γ_D, interpolado nas funções base.",
                                    "Escreva a forma final: ∫_Ω ρ ∇w · ∇φ dΩ = ∫_Γ_N w ρ h dΓ ∀ w ∈ V.",
                                    "Discuta linearização para método de Newton-Raphson devido à não-linearidade.",
                                    "Verifique consistência: a forma fraca deve ser consistente com a forte ao tomar w → delta de Dirac.",
                                    "Teste com um caso simples numérico para validar."
                                  ],
                                  "verification": "Substitua φ exata na forma fraca e confirme que satisfaz para w arbitrárias.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software FEM como FEniCS ou código MATLAB para teste",
                                    "Exemplo numérico simples"
                                  ],
                                  "tips": "Para não-linearidade, itere com ρ atualizado de iteração anterior.",
                                  "learningObjective": "Obter a integral fraca completa pronta para discretização em elementos finitos.",
                                  "commonMistakes": [
                                    "Esquecer fator ρ no termo de contorno",
                                    "Não tratar Γ_D corretamente",
                                    "Ignorar não-linearidade na forma final"
                                  ]
                                }
                              ],
                              "practicalExample": "Para escoamento compressível 2D em um canal convergente-divergente (bico de Laval), com Ma_in=0.5, γ=1.4. Equação: div(ρ ∇φ)=0 com ρ=(1 + 0.2 |∇φ|^2)^{-2.5}. Integral fraca: ∫_Ω ρ ∇w · ∇φ dΩ = ∫_Γ_out w ρ_out v_n dΓ, onde Γ_out é saída supersônica.",
                              "finalVerifications": [
                                "Forma bilinear simétrica: ∫ ρ ∇w · ∇φ dΩ.",
                                "Termo de contorno natural: ∫_Γ_N w ρ h dΓ.",
                                "Condições essenciais incorporadas em V_g.",
                                "Consistência com equação forte via Green.",
                                "Tratamento de não-linearidade via ρ(∇φ).",
                                "Equilíbrio global: esquerda = direita para soluções exatas.",
                                "Dimensões consistentes (todas em [velocidade]^2)."
                              ],
                              "assessmentCriteria": [
                                "Correta aplicação do teorema da divergência com sinal apropriado.",
                                "Uso preciso do método Galerkin (w no mesmo espaço).",
                                "Incorporação correta de condições de contorno Dirichlet/Neumann.",
                                "Reconhecimento e tratamento da não-linearidade em ρ.",
                                "Forma final pronta para montagem da matriz de rigidez.",
                                "Verificação matemática de consistência e estabilidade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo Variacional e Teoria de Sobolev.",
                                "Física: Mecânica dos Fluidos Compressíveis e Aerodinâmica.",
                                "Computação: Programação Numérica para Solução Não-Linear (Newton).",
                                "Engenharia: Simulações CFD em Turbomáquinas.",
                                "Estatística: Análise de Erro em Aproximações FEM."
                              ],
                              "realWorldApplication": "Formulação essencial para simulações numéricas de escoamentos supersônicos em design de nozzles de foguetes, asas de aviões e turbinas eólicas, permitindo previsão de ondas de choque e otimização aerodinâmica via software como ANSYS ou SU2."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.4.3.2",
                            "name": "Selecionar funções de interpolação",
                            "description": "Escolher e implementar funções de forma lineares ou quadráticas para aproximar o potencial φ em elementos 2D ou 3D.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Aproximação em MEF para Potencial φ",
                                  "subSteps": [
                                    "Estude o problema de escoamento compressível não viscoso e o papel do potencial φ como campo escalar irrotacional.",
                                    "Revise a formulação variacional do MEF: ∫∇φ·∇φ dΩ = ∫φ ∂φ/∂n dΓ.",
                                    "Entenda a aproximação φ^h = Σ N_i φ_i, onde N_i são funções de interpolação (shape functions).",
                                    "Compare requisitos de continuidade (C0 para φ).",
                                    "Identifique elementos comuns: triângulo linear (3 nós), quadrilátero bilinear (4 nós) em 2D."
                                  ],
                                  "verification": "Resuma em um diagrama os componentes da aproximação φ^h e liste 3 propriedades das shape functions.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de MEF (ex: Zienkiewicz), slides de aula sobre formulação fraca, papel e caneta.",
                                  "tips": "Use coordenadas naturais (ξ, η) para simplicidade em elementos isoparamétricos.",
                                  "learningObjective": "Compreender o papel das funções de interpolação na aproximação de φ em MEF.",
                                  "commonMistakes": "Confundir φ com velocidade vetorial; esquecer normalização das shape functions (Σ N_i = 1)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar e Implementar Funções Lineares em Elementos 2D e 3D",
                                  "subSteps": [
                                    "Para triângulo 2D: derive N1 = (a1 + b1 x + c1 y)/(2A), com a1= x2 y3 - x3 y2, etc.",
                                    "Implemente em código ou calcule manualmente para um triângulo exemplo com nós (0,0), (1,0), (0,1).",
                                    "Estenda para tetraedro 3D: N1 = (a1 + b1 x + c1 y + d1 z)/(6V).",
                                    "Verifique propriedades: N_i(nó j) = δ_ij, grad N_i constante.",
                                    "Compare precisão: erro O(h^2) para solução quadrática."
                                  ],
                                  "verification": "Calcule φ^h no centroide de um elemento e confirme Σ N_i = 1 e valores nos nós corretos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software MATLAB/Python com sympy para derivação simbólica, calculadora.",
                                  "tips": "Memorize fórmulas de área/volume para derivação rápida.",
                                  "learningObjective": "Derivar e verificar funções lineares para elementos simplex 2D/3D.",
                                  "commonMistakes": "Erros em coeficientes b,c,d por troca de índices de nós; não verificar partição da unidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Funções Quadráticas em Elementos 2D e 3D",
                                  "subSteps": [
                                    "Para triângulo quadrático (6 nós): use N_i = λ_i (λ_i - 0.5) * 2, onde λ_i são barycêntricas lineares.",
                                    "Implemente para quadrilátero serendepity (8 nós): N1 = (1-ξ)(1-η)(-ξ-η)/4, etc.",
                                    "Estenda para hexaedro 3D (20 nós) ou tetraedro (10 nós).",
                                    "Calcule grad N_i e note variação linear (mais precisão).",
                                    "Avalie custo: mais DOFs por elemento (6 vs 3 em 2D)."
                                  ],
                                  "verification": "Plote shape functions em software (ex: Gmsh) e confirme interpolação exata de polinômios quadráticos.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Gmsh ou FreeFEM para visualização, notebook Jupyter.",
                                  "tips": "Use transformação isoparamétrica para elementos curvos.",
                                  "learningObjective": "Dominar formulação de funções quadráticas e suas propriedades.",
                                  "commonMistakes": "Confundir nós midside com corner; gradientes incorretos em nós midside."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Selecionar Funções Baseado em Critérios de Precisão e Eficiência",
                                  "subSteps": [
                                    "Analise convergência: linear O(h^2), quadrática O(h^3) para φ suave.",
                                    "Considere custo computacional: tempo/malha ~ DOFs^1.5-2.",
                                    "Avalie para escoamento: linear para malhas grossas, quadrática perto de singularidades (trailing edge).",
                                    "Teste em benchmark: fluxo uniforme, compare erro L2 com solução exata.",
                                    "Documente trade-offs em tabela: precisão vs tempo vs memória."
                                  ],
                                  "verification": "Crie tabela comparativa para um problema teste e justifique escolha.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Código MEF simples (FEniCS ou deal.II), dados de benchmark.",
                                  "tips": "Comece com linear para protótipo, refine com quadrático adaptativo.",
                                  "learningObjective": "Aplicar critérios para escolher linear vs quadrática em contextos reais.",
                                  "commonMistakes": "Ignorar locking em elementos quadráticos distorcidos; superestimar ganhos quadráticos em malhas finas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Implementar e Validar em um Caso Prático",
                                  "subSteps": [
                                    "Monte malha 2D para aerofólio NACA0012.",
                                    "Implemente MEF com linear e quadrática para φ em escoamento subsonico.",
                                    "Resolva sistema K φ = F.",
                                    "Compare Cp = 1 - 2 (∂φ/∂x)^2 vs dados experimentais.",
                                    "Analise sensibilidade à escolha de interpolação."
                                  ],
                                  "verification": "Erro em lift <5% para quadrática vs >10% linear; plote contornos φ.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "SU2 ou OpenFOAM para validação, código Python/MATLAB.",
                                  "tips": "Use BCs: φ= U∞ x em far-field, ∂φ/∂n=0 em corpo.",
                                  "learningObjective": "Integrar seleção e implementação em simulação completa.",
                                  "commonMistakes": "BCs erradas em far-field; não normalizar φ."
                                }
                              ],
                              "practicalExample": "Em simulação de escoamento ao redor de um aerofólio NACA0012 a Ma=0.8, use funções lineares em triângulos para malha inicial (rápido), refinando para quadráticas perto do bordo de ataque para capturar gradientes altos de φ, reduzindo erro em pressão de sucção de 15% para 4%.",
                              "finalVerifications": [
                                "Shape functions somam 1 em qualquer ponto do elemento.",
                                "Interpolação exata de polinômios até grau da função (1 para linear, 2 para quadrática).",
                                "Gradientes corretos nos nós, com continuidade C0 entre elementos.",
                                "Convergência observada em refinamento h: taxa 2 para linear, 3 para quadrática.",
                                "Solução φ satisfaz equação de Laplace em elementos internos (teste residual).",
                                "Pressão Cp coincide com solução analítica em fluxo uniforme."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de shape functions (fórmulas corretas, 30%).",
                                "Correta verificação de propriedades (partição unidade, δ_ij, 20%).",
                                "Justificativa fundamentada da escolha linear/quadrática (trade-offs, 25%).",
                                "Implementação numérica sem erros (resultados plots, 15%).",
                                "Análise de erros e conexões com escoamento (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Polinômios de Lagrange e coordenadas barycêntricas.",
                                "Programação: Implementação numérica de matrizes de rigidez em Python/Fortran.",
                                "Física: Conservação em escoamento potencial (equação de Laplace).",
                                "Computação Científica: Análise de convergência e h-refinamento.",
                                "Design: Otimização de malhas em CAD para MEF."
                              ],
                              "realWorldApplication": "Seleção de funções quadráticas em simulações CFD para design de turbinas eólicas, reduzindo tempo de iteração em 30% vs lineares, permitindo otimização aerodinâmica em aeronaves comerciais como o Boeing 787."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.3.3",
                            "name": "Montar matrizes globais",
                            "description": "Calcular e montar as matrizes de rigidez não lineares e vetores de carga considerando a dependência do coeficiente de compressibilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a malha e definir parâmetros iniciais",
                                  "subSteps": [
                                    "Identificar os nós e elementos da malha finita.",
                                    "Definir as funções de interpolação (ex: lineares para triângulos).",
                                    "Calcular o Jacobiano e derivadas das funções de forma para cada elemento.",
                                    "Estabelecer o coeficiente de compressibilidade β como função da pressão ou densidade (ex: β = 1/(ρ c²)).",
                                    "Inicializar valores iniciais para β baseados em solução anterior ou chute inicial."
                                  ],
                                  "verification": "Verificar se todos os nós têm coordenadas corretas e elementos conectividades válidas; plotar malha para inspeção visual.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de MEF (ex: MATLAB, Python com FEniCS ou código próprio)",
                                    "Arquivo da malha (.msh ou similar)",
                                    "Documentação das funções de forma"
                                  ],
                                  "tips": [
                                    "Use malhas estruturadas inicialmente para depuração.",
                                    "Armazene conectividades em arrays para acesso rápido."
                                  ],
                                  "learningObjective": "Compreender a estrutura da discretização e preparar dados para montagem.",
                                  "commonMistakes": [
                                    "Índices de nós errados nas conectividades.",
                                    "Esquecer unidades consistentes nas coordenadas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular matrizes de rigidez locais considerando compressibilidade",
                                  "subSteps": [
                                    "Para cada elemento, integrar numericamente ∫ β N_i N_j |J| dξ (onde N são funções de forma).",
                                    "Avaliar β no centro do elemento ou pontos de Gauss, usando valores da iteração anterior.",
                                    "Montar a matriz  local K^e (dimensão n_el x n_el, n_el = nós por elemento).",
                                    "Verificar simetria e positividade da matriz local.",
                                    "Repetir para todos os elementos."
                                  ],
                                  "verification": "Conferir se K^e é simétrica e soma das linhas é positiva; comparar com caso linear (β constante).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código para integração de Gauss",
                                    "Tabelas de pontos e pesos de Gauss",
                                    "Valores iniciais de β"
                                  ],
                                  "tips": [
                                    "Use 3-4 pontos de Gauss para precisão em 2D.",
                                    "Vetorize computações para eficiência."
                                  ],
                                  "learningObjective": "Dominar o cálculo local incorporando não-linearidade via β.",
                                  "commonMistakes": [
                                    "Integração incorreta do Jacobiano.",
                                    "Uso de β constante em vez de dependente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Montar a matriz de rigidez global",
                                  "subSteps": [
                                    "Inicializar matriz global K como esparsa (zero) de tamanho N x N (N = total de nós).",
                                    "Para cada elemento e cada par (i,j) em K^e, adicionar K^e_ij à posição global (dof_i, dof_j).",
                                    "Aplicar condições de contorno Dirichlet zerando linhas/colunas e ajustando.",
                                    "Verificar estrutura esparsa e eliminar graus de liberdade fixos.",
                                    "Salvar matriz em formato para solver (ex: CSR)."
                                  ],
                                  "verification": "Verificar dimensões (N x N), soma de contribuições locais em posições sobrepostas, e perfil de banda.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Bibliotecas esparsas (SciPy sparse, MATLAB sparse)",
                                    "Lista de dofs livres"
                                  ],
                                  "tips": [
                                    "Use índices locais-globais para evitar loops lentos.",
                                    "Teste com malha pequena (3 nós)."
                                  ],
                                  "learningObjective": "Executar montagem global eficiente preservando não-linearidade.",
                                  "commonMistakes": [
                                    "Sobrescrita incorreta em posições compartilhadas.",
                                    "Não aplicar BCs corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar o vetor de carga global",
                                  "subSteps": [
                                    "Para cada elemento, calcular f^e = ∫ fonte N_i |J| dξ + termos de contorno se aplicável.",
                                    "Incorporar dependência de β se houver fontes não-lineares.",
                                    "Inicializar vetor global f como zero (N x 1).",
                                    "Acumular contribuições locais nas posições globais dos nós.",
                                    "Aplicar BCs de Neumann adicionando fluxos nas faces de contorno."
                                  ],
                                  "verification": "Verificar equilíbrio global (soma f deve satisfazer conservação); comparar normas com caso linear.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Funções fonte do problema",
                                    "Condições de contorno definidas"
                                  ],
                                  "tips": [
                                    "Trate BCs de contorno em loop separado para clareza.",
                                    "Use simetria do problema para validação."
                                  ],
                                  "learningObjective": "Completar sistema afim não-linear K(β) φ = f.",
                                  "commonMistakes": [
                                    "Esquecer termos de contorno.",
                                    "Inconsistência na integração com K^e."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma malha 1D com 3 nós (2 elementos) para escoamento compressível em tubo: β = 1/(ρ0 + ρ(φ)) c². Calcule K^e1 = [[2.1, -1.1], [-1.1, 2.1]] (aprox.), monte K global 3x3 somando, aplique φ(0)=0, obtendo sistema 2x2 para solução iterativa.",
                              "finalVerifications": [
                                "Matriz K global é simétrica e definida positiva.",
                                "Dimensões corretas: N x N para K, N x 1 para f.",
                                "Soma de linhas de K^e contribui corretamente para K global.",
                                "Estrutura esparsa reflete conectividade da malha.",
                                "BCs aplicadas: linhas zeradas para Dirichlet.",
                                "Conservação: soma f global = integral fonte total."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erro <1% vs analítico em caso teste.",
                                "Eficiência: tempo de montagem O(N) para malhas grandes.",
                                "Tratamento não-linear: β atualizado corretamente por elemento.",
                                "Validação: teste de convergência Newton-Raphson.",
                                "Código modular: funções separadas para local/global.",
                                "Documentação: comentários explicando dependência de β."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra Linear - Matrizes esparsas e montagem.",
                                "Física: Mecânica dos Fluidos - Equação de continuidade compressível.",
                                "Computação: Programação Numérica - Integração e solvers iterativos.",
                                "Engenharia: Análise Computacional - Validação de MEF."
                              ],
                              "realWorldApplication": "Simulação de escoamento supersônico em bocais de turbinas ou foguetes, prevendo variações de densidade e choques onde β varia significativamente com Mach."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.6.4.3.4",
                            "name": "Implementar condições de contorno",
                            "description": "Aplicar condições de contorno essenciais (φ especificado) e naturais (condição de Kutta para perfis aerodinâmicos) em fluxos supersônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e classificar condições de contorno para fluxos supersônicos",
                                  "subSteps": [
                                    "Estude a equação governante para escoamento compressível não viscoso (equação de Euler potencial).",
                                    "Classifique condições essenciais (Dirichlet: φ especificado em bordas de entrada/saída) e naturais (Neumann: derivadas para paredes e condição de Kutta).",
                                    "Analise perfis aerodinâmicos supersônicos: identifique trailing edge para Kutta (φ contínuo e derivada zero).",
                                    "Revise literatura sobre fluxos supersônicos: ondas de choque e Mach >1 implicam condições específicas.",
                                    "Desenhe diagrama de malha com nós de contorno destacados."
                                  ],
                                  "verification": "Crie um diagrama anotado da malha mostrando tipos de condições de contorno aplicáveis.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Elementos Finitos (ex: Zienkiewicz), software de CAD para malha (Gmsh), notas de aerodinâmica supersônica"
                                  ],
                                  "tips": "Sempre priorize condições físicas: entrada supersônica usa φ=0, saída livre.",
                                  "learningObjective": "Compreender diferenças entre condições essenciais e naturais no contexto supersônico.",
                                  "commonMistakes": [
                                    "Confundir essencial com natural",
                                    "Ignorar Mach number alto",
                                    "Não considerar simetria em perfis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar condições essenciais (φ especificado)",
                                  "subSteps": [
                                    "Selecione nós de contorno onde φ é imposto (ex: borda de entrada com φ=0).",
                                    "Modifique o vetor de força global: fixe valores de φ nos graus de liberdade essenciais.",
                                    "Use penalização ou eliminação de equações para impor φ exato no sistema Ku=f.",
                                    "Codifique em Python/MATLAB: função para aplicar Dirichlet em matriz esparsa.",
                                    "Teste unitário: verifique se φ fixo persiste após uma iteração."
                                  ],
                                  "verification": "Execute simulação simples e confirme φ=valor imposto em todos os nós selecionados (erro <1e-6).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Biblioteca NumPy/SciPy para MEF, código base de MEF para escoamento potencial"
                                  ],
                                  "tips": "Use índices de nós para evitar loops ineficientes; prefira eliminação sobre penalização para precisão.",
                                  "learningObjective": "Aplicar condições Dirichlet no framework MEF sem perturbar o sistema global.",
                                  "commonMistakes": [
                                    "Não zerar linhas/colunas correspondentes",
                                    "Aplicar em nós errados",
                                    "Esquecer renormalização"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar condições naturais (incluindo Kutta para perfis aerodinâmicos)",
                                  "subSteps": [
                                    "Defina condição de Kutta: φ contínuo e ∂φ/∂n=0 no trailing edge para circulação finita.",
                                    "Integre termos naturais no funcional variacional: adicione ∫(∂φ/∂n - g)² na borda.",
                                    "Para supersônico: imponha ∂φ/∂n=0 em paredes impermeáveis e Kutta como multi-ponto.",
                                    "Atualize matriz de rigidez K e vetor f com contribuições de contorno naturais.",
                                    "Codifique função dedicada para Kutta: média de φ em nós adjacentes no trailing edge."
                                  ],
                                  "verification": "Verifique resíduo de Kutta: |∂φ/∂n| <1e-5 no trailing edge pós-convergência.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código MEF expandido, perfis NACA supersônicos (dados online), debugger para matrizes"
                                  ],
                                  "tips": "Para supersônico, Kutta é aproximada; valide com solução analítica de Prandtl-Meyer.",
                                  "learningObjective": "Incorporar condições de Neumann e Kutta no sistema fraco MEF.",
                                  "commonMistakes": [
                                    "Não linearizar Kutta corretamente",
                                    "Aplicar Kutta em leading edge",
                                    "Ignorar curvatura supersônica"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar, simular e validar implementação completa",
                                  "subSteps": [
                                    "Monte sistema global com todas condições: resolva Ku=f iterativamente (Gauss-Seidel ou CG).",
                                    "Gere malha para perfil supersônico (ex: diamante wedge) usando Gmsh.",
                                    "Execute simulação: plote linhas de potencial φ e velocidades.",
                                    "Valide: compare coeficiente de pressão Cp com dados teóricos supersônicos.",
                                    "Otimize: ajuste tolerâncias para convergência em fluxos Mach>1."
                                  ],
                                  "verification": "Simulação converge com Cp erro <5% vs. analítico; visualize φ suave com Kutta satisfeita.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Gmsh para malha, Matplotlib/Paraview para pós-processamento, benchmark supersônico"
                                  ],
                                  "tips": "Monitore condição de onda de choque; use malhas refinadas no trailing edge.",
                                  "learningObjective": "Executar simulação end-to-end com condições de contorno corretas.",
                                  "commonMistakes": [
                                    "Malha grosseira causa não-convergência",
                                    "Escala errada de φ",
                                    "Não plotar vetores velocidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente MEF para fluxo supersônico (Mach=2) sobre perfil diamante: imponha φ=0 na entrada, ∂φ/∂n=0 nas paredes, e condição de Kutta no trailing edge. Plote mapa de velocidade mostrando onda de choque oblíqua.",
                              "finalVerifications": [
                                "φ satisfaz condições essenciais em todos nós fronteira (erro <1e-6).",
                                "Resíduo de Kutta |∂φ/∂n| <1e-5 no trailing edge.",
                                "Sistema converge em <100 iterações para malha de 1000 elementos.",
                                "Coeficientes aerodinâmicos (Cp, lift) coincidem com teoria em 5%.",
                                "Visualização mostra fluxo físico sem singularidades.",
                                "Teste de sensibilidade: variação de malha não altera solução >2%."
                              ],
                              "assessmentCriteria": [
                                "Precisão na imposição de condições essenciais/naturais (90%+ acurácia).",
                                "Correta implementação de Kutta em perfis supersônicos.",
                                "Eficiência computacional: tempo de simulação <10min para malha média.",
                                "Validação quantitativa com benchmarks analíticos.",
                                "Código modular e comentado, reproduzível.",
                                "Análise de erros e discussão de limitações supersônicas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise funcional e métodos variacionais para PDEs elípticas.",
                                "Programação: Manipulação de matrizes esparsas e solvers iterativos (SciPy).",
                                "Física: Aerodinâmica compressível e teoria de potencial linearizado.",
                                "Engenharia Aeronáutica: Design de perfis para Mach alto.",
                                "Computação Científica: Pós-processamento e visualização de campos escalares."
                              ],
                              "realWorldApplication": "Análise de fluxo supersônico em nozzles de foguetes, wings de aviões militares (ex: F-22), ou simuladores de hypersonic vehicles, otimizando formas para minimizar drag onda de choque."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.2.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.5",
                    "name": "Acústica",
                    "description": "Simulação de propagação de ondas acústicas em meios fluidos com equação de Helmholtz como problema de campo escalar.",
                    "individualConcepts": [
                      {
                        "id": "34.3.5.1",
                        "name": "Fundamentos de Ondas Acústicas em Meios Fluidos",
                        "description": "Introdução aos conceitos básicos da propagação de ondas acústicas em fluidos compressíveis, lineares e isotrópicos, incluindo a equação da onda e sua transformação para o domínio da frequência via equação de Helmholtz.",
                        "specificSkills": [
                          {
                            "id": "34.3.5.1.1",
                            "name": "Derivação da Equação da Onda Acústica",
                            "description": "Derivar a equação diferencial da onda acústica a partir das equações de conservação de massa e momento linearizado para fluidos homogêneos, destacando pressupostos de pequenas perturbações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Equações de Conservação de Massa e Momento em Fluidos",
                                  "subSteps": [
                                    "Escreva a equação de continuidade integral e diferencial: ∂ρ/∂t + ∇·(ρv) = 0",
                                    "Escreva a equação de conservação de momento (Euler para fluidos invíscidos): ρ (∂v/∂t + (v·∇)v) = -∇p",
                                    "Identifique variáveis: densidade ρ, velocidade v, pressão p",
                                    "Discuta pressupostos iniciais: fluido homogêneo, newtoniano, sem viscosidade e sem forças externas",
                                    "Expresse em termos de perturbações: ρ = ρ₀ + ρ', p = p₀ + p', v = 0 + v' onde variáveis com ' são pequenas"
                                  ],
                                  "verification": "Equações de conservação escritas corretamente e pressupostos iniciais listados sem erros",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Dinâmica dos Fluidos (ex: Currie ou White)",
                                    "Caderno e calculadora simbólica (SymPy ou papel)"
                                  ],
                                  "tips": "Use notação vetorial consistente e defina o estado de equilíbrio (ρ₀, p₀ constantes, v=0)",
                                  "learningObjective": "Compreender as equações fundamentais de conservação aplicadas a fluidos compressíveis",
                                  "commonMistakes": [
                                    "Incluir viscosidade prematuramente",
                                    "Esquecer o termo convectivo (v·∇)v",
                                    "Confundir ρ e p como constantes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Linearizar as Equações para Pequenas Perturbações",
                                  "subSteps": [
                                    "Defina os pressupostos de linearização: |ρ'| << ρ₀, |v'| << c (c=velocidade do som), gradientes pequenos",
                                    "Linearize a continuidade: ∂ρ'/∂t + ρ₀ ∇·v' = 0 (negligencie produtos de perturbações)",
                                    "Linearize o momento: ρ₀ ∂v'/∂t = -∇p' (estado de base em repouso)",
                                    "Introduza a relação barotrópica linearizada: p' = c² ρ' onde c² = (∂p/∂ρ)_s = γ p₀ / ρ₀ para gas ideal",
                                    "Verifique consistência: todas as não-linearidades (ρ'v', v'·∇v') são desprezíveis de segunda ordem"
                                  ],
                                  "verification": "Equações linearizadas derivadas corretamente, mostrando negligência de termos quadráticos",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Folha de derivação",
                                    "Software de álgebra simbólica como Mathematica ou SymPy"
                                  ],
                                  "tips": "Expanda em série de Taylor em torno do equilíbrio e retenha apenas termos de primeira ordem",
                                  "learningObjective": "Dominar a linearização para aproximação acústica válida para pequenas amplitudes",
                                  "commonMistakes": [
                                    "Manter termos não-lineares como ρ'∇·v",
                                    "Esquecer fator ρ₀ na equação de momento",
                                    "Usar relação isotérmica em vez de adiabática"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Equação de Continuidade Linearizada",
                                  "subSteps": [
                                    "Parta da continuidade linearizada: ∂ρ'/∂t + ρ₀ ∇·v' = 0",
                                    "Substitua ρ' = p'/c² na equação",
                                    "Obtenha: (1/c²) ∂p'/∂t + ρ₀ ∇·v' = 0",
                                    "Diferencie temporalmente: (1/c²) ∂²p'/∂t² + ρ₀ ∂(∇·v')/∂t = 0",
                                    "Mantenha anotado o significado físico: conservação de massa para perturbações acústicas"
                                  ],
                                  "verification": "Equação de continuidade linearizada em termos de p' e v' correta e diferenciada no tempo",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Caderno de equações",
                                    "Referência: notas de acústica ou Landau Fluid Mechanics"
                                  ],
                                  "tips": "Use a identidade ∇·v' para compressibilidade acústica",
                                  "learningObjective": "Aplicar linearização para obter relação entre pressão e velocidade divergente",
                                  "commonMistakes": [
                                    "Inverter ρ₀ e 1/c²",
                                    "Diferenciar incorretamente o tempo",
                                    "Esquecer substituição p' = c² ρ'"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar a Equação de Momento Linearizada e Combinar",
                                  "subSteps": [
                                    "Da momento linearizada: ∂v'/∂t = - (1/ρ₀) ∇p'",
                                    "Aplique divergência: ∇·(∂v'/∂t) = - (1/ρ₀) ∇·(∇p') = - (1/ρ₀) ∇²p'",
                                    "Ou seja: ∂(∇·v')/∂t = - (1/ρ₀) ∇²p'",
                                    "Substitua na continuidade diferenciada: (1/c²) ∂²p'/∂t² - (1/c² ρ₀) ∇²p' = 0",
                                    "Simplifique para equação da onda: ∂²p'/∂t² = c² ∇²p'"
                                  ],
                                  "verification": "Equação da onda final ∂²p/∂t² = c² ∇²p obtida corretamente (dropando ' para notação acústica)",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora vetorial",
                                    "Exemplos resolvidos de livros de acústica"
                                  ],
                                  "tips": "Assuma campo irrotacional se necessário (∇×v'=0 para acústica), mas não essencial aqui",
                                  "learningObjective": "Combinar equações linearizadas para obter a PDE hiperbólica da onda acústica",
                                  "commonMistakes": [
                                    "Erro no sinal da divergência",
                                    "Confundir ∇²p com ∂²p/∂x² em 1D",
                                    "Fator c² incorreto (lembre c²=γR T)"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Destacar Pressupostos e Extensões",
                                  "subSteps": [
                                    "Liste pressupostos: pequenas perturbações, sem viscosidade/dissipação, fluido homogêneo, sem gravidade",
                                    "Verifique dimensionalmente: [c²] = L²/T² consistente",
                                    "Teste em 1D: reduza para ∂²p/∂t² = c² ∂²p/∂x² e solução d'Alembert",
                                    "Discuta limitações: não captura choques ou não-linearidades",
                                    "Conecte a potencial de velocidade φ: v=∇φ, p'=-ρ₀ ∂φ/∂t para irrotacional"
                                  ],
                                  "verification": "Pressupostos explicitados e verificação 1D realizada com solução de onda propagante",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Simulador online de ondas (PhET ou similar)",
                                    "Artigo clássico de Rayleigh sobre acústica"
                                  ],
                                  "tips": "Simule numericamente em 1D para validar (opcional com Python/MATLAB)",
                                  "learningObjective": "Garantir rigor matemático e compreensão das aproximações acústicas",
                                  "commonMistakes": [
                                    "Ignorar que linearização falha para amplitudes finitas",
                                    "Confundir adiabático com isotérmico (use γ>1)"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma onda sonora planar em ar confinado em um tubo longo (1D): derive ∂²p/∂t² = c² ∂²p/∂x² com c=√(γRT), aplique condições de contorno rígidas e encontre a solução viajante p(x,t)=A cos(kx-ωt) com ω=kc, simulando em software como MATLAB para visualizar propagação sem dispersão.",
                              "finalVerifications": [
                                "Equação da onda acústica ∂²p/∂t² = c² ∇²p derivada corretamente",
                                "Pressupostos de pequenas perturbações e linearização explicitados",
                                "Relação barotrópica p'=c²ρ' justificada (adiabática para gases)",
                                "Verificação em 1D com solução de onda viajante",
                                "Dimensões e unidades consistentes",
                                "Identificação de termos negligenciados (viscosidade, não-linearidades)"
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na linearização e derivação (sem erros algébricos)",
                                "Correta identificação e justificativa dos pressupostos acústicos",
                                "Clareza na transição de equações vetoriais para escalar (pressão)",
                                "Capacidade de reduzir a 1D e interpretar fisicamente",
                                "Rigor em verificações dimensionais e limitações",
                                "Originalidade na discussão de extensões (ex: irrotacional)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações diferenciais parciais hiperbólicas e métodos de características",
                                "Física: Mecânica de fluidos compressíveis e termodinâmica (processos adiabáticos)",
                                "Engenharia: Modelagem em elementos finitos para simulações acústicas (COMSOL)",
                                "Computação: Implementação numérica via diferenças finitas ou método dos elementos finitos",
                                "Química: Propriedades de fluidos reais (equação de estado não-ideal)"
                              ],
                              "realWorldApplication": "Projeto de sistemas de cancelamento ativo de ruído em aviões (usando equação da onda para prever propagação sonora), design de transdutores ultrassônicos para imagens médicas, ou otimização de caixas acústicas em alto-falantes para minimizar distorções harmônicas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "34.3.5.1.2",
                            "name": "Transformação para Equação de Helmholtz",
                            "description": "Explicar a transição da equação da onda no tempo para a equação de Helmholtz no domínio da frequência, introduzindo o potencial de pressão escalar p e o número de onda k = ω/c.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Equação da Onda Acústica no Domínio do Tempo",
                                  "subSteps": [
                                    "Estude a equação de onda linearizada para meios fluidos: ∇²p - (1/c²) ∂²p/∂t² = 0.",
                                    "Identifique os termos de laplaciano espacial e aceleração temporal.",
                                    "Discuta pressupostos: fluido incompressível, pequenas amplitudes, sem viscosidade.",
                                    "Derive brevemente a partir das equações de Navier-Stokes linearizadas.",
                                    "Resolva um caso 1D simples: onda plana p(x,t) = A cos(kx - ωt)."
                                  ],
                                  "verification": "Escreva a equação da onda e resolva analiticamente um caso 1D, confirmando que satisfaz a PDE.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de acústica (ex: Pierce 'Acoustics'), caderno, calculadora simbólica (SymPy ou Mathematica)"
                                  ],
                                  "tips": "Visualize ondas com animações online para intuitar o comportamento temporal.",
                                  "learningObjective": "Compreender a forma temporal da equação da onda e suas implicações físicas.",
                                  "commonMistakes": [
                                    "Confundir pressão p com velocidade de partícula; ignorar pressupostos de linearidade."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a Transformada de Fourier Temporal",
                                  "subSteps": [
                                    "Defina a transformada de Fourier: P(ω) = ∫ p(t) e^{-iωt} dt de -∞ a ∞.",
                                    "Aplique à equação da onda: transforme ∂²p/∂t² → -ω² P(ω).",
                                    "Transforme o laplaciano ∇²p(t) → ∇² P(ω), assumindo independência espacial.",
                                    "Obtenha a equação intermediária: ∇² P(ω) + (ω²/c²) P(ω) = 0.",
                                    "Verifique propriedades: invertibilidade e Parseval."
                                  ],
                                  "verification": "Aplique Fourier a uma função teste (ex: gaussiana) e inverta para confirmar recuperação.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software MATLAB/Python (numpy.fft), notas de Fourier analysis"
                                  ],
                                  "tips": "Use convenção e^{-iωt} para consistência com física; pratique com sinais reais.",
                                  "learningObjective": "Dominar a transição do domínio tempo para frequência via Fourier.",
                                  "commonMistakes": [
                                    "Erro no sinal da transformada (i vs -i); esquecer normalização 2π."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Equação de Helmholtz",
                                  "subSteps": [
                                    "Reescreva a equação transformada: ∇² P + k² P = 0, onde k = ω/c.",
                                    "Identifique k como número de onda complexo para meios dissipativos (opcional).",
                                    "Introduza o potencial de pressão escalar p( r ) = P(ω, r ) para notação simplificada.",
                                    "Discuta soluções: funções de Bessel, Hankel para 2D/3D; plano ondas e^{ik·r}.",
                                    "Compare com equação de Schrödinger ou Helmholtz clássica em eletromagnetismo."
                                  ],
                                  "verification": "Derive passo a passo da equação da onda para Helmholtz e resolva para onda esférica.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis para derivação, SymPy para verificação simbólica"
                                  ],
                                  "tips": "Mantenha unidades consistentes: k em rad/m, ω em rad/s, c em m/s.",
                                  "learningObjective": "Executar a derivação exata e reconhecer a forma de Helmholtz.",
                                  "commonMistakes": [
                                    "Inverter o sinal de k²; confundir k com 2π/λ."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e Aplicar Conceitos Chave: p e k",
                                  "subSteps": [
                                    "Explique p como amplitude complexa da pressão no domínio frequência.",
                                    "Discuta k = ω/c: relação dispersão para ondas acústicas não-dispersivas.",
                                    "Analise implicações: soluções harmônicas estacionárias, radiação.",
                                    "Implemente numericamente: resolva Helmholtz em 1D com diferenças finitas.",
                                    "Verifique com limite ω→0: equação de Laplace (quase-estática)."
                                  ],
                                  "verification": "Implemente código simples para resolver Helmholtz 1D e plote soluções para diferentes k.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python (scipy, matplotlib), Jupyter notebook"
                                  ],
                                  "tips": "Use malha uniforme para FD; teste convergência variando passos.",
                                  "learningObjective": "Interpretar fisicamente p e k e aplicar em simulações básicas.",
                                  "commonMistakes": [
                                    "Tratar p como real em vez de complexo; ignorar fase em k."
                                  ]
                                }
                              ],
                              "practicalExample": "Simule a propagação de uma onda harmônica em um tubo acústico fechado: aplique Helmholtz para prever modos ressonantes (f = nc/4L) e compare com medições experimentais usando microfone e speaker.",
                              "finalVerifications": [
                                "Deriva corretamente Helmholtz a partir da equação da onda em <10 minutos.",
                                "Explica o papel de k = ω/c em contextos físicos.",
                                "Implementa solução numérica 1D de Helmholtz com precisão <1%.",
                                "Identifica quando usar domínio tempo vs frequência.",
                                "Discute limitações (ex: não-linearidades)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (100% correta).",
                                "Compreensão conceitual de Fourier e k (explicação clara).",
                                "Habilidade computacional: código funcional e plots corretos.",
                                "Aplicação contextual: liga a acústica em EF.",
                                "Criatividade em exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de Fourier e PDEs elípticas.",
                                "Física: Ondas eletromagnéticas (equação de Helmholtz idêntica).",
                                "Computação: FFT em processamento de sinal/audio.",
                                "Engenharia Elétrica: Simulações acústicas em MEMS.",
                                "Programação: Métodos numéricos em FEM (COMSOL)."
                              ],
                              "realWorldApplication": "Modelagem de campos sonoros em design de salas de concerto, mufflers automotivos ou simulações de ruído aeronáutico usando software como ACTRAN ou ANSYS, otimizando atenuação para frequências específicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "34.3.5.1.1"
                            ]
                          },
                          {
                            "id": "34.3.5.1.3",
                            "name": "Propriedades dos Meios Fluidos em Acústica",
                            "description": "Identificar parâmetros materiais como densidade ρ, velocidade do som c e coeficiente de absorção, e seu impacto na propagação de ondas em simulações numéricas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais dos Parâmetros Materiais",
                                  "subSteps": [
                                    "Estude a definição de densidade ρ (massa por unidade de volume) e sua unidade (kg/m³).",
                                    "Analise a velocidade do som c (m/s), derivada de c = √(K/ρ), onde K é o módulo de compressibilidade.",
                                    "Explore o coeficiente de absorção α, que quantifica a fração de energia sonora dissipada, variando de 0 (perfeita reflexão) a 1 (absorção total).",
                                    "Revise equações básicas da acústica linear: equação de onda p_tt = c² ∇²p em fluidos.",
                                    "Compare valores típicos: ar (ρ=1.2 kg/m³, c=343 m/s), água (ρ=1000 kg/m³, c=1480 m/s)."
                                  ],
                                  "verification": "Resuma em um diagrama os três parâmetros, suas unidades e um valor exemplo para ar e água.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Acústica (ex: Pierce 'Acoustics'), calculadora, notas de aula"
                                  ],
                                  "tips": "Use analogias: ρ como 'inércia do fluido', c como 'rigidez de propagação'.",
                                  "learningObjective": "Definir precisamente ρ, c e α e listar suas unidades e valores típicos em fluidos comuns.",
                                  "commonMistakes": [
                                    "Confundir c com velocidade de partículas (u << c), ignorar dependência de temperatura em c."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Impacto dos Parâmetros na Propagação de Ondas",
                                  "subSteps": [
                                    "Derive qualitativamente: alto ρ reduz c e aumenta impedância Z=ρc, afetando transmissão/reflexão.",
                                    "Simule graficamente: ondas em meios com ρ baixo/alto, mostrando atenuação e velocidade.",
                                    "Estude absorção: equação de atenuação α f² (frequência dependente), plotando decay exponencial.",
                                    "Calcule impedância acústica Z=ρc e coeficiente de reflexão R=(Z2-Z1)/(Z2+Z1) para interfaces.",
                                    "Discuta dispersão e não-linearidades em altos níveis, mas foque em regime linear."
                                  ],
                                  "verification": "Crie uma tabela comparando propagação em ar vs água para uma onda de 1 kHz.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de plotagem (Matlab/Python/Mathematica), artigos sobre acústica de fluidos"
                                  ],
                                  "tips": "Visualize com simulações 1D simples: resolva equação de onda numericamente.",
                                  "learningObjective": "Explicar como variações em ρ, c e α alteram velocidade, atenuação e reflexão de ondas sonoras.",
                                  "commonMistakes": [
                                    "Esquecer que α é frequência-dependente, confundir absorção com espalhamento."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Parâmetros em Simulações Numéricas Básicas",
                                  "subSteps": [
                                    "Configure um modelo 1D no Python/Matlab: discretize equação de onda com diferenças finitas.",
                                    "Insira parâmetros variáveis: defina ρ, c, α como inputs e aplique termo de amortecimento -2α c ∇p.",
                                    "Rode simulações: plano de onda em tubo com mudança de meio, variando ρ e c.",
                                    "Adicione absorção: implemente condições de contorno com lei de massa ou PML.",
                                    "Valide: compare com soluções analíticas para onda plana em meio infinito."
                                  ],
                                  "verification": "Gere plots de pressão vs tempo em pontos de monitoramento para cenários base e alterados.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy/Matplotlib, tutoriais de FDTD acústico"
                                  ],
                                  "tips": "Comece com malha grosseira (Δx = λ/20) para testes rápidos, refine depois.",
                                  "learningObjective": "Configurar e executar simulações numéricas incorporando ρ, c e α corretamente.",
                                  "commonMistakes": [
                                    "Malha inadequada causando dispersão numérica, esquecendo fator de normalização em α."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Interpretar Resultados de Simulações",
                                  "subSteps": [
                                    "Varie parâmetros sistematicamente: ±20% em ρ, c, α e observe picos, atenuação e fase.",
                                    "Calcule métricas: tempo de propagação, perda de energia (∫p² dt), fator de qualidade Q.",
                                    "Compare com teoria: verifique se Δc afeta comprimento de onda λ=f/c corretamente.",
                                    "Identifique sensibilidade: plote resposta em frequência para diferentes α.",
                                    "Documente achados em relatório com gráficos e conclusões quantitativas."
                                  ],
                                  "verification": "Explique em 3-5 frases como dobrar ρ afeta a simulação, suportado por evidências gráficas.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Software de simulação, template de relatório LaTeX/Word"
                                  ],
                                  "tips": "Use loops paramétricos para sweeps eficientes; normalize amplitudes iniciais.",
                                  "learningObjective": "Interpretar impactos quantitativos dos parâmetros em saídas de simulações acústicas.",
                                  "commonMistakes": [
                                    "Ignorar efeitos de borda em simulações finitas, superestimar α em baixas frequências."
                                  ]
                                }
                              ],
                              "practicalExample": "Simule a propagação de uma onda sonora de 500 Hz em um tubo preenchido com ar (ρ=1.2, c=343), depois substitua metade por água (ρ=1000, c=1480) com α=0.01 na interface. Observe reflexão total devido a mismatch de Z e atenuação gradual.",
                              "finalVerifications": [
                                "Liste e defina ρ, c e α com unidades e exemplos numéricos.",
                                "Explique o impacto de aumentar ρ em 50% na velocidade e impedância.",
                                "Rode uma simulação simples e interprete um gráfico de pressão.",
                                "Calcule R para ar-espuma (α alta) vs ar-parede rígida.",
                                "Identifique erro comum em simulações de absorção."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas e relações matemáticas (30%)",
                                "Análise qualitativa/quantitativa: impactos explicados com evidências (25%)",
                                "Proficiência em simulação: código funcional e plots corretos (25%)",
                                "Interpretação crítica: sensibilidade e limitações discutidas (15%)",
                                "Clareza e organização: relatórios com diagramas e conclusões (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Física: Mecânica de fluidos e ondas (equação de Navier-Stokes linearizada)",
                                "Matemática: Equações diferenciais parciais e métodos numéricos (diferenças finitas)",
                                "Computação: Programação científica (Python/NumPy para PDEs)",
                                "Engenharia Civil: Controle de ruído em edifícios",
                                "Biologia: Bioacústica em tecidos (ρ e c em água vs ar)"
                              ],
                              "realWorldApplication": "No design de estúdios de gravação, otimizar painéis absorvedores ajustando α para frequências específicas; em engenharia submarina, modelar sonar prevendo atenuação em oceanos variando ρ e c com salinidade."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "34.3.5.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "34.3.5.2",
                        "name": "Formulação Variacional do Problema de Helmholtz",
                        "description": "Desenvolvimento da formulação fraca ou variacional da equação de Helmholtz para problemas de acústica, preparando para a aplicação do método dos elementos finitos como problema de campo escalar.",
                        "specificSkills": [
                          {
                            "id": "34.3.5.2.1",
                            "name": "Formulação Fraca da Equação de Helmholtz",
                            "description": "Obter a forma integral fraca multiplicando pela função teste, integrando por partes e identificando termos de rigidez, massa e fontes, para domínios arbitrários.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão da Equação Forte de Helmholtz",
                                  "subSteps": [
                                    "Escreva a equação diferencial de Helmholtz na forma forte: -∇²u + k²u = f em Ω.",
                                    "Defina o domínio Ω arbitrário e as condições de contorno (Dirichlet ou Neumann).",
                                    "Identifique os termos físico-matemáticos: laplaciano (rigidez), termo de massa (k²u) e fonte f.",
                                    "Discuta o espaço de funções adequadas (H¹(Ω)) para soluções fracas.",
                                    "Verifique a consistência dimensional dos termos."
                                  ],
                                  "verification": "Conferir se a equação forte está corretamente anotada e os termos identificados em um caderno ou software simbólico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Elementos Finitos (ex: Zienkiewicz)",
                                    "Papel e caneta",
                                    "Software como Mathematica ou SymPy"
                                  ],
                                  "tips": "Comece sempre pela forma padrão para evitar confusões com variações da equação.",
                                  "learningObjective": "Compreender a equação forte como base para a derivação da forma fraca.",
                                  "commonMistakes": "Confundir o sinal do laplaciano ou o termo de massa; inverter k²u para -k²u."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introdução da Função Teste e Integração Inicial",
                                  "subSteps": [
                                    "Escolha uma função teste v ∈ H¹(Ω) suave e com suporte compacto ou satisfazendo condições de contorno.",
                                    "Multiplique a equação forte por v e integre sobre o domínio Ω: ∫_Ω v(-∇²u + k²u - f) dΩ = 0.",
                                    "Reescreva como ∫_Ω v ∇²u dΩ - k² ∫_Ω v u dΩ + ∫_Ω v f dΩ = 0.",
                                    "Discuta a Galerkin orthogonality: a equação vale para todo v no espaço de teste.",
                                    "Anote a forma integral inicial antes da integração por partes."
                                  ],
                                  "verification": "Verificar se a integral inicial está balanceada e igual a zero para soluções clássicas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Caderno de anotações",
                                    "Calculadora simbólica",
                                    "Referência: Hughes 'The Finite Element Method'"
                                  ],
                                  "tips": "Use v vanishing na fronteira se condições homogêneas para simplificar.",
                                  "learningObjective": "Aplicar o método de multiplicação por função teste para obter a forma integral.",
                                  "commonMistakes": "Esquecer o sinal negativo no laplaciano ou não integrar corretamente o termo fonte."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicação da Integração por Partes",
                                  "subSteps": [
                                    "Aplique o teorema da integração por partes (Green's first identity) ao termo ∫ v ∇²u dΩ.",
                                    "Obtenha: ∫_Ω ∇v · ∇u dΩ - ∫_∂Ω v ∂u/∂n dS - k² ∫_Ω v u dΩ + ∫_Ω v f dΩ = 0.",
                                    "Discuta o tratamento do termo de contorno ∫_∂Ω dependendo das condições (Neumann ou Dirichlet).",
                                    "Para domínios arbitrários, assuma v=0 em Γ_D para eliminar termos Dirichlet.",
                                    "Simplifique para obter a forma bilinear simétrica."
                                  ],
                                  "verification": "Comparar o resultado com a identidade de Green anotada em referência padrão.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": [
                                    "Quadro branco ou tablet gráfico",
                                    "SymPy para verificação simbólica",
                                    "Notas de análise funcional"
                                  ],
                                  "tips": "Lembre-se: integração por partes move derivadas de u para v, criando termos de rigidez.",
                                  "learningObjective": "Dominar a integração por partes para transferir regularidade da solução forte para fraca.",
                                  "commonMistakes": "Erro no sinal do termo de contorno ou confundir ∇v · ∇u com ∇u · ∇v (deve ser simétrico)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificação dos Termos e Formulação Final da Forma Fraca",
                                  "subSteps": [
                                    "Identifique o termo de rigidez: ∫_Ω ∇u · ∇v dΩ.",
                                    "Identifique o termo de massa: -k² ∫_Ω u v dΩ.",
                                    "Identifique o termo de fonte: ∫_Ω f v dΩ (mais termos de contorno se Neumann).",
                                    "Escreva a forma fraca: Encontre u ∈ V tal que a(u,v) = l(v) ∀ v ∈ V, onde a(u,v) = ∫∇u∇v - k²∫uv, l(v)=∫fv.",
                                    "Verifique propriedades: bilinearidade, coercividade e continuidade para existência/unicidade."
                                  ],
                                  "verification": "Testar com uma solução conhecida exata (ex: u=sen(kx)) e verificar se satisfaz a forma fraca.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software MATLAB ou Python (FEniCS para demo)",
                                    "Exemplos resolvidos de acústica"
                                  ],
                                  "tips": "Nomeie explicitamente K (rigidez), M (massa) para visualização em MEF.",
                                  "learningObjective": "Reconhecer e nomear os termos padrão usados em métodos numéricos como Elementos Finitos.",
                                  "commonMistakes": "Omitir o sinal negativo no termo de massa ou confundir l(v) com termos de contorno."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validação para Domínios Arbitrários e Considerações Numéricas",
                                  "subSteps": [
                                    "Discuta generalização para Ω irregular via triangulação em MEF.",
                                    "Inclua condições mistas de contorno na forma fraca.",
                                    "Verifique consistência: soluções fortes satisfazem a forma fraca.",
                                    "Implemente um exemplo simples em código para discretização.",
                                    "Analise estabilidade numérica (condição de Courant-Friedrichs-Lewy para acústica)."
                                  ],
                                  "verification": "Executar código simples e comparar com solução analítica.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": [
                                    "Python com FEniCS ou deal.II",
                                    "Exemplo de malha 1D/2D"
                                  ],
                                  "tips": "Use malhas não estruturadas para demonstrar arbitrariedade do domínio.",
                                  "learningObjective": "Aplicar a formulação fraca em contextos computacionais reais.",
                                  "commonMistakes": "Ignorar condições de contorno não homogêneas ou superfícies de integração erradas."
                                }
                              ],
                              "practicalExample": "Considere a equação de Helmholtz em 1D: -u'' + k²u = f em [0,1], u(0)=0, u'(1)=0. Multiplique por v (v(0)=0), integre: ∫u'v' - k²∫uv = ∫fv + v(1)u'(1). Discretize com 2 elementos finitos e resolva o sistema Ku - k²Mu = F.",
                              "finalVerifications": [
                                "Derivação correta da forma a(u,v) = ∫∇u∇v - k²∫uv dΩ.",
                                "Tratamento adequado dos termos de contorno para domínios arbitrários.",
                                "Identificação precisa de rigidez (∇u∇v), massa (-k²uv) e fontes (fv).",
                                "Verificação de que soluções clássicas satisfazem a forma fraca.",
                                "Implementação numérica simples converge para solução conhecida.",
                                "Análise de propriedades (simetria, coercividade) confirmada."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (sem erros de sinal ou integração).",
                                "Clareza na identificação e nomenclatura dos termos (rigidez, massa, fontes).",
                                "Correto tratamento de condições de contorno e domínios irregulares.",
                                "Profundidade nos subpassos com pelo menos 4 ações por step.",
                                "Validação prática via exemplo numérico ou código.",
                                "Conexão com aplicações em MEF para acústica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Espaços de Sobolev e Análise Funcional (H¹(Ω)).",
                                "Física: Teoria de Ondas Acústicas e Propagação Sonora.",
                                "Computação: Programação Numérica e Métodos de Elementos Finitos (FEniCS, deal.II).",
                                "Engenharia: Simulações em Vibroacústica e Controle de Ruído."
                              ],
                              "realWorldApplication": "Essa formulação é essencial em simulações numéricas de propagação de ondas sonoras em ambientes complexos, como salas de concerto, automóveis ou turbinas eólicas, permitindo otimizar isolamento acústico e design de alto-falantes via software CAE como ANSYS ou COMSOL."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.3.5.1.2"
                            ]
                          },
                          {
                            "id": "34.3.5.2.2",
                            "name": "Condições de Contorno em Acústica",
                            "description": "Classificar e formular condições de contorno de Dirichlet (pressão rígida), Neumann (velocidade normal zero) e Robin (impedância de radiação), essenciais para simulações realistas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Fundamentos das Condições de Contorno no Problema de Helmholtz em Acústica",
                                  "subSteps": [
                                    "Estudar a equação de Helmholtz: ∇²p + k²p = 0, onde p é o campo de pressão e k o número de onda.",
                                    "Identificar as fronteiras do domínio: paredes rígidas, absorventes, fontes e radiação externa.",
                                    "Revisar princípios físicos: conservação de massa, momentum e relação pressão-velocidade em superfícies.",
                                    "Classificar tipos genéricos: Dirichlet (valor de p fixo), Neumann (derivada normal ∂p/∂n fixo) e Robin (combinação linear)."
                                  ],
                                  "verification": "Resumir em um diagrama as diferenças físicas entre cada tipo de condição de contorno.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Livro 'Finite Element Methods for Acoustics' de Bjørnsson",
                                    "Notas de aula sobre equação de Helmholtz",
                                    "Software MATLAB ou Python (SymPy)"
                                  ],
                                  "tips": "Visualize com analogias: Dirichlet como temperatura fixa, Neumann como fluxo isolado.",
                                  "learningObjective": "Compreender a base matemática e física das condições de contorno em problemas acústicos.",
                                  "commonMistakes": [
                                    "Confundir pressão com velocidade",
                                    "Ignorar o número de onda k na formulação",
                                    "Não considerar o domínio 2D/3D"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formulação da Condição de Dirichlet (Pressão Rígida)",
                                  "subSteps": [
                                    "Definir Dirichlet: p = g na fronteira Γ_D, onde g é pressão especificada (ex: p=0 para superfície perfeitamente absorvente).",
                                    "Derivar fisicamente: corresponde a uma parede com pressão imposta, como em cavidades ressonantes.",
                                    "Implementar na formulação variacional: restringir o espaço de funções teste/trial com p|g=0.",
                                    "Exemplo numérico: Resolver Helmholtz em 1D com p(0)=0 e p(L)=1.",
                                    "Testar em software: Configurar malha EF com BC Dirichlet."
                                  ],
                                  "verification": "Implementar e plotar solução analítica vs. numérica em domínio simples.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "COMSOL Multiphysics ou FreeFEM",
                                    "Planilha Excel para soluções 1D",
                                    "Artigos sobre acústica computacional"
                                  ],
                                  "tips": "Use p=0 para simplificar em paredes 'rígidas' ideais, mas valide fisicamente.",
                                  "learningObjective": "Formular e aplicar Dirichlet em simulações acústicas realistas.",
                                  "commonMistakes": [
                                    "Aplicar Dirichlet em paredes rígidas (use Neumann)",
                                    "Esquecer normalização da pressão",
                                    "Malha inadequada na fronteira"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formulação da Condição de Neumann (Velocidade Normal Zero)",
                                  "subSteps": [
                                    "Definir Neumann: ∂p/∂n = h na fronteira Γ_N, onde h=0 para velocidade normal nula (parede rígida).",
                                    "Explicar fisicamente: Sem fluxo acústico através da superfície, ideal para materiais infinitamente densos.",
                                    "Integrar na variacional: Termo natural, surge da integração por partes ∫_Γ (∂p/∂n) v dΓ.",
                                    "Exemplo: Tubo fechado em uma extremidade com ∂p/∂x=0.",
                                    "Simular: Configurar EF com Neumann homogêneo e validar modos ressonantes."
                                  ],
                                  "verification": "Calcular frequências ressonantes de uma cavidade e comparar com teoria.",
                                  "estimatedTime": "1.5-2 horas",
                                  "materials": [
                                    "Ansys ou Code_Aster",
                                    "Tutoriais YouTube sobre EF acústico",
                                    "Caderno para derivações manuais"
                                  ],
                                  "tips": "Neumann é 'natural' em EF, menos sensível a malhas grosseiras.",
                                  "learningObjective": "Dominar Neumann para modelar barreiras impermeáveis ao som.",
                                  "commonMistakes": [
                                    "Confundir com Dirichlet para paredes rígidas",
                                    "Não tratar h não-nulo corretamente",
                                    "Instabilidade numérica em domínios abertos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formulação da Condição de Robin (Impedância de Radiação) e Integração",
                                  "subSteps": [
                                    "Definir Robin: ∂p/∂n + i k β p = 0 na Γ_R, onde β é coeficiente de impedância normalizado.",
                                    "Derivar: Baseado em relação p = Z v_n, com Z impedância específica.",
                                    "Incorporar variacional: Adiciona termo bilinear ∫_Γ β p v dΓ.",
                                    "Aplicar em cenários reais: Radiação em aberturas, absorvedores porosos.",
                                    "Verificar: Simular atenuação em muffler com Robin misto."
                                  ],
                                  "verification": "Gerar gráfico de módulo de pressão com variação de β e analisar atenuação.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Documentação FEniCS para Robin BC",
                                    "Dados experimentais de impedância acústica",
                                    "Python com NumPy/SciPy"
                                  ],
                                  "tips": "Comece com β→∞ (Dirichlet) e β→0 (Neumann) para validar limites.",
                                  "learningObjective": "Formular Robin para simulações realistas com perdas e radiação.",
                                  "commonMistakes": [
                                    "Sinal errado no termo i k β",
                                    "Ignorar dependência freqüencial de Z",
                                    "Sobreposição de condições em vértices"
                                  ]
                                }
                              ],
                              "practicalExample": "Modelar acusticamente um silenciador automotivo: Aplicar Neumann (∂p/∂n=0) nas paredes rígidas, Dirichlet (p=0) na entrada com pressão conhecida e Robin (impedância) na saída para simular radiação livre, calculando atenuação de transmissão em 500-2000 Hz.",
                              "finalVerifications": [
                                "Classificar corretamente Dirichlet, Neumann e Robin com exemplos físicos.",
                                "Derivar a integração por partes para cada condição na formulação variacional.",
                                "Implementar todas em um solver EF simples e validar contra solução analítica.",
                                "Analisar estabilidade numérica com malhas refinadas nas fronteiras.",
                                "Prever comportamento limite: β→0 e β→∞.",
                                "Documentar um relatório com gráficos de pressão e velocidades."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas formulações (sem erros algébricos).",
                                "Correta interpretação física e aplicação em contextos reais.",
                                "Eficiência na implementação EF (convergência <5% erro).",
                                "Criatividade em exemplos práticos e conexões interdisciplinares.",
                                "Clareza na verificação e tratamento de erros comuns.",
                                "Domínio de ferramentas computacionais para simulação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise funcional e espaços de Sobolev para fraquezas.",
                                "Física: Teoria de ondas e propriedades de materiais porosos.",
                                "Engenharia Civil: Isolamento acústico em edifícios.",
                                "Computação: Programação de solvers EF em Python/FEniCS.",
                                "Engenharia Elétrica: Modelagem de transdutores piezoelétricos."
                              ],
                              "realWorldApplication": "No design de estúdios de gravação, aplicar Neumann em paredes rígidas e Robin em painéis absorventes para minimizar reflexões; em automotivo, otimizar mufflers reduzindo ruído de escapamento via simulações precisas de impedância."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "34.3.5.2.1"
                            ]
                          },
                          {
                            "id": "34.3.5.2.3",
                            "name": "Princípio da Estacionariedade Variacional",
                            "description": "Aplicar o princípio de Rayleigh-Ritz ou Galerkin para aproximar a solução exata pela minimização do funcional de energia associado à equação de Helmholtz.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos do Princípio da Estacionariedade Variacional",
                                  "subSteps": [
                                    "Estude a definição do princípio da estacionariedade variacional e sua relação com o cálculo variacional.",
                                    "Revise a equação de Helmholtz: ∇²u + k²u = 0, e derive o funcional de energia associado.",
                                    "Analise como a minimização do funcional leva à solução exata.",
                                    "Compare com princípios semelhantes em mecânica (ex.: energia potencial).",
                                    "Resolva um exemplo analítico simples em 1D para fixar conceitos."
                                  ],
                                  "verification": "Derive corretamente o funcional de energia para a equação de Helmholtz em uma dimensão.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Notas de aula sobre cálculo variacional",
                                    "Livro 'Métodos dos Elementos Finitos' de Zienkiewicz",
                                    "Software simbólico como Mathematica ou SymPy"
                                  ],
                                  "tips": "Comece com problemas 1D para visualizar a minimização; use gráficos de funções de teste.",
                                  "learningObjective": "Entender a base teórica do princípio e formular o funcional de energia para problemas de Helmholtz.",
                                  "commonMistakes": [
                                    "Confundir o funcional bilinear com linear",
                                    "Ignorar termos de contorno na derivação",
                                    "Esquecer a normalização da função de teste"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar os Métodos Rayleigh-Ritz e Galerkin",
                                  "subSteps": [
                                    "Estude o método Rayleigh-Ritz: escolha funções de aproximação e minimize o funcional.",
                                    "Aprenda o método Galerkin: use funções de teste ortogonais ao resíduo.",
                                    "Compare as diferenças e semelhanças entre os dois métodos para Helmholtz.",
                                    "Implemente um exemplo numérico simples com 2-3 funções base em 1D.",
                                    "Calcule os autovalores aproximados e compare com soluções exatas."
                                  ],
                                  "verification": "Aplique Rayleigh-Ritz a um problema 1D e obtenha coeficientes corretos.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Artigos sobre métodos variacionais em acústica",
                                    "Python com NumPy/SciPy para cálculos matriciais",
                                    "Exemplos resolvidos de problemas de autovalores"
                                  ],
                                  "tips": "Escolha funções base sinusoidais para problemas acústicos; verifique ortogonalidade.",
                                  "learningObjective": "Dominar a aplicação prática de Rayleigh-Ritz e Galerkin na minimização variacional.",
                                  "commonMistakes": [
                                    "Funções base não satisfazendo condições de contorno",
                                    "Erro na montagem da matriz de rigidez",
                                    "Confundir autovalores com autofunções"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular e Resolver um Problema de Helmholtz em 2D",
                                  "subSteps": [
                                    "Defina um domínio 2D simples (ex.: quadrado com contornos Dirichlet).",
                                    "Escreva o funcional de energia total: I(u) = ∫ (∇u·∇u - k²u²) dΩ.",
                                    "Aplique Rayleigh-Ritz com funções base polinomiais ou modais.",
                                    "Monte as matrizes de massa e rigidez discretizadas.",
                                    "Resolva o sistema generalizado de autovalores: Kφ = λMφ."
                                  ],
                                  "verification": "Obtenha uma aproximação convergente para o primeiro modo de ressonância.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Software FEniCS ou MATLAB para elementos finitos",
                                    "Papel e lápis para derivações manuais",
                                    "Referências sobre formulações fracas"
                                  ],
                                  "tips": "Use malha uniforme inicial; refine para observar convergência.",
                                  "learningObjective": "Formular e minimizar o funcional para problemas reais de acústica em 2D.",
                                  "commonMistakes": [
                                    "Integração numérica incorreta nos elementos",
                                    "Escolha inadequada de k (número de onda)",
                                    "Não normalizar as funções base"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Verificar a Aproximação",
                                  "subSteps": [
                                    "Compare resultados aproximados com soluções exatas ou referências.",
                                    "Calcule erros relativos em autovalores e autovetores.",
                                    "Aplique Galerkin para o mesmo problema e compare convergência.",
                                    "Estude o impacto do número de graus de liberdade na precisão.",
                                    "Documente os resultados em um relatório com gráficos de modos."
                                  ],
                                  "verification": "Produza gráficos mostrando convergência e erros <5% para os primeiros modos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python/MATLAB para plotagem (Matplotlib)",
                                    "Dados de benchmark de problemas acústicos"
                                  ],
                                  "tips": "Use norma L2 para medir erro; foque em modos baixos primeiro.",
                                  "learningObjective": "Avaliar a qualidade da aproximação variacional e otimizar escolhas.",
                                  "commonMistakes": [
                                    "Ignorar efeitos de malha grossa",
                                    "Comparação com soluções erradas",
                                    "Não considerar simetria do problema"
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva numericamente as frequências de ressonância de uma cavidade acústica retangular de 1m x 0.5m, com contornos rígidos em três lados e absorvente em um, usando Rayleigh-Ritz com 4 funções base por direção para aproximar os primeiros 3 modos.",
                              "finalVerifications": [
                                "Derivar o funcional de energia para Helmholtz corretamente.",
                                "Montar matrizes K e M para um problema 2D.",
                                "Resolver sistema de autovalores e obter convergência.",
                                "Comparar com solução exata com erro <3%.",
                                "Explicar diferenças entre Rayleigh-Ritz e Galerkin.",
                                "Aplicar em um exemplo prático com relatório."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática na derivação do funcional (peso 25%).",
                                "Precisão da aproximação numérica e análise de erro (peso 30%).",
                                "Escolha adequada de funções base e convergência (peso 20%).",
                                "Clareza na documentação e gráficos de resultados (peso 15%).",
                                "Compreensão conceitual via explicação oral/escrita (peso 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e autovalores.",
                                "Física: Teoria de ondas acústicas e vibrações.",
                                "Computação: Programação numérica e elementos finitos.",
                                "Engenharia Civil: Análise modal de estruturas.",
                                "Engenharia Elétrica: Simulação de campos eletromagnéticos análogos."
                              ],
                              "realWorldApplication": "Aplicado no método dos elementos finitos para simular propagação sonora em salas, design de mufflers automotivos, otimização acústica de auditórios e redução de vibrações em turbinas eólicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "34.3.5.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "34.3.5.3",
                        "name": "Discretização e Solução pelo Método dos Elementos Finitos",
                        "description": "Implementação prática do MEF para simular propagação acústica, incluindo escolha de elementos, montagem de matrizes e resolução do sistema eigenvalue ou forçado.",
                        "specificSkills": [
                          {
                            "id": "34.3.5.3.1",
                            "name": "Escolha de Elementos Finitos para Campo Escalar",
                            "description": "Selecionar e descrever elementos lineares (triangular CST, quadrilateral 4-nós) e quadráticos para malhas 2D/3D em problemas acústicos, considerando precisão e custo computacional.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Elementos Finitos para Campos Escalares em Acústica",
                                  "subSteps": [
                                    "Estudar a equação de Helmholtz para problemas acústicos: ∇²p + k²p = 0, onde p é o campo de pressão e k o número de onda.",
                                    "Compreender a discretização pelo Método dos Elementos Finitos (MEF) para campos escalares.",
                                    "Identificar requisitos de elementos finitos: continuidade C0 para pressão acústica.",
                                    "Explorar diferenças entre malhas 2D (plana) e 3D (volume) em simulações acústicas.",
                                    "Analisar o papel da malha na precisão da solução numérica."
                                  ],
                                  "verification": "Resumir em um diagrama os componentes chave do MEF para acústica e listar 3 diferenças entre 2D e 3D.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Livro 'Finite Element Method' de Zienkiewicz; vídeo tutorial sobre equação de Helmholtz no YouTube; software gratuito como FreeFEM.",
                                  "tips": "Use analogias com molas para visualizar discretização.",
                                  "learningObjective": "Entender os princípios básicos que guiam a escolha de elementos em problemas acústicos.",
                                  "commonMistakes": "Confundir continuidade C0 com C1; ignorar dependência do número de onda k."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Elementos Lineares: Triangular CST e Quadrilateral 4-Nós",
                                  "subSteps": [
                                    "Descrever o elemento triangular CST (Constant Strain Triangle): 3 nós, interpolação linear.",
                                    "Detalhar o quadrilateral 4-nós (Q4): funções de forma bilinear, isoparamétrico.",
                                    "Calcular graus de liberdade (DoF): 1 por nó para campo escalar.",
                                    "Simular uma malha simples 2D e 3D (tetraedro linear equivalente) em software.",
                                    "Avaliar distorção geométrica e locking em elementos lineares."
                                  ],
                                  "verification": "Gerar malha com 10 elementos e plotar campo de pressão aproximado vs. exato.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Software ANSYS Student ou Gmsh; template de malha .geo; artigo sobre elementos CST.",
                                  "tips": "Comece com malhas regulares para evitar distorções iniciais.",
                                  "learningObjective": "Dominar características e limitações de elementos lineares em acústica.",
                                  "commonMistakes": "Subestimar shear locking em quadriláteros distorcidos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Elementos Quadráticos e Comparar com Lineares",
                                  "subSteps": [
                                    "Estudar triangular 6-nós e quadrilateral 8/9-nós: interpolação quadrática.",
                                    "Comparar precisão: convergência quadrática vs. linear.",
                                    "Calcular custo computacional: DoF dobrados, matriz de rigidez ~4x maior.",
                                    "Testar em malha 3D (hexaedro quadrático vs. linear).",
                                    "Analisar trade-offs para diferentes números de onda k."
                                  ],
                                  "verification": "Criar tabela comparativa de precisão (erro L2) e tempo de CPU para ambos tipos.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Software COMSOL ou Code_Aster; planilha Excel para benchmarks; paper IEEE sobre elementos em acústica.",
                                  "tips": "Use refinamento h vs. p para demonstrar superioridade quadrática.",
                                  "learningObjective": "Comparar quantitativamente lineares e quadráticos em precisão e custo.",
                                  "commonMistakes": "Ignorar custo não-linear em 3D devido a mais DoF."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Desenvolver Critérios de Seleção para Problemas Acústicos 2D/3D",
                                  "subSteps": [
                                    "Definir critérios: precisão requerida (erro <5%), custo (tempo <1h), comprimento de onda λ.",
                                    "Selecionar baseado em k*h <1 (h=tamanho elemento) para lineares; flexível para quadráticos.",
                                    "Justificar escolha: lineares para malhas grosseiras/custo baixo; quadráticos para alta precisão.",
                                    "Aplicar em cenários: baixa frequência (lineares), alta (quadráticos).",
                                    "Documentar decisão em relatório com gráficos de convergência."
                                  ],
                                  "verification": "Produzir fluxograma de decisão para escolha de elemento baseado em parâmetros do problema.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Ferramenta Draw.io para fluxograma; dados de simulações anteriores.",
                                  "tips": "Priorize custo para protótipos iniciais.",
                                  "learningObjective": "Formular processo decisório otimizado para elementos finitos em acústica.",
                                  "commonMistakes": "Escolher quadráticos sem necessidade, inflando tempo computacional."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar Escolha em Simulação Prática",
                                  "subSteps": [
                                    "Escolher elemento para problema teste (ex: cavidade 2D).",
                                    "Executar simulação com linear e quadrático, comparar resultados.",
                                    "Analisar mesh independence e computational efficiency.",
                                    "Ajustar escolha baseado em métricas.",
                                    "Relatar recomendações finais."
                                  ],
                                  "verification": "Relatório com plots de pressão e tabela de trade-offs.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Software MEF; benchmark problems de acústica.",
                                  "tips": "Monitore uso de RAM em 3D.",
                                  "learningObjective": "Aplicar e validar critérios de seleção na prática.",
                                  "commonMistakes": "Não normalizar erros por DoF."
                                }
                              ],
                              "practicalExample": "Em uma simulação de ruído em um painel automotivo 2D (malha ~1000 elementos), use elementos lineares Q4 para protótipo rápido (erro 8%, 5min CPU); mude para quadráticos 8-nós para precisão final (erro 2%, 20min CPU).",
                              "finalVerifications": [
                                "Tabela comparativa de precisão e custo para lineares vs. quadráticos.",
                                "Fluxograma de decisão funcional para novos problemas.",
                                "Simulação validada com erro <5% em exemplo prático.",
                                "Relatório descrevendo elementos para 2D e 3D.",
                                "Gráficos de convergência confirmando trade-offs.",
                                "Lista de critérios personalizados para acústica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de funções de forma (90% correto).",
                                "Análise quantitativa de custo vs. precisão (com métricas).",
                                "Justificativa contextual para 2D/3D acústica.",
                                "Identificação correta de limitações (locking, DoF).",
                                "Fluxograma lógico e acionável.",
                                "Exemplo prático com simulação executada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções de interpolação polinomial e análise de erro.",
                                "Física: Teoria de ondas acústicas e equação de Helmholtz.",
                                "Computação: Otimização de malhas e paralelização em MEF.",
                                "Engenharia de Materiais: Propriedades acústicas de meios."
                              ],
                              "realWorldApplication": "Na indústria automotiva, otimizar elementos finitos para simular ruído de escapamento, reduzindo protótipos físicos e acelerando design de silenciadores com equilíbrio entre precisão NVH e tempo de simulação."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "34.3.5.2.1"
                            ]
                          },
                          {
                            "id": "34.3.5.3.2",
                            "name": "Montagem das Matrizes Globais",
                            "description": "Derivar e montar as matrizes de rigidez [K] = ∫∇N^T ∇N dΩ e de massa [M] = ∫N^T N dΩ por elemento, com integração numérica Gauss para elementos isoparamétricos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Derivação das Expressões das Matrizes Elementares",
                                  "subSteps": [
                                    "Revise a formulação fraca do problema de acústica: encontrar u tal que ∫∇u·∇v dΩ - ω²∫uv dΩ = ∫f v dΩ para todo v teste.",
                                    "Identifique as matrizes elementares: [Ke] = ∫_Ωe ∇N^T ∇N dΩ e [Me] = ∫_Ωe N^T N dΩ, onde N são funções de forma.",
                                    "Escreva explicitamente os elementos K_ij = ∫_Ωe ∇N_i · ∇N_j dΩ e M_ij = ∫_Ωe N_i N_j dΩ.",
                                    "Verifique simetria: K_ij = K_ji e M_ij = M_ji devido à propriedade das funções de forma.",
                                    "Discuta o domínio de integração Ωe para elementos isoparamétricos."
                                  ],
                                  "verification": "Expressões derivadas corretamente e simetria confirmada por inspeção manual.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Elementos Finitos (ex: Zienkiewicz), caderno para derivações, software simbólico como SymPy (opcional).",
                                  "tips": "Use notação vetorial consistente e lembre-se que ∇N é o gradiente das funções de forma.",
                                  "learningObjective": "Compreender a origem física e matemática das matrizes de rigidez e massa no MEF para acústica.",
                                  "commonMistakes": "Confundir gradiente com derivada escalar; esquecer o domínio elementar Ωe."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapeamento para Coordenadas Isoparamétricas",
                                  "subSteps": [
                                    "Defina o mapeamento isoparamétrico: x(ξ,η) = Σ N_k(ξ,η) x_k, onde ξ,η no elemento de referência.",
                                    "Calcule o Jacobiano J = ∂(x,y)/∂(ξ,η) e seu determinante |J|.",
                                    "Expresse ∇N no espaço físico: ∇N_i = J^{-T} ∇_ξ N_i.",
                                    "Reescreva as integrais: ∫_Ωe f dΩ = ∫_Ωref f |J| dξ dη.",
                                    "Implemente funções de forma para elementos comuns (ex: triângulo linear Q4 quadrilateral)."
                                  ],
                                  "verification": "Jacobiano computado corretamente para um elemento teste; integrais transformadas validam volume elementar.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Tabelas de funções de forma isoparamétricas, MATLAB/Python para plotar mapeamento, papel milimetrado.",
                                  "tips": "Sempre verifique det(J) > 0 para evitar inversão de elementos.",
                                  "learningObjective": "Dominar a transformação isoparamétrica essencial para elementos curvos.",
                                  "commonMistakes": "Erro na transposição do Jacobiano (use J^{-T} para ∇); esquecer |J| na integral."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integração Numérica com Pontos de Gauss",
                                  "subSteps": [
                                    "Selecione esquema de Gauss: 2x2 para quadriláteros lineares, 3x3 para quadráticos.",
                                    "Liste pesos w_i e pontos ξ_i, η_i de tabelas de Gauss-Legendre.",
                                    "Para cada ponto Gauss: calcule N(ξ_i), ∇_ξ N(ξ_i), J(ξ_i), ∇N = J^{-T} ∇_ξ N, então K_ij += w_i ∇N_i · ∇N_j |J|, M_ij += w_i N_i N_j |J|.",
                                    "Some contribuições de todos pontos Gauss para obter [Ke] e [Me].",
                                    "Valide convergência comparando com integração exata para elemento simples."
                                  ],
                                  "verification": "Matrizes coincidem com solução analítica para elemento retangular uniforme (erro <1%).",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Tabelas de pontos/pesos Gauss (online ou livro), código Python/MATLAB para automação, calculadora.",
                                  "tips": "Use loops vetorizados em código para eficiência; teste com 1 ponto Gauss primeiro.",
                                  "learningObjective": "Aplicar integração numérica Gauss-Legendre de forma precisa em MEF.",
                                  "commonMistakes": "Índices errados nos loops de Gauss; não multiplicar por peso w_i."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montagem das Matrizes Globais",
                                  "subSteps": [
                                    "Inicialize [K] e [M] globais como zeros (tamanho ndof x ndof).",
                                    "Para cada elemento e: localize graus de liberdade globais conn(e), então K[conn,conn] += Ke, M[conn,conn] += Me.",
                                    "Aplique condições de contorno: remova/penalize linhas/colunas de nós fixos.",
                                    "Verifique propriedades globais: simetria, diâmetro de banda, partição de unidade Σ N_i =1.",
                                    "Salve matrizes em formato esparso (CSR) para eficiência."
                                  ],
                                  "verification": "Soma de todas linhas de M ≈ volume total; K positiva definida para ω=0.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código MEF base (ex: FEniCS, deal.II ou script custom), malha de teste com 10 elementos.",
                                  "tips": "Use índices 1-based ou 0-based consistentemente; visualize esparsidade com spy plot.",
                                  "learningObjective": "Montar sistema global coeso a partir de contribuições elementares.",
                                  "commonMistakes": "Sobrescrita em vez de soma nas contribuições; mismatch de conectividade."
                                }
                              ],
                              "practicalExample": "Para um elemento triangular linear em malha 2D acústica: nós (0,0),(1,0),(0,1); funções N1=1-ξ-η, etc. Use 1 ponto Gauss (ξ=1/3,η=1/3,w=2), compute Ke (gradientes constantes) e Me, monte em malha de 3 elementos simulando caixa acústica simples.",
                              "finalVerifications": [
                                "Matrizes [K] e [M] são simétricas e positivas semi-definidas.",
                                "Soma das linhas de [M] equals volume/massa total da malha.",
                                "Integração Gauss converge para solução exata (erro <0.1% com 3x3 pontos).",
                                "Montagem global preserva energia: teste com autovalores.",
                                "Condições de Dirichlet aplicadas corretamente (linhas zero).",
                                "Tempo de computação escalável para malha >100 elementos."
                              ],
                              "assessmentCriteria": [
                                "Precisão da integração numérica (erro relativo <1%).",
                                "Correção da transformação Jacobiana e gradientes.",
                                "Eficiência da montagem global (uso de esparsidade).",
                                "Validação contra soluções analíticas ou benchmarks.",
                                "Clareza no código/documentação com comentários.",
                                "Tratamento robusto de elementos distorcidos (det(J)>0)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Integração numérica Gauss-Legendre e álgebra linear esparsa.",
                                "Programação: Implementação eficiente em Python/MATLAB com NumPy/SciPy.",
                                "Física: Formulação variacional de equações de Helmholtz para acústica.",
                                "Computação Científica: Paralelização e solvers iterativos (CG, GMRES)."
                              ],
                              "realWorldApplication": "Simulação de propagação sonora em salas de concerto ou automóveis para otimizar acústica; design de mufflers em escapamentos veiculares; análise de vibroacústica em estruturas aeroespaciais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.3.5.3.1",
                              "34.3.5.2.3"
                            ]
                          },
                          {
                            "id": "34.3.5.3.3",
                            "name": "Resolução do Sistema Acústico",
                            "description": "Resolver o sistema [K - k² M] {p} = {F} para problemas harmônicos, discutindo solvers iterativos para grandes malhas e tratamento de frequências ressonantes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Formulação Matemática do Problema Acústico Harmônico",
                                  "subSteps": [
                                    "Revise a equação de Helmholtz para propagação de ondas acústicas: ∇²p + k²p = 0, onde k = ω/c.",
                                    "Identifique as condições de contorno: Dirichlet para paredes rígidas (∂p/∂n=0), Neumann para fontes.",
                                    "Discuta o significado físico de p (pressão acústica) e sua relação com velocidade e densidade.",
                                    "Derive a forma fraca da equação para aplicação do MEF.",
                                    "Explique o sistema resultante [K - k²M]{p} = {F}, identificando K (matriz de rigidez), M (matriz de massa) e {F} (vetor de forças)."
                                  ],
                                  "verification": "O aluno pode escrever e explicar a derivação do sistema [K - k²M]{p} = {F} a partir da equação de Helmholtz.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'Finite Element Methods for Acoustics' de Ihlenburg",
                                    "Notas de aula sobre equação de onda",
                                    "Software MATLAB ou Python para visualização de ondas"
                                  ],
                                  "tips": "Use analogias com problemas de vibração estrutural para intuitar K e M.",
                                  "learningObjective": "Compreender a origem física e matemática do sistema acústico discretizado.",
                                  "commonMistakes": [
                                    "Confundir k com ω (lembre k=ω/c)",
                                    "Ignorar condições de contorno na formulação fraca",
                                    "Esquecer o sinal negativo em -k²M"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Montagem das Matrizes K, M e Vetor F no Contexto Acústico",
                                  "subSteps": [
                                    "Implemente elementos finitos lineares ou quadráticos para campos escalares em 2D/3D.",
                                    "Calcule a matriz de rigidez K usando integrais de forma ∇N_i · ∇N_j.",
                                    "Calcule a matriz de massa M usando integrais N_i N_j, discutindo integração numérica (Gauss-Lobatto).",
                                    "Monte o vetor de carga F para fontes puntiformes ou distribuídas.",
                                    "Verifique simetria e propriedades espectrais das matrizes (K positiva definida, M positiva semi-definida)."
                                  ],
                                  "verification": "Montar manualmente K e M para uma malha simples de 2 elementos e validar com software.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Software FEniCS ou FreeFEM para montagem automática",
                                    "Malha de exemplo em .msh (Gmsh)",
                                    "Código Python/MATLAB template para MEF acústico"
                                  ],
                                  "tips": "Comece com malhas 1D (tubos) para depuração antes de 2D/3D.",
                                  "learningObjective": "Capacitar a construção correta das matrizes do sistema acústico via MEF.",
                                  "commonMistakes": [
                                    "Erro na transformação de coordenadas jacobianas",
                                    "Integração inexata levando a M imprecisa",
                                    "Falta de normalização de unidades (k em 1/m)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolução com Solvers Diretos e Limitações para Grandes Malhas",
                                  "subSteps": [
                                    "Aplique solvers diretos (LU, Cholesky) para sistemas pequenos-médios.",
                                    "Analise complexidade O(n³) e armazenamento O(n²) para n graus de liberdade.",
                                    "Teste em problemas com 10³-10⁴ DOFs e observe tempo de CPU e memória.",
                                    "Discuta pré-condicionadores simples (diagonal) para melhorar condicionamento.",
                                    "Identifique quando solvers diretos falham (malhas >10⁵ DOFs)."
                                  ],
                                  "verification": "Resolver um sistema de 5000 DOFs em <5 min e plotar campo de pressão.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "MATLAB com 'backslash' ou SciPy sparse.linalg",
                                    "SuiteSparse para solvers diretos eficientes",
                                    "Exemplo de malha acústica grande"
                                  ],
                                  "tips": "Use formatos sparse (CSR) desde o início para eficiência.",
                                  "learningObjective": "Dominar resolução direta e reconhecer suas limitações em acústica computacional.",
                                  "commonMistakes": [
                                    "Usar matrizes densas em problemas grandes",
                                    "Ignorar escalonamento para evitar overflow",
                                    "Não verificar simetria positiva definida"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Solvers Iterativos e Tratamento de Frequências Ressonantes",
                                  "subSteps": [
                                    "Implemente GMRES ou BiCGSTAB para [K - k²M]{p} = {F}, com pré-condicionador ILU ou AMG.",
                                    "Teste convergência para malhas grandes (10⁵+ DOFs) e compare com diretos.",
                                    "Identifique picos de condicionamento perto de modos ressonantes (autovalores de K^{-1}M).",
                                    "Aplique técnicas de shift: resolva [K - (k+δ)²M] para δ pequeno, ou modo complexo.",
                                    "Valide com análise modal prévia para detectar e evitar ressonâncias."
                                  ],
                                  "verification": "Resolver problema ressonante com iterativo convergindo em <100 iterações, plotando residual.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "PETSc ou PyAMG para solvers avançados",
                                    "Código exemplo com GMRES em Python",
                                    "Ferramenta modal como ARPACK"
                                  ],
                                  "tips": "Monitore residual a cada 10 iterações e ajuste tolerância baseada em máquina.",
                                  "learningObjective": "Aplicar solvers iterativos eficientes e mitigar instabilidades ressonantes.",
                                  "commonMistakes": [
                                    "Pré-condicionador fraco causando estagnação",
                                    "Não detectar ressonância (verifique autovalores próximos)",
                                    "Tolerância muito frouxa levando a erros de fase"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule o campo de pressão em um duto acústico de 2m com fonte harmônica a 500Hz (k≈4.4 rad/m), malha de 10k elementos, usando solver iterativo GMRES para capturar modos ressonantes e prever atenuação.",
                              "finalVerifications": [
                                "Derivação correta do sistema [K - k²M]{p} = {F} para um problema dado.",
                                "Montagem e verificação de K, M, F em software para malha 2D.",
                                "Solução com solver direto para n<10k DOFs com precisão <1e-6.",
                                "Implementação de GMRES convergente para n>50k DOFs.",
                                "Tratamento bem-sucedido de frequência ressonante com shift ou damping.",
                                "Plot e interpretação física do campo de pressão (nós, antinós)."
                              ],
                              "assessmentCriteria": [
                                "Precisão da solução (erro L2 <1%) comparado a analítico.",
                                "Eficiência computacional (tempo < esperado para tamanho de malha).",
                                "Correta identificação e mitigação de ressonâncias.",
                                "Explicação clara de escolhas de solver e pré-condicionador.",
                                "Validação com convergência h/p-refinamento.",
                                "Relatório com plots de pressão e resíduos iterativos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (autovalores, métodos iterativos).",
                                "Física: Teoria de ondas e ressonância acústica.",
                                "Programação: Implementação numérica em Python/MATLAB (sparse matrices).",
                                "Engenharia: Vibrações modais e controle de ruído.",
                                "Computação Científica: Paralelização para malhas grandes."
                              ],
                              "realWorldApplication": "Projeto de forros acústicos em auditórios para evitar ressonâncias, simulação de ruído em cabines de aviões ou otimização de difusores em estúdios de gravação usando MEF com solvers escaláveis."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "34.3.5.3.2"
                            ]
                          },
                          {
                            "id": "34.3.5.3.4",
                            "name": "Validação e Análise de Resultados",
                            "description": "Avaliar soluções numéricas comparando com soluções analíticas (ex: tubo 1D), analisando dispersão numérica e condições de estabilidade em simulações acústicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparação da Solução Analítica e Numérica",
                                  "subSteps": [
                                    "Derive a solução analítica para o problema de tubo 1D acústico (equação da onda com condições de contorno rígidas ou absorbentes).",
                                    "Configure e execute a simulação numérica usando FEM com malha uniforme (ex: 50-200 elementos).",
                                    "Extraia os campos de pressão e velocidade em pontos/nós selecionados para ambos os métodos.",
                                    "Plote as soluções lado a lado para visualização inicial.",
                                    "Calcule métricas básicas como máximo e mínimo dos campos."
                                  ],
                                  "verification": "Gráficos superpostos mostram similaridade qualitativa; valores tabulados em pontos chave coincidem dentro de 10%.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software FEM (ex: MATLAB PDE Toolbox, FEniCS ou COMSOL)",
                                    "Código analítico em Python/MATLAB",
                                    "Documentação teórica do tubo 1D"
                                  ],
                                  "tips": [
                                    "Use frequência baixa inicialmente para convergência fácil.",
                                    "Salve dados em formato CSV para análise posterior."
                                  ],
                                  "learningObjective": "Entender e implementar soluções de referência analítica para benchmark.",
                                  "commonMistakes": [
                                    "Ignorar perdas viscosas na analítica.",
                                    "Malha muito grosseira causando discrepâncias iniciais.",
                                    "Unidades inconsistentes (Pa vs. dB)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Comparação Quantitativa e Análise de Erros",
                                  "subSteps": [
                                    "Calcule erro absoluto e relativo ponto a ponto (L1, L2, L∞ norms).",
                                    "Gere gráficos de erro vs. posição e vs. malha (estudo de convergência).",
                                    "Avalie ordem de convergência comparando com teoria (esperado O(h^2) para lineares).",
                                    "Identifique regiões de alto erro (ex: perto de boundaries).",
                                    "Documente tabela de erros para diferentes refinamentos de malha."
                                  ],
                                  "verification": "Norma L2 do erro < 2% da norma da solução analítica; gráfico de convergência log-log linear.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python com NumPy/SciPy para normas",
                                    "Matplotlib/Paraview para plots",
                                    "Planilha Excel para tabelas"
                                  ],
                                  "tips": [
                                    "Use interpolação para comparar malhas não alinhadas.",
                                    "Logaritme erros para visualizar escalas."
                                  ],
                                  "learningObjective": "Dominar métricas de validação numérica e interpretação de precisão.",
                                  "commonMistakes": [
                                    "Confundir erro absoluto com relativo.",
                                    "Não normalizar erros pela amplitude da solução.",
                                    "Ignorar polluição numérica em altas frequências."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Análise de Dispersão Numérica",
                                  "subSteps": [
                                    "Extraia números de onda numéricos de fase/velocidade em diferentes frequências.",
                                    "Plote curva de dispersão (ω numérico vs. ω analítico) e velocidade de fase normalizada.",
                                    "Calcule erro de dispersão e comprimento de onda numérico.",
                                    "Compare com análise teórica de elementos lineares (dispersão parabólica).",
                                    "Avalie impacto em comprimentos de onda resolvidos (λ/h > 10-12)."
                                  ],
                                  "verification": "Curva de dispersão mostra desvio <5% para k h < π/2; pelo menos 10 pontos de frequência testados.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Script Python para extração de fase (FFT ou zero-crossing)",
                                    "Referências teóricas (ex: Ihlenburg book)"
                                  ],
                                  "tips": [
                                    "Use sinal senoidal puro para análise de fase limpa.",
                                    "Teste múltiplas frequências harmônicas."
                                  ],
                                  "learningObjective": "Identificar e quantificar erros de dispersão em esquemas FEM acústicos.",
                                  "commonMistakes": [
                                    "Não remover transients iniciais afetando fase.",
                                    "Confundir dispersão com atenuação numérica.",
                                    "Malha insuficiente por comprimento de onda."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificação de Condições de Estabilidade e Síntese",
                                  "subSteps": [
                                    "Calcule timestep Δt baseado em CFL (Δt < h / c, c=velocidade do som).",
                                    "Execute simulações transitórias e monitore normas de energia/resíduo.",
                                    "Analise eigenvalues do sistema para modos instáveis (imaginários positivos).",
                                    "Sintetize achados em relatório com recomendações de malha/timestep.",
                                    "Teste sensibilidade a parâmetros (ex: mass lumping)."
                                  ],
                                  "verification": "Simulação estável por 10 períodos; resíduo decresce monotonicamente; relatório cobre todos aspectos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Solver transitório no software FEM",
                                    "MATLAB para análise modal"
                                  ],
                                  "tips": [
                                    "Use implicit solver para timestep maiores.",
                                    "Monitore múltiplas normas (L2 energia)."
                                  ],
                                  "learningObjective": "Avaliar estabilidade numérica e formular guidelines para simulações robustas.",
                                  "commonMistakes": [
                                    "Timestep muito grande causando blow-up.",
                                    "Ignorar boundary conditions na estabilidade.",
                                    "Não diferenciar instabilidade de não-linearidades."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um tubo 1D de 1m de comprimento, comprimento de onda λ=3.4m (f=100Hz, c=343m/s), use FEM linear com 100 elementos. Compare pressão em t=0.01s com solução analítica p(x,t)=p0 sin(kx - ωt). Verifique erro L2<1%, dispersão δk/k<3%, e estabilidade com Δt=1e-5s.",
                              "finalVerifications": [
                                "Erro relativo global <3% em pelo menos 3 refinamentos de malha.",
                                "Curva de dispersão física (sem oscilações anômalas).",
                                "Condições CFL satisfeitas (CFL<0.8); simulação estável >20 períodos.",
                                "Estudo de convergência confirma ordem teórica.",
                                "Relatório identifica fontes de erro e mitigações.",
                                "Visualizações (plots) claras e rotuladas."
                              ],
                              "assessmentCriteria": [
                                "Precisão das métricas de erro (cálculo correto de normas).",
                                "Interpretação qualitativa/quantitativa da dispersão e estabilidade.",
                                "Qualidade dos gráficos e tabelas (legíveis, informativos).",
                                "Cobertura completa: analítica vs numérica, dispersão, estabilidade.",
                                "Recomendações práticas baseadas em análise.",
                                "Ausência de erros comuns (ex: unidades, transients)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Análise de erros e convergência.",
                                "Programação Científica: Scripts para pós-processamento e FFT.",
                                "Física: Teoria de ondas acústicas e condições de contorno.",
                                "Estatística: Análise de incertezas em validação.",
                                "Engenharia de Software: Verificação e Validação (V&V) em simulações."
                              ],
                              "realWorldApplication": "Validação de simulações FEM para design de silenciadores automotivos, otimizando atenuação sem protótipos caros; análise de estabilidade em simulações de salas de concerto para evitar artefatos em predições de reverberação."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "34.3.5.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "totalSkills": 308
          }
        ],
        "totalSkills": 308
      }
    ]
  }
}