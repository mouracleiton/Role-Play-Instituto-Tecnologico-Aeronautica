{
  "formatVersion": "1.0",
  "exportDate": "2025-12-04T11:55:59.698Z",
  "appVersion": "1.0",
  "curriculumData": {
    "metadata": {
      "baseOn": "Catálogo dos Cursos de Graduação 2025 - ST-57",
      "lastUpdated": "2025-12-04",
      "totalAtomicSkills": 284
    },
    "areas": [
      {
        "id": "10",
        "name": "Mecânica do Voo",
        "description": "Disciplinas do Departamento de Mecânica do Voo (IEA-B), abrangendo dinâmica de estruturas aeroespaciais e aeroelasticidade.",
        "disciplines": [
          {
            "id": "10.1",
            "name": "ST-57 - Dinâmica de Estruturas Aeroespaciais e Aeroelasticidade",
            "description": "Modelagem dinâmica de estruturas aeroespaciais por equações de Lagrange e Princípio de Hamilton. Resposta dinâmica de sistemas estruturais a condições iniciais, excitações harmônicas, periódicas e arbitrárias, com único grau de liberdade. Excitações de base, transmissão e isolamento de vibrações. Sistemas estruturais modelados com dois ou mais graus de liberdade: cálculo de frequências naturais, ortogonalidade dos modos de vibração natural, coordenadas naturais e solução por análise modal. Métodos de análise da dinâmica de estruturas contínuas incluindo parâmetros concentrados. Análise dinâmica de estruturas pelo Método de Elementos Finitos. Amortecimento de Rayleigh. Análise de vibrações aleatórias em estruturas aeroespaciais. Ensaios de vibração estrutural experimental. Aeroelasticidade de placas e cascas. Problemas de estabilidade e resposta aeroelástica. Modelos aeroelásticos na base modal. Ensaios de aeroelasticidade em túnel de vento. Bibliografia: MEIROVITCH, L. Fundamentals of vibrations, McGraw-Hill, 2001. RAO, S.S. Mechanical vibrations. 5th ed. Prentice Hall, 2011. WRIGHT, J.R.; COOPER, J.E. Introduction to aircraft aeroelasticity and loads. 2. ed. John Wiley & Sons, 2015.",
            "mainTopics": [
              {
                "id": "10.1.1",
                "name": "Modelagem Dinâmica por Equações de Lagrange e Princípio de Hamilton",
                "description": "Apresenta a modelagem dinâmica de estruturas aeroespaciais utilizando equações de Lagrange e o Princípio de Hamilton como base fundamental.",
                "totalSkills": 47,
                "atomicTopics": [
                  {
                    "id": "10.1.1.1",
                    "name": "Formulação das Equações de Lagrange",
                    "description": "Derivação das equações de movimento para sistemas discretos a partir do lagrangiano L = T - V, com coordenadas generalizadas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.1.1",
                        "name": "Definição do Lagrangiano",
                        "description": "O lagrangiano L é definido como L = T - V, onde T representa a energia cinética total do sistema e V a energia potencial total, expressos em termos de coordenadas generalizadas e suas derivadas temporais.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.1.1",
                            "name": "Identificar energia cinética T",
                            "description": "Reconhecer e expressar a energia cinética T de um sistema discreto com múltiplas partículas ou graus de liberdade em termos das velocidades das coordenadas generalizadas q̇_i.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar energia cinética para sistemas de partículas individuais",
                                  "subSteps": [
                                    "Lembre-se da fórmula básica de energia cinética para uma partícula: T = (1/2) m v², onde v é a velocidade escalar.",
                                    "Expanda para velocidade vetorial: T = (1/2) m ||v||², com v = dr/dt.",
                                    "Identifique componentes cartesianos: v_x = dx/dt, v_y = dy/dt, v_z = dz/dt.",
                                    "Some energias cinéticas para múltiplas partículas: T_total = Σ (1/2) m_i ||v_i||².",
                                    "Anote posições r_i em termos de coordenadas cartesianas."
                                  ],
                                  "verification": "Escreva a expressão de T para duas partículas em movimento retilíneo e confirme que soma corretamente as contribuições individuais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de mecânica clássica (ex: Goldstein), caderno para anotações.",
                                  "tips": "Visualize vetores de velocidade para intuitivamente entender a contribuição quadrática.",
                                  "learningObjective": "Compreender a base da energia cinética em coordenadas cartesianas para partículas discretas.",
                                  "commonMistakes": "Confundir velocidade escalar com vetorial ou esquecer o fator 1/2."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir coordenadas generalizadas q_i e suas velocidades q̇_i",
                                  "subSteps": [
                                    "Defina coordenadas generalizadas q_i como um conjunto mínimo de parâmetros que descrevem a configuração do sistema (ex: ângulos, comprimentos).",
                                    "Relacione posições cartesianas r_i com q_i: r_i = r_i(q_1, q_2, ..., q_n).",
                                    "Calcule velocidades: v_i = Σ (∂r_i / ∂q_k) q̇_k, usando a regra da cadeia.",
                                    "Identifique que q̇_i = dq_i/dt são as velocidades generalizadas.",
                                    "Discuta graus de liberdade: n = número de q_i independentes."
                                  ],
                                  "verification": "Para um pêndulo simples (q = θ), derive v em termos de θ̇ e confirme T = (1/2) m l² θ̇².",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel quadriculado, calculadora, vídeo tutorial sobre coordenadas generalizadas (ex: YouTube MIT OCW).",
                                  "tips": "Use a notação matricial para múltiplas q_i: v = J q̇, onde J é a matriz jacobiana.",
                                  "learningObjective": "Relacionar velocidades cartesianas com velocidades generalizadas via transformações.",
                                  "commonMistakes": "Esquecer derivadas parciais ou assumir q_i como cartesianas diretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a expressão geral de T em termos de q̇_i",
                                  "subSteps": [
                                    "Substitua v_i na fórmula de T: T = Σ_i (1/2) m_i || Σ_k (∂r_i / ∂q_k) q̇_k ||².",
                                    "Expanda o quadrado: envolva produtos q̇_j q̇_k multiplicados por coeficientes cinéticos.",
                                    "Defina massas reduzidas ou coeficientes: T = (1/2) Σ_{j,k} a_{jk}(q) q̇_j q̇_k, onde a_{jk} = Σ_i m_i (∂r_i/∂q_j · ∂r_i/∂q_k).",
                                    "Reconheça a forma quadrática: T é uma forma quadrática positiva definida em q̇.",
                                    "Verifique simetria: a_{jk} = a_{kj}."
                                  ],
                                  "verification": "Derive a matriz de inércias A(q) para um sistema de duas partículas e escreva T = (1/2) q̇^T A q̇.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software simbólico como SymPy ou Mathematica para derivadas, notas de aula.",
                                  "tips": "Comece com sistemas de baixa dimensão (2-3 DOF) para evitar algebra complexa.",
                                  "learningObjective": "Expressar T como função quadrática das velocidades generalizadas.",
                                  "commonMistakes": "Ignorar dependência de q nas derivadas parciais ou erros em produtos ponto."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e validar em um exemplo com múltiplas partículas",
                                  "subSteps": [
                                    "Escolha um sistema: duas massas m1 e m2 conectadas por hastes rígidas em plano (q1=θ1, q2=θ2).",
                                    "Escreva r1(q1,q2) e r2(q1,q2) em cartesianas.",
                                    "Compute ∂r/∂q_i e forme a matriz A(q).",
                                    "Escreva T explicitamente e simplifique.",
                                    "Compare com energia cinética em coordenadas separadas para validar."
                                  ],
                                  "verification": "Calcule T para velocidades específicas (ex: q̇1=1, q̇2=0) e confirme energia positiva.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Python com NumPy/SymPy para simulação, diagramas desenhados à mão.",
                                  "tips": "Desenhe o sistema cinemático para visualizar transformações.",
                                  "learningObjective": "Identificar e expressar T corretamente para sistemas discretos reais.",
                                  "commonMistakes": "Erros de sinal em ângulos ou confusão entre posições relativas e absolutas."
                                }
                              ],
                              "practicalExample": "Em um sistema de duas partículas conectadas por uma mola em movimento planar, com coordenadas generalizadas q1 (posição da mola) e q2 (ângulo de rotação), T = (1/2) m1 (q̇1)^2 + (1/2) (m1 + m2) (l q̇2)^2 + termos cruzados m1 l q̇1 q̇2 cos(q2), derivados das velocidades v1 = q̇1 e v2 = q̇1 + l q̇2 no sistema rotante.",
                              "finalVerifications": [
                                "T é homogênea de grau 2 em q̇_i (escala como velocidades ao quadrado).",
                                "T ≥ 0 para todo q̇ ≠ 0, e T=0 só se q̇=0.",
                                "Para q̇_i constantes, T é constante (sem forças, conservação).",
                                "Matriz de coeficientes A(q) é simétrica e definida positiva.",
                                "Reduz corretamente para casos cartesianos quando q_i = x_i.",
                                "Derivadas parciais ∂T/∂q̇_i = p_i (momentos generalizados conjugados)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação das derivadas parciais ∂r_i/∂q_k.",
                                "Correta expansão e identificação dos termos cruzados q̇_j q̇_k.",
                                "Validação numérica ou simbólica da forma quadrática.",
                                "Explicação clara da dependência de q nas massas inerciais.",
                                "Aplicação correta a um exemplo com ≥2 graus de liberdade.",
                                "Identificação de propriedades físicas como positividade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (formas quadráticas, matrizes simétricas).",
                                "Física: Mecânica clássica e conservação de energia.",
                                "Engenharia Aeroespacial: Modelagem de estruturas flexíveis em aeroelasticidade.",
                                "Computação: Simulações numéricas em dinâmica (ex: MATLAB para integração de equações de Lagrange)."
                              ],
                              "realWorldApplication": "Na dinâmica de estruturas aeroespaciais, como asas de aeronaves com múltiplos graus de liberdade (flexão, torção), a energia cinética T em coordenadas generalizadas (modos modais) é essencial para formular equações de Lagrange, prevendo instabilidades aeroelásticas como flutter em voo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.2",
                            "name": "Identificar energia potencial V",
                            "description": "Determinar a energia potencial V para sistemas conservativos, incluindo potenciais gravitacionais e elásticos, em função das coordenadas generalizadas q_i.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito fundamental de energia potencial V em sistemas conservativos",
                                  "subSteps": [
                                    "Estudar a definição de força conservativa: uma força derivável de um potencial escalar V tal que F = -∇V",
                                    "Analisar propriedades: V depende apenas da posição (configuração), não da velocidade ou história do movimento",
                                    "Revisar exemplos clássicos: gravitação universal e elástica harmônica",
                                    "Diferenciar V de T (energia cinética): V é função das coordenadas q_i apenas",
                                    "Verificar independência do caminho: ∫F·dr = 0 em loops fechados"
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito por que V é conservativa e listar 3 propriedades chave",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Mecânica Lagrangeana (ex: Goldstein), notas de aula, calculadora simbólica (Wolfram Alpha)",
                                  "tips": "Sempre associe V à configuração estática do sistema, ignore velocidades",
                                  "learningObjective": "Dominar a definição e propriedades de V como função de q_i em sistemas conservativos",
                                  "commonMistakes": "Confundir V com dissipativa (ex: atrito); incluir termos de velocidade em V"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e formular energia potencial gravitacional V_g",
                                  "subSteps": [
                                    "Recordar V_g = m g h para campo uniforme, expressando h em termos de q_i (ex: altura de centro de massa)",
                                    "Generalizar para campo não-uniforme: V_g = -G M m / r, com r(q_i)",
                                    "Calcular para sistemas multi-corpo: somar V_g individuais",
                                    "Expressar em coordenadas generalizadas: identificar q_i relevantes (ex: ângulos em pêndulo)",
                                    "Derivar ∂V_g/∂q_i para confirmar F_i = -∂V_g/∂q_i"
                                  ],
                                  "verification": "Derivar V_g para um pêndulo simples e computar ∂V/∂θ",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Papel e lápis, software de álgebra simbólica (Mathematica ou SymPy), exemplos de estruturas aeroespaciais",
                                  "tips": "Desenhe o sistema e rotule q_i explicitamente antes de escrever V",
                                  "learningObjective": "Formular V_g corretamente como função de q_i para sistemas gravitacionais",
                                  "commonMistakes": "Usar coordenadas cartesianas sem transformar para q_i; esquecer fator de sinal em F = -∇V"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular energia potencial elástica V_el para deformações",
                                  "subSteps": [
                                    "Estudar V_el = (1/2) k Δl^2 para molas lineares, com Δl(q_i)",
                                    "Generalizar para múltiplas molas ou elementos finitos: V_el = Σ (1/2) k_j δ_j^2",
                                    "Aplicar a estruturas aeroespaciais: deformações em vigas ou asas (ex: torção ou flexão via q_i)",
                                    "Incluir não-linearidades se aplicável, mas focar em harmônicos para conservativos",
                                    "Verificar ortogonalidade: V_el depende só de deslocamentos q_i, não ḗq_i"
                                  ],
                                  "verification": "Escrever V_el para uma viga com mola torsional e derivar torque",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Diagramas de estruturas (ex: asa com flaps), MATLAB/Simulink para plotar V(q), referências de aeroelasticidade",
                                  "tips": "Use matriz de rigidez K para V = (1/2) q^T K q em sistemas discretos",
                                  "learningObjective": "Construir V_el em coordenadas generalizadas para elementos elásticos",
                                  "commonMistakes": "Incluir amortecimento em V (é dissipativo); confundir elongação com velocidade"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar potenciais e validar V total em coordenadas q_i",
                                  "subSteps": [
                                    "Somar V = V_g + V_el + outros conservativos",
                                    "Verificar dependência exclusiva de q_i: ∂V/∂ḗq_i = 0",
                                    "Testar em exemplo composto: pêndulo com mola",
                                    "Analisar estabilidade: mínimos de V indicam equilíbrio",
                                    "Preparar para Lagrange: L = T(q, ḗq) - V(q)"
                                  ],
                                  "verification": "Construir V completa para um sistema dado e plotar contornos V(q_i)",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Exemplos de problemas de aeroelasticidade, Python com Matplotlib para visualização",
                                  "tips": "Sempre normalize unidades e cheque dimensões de V (Joules)",
                                  "learningObjective": "Integrar todos os componentes em V(q) e validar para formulação Lagrangiana",
                                  "commonMistakes": "Omitir termos cruzados em V multi-corpo; depender de tempo explícito em V"
                                }
                              ],
                              "practicalExample": "Em uma asa flexível modelada por 2 graus de liberdade q1 (flexão) e q2 (torção): V = m g q1 + (1/2) k_b q1^2 + (1/2) k_t q2^2, onde q1 é deslocamento vertical e q2 ângulo de torção.",
                              "finalVerifications": [
                                "Derivar corretamente V para gravidade e elástica em um sistema dado",
                                "Confirmar F_i = -∂V/∂q_i para todos os graus de liberdade",
                                "Identificar se V é conservativa (independente de ḗq_i e tempo)",
                                "Plotar V(q) e localizar mínimos/ máximos",
                                "Combinar V_g e V_el sem erros de sinal ou soma",
                                "Explicar papel de V no Lagrangiano L = T - V"
                              ],
                              "assessmentCriteria": [
                                "Precisão na expressão de V como função exclusiva de q_i (100%)",
                                "Correção das derivadas parciais ∂V/∂q_i (90% acurácia)",
                                "Identificação correta de componentes gravitacionais e elásticos",
                                "Validação via gradiente e propriedades conservativas",
                                "Aplicação contextual a sistemas aeroespaciais",
                                "Clareza na documentação e visualizações"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo multivariável e gradientes",
                                "Engenharia Mecânica: Teoria de elasticidade e elementos finitos",
                                "Física: Mecânica clássica e conservação de energia",
                                "Computação: Simulação numérica com Python/MATLAB para otimização de V"
                              ],
                              "realWorldApplication": "Na aeroelasticidade, identificar V permite modelar energia armazenada em deformações de asas de aeronaves, prevendo instabilidades como flutter durante o voo, essencial para certificação de segurança em aviação."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.3",
                            "name": "Construir o lagrangiano L",
                            "description": "Calcular o lagrangiano L = T - V para um sistema discreto simples, como um pêndulo ou massa-mola, verificando dependências em q_i e q̇_i.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar as coordenadas generalizadas q_i do sistema",
                                  "subSteps": [
                                    "Analise o sistema físico (ex: pêndulo ou massa-mola) e determine os graus de liberdade.",
                                    "Escolha coordenadas generalizadas q_i que descrevam completamente a configuração (ex: ângulo θ para pêndulo).",
                                    "Verifique se as q_i são independentes e suficientes para o movimento.",
                                    "Anote as velocidades generalizadas q̇_i como derivadas temporais das q_i.",
                                    "Desenhe um diagrama esquemático do sistema com as q_i destacadas."
                                  ],
                                  "verification": "Lista de q_i e q̇_i explicitamente definida e diagramada corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Diagrama do sistema físico"
                                  ],
                                  "tips": "Prefira coordenadas que simplifiquem T e V; evite coordenadas redundantes.",
                                  "learningObjective": "Compreender como coordenadas generalizadas capturam a configuração do sistema.",
                                  "commonMistakes": [
                                    "Escolher coordenadas cartesianas em vez de generalizadas",
                                    "Ignorar restrições holonômicas",
                                    "Confundir q_i com q̇_i"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a energia cinética T em termos de q_i e q̇_i",
                                  "subSteps": [
                                    "Expresse as velocidades lineares ou angulares das partículas em termos de q̇_i.",
                                    "Use a fórmula T = (1/2) Σ m v² para sistemas discretos.",
                                    "Substitua as componentes de velocidade derivadas das q̇_i.",
                                    "Simplifique a expressão algébricamente, verificando dependências apenas em q̇_i (não em q_i para sistemas livres).",
                                    "Confira unidades: T deve ter unidades de energia (Joules)."
                                  ],
                                  "verification": "Expressão de T correta, com dependência explícita em q̇_i e sem q_i (se aplicável).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Tabelas de cinemática",
                                    "Software simbólico como SymPy (opcional)"
                                  ],
                                  "tips": "Comece com velocidades em coordenadas cartesianas e transforme para generalizadas.",
                                  "learningObjective": "Dominar a expressão da energia cinética em coordenadas generalizadas.",
                                  "commonMistakes": [
                                    "Incluir termos de q_i em T acidentalmente",
                                    "Erros em derivadas parciais",
                                    "Esquecer fatores 1/2"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a energia potencial V em termos de q_i",
                                  "subSteps": [
                                    "Identifique fontes de potencial (gravidade, mola, etc.) no sistema.",
                                    "Expresse posições das massas em termos de q_i.",
                                    "Aplique fórmulas: V_grav = m g h, V_mola = (1/2) k x², etc.",
                                    "Simplifique, garantindo dependência apenas em q_i (não em q̇_i).",
                                    "Verifique unidades e sinal correto (ex: V aumenta com altura)."
                                  ],
                                  "verification": "Expressão de V correta, dependente apenas de q_i.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabelas de forças conservativas",
                                    "Diagrama de posições"
                                  ],
                                  "tips": "Escolha o referencial de zero potencial para simplificar.",
                                  "learningObjective": "Expressar corretamente energias potenciais conservativas.",
                                  "commonMistakes": [
                                    "Confundir V com T",
                                    "Erros de sinal em potenciais gravitacionais",
                                    "Incluir velocidades em V"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formar o Lagrangiano L = T - V e verificar dependências",
                                  "subSteps": [
                                    "Subtraia V de T para obter L.",
                                    "Inspecione dependências: ∂L/∂q̇_i ≠ 0, ∂L/∂q_i pode ser ≠ 0.",
                                    "Verifique se L é homogêneo de grau 2 em q̇_i para conservação de energia.",
                                    "Teste dimensionalmente e substitua valores numéricos simples para validar.",
                                    "Escreva a expressão final de forma limpa."
                                  ],
                                  "verification": "L = T - V correto, com dependências verificadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha de rascunho anterior"
                                  ],
                                  "tips": "Sempre subtraia V de T, nunca o inverso.",
                                  "learningObjective": "Construir e validar o Lagrangiano completo.",
                                  "commonMistakes": [
                                    "Escrever L = V - T",
                                    "Erros de sinal na subtração",
                                    "Ignorar verificação de dependências"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um pêndulo simples: massa m no final de uma haste de comprimento l, ângulo θ da vertical. T = (1/2) m (l θ̇)², V = - m g l cos θ, logo L = (1/2) m l² θ̇² + m g l cos θ. Verifique: depende de θ̇² e θ.",
                              "finalVerifications": [
                                "T é função quadrática em q̇_i e não depende de q_i (para sistemas sem restrições de velocidade).",
                                "V depende apenas de q_i.",
                                "L = T - V está correto algebricamente.",
                                "Unidades de L são consistentes com energia.",
                                "Dependências parciais: ∂L/∂q̇_i = momento generalizado, ∂L/∂q_i = -força generalizada.",
                                "Substituição numérica simples reproduz valores esperados."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática das expressões de T e V (sem erros algébricos).",
                                "Correta identificação de dependências em q_i e q̇_i.",
                                "Uso apropriado de coordenadas generalizadas.",
                                "Verificações dimensionais e de unidades realizadas.",
                                "Clareza na apresentação e diagramação.",
                                "Capacidade de aplicar a um exemplo não trivial."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e derivadas parciais.",
                                "Física: Princípios de conservação de energia e momentum.",
                                "Engenharia: Modelagem de sistemas multi-corpo em aeroespacial.",
                                "Computação: Implementação numérica em Python/SymPy para simulações.",
                                "Controle: Base para derivar equações de movimento em controladores."
                              ],
                              "realWorldApplication": "Em dinâmica de estruturas aeroespaciais, o Lagrangiano modela vibrações de asas flexíveis ou pêndulos de combustível em foguetes, permitindo análise de estabilidade via equações de Lagrange e prevenção de flutter aeroelástico."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.2",
                        "name": "Coordenadas Generalizadas",
                        "description": "Coordenadas generalizadas q_i são variáveis independentes que descrevem completamente a configuração do sistema, permitindo a formulação em termos não necessariamente cartesianos.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.2.1",
                            "name": "Selecionar coordenadas generalizadas",
                            "description": "Escolher um conjunto mínimo de coordenadas generalizadas q_1, q_2, ..., q_n para sistemas discretos com n graus de liberdade, garantindo independência e completude.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Determinar o número de graus de liberdade (DOF) do sistema",
                                  "subSteps": [
                                    "Desenhe um diagrama esquemático detalhado do sistema discreto, identificando todas as partículas, corpos rígidos e conexões.",
                                    "Conte o número total de coordenadas cartesianas possíveis (3N para N partículas em 3D ou 2N em 2D).",
                                    "Identifique e classifique todas as restrições (holonômicas, não-holonômicas, escleronômicas).",
                                    "Calcule DOF como n = total_coordenadas - número_de_restrições_independentes.",
                                    "Valide o cálculo com um exemplo simples conhecido para confirmação."
                                  ],
                                  "verification": "Confirme que n está correto comparando com soluções padrão ou software de cinemática.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis para diagramas",
                                    "Livro de Mecânica Clássica (ex: Goldstein)",
                                    "Software como MATLAB para validação de DOF"
                                  ],
                                  "tips": "Sempre subtraia restrições independentes; use matriz de restrições para verificar linear independência.",
                                  "learningObjective": "Calcular precisamente o número mínimo de coordenadas necessárias para descrever o sistema.",
                                  "commonMistakes": [
                                    "Confundir restrições dependentes com independentes",
                                    "Esquecer DOF de rotação em corpos rígidos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar coordenadas generalizadas candidatas",
                                  "subSteps": [
                                    "Baseado nos DOF n, proponha n coordenadas que capturem os movimentos permitidos (ex: ângulos, deslocamentos arcados).",
                                    "Considere a simetria do sistema para escolher coordenadas 'naturais' (ex: ângulos polares para rotações).",
                                    "Expresse as posições de todas as partículas em termos dessas coordenadas q_i.",
                                    "Verifique se as restrições são automaticamente satisfeitas pelas coordenadas escolhidas.",
                                    "Documente as transformações cinemáticas de cartesianas para generalizadas."
                                  ],
                                  "verification": "Escreva as expressões de posição x(q_i) e confirme que derivadas parciais ∂x/∂q_i são consistentes.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Caderno de exercícios",
                                    "Ferramentas de desenho vetorial (ex: GeoGebra)",
                                    "Referências de exemplos em Lagrange (ex: pêndulo, articulado)"
                                  ],
                                  "tips": "Prefira coordenadas que simplifiquem o Lagrangiano; evite coordenadas cartesianas quando possível.",
                                  "learningObjective": "Selecionar coordenadas intuitivas e cinematicamente adequadas ao sistema.",
                                  "commonMistakes": [
                                    "Escolher mais de n coordenadas",
                                    "Ignorar simetria, levando a expressões complexas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar independência das coordenadas generalizadas",
                                  "subSteps": [
                                    "Construa a matriz Jacobiana J onde J_{kj} = ∂x_k / ∂q_j para todas as coordenadas cartesianas x_k.",
                                    "Calcule o determinante ou posto da Jacobiana na configuração de referência.",
                                    "Confirme que rank(J) = n, indicando independência local.",
                                    "Teste variações infinitesimais: δq_i devem gerar deslocamentos linearmente independentes.",
                                    "Analise singularidades potenciais em configurações extremas do sistema."
                                  ],
                                  "verification": "Jacobiana tem posto completo (rank n) em pontos genéricos; use software para computar.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Calculadora simbólica (ex: SymPy ou Mathematica)",
                                    "Papel para matrizes",
                                    "Exemplos resolvidos de sistemas multi-DOF"
                                  ],
                                  "tips": "Use coordenadas que evitem configurações singulares comuns, como alinhamentos colineares.",
                                  "learningObjective": "Garantir que pequenas mudanças em q_i produzam movimentos distintos.",
                                  "commonMistakes": [
                                    "Assumir independência sem Jacobiana",
                                    "Erros em derivadas parciais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Confirmar completude e minimalidade do conjunto",
                                  "subSteps": [
                                    "Verifique se qualquer configuração acessível do sistema pode ser alcançada variando apenas os q_i.",
                                    "Confirme que o conjunto spans todo o espaço de configuração (dimensão n).",
                                    "Teste com trajetórias específicas: simule movimentos e veja se DOF são fully explorados.",
                                    "Otimize para minimalidade: remova qualquer q redundante e re-verifique DOF.",
                                    "Compare com formulações alternativas para validar unicidade."
                                  ],
                                  "verification": "O mapeamento q → configuração é sobrejetivo e injetivo localmente; teste numérico de trajetórias.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software de simulação dinâmica (ex: MATLAB Simulink)",
                                    "Diagramas de configuração",
                                    "Checklist de completude"
                                  ],
                                  "tips": "Use princípio da menor ação: se Lagrangiano leva a EDOs consistentes, está completo.",
                                  "learningObjective": "Assegurar que o conjunto q descreva fully e unicamente o sistema com n coordenadas.",
                                  "commonMistakes": [
                                    "Conjunto incompleto, perdendo modos de movimento",
                                    "Adicionar coordenadas extras desnecessárias"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um pêndulo duplo aeroespacial modelando oscilações de um estabilizador (2 DOF): escolha q1 = θ1 (ângulo da primeira haste de comprimento l1), q2 = θ2 (ângulo relativo da segunda haste l2). Posições: x1 = l1 sin θ1, y1 = -l1 cos θ1; x2 = x1 + l2 sin θ2, y2 = y1 - l2 cos θ2. Verifique Jacobiana 4x2 tem rank 2.",
                              "finalVerifications": [
                                "Número de coordenadas q_i exatamente igual a n DOF.",
                                "Jacobiana das transformações cinemáticas tem posto n.",
                                "Restrições do sistema são implicitamente satisfeitas.",
                                "Qualquer movimento permitido é reproduzível variando q_i.",
                                "Lagrangiano L(T-U) é bem-definido e leva a EDOs de ordem 2.",
                                "Sem singularidades em configurações operacionais típicas."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de DOF (erro <5%).",
                                "Correção das expressões cinemáticas x(q_i).",
                                "Demonstração explícita de independência via Jacobiana.",
                                "Evidência de completude através de testes de trajetórias.",
                                "Minimalidade: não mais que n coordenadas usadas.",
                                "Clareza na documentação e justificativas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes Jacobianas, posto).",
                                "Física: Cinemática clássica e princípios variacionais.",
                                "Engenharia Mecânica: Modelagem multi-corpo em aeroespacial.",
                                "Computação: Simulação numérica em Python/MATLAB para verificação."
                              ],
                              "realWorldApplication": "Em dinâmica aeroelástica de asas de aeronaves, selecionar coordenadas generalizadas (ex: amplitudes modais de flexão/torção) para formular equações de Lagrange, prevendo flutter e fadiga estrutural em projetos da Boeing ou Embraer."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.1.2.2",
                            "name": "Expressar velocidades em q̇_i",
                            "description": "Derivar as velocidades lineares e angulares das partículas do sistema em função das derivadas temporais das coordenadas generalizadas q̇_i para computar T.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar coordenadas generalizadas e posições das partículas",
                                  "subSteps": [
                                    "Defina as coordenadas generalizadas q_i do sistema dinâmico.",
                                    "Expresse as posições cartesianas r_j de cada partícula j em termos das q_i e parâmetros constantes.",
                                    "Inclua rotações se o sistema envolver corpos rígidos.",
                                    "Verifique se todas as restrições cinemáticas estão incorporadas nas q_i.",
                                    "Anote o número de graus de liberdade n."
                                  ],
                                  "verification": "Confirme que r_j = r_j(q_1, q_2, ..., q_n, t) está correto comparando com o diagrama do sistema.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Mecânica Lagrangiana (ex: Goldstein), papel e lápis, diagrama do sistema.",
                                  "tips": "Comece com sistemas simples como pêndulo para praticar.",
                                  "learningObjective": "Dominar a representação posicional em coordenadas generalizadas.",
                                  "commonMistakes": "Esquecer dependência temporal explícita ou confundir q_i com q̇_i."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar velocidades lineares das partículas",
                                  "subSteps": [
                                    "Calcule a velocidade linear v_j = dr_j/dt usando a regra da cadeia: v_j = Σ (∂r_j/∂q_i) q̇_i + ∂r_j/∂t.",
                                    "Ignore termos ∂r_j/∂t se o sistema for não-autônomo só se aplicável.",
                                    "Expresse v_j como vetor em componentes cartesianas.",
                                    "Calcule o módulo |v_j|^2 para preparar T = Σ m_j |v_j|^2 / 2.",
                                    "Simplifique expressões algébricas."
                                  ],
                                  "verification": "Diferencie manualmente e compare com software simbólico como SymPy.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora simbólica (SymPy ou Mathematica), quadro branco.",
                                  "tips": "Use notação vetorial para clareza: v = J q̇, onde J é a matriz Jacobiana.",
                                  "learningObjective": "Aplicar derivada total para velocidades lineares em q̇_i.",
                                  "commonMistakes": "Esquecer a soma sobre todos os q_i ou derivar incorretamente ∂r/∂q_i."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar velocidades angulares para corpos rígidos",
                                  "subSteps": [
                                    "Para cada corpo rígido, defina ω_k = Σ (∂θ_k/∂q_i) q̇_i, onde θ_k são ângulos de rotação.",
                                    "Use convenções de rotação (ex: ângulos de Euler) consistentes.",
                                    "Calcule energia rotacional (1/2) I_k |ω_k|^2.",
                                    "Combine com velocidades lineares do centro de massa.",
                                    "Verifique ortogonalidade entre movimentos se aplicável."
                                  ],
                                  "verification": "Substitua valores numéricos simples e confira |ω|^2.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Tabelas de momentos de inércia, software de visualização (ex: MATLAB).",
                                  "tips": "Represente rotações com quaternions para evitar gimbal lock em sistemas complexos.",
                                  "learningObjective": "Expressar velocidades angulares em termos generalizados.",
                                  "commonMistakes": "Confundir velocidades angulares com lineares ou usar eixos errados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formar a energia cinética T e validar",
                                  "subSteps": [
                                    "Some T = Σ (1/2 m_j |v_j|^2) + Σ (1/2 I_k |ω_k|^2).",
                                    "Expresse T como forma quadrática: T = (1/2) Σ Σ a_{ij} q̇_i q̇_j.",
                                    "Identifique a matriz de massa M(q) onde T = (1/2) q̇^T M q̇.",
                                    "Teste com caso limite (ex: q̇_i = 0 implica T=0).",
                                    "Prepare para derivação das equações de Lagrange."
                                  ],
                                  "verification": "Compute ∂T/∂q̇_i e veja se recupera as quantidades de momento conjugado.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha para matriz M, exemplos resolvidos.",
                                  "tips": "Mantenha simetria da matriz M para eficiência computacional.",
                                  "learningObjective": "Construir T completa em q̇_i para formulação lagrangiana.",
                                  "commonMistakes": "Duplicar termos cinéticos ou esquecer fatores 1/2."
                                }
                              ],
                              "practicalExample": "Considere um pêndulo duplo com massas m1, m2 e comprimentos l1, l2, coordenadas q1 (ângulo1), q2 (ângulo2). Posições: r1 = (l1 sin q1, -l1 cos q1), r2 = (l1 sin q1 + l2 sin q2, -l1 cos q1 - l2 cos q2). Velocidades: v1_x = l1 q̇1 cos q1, etc. T = (1/2)(m1+m2) l1² q̇1² + (1/2) m2 l2² q̇2² + m2 l1 l2 q̇1 q̇2 cos(q1-q2).",
                              "finalVerifications": [
                                "T é homogênea quadrática em q̇_i (grau 2).",
                                "T=0 quando todos q̇_i=0.",
                                "∂T/∂q̇_i linear em q̇_j.",
                                "Matriz de massa M é simétrica positiva definida.",
                                "Recupera equações cartesianas no limite de coordenadas retas.",
                                "Conserva energia em ausência de não-conservatividade."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática na derivação de v_j e ω_k.",
                                "Expressão completa e simplificada de T em q̇_i.",
                                "Identificação correta da Jacobiana posicional.",
                                "Tratamento adequado de rotações em sistemas rígidos.",
                                "Validação numérica com exemplo específico.",
                                "Clareza na documentação dos passos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo vetorial e formas quadráticas.",
                                "Física: Cinemática clássica e princípios variacionais.",
                                "Engenharia: Simulações em software como ANSYS para aeroelasticidade.",
                                "Computação: Programação simbólica em Python/SymPy para automação."
                              ],
                              "realWorldApplication": "Em dinâmica aeroespacial, expressar velocidades de pontos em asas flexíveis em termos de modos generalizados q_i permite computar T para equações de Lagrange, simulando flutter em aeronaves como o Boeing 737 ou satélites com painéis solares deformáveis."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.1.2.3",
                            "name": "Verificar holonomia das restrições",
                            "description": "Distinguir coordenadas generalizadas para sistemas holonômicos e não-holonômicos, aplicando a redução para sistemas discretos aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Definições e Conceitos Básicos de Holonomia",
                                  "subSteps": [
                                    "Estude a definição formal de restrições holonômicas: restrições expressas como f(q, t) = 0, onde q são coordenadas generalizadas e t é tempo.",
                                    "Analise restrições não-holonômicas: restrições em velocidades, como a(q, ḗq, t) = 0, não integráveis.",
                                    "Revise exemplos clássicos: pêndulo simples (holonômico) vs. esferas rolando sem deslizar (não-holonômico).",
                                    "Compare graus de liberdade: holonômicas reduzem via integração; não-holonômicas mantêm dimensões originais.",
                                    "Anote diferenças em termos de integrabilidade das formas de Pfaff."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras diferenciando os conceitos e classifique dois exemplos simples.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Classical Mechanics' de Goldstein",
                                    "Notas de aula sobre Equações de Lagrange",
                                    "Vídeo tutorial sobre restrições em mecânica"
                                  ],
                                  "tips": "Foque na integrabilidade: teste se a restrição diferencial é exata (dω = 0).",
                                  "learningObjective": "Definir precisamente holonomia e identificar suas implicações em sistemas dinâmicos.",
                                  "commonMistakes": [
                                    "Confundir restrições rheonômicas (dependentes de tempo) com não-holonômicas",
                                    "Ignorar dependência temporal nas definições"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Classificar Restrições em Sistemas Físicos",
                                  "subSteps": [
                                    "Liste restrições comuns em sistemas aeroespaciais: juntas esféricas, rolamento sem deslize em rodas de pouso.",
                                    "Extraia restrições de problemas reais: para um braço robótico em satélite, identifique f(q) = 0 ou a(ḗq) = 0.",
                                    "Classifique 3-5 restrições dadas em exercícios como holonômicas ou não-holonômicas.",
                                    "Desenhe diagramas de configuração mostrando redução de DOF para holonômicas.",
                                    "Discuta impacto na escolha de coordenadas generalizadas."
                                  ],
                                  "verification": "Classifique corretamente um conjunto de 5 restrições fornecidas em um exercício supervisionado.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software MATLAB/Simulink para visualização",
                                    "Folhas de exercícios de mecânica aeroespacial",
                                    "Referência: 'Aerospace Dynamics'"
                                  ],
                                  "tips": "Sempre pergunte: 'Essa restrição pode ser integrada a uma função de posição?'",
                                  "learningObjective": "Reconhecer restrições em contextos reais e classificá-las com justificativa.",
                                  "commonMistakes": [
                                    "Classificar erroneamente restrições de velocidade integráveis como não-holonômicas",
                                    "Omitir análise de dependência de velocidades"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Testes Matemáticos para Verificar Holonomia",
                                  "subSteps": [
                                    "Aprenda o teste de integrabilidade: para a(ḗq) = 0, compute dω = ∑ (∂a_i/∂q_j - ∂a_j/∂q_i) dq_i ∧ dq_j = 0.",
                                    "Resolva exemplos: verifique holonomia de restrição de rolamento em 2D.",
                                    "Use critério de Frobenius para formas não-exatas em múltiplas restrições.",
                                    "Implemente numericamente em código para validar.",
                                    "Pratique com restrições não-lineares comuns em aeroelasticidade."
                                  ],
                                  "verification": "Realize o teste em 3 restrições complexas e demonstre que o resultado é consistente.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Python com SymPy para cálculo simbólico",
                                    "Planilha de exercícios com soluções",
                                    "Artigo sobre formas de Pfaff"
                                  ],
                                  "tips": "Comece com restrições lineares para ganhar confiança antes de não-lineares.",
                                  "learningObjective": "Executar testes matemáticos rigorosos para determinar holonomia.",
                                  "commonMistakes": [
                                    "Erro no cálculo de diferenciais exteriores",
                                    "Confundir condição necessária com suficiente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Verificação de Holonomia em Redução para Sistemas Discretos Aeroespaciais",
                                  "subSteps": [
                                    "Selecione modelo aeroespacial discreto: e.g., treliça de asa com 6 DOF por nó.",
                                    "Identifique restrições: rigidez em nós fixos (holonômicas).",
                                    "Reduza coordenadas se holonômico: elimine variáveis dependentes via Lagrange multipliers ou substituição.",
                                    "Simule antes/depois da redução e compare.",
                                    "Documente processo para relatório de modelagem."
                                  ],
                                  "verification": "Produza equações reduzidas para um sistema aeroespacial simples e valide via simulação.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "MATLAB Aerospace Toolbox",
                                    "Exemplo de modelo de treliça aeroelástica",
                                    "Template de relatório LaTeX"
                                  ],
                                  "tips": "Use multiplicadores de Lagrange apenas se necessário; prefira redução direta para holonômicas.",
                                  "learningObjective": "Integrar verificação de holonomia à formulação Lagrangeana em aplicações aeroespaciais.",
                                  "commonMistakes": [
                                    "Reduzir incorretamente DOF em não-holonômicos",
                                    "Ignorar singularidades na redução"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um quadricóptero (UAV aeroespacial), as restrições de não-deslizamento das hélices são a_x ḗx + a_y ḗy = 0. Teste holonomia: compute dω ≠ 0, confirmando não-holonômico, impedindo redução simples de DOF e exigindo formulação em velocidades completas para controle de voo.",
                              "finalVerifications": [
                                "Classificar corretamente holonomia em 5 exemplos aeroespaciais variados.",
                                "Derivar teste de integrabilidade para restrição dada sem erros.",
                                "Reduzir DOF em sistema holonômico discreto com equações corretas.",
                                "Explicar impacto na modelagem Lagrangeana de forma precisa.",
                                "Simular sistema reduzido vs. não-reduzido com resultados coincidentes.",
                                "Identificar não-holonômico em contexto real como drone."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos testes de holonomia (90%+ correto).",
                                "Justificativa clara e rigorosa para classificações.",
                                "Correta aplicação de redução de coordenadas em holonômicos.",
                                "Uso apropriado de ferramentas computacionais sem erros.",
                                "Integração contextual com dinâmica aeroespacial.",
                                "Identificação de erros comuns e sua mitigação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Geometria diferencial e formas de Pfaff.",
                                "Engenharia de Controle: Cinemática não-holonômica em UAVs e robótica.",
                                "Programação: Simulações simbólicas com SymPy/MATLAB.",
                                "Física Computacional: Modelagem multi-corpo em aeroelasticidade."
                              ],
                              "realWorldApplication": "Na NASA/JAXA, verificar holonomia em modelos de satélites com braços articulados permite redução eficiente de DOF, acelerando simulações de dinâmica orbital e estabilidade estrutural durante deploy de painéis solares."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.3",
                        "name": "Derivação das Equações de Lagrange",
                        "description": "As equações de movimento são obtidas pela variação do princípio da ação, resultando em d/dt (∂L/∂q̇_i) - ∂L/∂q_i = Q_i, onde Q_i são forças generalizadas não-conservativas.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.3.1",
                            "name": "Derivar a forma geral das equações",
                            "description": "Demonstrar a derivação das equações de Lagrange a partir do princípio variacional δ∫L dt = 0, obtendo explicitamente d/dt (∂L/∂q̇_i) - ∂L/∂q_i = 0 para sistemas conservativos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Princípio Variacional e o Lagrangiano",
                                  "subSteps": [
                                    "Revise a definição do Lagrangiano L = T - V, onde T é energia cinética e V é potencial.",
                                    "Entenda a ação S = ∫_{t1}^{t2} L(q, q̇, t) dt.",
                                    "Aprenda que o princípio variacional afirma que o caminho real extremiza S, i.e., δS = 0 para variações δq que fixam q(t1) e q(t2)."
                                  ],
                                  "verification": "Escreva a expressão para S e explique verbalmente por que δS = 0 implica nas equações de movimento.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Mecânica Clássica (Goldstein), notas de aula sobre Lagrange.",
                                  "tips": "Visualize o caminho real como uma 'montanha' na paisagem funcional onde a derivada funcional é zero.",
                                  "learningObjective": "Dominar os fundamentos do princípio variacional para sistemas conservativos.",
                                  "commonMistakes": "Confundir L com a ação S; esquecer que variações são pequenas e nulas nas extremidades."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Variação da Ação δS",
                                  "subSteps": [
                                    "Escreva δS = ∫_{t1}^{t2} δL dt, com δL = ∂L/∂q_i δq_i + ∂L/∂q̇_i δq̇_i (soma sobre i implícita).",
                                    "Note que δq̇_i = d/dt (δq_i).",
                                    "Expresse δS para um sistema com múltiplas coordenadas generalizadas q_i."
                                  ],
                                  "verification": "Derive explicitamente δS para uma coordenada q_i e confirme que é ∫ [∂L/∂q_i δq_i + ∂L/∂q̇_i d(δq_i)/dt] dt.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e lápis, calculadora simbólica (SymPy opcional).",
                                  "tips": "Use a notação de Einstein para somas implícitas para evitar confusão com múltiplas coordenadas.",
                                  "learningObjective": "Aplicar cálculo variacional para expressar a variação da ação.",
                                  "commonMistakes": "Esquecer o termo δq̇_i ou tratá-lo como independente de δq_i."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Integração por Partes ao Termo de Velocidade",
                                  "subSteps": [
                                    "Integre por partes o termo ∂L/∂q̇_i δq̇_i: ∫ u dv = uv - ∫ v du, com u = ∂L/∂q̇_i, dv = d(δq_i).",
                                    "Obtenha [∂L/∂q̇_i δq_i]_{t1}^{t2} - ∫ δq_i d/dt(∂L/∂q̇_i) dt.",
                                    "Como δq_i(t1)=δq_i(t2)=0, o termo de contorno some."
                                  ],
                                  "verification": "Mostre que δS = ∫ δq_i [∂L/∂q_i - d/dt(∂L/∂q̇_i)] dt.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Folha de exercícios de integração por partes, vídeo tutorial sobre cálculo variacional.",
                                  "tips": "Pratique integração por partes em funções simples antes de aplicar ao Lagrangiano.",
                                  "learningObjective": "Executar a manipulação chave que leva às equações de Euler-Lagrange.",
                                  "commonMistakes": "Erros no sinal durante integração por partes; ignorar limites de integração."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Obter a Forma Geral das Equações de Lagrange",
                                  "subSteps": [
                                    "Como δS = 0 para variações δq_i arbitrárias, o integrando deve ser zero: ∂L/∂q_i - d/dt(∂L/∂q̇_i) = 0.",
                                    "Escreva explicitamente d/dt(∂L/∂q̇_i) - ∂L/∂q_i = 0 para cada i.",
                                    "Verifique para um sistema simples, como pêndulo, que recupera F = ma."
                                  ],
                                  "verification": "Derive e escreva a equação geral, aplicando-a a um exemplo unidimensional.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Exemplos resolvidos de equações de Lagrange.",
                                  "tips": "Lembre-se: a independência das δq_i força o coeficiente a zero (teorema fundamental do cálculo variacional).",
                                  "learningObjective": "Concluir a derivação e reconhecer a forma final das EOM lagrangianas.",
                                  "commonMistakes": "Inverter o sinal final; confundir ∂L/∂q_i com ∂L/∂q̇_i."
                                }
                              ],
                              "practicalExample": "Para um pêndulo simples com L = (1/2)m l^2 θ̇^2 - m g l (1 - cos θ), derive δS = 0 levando a d/dt (m l^2 θ̇) - (-m g l sin θ) = 0, ou m l^2 θ̈ + m g l sin θ = 0.",
                              "finalVerifications": [
                                "Pode escrever δ∫L dt = 0 e derivar a forma geral sem consultar notas?",
                                "Aplica corretamente integração por partes ao termo ∂L/∂q̇_i δq̇_i?",
                                "Identifica os termos de contorno e por que eles somem?",
                                "Verifica a equação para um sistema de 2 graus de liberdade?",
                                "Explica intuitivamente por que δq_i arbitrárias implicam o integrando zero?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de δL e δS (exata, sem erros algébricos).",
                                "Correta aplicação de integração por partes, incluindo limites.",
                                "Forma final das equações idêntica à padrão: d/dt(∂L/∂q̇_i) - ∂L/∂q_i = 0.",
                                "Capacidade de aplicar a um exemplo concreto com resultado físico correto.",
                                "Clareza na explicação verbal dos passos lógicos.",
                                "Identificação de erros comuns e como evitá-los."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e equações de Euler-Lagrange.",
                                "Física: Mecânica clássica e princípios de Hamilton.",
                                "Engenharia: Modelagem dinâmica em aeroespacial (vibrações de asas).",
                                "Computação: Implementação numérica em simulações (Python/SymPy)."
                              ],
                              "realWorldApplication": "Na dinâmica de estruturas aeroespaciais, deriva equações de Lagrange para modelar aeroelasticidade de asas de aeronaves, prevendo flutter e instabilidades em voo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1",
                              "10.1.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.1.1.3.2",
                            "name": "Incluir forças generalizadas Q_i",
                            "description": "Incorporar forças externas ou não-conservativas como forças generalizadas Q_i = ∑ F · ∂r/∂q_i, estendendo para sistemas com dissipação ou excitações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Forças Generalizadas Q_i",
                                  "subSteps": [
                                    "Revise as coordenadas generalizadas q_i e posições r em termos de q_i.",
                                    "Identifique forças conservativas (potenciais) versus não-conservativas (externas, dissipativas).",
                                    "Estude a definição: Q_i representa o trabalho virtual das forças não-conservativas na direção ∂r/∂q_i.",
                                    "Discuta exemplos como atrito, forças de excitação em estruturas aeroespaciais.",
                                    "Anote diferenças entre forças generalizadas e forças cartesianas."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que Q_i representa e dê um exemplo simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Mecânica Lagrangeana (ex: Goldstein), notas de aula, calculadora simbólica (SymPy)."
                                  ],
                                  "tips": "Visualize Q_i como a 'projeção' das forças no espaço das coordenadas generalizadas.",
                                  "learningObjective": "Dominar a interpretação física de Q_i para forças externas e dissipativas.",
                                  "commonMistakes": "Confundir Q_i com forças conservativas; ignorar que Q_i só inclui não-conservativas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Expressão Matemática de Q_i",
                                  "subSteps": [
                                    "Comece com o princípio do trabalho virtual: δW = ∑ F · δr.",
                                    "Expresse δr = ∑ (∂r/∂q_i) δq_i.",
                                    "Derive Q_i = ∑ F · (∂r/∂q_i) para cada coordenada q_i.",
                                    "Considere múltiplas forças F_j e some contribuições.",
                                    "Verifique com um sistema 1D: Q = F para q = x."
                                  ],
                                  "verification": "Derive a fórmula em um papel e confira com referência padrão.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel e lápis, software Mathematica/MATLAB para verificação simbólica."
                                  ],
                                  "tips": "Use vetores unitários parciais ∂r/∂q_i para intuição geométrica.",
                                  "learningObjective": "Derivar rigorosamente Q_i a partir do trabalho virtual.",
                                  "commonMistakes": "Esquecer a soma sobre todas as partículas/forças; confundir com Jacobiano completo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e Calcular Q_i em um Sistema com Dissipação",
                                  "subSteps": [
                                    "Escolha um sistema: pêndulo com amortecimento viscoso.",
                                    "Expresse posição r(θ) para ângulo θ = q.",
                                    "Identifique força dissipativa F_d = -b v.",
                                    "Calcule ∂r/∂θ e Q_θ = F_d · ∂r/∂θ.",
                                    "Generalize para excitações harmônicas F_exc = F0 cos(ωt)."
                                  ],
                                  "verification": "Calcule Q_i numericamente para valores específicos e plote.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Exemplo de pêndulo, Python com NumPy para cálculo."
                                  ],
                                  "tips": "Para damping, Q_i frequentemente resulta em -c ∂q_i/∂t.",
                                  "learningObjective": "Aplicar derivação para calcular Q_i em cenários reais de dissipação.",
                                  "commonMistakes": "Negligenciar velocidade na força dissipativa; usar coordenadas erradas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incorporar Q_i nas Equações de Lagrange Completas",
                                  "subSteps": [
                                    "Lembre equações padrão: d/dt (∂L/∂q̇_i) - ∂L/∂q_i = 0.",
                                    "Estenda para: d/dt (∂L/∂q̇_i) - ∂L/∂q_i = Q_i.",
                                    "Substitua Q_i calculado no sistema escolhido.",
                                    "Forme as EDOs completas e resolva numericamente.",
                                    "Analise estabilidade com Q_i (ex: amortecimento reduz oscilações)."
                                  ],
                                  "verification": "Simule o sistema com e sem Q_i; compare trajetórias.",
                                  "estimatedTime": "70 minutos",
                                  "materials": [
                                    "Solver numérico (SciPy odeint), gráfico de resultados."
                                  ],
                                  "tips": "Linearize para pequenos ângulos em aeroelasticidade.",
                                  "learningObjective": "Integrar Q_i nas equações dinâmicas para modelagem realista.",
                                  "commonMistakes": "Colocar Q_i no lado errado da equação; esquecer termos inerciais."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Analisar o Modelo Estendido",
                                  "subSteps": [
                                    "Compare solução com caso conservativo (Q_i=0).",
                                    "Teste sensibilidade a parâmetros de dissipação/excitação.",
                                    "Discuta limitações: Q_i assume forças conhecidas.",
                                    "Conecte a aeroelasticidade: forças aerodinâmicas como Q_i.",
                                    "Documente equações finais."
                                  ],
                                  "verification": "Gráficos mostram decaimento devido a Q_i; equações balanceadas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Gráficos de simulação, relatório curto."
                                  ],
                                  "tips": "Use energias para validar: dE/dt = Q_i q̇_i <0 para dissipação.",
                                  "learningObjective": "Verificar fisicamente a inclusão de Q_i em dinâmicas.",
                                  "commonMistakes": "Ignorar efeitos cumulativos de Q_i em simulações longas."
                                }
                              ],
                              "practicalExample": "Em uma viga aeroelástica de asa, inclua forças aerodinâmicas não-conservativas (lift/disturbances) como Q_i = ∫ p(x) ∂w/∂q_i dx, onde w é deslocamento, modelando flutter com damping estrutural.",
                              "finalVerifications": [
                                "Equações de Lagrange incluem corretamente Q_i ≠ 0.",
                                "Simulação mostra dissipação realista (amortecimento).",
                                "Cálculo de Q_i bate com trabalho virtual δW/δq_i.",
                                "Solução converge para equilíbrio estável.",
                                "Análise de energia confirma Q_i como fonte dissipativa.",
                                "Generalização para múltiplas q_i é consistente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de Q_i (100% correta).",
                                "Correta identificação de forças não-conservativas.",
                                "Simulações numéricas executadas e analisadas.",
                                "Explicação física clara de impactos de Q_i.",
                                "Ausência de erros algébricos em EDOs.",
                                "Conexão com contexto aeroespacial demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e derivadas parciais.",
                                "Física: Princípios de mínima ação estendidos.",
                                "Engenharia: Modelagem de vibrações em estruturas.",
                                "Computação: Simulação numérica de EDOs dinâmicas."
                              ],
                              "realWorldApplication": "Na dinâmica de aeronaves, Q_i modela forças aerodinâmicas e damping em análises de flutter, essencial para certificação de estabilidade em projetos da Boeing ou Embraer, prevenindo falhas catastróficas como no caso histórico de Tacoma Narrows."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1",
                              "10.1.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.1.1.3.3",
                            "name": "Aplicar a um sistema discreto simples",
                            "description": "Formular e resolver as equações de Lagrange para um sistema com um grau de liberdade, como um oscilador harmônico, e verificar contra equações newtonianas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o sistema discreto simples: Oscilador harmônico",
                                  "subSteps": [
                                    "Escolha um sistema com um grau de liberdade, como uma massa m ligada a uma mola de constante k em uma superfície sem atrito.",
                                    "Defina a coordenada generalizada q(t) como o deslocamento da massa da posição de equilíbrio.",
                                    "Desenhe um diagrama esquemático do sistema, indicando forças e posição.",
                                    "Especifique condições iniciais: q(0) e dq/dt(0).",
                                    "Liste as premissas: movimento unidimensional, sem amortecimento."
                                  ],
                                  "verification": "Diagrama completo desenhado e coordenadas definidas corretamente em um relatório ou caderno.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora",
                                    "Livro-texto de mecânica clássica (opcional)"
                                  ],
                                  "tips": "Comece sempre com o caso mais simples para construir intuição; visualize o movimento.",
                                  "learningObjective": "Identificar e parametrizar um sistema discreto com um grau de liberdade.",
                                  "commonMistakes": [
                                    "Confundir graus de liberdade com dimensões",
                                    "Esquecer de especificar condições iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Expressar energia cinética T e potencial V em termos de q e dq/dt",
                                  "subSteps": [
                                    "Calcule T = (1/2) m (dq/dt)^2 para a energia cinética.",
                                    "Calcule V = (1/2) k q^2 para a energia potencial da mola.",
                                    "Verifique as unidades: T e V em joules.",
                                    "Escreva expressões explícitas com valores numéricos exemplo: m=1 kg, k=1 N/m.",
                                    "Confirme que T depende de velocidades e V de posições."
                                  ],
                                  "verification": "Expressões de T e V derivadas corretamente e unidades verificadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora"
                                  ],
                                  "tips": "Lembre-se: T é sempre quadrática em velocidades generalizadas; V não depende de velocidades.",
                                  "learningObjective": "Formular corretamente as energias cinética e potencial em coordenadas generalizadas.",
                                  "commonMistakes": [
                                    "Incluir termos cruzados desnecessários em T",
                                    "Usar posição absoluta em vez de deslocamento"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a Lagrangiana L = T - V e derivar as equações de Lagrange",
                                  "subSteps": [
                                    "Escreva L = T - V explicitamente.",
                                    "Aplique a equação de Lagrange: d/dt (∂L/∂(dq/dt)) - ∂L/∂q = 0.",
                                    "Compute ∂L/∂(dq/dt) = m dq/dt.",
                                    "Compute d/dt de ∂L/∂(dq/dt) = m d²q/dt².",
                                    "Compute ∂L/∂q = -k q e assim obtenha m d²q/dt² + k q = 0."
                                  ],
                                  "verification": "Equação de movimento derivada: m ÿ + k y = 0, onde y=q.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software simbólico como SymPy (opcional)"
                                  ],
                                  "tips": "Use notação de pontos para derivadas temporais para clareza.",
                                  "learningObjective": "Derivar as equações de movimento de Lagrange a partir da Lagrangiana.",
                                  "commonMistakes": [
                                    "Erro no sinal de V em L (deve ser T - V)",
                                    "Confundir ∂L/∂q com ∂L/∂(dq/dt)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver a equação e verificar contra abordagem newtoniana",
                                  "subSteps": [
                                    "Resolva a EDO: solução geral q(t) = A cos(ωt) + B sen(ωt), com ω=sqrt(k/m).",
                                    "Aplique condições iniciais para encontrar A e B.",
                                    "Derive a equação newtoniana: F = -k q = m d²q/dt².",
                                    "Compare: ambas levam à mesma EDO m ÿ + k y = 0.",
                                    "Plote q(t) para visualização e valide numericamente com valores exemplo."
                                  ],
                                  "verification": "Solução analítica obtida, plotada e comparada com Newton sem discrepâncias.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Python/MATLAB para plotagem",
                                    "Calculadora"
                                  ],
                                  "tips": "Use solver numérico para validar se analítico for complexo.",
                                  "learningObjective": "Resolver EDOs de Lagrange e validar equivalência com Newton.",
                                  "commonMistakes": [
                                    "Erro na frequência angular ω",
                                    "Ignorar constantes de integração"
                                  ]
                                }
                              ],
                              "practicalExample": "Modelagem de uma massa-mola representando vibrações de uma estrutura aeroespacial simples, como um suporte de motor em uma aeronave: defina m=10 kg, k=100 N/m, q(0)=0.1 m, v(0)=0; resolva e plote deslocamento vs tempo.",
                              "finalVerifications": [
                                "Equações de Lagrange derivadas corretamente iguais à newtoniana.",
                                "Solução analítica resolve condições iniciais.",
                                "Gráfico de q(t) mostra oscilação harmônica com período correto T=2π sqrt(m/k).",
                                "Validação numérica coincide com solução exata dentro de 1%.",
                                "Relatório explica diferenças/conexões entre abordagens Lagrange e Newton.",
                                "Identificação correta de graus de liberdade (1 DOF)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação de T e V (100% correto).",
                                "Derivação impecável das EOMs de Lagrange (sem erros algébricos).",
                                "Solução da EDO com condições iniciais aplicadas corretamente.",
                                "Comparação clara e quantitativa com Newton.",
                                "Uso apropriado de ferramentas e visualizações.",
                                "Clareza no relatório e compreensão conceitual demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Resolução de EDOs lineares de segunda ordem.",
                                "Programação: Implementação numérica em Python (SciPy odeint).",
                                "Engenharia Aeroespacial: Modelagem de vibrações em estruturas.",
                                "Física Computacional: Simulações de dinâmica.",
                                "Controle de Sistemas: Base para controladores de osciladores."
                              ],
                              "realWorldApplication": "Em dinâmica de estruturas aeroespaciais, as equações de Lagrange modelam vibrações de asas ou fuselagens (ex.: flutter em aeronaves), permitindo análise de estabilidade e design contra ressonância em voo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1",
                              "10.1.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.1.1.3.4",
                            "name": "Analisar propriedades das equações",
                            "description": "Identificar termos inerciais, de Coriolis, centrífugos e de rigidez nas equações de Lagrange para sistemas multi-grau de liberdade em estruturas aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a forma geral das equações de Lagrange para sistemas multi-grau de liberdade",
                                  "subSteps": [
                                    "Relembrar a equação geral: d/dt (∂L/∂q̇_i) - ∂L/∂q_i = Q_i, onde L = T - V.",
                                    "Expandir para sistemas com coordenadas generalizadas q_i em estruturas aeroespaciais rotativas.",
                                    "Escrever a forma matricial: M(q, q̇) q̈ + C(q, q̇) q̇ + K(q) q = F.",
                                    "Identificar componentes: M (inercial), C (Coriolis/centrífugo), K (rigidez).",
                                    "Estudar exemplos de DOF em asas flexíveis ou painéis aeroespaciais."
                                  ],
                                  "verification": "Capacidade de escrever e explicar a forma matricial correta das equações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Dinâmica de Estruturas (ex: Hodges & Alvin), software MATLAB/Simulink para simulação.",
                                  "tips": "Use notação matricial desde o início para visualizar acoplamentos.",
                                  "learningObjective": "Compreender a estrutura matricial das equações de Lagrange em sistemas rotativos.",
                                  "commonMistakes": "Confundir energia cinética T com potencial V ao derivar L."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e isolar o termo inercial (matriz de massa M)",
                                  "subSteps": [
                                    "Derivar M a partir da energia cinética T = (1/2) q̇^T M q̇, considerando velocidades absolutas em referenciais rotativos.",
                                    "Calcular contribuições de translação e rotação para cada DOF.",
                                    "Verificar simetria positiva definida de M.",
                                    "Analisar dependência de q (posição) em sistemas não-lineares.",
                                    "Testar com um exemplo simples de 2 DOF (ex: viga em rotação)."
                                  ],
                                  "verification": "Extrair M corretamente de uma equação de Lagrange dada e confirmar simetria.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel e lápis para derivações, MATLAB para plotar autovalores de M.",
                                  "tips": "Expresse velocidades em termos de q̇ usando Jacobianos para automação.",
                                  "learningObjective": "Reconhecer o termo inercial como a matriz de massa dependente de configuração.",
                                  "commonMistakes": "Ignorar termos de rotação na energia cinética, subestimando M."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar termos de Coriolis e centrífugos (matriz gyroscópica C)",
                                  "subSteps": [
                                    "Derivar C de d/dt (∂T/∂q̇_i), focando em produtos cruzados de velocidades angulares.",
                                    "Separar Coriolis (2 Ω × v) de centrífugo (Ω × (Ω × r)).",
                                    "Verificar propriedades: C antissimétrica, dependente de q e q̇.",
                                    "Implementar em código para um sistema como hélice ou rotor.",
                                    "Analisar estabilidade: termos dissipativos vs. conservativos."
                                  ],
                                  "verification": "Isolar C de uma equação exemplo e demonstrar sua antissimetria.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Software ANSYS ou custom script Python para visualização de C.",
                                  "tips": "Use a regra da mão direita para vetores de Coriolis em 3D.",
                                  "learningObjective": "Diferenciar e extrair termos não-lineares de velocidade nas equações.",
                                  "commonMistakes": "Confundir Coriolis (linear em q̇) com centrífugo (quadrático em q̇)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar o termo de rigidez (matriz K) e analisar propriedades globais",
                                  "subSteps": [
                                    "Derivar K de -∂V/∂q_i, incluindo rigidez geométrica e aerodinâmica.",
                                    "Verificar dependência de q em pré-estresse ou grandes deslocamentos.",
                                    "Analisar propriedades: simetria, definitude, autovalores para modos naturais.",
                                    "Comparar com sistemas lineares para validar linearizações.",
                                    "Sintetizar: equação completa M q̈ + C q̇ + K q = 0."
                                  ],
                                  "verification": "Decompor uma equação completa em M, C, K e discutir estabilidade.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Exemplos de artigos sobre aeroelasticidade (ex: AIAA journals), eigenvalue solver.",
                                  "tips": "Linearize em torno de equilíbrio para simplificar análise inicial.",
                                  "learningObjective": "Isolar termos de rigidez e avaliar propriedades dinâmicas do sistema.",
                                  "commonMistakes": "Omitir rigidez geométrica em rotações grandes."
                                }
                              ],
                              "practicalExample": "Em uma asa flexível de aeronave em voo (2 DOF: flexão e torção), derive as equações de Lagrange considerando rotação da fuselagem. Identifique M (massas inerciais da asa), C (Coriolis devido à velocidade angular da aeronave), e K (rigidez torsional e flexural). Simule em MATLAB para verificar flutter.",
                              "finalVerifications": [
                                "Decompor corretamente uma equação de Lagrange em M, C, K.",
                                "Explicar diferenças físicas entre termos inercial, Coriolis, centrífugo e rigidez.",
                                "Demonstrar simetria de M e antissimetria de C.",
                                "Analisar impacto de rotação em autovalores do sistema.",
                                "Validar com simulação numérica simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de cada termo (90% correto).",
                                "Explicação física clara e correta dos termos.",
                                "Uso apropriado de notação matricial e propriedades.",
                                "Análise de dependências (q, q̇) demonstrada.",
                                "Aplicação a exemplo aeroespacial realista.",
                                "Ausência de erros comuns em derivações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (autovalores, simetria de matrizes).",
                                "Física: Mecânica clássica (referenciais não-inerciais).",
                                "Engenharia Aeroespacial: Aeroelasticidade e controle de vibrações.",
                                "Computação: Programação numérica para simulações dinâmicas."
                              ],
                              "realWorldApplication": "Na análise de flutter em asas de aviões ou hélices de turbinas, identificar esses termos permite prever instabilidades dinâmicas, otimizando designs para evitar falhas catastróficas como o incidente do Lockheed Electra."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.1.1",
                              "10.1.1.1.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.2",
                    "name": "Princípio Variacional de Hamilton",
                    "description": "Enunciado do princípio de Hamilton e sua relação com a ação integral para obter equações de movimento.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.2.1",
                        "name": "Enunciado do Princípio Variacional de Hamilton",
                        "description": "Apresentação formal do princípio variacional de Hamilton, que afirma que o movimento real de um sistema conservativo ocorre ao longo do caminho que torna a ação integral estacionária (δS = 0), onde S é a integral temporal do lagrangiano ou hamiltoniano.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.1",
                            "name": "Identificar o enunciado matemático do princípio de Hamilton",
                            "description": "Reconhecer e reproduzir o enunciado δ∫(L dt) = 0 ou sua forma hamiltoniana equivalente δ∫(p dq - H dt) = 0, explicando os símbolos q (coordenadas generalizadas), p (momentos conjugados) e H (hamiltoniano).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o princípio variacional básico em mecânica clássica",
                                  "subSteps": [
                                    "Estude a definição do princípio variacional: caminhos reais de sistemas extremizam a ação S = ∫ L(q, ᵓq, t) dt.",
                                    "Revise o lagrangiano L = T - V, onde T é energia cinética e V é potencial.",
                                    "Analise a variação δS = 0, significando que a primeira variação da ação é zero para trajetórias verdadeiras.",
                                    "Compare com princípios newtonianos para contextualizar.",
                                    "Anote exemplos simples como o pêndulo."
                                  ],
                                  "verification": "Escreva uma explicação em 3 frases do que significa δ∫ L dt = 0 e recite sem consultar materiais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Mecânica Clássica (ex: Goldstein)",
                                    "Vídeo introdutório sobre cálculo das variações",
                                    "Caderno para anotações"
                                  ],
                                  "tips": "Use analogias visuais, como uma bola rolando no caminho de menor tempo.",
                                  "learningObjective": "Dominar o conceito fundamental do princípio variacional e sua relação com o lagrangiano.",
                                  "commonMistakes": [
                                    "Confundir variação δ com derivada d",
                                    "Achar que sempre minimiza, ignorando que é ponto estacionário"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Memorizar e reproduzir o enunciado lagrangiano do princípio de Hamilton",
                                  "subSteps": [
                                    "Escreva repetidamente o enunciado: δ∫ (L dt) = 0, onde a integral é sobre o tempo.",
                                    "Identifique os limites da integral: tipicamente de t1 a t2 com condições de contorno fixas.",
                                    "Pratique derivando as equações de Euler-Lagrange a partir dele.",
                                    "Teste reproduzindo em voz alta 5 vezes.",
                                    "Registre em um flashcard para revisão."
                                  ],
                                  "verification": "Reproduza o enunciado exato em papel sem erros e explique verbalmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Flashcards digitais (Anki)",
                                    "Papel e caneta",
                                    "Notas de aula sobre Lagrange"
                                  ],
                                  "tips": "Associe a fórmula a uma imagem mental de uma trajetória otimizada em voo.",
                                  "learningObjective": "Reproduzir com precisão o enunciado na forma lagrangiana.",
                                  "commonMistakes": [
                                    "Esquecer os limites de integração",
                                    "Omitir o δ ou confundir com igual a zero apenas para mínimos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aprender a forma hamiltoniana equivalente e os símbolos chave",
                                  "subSteps": [
                                    "Estude a transformação Legendre: p = ∂L/∂ᵓq e H = p ᵓq - L.",
                                    "Memorize o enunciado: δ∫ (p dq - H dt) = 0.",
                                    "Defina símbolos: q (coordenadas generalizadas), p (momentos conjugados), H (hamiltoniano, energia total).",
                                    "Compare as duas formas e entenda a equivalência via transformação canônica.",
                                    "Esboce um diagrama de fase simples para ilustrar."
                                  ],
                                  "verification": "Escreva ambos os enunciados e defina q, p, H corretamente em uma tabela.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de simulação (ex: MATLAB para plotar fase)",
                                    "Referência: Mecânica Analítica (Landau)",
                                    "Quadro branco"
                                  ],
                                  "tips": "Pense em q e p como posição e momento em sistemas generalizados, como ângulo e torque em hélices.",
                                  "learningObjective": "Entender e reproduzir a forma hamiltoniana, explicando todos os símbolos.",
                                  "commonMistakes": [
                                    "Confundir H com L",
                                    "Esquecer que p é conjugado a q",
                                    "Invertir a ordem em p dq - H dt"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação e explicação em contextos aeroespaciais",
                                  "subSteps": [
                                    "Aplique a um exemplo: derive equação de uma partícula em campo gravitacional.",
                                    "Identifique o enunciado em um problema de dinâmica de estruturas (ex: viga flexível).",
                                    "Explique verbalmente os símbolos em um contexto de voo (q como deslocamento da asa, p como momento inercial).",
                                    "Resolva um exercício: dado L, escreva o princípio de Hamilton.",
                                    "Autoavalie reproduzindo em cenários variados."
                                  ],
                                  "verification": "Resolva um problema curto e identifique corretamente ambos os enunciados com explicações.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exercícios de mecânica aeroespacial",
                                    "Python ou MATLAB para verificação numérica",
                                    "Artigos sobre aeroelasticidade"
                                  ],
                                  "tips": "Relacione com flutter em asas: Hamilton modela vibrações.",
                                  "learningObjective": "Identificar e aplicar o enunciado em problemas reais de modelagem dinâmica.",
                                  "commonMistakes": [
                                    "Não generalizar símbolos além de x e p_x",
                                    "Ignorar condições de contorno"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma asa de aeronave modelada como viga flexível, use δ∫ (p dq - H dt) = 0 para derivar equações de movimento que preveem deformações sob carga aerodinâmica, identificando q como deslocamento transversal, p como momento associado e H como energia do sistema.",
                              "finalVerifications": [
                                "Reproduzir δ∫(L dt) = 0 e δ∫(p dq - H dt) = 0 sem erros.",
                                "Definir precisamente q, p e H com exemplos.",
                                "Explicar equivalência entre formas lagrangiana e hamiltoniana.",
                                "Identificar o enunciado em um problema escrito.",
                                "Derivar equações de Euler-Lagrange a partir do princípio.",
                                "Aplicar a um exemplo simples de sistema conservativo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na reprodução dos enunciados matemáticos (100% correto).",
                                "Clareza na explicação dos símbolos q, p e H.",
                                "Compreensão da variação δ e seu significado físico.",
                                "Capacidade de relacionar com transformação Legendre.",
                                "Aplicação correta em contexto aeroespacial.",
                                "Ausência de confusões com princípios newtonianos ou lagrangianos isolados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo das Variações e Equações Diferenciais.",
                                "Física: Mecânica Clássica e Hamiltoniana.",
                                "Engenharia Aeroespacial: Modelagem de Dinâmica e Aeroelasticidade.",
                                "Computação: Simulações Numéricas em Python/MATLAB.",
                                "Filosofia da Ciência: Princípios de Mínima Ação."
                              ],
                              "realWorldApplication": "No design de aeronaves, o princípio de Hamilton é usado para modelar vibrações estruturais e prever fenômenos como flutter aeroelástico, otimizando estruturas para segurança em voo supersônico."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.2",
                            "name": "Explicar as condições de contorno no princípio variacional",
                            "description": "Descrever as condições de variação nula nas extremidades temporais (δq(T1) = δq(T2) = 0) e sua importância para trajetórias fixas em problemas de dinâmica estrutural aeroespacial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Princípio Variacional de Hamilton",
                                  "subSteps": [
                                    "Leia a definição do princípio: a integral da Lagrangiana L(q, ḓq, t) de T1 a T2 é estacionária para a trajetória real.",
                                    "Entenda que δS = 0 para variações pequenas δq(t).",
                                    "Derive a equação de Euler-Lagrange a partir da condição de estacionariedade.",
                                    "Identifique os limites temporais fixos T1 e T2.",
                                    "Anote os termos de integração por partes na derivação."
                                  ],
                                  "verification": "Escreva a equação de Euler-Lagrange e explique verbalmente por que δS = 0.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Mecânica Analítica (ex: Goldstein), notas de aula sobre Lagrange, calculadora simbólica (SymPy ou Mathematica).",
                                  "tips": "Visualize a Lagrangiana como energia cinética menos potencial para clareza.",
                                  "learningObjective": "Compreender a base matemática do princípio variacional antes das condições de contorno.",
                                  "commonMistakes": "Confundir Lagrangiana com Hamiltoniana; ignorar dependência explícita no tempo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Conceito de Variações δq(t)",
                                  "subSteps": [
                                    "Defina δq(t) como variação arbitrária que some zero nas extremidades para trajetórias fixas.",
                                    "Desenhe curvas de trajetórias reais vs. variadas, destacando δq(T1) = δq(T2) = 0.",
                                    "Explique que δq(t) é infinitesimal e suave (pertence a C⁰ ou superior).",
                                    "Calcule a primeira variação δS explicitamente.",
                                    "Discuta por que variações não-nulas nas extremidades alterariam o problema."
                                  ],
                                  "verification": "Desenhe um diagrama de trajetórias e rotule as condições δq(T1) = δq(T2) = 0.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel quadriculado, lápis, software de plotagem (Matplotlib ou Desmos).",
                                  "tips": "Pense em δq como uma 'perturbação teste' que não muda posições fixas.",
                                  "learningObjective": "Dominar a representação geométrica e matemática das variações com contornos fixos.",
                                  "commonMistakes": "Assumir δq zero em todo o intervalo; confundir com derivadas temporais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar as Condições de Contorno δq(T1) = δq(T2) = 0",
                                  "subSteps": [
                                    "Derive matematicamente os termos de contorno da integração por partes: [δq · δL/δḓq ]_{T1}^{T2} = 0.",
                                    "Mostre que para trajetórias fixas, isso força as condições naturais de variação nula.",
                                    "Compare com condições livres (onde momentum conjugado é zero).",
                                    "Discuta implicações para problemas com extremidades fixas vs. livres.",
                                    "Resolva um exemplo simples: oscilador harmônico com posições iniciais/finais fixas."
                                  ],
                                  "verification": "Derive os termos de contorno em uma folha e verifique que somam zero apenas com δq(T1)=0 e δq(T2)=0.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Caderno de equações, tabela de integrais, simulador online de Lagrange (ex: Wolfram Alpha).",
                                  "tips": "Use notação de Dirac delta conceitualmente para extremidades.",
                                  "learningObjective": "Derivar e justificar rigorosamente as condições de contorno no contexto variacional.",
                                  "commonMistakes": "Esquecer o sinal nos termos de contorno; aplicar condições livres indevidamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Importância em Dinâmica Estrutural Aeroespacial",
                                  "subSteps": [
                                    "Aplique a uma viga em flexão com extremidades fixas (ex: asa de aeronave).",
                                    "Explique como garante trajetórias fixas em simulações de vibrações estruturais.",
                                    "Conecte a aeroelasticidade: controle de flutter com contornos fixos em roots.",
                                    "Analise um caso numérico simples com discretização temporal.",
                                    "Resuma limitações (ex: não-holônomas) e extensões."
                                  ],
                                  "verification": "Explique em 2 minutos como as condições afetam modelagem de uma asa cantilever.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Artigo sobre dinâmica aeroespacial, software FEM básico (ex: ANSYS tutorial gratuito).",
                                  "tips": "Relacione com experimentos reais de vibração modal em estruturas.",
                                  "learningObjective": "Aplicar as condições a contextos aeroespaciais reais, destacando relevância prática.",
                                  "commonMistakes": "Ignorar efeitos dinâmicos não-lineares; superestimar universalidade das condições fixas."
                                }
                              ],
                              "practicalExample": "Considere uma viga cantilever modelada por Lagrange, com deslocamento q(t) fixo em t=0 (q(0)=0) e t=T (q(T)=0). As condições δq(0)=δq(T)=0 garantem que variações não alterem as posições fixas da raiz e ponta, levando à equação de Euler-Lagrange para modos de vibração pura, essencial para análise de flutter em asas de avião.",
                              "finalVerifications": [
                                "Derivar corretamente os termos de contorno da integração por partes.",
                                "Explicar verbalmente por que δq(T1)=δq(T2)=0 para trajetórias fixas.",
                                "Aplicar as condições a um exemplo de oscilador com extremidades fixas.",
                                "Identificar diferenças entre contornos fixos e livres.",
                                "Desenhar diagrama preciso de trajetórias variadas.",
                                "Discutir implicações em um contexto aeroespacial específico."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (90% correto).",
                                "Clareza na explicação conceitual (linguagem acessível e lógica).",
                                "Profundidade na aplicação aeroespacial (exemplo relevante).",
                                "Completude dos subpassos (todos cobertos).",
                                "Criatividade em visualizações/diagramas.",
                                "Identificação de erros comuns e como evitá-los."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo de Variações (matemática avançada).",
                                "Mecânica Clássica e Física Computacional.",
                                "Engenharia Aeroespacial (dinâmica de estruturas).",
                                "Controle de Sistemas (condições de contorno em OTP).",
                                "Programação Numérica (simulações Lagrangeanas)."
                              ],
                              "realWorldApplication": "Em projetos de aeronaves, essas condições são usadas em simulações FEM para prever vibrações de asas com raízes fixas, prevenindo flutter catastrófico (ex: incidente do Lockheed Electra), otimizando trajetórias de lançamento de foguetes e modelando deformações estruturais sob cargas dinâmicas."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.3",
                            "name": "Diferenciar princípio de Hamilton de princípios variacionais clássicos",
                            "description": "Comparar o princípio de Hamilton com o de d'Alembert ou Hamilton direto, destacando sua base em momentos conjugados para modelagem de estruturas aeroespaciais com múltiplos graus de liberdade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Princípios Variacionais Clássicos (d'Alembert e Lagrange)",
                                  "subSteps": [
                                    "Estude a formulação do princípio de d'Alembert: δ∫(T - V)dt + δW = 0, onde T é energia cinética, V potencial e W trabalho virtual.",
                                    "Derive as equações de movimento a partir do princípio de Lagrange: d/dt(∂L/∂q̇) - ∂L/∂q = 0, com L = T - V.",
                                    "Identifique limitações: dependência de coordenadas generalizadas e dificuldade com restrições não holonômicas.",
                                    "Resuma exemplos simples como pêndulo duplo para ilustrar aplicação.",
                                    "Compare com princípios newtonianos para contextualizar a abordagem variacional."
                                  ],
                                  "verification": "Derive corretamente as equações de Lagrange para um sistema de 2 graus de liberdade e explique sua relação com d'Alembert.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Classical Mechanics' de Goldstein",
                                    "Notas de aula sobre Mecânica Lagrangiana",
                                    "Calculadora simbólica (SymPy ou Mathematica)"
                                  ],
                                  "tips": "Use diagramas de forças virtuais para visualizar d'Alembert; memorize a identidade ∂L/∂q̇ = p (momentum generalizado).",
                                  "learningObjective": "Compreender a base variacional clássica focada em energia e trabalho virtual.",
                                  "commonMistakes": [
                                    "Confundir δW com forças reais em vez de virtuais",
                                    "Esquecer o termo d/dt na equação de Euler-Lagrange",
                                    "Aplicar a sistemas com restrições sem coordenadas reduzidas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Princípio de Hamilton e sua Formulação",
                                  "subSteps": [
                                    "Defina o Hamiltoniano H = p·q̇ - L, onde p são momentos conjugados.",
                                    "Estude as equações canônicas: q̇ = ∂H/∂p, ṗ = -∂H/∂q.",
                                    "Derive o princípio variacional de Hamilton: δ∫(p·δq - H dt) = 0.",
                                    "Explique a transformação de Legendre de velocidades para momentos conjugados.",
                                    "Resolva um exemplo simples como oscilador harmônico usando Hamilton.",
                                    "verification: "
                                  ],
                                  "verification": "Escreva as equações canônicas para um sistema com H = p²/2m + V(q) e verifique conservação de energia.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "'Mechanics' de Landau e Lifshitz",
                                    "Software MATLAB para simulação numérica",
                                    "Folhas de papel para derivações"
                                  ],
                                  "tips": "Sempre verifique se H é conservado (dH/dt = 0 para sistemas autônomos); pratique fase space.",
                                  "learningObjective": "Dominar a formulação hamiltoniana em termos de momentos conjugados.",
                                  "commonMistakes": [
                                    "Confundir H com L diretamente sem transformação Legendre",
                                    "Esquecer sinal negativo em ṗ",
                                    "Usar coordenadas erradas para momentos conjugados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Princípio de Hamilton com Clássicos",
                                  "subSteps": [
                                    "Liste diferenças chave: Hamilton usa (q,p) vs (q,q̇); simetria em equações canônicas vs assimetria em Lagrange.",
                                    "Destaque momentos conjugados: facilitam quantização e simulações numéricas.",
                                    "Compare para múltiplos graus de liberdade: Hamilton preserva estrutura simplética.",
                                    "Analise estabilidade: Hamilton melhor para caos e integradores simétricos.",
                                    "Crie tabela comparativa: formulação, conservação, aplicações."
                                  ],
                                  "verification": "Preencha tabela comparativa com 5 diferenças principais e justifique cada uma com equação.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Artigo 'Hamiltonian vs Lagrangian' (PDF acadêmico)",
                                    "Planilha Excel para tabela",
                                    "Vídeo Khan Academy sobre Hamiltoniano"
                                  ],
                                  "tips": "Foque em momentos conjugados como 'ponte' para mecânica quântica; teste com sistema acoplado.",
                                  "learningObjective": "Identificar e explicar diferenças fundamentais, especialmente para modelagem complexa.",
                                  "commonMistakes": [
                                    "Ignorar simetria canônica",
                                    "Achar Hamilton 'apenas reformulação' sem vantagens numéricas",
                                    "Confundir Hamilton direto com variacional"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar à Modelagem de Estruturas Aeroespaciais",
                                  "subSteps": [
                                    "Modele uma estrutura com múltiplos DOF, ex: viga flexível como q_i deslocamentos, p_i momentos.",
                                    "Formule H para sistema aeroelástico: inclua termos aerodinâmicos em potencial.",
                                    "Simule numericamente usando integrador simplético (ex: Verlet).",
                                    "Compare resultados Lagrange vs Hamilton para precisão em tempo longo.",
                                    "Discuta vantagens em aeroespacial: estabilidade para flutter."
                                  ],
                                  "verification": "Implemente simulação simples em Python e plote trajetórias em fase space.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Exemplo de código GitHub para Hamiltoniano aeroespacial",
                                    "Artigo sobre aeroelasticidade"
                                  ],
                                  "tips": "Use coordenadas modais para reduzir DOF; valide com energia conservada.",
                                  "learningObjective": "Aplicar comparação em contexto aeroespacial real.",
                                  "commonMistakes": [
                                    "Negligenciar acoplamento aerodinâmico",
                                    "Usar integrador não-simétrico levando a drift de energia",
                                    "Escolher mal momentos conjugados"
                                  ]
                                }
                              ],
                              "practicalExample": "Modelar o movimento de um painel de asa flexível com 3 modos vibracionais: use Lagrange para equações iniciais, transforme para Hamilton com p_i = ∂L/∂q̇_i, simule flutter sob fluxo aerodinâmico e observe como Hamilton preserva energia melhor em simulações longas.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 diferenças chave entre Hamilton e d'Alembert/Lagrange.",
                                "Derivar equações canônicas para sistema aeroespacial com 2 DOF.",
                                "Identificar momentos conjugados corretamente em exemplo dado.",
                                "Comparar estabilidade numérica em simulação simples.",
                                "Discutir aplicação em estruturas com múltiplos DOF sem erros.",
                                "Preencher tabela comparativa sem falhas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de H e equações canônicas (30%)",
                                "Correta identificação de diferenças, especialmente momentos conjugados (25%)",
                                "Qualidade da tabela comparativa e exemplos (20%)",
                                "Aplicação correta a modelagem aeroespacial (15%)",
                                "Clareza na explicação verbal/escrita (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Mecânica Quântica: Hamiltoniano como base para equação de Schrödinger.",
                                "Engenharia de Controle: Sistemas hamiltonianos para controle ótimo.",
                                "Física Computacional: Integradores simpléticos em simulações.",
                                "Matemática Aplicada: Geometria simplética e variedades.",
                                "Ciência de Dados: Análise de fase space em ML para dinâmica."
                              ],
                              "realWorldApplication": "Na indústria aeroespacial, o princípio de Hamilton é usado pela NASA e Boeing para modelar aeroelasticidade em asas de aviões (ex: prevenção de flutter no Boeing 737), permitindo simulações precisas de estruturas com centenas de DOF onde métodos clássicos divergem devido a instabilidades numéricas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.2",
                        "name": "Ação Integral e Hamiltoniano",
                        "description": "Definição da ação integral S como ∫(T - V) dt ou ∫(p · ḗq - H) dt, e introdução do hamiltoniano H = T + V como função de q, p e t, fundamental para derivar equações canônicas em dinâmica de estruturas.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.2.1",
                            "name": "Calcular a ação integral para sistemas simples",
                            "description": "Computar S = ∫_{t1}^{t2} L(q, ḗq, t) dt para um oscilador harmônico, identificando sua relação com vibrações estruturais de um grau de liberdade em aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o Lagrangiano para o oscilador harmônico",
                                  "subSteps": [
                                    "Identifique as coordenadas generalizadas: posição q(t) e velocidade ḟq(t) = dq/dt.",
                                    "Escreva a energia cinética T = (1/2) m ḟq², onde m é a massa.",
                                    "Escreva a energia potencial V = (1/2) k q², onde k é a constante da mola.",
                                    "Formule o Lagrangiano L = T - V = (1/2) m ḟq² - (1/2) k q².",
                                    "Confirme que L não depende explicitamente de t para sistemas simples."
                                  ],
                                  "verification": "Verifique se L(q, ḟq, t) está corretamente expresso e independe de t.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de mecânica lagrangiana, papel e caneta ou software como Mathematica.",
                                  "tips": "Lembre-se de que T é sempre positiva e quadrática em velocidades.",
                                  "learningObjective": "Compreender a estrutura do Lagrangiano para sistemas conservativos de 1 grau de liberdade.",
                                  "commonMistakes": "Confundir T e V, ou esquecer o sinal negativo em L = T - V."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a ação integral S",
                                  "subSteps": [
                                    "Defina os limites de integração: de t1 a t2.",
                                    "Escreva S = ∫_{t1}^{t2} L(q, ḟq, t) dt.",
                                    "Substitua L: S = ∫_{t1}^{t2} [(1/2) m ḟq² - (1/2) k q²] dt.",
                                    "Escolha uma trajetória teste q(t), como q(t) = A cos(ω t + φ), com ω = sqrt(k/m).",
                                    "Expresse ḟq(t) = -A ω sin(ω t + φ)."
                                  ],
                                  "verification": "Confirme que a expressão de S está integral e parametrizada corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora simbólica ou software de integração como SymPy.",
                                  "tips": "Use uma solução conhecida do movimento harmônico para simplificar.",
                                  "learningObjective": "Formular a ação como funcional da trajetória q(t).",
                                  "commonMistakes": "Esquecer de expressar ḟq em termos de q(t) antes de integrar."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a integral da ação",
                                  "subSteps": [
                                    "Separe a integral: S = (1/2)m ∫ ḟq² dt - (1/2)k ∫ q² dt.",
                                    "Compute ∫ q² dt = ∫ A² cos²(ω t + φ) dt = (A²/2) (t + sin(2(ω t + φ))/(2ω)) de t1 a t2.",
                                    "Compute ∫ ḟq² dt = ∫ A² ω² sin²(ω t + φ) dt = (A² ω² / 2) (t - sin(2(ω t + φ))/(2ω)) de t1 a t2.",
                                    "Simplifique para período completo: S ≈ (m ω A² / 4) (t2 - t1) para grandes intervalos.",
                                    "Avalie numericamente para valores específicos, ex: m=1, k=1, A=1, t2-t1=2π/ω."
                                  ],
                                  "verification": "O valor numérico de S deve ser finito e positivo para trajetórias físicas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de matemática (MATLAB, Python com SciPy), quadro branco.",
                                  "tips": "Use identidades trigonométricas: cos²θ = (1 + cos2θ)/2.",
                                  "learningObjective": "Executar a integração analítica ou numérica da ação.",
                                  "commonMistakes": "Erros em limites de integração ou simplificação de integrais trigonométricas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar com vibrações estruturais aeroespaciais",
                                  "subSteps": [
                                    "Identifique o oscilador como modelo de 1 DOF para estruturas (ex: viga com massa concentrada).",
                                    "Discuta minimização de S: via princípio variacional, leva às EDO de Euler-Lagrange.",
                                    "Conecte com aeroelasticidade: modos de flutter em asas modelados similarmente.",
                                    "Compare S com energia total: para trajetórias estacionárias, dS=0.",
                                    "Simule variação de parâmetros (m, k) e observe impacto em S."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a conexão com vibrações de 1 DOF em aeronaves.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Artigos sobre dinâmica aeroespacial, simulador como ANSYS.",
                                  "tips": "Pense em q como deslocamento modal normalizado.",
                                  "learningObjective": "Aplicar o conceito de ação a contextos de engenharia aeroespacial.",
                                  "commonMistakes": "Ignorar dissipação ou acoplamentos em sistemas reais."
                                }
                              ],
                              "practicalExample": "Para um oscilador com m=1 kg, k=9.87 N/m (ω≈π rad/s), q(t)=sin(π t), t de 0 a 2s: L=(1/2)ḟq² - (1/2)q², S=∫L dt ≈ 0.363 (calculado via integração numérica).",
                              "finalVerifications": [
                                "Deriva corretamente L para oscilador harmônico.",
                                "Computa S para trajetória harmônica com erro <5%.",
                                "Identifica EDO de Euler-Lagrange a partir de δS=0.",
                                "Relaciona S com período de vibração T=2π/ω.",
                                "Explica aplicação em modelo de ala cantilever.",
                                "Simula variação de A e observa proporcionalidade em S."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação de L (100% correto).",
                                "Correção na integração de S (erro <1% numérico).",
                                "Profundidade na interpretação variacional.",
                                "Clareza na conexão com aeroespaciais.",
                                "Criatividade em exemplos práticos.",
                                "Eficiência temporal nos cálculos."
                              ],
                              "crossCurricularConnections": [
                                "Física Quântica: Ação em mecânica quântica via integral de caminhos.",
                                "Controle de Sistemas: Otimização de trajetórias via Hamiltoniano.",
                                "Engenharia Mecânica: Análise modal de estruturas.",
                                "Matemática: Cálculo variacional e integrais funcionais."
                              ],
                              "realWorldApplication": "Em aeroespaciais, calcular a ação integral modela vibrações de painéis ou asas (1 DOF), essencial para prever flutter crítico em aeronaves como o Boeing 737, otimizando design para evitar falhas estruturais durante o voo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.2.2",
                            "name": "Construir o hamiltoniano a partir do lagrangiano",
                            "description": "Aplicar a transformação Legendre para obter H(q, p, t) = p ḗq - L, exemplificando com sistemas estruturais como vigas ou placas aeroelásticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e analisar os componentes do Lagrangiano",
                                  "subSteps": [
                                    "Escreva o Lagrangiano L(q, ḟq, t) para o sistema dado, separando termos cinéticos T e potenciais V.",
                                    "Identifique as coordenadas generalizadas q e suas velocidades ḟq.",
                                    "Verifique dependências explícitas em tempo t.",
                                    "Simplifique expressões se possível, garantindo L = T - V.",
                                    "Anote graus de liberdade do sistema."
                                  ],
                                  "verification": "Confirme que L está corretamente escrito e derivado do problema, sem erros algébricos iniciais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor LaTeX/Mathematica",
                                    "Referência do problema (ex: equações de viga aeroelástica)"
                                  ],
                                  "tips": "Comece com sistemas simples como oscilador harmônico antes de estruturas complexas.",
                                  "learningObjective": "Compreender a estrutura do Lagrangiano para sistemas estruturais.",
                                  "commonMistakes": [
                                    "Confundir T e V",
                                    "Ignorar dependências em t",
                                    "Erros em derivadas parciais iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os momentos conjugados p via transformação Legendre",
                                  "subSteps": [
                                    "Compute p_i = ∂L / ∂ḟq_i para cada coordenada q_i.",
                                    "Expresse p em termos de q, ḟq e t.",
                                    "Verifique se p é linear em ḟq para sistemas padrão.",
                                    "Resolva equações se p for implícito em ḟq.",
                                    "Anotar matriz Jacobiana se múltiplas DOFs."
                                  ],
                                  "verification": "Derivadas parciais ∂L/∂ḟq devem coincidir com definição canônica de momento.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Calculadora simbólica (SymPy ou Mathematica)",
                                    "Folha de derivadas parciais"
                                  ],
                                  "tips": "Use notação indexada para múltiplas coordenadas em vigas/placas.",
                                  "learningObjective": "Dominar definição de momentos generalizados.",
                                  "commonMistakes": [
                                    "Derivar errado ∂L/∂ḟq",
                                    "Esquecer fatores de massa em T",
                                    "Não considerar ḟq vetorial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver velocidades ḟq em termos de momentos p",
                                  "subSteps": [
                                    "Inverta a relação p = ∂L/∂ḟq para obter ḟq = ḟq(q, p, t).",
                                    "Para T quadrático em ḟq, use inversa da matriz de massa.",
                                    "Substitua em expressões algébricas, simplificando.",
                                    "Verifique invertibilidade (matriz hessiana positiva definida).",
                                    "Teste com valores numéricos simples."
                                  ],
                                  "verification": "Substitua p de volta e recupere L original.",
                                  "estimatedTime": "1 hora 15 minutos",
                                  "materials": [
                                    "Software de álgebra computacional",
                                    "Matriz inversora manual"
                                  ],
                                  "tips": "Assuma forma cinética T = (1/2) m ḟq² para inícios simples.",
                                  "learningObjective": "Executar transformação Legendre explicitamente.",
                                  "commonMistakes": [
                                    "Inversão incorreta de matrizes",
                                    "Introduzir singularidades",
                                    "Perder termos em t"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e verificar o Hamiltoniano H(q, p, t)",
                                  "subSteps": [
                                    "Calcule H = Σ p_i ḟq_i - L(q, ḟq(q,p,t), t).",
                                    "Substitua ḟq por sua expressão em p.",
                                    "Simplifique para mostrar H = T + V em coordenadas (q,p).",
                                    "Verifique equações de Hamilton: ḟq = ∂H/∂p, ṗ = -∂H/∂q.",
                                    "Compare com forma esperada para o sistema."
                                  ],
                                  "verification": "Equações de Hamilton devem reproduzir equações de Lagrange originais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Verificador simbólico",
                                    "Exemplo resolvido de referência"
                                  ],
                                  "tips": "Mantenha consistência de notação em somatórios.",
                                  "learningObjective": "Finalizar transformação L → H corretamente.",
                                  "commonMistakes": [
                                    "Sinal errado em H",
                                    "Não substituir todos ḟq",
                                    "Erros de simplificação"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma viga Euler-Bernoulli aeroelástica simples com deslocamento w(x,t), L = ∫ [ (ρA/2)(∂w/∂t)² - (EI/2)(∂²w/∂x²)² ] dx - ∫ p(x,t) w dx. Compute p = ρA ∂w/∂t, resolva ∂w/∂t = p/ρA, então H = ∫ [ (1/(2ρA)) p² + (EI/2)(∂²w/∂x²)² + p w ] dx.",
                              "finalVerifications": [
                                "H depende apenas de q, p, t (sem ḟq velhas).",
                                "∂H/∂p_i = ḟq_i e ∂H/∂q_i = -ṗ_i.",
                                "Energia total conservada se autônomo.",
                                "H = T + V em novas variáveis.",
                                "Consistência dimensional verificada.",
                                "Simulação numérica breve reproduz dinâmica."
                              ],
                              "assessmentCriteria": [
                                "Correção das derivadas ∂L/∂ḟq (30%).",
                                "Inversão precisa e simplificação (25%).",
                                "Construção final de H sem erros algébricos (20%).",
                                "Verificação das equações canônicas (15%).",
                                "Aplicação ao exemplo estrutural (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física Quântica: Hamiltoniano em mecânica quântica.",
                                "Controle de Sistemas: Formulações Hamiltonianas em controle ótimo.",
                                "Engenharia Computacional: Simulações em MATLAB/Simulink.",
                                "Matemática Aplicada: Variacional e transformações de Legendre."
                              ],
                              "realWorldApplication": "Em aeroelasticidade, permite simulações eficientes de flutter em asas de aeronaves usando integradores simétricos preservadores de energia, essenciais para certificação de segurança em projetos da Boeing ou Embraer."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.2.3",
                            "name": "Interpretar propriedades do hamiltoniano",
                            "description": "Explicar conservação de energia quando ∂H/∂t = 0 e sua relevância para respostas dinâmicas estacionárias em excitações harmônicas de estruturas aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar definição e formulação do Hamiltoniano",
                                  "subSteps": [
                                    "Estude a transformação de Lagrange para Hamiltoniano via momenta conjugados: p = ∂L/∂q̇.",
                                    "Escreva a expressão geral do Hamiltoniano H = p q̇ - L(q, q̇, t).",
                                    "Identifique componentes cinéticas e potenciais no Hamiltoniano para sistemas conservativos.",
                                    "Pratique com um exemplo simples de oscilador harmônico.",
                                    "Discuta dependência explícita de tempo no Hamiltoniano."
                                  ],
                                  "verification": "Derivar corretamente H para um oscilador harmônico e identificar termos independentes de tempo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Mecânica Clássica (Goldstein), caderno de anotações, calculadora simbólica (SymPy ou Mathematica).",
                                  "tips": "Sempre verifique unidades: H deve ter unidades de energia.",
                                  "learningObjective": "Compreender a estrutura matemática do Hamiltoniano e sua relação com a Lagrangiana.",
                                  "commonMistakes": "Confundir H com L; esquecer o sinal negativo em H = p q̇ - L."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a derivada temporal parcial do Hamiltoniano ∂H/∂t",
                                  "subSteps": [
                                    "Derive a relação dH/dt = ∂H/∂t + (∂H/∂q) q̇ + (∂H/∂p) ṗ.",
                                    "Use as equações de Hamilton: q̇ = ∂H/∂p, ṗ = -∂H/∂q para simplificar.",
                                    "Mostre que dH/dt = ∂H/∂t para sistemas autônomos.",
                                    "Explique o significado físico: taxa de mudança total da energia.",
                                    "Calcule ∂H/∂t para um sistema dissipativo vs. conservativo."
                                  ],
                                  "verification": "Provar matematicamente que dH/dt = ∂H/∂t e interpretá-la verbalmente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel quadriculado, software de álgebra simbólica, vídeo tutorial sobre mecânica hamiltoniana.",
                                  "tips": "Lembre-se: ∂H/∂t é a dependência explícita de t, não total.",
                                  "learningObjective": "Dominar a interpretação matemática de ∂H/∂t como indicador de conservação.",
                                  "commonMistakes": "Ignorar termos de Poisson brackets; confundir derivada parcial com total."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar conservação de energia quando ∂H/∂t = 0",
                                  "subSteps": [
                                    "Demonstre que ∂H/∂t = 0 implica H constante (energia conservada).",
                                    "Aplique a oscilador harmônico: verifique H = (p²/2m) + (k q²/2).",
                                    "Discuta implicações para trajetórias em espaço de fase fechadas.",
                                    "Compare com sistemas não-conservativos (ex.: atrito).",
                                    "Simule numericamente conservação usando integrador Hamiltoniano."
                                  ],
                                  "verification": "Simulação ou prova mostrando H constante ao longo do tempo.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Python com SciPy para simulação, gráficos de fase.",
                                  "tips": "Use simetrias de Noether para intuír conservação.",
                                  "learningObjective": "Associar ∂H/∂t = 0 diretamente à conservação de energia total.",
                                  "commonMistakes": "Assumir conservação sem verificar dependência de tempo explícita."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a respostas dinâmicas estacionárias em excitações harmônicas aeroespaciais",
                                  "subSteps": [
                                    "Modele uma estrutura aeroespacial (ex.: viga cantilever simulando asa) com excitação harmônica F(t) = F0 cos(ωt).",
                                    "Formule Hamiltoniano incluindo termo de excitação externa.",
                                    "Analise ∂H/∂t ≠ 0 devido à força externa, mas estado estacionário em resposta harmônica.",
                                    "Calcule resposta estacionária: q(t) = A cos(ωt + φ), verificando energia média constante.",
                                    "Discuta relevância para aeroelasticidade (evitar ressonância)."
                                  ],
                                  "verification": "Derivar resposta estacionária e explicar por que energia não é estritamente conservada mas estável.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Software FEM (ANSYS ou MATLAB), artigos sobre aeroelasticidade.",
                                  "tips": "Foco em soluções particulares para não-homogeneidades.",
                                  "learningObjective": "Conectar teoria hamiltoniana a aplicações práticas em engenharia aeroespacial.",
                                  "commonMistakes": "Negligenciar transientes iniciais; confundir conservação com estado estacionário."
                                }
                              ],
                              "practicalExample": "Considere uma asa de aeronave modelada como viga com excitação harmônica devido a turbulência. Formule H incluindo forças aerodinâmicas dependentes de t. Mostre que apesar de ∂H/∂t ≠ 0, a resposta em regime permanente tem amplitude constante, ilustrando 'estacionariedade dinâmica' sem conservação estrita de energia.",
                              "finalVerifications": [
                                "Explicar verbalmente por que ∂H/∂t = 0 implica conservação de energia.",
                                "Derivar dH/dt para um sistema genérico.",
                                "Aplicar a um modelo de estrutura aeroespacial com excitação harmônica.",
                                "Simular numericamente e plotar H(t) para verificar constância.",
                                "Discutir limitações em sistemas reais com dissipação."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de ∂H/∂t (90% correto).",
                                "Interpretação física clara e concisa da conservação.",
                                "Aplicação correta a excitações harmônicas (incluindo fase e amplitude).",
                                "Uso de exemplos aeroespaciais relevantes.",
                                "Identificação de erros comuns e limitações.",
                                "Qualidade da simulação ou gráfico de verificação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e equações diferenciais ordinárias.",
                                "Física: Mecânica clássica e teoria de controle (estabilidade).",
                                "Engenharia: Análise modal em estruturas e dinâmica de fluidos (aeroelasticidade).",
                                "Computação: Simulações numéricas e métodos de integração simplética."
                              ],
                              "realWorldApplication": "Em projetos de aeronaves, essa interpretação previne falhas por flutter (ressonância harmônica), otimizando designs de asas e hélices para respostas estacionárias seguras sob cargas aerodinâmicas variáveis, como em aviões comerciais ou drones."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.3",
                        "name": "Derivação das Equações de Movimento via Princípio de Hamilton",
                        "description": "Processo de variações da ação integral levando às equações canônicas ḗq = ∂H/∂p e ḗp = -∂H/∂q, aplicadas à obtenção de equações de movimento para sistemas estruturais.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.3.1",
                            "name": "Executar a variação da ação integral",
                            "description": "Realizar δS = ∫ [∂L/∂q δq + ∂L/∂ḗq δḗq] dt = 0, integrando por partes para derivar equações de Euler-Lagrange e transição para forma hamiltoniana.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a Ação Integral e sua Variação Inicial",
                                  "subSteps": [
                                    "Escreva a ação S = ∫_{t1}^{t2} L(q, ḟq, t) dt, onde L é o lagrangiano.",
                                    "Introduza uma variação infinitesimal δq(t) com δq(t1) = δq(t2) = 0.",
                                    "Compute δS = ∫_{t1}^{t2} [ (∂L/∂q) δq + (∂L/∂q̇) δq̇ ] dt.",
                                    "Estabeleça a condição δS = 0 para caminhos estacionários.",
                                    "Verifique a notação e limites de integração."
                                  ],
                                  "verification": "Confirme que δS está corretamente expandida em termos de δq e δq̇, com condições de contorno aplicadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis, calculadora simbólica (ex: SymPy ou Mathematica), referência de mecânica lagrangiana.",
                                  "tips": "Use δq pequeno e independente para simplificar; anote todos os termos explicitamente.",
                                  "learningObjective": "Compreender a base variacional do princípio de Hamilton.",
                                  "commonMistakes": "Esquecer as condições de contorno δq(t1)=δq(t2)=0; confundir L com H."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Integrar por Partes o Termo de Velocidade Variada",
                                  "subSteps": [
                                    "Isole o termo ∫ (∂L/∂q̇) δq̇ dt.",
                                    "Aplique integração por partes: u = δq, dv = d/dt[(∂L/∂q̇)] dt? Não: ∫ (∂L/∂q̇) d(δq) = [ (∂L/∂q̇) δq ] - ∫ δq d/dt(∂L/∂q̇).",
                                    "Avalie o termo de contorno: zero devido a δq(t1)=δq(t2)=0.",
                                    "Substitua de volta em δS: ∫ [ ∂L/∂q - d/dt(∂L/∂q̇) ] δq dt = 0.",
                                    "Simplifique para todos os q independentes."
                                  ],
                                  "verification": "O termo de contorno some e δS reduz a ∫ [∂L/∂q - d/dt(∂L/∂q̇)] δq dt = 0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel quadriculado, software de álgebra simbólica para verificação.",
                                  "tips": "Lembre-se da fórmula de integração por partes: ∫ u dv = uv - ∫ v du.",
                                  "learningObjective": "Dominar a técnica de integração por partes na variação.",
                                  "commonMistakes": "Erro no sinal da derivada temporal; ignorar dependência explícita em t."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar as Equações de Euler-Lagrange",
                                  "subSteps": [
                                    "Como δq é arbitrário, o integrando deve ser zero: ∂L/∂q - d/dt(∂L/∂q̇) = 0.",
                                    "Escreva explicitamente as equações de Euler-Lagrange para um sistema com múltiplas coordenadas.",
                                    "Verifique para um exemplo simples, como oscilador harmônico: L = ṁq̇²/2 - ½kq².",
                                    "Confirme que reproduce ̈q + ω²q = 0.",
                                    "Discuta generalizações para restrições ou forças não-conservativas."
                                  ],
                                  "verification": "Equações E-L derivadas corretamente e testadas em um exemplo conhecido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Exemplos resolvidos de livros (ex: Goldstein), SymPy para derivação automática.",
                                  "tips": "Teste sempre com um sistema 1D para validação rápida.",
                                  "learningObjective": "Extrair equações de movimento do princípio variacional.",
                                  "commonMistakes": "Invertar o sinal das E-L; esquecer derivada total em t."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Transição para a Forma Hamiltoniana",
                                  "subSteps": [
                                    "Defina momentos conjugados p = ∂L/∂q̇.",
                                    "Compute o hamiltoniano H = p ḟq - L via transformação de Legendre.",
                                    "Mostre que as E-L implicam ḟq = ∂H/∂p, ṗ = -∂H/∂q.",
                                    "Verifique conservação de H para sistemas autônomos.",
                                    "Aplique a um exemplo, derivando H para o oscilador."
                                  ],
                                  "verification": "Equações de Hamilton derivadas e verificadas: {q,p} Poisson bracket gera dinâmica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Tabela de transformações L->H, software para plotar fase space.",
                                  "tips": "Use a identidade dH/dt = ∂L/∂t para provar conservação.",
                                  "learningObjective": "Conectar formulações lagrangiana e hamiltoniana.",
                                  "commonMistakes": "Erro na definição de H (esquecer sinal); não verificar invertibilidade da Legendre."
                                }
                              ],
                              "practicalExample": "Para um pêndulo simples: L = ½ m l² θ̇² - m g l (1 - cos θ). Compute δS, integre por partes, derive θ̈ + (g/l) sin θ = 0, então H = p²/(2 m l²) + m g l (1 - cos θ), com p = m l² θ̇.",
                              "finalVerifications": [
                                "δS corretamente reduz a zero via E-L.",
                                "Equações de Euler-Lagrange coincidem com derivadas newtonianas.",
                                "Transformação L -> H é canônica e preserva dinâmica.",
                                "Exemplo numérico resolvido sem erros algébricos.",
                                "Condições de contorno aplicadas consistentemente.",
                                "Conservação do hamiltoniano verificada para sistema autônomo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na expansão de δS e integração por partes (80%).",
                                "Correta derivação das E-L e transição hamiltoniana (90%).",
                                "Uso correto de notação e condições de contorno (100%).",
                                "Validação via exemplo prático sem discrepâncias.",
                                "Clareza na explicação de passos intermediários.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Física Quântica: Princípio variacional leva a equação de Schrödinger.",
                                "Otimização Numérica: Métodos de gradiente descendente análogos.",
                                "Engenharia de Controle: Formulações hamiltonianas em MPC.",
                                "Matemática Computacional: SymPy para derivações simbólicas."
                              ],
                              "realWorldApplication": "Em dinâmica aeroespacial, deriva equações de movimento para estruturas flexíveis em aeronaves, permitindo simulações de flutter e estabilidade via software como NASTRAN, otimizando design contra vibrações catastróficas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.3.2",
                            "name": "Derivar equações canônicas de Hamilton",
                            "description": "Obter ḗq_i = ∂H/∂p_i e ḗp_i = -∂H/∂q_i para sistemas com n graus de liberdade, aplicando a um modelo estrutural aeroespacial simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Hamiltoniano e o Princípio Variacional",
                                  "subSteps": [
                                    "Revise a ação de Hamilton S = ∫ (p_i ḟq_i - H(q, p, t)) dt",
                                    "Defina o Hamiltoniano H como H = T + V, expresso em coordenadas generalizadas q_i e momentos conjugados p_i",
                                    "Entenda o princípio variacional: δS = 0 leva às equações canônicas",
                                    "Identifique transformações de Lagrange para Hamilton",
                                    "Pratique convertendo um Lagrangiano simples L = T - V para H"
                                  ],
                                  "verification": "Escreva a expressão de H para um sistema massa-mola simples e confirme que ∂L/∂ḟq = p",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Livro de Mecânica Clássica (Goldstein ou similar)",
                                    "Papel e caneta",
                                    "Calculadora simbólica (SymPy ou Mathematica)"
                                  ],
                                  "tips": [
                                    "Comece com sistemas conservativos onde H é tempo-independente",
                                    "Visualize q e p como posição e momento no espaço de fase"
                                  ],
                                  "learningObjective": "Dominar a definição e propriedades do Hamiltoniano H",
                                  "commonMistakes": [
                                    "Confundir H com L diretamente",
                                    "Esquecer de expressar velocidades em termos de p_i"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar as Equações Canônicas Gerais",
                                  "subSteps": [
                                    "Parta da variação δS = [p_i δq_i]_{t1}^{t2} + ∫ (ḟq_i δp_i - ḟp_i δq_i) dt = 0",
                                    "Aplique condições de contorno δq(t1)=δq(t2)=0 para obter ḟq_i = ∂H/∂p_i",
                                    "Similarmente, derive ḟp_i = -∂H/∂q_i",
                                    "Verifique para n=1 grau de liberdade (ex: oscilador harmônico)",
                                    "Generalize para n graus de liberdade, indexando i=1 a n"
                                  ],
                                  "verification": "Derive explicitamente as equações para um oscilador harmônico e resolva numericamente uma trajetória",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Folhas de cálculo",
                                    "Software de simulação (Python com SciPy)",
                                    "Notas de aula sobre Hamilton"
                                  ],
                                  "tips": [
                                    "Use integração por partes na variação para clareza",
                                    "Lembre-se: as equações são de primeira ordem no espaço de fase"
                                  ],
                                  "learningObjective": "Derivar rigorosamente as equações ḟq_i = ∂H/∂p_i e ḟp_i = -∂H/∂q_i",
                                  "commonMistakes": [
                                    "Erros de sinal em ḟp_i",
                                    "Não generalizar corretamente para múltiplos DOF"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a Sistemas com n Graus de Liberdade",
                                  "subSteps": [
                                    "Escolha um sistema com n=2 DOF, como um pêndulo duplo",
                                    "Calcule momentos p_i = ∂L/∂ḟq_i",
                                    "Formule H(q1,q2,p1,p2,t)",
                                    "Escreva o vetor de equações: ḟQ = J ∇H, onde J é a matriz simplética",
                                    "Simule numericamente usando método de Runge-Kutta"
                                  ],
                                  "verification": "Implemente em código e plote órbitas no espaço de fase, confirmando conservação de H",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Python/Jupyter Notebook",
                                    "Bibliotecas NumPy, SciPy, Matplotlib"
                                  ],
                                  "tips": [
                                    "Use coordenadas generalizadas para reduzir complexidade",
                                    "Verifique se H é conservado ao longo da simulação"
                                  ],
                                  "learningObjective": "Manipular equações canônicas para sistemas multi-DOF",
                                  "commonMistakes": [
                                    "Índices errados em matrizes para n>1",
                                    "Não legendar p_i corretamente de L"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a um Modelo Estrutural Aeroespacial Simples",
                                  "subSteps": [
                                    "Modele uma viga cantilever como sistema discreto com 1 DOF (deslocamento lateral w(x,t))",
                                    "Defina q = w, T = (1/2) m ḟw², V = (1/2) k w² (aproximação modal)",
                                    "Derive H = p²/(2m) + (1/2) k q², com p = m ḟq",
                                    "Escreva e resolva as equações canônicas",
                                    "Discuta extensões para aeroelasticidade (flutter)"
                                  ],
                                  "verification": "Compare solução analítica com numérica e analise frequências naturais",
                                  "estimatedTime": "2-4 horas",
                                  "materials": [
                                    "Referências aeroespaciais (Bisplinghoff)",
                                    "Software FEM básico (opcional)"
                                  ],
                                  "tips": [
                                    "Use modos normais para discretizar estruturas contínuas",
                                    "Considere acoplamento aerodinâmico futuro"
                                  ],
                                  "learningObjective": "Aplicar equações de Hamilton a contextos aeroespaciais reais",
                                  "commonMistakes": [
                                    "Ignorar dependência temporal em H para sistemas dissipativos",
                                    "Simplificações excessivas no modelo estrutural"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma asa simplificada modelada como viga com deslocamento lateral q(t), H = p²/(2μ) + (1/2) ω² q² + termo aerodinâmico. Derive ḟq = p/μ, ḟp = -ω² q - força_aero, simulando resposta a gust.",
                              "finalVerifications": [
                                "Derive corretamente H e equações para oscilador harmônico",
                                "Simule trajetória em espaço de fase conservando H",
                                "Aplique a viga aeroespacial e identifique frequências",
                                "Explique diferenças vs. equações de Lagrange",
                                "Resolva numericamente para n=2 DOF sem erros",
                                "Discuta simetria em equações canônicas"
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação das equações canônicas (100% corretas)",
                                "Correta formulação de H para sistemas dados (sem erros de sinal)",
                                "Implementação numérica funcional e plots coerentes",
                                "Explicação clara de passos variacionais",
                                "Aplicação contextualizada ao aeroespacial",
                                "Identificação de erros comuns e correções"
                              ],
                              "crossCurricularConnections": [
                                "Física Quântica: Mecânica Hamiltoniana como base para Schrödinger",
                                "Controle de Sistemas: Formas Hamiltonianas em controle ótimo",
                                "Engenharia de Controle: Simulações em espaço de fase para aeronaves",
                                "Matemática Computacional: Integração simplética para estabilidade numérica"
                              ],
                              "realWorldApplication": "Em dinâmica aeroespacial, usado para modelar flutter em asas, simulações de satélites em órbita (n-DOF) e controle não-linear de veículos espaciais, permitindo análise de estabilidade via espaço de fase."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.3.3",
                            "name": "Aplicar o princípio a problemas de dinâmica estrutural",
                            "description": "Usar o princípio para modelar vibrações de uma estrutura com base modal, relacionando com frequências naturais e modos de vibração em aeroelasticidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o Lagrangiano para uma estrutura vibrante",
                                  "subSteps": [
                                    "Defina as coordenadas generalizadas (q_i) representando deslocamentos modais ou nodais da estrutura.",
                                    "Calcule a energia cinética T usando velocidades generalizadas e matriz de massa M.",
                                    "Calcule a energia potencial V usando deslocamentos e rigidez estrutural K.",
                                    "Formule o Lagrangiano L = T - V para o sistema discreto ou contínuo aproximado."
                                  ],
                                  "verification": "Verifique se L é função apenas de q, dq/dt e t, sem derivadas de ordem superior.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": "Livro de Dinâmica Estrutural (ex: Clough & Penzien), MATLAB para matrizes simbólicas.",
                                  "tips": "Comece com um sistema de 2-3 graus de liberdade para validar.",
                                  "learningObjective": "Dominar a expressão do Lagrangiano em termos modais para vibrações estruturais.",
                                  "commonMistakes": "Confundir coordenadas generalizadas com deslocamentos físicos; esquecer termos não lineares iniciais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar equações de movimento via Princípio de Hamilton",
                                  "subSteps": [
                                    "Aplique as equações de Hamilton: d/dt (∂L/∂q̇_i) - ∂L/∂q_i = Q_i, onde Q_i são forças generalizadas.",
                                    "Compute os momentos generalizados p_i = ∂L/∂q̇_i e derive ḟp_i = ∂L/∂q_i + Q_i.",
                                    "Para vibrações livres, defina Q_i = 0 e obtenha M q̈ + K q = 0.",
                                    "Verifique a simetria das matrizes M e K derivadas."
                                  ],
                                  "verification": "Compare as EOM obtidas com a forma padrão M q̈ + C q̇ + K q = 0 para casos dissipativos.",
                                  "estimatedTime": "2 hours",
                                  "materials": "Software simbólico (MATLAB Symbolic Toolbox ou SymPy), papel e lápis para derivação manual.",
                                  "tips": "Use variações δ para validar o princípio variacional discretamente.",
                                  "learningObjective": "Aplicar corretamente o Princípio de Hamilton para obter EOM dinâmicas.",
                                  "commonMistakes": "Erro no sinal das equações de Euler-Lagrange; ignorar dependência explícita no tempo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar análise modal para frequências e modos",
                                  "subSteps": [
                                    "Assuma solução harmônica q(t) = φ e^{iωt} e substitua nas EOM para obter autovalor (K - ω² M) φ = 0.",
                                    "Resolva o problema de autovalores generalizado para ω_n (frequências naturais) e φ_n (modos).",
                                    "Ortogonalize os modos em relação a M e K para base modal desacoplada.",
                                    "Transforme para coordenadas modais η: q = Φ η, obtendo equações desacopladas."
                                  ],
                                  "verification": "Confirme que os modos satisfazem φ_n^T M φ_m = δ_{nm} e φ_n^T K φ_m = ω_n² δ_{nm}.",
                                  "estimatedTime": "2.5 hours",
                                  "materials": "MATLAB eig() ou eigenvalue solvers, exemplo de viga Euler-Bernoulli.",
                                  "tips": "Use decomposição modal para reduzir graus de liberdade em estruturas grandes.",
                                  "learningObjective": "Extrair frequências naturais e modos de vibração de EOM hamiltonianas.",
                                  "commonMistakes": "Não normalizar modos corretamente; confundir frequências com períodos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar com aeroelasticidade e validar modelo",
                                  "subSteps": [
                                    "Inclua forças aerodinâmicas Q_aero como termo forçante nas EOM modais.",
                                    "Analise estabilidade via raízes do polinômio característico, identificando flutter.",
                                    "Simule resposta transitória usando integração numérica (ex: Newmark).",
                                    "Compare frequências modais com dados experimentais ou FEM."
                                  ],
                                  "verification": "Simule e plote modos de vibração; verifique convergência com malha fina.",
                                  "estimatedTime": "2 hours",
                                  "materials": "MATLAB ODE solvers, dados de benchmark de asas (ex: AGARD 445.6).",
                                  "tips": "Comece com aeroelasticidade linear antes de não-linearidades.",
                                  "learningObjective": "Conectar dinâmica estrutural modal com fenômenos aeroelásticos.",
                                  "commonMistakes": "Ignorar acoplamento fluido-estrutura; escalas erradas em unidades."
                                }
                              ],
                              "practicalExample": "Modelar vibrações de uma viga cantilever representando uma asa simplificada: derive EOM via Hamilton para 3 modos, compute ω1=15 Hz, ω2=42 Hz, e simule resposta a pulso aerodinâmico, identificando risco de ressonância em Mach 0.8.",
                              "finalVerifications": [
                                "EOM derivadas coincidem com solução analítica para sistema massa-mola conhecido.",
                                "Frequências modais convergem com aumento de graus de liberdade (>5%).",
                                "Modos visualizados mostram deformações físicas realistas (ex: flexão/torção).",
                                "Simulação numérica estável sem amortecimento artificial.",
                                "Relação com aeroelasticidade: frequência de flutter predita próxima a benchmarks."
                              ],
                              "assessmentCriteria": [
                                "Precisão das EOM derivadas (erro <1% vs. analítico).",
                                "Correta identificação de pelo menos 3 frequências/modos naturais.",
                                "Validação cruzada com software FEM (ex: NASTRAN).",
                                "Explicação clara da relação modal-aeroelasticidade.",
                                "Simulação funcional com plots de tempo/frequência.",
                                "Ausência de erros dimensionais ou numéricos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Problemas de autovalores e cálculo variacional.",
                                "Física: Mecânica lagrangiana e ondulatória.",
                                "Engenharia Computacional: Simulações numéricas e FEM.",
                                "Aerodinâmica: Modelos de forças fluid-estrutura."
                              ],
                              "realWorldApplication": "Projeto de asas de aeronaves para evitar flutter (ex: análise modal no Boeing 787 previne vibrações catastróficas em cruzeiro supersônico)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.3.4",
                            "name": "Comparar equações de Hamilton com Lagrange",
                            "description": "Analisar equivalência entre d²q/dt² formas lagrangianas e equações de primeira ordem hamiltonianas, destacando vantagens para análise numérica em elementos finitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão das Equações de Lagrange",
                                  "subSteps": [
                                    "Defina o Lagrangiano L = T(q, ḗq) - V(q), onde T é energia cinética e V é potencial.",
                                    "Escreva as equações de Euler-Lagrange: d/dt (∂L/∂ḗq_i) - ∂L/∂q_i = 0 para cada coordenada generalizada q_i.",
                                    "Discuta sistemas com múltiplos graus de liberdade (DOF) e forma matricial M(q)ḗ²q + C(q,ḗq)ḗq + K(q)q = F.",
                                    "Resolva um exemplo simples: oscilador harmônico simples, derivando ²q + ω²q = 0.",
                                    "Identifique a natureza de segunda ordem das equações."
                                  ],
                                  "verification": "Derive corretamente as equações de Lagrange para um sistema com 2 DOF e verifique com software simbólico como SymPy.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Classical Mechanics' de Goldstein (cap. 2)",
                                    "SymPy ou Mathematica",
                                    "Papel e calculadora"
                                  ],
                                  "tips": "Sempre expresse T em termos de velocidades generalizadas ḗq para clareza.",
                                  "learningObjective": "Compreender a formulação lagrangiana em segunda ordem e sua representação matricial para dinâmica estrutural.",
                                  "commonMistakes": [
                                    "Confundir energia cinética quadrática com linear",
                                    "Esquecer termos de Coriolis em sistemas não lineares",
                                    "Ignorar dependência de q em M(q)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introdução às Equações de Hamilton",
                                  "subSteps": [
                                    "Defina o Hamiltoniano H(q, p) = p · ḗq - L(q, ḗq), com p_i = ∂L/∂ḗq_i (transformação Legendre).",
                                    "Escreva as equações de Hamilton: ḗq_i = ∂H/∂p_i, ḗp_i = -∂H/∂q_i.",
                                    "Mostre que para sistemas padrão, H = T(p) + V(q), com T quadrático em p.",
                                    "Converta o oscilador harmônico para forma hamiltoniana: qdot = p/m, pdot = -k q.",
                                    "Discuta o fluxo em espaço de fase (q,p) e propriedades conservativas."
                                  ],
                                  "verification": "Transforme um Lagrangiano dado em Hamiltoniano e escreva as equações de primeira ordem corretamente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Notas de aula sobre mecânica hamiltoniana",
                                    "SymPy para transformação automática",
                                    "Gráficos de fase em Python (Matplotlib)"
                                  ],
                                  "tips": "Visualize trajetórias em espaço de fase para intuitar a estrutura simétrica.",
                                  "learningObjective": "Dominar a formulação hamiltoniana em primeira ordem e sua relação com momentos conjugados.",
                                  "commonMistakes": [
                                    "Erro no sinal de pdot",
                                    "Confundir H com L diretamente",
                                    "Não inverter corretamente para ḗq em termos de p"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstração da Equivalência entre Formulações",
                                  "subSteps": [
                                    "Derive as equações de Hamilton a partir de Lagrange via p = ∂L/∂ḗq e substituição.",
                                    "Mostre que diferenciando ḗq = ∂H/∂p obtém-se a segunda derivada equivalente à Euler-Lagrange.",
                                    "Verifique conservação de energia: dH/dt = 0 para sistemas autônomos em ambas.",
                                    "Aplique a um sistema acoplado (ex: pêndulo duplo) e compare soluções numéricas.",
                                    "Analise linearização em torno de equilíbrio em ambas formas."
                                  ],
                                  "verification": "Prove matematicamente que as equações hamiltonianas implicam nas lagrangianas para um sistema genérico.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Artigo sobre princípios variacionais",
                                    "Python/Scipy para simulação numérica",
                                    "Papel para derivações"
                                  ],
                                  "tips": "Use a identidade de Poisson para mostrar simetrias compartilhadas.",
                                  "learningObjective": "Estabelecer rigorosamente a equivalência matemática entre as duas formulações.",
                                  "commonMistakes": [
                                    "Erro na cadeia de diferenciação ao provar equivalência",
                                    "Ignorar restrições holonômicas",
                                    "Assumir H = T + V sem verificação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparação e Vantagens para Análise Numérica",
                                  "subSteps": [
                                    "Compare ordens: Lagrange (2ª ordem, stiff para altos modos) vs Hamilton (1ª ordem, symplectic).",
                                    "Discuta estabilidade: integradores symplectic preservam estrutura em Hamilton.",
                                    "Aplique a elementos finitos: discretização em espaço de fase para dinâmica não linear aeroelástica.",
                                    "Simule erro de energia em Runge-Kutta vs symplectic integrator para uma viga vibrante.",
                                    "Resuma vantagens: melhor para longas simulações, conservação em FEM dinâmico."
                                  ],
                                  "verification": "Implemente uma simulação numérica comparativa mostrando preservação de energia em Hamilton.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Software FEM como ANSYS ou código Python/FEniCS",
                                    "Tutoriais symplectic integrators",
                                    "Dados de viga Euler-Bernoulli"
                                  ],
                                  "tips": "Teste com passos de tempo grandes para destacar divergência em Lagrange.",
                                  "learningObjective": "Identificar vantagens práticas de Hamilton em contextos numéricos aeroespaciais.",
                                  "commonMistakes": [
                                    "Subestimar stiffening em modos altos para Lagrange",
                                    "Não normalizar energia inicial",
                                    "Confundir symplectic com energy-conserving genérico"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma viga Euler-Bernoulli aeroelástica com 2 DOF (flexão e torção), derive equações de Lagrange, transforme para Hamilton, e simule resposta flutter com integrator symplectic em Python, comparando drift de energia após 1000 ciclos.",
                              "finalVerifications": [
                                "Derivar corretamente Hamiltoniano de um Lagrangiano dado com 3 DOF.",
                                "Provar equivalência diferenciando equações hamiltonianas para obter lagrangianas.",
                                "Explicar verbalmente 3 vantagens numéricas de Hamilton em FEM dinâmico.",
                                "Simular um sistema e plotar energia vs tempo, mostrando preservação.",
                                "Identificar quando usar cada formulação em dinâmica aeroespacial.",
                                "Comparar estabilidade para problema stiff com frequências díspares."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações (sem erros algébricos).",
                                "Correta identificação de diferenças estruturais (ordem, espaço de fase).",
                                "Profundidade na análise numérica (uso de symplectic vs explícito).",
                                "Relevância ao contexto aeroelástico (exemplos em estruturas).",
                                "Clareza na comunicação de vantagens e limitações.",
                                "Implementação prática funcional em código/simulação."
                              ],
                              "crossCurricularConnections": [
                                "Computação Científica: Implementação de integradores symplectic em Python/Scipy.",
                                "Engenharia de Controle: Uso de espaço de fase para observabilidade/estabilização.",
                                "Física Computacional: Analogias com mecânica quântica (formulação Hamiltoniana).",
                                "Análise Numérica: Estudo de estabilidade e erro em EDOs stiff.",
                                "Otimização: Princípios variacionais em métodos de elementos finitos."
                              ],
                              "realWorldApplication": "Na simulação de flutter aeroelástico em asas de aeronaves via elementos finitos, as equações de Hamilton permitem integradores symplectic que preservam energia e momentum por longos tempos, reduzindo erros em previsões de instabilidades dinâmicas críticas para certificação FAA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.3",
                    "name": "Hamiltoniano e Equações Canônicas",
                    "description": "Definição do Hamiltoniano H = T + V em termos de momentos conjugados e derivação das equações de Hamilton.",
                    "individualConcepts": [
                      {
                        "id": "57.2.3.1",
                        "name": "Definição do Hamiltoniano",
                        "description": "O Hamiltoniano H é definido como a soma da energia cinética T e potencial V, expressa em termos de coordenadas generalizadas q e momentos conjugados p, ou seja, H(q, p) = T(q, p) + V(q).",
                        "specificSkills": [
                          {
                            "id": "57.2.3.1.1",
                            "name": "Reconhecer a forma do Hamiltoniano",
                            "description": "Identificar e formular o Hamiltoniano H para sistemas conservativos como H = T + V, distinguindo sua dependência de velocidades generalizadas transformadas em momentos conjugados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Lagrangiano para sistemas conservativos",
                                  "subSteps": [
                                    "Estude a definição do Lagrangiano L = T - V, onde T é a energia cinética e V é o potencial.",
                                    "Identifique as velocidades generalizadas ˙q_i nos termos de T.",
                                    "Analise exemplos simples como o oscilador harmônico ou pêndulo simples.",
                                    "Verifique que para sistemas conservativos, L depende explicitamente de q_i e ˙q_i.",
                                    "Anote as equações de Euler-Lagrange derivadas de L."
                                  ],
                                  "verification": "Liste os componentes de L para um sistema dado e explique a dependência em ˙q_i.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Mecânica Clássica (Goldstein ou similar)",
                                    "Caderno de anotações",
                                    "Vídeos introdutórios sobre Lagrangiano no YouTube"
                                  ],
                                  "tips": "Comece com sistemas de 1 grau de liberdade para simplificar.",
                                  "learningObjective": "Compreender a estrutura do Lagrangiano como base para o Hamiltoniano.",
                                  "commonMistakes": [
                                    "Confundir T e V",
                                    "Esquecer que T é quadrático em ˙q_i"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir momentos conjugados",
                                  "subSteps": [
                                    "Defina o momento conjugado p_i = ∂L / ∂˙q_i.",
                                    "Calcule p_i para T homogêneo de grau 2 em ˙q_i, resultando p_i = ∂T / ∂˙q_i.",
                                    "Resolva ˙q_i em função de p_i, obtendo a transformação de Legendre.",
                                    "Verifique que T expresso em p_i e q_i é T = (1/2) sum p_i ˙q_i(p,q).",
                                    "Pratique com um exemplo de duas partículas."
                                  ],
                                  "verification": "Compute p_i e expresse ˙q_i em termos de p_i para um sistema simples.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora simbólica (SymPy ou Mathematica)",
                                    "Folhas de exercícios de mecânica analítica"
                                  ],
                                  "tips": "Lembre que a transformação é canônica e preserva simetrias.",
                                  "learningObjective": "Dominar a transição de velocidades para momentos conjugados.",
                                  "commonMistakes": [
                                    "Erro no cálculo da derivada parcial",
                                    "Não inverter corretamente ˙q_i(p)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular o Hamiltoniano geral",
                                  "subSteps": [
                                    "Defina H(q,p) = sum_i p_i ˙q_i - L(q, ˙q(q,p)).",
                                    "Substitua L = T - V e simplifique usando homogeneidade de T.",
                                    "Mostre que sum p_i ˙q_i = 2T para T quadrático.",
                                    "Conclua que H = T + V.",
                                    "Derive as equações canônicas ˙q_i = ∂H/∂p_i e ˙p_i = -∂H/∂q_i."
                                  ],
                                  "verification": "Escreva a expressão de H a partir de L para um sistema conservativo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Apostila de Mecânica Hamiltoniana",
                                    "Software de álgebra computacional"
                                  ],
                                  "tips": "Use a propriedade de Euler para homogeneidade: sum p ˙q = 2T.",
                                  "learningObjective": "Formular H corretamente a partir da transformação Legendre.",
                                  "commonMistakes": [
                                    "Esquecer o sinal em H = sum p ˙q - L",
                                    "Não reconhecer 2T - T + V = T + V"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reconhecer e distinguir a forma do Hamiltoniano",
                                  "subSteps": [
                                    "Identifique quando H = T(p,q) + V(q), sem ˙q explícitas.",
                                    "Compare com Lagrangiano: H não depende de ˙q, mas de p.",
                                    "Aplique em sistemas aeroespaciais, como vibração de asas.",
                                    "Diferencie casos não-conservativos onde H ≠ T + V.",
                                    "Resolva um problema completo de identificação."
                                  ],
                                  "verification": "Dado L, identifique se H = T + V e escreva sua forma.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Exercícios de dinâmica aeroespacial",
                                    "Simulador online de mecânica (PhET ou similar)"
                                  ],
                                  "tips": "Sempre verifique conservatividade: forças deriváveis de V.",
                                  "learningObjective": "Reconhecer a forma padrão de H em contextos práticos.",
                                  "commonMistakes": [
                                    "Assumir H = T + V sem verificar conservatividade",
                                    "Confundir dependências variáveis"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um pêndulo simples: L = (1/2) m l² ˙θ² - m g l (1 - cos θ). Momento p_θ = m l² ˙θ, então ˙θ = p_θ / (m l²), T = p_θ² / (2 m l²), H = T + V = p_θ² / (2 m l²) + m g l (1 - cos θ). Reconheça que H depende de θ e p_θ, sem ˙θ.",
                              "finalVerifications": [
                                "Formule H corretamente a partir de L dado.",
                                "Identifique dependências: H(q,p), não ˙q.",
                                "Distinga H = T + V para conservativos.",
                                "Aplique em exemplo aeroespacial simples.",
                                "Explique transformação Legendre verbalmente.",
                                "Resolva equações canônicas iniciais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de H (100% dos componentes corretos).",
                                "Correta distinção entre L e H (sem confusão de variáveis).",
                                "Aplicação em exemplo prático sem erros de cálculo.",
                                "Explicação clara de propriedades para conservativos.",
                                "Identificação de erros comuns evitados.",
                                "Uso adequado de terminologia técnica."
                              ],
                              "crossCurricularConnections": [
                                "Física Quântica: Hamiltoniano como operador em mecânica quântica.",
                                "Engenharia Aeroespacial: Modelagem de flutter e aeroelasticidade.",
                                "Computação: Simulações numéricas com Hamiltonianos (ex: symplectic integrators).",
                                "Matemática: Geometria simplética e variedades.",
                                "Controle de Sistemas: Otimização hamiltoniana em trajetórias."
                              ],
                              "realWorldApplication": "Na dinâmica de estruturas aeroespaciais, reconhecer H = T + V permite simular vibrações de asas de aeronaves usando equações canônicas, prevendo instabilidades como flutter e otimizando designs para segurança de voo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.2.3.1.2",
                            "name": "Calcular o Hamiltoniano a partir da Lagrangiana",
                            "description": "Derivar o Hamiltoniano através da transformação de Legendre, utilizando L(q, ḗ) para obter H(q, p) onde p = ∂L/∂ḗ.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e analisar a Lagrangiana",
                                  "subSteps": [
                                    "Escreva a Lagrangiana L(q, ḗ) = T(q, ḗ) - V(q), identificando energia cinética T e potencial V.",
                                    "Liste todas as coordenadas generalizadas q_i e suas velocidades ḗ_i explicitamente.",
                                    "Verifique dependências: L deve depender de q, ḗ e possivelmente t.",
                                    "Simplifique expressões algébricas se necessário.",
                                    "Confirme que T é homogênea quadrática em ḗ para sistemas padrão."
                                  ],
                                  "verification": "A Lagrangiana está corretamente escrita e analisada sem erros dimensionais ou conceituais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora simbólica (opcional)",
                                    "Referência do sistema físico"
                                  ],
                                  "tips": "Comece sempre com T - V para evitar confusões de sinal.",
                                  "learningObjective": "Dominar a estrutura fundamental da Lagrangiana em coordenadas generalizadas.",
                                  "commonMistakes": [
                                    "Inverter T e V",
                                    "Esquecer termos cruzados em T para sistemas multi-DOF",
                                    "Ignorar dependência temporal explícita"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os momentos conjugados",
                                  "subSteps": [
                                    "Compute p_i = ∂L / ∂ḗ_i para cada coordenada i.",
                                    "Diferencie L em relação a ḗ_i, tratando q como constantes.",
                                    "Simplifique a expressão algébrica resultante.",
                                    "Verifique dimensionalmente: p deve ter unidades de momento.",
                                    "Anote p_i como funções de q e ḗ."
                                  ],
                                  "verification": "Os momentos p_i coincidem com a definição padrão (ex: p = mḗ para partícula livre).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "SymPy ou Mathematica para verificação (opcional)"
                                  ],
                                  "tips": "Use a regra da cadeia se L for complicada; foque em termos lineares/quadráticos em ḗ.",
                                  "learningObjective": "Aplicar a transformação de Legendre para definir momentos conjugados.",
                                  "commonMistakes": [
                                    "Diferenciar errado em relação a ḗ_i",
                                    "Esquecer fator de multiplicação em T quadrático",
                                    "Confundir p_i com ḗ_i"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver para velocidades em termos de momentos",
                                  "subSteps": [
                                    "Resolva a equação p_i(q, ḗ) para ḗ_i(q, p).",
                                    "Inverta explicitamente se possível (ex: ḗ = p/m).",
                                    "Para sistemas acoplados, resolva o sistema algébrico.",
                                    "Expresse todas as ḗ_j em termos de q e p.",
                                    "Verifique invertibilidade (Jacobiano ∂²L/∂ḗ² deve ser positivo definido)."
                                  ],
                                  "verification": "ḗ_i(q, p) recupera p_i corretamente ao substituir de volta.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Solver numérico/simbolico se multi-variável"
                                  ],
                                  "tips": "Assuma T quadrático para inversão simples; use aproximações se não exata.",
                                  "learningObjective": "Executar a transformação de Legendre completa.",
                                  "commonMistakes": [
                                    "Falhar em inverter corretamente",
                                    "Introduzir dependências erradas em q",
                                    "Ignorar acoplamentos entre DOFs"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e simplificar o Hamiltoniano",
                                  "subSteps": [
                                    "Calcule H = ∑_i p_i ḗ_i(q,p) - L(q, ḗ(q,p)).",
                                    "Substitua todas as ḗ_i por suas expressões em q,p.",
                                    "Simplifique termos: geralmente H = T + V em forma canônica.",
                                    "Elimine todas as ḗ restantes.",
                                    "Confirme H(q,p) sem ḗ explícito."
                                  ],
                                  "verification": "H depende apenas de q, p (e t se aplicável); ∂H/∂p_i = ḗ_i.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Ferramenta simbólica para expansão"
                                  ],
                                  "tips": "Expanda ∑ p ḗ primeiro, pois cancela termos lineares em L.",
                                  "learningObjective": "Derivar o Hamiltoniano como função de fase.",
                                  "commonMistakes": [
                                    "Esquecer substituição completa de ḗ",
                                    "Erro de sinal em H = pḗ - L",
                                    "Não simplificar para T + V"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar propriedades do Hamiltoniano",
                                  "subSteps": [
                                    "Compute ∂H/∂p_i e confirme = ḗ_i.",
                                    "Compute ∂H/∂q_i e confirme = -ḗ_i (preparando equações canônicas).",
                                    "Verifique conservação de H se L não explícito em t.",
                                    "Compare com forma conhecida para o sistema.",
                                    "Teste com valores numéricos simples."
                                  ],
                                  "verification": "Equações canônicas iniciais são satisfeitas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Exemplo numérico"
                                  ],
                                  "tips": "Use o teorema: dH/dt = ∂L/∂t para verificação.",
                                  "learningObjective": "Validar a transformação Lagrangiano-Hamiltoniano.",
                                  "commonMistakes": [
                                    "Sinais errados nas derivadas",
                                    "Confundir Hamiltoniano com energia",
                                    "Ignorar não-conservatividade"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um oscilador harmônico 1D: L = (1/2)m ḗ² - (1/2)k x². Calcule p = ∂L/∂ḗ = m ḗ → ḗ = p/m. Então H = p*(p/m) - L = p²/(2m) + (1/2)k x².",
                              "finalVerifications": [
                                "H é expresso exclusivamente em termos de q e p.",
                                "∂H/∂p_i = ḗ_i(q,p) corretamente.",
                                "∂H/∂q_i = - ḗ_i das equações de Lagrange.",
                                "H corresponde à energia total T + V.",
                                "Transformação preserva dinâmica (equações canônicas iniciais OK).",
                                "Sem dependência residual em ḗ."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de p_i = ∂L/∂ḗ_i.",
                                "Correção e completude na inversão ḗ(q,p).",
                                "Construção exata de H sem erros de substituição.",
                                "Simplificação algébrica para forma canônica.",
                                "Verificações parciais (derivadas) corretas.",
                                "Tratamento adequado de sistemas multi-DOF."
                              ],
                              "crossCurricularConnections": [
                                "Física Quântica: Hamiltoniano quantizado para mecânica quântica.",
                                "Engenharia Aeroespacial: Modelagem de vibrações em asas flexíveis.",
                                "Matemática: Aplicações da transformada de Legendre em otimização variacional.",
                                "Computação: Implementação simbólica com SymPy para simulações dinâmicas.",
                                "Controle: Base para Hamilton-Jacobi em controle ótimo de voo."
                              ],
                              "realWorldApplication": "Em dinâmica de estruturas aeroespaciais, como análise aeroelástica de aeronaves, o Hamiltoniano facilita simulações numéricas eficientes, estabilidade de flutter e síntese de controladores para manobras de voo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.2.3.1.3",
                            "name": "Aplicar em sistemas com um grau de liberdade",
                            "description": "Construir o Hamiltoniano para um oscilador harmônico simples, verificando que H = p²/(2m) + (1/2) k q².",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o sistema e derivar o Lagrangiano",
                                  "subSteps": [
                                    "Defina o oscilador harmônico simples com um grau de liberdade: posição q, massa m, constante de mola k.",
                                    "Escreva a energia cinética T = (1/2) m \\dot{q}^2.",
                                    "Escreva a energia potencial V = (1/2) k q^2.",
                                    "Construa o Lagrangiano L = T - V = (1/2) m \\dot{q}^2 - (1/2) k q^2.",
                                    "Verifique as unidades: L deve ter unidades de energia (Joules)."
                                  ],
                                  "verification": "Confirme que L = (1/2) m \\dot{q}^2 - (1/2) k q^2 está correto e unidades consistentes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e caneta ou software como Mathematica/MATLAB para simbólico; tabela de unidades físicas.",
                                  "tips": "Sempre expresse T em termos de velocidades generalizadas \\dot{q}, não posições.",
                                  "learningObjective": "Entender a base lagrangiana como energia cinética menos potencial.",
                                  "commonMistakes": "Confundir T e V; esquecer o sinal negativo em L = T - V."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o momento conjugado p",
                                  "subSteps": [
                                    "Lembre a definição: p = ∂L / ∂\\dot{q}.",
                                    "Diferencie L em relação a \\dot{q}: ∂L/∂\\dot{q} = ∂/∂\\dot{q} [(1/2) m \\dot{q}^2] = m \\dot{q}.",
                                    "Assim, p = m \\dot{q}, e resolva para \\dot{q} = p / m.",
                                    "Verifique dimensionalmente: p deve ter unidades de momento (kg m/s).",
                                    "Anote a relação explicitamente."
                                  ],
                                  "verification": "Verifique se p = m \\dot{q} e \\dot{q} = p/m derivadas corretamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Calculadora simbólica ou papel; referências de mecânica clássica.",
                                  "tips": "Use a regra da cadeia para derivadas parciais se L for complexo.",
                                  "learningObjective": "Dominar a definição e cálculo de momentos conjugados.",
                                  "commonMistakes": "Derivar em relação a q em vez de \\dot{q}; esquecer o fator m."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o Hamiltoniano H",
                                  "subSteps": [
                                    "Lembre H = p \\dot{q} - L.",
                                    "Substitua \\dot{q} = p/m em T: T = p^2 / (2m).",
                                    "Substitua em H: H = p (p/m) - [(1/2)m (p/m)^2 - (1/2) k q^2] = p^2/m - (1/2) p^2/m + (1/2) k q^2.",
                                    "Simplifique: H = (1/2) p^2/m + (1/2) k q^2.",
                                    "Corrija para forma padrão: H = p^2/(2m) + (1/2) k q^2."
                                  ],
                                  "verification": "Expanda algebricamente e confirme H = p^2/(2m) + (1/2) k q^2.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Folha de cálculo simbólica (SymPy em Python ou similar); valores numéricos para teste (m=1, k=1).",
                                  "tips": "Substitua passo a passo para evitar erros algébricos; teste com números.",
                                  "learningObjective": "Aplicar a transformação Legendre para obter H em termos de q e p.",
                                  "commonMistakes": "Erro em simplificação algébrica (ex: p^2/m - 1/2 p^2/m = 1/2 p^2/m, não p^2/2m); confundir coeficientes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e interpretar o Hamiltoniano",
                                  "subSteps": [
                                    "Confirme que H = T + V, com T(p) e V(q), separáveis.",
                                    "Derive equações canônicas: \\dot{q} = ∂H/∂p = p/m; \\dot{p} = -∂H/∂q = -k q.",
                                    "Verifique conservação: dH/dt = 0 pois H não depende explicitamente de tempo.",
                                    "Compare com equação de movimento: m \\ddot{q} + k q = 0.",
                                    "Discuta independência de velocidades generalizadas em H."
                                  ],
                                  "verification": "Equações canônicas reproduzem dinâmica lagrangiana corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Software de simulação (ex: Python com NumPy para plotar trajetórias); gráficos de fase.",
                                  "tips": "Plote fase space (q vs p) para visualização intuitiva.",
                                  "learningObjective": "Validar H e entender sua interpretação como energia total.",
                                  "commonMistakes": "Esquecer sinal em \\dot{p} = -∂H/∂q; não verificar conservação."
                                }
                              ],
                              "practicalExample": "Modelagem de vibração de uma viga cantilever em asa de aeronave: q = deslocamento lateral na ponta, m = massa efetiva, k = rigidez equivalente; construa H para analisar modos de flutter aeroelástico.",
                              "finalVerifications": [
                                "H expresso corretamente como p²/(2m) + (1/2) k q².",
                                "Momentos conjugados calculados com derivadas parciais precisas.",
                                "Equações canônicas derivadas e verificadas contra EOM clássica.",
                                "Unidades consistentes em todos termos.",
                                "H conservado (dH/dt=0) demonstrado.",
                                "Interpretação física como energia total confirmada."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na derivação de p e H (100% correto).",
                                "Completude dos substeps com explicações claras.",
                                "Correta verificação dimensional e de conservação.",
                                "Uso apropriado de notação matemática (LaTeX ou similar).",
                                "Criatividade na interpretação contextual (aeroespacial).",
                                "Ausência de erros comuns identificados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e transformadas Legendre.",
                                "Engenharia: Modelagem de vibrações em estruturas aeroespaciais.",
                                "Física: Mecânica clássica e conservação de energia.",
                                "Computação: Simulações numéricas em Python/MATLAB para fase space."
                              ],
                              "realWorldApplication": "Em dinâmica aeroelástica, o Hamiltoniano modela oscilações de asas de aviões para prever instabilidades como flutter, essencial para certificação de aeronaves pela FAA, evitando falhas catastróficas em voo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "57.2.3.2",
                        "name": "Momentos Conjugados",
                        "description": "Os momentos conjugados p_i são definidos como p_i = ∂L/∂ḗ_i, onde L é a Lagrangiana, representando a generalização do momento linear e angular em coordenadas generalizadas.",
                        "specificSkills": [
                          {
                            "id": "57.2.3.2.1",
                            "name": "Definir momentos conjugados",
                            "description": "Explicar a definição matemática dos momentos conjugados e sua relação com as derivadas parciais da Lagrangiana em relação às velocidades generalizadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Formulação Lagrangiana Básica",
                                  "subSteps": [
                                    "Relembrar que a Lagrangiana L é definida como L = T - V, onde T é a energia cinética e V é a energia potencial.",
                                    "Identificar coordenadas generalizadas q_i e suas velocidades generalizadas ṑ_i (q_dot_i).",
                                    "Examinar como L depende explicitamente de q_i, ṑ_i e possivelmente do tempo t.",
                                    "Discutir a importância das velocidades generalizadas na captura da cinemática do sistema.",
                                    "Relacionar com contextos de mecânica do voo, como graus de liberdade de uma asa flexível."
                                  ],
                                  "verification": "Escrever a expressão geral da Lagrangiana para um sistema com duas coordenadas generalizadas e identificar dependências.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Mecânica Clássica (ex: Goldstein)",
                                    "Notas de aula sobre Lagrange",
                                    "Calculadora ou software simbólico como SymPy"
                                  ],
                                  "tips": [
                                    "Sempre expresse T em termos quadráticos de ṑ_i para sistemas conservativos.",
                                    "Verifique unidades: L deve ter unidades de energia."
                                  ],
                                  "learningObjective": "Compreender os fundamentos da Lagrangiana e o papel das velocidades generalizadas.",
                                  "commonMistakes": [
                                    "Confundir L = T - V com L = T + V.",
                                    "Esquecer que T depende de ṑ_i enquanto V tipicamente não."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Conceitualmente os Momentos Conjugados",
                                  "subSteps": [
                                    "Introduzir o conceito de momento conjugado p_i como a variável canônica dual à coordenada q_i.",
                                    "Explicar que p_i generaliza o momento linear e angular clássicos.",
                                    "Discutir o significado físico: p_i representa a 'quantidade de movimento' associada a q_i.",
                                    "Relacionar com transformações de Legendre na mecânica analítica.",
                                    "Explorar por que são chamados 'conjugados' (par q_i, p_i no espaço de fase)."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito o que é um momento conjugado e dar um exemplo clássico (ex: p = m v).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Artigo ou vídeo sobre mecânica Hamiltoniana",
                                    "Quadro branco para diagramas"
                                  ],
                                  "tips": [
                                    "Pense em p_i como 'inclinação' da dependência de L em ṑ_i.",
                                    "Visualize o espaço de fase (q, p)."
                                  ],
                                  "learningObjective": "Graspar o conceito intuitivo e físico dos momentos conjugados.",
                                  "commonMistakes": [
                                    "Confundir momentos conjugados com momentos de inércia.",
                                    "Ignorar o papel dual no formalismo Hamiltoniano."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer a Definição Matemática e Derivação",
                                  "subSteps": [
                                    "Derivar formalmente p_i = ∂L / ∂ṑ_i a partir dos princípios variacionais.",
                                    "Calcular explicitamente para um exemplo simples: partícula livre (L = (1/2)m ṑ^2).",
                                    "Mostrar que para sistemas com T quadrático em ṑ_i, p_i é linear em ṑ_i.",
                                    "Verificar propriedades: p_i é homogêneo de grau 1 em ṑ_i.",
                                    "Discutir casos com restrições ou campos não-conservativos."
                                  ],
                                  "verification": "Derivar e escrever p_i para uma Lagrangiana dada, como L = (1/2)( ṑ_1^2 + ṑ_2^2 ) - V(q_1, q_2).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software como Mathematica ou Python (SymPy)",
                                    "Folha de exercícios com Lagrangianas exemplo"
                                  ],
                                  "tips": [
                                    "Use a regra da cadeia para derivadas parciais complexas.",
                                    "Confirme que ∂L/∂ṑ_i = 0 se L não depender de ṑ_i."
                                  ],
                                  "learningObjective": "Dominar a definição matemática precisa e sua derivação.",
                                  "commonMistakes": [
                                    "Erros em derivadas parciais (confundir com totais).",
                                    "Esquecer o sinal em L = T - V ao derivar."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar a Relação e Verificar Compreensão",
                                  "subSteps": [
                                    "Explicar como p_i surge nas equações de Euler-Lagrange: d/dt (∂L/∂ṑ_i) = ∂L/∂q_i.",
                                    "Transicionar para o Hamiltoniano H = ∑ p_i ṑ_i - L.",
                                    "Aplicar em contexto aeroespacial: momentos para modos de flutter.",
                                    "Resolver ṑ_i em termos de p_i para transformações.",
                                    "Testar com um sistema acoplado simples."
                                  ],
                                  "verification": "Converter uma Lagrangiana em momentos conjugados e esboçar o Hamiltoniano correspondente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de problemas de aeroelasticidade",
                                    "Simulador online de mecânica Lagrangiana"
                                  ],
                                  "tips": [
                                    "Memorize: momentos são 'gerados' pelas velocidades via Legendre.",
                                    "Pratique inversão: ṑ_i = ∂H / ∂p_i."
                                  ],
                                  "learningObjective": "Integrar a definição com as equações dinâmicas e aplicações.",
                                  "commonMistakes": [
                                    "Não inverter corretamente para obter H.",
                                    "Aplicar fora de contexto holonômico."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma asa simplificada modelada como um oscilador com coordenada generalizada q (deslocamento angular) e ṑ. A Lagrangiana é L = (1/2) I ṑ^2 - (1/2) k q^2, onde I é o momento de inércia efetivo e k a rigidez aerodinâmica. O momento conjugado é p = ∂L / ∂ṑ = I ṑ, representando o momento angular conjugado ao ângulo q.",
                              "finalVerifications": [
                                "Escrever corretamente a definição p_i = ∂L / ∂ṑ_i.",
                                "Calcular p_i para pelo menos dois exemplos de Lagrangiana fornecidos.",
                                "Explicar a relação com equações de Euler-Lagrange.",
                                "Identificar p_i em um sistema aeroespacial simples.",
                                "Derivar o Hamiltoniano básico a partir de L e p_i."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivada parcial (sem erros algébricos).",
                                "Correta interpretação física do conjugado.",
                                "Capacidade de aplicar em sistemas com múltiplas DOFs.",
                                "Clareza na explicação da transição Lagrange-Hamilton.",
                                "Consistência com propriedades (ex: simetria, conservação)."
                              ],
                              "crossCurricularConnections": [
                                "Física Quântica: p como operador momento em mecânica quântica.",
                                "Engenharia de Controle: p_i como co-estados em otimização ótima.",
                                "Matemática Aplicada: Transformadas de Legendre em cálculo variacional.",
                                "Física Estatística: Espaço de fase em ensembles canônicos."
                              ],
                              "realWorldApplication": "Em simulações de dinâmica de aeronaves, momentos conjugados permitem formular equações de Hamilton para análise de estabilidade de voo, controle ótimo de trajetória e modelagem de aeroelasticidade em software como MATLAB/Simulink, otimizando desempenho e segurança em projetos de aviões e satélites."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.2.3.2.2",
                            "name": "Calcular momentos conjugados para sistemas estruturais",
                            "description": "Determinar os momentos conjugados para um sistema com dois graus de liberdade, como uma viga flexível modelada em aeroespacial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o modelo do sistema e coordenadas generalizadas",
                                  "subSteps": [
                                    "Descreva o sistema estrutural com dois graus de liberdade, como uma viga flexível cantilever em modelagem aeroespacial.",
                                    "Identifique e selecione as coordenadas generalizadas q₁ (ex: deslocamento vertical na ponta) e q₂ (ex: rotação na ponta).",
                                    "Expresse as posições das partículas ou elementos da viga em termos de q₁, q₂ e funções de forma assumidas.",
                                    "Calcule as velocidades generalizadas q₁̇ e q₂̇ e suas contribuições para velocidades lineares e angulares.",
                                    "Esboce um diagrama cinemático do sistema destacando os graus de liberdade."
                                  ],
                                  "verification": "Lista clara de q₁, q₂ definidas, diagrama esboçado e expressões de posição/velocidade escritas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel sulfite",
                                    "Lápis e borracha",
                                    "Livro de dinâmica estrutural ou notas de aula"
                                  ],
                                  "tips": "Prefira coordenadas que reflitam modos dominantes da estrutura para simplificar cálculos.",
                                  "learningObjective": "Selecionar e definir coordenadas generalizadas independentes adequadas para um sistema estrutural com 2 GDL.",
                                  "commonMistakes": "Confundir coordenadas cinemáticas com coordenadas modais ou escolher variáveis dependentes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a energia cinética T",
                                  "subSteps": [
                                    "Expresse as velocidades de pontos discretos ou integrais da viga usando q₁̇ e q₂̇.",
                                    "Calcule a energia cinética translacional: ∫ (1/2) ρ |v|² dx, onde v depende de q̇.",
                                    "Adicione a energia cinética rotacional: ∫ (1/2) ρ I ω² dx, com ω de q₂̇.",
                                    "Integre ao longo do comprimento da viga para obter T(q̇) = (1/2) [m₁₁ q₁̇² + 2 m₁₂ q₁̇ q₂̇ + m₂₂ q₂̇²].",
                                    "Verifique simetria e positividade da matriz de massa."
                                  ],
                                  "verification": "Expressão completa de T com matriz de massa 2x2 simétrica e termos quadráticos corretos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico como SymPy",
                                    "Tabelas de funções de forma para vigas",
                                    "Papel para integrais"
                                  ],
                                  "tips": "Use funções de forma modais (ex: primeira e segunda flexão) para aproximar.",
                                  "learningObjective": "Formular a energia cinética quadrática em velocidades generalizadas para sistemas discretizados.",
                                  "commonMistakes": "Esquecer termos cruzados m₁₂ ou erros em integrais de velocidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a energia potencial V e formar o Lagrangiano L",
                                  "subSteps": [
                                    "Expresse deformações ou deslocamentos em termos de q₁ e q₂ usando funções de forma.",
                                    "Calcule V = (1/2) ∫ EI (w'')² dx para flexão, onde w(x) = φ₁(x) q₁ + φ₂(x) q₂.",
                                    "Obtenha matriz de rigidez K: V = (1/2) [k₁₁ q₁² + 2 k₁₂ q₁ q₂ + k₂₂ q₂²].",
                                    "Forme o Lagrangiano L = T(q, q̇) - V(q).",
                                    "Simplifique expressões algébricas e verifique dependências (T em q̇, V em q)."
                                  ],
                                  "verification": "Lagrangiano L escrito explicitamente com T e V corretos e independentes.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Tabelas de rigidez para vigas",
                                    "Software para integrais simbólicas",
                                    "Notas sobre funções de forma"
                                  ],
                                  "tips": "Para vigas Euler-Bernoulli, use φ₁(x) = (x/L)², φ₂(x) = (x/L)³ aproximados.",
                                  "learningObjective": "Construir o Lagrangiano completo para um sistema estrutural conservativo.",
                                  "commonMistakes": "Incluir dependência errada de q em T ou vice-versa, ou erros em matriz K."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular os momentos conjugados",
                                  "subSteps": [
                                    "Compute p₁ = ∂L / ∂q₁̇, diferenciando apenas termos de T em q₁̇.",
                                    "Compute p₂ = ∂L / ∂q₂̇, similarmente para q₂̇.",
                                    "Expresse p₁ e p₂ como p = M q̇, onde M é a matriz de massa de T.",
                                    "Verifique invertibilidade de M para obter velocidades de momentos.",
                                    "Discuta interpretação física: p como momentos generalizados de inércia."
                                  ],
                                  "verification": "Expressões explícitas de p₁(q̇) e p₂(q̇), com ∂L/∂q̇ corretas e matriz M.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para derivadas parciais",
                                    "Calculadora"
                                  ],
                                  "tips": "L não depende de q̇ em V, então ∂L/∂q̇ = ∂T/∂q̇ sempre.",
                                  "learningObjective": "Determinar momentos conjugados via derivadas parciais do Lagrangiano.",
                                  "commonMistakes": "Diferenciar termos errados ou esquecer que V não contribui para p."
                                }
                              ],
                              "practicalExample": "Considere uma viga cantilever de comprimento L=1m, módulo E=70GPa, inércia I=1e-6 m⁴, densidade ρ=2700 kg/m³, seção A=1e-4 m². Use q₁=w(L) (desloc. ponta), q₂=θ(L) (rotação ponta), funções φ₁(x)=(x/L)²(3-2(x/L)), φ₂(x)=(x/L)³(x/L-1). Calcule T≈(1/2)(0.24 ρ A L q₁̇² + ...), V=(1/2)(12 EI/L³ q₁² + ...), então p₁=∂L/∂q₁̇ ≈ 0.24 ρ A L q₁̇ + termos cruzados.",
                              "finalVerifications": [
                                "Momento p₁ = ∂L/∂q₁̇ resulta em combinação linear correta de q̇₁ e q̇₂.",
                                "Momento p₂ = ∂L/∂q₂̇ simétrico e consistente com matriz de massa.",
                                "Matriz de massa M positiva definida (autovalores >0).",
                                "Unidades de p: kg m²/s ou equivalentes estruturais.",
                                "Inversão possível: q̇ = M⁻¹ p.",
                                "Comparação numérica com valores esperados para o exemplo."
                              ],
                              "assessmentCriteria": [
                                "Correção conceitual na definição de coordenadas e energias.",
                                "Precisão matemática nas derivadas parciais e integrais.",
                                "Completude das expressões (todos termos incluídos).",
                                "Clareza na apresentação de equações e diagramas.",
                                "Capacidade de simplificar e interpretar resultados físicos.",
                                "Tratamento adequado de acoplamentos cruzados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo multivariável e derivadas parciais.",
                                "Física: Mecânica lagrangiana e hamiltoniana clássica.",
                                "Engenharia Mecânica: Análise modal e dinâmica de estruturas.",
                                "Computação: Implementação em MATLAB/SymPy para simulações.",
                                "Aeroespacial: Modelagem de aeroelasticidade e flutter."
                              ],
                              "realWorldApplication": "Na análise de estruturas aeroespaciais, como asas de aviões flexíveis, os momentos conjugados permitem formular equações de Hamilton para simular respostas dinâmicas, prever flutter e otimizar designs contra vibrações, essencial em projetos da NASA/Embraer."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.2.3.2.3",
                            "name": "Interpretar propriedades dos momentos conjugados",
                            "description": "Analisar como os momentos conjugados preservam simetrias e são canônicos na formulação hamiltoniana para dinâmica de estruturas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definição e Derivação de Momentos Conjugados",
                                  "subSteps": [
                                    "Defina coordenadas generalizadas q e derive o momento conjugado p = ∂L/∂q̇ a partir da Lagrangiana L.",
                                    "Explique a transformação de Legendre da Lagrangiana para o Hamiltoniano H(q, p).",
                                    "Identifique pares canônicos (q, p) em um sistema simples como oscilador harmônico.",
                                    "Discuta a relação entre momentos conjugados e velocidades generalizadas.",
                                    "Calcule explicitamente p para um sistema com múltiplas graus de liberdade."
                                  ],
                                  "verification": "Derive corretamente p para um exemplo dado e transforme L em H sem erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Mecânica Clássica (Goldstein), caderno de anotações, calculadora simbólica (SymPy).",
                                  "tips": "Sempre verifique unidades: p deve ter unidades de momento angular ou generalizado.",
                                  "learningObjective": "Compreender a origem matemática dos momentos conjugados na transição Lagrangiana-Hamiltoniana.",
                                  "commonMistakes": "Confundir p com momento linear; esquecer dependência explícita de q̇ em L."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Preservação de Simetrias pelos Momentos Conjugados",
                                  "subSteps": [
                                    "Revise o Teorema de Noether: simetrias contínuas geram quantidades conservadas.",
                                    "Mostre como transformações canônicas preservam a forma do Hamiltoniano.",
                                    "Identifique simetrias cíclicas onde ∂L/∂q = 0 implica dp/dt = 0.",
                                    "Aplique a um sistema rotacional: momento angular como p conjugado conservado.",
                                    "Discuta grupos de Lie e geradores de simetrias em coordenadas canônicas."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como uma rotação preserva H via momentos conjugados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Notas de simetrias em mecânica, software de simulação (MATLAB), exemplos de estruturas rotativas.",
                                  "tips": "Use diagramas de Poisson brackets para visualizar conservação.",
                                  "learningObjective": "Reconhecer como momentos conjugados capturam simetrias inerentes do sistema físico.",
                                  "commonMistakes": "Ignorar simetrias dependentes de tempo; confundir simetria com invariância total."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Propriedades Canônicas na Formulação Hamiltoniana",
                                  "subSteps": [
                                    "Defina equações canônicas: dq/dt = ∂H/∂p, dp/dt = -∂H/∂q.",
                                    "Demonstre que transformações canônicas mantêm a forma das equações.",
                                    "Calcule brackets de Poisson {q, p} = 1 para verificar canonicidade.",
                                    "Analise estabilidade: momentos conjugados em integradores simétricos.",
                                    "Compare com formulação Lagrangiana em termos de simetria e numericidade."
                                  ],
                                  "verification": "Resolva numericamente um sistema hamiltoniano e verifique conservação de H.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Software numérico (Python com SciPy), exemplos de H para estruturas.",
                                  "tips": "Teste pequenas perturbações para checar sensibilidade canônica.",
                                  "learningObjective": "Dominar como momentos conjugados garantem estrutura canônica para dinâmica precisa.",
                                  "commonMistakes": "Usar derivadas erradas nos brackets de Poisson; violar canonicidade em aproximações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Interpretação em Dinâmica de Estruturas Aeroespaciais",
                                  "subSteps": [
                                    "Modele uma viga flexível com graus de liberdade q (deslocamentos) e p (momentos inerciais).",
                                    "Identifique simetrias translacionais/rotacionais em painéis aeroelásticos.",
                                    "Analise como p preserva energia em flutter.",
                                    "Simule numericamente e interprete evolução de p em instabilidades.",
                                    "Discuta implicações para controle ativo de vibrações."
                                  ],
                                  "verification": "Produza gráfico de q(t) e p(t) mostrando conservação de simetrias.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Modelo FEM simples (ANSYS ou código customizado), dados de asas de aeronaves.",
                                  "tips": "Comece com sistema 1DOF para validar antes de multi-DOF.",
                                  "learningObjective": "Interpretar propriedades de momentos conjugados em contextos reais de aeroelasticidade.",
                                  "commonMistakes": "Negligenciar acoplamentos não-lineares em estruturas; superestimar simetrias ideais."
                                }
                              ],
                              "practicalExample": "Em uma asa de aeronave modelada como viga Euler-Bernoulli, o momento conjugado p_θ (para rotação θ) preserva o momento angular durante oscilações, permitindo simulações estáveis de flutter onde H permanece constante, evitando divergências numéricas.",
                              "finalVerifications": [
                                "Derivação correta de p a partir de L para um sistema aeroelástico.",
                                "Identificação precisa de 3 simetrias conservadas via teorema de Noether.",
                                "Cálculo de brackets de Poisson confirmando canonicidade.",
                                "Simulação numérica com H conservado dentro de 1% de erro.",
                                "Explicação escrita ligando propriedades a estabilidade estrutural.",
                                "Análise de um caso real de painel oscilante."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação matemática (90% correto).",
                                "Profundidade na explicação de simetrias (cobertura de Noether e Lie).",
                                "Correção em equações canônicas e brackets.",
                                "Qualidade da simulação e interpretação gráfica.",
                                "Relevância ao contexto aeroespacial (exemplos concretos).",
                                "Clareza na discussão de erros comuns e tips."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Grupos de Lie e álgebra de Lie para simetrias avançadas.",
                                "Física Quântica: Momentos conjugados como operadores [q, p] = iℏ.",
                                "Engenharia de Controle: Uso em observadores de estado para sistemas hamiltonianos.",
                                "Computação Científica: Integradores geométricos simétricos (ex: Verlet).",
                                "Aerodinâmica: Acoplamento fluido-estrutura via momentos generalizados."
                              ],
                              "realWorldApplication": "Na certificação de aeronaves, engenheiros usam momentos conjugados para simular aeroelasticidade precisa, prevendo flutter crítico em asas (ex: Boeing 787), garantindo segurança via conservação de simetrias em modelos de alta fidelidade."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "57.2.3.3",
                        "name": "Equações Canônicas de Hamilton",
                        "description": "As equações canônicas são ḗ_i = ∂H/∂p_i e ṉp_i = -∂H/∂q_i, derivadas do Princípio Variacional, fornecendo um sistema de equações de primeira ordem para a dinâmica.",
                        "specificSkills": [
                          {
                            "id": "57.2.3.3.1",
                            "name": "Derivar as equações canônicas",
                            "description": "Demonstrar a derivação das equações de Hamilton a partir da Lagrangiana via transformação de Legendre e princípio variacional.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Lagrangiano e as Equações de Lagrange",
                                  "subSteps": [
                                    "Defina o Lagrangiano L(q, q̇, t) = T(q, q̇, t) - V(q, t), onde T é energia cinética e V é potencial.",
                                    "Escreva as equações de Lagrange: d/dt (∂L/∂q̇_i) - ∂L/∂q_i = 0 para cada coordenada generalizada q_i.",
                                    "Discuta o princípio variacional subjacente: ação S = ∫ L dt é estacionária.",
                                    "Identifique dependências em velocidades q̇ e posições q.",
                                    "Pratique com um exemplo simples como pêndulo para solidificar conceitos."
                                  ],
                                  "verification": "Escreva corretamente as equações de Lagrange para um sistema de 2 graus de liberdade e explique o princípio variacional em suas palavras.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Mecânica Clássica (Goldstein), caderno, calculadora simbólica (SymPy ou Mathematica).",
                                  "tips": "Sempre expresse L explicitamente em termos de q e q̇ antes de derivar.",
                                  "learningObjective": "Compreender a base lagrangiana para transição ao formalismo hamiltoniano.",
                                  "commonMistakes": "Confundir T e V; esquecer dependência temporal em L."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Momentos Conjugados via Transformação de Legendre",
                                  "subSteps": [
                                    "Defina o momento conjugado p_i = ∂L/∂q̇_i para cada i.",
                                    "Explique a transformação de Legendre: ela converte o Lagrangiano (convexo em q̇) em Hamiltoniano (convexo em p).",
                                    "Verifique invertibilidade: q̇_i = q̇_i(p, q, t) resolvendo ∂²L/∂q̇_i² > 0.",
                                    "Calcule explicitamente p para um sistema exemplo (ex: partícula livre).",
                                    "Discuta condições para transformação válida (não singular)."
                                  ],
                                  "verification": "Derive p_i de L para um oscilador harmônico e encontre q̇ em termos de p.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel e lápis, software de álgebra computacional, notas de aula sobre convexidade.",
                                  "tips": "Use a regra da cadeia para derivadas parciais ao inverter.",
                                  "learningObjective": "Dominar a definição e propriedades dos momentos conjugados.",
                                  "commonMistakes": "Assumir invertibilidade sem verificar Hessian; erros em derivadas parciais mistas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o Hamiltoniano",
                                  "subSteps": [
                                    "Escreva H(q, p, t) = ∑ p_i q̇_i(p, q, t) - L(q, q̇(p, q, t), t).",
                                    "Mostre que H = T + V na maioria dos casos (se T quadrático em q̇).",
                                    "Verifique conservação: dH/dt = ∂H/∂t se L não explícito em t.",
                                    "Calcule H para exemplo concreto (oscilador: H = p²/2m + (1/2)kx²).",
                                    "Compare com L para validar."
                                  ],
                                  "verification": "Construa H a partir de L dado e confirme H = T + V.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Exemplos resolvidos de Goldstein ou Landau, SymPy para simplificação.",
                                  "tips": "Expanda ∑ p q̇ antes de substituir para evitar erros algébricos.",
                                  "learningObjective": "Construir corretamente o Hamiltoniano a partir de L.",
                                  "commonMistakes": "Erro no sinal: lembrar H = p q̇ - L; esquecer substituição completa de q̇."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar as Equações Canônicas de Hamilton",
                                  "subSteps": [
                                    "Mostre q̇_i = ∂H/∂p_i pela definição de H (derivada total).",
                                    "Derive ṗ_i = -∂H/∂q_i usando equações de Lagrange e cadeia.",
                                    "Escreva o par canônico: dq_i/dt = ∂H/∂p_i, dp_i/dt = -∂H/∂q_i.",
                                    "Verifique com exemplo: para oscilador, q̇ = p/m, ṗ = -kx.",
                                    "Discuta simetria e estrutura em fase (q, p)."
                                  ],
                                  "verification": "Derive as 4 equações canônicas para sistema de 2 DOF e resolva numericamente para validação.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Caderno, software numérico (Python/MATLAB para simulação), referências teóricas.",
                                  "tips": "Use identidades diferenciais para provar ṗ sem cálculo direto.",
                                  "learningObjective": "Derivar e interpretar as equações canônicas completas.",
                                  "commonMistakes": "Sinal errado em ṗ; confundir parciais de H com L."
                                }
                              ],
                              "practicalExample": "Para um oscilador harmônico simples: L = (1/2)m q̇² - (1/2)k q². Derive p = m q̇, H = p²/(2m) + (1/2)k q², então q̇ = p/m, ṗ = -k q. Simule trajetórias em fase para visualizar órbitas elípticas.",
                              "finalVerifications": [
                                "Derivação de H a partir de L arbitrário sem erros algébricos.",
                                "Equações canônicas produzidas coincidem com Lagrange para exemplo testado.",
                                "Explicação verbal correta da transformação de Legendre.",
                                "Identificação de condições de validade (ex: não dissipativo).",
                                "Simulação numérica confirma conservação de H.",
                                "Resolução de sistema canônico para caso simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (100% correto).",
                                "Clareza na explicação conceitual (princípio variacional ligado).",
                                "Uso correto de notação (parciais, índices).",
                                "Validação com exemplo prático e verificação numérica.",
                                "Identificação de erros comuns e prevenções.",
                                "Profundidade em conexões (fase space, simetrias)."
                              ],
                              "crossCurricularConnections": [
                                "Física Quântica: Mecânica Hamiltoniana base para quantização canônica.",
                                "Engenharia de Controle: Estados (q,p) em modelagem de sistemas dinâmicos.",
                                "Matemática: Equações diferenciais parciais e geometria sinplética.",
                                "Computação: Algoritmos numéricos para integração Hamiltoniana (ex: symplectic integrators)."
                              ],
                              "realWorldApplication": "Em aeroespacial, usado para modelar dinâmica de satélites ou flaps de aeronaves, permitindo simulações eficientes em espaço de fase para estabilidade aeroelástica e otimização de trajetórias orbitais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.2.3.3.2",
                            "name": "Escrever equações para sistemas simples",
                            "description": "Formular e resolver numericamente as equações canônicas para um sistema com um grau de liberdade sob excitação harmônica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o sistema físico e coordenadas generalizadas",
                                  "subSteps": [
                                    "Selecione um sistema simples com um grau de liberdade (GDL), como um oscilador harmônico massa-mola.",
                                    "Identifique a coordenada generalizada q (ex: posição x da massa).",
                                    "Defina o momento conjugado p como p = ∂L/∂\\dot{q}, onde L é o Lagrangiano.",
                                    "Especifique parâmetros: massa m, constante da mola k e excitação F(t) = F₀ cos(ωt).",
                                    "Desenhe um diagrama esquemático do sistema."
                                  ],
                                  "verification": "Verifique se q representa o GDL corretamente e p é o momento linear m \u001d{q}.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de mecânica clássica",
                                    "Calculadora"
                                  ],
                                  "tips": "Use sempre o exemplo clássico massa-mola para iniciantes.",
                                  "learningObjective": "Compreender a escolha de coordenadas generalizadas e momentos conjugados para sistemas com 1 GDL.",
                                  "commonMistakes": "Confundir momento conjugado com momento angular ou velocidade diretamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular o Hamiltoniano H",
                                  "subSteps": [
                                    "Expresse a energia cinética T = p² / (2m).",
                                    "Expresse a energia potencial V = (1/2) k q².",
                                    "Construa o Hamiltoniano H(q, p, t) = T + V.",
                                    "Confirme que H não depende explicitamente de \u001d{q} (forma padrão).",
                                    "Anote os parâmetros numéricos para o exemplo prático."
                                  ],
                                  "verification": "Substitua valores e verifique se H tem unidades de energia (Joules).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software simbólico como SymPy (opcional)"
                                  ],
                                  "tips": "Lembre-se: transformação de Legendre para passar de velocidades para momentos.",
                                  "learningObjective": "Dominar a construção do Hamiltoniano a partir de T e V em coordenadas canônicas.",
                                  "commonMistakes": "Esquecer de expressar T em termos de p ou incluir termos desnecessários."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar as equações canônicas",
                                  "subSteps": [
                                    "Escreva \u001dq/dt = ∂H/∂p.",
                                    "Escreva \u001dp/dt = -∂H/∂q.",
                                    "Simplifique para o oscilador: \u001dq/dt = p/m, \u001dp/dt = -k q.",
                                    "Inclua a força externa generalizada Q = F₀ cos(ωt) na equação de p: \u001dp/dt = -∂H/∂q + Q.",
                                    "Verifique dimensionalmente as equações resultantes."
                                  ],
                                  "verification": "As equações devem reproduzir a equação de Newton equivalente: m \u001d²q/dt² + k q = F₀ cos(ωt).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de derivadas parciais"
                                  ],
                                  "tips": "Use a regra: forças não-conservativas entram como Q_j na equação de \u001dp_j/dt.",
                                  "learningObjective": "Aplicar corretamente as equações canônicas de Hamilton para sistemas forçados.",
                                  "commonMistakes": "Esquecer o sinal negativo em \u001dp/dt ou não incluir Q corretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver numericamente as equações",
                                  "subSteps": [
                                    "Escolha um método numérico (ex: Runge-Kutta de ordem 4).",
                                    "Implemente em software (Python com scipy.integrate.odeint ou MATLAB).",
                                    "Defina condições iniciais: q(0)=0, p(0)=0.",
                                    "Integre no tempo de 0 a 50s com passo dt=0.01s.",
                                    "Plote q(t) e compare com solução analítica conhecida (steady-state)."
                                  ],
                                  "verification": "A solução numérica deve mostrar ressonância se ω ≈ √(k/m) e convergir para particular.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Python/MATLAB",
                                    "Biblioteca scipy ou ode45",
                                    "Computador"
                                  ],
                                  "tips": "Use dt pequeno para precisão; valide com caso sem força (F₀=0).",
                                  "learningObjective": "Implementar e validar soluções numéricas de sistemas hamiltonianos forçados.",
                                  "commonMistakes": "Condições iniciais erradas ou dt muito grande causando instabilidade."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e validar a solução",
                                  "subSteps": [
                                    "Calcule energia total H ao longo do tempo e verifique conservação (exceto pelo forçamento).",
                                    "Identifique amplitude estacionária e fase.",
                                    "Compare com solução analítica: q_p(t) = [F₀ / m (ω₀² - ω²)] cos(ωt).",
                                    "Discuta efeitos de ω próximo a ω₀ (ressonância).",
                                    "Gere relatório com gráficos e conclusões."
                                  ],
                                  "verification": "Erro numérico < 1% em relação à analítica no regime estacionário.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software de plotagem (Matplotlib)"
                                  ],
                                  "tips": "Ignore transientes iniciais para comparar steady-state.",
                                  "learningObjective": "Interpretar resultados numéricos em contexto físico-aeroespacial.",
                                  "commonMistakes": "Confundir solução transitória com estacionária."
                                }
                              ],
                              "practicalExample": "Para uma massa m=1 kg, k=100 N/m (ω₀=10 rad/s), F₀=10 N, ω=9 rad/s: H = p²/2 + 50 q². Equações: \u001dq/dt = p, \u001dp/dt = -100 q + 10 cos(9t). Resolva numericamente e plote q(t), mostrando batimento antes do steady-state.",
                              "finalVerifications": [
                                "Hamiltoniano H corretamente formulado em termos de q e p.",
                                "Equações canônicas derivadas com inclusão precisa da força Q.",
                                "Solução numérica implementada sem erros de sintaxe ou divergência.",
                                "Gráficos mostram comportamento físico esperado (ressonância aproximada).",
                                "Validação contra equação de Newton ou solução analítica.",
                                "Energia H oscila coerentemente com o forçamento."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática na derivação de ∂H/∂p e ∂H/∂q (100%).",
                                "Implementação numérica precisa e eficiente (erro <0.5%).",
                                "Interpretação física dos resultados (ressonância, fase).",
                                "Clareza na documentação e gráficos.",
                                "Tratamento correto de forças não-conservativas.",
                                "Uso adequado de unidades e parâmetros realistas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Solução numérica de EDOs não-lineares e lineares.",
                                "Programação: Integração numérica com Python/Scipy ou MATLAB.",
                                "Física: Mecânica lagrangiana/hamiltoniana e vibrações forçadas.",
                                "Engenharia de Controle: Análise de sistemas dinâmicos lineares.",
                                "Ciência de Computação: Validação de simulações."
                              ],
                              "realWorldApplication": "Em aeroelasticidade, modela vibrações de asas ou fuselagens sob cargas harmônicas de turbulência ou motores, prevendo flutter e fadiga estrutural em aeronaves."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.2.3.3.3",
                            "name": "Aplicar em contextos aeroespaciais",
                            "description": "Utilizar equações canônicas para modelar a dinâmica de uma estrutura aeroespacial com amortecimento de Rayleigh em termos hamiltonianos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos das Equações Canônicas de Hamilton",
                                  "subSteps": [
                                    "Relembrar a definição do Hamiltoniano H = T + V, onde T é energia cinética e V é potencial.",
                                    "Derivar as equações canônicas: dq/dt = ∂H/∂p e dp/dt = -∂H/∂q para um sistema conservativo.",
                                    "Estender para sistemas com múltiplas graus de liberdade, como estruturas aeroespaciais.",
                                    "Identificar coordenadas generalizadas q e momentos conjugados p adequados para uma estrutura (ex: deslocamentos e velocidades).",
                                    "Verificar linearidade das equações para pequenos deslocamentos em aeroelasticidade."
                                  ],
                                  "verification": "Derivar corretamente as equações canônicas para um oscilador harmônico simples e comparar com soluções conhecidas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Goldstein 'Classical Mechanics'",
                                    "Software MATLAB ou Python (SymPy)",
                                    "Notas de aula sobre Hamiltonianos"
                                  ],
                                  "tips": [
                                    "Comece com sistemas de 1 DOF antes de múltiplos.",
                                    "Use diagramas de fase para visualizar o comportamento."
                                  ],
                                  "learningObjective": "Compreender a estrutura das equações canônicas e sua aplicabilidade a sistemas dinâmicos.",
                                  "commonMistakes": [
                                    "Confundir momentos p com velocidades diretamente.",
                                    "Esquecer o sinal negativo em dp/dt."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Incorporar Amortecimento de Rayleigh no Formalismo Hamiltoniano",
                                  "subSteps": [
                                    "Definir o modelo de amortecimento de Rayleigh: forças dissipativas proporcionais a velocidades, F_d = -c · ᵓq.",
                                    "Transformar o amortecimento não-hamiltoniano em termos de derivadas de um 'pseudo-potencial' dissipativo.",
                                    "Modificar as equações canônicas: adicionar termos de Rayleigh como dp/dt = -∂H/∂q - ∂R/∂ᵓq, onde R é a função de Rayleigh.",
                                    "Linearizar para estruturas aeroespaciais: R = (1/2) · C · ᵓq^T · ᵓq.",
                                    "Verificar conservação de energia modificada e estabilidade do sistema."
                                  ],
                                  "verification": "Escrever as equações modificadas para um sistema massa-mola-amortecedor e resolver numericamente para decaimento exponencial.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Artigo 'Rayleigh Dissipation Function'",
                                    "MATLAB para simulação numérica",
                                    "Folha de papel para derivações"
                                  ],
                                  "tips": [
                                    "Lembre-se que Rayleigh não é holonômico; use aproximações lineares para aeroespaciais.",
                                    "Plote envelopes de decaimento para validar."
                                  ],
                                  "learningObjective": "Integrar dissipação de Rayleigh nas equações canônicas sem violar estrutura hamiltoniana.",
                                  "commonMistakes": [
                                    "Tratar Rayleigh como potencial conservativo.",
                                    "Ignorar a matriz de amortecimento diagonal."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelar uma Estrutura Aeroespacial Específica",
                                  "subSteps": [
                                    "Escolher uma estrutura: viga Euler-Bernoulli representando uma asa de aeronave com 2 modos de flexão.",
                                    "Definir energia cinética T incluindo massas distribuídas e momentos de inércia.",
                                    "Definir energia potencial V com rigidez flexural e tensões aerodinâmicas aproximadas.",
                                    "Adicionar amortecimento de Rayleigh com coeficientes estruturais e aerodinâmicos.",
                                    "Escrever o Hamiltoniano completo H e derivar as equações canônicas acopladas."
                                  ],
                                  "verification": "Obter matrizes de massa M, rigidez K e amortecimento C no formato padrão ᵀᵓ + Cᵓ + Kq = 0.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software ANSYS ou NASTRAN para validação",
                                    "Referência 'Aeroelasticity' de Bisplinghoff",
                                    "Computador com Python/Octave"
                                  ],
                                  "tips": [
                                    "Use modos modais para reduzir DOFs.",
                                    "Inclua acoplamento pistão-torsão para realismo aeroespacial."
                                  ],
                                  "learningObjective": "Construir um modelo hamiltoniano realista para dinâmica estrutural aeroespacial.",
                                  "commonMistakes": [
                                    "Negligir termos de Coriolis em rotações.",
                                    "Escolha incorreta de coordenadas generalizadas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular, Analisar e Validar o Modelo",
                                  "subSteps": [
                                    "Implementar numericamente as equações canônicas usando método de Runge-Kutta ou modal.",
                                    "Analisar autovalores para frequências naturais, fator de amortecimento e estabilidade.",
                                    "Comparar com dados experimentais ou FEM de flutter em asas.",
                                    "Sensibilizar parâmetros (ex: variação de velocidade de voo) e observar bifurcações.",
                                    "Documentar o modelo em relatório com gráficos de resposta temporal e frequência."
                                  ],
                                  "verification": "Simulação mostra decaimento estável sem oscilações divergentes para condições subcríticas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB Aerospace Toolbox",
                                    "Python SciPy para integração ODE",
                                    "Dados de benchmark de NASA flutter tests"
                                  ],
                                  "tips": [
                                    "Use eigenvalues para prever flutter speed.",
                                    "Valide com casos analíticos conhecidos."
                                  ],
                                  "learningObjective": "Aplicar o modelo para previsão de comportamento dinâmico e validação.",
                                  "commonMistakes": [
                                    "Passo de tempo inadequado causando instabilidade numérica.",
                                    "Interpretação errada de autovalores complexos."
                                  ]
                                }
                              ],
                              "practicalExample": "Modelar a dinâmica de uma seção de asa flexível de um jato comercial sujeita a cargas aerodinâmicas, usando equações canônicas para prever o onset de flutter com amortecimento estrutural de Rayleigh, simulando respostas a gusts turbulentos.",
                              "finalVerifications": [
                                "Equações canônicas derivadas coincidem com forma matricial padrão Mᵓ + Cᵓ + Kq = 0.",
                                "Simulações numéricas mostram decaimento exponencial em regime amortecido.",
                                "Autovalores reais negativos para modos estáveis; complexos com parte imaginária para oscilações.",
                                "Predição de velocidade de flutter dentro de 10% de dados experimentais.",
                                "Energia total decresce monotonicamente devido a Rayleigh.",
                                "Resposta a excitação inicial converge para equilíbrio."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação do Hamiltoniano e equações canônicas (90% correto).",
                                "Correta incorporação e linearização do amortecimento de Rayleigh.",
                                "Validade física do modelo para contexto aeroespacial (ex: inclusão de aerodinâmica).",
                                "Qualidade da simulação numérica e análise de resultados.",
                                "Clareza na documentação e interpretação de resultados.",
                                "Criatividade na extensão para cenários reais como controle ativo."
                              ],
                              "crossCurricularConnections": [
                                "Física Clássica: Formalismo lagrangiano-hamiltoniano.",
                                "Engenharia Aeroespacial: Aeroelasticidade e controle de flutter.",
                                "Computação Científica: Integração numérica de EDOs e análise modal.",
                                "Matemática Aplicada: Autovalores e estabilidade de sistemas lineares."
                              ],
                              "realWorldApplication": "Previsão e prevenção de flutter em asas de aeronaves comerciais e foguetes, como no Boeing 787 ou SLS da NASA, otimizando design para segurança e eficiência, evitando falhas catastróficas como o caso do Tacoma Narrows em pontes (análoga aeroespacial)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.2.3.3.4",
                            "name": "Verificar conservação de energia",
                            "description": "Mostrar que dH/dt = 0 para sistemas conservativos usando as equações canônicas, aplicando a vibrações estruturais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Hamiltoniano e as Equações Canônicas",
                                  "subSteps": [
                                    "Defina o Hamiltoniano H como H(q, p, t) = T + V, onde T é energia cinética e V é potencial.",
                                    "Escreva as equações canônicas: dq/dt = ∂H/∂p e dp/dt = -∂H/∂q.",
                                    "Identifique dependências explícitas em t nos termos de H.",
                                    "Discuta sistemas conservativos: forças derivadas de potencial V(q), sem dissipação.",
                                    "Verifique a forma padrão para vibrações estruturais, como coordenadas generalizadas q para deslocamentos."
                                  ],
                                  "verification": "Escreva corretamente as equações canônicas e defina H para um sistema simples como massa-mola.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Mecânica Hamiltoniana (ex: Goldstein), caderno de anotações, calculadora simbólica (SymPy ou Mathematica).",
                                  "tips": "Use coordenadas generalizadas para generalizar além de Cartesianas.",
                                  "learningObjective": "Compreender a estrutura das equações canônicas e o papel do Hamiltoniano.",
                                  "commonMistakes": "Confundir dq/dt com ∂H/∂p em vez de usar p para momento conjugado."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Derivada Temporal Total dH/dt",
                                  "subSteps": [
                                    "Calcule dH/dt usando a regra da cadeia: dH/dt = (∂H/∂q)(dq/dt) + (∂H/∂p)(dp/dt) + ∂H/∂t.",
                                    "Substitua dq/dt = ∂H/∂p e dp/dt = -∂H/∂q nas equações canônicas.",
                                    "Simplifique: os termos (∂H/∂q)(∂H/∂p) - (∂H/∂p)(∂H/∂q) cancelam-se (Poisson bracket zero).",
                                    "Conclua que dH/dt = ∂H/∂t.",
                                    "Verifique algebricamente para um exemplo unidimensional."
                                  ],
                                  "verification": "Mostre que os termos de Poisson se cancelam, deixando dH/dt = ∂H/∂t.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel quadriculado, software de álgebra simbólica, notas da aula anterior.",
                                  "tips": "Lembre-se: o bracket de Poisson {H,H}=0 garante o cancelamento.",
                                  "learningObjective": "Derivar matematicamente que dH/dt reduz a ∂H/∂t ao longo das trajetórias.",
                                  "commonMistakes": "Esquecer o termo ∂H/∂t explícito ou inverter os sinais nas equações canônicas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer Condições para Conservação de Energia",
                                  "subSteps": [
                                    "Analise sistemas conservativos: H = T(q,p) + V(q), sem dependência explícita em t (∂H/∂t = 0).",
                                    "Confirme que para potenciais dependentes apenas de q, dp/dt = -∂V/∂q (força conservativa).",
                                    "Discuta ausência de forças não-conservativas ou dissipativas.",
                                    "Verifique que dH/dt = 0 implica conservação de H como energia total.",
                                    "Considere generalizações para múltiplas graus de liberdade."
                                  ],
                                  "verification": "Demonstre ∂H/∂t = 0 para H sem t explícito e conclua dH/dt = 0.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Exemplos de problemas de vibração (ex: equações de Euler-Bernoulli), quadro branco.",
                                  "tips": "Sistemas autônomos (sem t em H) são chave para conservação.",
                                  "learningObjective": "Identificar condições onde H é conservado como energia.",
                                  "commonMistakes": "Assumir conservação sem verificar dependência em t ou forças dissipativas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar à Modelagem de Vibrações Estruturais",
                                  "subSteps": [
                                    "Modele uma viga em vibração como sistema discreto com coordenadas q (modos normais).",
                                    "Formule H = Σ (p_i²/(2m_i) + (1/2) k_i q_i²) para osciladores desacoplados.",
                                    "Verifique ∂H/∂t = 0 (sem excitação temporal).",
                                    "Simule numericamente trajetórias e plote H(t) para confirmar constante.",
                                    "Discuta implicações em aeroelasticidade: estabilidade sem dissipação."
                                  ],
                                  "verification": "Compute dH/dt para o modelo e mostre =0; plote H constante em simulação.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software MATLAB/Python (SciPy para integração), dados de viga cantilever.",
                                  "tips": "Use modos normais para simplificar H em forma diagonal.",
                                  "learningObjective": "Aplicar conservação de H em contextos de engenharia aeroespacial.",
                                  "commonMistakes": "Incluir amortecimento artificial, violando conservatividade."
                                }
                              ],
                              "practicalExample": "Para uma asa de aeronave modelada como viga cantilever vibrando em flexão, formule H(q,p) com q=deslocamento modal e p=momento modal. Derive dH/dt=0, simulando vibração livre e confirmando energia total constante, essencial para prever flutter sem dissipadores.",
                              "finalVerifications": [
                                "Derivação algébrica de dH/dt = ∂H/∂t está correta e completa.",
                                "Condições de conservatividade (sem ∂H/∂t, forças de V(q)) são explicitamente declaradas.",
                                "Aplicação ao exemplo de vibração mostra H constante em simulação numérica.",
                                "Gráficos de q(t), p(t) e H(t) confirmam trajetórias fechadas e conservação.",
                                "Discussão qualitativa liga conservação à estabilidade estrutural.",
                                "Identificação correta de violações (ex: amortecimento) em casos não-conservativos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação do bracket de Poisson e simplificação.",
                                "Correta identificação de sistemas conservativos vs. não-autônomos.",
                                "Qualidade da modelagem Hamiltoniana para vibrações estruturais.",
                                "Integração numérica precisa e visualização de conservação.",
                                "Profundidade na discussão de implicações em aeroelasticidade.",
                                "Clareza na explicação conceitual de H como energia total."
                              ],
                              "crossCurricularConnections": [
                                "Física Clássica: Teorema de Noether e simetrias temporais.",
                                "Engenharia Computacional: Simulações em dinâmica não-linear (FEM com Hamiltoniano).",
                                "Controle de Sistemas: Estabilidade de sistemas conservativos em controle ótimo.",
                                "Matemática Aplicada: Equações diferenciais ordinárias e integrais de movimento."
                              ],
                              "realWorldApplication": "Em análise aeroelástica de aeronaves, verificar dH/dt=0 assegura que vibrações livres em asas ou fuselagem não ganham energia spurious em simulações, prevendo criticamente instabilidades como flutter e divergência sem modelar dissipação prematuramente."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.4",
                    "name": "Aplicação à Modelagem de Estruturas Aeroespaciais",
                    "description": "Uso das equações de Lagrange e Hamilton para modelar vibrações em estruturas aeroespaciais com graus de liberdade.",
                    "individualConcepts": [
                      {
                        "id": "57.1.1.1",
                        "name": "Formulação Lagrangiana para Vibrações em Estruturas com Um Grau de Liberdade",
                        "description": "Uso das equações de Lagrange para derivar as equações de movimento de sistemas estruturais aeroespaciais com um único grau de liberdade (GDL), considerando energias cinética e potencial em contextos de vibrações livres e forçadas.",
                        "specificSkills": [
                          {
                            "id": "57.1.1.1.1",
                            "name": "Identificar coordenadas generalizadas e formular o Lagrangiano",
                            "description": "Selecionar coordenadas generalizadas adequadas para modelar vibrações em vigas ou placas aeroespaciais simplificadas com 1 GDL, calculando a energia cinética T e potencial V, e formando L = T - V.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de coordenadas generalizadas e formulação Lagrangiana",
                                  "subSteps": [
                                    "Defina coordenadas generalizadas como variáveis independentes que descrevem completamente a configuração do sistema.",
                                    "Explique que para 1 GDL, uma única coordenada q(t) é suficiente.",
                                    "Revise as expressões para energia cinética T (função de velocidades generalizadas) e potencial V (função de coordenadas).",
                                    "Lembre que o Lagrangiano L = T - V leva às equações de Euler-Lagrange.",
                                    "Discuta simplificações para estruturas aeroespaciais como vigas ou placas."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e dê um exemplo simples de 1 GDL (ex: pêndulo).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Mecânica Analítica (Goldstein ou similar)",
                                    "Notas de aula sobre Lagrange",
                                    "Calculadora simbólica (SymPy ou Mathematica)"
                                  ],
                                  "tips": "Use analogias mecânicas simples para fixar ideias antes de estruturas complexas.",
                                  "learningObjective": "Compreender o papel das coordenadas generalizadas na redução de GDLs para modelagem eficiente.",
                                  "commonMistakes": [
                                    "Confundir coordenadas generalizadas com cartesianas; ignorar restrições holonômicas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o sistema físico e selecionar coordenada generalizada adequada",
                                  "subSteps": [
                                    "Descreva a geometria e condições de contorno da viga ou placa (ex: cantilever, comprimento L, seção transversal).",
                                    "Identifique o modo de vibração dominante (ex: flexão no primeiro modo).",
                                    "Escolha q(t) como amplitude modal ou deslocamento em ponto chave (ex: ponta da viga).",
                                    "Justifique a escolha: deve capturar a cinemática essencial com 1 GDL.",
                                    "Esboce o sistema com q(t) anotado."
                                  ],
                                  "verification": "Desenhe diagrama da estrutura com q(t) indicada e explique por que é adequada para 1 GDL.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Diagrama de viga cantilever",
                                    "Software de desenho (Draw.io)",
                                    "Tabelas de funções modais para vigas"
                                  ],
                                  "tips": "Prefira coordenadas modais para vibrações, pois diagonalizam massas e rigidezes.",
                                  "learningObjective": "Selecionar q(t) que minimize complexidade mantendo fidelidade ao comportamento dinâmico.",
                                  "commonMistakes": [
                                    "Escolher múltiplas coordenadas desnecessárias; ignorar simetrias do sistema."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular e calcular a energia cinética T em termos de q e \\dot{q}",
                                  "subSteps": [
                                    "Expresse o campo de deslocamento y(x,t) = φ(x) q(t), onde φ(x) é a função modal.",
                                    "Calcule velocidades locais: \\dot{y}(x,t) = φ(x) \\dot{q}(t).",
                                    "Integre T = (1/2) ∫ μ(x) \\dot{y}^2 dx = (1/2) M \\dot{q}^2, onde M é a massa generalizada.",
                                    "Verifique normalização: ∫ φ^2 dx = 1 para M = massa total.",
                                    "Numeralize para valores típicos de viga aeroespacial."
                                  ],
                                  "verification": "Derive expressão analítica de T e compute coeficiente numérico para L=1m, μ=1kg/m.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Tabelas de funções modais (φ(x) = sinh(kx)/sinh(kl) etc.)",
                                    "SymPy para integrais",
                                    "Papel e lápis para derivação"
                                  ],
                                  "tips": "Use funções modais ortonormais para simplificar integrais.",
                                  "learningObjective": "Expressar T quadraticamente em \\dot{q} para sistemas discretizados.",
                                  "commonMistakes": [
                                    "Esquecer fator 1/2; erros em limites de integração."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular e calcular a energia potencial V em termos de q",
                                  "subSteps": [
                                    "Expresse curvatura ou deformação ε(x) em termos de y(x,t) = φ(x) q(t).",
                                    "Para flexão: κ(x) ≈ ∂²y/∂x², então V = (1/2) ∫ EI (∂²y/∂x²)^2 dx = (1/2) K q^2.",
                                    "Calcule rigidez generalizada K = ∫ EI (φ'')^2 dx.",
                                    "Inclua pré-estresse se aplicável (ex: aeroespacial).",
                                    "Valide com frequência natural ω = sqrt(K/M)."
                                  ],
                                  "verification": "Derive V analiticamente e confirme ω ≈ 3.52 sqrt(EI/μ L^4) para viga cantilever.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Propriedades de materiais aeroespaciais (E, I para compósitos)",
                                    "SymPy",
                                    "Referências de vibrações (Meirovitch)"
                                  ],
                                  "tips": "Aproximações de Rayleigh-Ritz validam escolhas modais.",
                                  "learningObjective": "Capturar energia elástica via integrais de deformação.",
                                  "commonMistakes": [
                                    "Usar teoria de Euler-Bernoulli incorretamente; confundir V com T."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Formular o Lagrangiano L = T - V e validar a formulação",
                                  "subSteps": [
                                    "Escreva L(q, \\dot{q}, t) = (1/2) M \\dot{q}^2 - (1/2) K q^2.",
                                    "Verifique dependências: L deve depender só de q, \\dot{q} (não x explícito).",
                                    "Derive equação de movimento via d/dt(∂L/∂\\dot{q}) - ∂L/∂q = 0 → \\ddot{q} + ω^2 q = 0.",
                                    "Compare com equação clássica da viga.",
                                    "Teste com valores numéricos."
                                  ],
                                  "verification": "Mostre que a EOM reduz à equação harmônica e matches literatura.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Caderno de exercícios",
                                    "Software de simulação (MATLAB para validar)"
                                  ],
                                  "tips": "Sempre normalize modais para M=1 se possível.",
                                  "learningObjective": "Montar L completo e gerar EOM corretas.",
                                  "commonMistakes": [
                                    "Inverter sinal de V; esquecer tempo-derivadas em ∂L/∂\\dot{q}."
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma viga cantilever aeroespacial de L=2m, μ=0.5 kg/m, EI=10^4 Nm², use primeiro modo φ(x)=(sinh(1.875 x/L) - sin(1.875 x/L))/(cosh(1.875)-cos(1.875)) - [...normalização...]. Então T=(1/2)(0.24) \\dot{q}^2, V=(1/2)(22.4) q^2, L=T-V, levando a ω≈3.14 rad/s.",
                              "finalVerifications": [
                                "T é quadrática em \\dot{q} apenas, sem q.",
                                "V é quadrática em q apenas, sem \\dot{q}.",
                                "L gera EOM harmônica via Euler-Lagrange.",
                                "Frequência natural coincide com solução exata da viga.",
                                "Coordenada q captura >90% da energia modal.",
                                "Formulação invariante sob mudança de escala de q."
                              ],
                              "assessmentCriteria": [
                                "Precisão analítica das expressões de T e V (erro <5%).",
                                "Justificativa física da escolha de q(t).",
                                "Correção das integrais de massa e rigidez.",
                                "Validação numérica com frequências conhecidas.",
                                "Clareza no diagrama e derivações passo-a-passo.",
                                "Identificação de potenciais extensões (ex: forçantes aerodinâmicas)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e métodos de Rayleigh-Ritz.",
                                "Física: Princípios de conservação de energia em mecânica clássica.",
                                "Engenharia Mecânica: Análise modal de vibrações estruturais.",
                                "Ciência de Materiais: Propriedades anisotrópicas em compósitos aeroespaciais."
                              ],
                              "realWorldApplication": "Modelagem de vibrações em painéis de fuselagem ou asas de aeronaves para prever flutter aeroelástico, essencial em certificação FAA/EASA, evitando falhas catastróficas como no caso histórico do Tacoma Narrows."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.1.1.1.2",
                            "name": "Derivar equações de movimento via equações de Lagrange",
                            "description": "Aplicar d/dt (∂L/∂q̇) - ∂L/∂q = Q para obter equações diferenciais de segunda ordem para resposta dinâmica a excitações harmônicas ou iniciais em estruturas como massas-molas representando componentes aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o sistema físico e coordenadas generalizadas",
                                  "subSteps": [
                                    "Selecione um sistema simples com um grau de liberdade (DOF), como um oscilador massa-mola representando um componente aeroespacial.",
                                    "Desenhe o diagrama esquemático mostrando a massa m, mola com constante k, e posição de equilíbrio.",
                                    "Identifique a coordenada generalizada q (ex: deslocamento x da posição de equilíbrio).",
                                    "Defina velocidades generalizadas q̇ (ex: ẋ).",
                                    "Especifique forças não conservativas Q, como excitação harmônica F(t) = F0 cos(ωt)."
                                  ],
                                  "verification": "Diagrama completo com q, q̇ e Q anotados corretamente.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software de desenho como Draw.io",
                                    "Livro de dinâmica de estruturas aeroespaciais"
                                  ],
                                  "tips": "Mantenha o sistema com 1 DOF para simplicidade inicial; expanda depois.",
                                  "learningObjective": "Selecionar coordenadas generalizadas adequadas para formulação Lagrangiana.",
                                  "commonMistakes": [
                                    "Usar coordenadas cartesianas redundantes em vez de generalizadas",
                                    "Ignorar forças externas Q"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a energia cinética T e potencial V",
                                  "subSteps": [
                                    "Expresse T em termos de q̇: para massa-mola, T = (1/2) m q̇².",
                                    "Expresse V em termos de q: V = (1/2) k q².",
                                    "Verifique unidades: T e V em joules.",
                                    "Considere excitações iniciais ou harmônicas na definição de V se aplicável.",
                                    "Anote expressões explicitamente para o sistema aeroespacial (ex: m de flap, k efetiva)."
                                  ],
                                  "verification": "Expressões de T e V corretas e dimensionally consistentes.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Calculadora",
                                    "Folha de anotações",
                                    "Referência: Goldstein 'Classical Mechanics'"
                                  ],
                                  "tips": "Use posições relativas à equilíbrio para simplificar V.",
                                  "learningObjective": "Expressar energias em coordenadas generalizadas.",
                                  "commonMistakes": [
                                    "Confundir T com V",
                                    "Esquecer fator 1/2 nas energias quadráticas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formar o Lagrangiano L = T - V",
                                  "subSteps": [
                                    "Subtraia V de T para obter L(q, q̇) = (1/2)m q̇² - (1/2)k q².",
                                    "Confirme que L depende de q e q̇, mas não explicitamente de t (sistema autônomo).",
                                    "Para excitação harmônica, inclua Q separadamente.",
                                    "Escreva L explicitamente para o exemplo massa-mola aeroespacial.",
                                    "Diferencie preliminarmente: compute ∂L/∂q̇ = m q̇."
                                  ],
                                  "verification": "L correto e ∂L/∂q̇ computado.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Papel quadriculado",
                                    "SymPy ou Mathematica para verificação simbólica"
                                  ],
                                  "tips": "L deve ser escalar; verifique sinal T - V.",
                                  "learningObjective": "Construir o Lagrangiano a partir de energias.",
                                  "commonMistakes": [
                                    "Erro de sinal em L (T + V ao invés de T - V)",
                                    "Dependência errada em t"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar as equações de Euler-Lagrange",
                                  "subSteps": [
                                    "Compute ∂L/∂q = -k q.",
                                    "Compute d/dt (∂L/∂q̇) = m q̈.",
                                    "Aplique d/dt (∂L/∂q̇) - ∂L/∂q = Q → m q̈ + k q = Q(t).",
                                    "Para Q=0, obtenha equação livre; para harmônica, inclua F0 cos(ωt).",
                                    "Simplifique para forma padrão de segunda ordem."
                                  ],
                                  "verification": "Equação final: m q̈ + k q = Q(t), com coeficientes corretos.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Calculadora simbólica",
                                    "Exemplos de livros de aeroelasticidade"
                                  ],
                                  "tips": "Derive d/dt cuidadosamente usando regra da cadeia.",
                                  "learningObjective": "Derivar equações de movimento via Lagrange.",
                                  "commonMistakes": [
                                    "Erro na derivada temporal de ∂L/∂q̇",
                                    "Esquecer o sinal na equação"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e interpretar a equação de movimento",
                                  "subSteps": [
                                    "Compare com equação Newtoniana: mẍ + kx = F.",
                                    "Discuta condições iniciais (q(0), q̇(0)) para resposta.",
                                    "Para excitação harmônica, identifique solução particular.",
                                    "Relacione a vibrações estruturais aeroespaciais (ex: frequência natural ω_n = sqrt(k/m)).",
                                    "Teste numericamente com valores exemplo."
                                  ],
                                  "verification": "Equação matches Newton e solução teste numérica converge.",
                                  "estimatedTime": "60 minutes",
                                  "materials": [
                                    "Python/MATLAB para simulação",
                                    "Valores numéricos: m=1kg, k=100N/m"
                                  ],
                                  "tips": "Simule para validar.",
                                  "learningObjective": "Interpretar e validar derivação Lagrangiana.",
                                  "commonMistakes": [
                                    "Ignorar Q em sistemas forçados",
                                    "Frequência errada"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um flap de asa simplificado como massa-mola (m=10kg, k=1000N/m), com excitação harmônica F(t)=100 cos(2t) N: L = 5 ẋ² - 500 x², leva a 10 ẍ + 1000 x = 100 cos(2t), modelando resposta dinâmica a turbulência.",
                              "finalVerifications": [
                                "Equação é diferencial linear de segunda ordem com coeficientes corretos.",
                                "Forma matches equação Newtoniana equivalente.",
                                "Frequência natural ω_n = sqrt(k/m) emerge corretamente.",
                                "Resposta a condições iniciais ou harmônicas é solucionável.",
                                "Dimensões consistentes (aceleração em m/s²).",
                                "Validação numérica com simulação simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação de T, V e L (sem erros algébricos).",
                                "Correta aplicação de d/dt (∂L/∂q̇) - ∂L/∂q = Q.",
                                "Inclusão apropriada de Q para excitações.",
                                "Interpretação física da equação derivada.",
                                "Validação cruzada com método Newtoniano.",
                                "Clareza na documentação dos passos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e derivadas parciais.",
                                "Física: Mecânica lagrangiana vs. newtoniana.",
                                "Engenharia Aeroespacial: Modelagem de aeroelasticidade e flutter.",
                                "Computação: Simulação numérica em Python/MATLAB.",
                                "Controle: Análise de sistemas dinâmicos lineares."
                              ],
                              "realWorldApplication": "Derivação usada em aeroespacial para modelar vibrações de componentes como painéis de asas ou flaps sob cargas harmônicas (turbulência), prevendo instabilidades como flutter e otimizando designs para segurança em aeronaves."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.1.1.1.3",
                            "name": "Analisar resposta dinâmica com excitações de base",
                            "description": "Modelar transmissão e isolamento de vibrações usando Lagrange para excitações de base em sistemas aeroespaciais, calculando fatores de amplificação e diagramas de resposta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o modelo físico de excitação de base em estruturas aeroespaciais",
                                  "subSteps": [
                                    "Identifique componentes típicos: massa (m), amortecedor (c), mola (k) e movimento base y(t) = Y sin(ωt).",
                                    "Desenhe o diagrama de corpo livre mostrando forças inerciais relativas e deslocamentos absolutos.",
                                    "Defina coordenadas generalizadas: x (deslocamento relativo à base) e y (deslocamento da base).",
                                    "Revise conceitos de vibração forçada vs. excitação de base em contextos aeroespaciais como painéis de satélites.",
                                    "Calcule a posição absoluta z = x + y para entender transmissão de vibrações."
                                  ],
                                  "verification": "Desenhe e rotule corretamente o diagrama de corpo livre com todas as forças e coordenadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel, lápis, software de desenho (ex: Draw.io), notas de aula sobre vibrações básicas.",
                                  "tips": "Use analogias como um carro em estrada irregular para visualizar excitação de base.",
                                  "learningObjective": "Modelar fisicamente sistemas com um grau de liberdade sujeitos a excitação de base.",
                                  "commonMistakes": "Confundir deslocamento relativo com absoluto; ignorar aceleração da base na força inercial."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a função Lagrangiana para o sistema",
                                  "subSteps": [
                                    "Escreva a energia cinética T = (1/2)m (ẋ + ẏ)^2 expandindo para termos relativos e absolutos.",
                                    "Escreva a energia potencial V = (1/2)k x^2, focando no alongamento relativo da mola.",
                                    "Calcule a Lagrangiana L = T - V.",
                                    "Verifique unidades e dependências: L deve depender de x, ẋ, ẏ e ω.",
                                    "Discuta simplificações para sistemas aeroespaciais leves."
                                  ],
                                  "verification": "Derive L corretamente e confirme que ∂L/∂ẋ = m(ẋ + ẏ).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Caderno de equações, calculadora simbólica (ex: SymPy ou Mathematica), referências de Lagrange.",
                                  "tips": "Expanda sempre (ẋ + ẏ)^2 = ẋ² + 2ẋẏ + ẏ² para evitar erros algébricos.",
                                  "learningObjective": "Construir a Lagrangiana corretamente para vibrações com excitação de base.",
                                  "commonMistakes": "Incluir y na energia potencial; esquecer termos cruzados na cinética."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar as equações de movimento usando os Equações de Lagrange",
                                  "subSteps": [
                                    "Aplique d/dt (∂L/∂ẋ) - ∂L/∂x = 0 para obter mẍ + cẋ + kx = -mÿ.",
                                    "Inclua amortecimento via Rayleigh: adicione termo não conservativo Q = -cẋ.",
                                    "Formule a equação final: mẍ + cẋ + kx = -m Y ω² sin(ωt).",
                                    "Identifique o termo de excitação equivalente como força inercial -mÿ.",
                                    "Valide com equação padrão de vibração forçada."
                                  ],
                                  "verification": "Resolva numericamente para parâmetros simples e compare com solução conhecida.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Software de simulação (MATLAB/Simulink ou Python com SciPy), exemplos resolvidos.",
                                  "tips": "Lembre-se: excitação de base é equivalente a uma força -mÿ aplicada à massa.",
                                  "learningObjective": "Derivar equações dinâmicas precisas via Lagrange para isolamento de vibrações.",
                                  "commonMistakes": "Esquecer o sinal negativo em -mÿ; omitir amortecimento corretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular a resposta em regime permanente e fatores de amplificação",
                                  "subSteps": [
                                    "Assuma solução x(t) = X sin(ωt - φ) e derive amplitude X = (m Y ω²) / sqrt((k - mω²)^2 + (cω)^2).",
                                    "Calcule fator de amplificação transmissibilidade TR = |X/Y| = (ω/ω_n)^2 / sqrt((1 - (ω/ω_n)^2)^2 + (2ζ ω/ω_n)^2).",
                                    "Determine fator de fase φ.",
                                    "Gere diagrama de resposta: Bode plot de TR vs. r = ω/ω_n para ζ variados.",
                                    "Analise regiões: isolamento (r > √2), ressonância."
                                  ],
                                  "verification": "Plote TR para ζ=0.1 e confirme picos em r≈1 e decaimento para r>√2.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "MATLAB/Python para plotting (Matplotlib), planilhas Excel para cálculos iniciais.",
                                  "tips": "Use ratios adimensionais r e ζ para generalizar análise aeroespacial.",
                                  "learningObjective": "Quantificar resposta dinâmica e transmissibilidade para design de isoladores.",
                                  "commonMistakes": "Confundir TR de deslocamento com aceleração; erros em denominação da amplitude."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar à modelagem aeroespacial e interpretar diagramas",
                                  "subSteps": [
                                    "Selecione parâmetros reais: m=10kg, k=1000N/m, c=5Ns/m para painel de satélite.",
                                    "Simule resposta para excitação base de foguete (Y=0.1m, ω=10-100 rad/s).",
                                    "Interprete diagramas: identifique faixas de isolamento vibracional.",
                                    "Discuta otimizações: variar ζ para minimizar TR em frequências críticas.",
                                    "Compare com dados experimentais ou literatura aeroespacial."
                                  ],
                                  "verification": "Gere e anote diagrama de resposta com conclusões sobre isolamento.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de simulação dinâmica (ANSYS ou similar), artigos sobre vibrações em launch vehicles.",
                                  "tips": "Foque em frequências de lançamento de foguetes (baixas) vs. orbitais (altas).",
                                  "learningObjective": "Interpretar resultados para aplicações práticas em aeroespacial.",
                                  "commonMistakes": "Ignorar efeitos não lineares em amplitudes altas; generalizações sem contexto real."
                                }
                              ],
                              "practicalExample": "Em um satélite acoplado a um lançador como o Falcon 9, modele um isolador de vibração para um painel eletrônico (m=5kg, k=2000N/m, c=10Ns/m) sujeito a excitação base y(t)=0.05 sin(20t) m durante lançamento. Calcule TR em ω=15 rad/s e plote diagrama para verificar se vibrações são atenuadas abaixo de 10% da base.",
                              "finalVerifications": [
                                "Derivação correta da equação mẍ + cẋ + kx = -mÿ.",
                                "Cálculo preciso de TR para r=0.5, 1.0, 2.0 com ζ=0.05.",
                                "Diagrama de resposta mostrando ressonância e zona de isolamento.",
                                "Interpretação qualitativa: faixa de frequências para isolamento efetivo.",
                                "Simulação numérica converge para solução analítica.",
                                "Aplicação correta a exemplo aeroespacial com parâmetros realistas."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na Lagrangiana e equações de movimento (90% correto).",
                                "Correção de fórmulas de amplitude e TR (sem erros dimensionais).",
                                "Qualidade e legibilidade dos diagramas de resposta (rótulos completos).",
                                "Profundidade de análise: identificação de ressonância e isolamento.",
                                "Criatividade na aplicação real: ligação com cenários aeroespaciais específicos.",
                                "Eficiência: tempo dentro do estimado com verificações passadas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Solução de EDOs lineares não homogêneas e análise assintótica.",
                                "Física: Princípios de conservação de energia e dinâmica newtoniana equivalente.",
                                "Engenharia de Controle: Projeto de isoladores como sistemas passivos de controle.",
                                "Ciência de Materiais: Seleção de k e c baseados em propriedades aeroespaciais."
                              ],
                              "realWorldApplication": "Projeto de isoladores de vibração em veículos de lançamento (ex: Ariane 5) para proteger eletrônicos de cargas dinâmicas durante ascensão, reduzindo fadiga estrutural e falhas por ressonância em frequências de motores."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "57.1.1.2",
                        "name": "Princípio de Hamilton para Modelagem Dinâmica de Estruturas",
                        "description": "Aplicação do princípio de Hamilton para formular equações canônicas em sistemas estruturais aeroespaciais, transformando o problema lagrangiano em hamiltoniano para análise de vibrações.",
                        "specificSkills": [
                          {
                            "id": "57.1.1.2.1",
                            "name": "Construir o Hamiltoniano a partir do Lagrangiano",
                            "description": "Calcular momentos generalizados p = ∂L/∂q̇ e o Hamiltoniano H = p q̇ - L para sistemas com 1 GDL em estruturas aeroespaciais vibrantes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e analisar o Lagrangiano do sistema",
                                  "subSteps": [
                                    "Identifique as coordenadas generalizadas q e velocidades q̇ para o sistema com 1 GDL.",
                                    "Escreva explicitamente a energia cinética T e potencial V do sistema aeroespacial vibrante.",
                                    "Forme o Lagrangiano L = T - V, expressando-o em termos de q, q̇ e parâmetros do sistema.",
                                    "Verifique a dependência: confirme que L depende de q̇ apenas quadraticamente para estruturas vibrantes.",
                                    "Simplifique expressões algébricas iniciais para facilitar derivações posteriores."
                                  ],
                                  "verification": "L está corretamente escrito como função de q e q̇, com T quadrática em q̇ e V independente de q̇.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis, calculadora simbólica (ex: SymPy ou Mathematica), notas do sistema físico.",
                                  "tips": "Use notação consistente para coordenadas (ex: q para deslocamento transversal em viga vibrante).",
                                  "learningObjective": "Entender a estrutura do Lagrangiano para sistemas dinâmicos com 1 GDL em aeroespacial.",
                                  "commonMistakes": "Confundir T e V; esquecer termos de acoplamento cinético em estruturas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o momento generalizado p",
                                  "subSteps": [
                                    "Compute a derivada parcial ∂L/∂q̇, tratando q como constante.",
                                    "Execute a diferenciação: para T = (1/2) m(q) q̇², p = m(q) q̇.",
                                    "Expresse p explicitamente como função de q e q̇.",
                                    "Verifique dimensionalmente: p deve ter unidades de momento (kg·m²/s).",
                                    "Anote a relação p = p(q, q̇) para referência."
                                  ],
                                  "verification": "∂L/∂q̇ resulta em p corretamente, coincidente com definição clássica para 1 GDL.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Folha de cálculo, software de álgebra simbólica.",
                                  "tips": "Se L tiver termos não quadráticos em q̇ (raro em vibrações lineares), use regra da cadeia.",
                                  "learningObjective": "Dominar o cálculo do momento canônico a partir do Lagrangiano.",
                                  "commonMistakes": "Derivar incorretamente ∂T/∂q̇ se m depender de q; esquecer sinal negativo de V."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver q̇ em termos de p e q",
                                  "subSteps": [
                                    "Inverta a relação p = ∂L/∂q̇ para obter q̇ = q̇(p, q).",
                                    "Para forma padrão p = m(q) q̇, resolva q̇ = p / m(q).",
                                    "Substitua esta expressão em L onde necessário.",
                                    "Confirme que a inversa existe (geralmente sim para T convexa em q̇).",
                                    "Simplifique algebricamente para evitar erros de propagação."
                                  ],
                                  "verification": "q̇(p, q) · ∂L/∂q̇ recupera o p original.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora, software para manipulação simbólica.",
                                  "tips": "Mantenha expressões fatoradas; teste com valores numéricos simples.",
                                  "learningObjective": "Aprender a Legendre transformar velocidades em momentos.",
                                  "commonMistakes": "Não inverter corretamente se m(q) complexo; propagar erros algébricos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e verificar o Hamiltoniano H",
                                  "subSteps": [
                                    "Calcule H = p q̇ - L, substituindo q̇(p, q) em ambos os termos.",
                                    "Expanda: H = p (p / m) - [T - V] = T + V para T quadrático.",
                                    "Simplifique para mostrar H(q, p) = T(q, p) + V(q).",
                                    "Verifique conservação: {H, H} = 0 via colchetes de Poisson.",
                                    "Confirme que H é energia total para sistema não dissipativo."
                                  ],
                                  "verification": "H depende apenas de q e p, não explicitamente do tempo, e ∂H/∂q = -∂L/∂q, ∂H/∂p = q̇.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel, software simbólico para verificação.",
                                  "tips": "Use identidade H = 2T - L para aceleração em casos quadráticos.",
                                  "learningObjective": "Construir H e validar suas propriedades como função Hamiltoniana.",
                                  "commonMistakes": "Esquecer substituição completa de q̇; não simplificar para T + V."
                                }
                              ],
                              "practicalExample": "Para uma viga cantilever aeroespacial vibrante com 1 GDL (deslocamento w na ponta): T = (1/2) ∫ ρ A (∂w/∂t)² dx ≈ (1/2) M_eff ű², V = (1/2) k w². L = T - V. Então p = M_eff ű, ű = p / M_eff, H = p²/(2 M_eff) + (1/2) k w².",
                              "finalVerifications": [
                                "H é expresso unicamente em q e p.",
                                "∂H/∂p = q̇ e ∂H/∂q = -∂L/∂q.",
                                "H conserva-se ao longo de trajetórias (dH/dt = 0 para sistemas autônomos).",
                                "H coincide com energia total T + V.",
                                "Colchete de Poisson {H, q} = ∂H/∂p = q̇ e {H, p} = -∂H/∂q.",
                                "Simulação numérica simples preserva H."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica em p = ∂L/∂q̇ (sem erros de derivação).",
                                "Correta inversão e substituição para q̇(p, q).",
                                "Simplificação completa de H para forma T(q,p) + V(q).",
                                "Verificações teóricas corretas (relações canônicas).",
                                "Aplicação contextual a estruturas aeroespaciais vibrantes.",
                                "Clareza e organização das derivações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformada de Legendre e equações diferenciais ordinárias.",
                                "Engenharia Mecânica: Modelagem de vibrações em estruturas flexíveis.",
                                "Física: Mecânica clássica avançada e conservação de energia.",
                                "Computação: Implementação em Python/SymPy para simulações dinâmicas.",
                                "Controle: Uso de H em controladores Hamiltonianos para aeroelasticidade."
                              ],
                              "realWorldApplication": "Em modelagem de flutter aeroelástico em asas de aeronaves ou painéis de satélites, o Hamiltoniano facilita simulações numéricas eficientes (ex: symplectic integrators) para prever instabilidades vibratórias e otimizar designs contra fadiga."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.1.1.2.2",
                            "name": "Derivar equações canônicas de Hamilton",
                            "description": "Obter dq/dt = ∂H/∂p e dp/dt = -∂H/∂q para simular respostas dinâmicas a forças periódicas ou arbitrárias em modelos de vibração estrutural.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Hamiltoniano e coordenadas canônicas",
                                  "subSteps": [
                                    "Revise a transformação de Lagrange para Hamilton: L(q, dq/dt) → H(q, p) via p = ∂L/∂(dq/dt).",
                                    "Defina H = p * dq/dt - L, expressando dq/dt em termos de p.",
                                    "Identifique q (coordenada generalizada) e p (momento conjugado) em sistemas conservativos.",
                                    "Estude propriedades de H: conservação de energia para sistemas sem tempo explícito.",
                                    "Pratique com um exemplo simples como oscilador harmônico."
                                  ],
                                  "verification": "Escreva a expressão do Hamiltoniano para um oscilador harmônico m(q'' + ω²q)=0 e confirme H = p²/2m + (1/2)mω²q².",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Livro de Mecânica Clássica (Goldstein)",
                                    "Notas de aula sobre Lagrange",
                                    "Calculadora simbólica (Wolfram Alpha)"
                                  ],
                                  "tips": "Sempre verifique se H é expresso apenas em q, p e t, sem velocidades explícitas.",
                                  "learningObjective": "Dominar a definição e construção do Hamiltoniano a partir do Lagrangiano.",
                                  "commonMistakes": [
                                    "Confundir p com mv em coordenadas não cartesianas",
                                    "Esquecer o termo -L na definição de H",
                                    "Não eliminar dq/dt completamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a equação canônica dq/dt = ∂H/∂p",
                                  "subSteps": [
                                    "Parta da definição total de H(q, p, t) e use a regra da cadeia: dH/dt = ∂H/∂q * dq/dt + ∂H/∂p * dp/dt + ∂H/∂t.",
                                    "Como H = p * dq/dt - L, derive dH/dt = dq/dt * dp/dt - dL/dt.",
                                    "Para L, dL/dt = ∂L/∂q * dq/dt + ∂L/∂(dq/dt) * d²q/dt² + ∂L/∂t.",
                                    "Use Equações de Euler-Lagrange para simplificar e isole dq/dt.",
                                    "Confirme que dq/dt = ∂H/∂p pela identidade ∂H/∂p = dq/dt."
                                  ],
                                  "verification": "Derive dq/dt para H = p²/2m + V(q) e obtenha dq/dt = p/m.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e caneta para derivações",
                                    "Software como Mathematica ou SymPy para verificação simbólica"
                                  ],
                                  "tips": "Use diferenciação total e preserve termos passo a passo para evitar erros algébricos.",
                                  "learningObjective": "Derivar matematicamente a primeira equação canônica de Hamilton.",
                                  "commonMistakes": [
                                    "Ignorar ∂H/∂t na diferenciação total",
                                    "Confundir ordem de derivadas parciais",
                                    "Esquecer sinal na transformação L para H"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a equação canônica dp/dt = -∂H/∂q",
                                  "subSteps": [
                                    "Continue da derivação anterior: compare dH/dt com expressão de L para isolar dp/dt.",
                                    "Mostre que dp/dt = -∂H/∂q usando Euler-Lagrange: d/dt(∂L/∂(dq/dt)) = ∂L/∂q.",
                                    "Substitua ∂L/∂q = -∂H/∂q + p * ∂²H/∂p∂q e simplifique.",
                                    "Verifique simetria com a primeira equação via Poisson brackets básicos.",
                                    "Aplique a um sistema com potencial V(q)."
                                  ],
                                  "verification": "Para o oscilador, mostre dp/dt = -mω²q a partir de ∂H/∂q = mω²q.",
                                  "estimatedTime": "1-1.5 horas",
                                  "materials": [
                                    "Referência: Marion & Thornton Mecânica Clássica",
                                    "SymPy ou MATLAB para derivadas simbólicas"
                                  ],
                                  "tips": "Mantenha consistência nos sinais: lembre que forças são -∇V.",
                                  "learningObjective": "Completar a derivação das equações canônicas simétricas.",
                                  "commonMistakes": [
                                    "Sinal errado em dp/dt (esquecer o negativo)",
                                    "Não usar corretamente Euler-Lagrange",
                                    "Introduzir dependência explícita de tempo prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar equações a modelos de vibração estrutural",
                                  "subSteps": [
                                    "Construa H para uma viga em vibração: discretize em modos normais q_i, p_i.",
                                    "Escreva dq_i/dt = ∂H/∂p_i e dp_i/dt = -∂H/∂q_i com forças periódicas F(t) sin(ωt).",
                                    "Inclua termo não-conservativo via ∂H/∂t ou forças generalizadas.",
                                    "Simule numericamente as equações para resposta dinâmica.",
                                    "Analise estabilidade para forças arbitrárias."
                                  ],
                                  "verification": "Implemente em código simples e plote q(t) para força periódica, confirmando ressonância.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Exemplo de viga Euler-Bernoulli",
                                    "Artigo sobre aeroelasticidade"
                                  ],
                                  "tips": "Use coordenadas modais para reduzir graus de liberdade em estruturas.",
                                  "learningObjective": "Aplicar derivação a simulações dinâmicas em aeroespacial.",
                                  "commonMistakes": [
                                    "Não linearizar para pequenas vibrações",
                                    "Ignorar acoplamento modal",
                                    "Erro numérico em integração (use Runge-Kutta)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma viga cantilever em vibração flexural com força periódica F(t) = F0 sin(ωt) no modo fundamental: H = Σ p_i²/2m_i + Σ (1/2) k_i q_i² - q1 F(t). Então dq1/dt = ∂H/∂p1 = p1/m1, dp1/dt = -∂H/∂q1 = -k1 q1 + F(t). Simule para prever amplitudes de resposta.",
                              "finalVerifications": [
                                "Deriva corretamente dq/dt e dp/dt para oscilador harmônico.",
                                "Constrói H para sistema multi-grau de liberdade.",
                                "Inclui corretamente forças externas nas equações.",
                                "Simula numericamente e interpreta resultados dinâmicos.",
                                "Verifica conservação de H em sistema sem dissipação.",
                                "Identifica condições de ressonância em vibrações forçadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação das equações canônicas (sem erros de sinal).",
                                "Correta construção do Hamiltoniano a partir de L ou energia.",
                                "Adequação da aplicação a vibrações estruturais com forças periódicas.",
                                "Clareza na explicação de passos e verificações.",
                                "Capacidade de simulação numérica e análise de resultados.",
                                "Identificação de erros comuns e limitações do método."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e derivadas parciais.",
                                "Computação: Integração numérica de EDOs (SciPy odeint).",
                                "Física Quântica: Analogia com mecânica quântica (operadores q, p).",
                                "Engenharia de Controle: Estabilização de sistemas hamiltonianos.",
                                "Aerodinâmica: Modelagem de flutter via equações acopladas."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, derivação permite simular respostas de asas ou fuselagens a cargas aerodinâmicas periódicas, prevendo instabilidades como flutter divergente e otimizando designs para missões espaciais ou aviônicos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "57.1.1.3",
                        "name": "Extensão a Múltiplos Graus de Liberdade e Aplicações Aeroespaciais",
                        "description": "Modelagem de estruturas aeroespaciais com múltiplos GDL usando Lagrange e Hamilton, incluindo análise modal, frequências naturais e integração com aeroelasticidade.",
                        "specificSkills": [
                          {
                            "id": "57.1.1.3.1",
                            "name": "Formular modelo Lagrangiano para sistemas MDOF",
                            "description": "Derivar matrizes de massa e rigidez para estruturas aeroespaciais com 2+ GDL, calculando frequências naturais e modos via equações de Lagrange generalizadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Formalismo Lagrangiano para Sistemas MDOF",
                                  "subSteps": [
                                    "Estudar a equação de Lagrange generalizada: d/dt (∂L/∂q̇_i) - ∂L/∂q_i = 0 para cada coordenada generalizada q_i.",
                                    "Compreender que L = T - V, com T energia cinética quadrática em velocidades q̇ e V potencial em q.",
                                    "Estender para MDOF: vetor q = [q1, q2, ..., qn]^T, resultando em M(q) q̈ + C(q, q̇) q̇ + K(q) q = 0.",
                                    "Linearizar para pequenas vibrações: assumir T = (1/2) q̇^T M q̇ e V = (1/2) q^T K q.",
                                    "Derivar a forma matricial padrão: M q̈ + K q = 0."
                                  ],
                                  "verification": "Derivar corretamente a equação linearizada para um sistema 2DOF simples e identificar M e K.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Advanced Engineering Dynamics' de Greenwood",
                                    "Notas de aula sobre Lagrange",
                                    "MATLAB para verificação simbólica"
                                  ],
                                  "tips": "Use coordenadas generalizadas que minimizem acoplamentos não-lineares; pratique com SDOF primeiro.",
                                  "learningObjective": "Dominar a formulação Lagrangiana linearizada para vibrações livres em MDOF.",
                                  "commonMistakes": [
                                    "Esquecer o termo Coriolis na linearização completa.",
                                    "Confundir derivadas parciais de T e V."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Coordenadas Generalizadas e Modelo da Estrutura Aeroespacial",
                                  "subSteps": [
                                    "Escolher estrutura exemplo: viga cantilever aeroespacial com 2 GDL (deslocamento vertical w e rotação θ na ponta).",
                                    "Definir q = [w, θ]^T como coordenadas generalizadas.",
                                    "Desenhar cinemática: posição de pontos massa usando funções de interpolação (ex: beam modes).",
                                    "Determinar massas concentradas ou distribuídas e propriedades geométricas (EI, ρA).",
                                    "Verificar ortogonalidade e completude das coordenadas."
                                  ],
                                  "verification": "Esboço do modelo com q definido e velocidades expressas em termos de q̇.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software CAD para visualização (SolidWorks)",
                                    "Tabelas de propriedades de materiais aeroespaciais",
                                    "Papel e lápis para esboços"
                                  ],
                                  "tips": "Prefira modos normais como coordenadas para diagonalizar M e K.",
                                  "learningObjective": "Selecionar coordenadas generalizadas adequadas para estruturas aeroespaciais discretizadas.",
                                  "commonMistakes": [
                                    "Escolher coordenadas redundantes levando a singularidade em M.",
                                    "Ignorar rotações em estruturas flexíveis."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar Energias Cinética (T) e Potencial (V)",
                                  "subSteps": [
                                    "Expressar velocidades de pontos massa: v = J q̇, onde J é matriz Jacobiana.",
                                    "Calcular T = (1/2) ∑ m_i v_i^2 = (1/2) q̇^T M q̇, extraindo matriz de massa M.",
                                    "Para V: deformação ε em termos de q, V = (1/2) ∫ E ε^2 dV = (1/2) q^T K q.",
                                    "Computar elementos de M e K explicitamente para o modelo 2DOF.",
                                    "Verificar simetria e definitude positiva de M e K."
                                  ],
                                  "verification": "Expressões explícitas de T e V em termos de q, q̇; matrizes M e K numéricas para parâmetros dados.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/SymPy para derivação simbólica",
                                    "Folhas de cálculo para integração",
                                    "Referência: 'Vibration of Mechanical Systems' de Rao"
                                  ],
                                  "tips": "Use expansão binomial para termos quadráticos em pequenas rotações.",
                                  "learningObjective": "Derivar matrizes M e K a partir de princípios energéticos Lagrangianos.",
                                  "commonMistakes": [
                                    "Erro em Jacobiana levando a M assimétrica.",
                                    "Confundir rigidez geométrica com material."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular Equações de Movimento e Resolver para Frequências e Modos",
                                  "subSteps": [
                                    "Aplicar Lagrange: ∂L/∂q̇ = M q̇, d/dt(∂L/∂q̇) = M q̈; ∂L/∂q = -K q.",
                                    "Obter M q̈ + K q = 0; assumir q = φ e^{iωt}, levando a (K - ω^2 M) φ = 0.",
                                    "Resolver problema generalizado de autovalores: det(K - ω^2 M) = 0.",
                                    "Calcular ω_n e φ_n; normalizar φ^T M φ = 1.",
                                    "Plotar modos e interpretar fisicamente."
                                  ],
                                  "verification": "Frequências ω e modos φ corretos, validados por software.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB eig() para autovalores",
                                    "Python NumPy/SciPy",
                                    "Gráficos de modos via animação"
                                  ],
                                  "tips": "Use decomposição QR para problemas grandes; verifique com método Rayleigh.",
                                  "learningObjective": "Resolver dinamicamente sistemas MDOF via eigenvalues Lagrangianos.",
                                  "commonMistakes": [
                                    "Normalização errada (usar I em vez de M).",
                                    "Interpretar ω como Hertz em vez de rad/s."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Interpretar Resultados no Contexto Aeroespacial",
                                  "subSteps": [
                                    "Comparar frequências com soluções analíticas ou FEM.",
                                    "Analisar participação modal em cargas aeroespaciais.",
                                    "Discutir sensibilidade a parâmetros (massa, rigidez).",
                                    "Simular resposta temporal para excitação inicial.",
                                    "Documentar modelo completo em relatório."
                                  ],
                                  "verification": "Relatório com M, K, ω, φ e validação numérica.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "FEM software como ANSYS",
                                    "Relatório template LaTeX"
                                  ],
                                  "tips": "Sempre dimensionalize unidades (kg, N/m, rad/s).",
                                  "learningObjective": "Aplicar e validar modelo Lagrangiano em cenários reais aeroespaciais.",
                                  "commonMistakes": [
                                    "Ignorar efeitos de cisalhamento em vigas aeroespaciais.",
                                    "Não validar com benchmarks conhecidos."
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma seção de asa modelada como viga cantilever de 1m, EI=1e6 Nm², ρA=10 kg/m, com 2 GDL na ponta (w, θ): derive M = [[10, 0.5], [0.5, 0.083]] kg m², K = [[3e4, 1.5e3], [1.5e3, 1e3]] N m, calcule ω1≈54 rad/s (flexão), ω2≈316 rad/s (torção).",
                              "finalVerifications": [
                                "Matrizes M e K são simétricas e positivas definidas.",
                                "Frequências naturais ω_n crescentes e modos ortogonais (φ_i^T M φ_j = δ_ij).",
                                "Energias T e V derivadas coincidem com formas quadráticas.",
                                "Solução de autovalores converge com precisão numérica.",
                                "Modos interpretados corretamente (ex: 1º modo flexão dominante).",
                                "Validação com Rayleigh quotient: ω^2 ≈ φ^T K φ / φ^T M φ."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de T e V (sem erros algébricos).",
                                "Correção das matrizes M e K para o modelo proposto.",
                                "Solução válida do problema de autovalores generalizado.",
                                "Interpretação física coerente dos modos e frequências.",
                                "Validação cruzada com métodos alternativos (ex: FEM).",
                                "Clareza na documentação e unidades consistentes."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Problemas de autovalores generalizados e decomposição modal.",
                                "Controle Automático: Síntese de controladores para supressão de modos críticos.",
                                "Aerodinâmica Computacional: Acoplamento aeroelástico com equações de Navier-Stokes.",
                                "Materiais Compósitos: Efeitos anisotrópicos em K para compósitos aeroespaciais.",
                                "Otimização: Sensibilidade modal para design de estruturas leves."
                              ],
                              "realWorldApplication": "Na certificação de aeronaves como o Airbus A350, modelos Lagrangianos MDOF preveem frequências de flutter em asas, permitindo evitar ressonâncias com cargas aerodinâmicas e garantir estabilidade estrutural em voo supersônico."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.1.1.3.2",
                            "name": "Aplicar análise modal e ortogonalidade",
                            "description": "Usar coordenadas modais para decoplar equações MDOF, verificando ortogonalidade e resolvendo respostas a excitações arbitrárias em contextos aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar equações de movimento para sistemas MDOF",
                                  "subSteps": [
                                    "Derivar as equações de movimento gerais para sistemas com múltiplos graus de liberdade (MDOF) usando Lagrange ou Hamilton.",
                                    "Identificar matrizes de massa [M], rigidez [K] e amortecimento [C] para um sistema aeroespacial simples, como uma viga ou painel.",
                                    "Escrever a forma matricial padrão: [M]{ẍ} + [C]{ẋ} + [K]{x} = {F(t)}.",
                                    "Discutir propriedades simétricas das matrizes e sua importância.",
                                    "Resolver numericamente para um sistema 2-GDL como exemplo inicial."
                                  ],
                                  "verification": "O aluno deriva corretamente as equações para um sistema 2-GDL e identifica as matrizes envolvidas.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Livro de Dinâmica das Estruturas (ex: Clough & Penzien), MATLAB ou Python com NumPy/SciPy"
                                  ],
                                  "tips": "Comece com sistemas pequenos (2-3 GDL) para visualizar os modos.",
                                  "learningObjective": "Compreender a formulação matricial de sistemas MDOF em contextos aeroespaciais.",
                                  "commonMistakes": [
                                    "Ignorar simetria das matrizes, confundir coordenadas generalizadas com deslocamentos físicos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar análise modal: autovalores e autovetores",
                                  "subSteps": [
                                    "Assumir amortecimento proporcional e resolver o problema de autovalores generalizado: ([K] - ω²[M]){φ} = 0.",
                                    "Calcular frequências naturais ω_n e modos {φ_n} usando métodos numéricos.",
                                    "Normalizar os modos (ortogonalização inicial pela massa: φ_i^T M φ_j = δ_ij).",
                                    "Plotar os modos para visualização em estruturas aeroespaciais.",
                                    "Verificar convergência numérica para sistemas maiores."
                                  ],
                                  "verification": "O aluno calcula corretamente autovalores e autovetores para um sistema 2-GDL e plota os modos.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Software: MATLAB eig() ou Python scipy.linalg.eig(), exemplos de estruturas aeroespaciais"
                                  ],
                                  "tips": "Use decomposição para matrizes grandes; valide com frequências analíticas para sistemas simples.",
                                  "learningObjective": "Executar análise modal para obter modos e frequências naturais.",
                                  "commonMistakes": [
                                    "Não normalizar modos corretamente, ignorar autovalores complexos em sistemas amortecidos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar ortogonalidade das funções modais",
                                  "subSteps": [
                                    "Verificar ortogonalidade em massa: φ_i^T M φ_j = 0 para i ≠ j.",
                                    "Verificar ortogonalidade em rigidez: φ_i^T K φ_j = 0 para i ≠ j.",
                                    "Confirmar para amortecimento: φ_i^T C φ_j = 0 (se proporcional).",
                                    "Calcular matrizes de modal participation e verificar decoplamento.",
                                    "Aplicar a uma estrutura aeroespacial como uma asa flexível."
                                  ],
                                  "verification": "Matrizes de ortogonalidade resultam em matriz identidade ou zero off-diagonal.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código MATLAB/Python para multiplicação matricial, exemplos numéricos"
                                  ],
                                  "tips": "Use tolerâncias numéricas (1e-10) para verificações devido a erros de arredondamento.",
                                  "learningObjective": "Validar propriedades ortogonais dos modos para desacoplamento.",
                                  "commonMistakes": [
                                    "Confundir ortogonalidade em massa com rigidez, não considerar não-proporcionalidade."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Transformar para coordenadas modais e desacoplar equações",
                                  "subSteps": [
                                    "Definir transformação modal: {x} = [Φ]{q}, onde [Φ] contém os modos.",
                                    "Substituir nas equações originais para obter: [Φ]^T M [Φ] {q̈} + [Φ]^T C [Φ] {q̇} + [Φ]^T K [Φ] {q} = [Φ]^T {F}.",
                                    "Explorar ortogonalidade para simplificar em equações SDOF desacopladas.",
                                    "Identificar forças modais: Q_i(t) = φ_i^T F(t).",
                                    "Implementar numericamente para um sistema MDOF."
                                  ],
                                  "verification": "Equações resultantes são diagonalizadas (desacopladas) em coordenadas modais.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/Python para transformação modal, script de automação"
                                  ],
                                  "tips": "Mantenha [Φ] ortonormalizado para simplificar cálculos.",
                                  "learningObjective": "Decoplar equações MDOF usando coordenadas modais.",
                                  "commonMistakes": [
                                    "Erro na transposição modal, esquecer normalização na força modal."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Resolver respostas a excitações arbitrárias",
                                  "subSteps": [
                                    "Para cada modo i, resolver a equação SDOF: m_i q̈_i + c_i q̇_i + k_i q_i = Q_i(t).",
                                    "Usar Duhamel ou Laplace para respostas transitórias.",
                                    "Superpor respostas modais para obter {x}(t) = [Φ]{q}(t).",
                                    "Aplicar a excitação aeroespacial (ex: rajada de vento).",
                                    "Analisar contribuição modal dominante."
                                  ],
                                  "verification": "Resposta total reconstrói corretamente a solução física para casos conhecidos.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Ferramentas de integração numérica (ode45 MATLAB, solve_ivp Python)"
                                  ],
                                  "tips": "Filtre modos de alta frequência para aproximações eficientes.",
                                  "learningObjective": "Calcular respostas dinâmicas desacopladas a forças arbitrárias.",
                                  "commonMistakes": [
                                    "Não truncar modos irrelevantes, erro na superposição modal."
                                  ]
                                }
                              ],
                              "practicalExample": "Modelar uma asa simplificada de aeronave com 3 GDL (flexão, torção, alongamento), submetida a excitação aerodinâmica sinusoidal. Realize análise modal, desacople e compute resposta em coordenadas modais, comparando com solução acoplada.",
                              "finalVerifications": [
                                "Modos calculados são ortogonais em massa e rigidez.",
                                "Equações desacopladas resultam em SDOF independentes.",
                                "Forças modais Q_i(t) corretamente projetadas.",
                                "Resposta total {x}(t) coincide com solução direta para validação.",
                                "Contribuições modais identificadas corretamente em contexto aeroespacial.",
                                "Análise numérica converge sem erros significativos."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos autovalores e autovetores (erro <1%).",
                                "Correta verificação de ortogonalidade (off-diagonais <1e-8).",
                                "Desacoplamento completo das equações modais.",
                                "Cálculo preciso de respostas modais a excitações.",
                                "Interpretação física das contribuições modais.",
                                "Eficiência computacional em sistemas >3 GDL.",
                                "Aplicação contextualizada a problemas aeroespaciais."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Problemas de autovalores generalizados.",
                                "Controle de Sistemas: Decoplamento modal para controle ativo.",
                                "Programação Numérica: Implementação em MATLAB/Python.",
                                "Aeroelasticidade: Análise de flutter via modos.",
                                "Engenharia Computacional: Simulações FEM dinâmicas."
                              ],
                              "realWorldApplication": "Na certificação de aeronaves, análise modal decopla vibrações de asas e fuselagens sob cargas aerodinâmicas, prevendo flutter e fadiga em missões espaciais ou voo supersônico, otimizando design para segurança e performance."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.1.1.3.3",
                            "name": "Integrar com aeroelasticidade e amortecimento",
                            "description": "Incorporar amortecimento de Rayleigh e modelos aeroelásticos baseados em modos para placas e cascas, analisando estabilidade via Hamilton ou Lagrange.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Amortecimento Rayleigh e Modelos Modais para Placas e Cascas",
                                  "subSteps": [
                                    "Estudar a matriz de amortecimento de Rayleigh, definida como C = αM + βK, onde M é massa e K rigidez.",
                                    "Derivar funções modais para placas (ex: placa retangular com condições de contorno simply supported) usando separação de variáveis.",
                                    "Estender para cascas cilíndricas, considerando modos longitudinais e circunferenciais.",
                                    "Calcular frequências naturais e formas modais usando equações de Euler-Bernoulli ou Mindlin-Reissner.",
                                    "Verificar ortogonalidade das funções modais para redução modal."
                                  ],
                                  "verification": "Derivar corretamente as primeiras três formas modais e frequências para uma placa simply supported e confirmar ortogonalidade.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Livro de Dinâmica das Estruturas (ex: Chopra)",
                                    "Software MATLAB ou Python (SymPy para simbólico)",
                                    "Notas de aula sobre teoria de placas e cascas"
                                  ],
                                  "tips": "Comece com casos 1D (viga) para intuitar antes de 2D/3D.",
                                  "learningObjective": "Compreender como o amortecimento Rayleigh é incorporado em modelos modais discretos.",
                                  "commonMistakes": "Confundir coeficientes α e β com amortecimento viscoso geral; ignorar acoplamento modal em cascas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Incorporar Amortecimento em Formulações de Hamilton e Lagrange",
                                  "subSteps": [
                                    "Escrever o funcional de Lagrange para sistemas com múltiplos graus de liberdade: L = T - V, com T incluindo termos cinéticos modais.",
                                    "Adicionar dissipação via Princípio de Hamilton com termo de Rayleigh: δ∫(Ṫ + V̇ - R)dt = 0, onde R é função de Rayleigh.",
                                    "Derivar equações de movimento modais: M̈q̈ + Cq̇ + Kq = Q_aero, com C Rayleigh.",
                                    "Aplicar para placas: discritizar deslocamentos em termos modais w(x,y,t) = Σ φ_i(x,y) q_i(t).",
                                    "Verificar linearidade e simetria das matrizes M, C, K."
                                  ],
                                  "verification": "Obter equações de movimento desacopladas para 3 modos e confirmar que C é diagonal para modos ortogonais.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Referência: 'Vibration of Plates' de Leissa",
                                    "MATLAB para montagem matricial",
                                    "Papel e lápis para derivação simbólica"
                                  ],
                                  "tips": "Use coordenadas generalizadas q_i para reduzir dimensões rapidamente.",
                                  "learningObjective": "Formular equações dinâmicas com amortecimento usando princípios variacionais.",
                                  "commonMistakes": "Esquecer o termo de Rayleigh na variação de Hamilton; não normalizar modos adequadamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Desenvolver Modelos Aeroelásticos Baseados em Modos",
                                  "subSteps": [
                                    "Introduzir forças aerodinâmicas via teoria de Theodorsen ou pistão teórico para placas oscilantes.",
                                    "Montar matriz de aerodinâmica A(ω) dependente de frequência reduzida k = ωb/U.",
                                    "Acoplar aeroelástica: M̈q̈ + Cq̇ + (K + A(ω))q = 0.",
                                    "Estender para cascas: considerar torção e flexão acopladas em modos assimétricos.",
                                    "Implementar em código para varredura paramétrica de velocidade U."
                                  ],
                                  "verification": "Gerar matriz aerodinâmica para k=0.1-0.5 e acoplar com 2 modos estruturais.",
                                  "estimatedTime": "4-5 horas",
                                  "materials": [
                                    "'Principles of Aeroelasticity' de Bisplinghoff",
                                    "Código Python/MATLAB com funções de Theodorsen",
                                    "Gráficos de lift em oscilação"
                                  ],
                                  "tips": "Aproxime A(ω) como quasi-steady inicialmente para validação.",
                                  "learningObjective": "Integrar cargas aerodinâmicas em modelos modais com amortecimento.",
                                  "commonMistakes": "Negligir dependência de frequência em A; confundir cisalhamento com torção em cascas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Estabilidade via Método de V- g ou Raízes Complexas",
                                  "subSteps": [
                                    "Linearizar o autovalor problema: [ (K + A) - ω²M + iω g C ] φ = 0, com g fator de amortecimento.",
                                    "Usar método V-g para plotar fronteiras de flutter (V_f, g=0).",
                                    "Resolver numericamente autovalores complexos para diferentes velocidades dinâmicas V.",
                                    "Identificar divergência (ω real=0) e flutter (colapso de frequências reais).",
                                    "Avaliar efeito do amortecimento Rayleigh na elevação de V_f."
                                  ],
                                  "verification": "Plotar diagrama V-g mostrando flutter acima de V=100 m/s e confirmar estabilidade com α>0.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Software eigenvalue solver (MATLAB eig)",
                                    "Exemplo numérico de asa típica (NACA 0012)"
                                  ],
                                  "tips": "Itere g de 0 a 1 para convergência rápida no método V-g.",
                                  "learningObjective": "Avaliar estabilidade aeroelástica com amortecimento incluído.",
                                  "commonMistakes": "Interpretar erroneamente modos complexos; ignorar acoplamento modal em análise."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Aplicar o Modelo em um Caso Prático",
                                  "subSteps": [
                                    "Simular resposta transitória a pulso inicial com ode45 no MATLAB.",
                                    "Comparar com benchmarks sem amortecimento para quantificar damping ratio.",
                                    "Sensibilizar parâmetros α, β, U para otimização de estabilidade.",
                                    "Documentar relatório com gráficos de deslocamento modal vs tempo.",
                                    "Discutir limitações (ex: linearidade, compressibilidade)."
                                  ],
                                  "verification": "Resposta decai com ζ>0.05 e sem oscilações divergentes até V=90% V_f.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Código completo do modelo",
                                    "Ferramentas de plotagem (Matplotlib)"
                                  ],
                                  "tips": "Use solvers stiff se β alto causar rigidez.",
                                  "learningObjective": "Aplicar e validar o modelo integrado aeroelástico.",
                                  "commonMistakes": "Escala errada em plots; não normalizar respostas."
                                }
                              ],
                              "practicalExample": "Modelar uma placa retangular representando a pele de uma asa de aeronave (0.5m x 1m, fluxo Mach 0.3), incorporando 3 modos de flexão com Rayleigh (α=0.1, β=0.001), acoplar com Theodorsen C(k), e determinar velocidade de flutter em ~150 m/s via V-g.",
                              "finalVerifications": [
                                "Derivação correta das equações modais com Rayleigh via Lagrange/Hamilton.",
                                "Matriz aerodinâmica acoplada corretamente para 3 modos.",
                                "Diagrama V-g identifica V_f com precisão <5%.",
                                "Simulação transitória mostra decaimento estável abaixo V_f.",
                                "Efeito de α/β eleva V_f em pelo menos 10%.",
                                "Relatório discute estabilidade para cascas torcidas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação variacional (sem erros em matrizes M/C/K).",
                                "Correta implementação de aerodinâmica dependente de frequência.",
                                "Análise de estabilidade revela flutter/divergência com justificativa física.",
                                "Validação numérica contra teoria (erro <2% em frequências).",
                                "Otimização paramétrica demonstra insight em trade-offs.",
                                "Clareza na documentação e interpretação de resultados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de autovalores complexos e métodos iterativos (V-g).",
                                "Aerodinâmica: Teoria de thin airfoil e unsteady aerodynamics.",
                                "Controle: Projeto de dampers ativos baseados em estados modais.",
                                "Materiais: Efeitos viscoelásticos em compósitos aeroespaciais.",
                                "Computacional: Redução modal e solvers de autovalores em CFD."
                              ],
                              "realWorldApplication": "Projeto de asas de aeronaves comerciais (ex: Boeing 787) para prevenir flutter, otimizando dampers Rayleigh em painéis de compósito, elevando envelope de voo seguro e reduzindo fadiga estrutural em missões hipersônicas."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.5",
                    "name": "Exemplos de Sistemas com Um Grau de Liberdade",
                    "description": "Modelagem dinâmica de sistemas estruturais simples utilizando Lagrange e Hamilton sob excitações.",
                    "individualConcepts": [
                      {
                        "id": "57.1.1.5.1",
                        "name": "Modelagem Lagrangiana de Sistemas com Um Grau de Liberdade",
                        "description": "Formulação das equações de movimento para sistemas estruturais aeroespaciais simples com um único grau de liberdade utilizando o formalismo de Lagrange, incluindo cálculo do Lagrangiano a partir de energias cinética e potencial.",
                        "specificSkills": [
                          {
                            "id": "57.1.1.5.1.1",
                            "name": "Identificar coordenadas generalizadas e calcular energias cinética e potencial",
                            "description": "Selecionar coordenadas generalizadas adequadas para sistemas com um grau de liberdade, como deslocamento vertical de uma viga cantilever, e computar explicitamente a energia cinética T e potencial V em termos dessas coordenadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de coordenadas generalizadas",
                                  "subSteps": [
                                    "Revise a definição de coordenadas generalizadas como variáveis independentes que descrevem completamente a configuração de um sistema com n graus de liberdade.",
                                    "Estude exemplos simples: posição angular θ para pêndulo simples ou deslocamento x para massa-mola.",
                                    "Diferencie coordenadas generalizadas de coordenadas cartesianas, destacando sua flexibilidade para sistemas com restrições.",
                                    "Analise por que elas simplificam a formulação Lagrangiana.",
                                    "Resolva exercícios básicos de identificação em sistemas com 1 DOF."
                                  ],
                                  "verification": "Explique em suas palavras o que são coordenadas generalizadas e dê 3 exemplos de sistemas com 1 DOF.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Mecânica Clássica (Goldstein ou similar)",
                                    "Notas de aula sobre Lagrange",
                                    "Papel e caneta"
                                  ],
                                  "tips": "Comece com sistemas familiares para construir intuição.",
                                  "learningObjective": "Definir e exemplificar coordenadas generalizadas para sistemas com 1 grau de liberdade.",
                                  "commonMistakes": "Confundir com coordenadas de inércia ou ignorar restrições holonômicas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o sistema físico e seus graus de liberdade",
                                  "subSteps": [
                                    "Desenhe o diagrama esquemático da viga cantilever: comprimento L, fixada em x=0, livre em x=L.",
                                    "Identifique os graus de liberdade: para modelo simplificado, 1 DOF como deslocamento vertical w(x,t), mas generalize para w(L,t).",
                                    "Liste restrições: fixação em x=0 (w=0, ∂w/∂x=0).",
                                    "Calcule a massa total M = μL, onde μ é massa linear.",
                                    "Discuta aproximações: viga Euler-Bernoulli para flexão."
                                  ],
                                  "verification": "Desenhe e descreva o sistema com suas restrições e DOF.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Diagrama da viga cantilever impresso",
                                    "Software de desenho como Draw.io",
                                    "Referência: Teoria de Vigas"
                                  ],
                                  "tips": "Use coordenadas locais do sistema para simplificar.",
                                  "learningObjective": "Modelar geometricamente sistemas estruturais com 1 DOF.",
                                  "commonMistakes": "Contar DOF incorretamente, ignorando modos de torção ou cisalhamento."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Selecionar coordenada generalizada adequada",
                                  "subSteps": [
                                    "Escolha q = w(L,t), o deslocamento vertical na ponta livre.",
                                    "Justifique: descreve completamente a configuração cinemática assumindo forma modal (primeiro modo).",
                                    "Expresse posição de pontos genéricos: para ponto em x, y(x,t) ≈ [x/L * q(t)] (forma linear aproximada).",
                                    "Verifique independência: q varia livremente sem violar restrições.",
                                    "Compare com outras escolhas: q = ∂w/∂x em L (rotação)."
                                  ],
                                  "verification": "Escreva q para a viga e expresse velocidades em termos de ḣ.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Calculadora simbólica como SymPy ou Mathematica",
                                    "Papel milimetrado"
                                  ],
                                  "tips": "Priorize coordenadas que minimizem complexidade em T e V.",
                                  "learningObjective": "Selecionar q ótima para sistemas contínuos discretizados.",
                                  "commonMistakes": "Escolher q que não capture o movimento dominante."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular a energia cinética T em termos de q e ḟ",
                                  "subSteps": [
                                    "Expresse velocidade vertical de elemento dx em x: v(x,t) = ∂y/∂t ≈ (x/L) ḟ(t).",
                                    "Integre T = (1/2) ∫₀ᴸ μ [v(x,t)]² dx = (1/2) μ ḟ² ∫₀ᴸ (x/L)² dx = (1/2) (μL/3) ḟ².",
                                    "Generalize para forma modal: φ(x) = x/L, T = (1/2) M_eff ḟ² com M_eff = ∫ μ φ² dx.",
                                    "Verifique unidades: T em Joules.",
                                    "Teste com caso limite: viga rígida."
                                  ],
                                  "verification": "Derive e simplifique a expressão exata de T(q, ḟ).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "SymPy para integração simbólica",
                                    "Tabela de integrais"
                                  ],
                                  "tips": "Use funções de forma para precisão.",
                                  "learningObjective": "Computar T via integração sobre o domínio contínuo.",
                                  "commonMistakes": "Esquecer o fator 1/2 ou limites de integração errados."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Calcular a energia potencial V em termos de q",
                                  "subSteps": [
                                    "Expresse curvatura κ ≈ ∂²w/∂x²; para y(x) = (x²/2L) q, κ(x) = q/L.",
                                    "V = (1/2) ∫₀ᴸ EI κ² dx, com EI rigidez flexural.",
                                    "Simplifique: V = (1/2) EI (q² / L³) ∫₀ᴸ x² dx wait, derive corretamente: para forma φ(x)=x/L, κ=φ'' q mas φ''=0? Use forma quadrática.",
                                    "Correto: assuma w(x,t)=(x²/(2L))q para curvatura const: ∂²w/∂x² = q/L, V=(1/2)EI ∫ (q/L)² dx = (1/2) k_eff q² com k_eff=EI/L³ * L/3.",
                                    "Verifique linearidade em pequenas deformações."
                                  ],
                                  "verification": "Escreva V(q) e confirme que é quadrática.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Teoria de vigas Euler-Bernoulli",
                                    "SymPy"
                                  ],
                                  "tips": "Garanta consistência na forma assumida para w(x,q).",
                                  "learningObjective": "Computar V elástica para deformações.",
                                  "commonMistakes": "Usar forma linear para w levando a κ=0."
                                }
                              ],
                              "practicalExample": "Para uma viga cantilever de L=1m, μ=1kg/m, EI=1000 Nm², q=w(L,t): T = (1/2)(1/3) ḗ² ≈ 0.167 ḗ² J; V ≈ (1/2)(EI/(3L³)) q² = (1/2)(1000/(3)) q² ≈ 166.7 q² J. Use para equação de Lagrange: d/dt(∂L/∂ḗ) - ∂L/∂q=0.",
                              "finalVerifications": [
                                "Identifique q corretamente para pêndulo duplo simplificado.",
                                "Compute T e V para massa-mola vertical.",
                                "Verifique T quadrática em ḗ e V em q.",
                                "Aplique a uma corda vibrante.",
                                "Confirme conservação de energia T+V=const para sistema livre.",
                                "Explique escolha de q em termos de modo fundamental."
                              ],
                              "assessmentCriteria": [
                                "Precisão na seleção de q (captura DOF essencial).",
                                "Correção matemática em derivações de T e V (integrações exatas).",
                                "Consistência entre forma cinemática e energias.",
                                "Unidades corretas e aproximações justificadas.",
                                "Capacidade de generalizar para outros sistemas.",
                                "Clareza na documentação passo a passo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e integrais definidas.",
                                "Física: Princípios de conservação de energia em mecânica clássica.",
                                "Engenharia: Análise modal em estruturas aeroespaciais.",
                                "Computação: Implementação numérica em MATLAB/SymPy para simulações.",
                                "Filosofia da Ciência: Minimalismo em descrição de sistemas físicos."
                              ],
                              "realWorldApplication": "Em aeroelasticidade, modela flutter de asas de aeronaves usando coordenadas generalizadas para modos de flexão/torção, prevendo instabilidades dinâmicas e otimizando designs de aviões como o Boeing 787."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.1.1.5.1.2",
                            "name": "Derivar equações de movimento via equações de Lagrange",
                            "description": "Aplicar a equação d/dt (∂L/∂q̇) - ∂L/∂q = Q para obter a equação diferencial de segunda ordem do movimento, considerando forças generalizadas Q para excitações externas em estruturas aeroespaciais simples.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o sistema físico e coordenadas generalizadas",
                                  "subSteps": [
                                    "Identifique o sistema com um grau de liberdade, como uma estrutura aeroespacial simples (ex: painel oscilante ou viga cantilever).",
                                    "Escolha a coordenada generalizada q (ex: deslocamento angular θ ou linear x).",
                                    "Descreva as restrições cinemáticas e forças externas Q.",
                                    "Esboce o diagrama do sistema com posições e velocidades.",
                                    "Defina velocidades generalizadas q̇ em termos de q."
                                  ],
                                  "verification": "Confirme que q captura todo o movimento relevante e que Q representa excitações externas (ex: aerodinâmicas).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis para esboços",
                                    "Referência: Livro de Dinâmica (ex: Greenwood ou Meirovitch)"
                                  ],
                                  "tips": "Comece com sistemas conservativos (Q=0) para validar antes de adicionar forças.",
                                  "learningObjective": "Selecionar coordenadas generalizadas adequadas para modelagem Lagrangiana de estruturas aeroespaciais.",
                                  "commonMistakes": [
                                    "Escolher coordenadas redundantes",
                                    "Ignorar restrições holonômicas",
                                    "Confundir q com componentes cartesianas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular o Lagrangiano L = T - V",
                                  "subSteps": [
                                    "Expresse a energia cinética T em termos de q e q̇ (ex: T = (1/2) m (dq/dt)^2 para massa simples).",
                                    "Expresse a energia potencial V em termos de q (ex: V = (1/2) k q^2 para mola).",
                                    "Subtraia: L = T - V.",
                                    "Verifique unidades: L deve ter unidades de energia (Joules).",
                                    "Considere termos não conservativos se aplicável, mas reserve para Q."
                                  ],
                                  "verification": "Calcule L para um caso conhecido (ex: pêndulo simples) e compare com literatura.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora simbólica (ex: SymPy online ou MATLAB Symbolic Toolbox)",
                                    "Notas de aula sobre energias em mecânica do voo"
                                  ],
                                  "tips": "Use aproximações pequenas para linearizar V em estruturas aeroespaciais (ex: teoria de vigas de Euler-Bernoulli).",
                                  "learningObjective": "Construir corretamente o Lagrangiano para sistemas com um DOF em contextos aeroespaciais.",
                                  "commonMistakes": [
                                    "Inverter T e V",
                                    "Esquecer fatores de 1/2 em energias quadráticas",
                                    "Incluir q̇ em V"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular derivadas parciais e aplicar equação de Lagrange",
                                  "subSteps": [
                                    "Compute ∂L/∂q̇ (geralmente momentum generalizado p = m q̇).",
                                    "Calcule d/dt(∂L/∂q̇) (ex: m q̈ para sistemas lineares).",
                                    "Compute ∂L/∂q (negativo do torque potencial).",
                                    "Aplique: d/dt(∂L/∂q̇) - ∂L/∂q = Q.",
                                    "Simplifique para EDO: ex: m q̈ + k q = Q(t)."
                                  ],
                                  "verification": "Para Q=0, verifique se obtém frequências naturais corretas (ω = sqrt(k/m)).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de álgebra simbólica",
                                    "Exemplos resolvidos de aeroelasticidade"
                                  ],
                                  "tips": "Mantenha derivadas simbólicas até o final para evitar erros numéricos.",
                                  "learningObjective": "Executar as derivadas da equação de Lagrange com precisão para obter EDOs de movimento.",
                                  "commonMistakes": [
                                    "Erros na regra da cadeia para d/dt(∂L/∂q̇)",
                                    "Confundir ∂L/∂q com ∂L/∂q̇",
                                    "Esquecer sinal em -∂L/∂q"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Incorporar forças generalizadas Q e validar a equação",
                                  "subSteps": [
                                    "Defina Q como forças não conservativas (ex: Q = F_aero(t) para cargas aerodinâmicas).",
                                    "Substitua na EDO e resolva para forma padrão (q̈ + 2ζω q̇ + ω² q = Q/m).",
                                    "Verifique linearidade e condições iniciais.",
                                    "Compare com método de Newton-Euler para o mesmo sistema.",
                                    "Simule numericamente para validar (ex: plot de resposta transitória)."
                                  ],
                                  "verification": "A EDO deve reproduzir movimento livre correto e resposta forçada esperada.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB ou Python (SciPy odeint)",
                                    "Dados de perfis aerodinâmicos simples"
                                  ],
                                  "tips": "Use Q harmônico para testar ressonância em contextos de flutter.",
                                  "learningObjective": "Integrar excitações externas e validar equações derivadas em aplicações aeroespaciais.",
                                  "commonMistakes": [
                                    "Definir Q incorretamente (deve ser potência virtual)",
                                    "Não normalizar a EDO",
                                    "Ignorar amortecimento viscoso"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um painel aeroespacial simples modelado como massa-mola (m=1 kg, k=100 N/m), com deslocamento q=x e forçamento aerodinâmico Q=0.1 sin(ωt) N: L = (1/2)m ẋ² - (1/2)k x² → equação: ẍ + 100x = 0.1 sin(ωt), simulada em Python para prever vibrações induzidas por fluxo.",
                              "finalVerifications": [
                                "Derive corretamente L para um novo sistema com 1 DOF.",
                                "Aplique equação de Lagrange e obtenha EDO idêntica a Newton para caso sem Q.",
                                "Inclua Q e identifique coeficientes de massa, amortecimento e rigidez.",
                                "Simule e plote resposta, confirmando estabilidade.",
                                "Explique physicalmente cada termo na EDO.",
                                "Compare com Princípio de Hamilton para o mesmo sistema."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas derivadas parciais (sem erros algébricos).",
                                "Correta identificação de q e Q no contexto aeroespacial.",
                                "EDO em forma padrão com interpretação física.",
                                "Validação via comparação ou simulação numérica.",
                                "Clareza na documentação de passos e verificações.",
                                "Aplicação a exemplo realista (ex: flutter de painel)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e EDOs lineares.",
                                "Programação: Simulação numérica em Python/MATLAB para solução de EDOs.",
                                "Engenharia Aeronáutica: Modelagem de aeroelasticidade e flutter.",
                                "Física: Princípios de conservação de energia em sistemas discretos.",
                                "Controle: Uso da EDO para design de controladores ativos."
                              ],
                              "realWorldApplication": "Em design de asas de aeronaves, deriva equações de Lagrange para modelar modos de flutter em painéis, prevendo instabilidades dinâmicas sob fluxo aerodinâmico e evitando falhas catastróficas como no caso histórico do Tacoma Narrows (adaptado a aeroespacial)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.1.1.5.1.3",
                            "name": "Resolver equações para condições iniciais livres",
                            "description": "Resolver analiticamente a equação de Lagrange para vibração livre, determinando frequência natural ω_n, condições iniciais de deslocamento e velocidade, e plotar a resposta temporal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular a Equação de Lagrange para Vibração Livre",
                                  "subSteps": [
                                    "Identifique as coordenadas generalizadas (ex: deslocamento x).",
                                    "Calcule a energia cinética T = (1/2) m ᴖ̇².",
                                    "Calcule a energia potencial V = (1/2) k x².",
                                    "Escreva a equação de Lagrange: d/dt (∂L/∂ᴖ̇) - ∂L/∂x = 0, onde L = T - V.",
                                    "Simplifique para obter m ᴖ̇̇ + k x = 0."
                                  ],
                                  "verification": "Verifique se a equação resultante é m ᴖ̇̇ + k x = 0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Parâmetros do sistema: m, k"
                                  ],
                                  "tips": "Sempre confirme que não há forças externas para vibração livre.",
                                  "learningObjective": "Entender a derivação da EDO a partir do formalismo Lagrangiano.",
                                  "commonMistakes": "Esquecer o sinal negativo em L = T - V ou confundir ∂L/∂x com ∂L/∂ᴖ̇."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar a Frequência Natural ω_n",
                                  "subSteps": [
                                    "Reescreva a EDO na forma padrão: ᴖ̇̇ + ω_n² x = 0.",
                                    "Identifique ω_n = √(k/m).",
                                    "Calcule numericamente ω_n para valores dados de m e k.",
                                    "Expresse o período T_n = 2π / ω_n.",
                                    "Verifique unidades: ω_n em rad/s."
                                  ],
                                  "verification": "Confirme ω_n² = k/m e calcule valor numérico correto.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Valores de m e k"
                                  ],
                                  "tips": "Use √(k/m) diretamente para evitar erros de simplificação.",
                                  "learningObjective": "Calcular e interpretar a frequência natural de sistemas oscilatórios.",
                                  "commonMistakes": "Confundir ω_n com f_n (frequência em Hz) ou inverter k e m."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Obter a Solução Geral da Equação Diferencial",
                                  "subSteps": [
                                    "Assuma solução x(t) = A cos(ω_n t) + B sen(ω_n t).",
                                    "Derive ᴖ̇(t) = -A ω_n sen(ω_n t) + B ω_n cos(ω_n t).",
                                    "Substitua na EDO e confirme que satisfaz.",
                                    "Alternativamente, use forma x(t) = C cos(ω_n t + φ), mas prefira A e B para condições iniciais.",
                                    "Anote a solução geral."
                                  ],
                                  "verification": "Derivadas devem satisfazer a EDO original.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tabela de soluções de EDOs"
                                  ],
                                  "tips": "Memorize a solução padrão para segunda ordem linear homogênea.",
                                  "learningObjective": "Resolver analiticamente EDOs de vibração livre.",
                                  "commonMistakes": "Usar ω em vez de ω_n ou esquecer fatores de amortecimento (não aplicável aqui)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Condições Iniciais e Plotar Resposta",
                                  "subSteps": [
                                    "Aplique x(0) = x_0 para encontrar A = x_0.",
                                    "Aplique ᴖ̇(0) = v_0 para encontrar B = v_0 / ω_n.",
                                    "Escreva x(t) = x_0 cos(ω_n t) + (v_0 / ω_n) sen(ω_n t).",
                                    "Plote x(t) vs t para t de 0 a 3 períodos usando software.",
                                    "Analise amplitude e fase."
                                  ],
                                  "verification": "x(0) = x_0 e ᴖ̇(0) = v_0 devem ser satisfeitos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de plotagem (MATLAB, Python/Matplotlib, Desmos)",
                                    "Valores x_0, v_0"
                                  ],
                                  "tips": "Normalize sen e cos se necessário para visualização.",
                                  "learningObjective": "Aplicar condições iniciais e visualizar resposta temporal.",
                                  "commonMistakes": "Esquecer dividir v_0 por ω_n ou plotar com ω errada."
                                }
                              ],
                              "practicalExample": "Para um sistema massa-mola com m=1 kg, k=100 N/m, x(0)=0.1 m, v(0)=0.2 m/s: ω_n=10 rad/s, x(t)=0.1 cos(10t) + 0.02 sen(10t). Plote mostrando oscilação com amplitude ~0.102 m.",
                              "finalVerifications": [
                                "Equação de Lagrange correta: m ᴖ̇̇ + k x = 0.",
                                "ω_n calculado precisamente como √(k/m).",
                                "Condições iniciais satisfeitas na solução x(t).",
                                "Gráfico de x(t) mostra oscilação com período correto T_n=2π/ω_n.",
                                "Derivada ᴖ̇(t) bate com v_0 em t=0.",
                                "Nenhuma força externa ou amortecimento incluída."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação Lagrangiana (100% correção).",
                                "Cálculo exato de ω_n e constantes A, B.",
                                "Solução geral e particular corretas.",
                                "Gráfico claro com eixos rotulados e escala adequada.",
                                "Interpretação física da resposta (amplitude, frequência).",
                                "Ausência de erros algébricos em condições iniciais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Solução de EDOs lineares homogêneas.",
                                "Física: Conservação de energia em osciladores harmônicos.",
                                "Programação: Uso de Python/MATLAB para plotagem numérica.",
                                "Engenharia: Análise modal em estruturas aeroespaciais."
                              ],
                              "realWorldApplication": "Em aeronáutica, modela vibrações livres de asas ou fuselagem durante flutter, permitindo prever frequências naturais para evitar ressonância com turbulências e garantir estabilidade estrutural em voo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "57.1.1.5.2",
                        "name": "Modelagem Hamiltoniana de Sistemas com Um Grau de Liberdade",
                        "description": "Formulação alternativa das equações de movimento utilizando o princípio de Hamilton, definindo o Hamiltoniano e as equações canônicas para sistemas estruturais com um grau de liberdade.",
                        "specificSkills": [
                          {
                            "id": "57.1.1.5.2.1",
                            "name": "Construir o Hamiltoniano a partir do Lagrangiano",
                            "description": "Calcular o momento conjugado p = ∂L/∂q̇ e o Hamiltoniano H = p q̇ - L, expressando-o em termos de q e p para um sistema massa-mola-amortecedor representativo de estruturas aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o sistema e derivar o Lagrangiano",
                                  "subSteps": [
                                    "Descreva o sistema massa-mola-amortecedor: uma massa m conectada a uma mola de constante k e amortecedor de coeficiente c, com deslocamento q = x.",
                                    "Escreva a energia cinética T = (1/2) m \\dot{q}^2.",
                                    "Escreva a energia potencial V = (1/2) k q^2 (nota: o amortecedor é dissipativo e não entra no potencial).",
                                    "Calcule o Lagrangiano L = T - V = (1/2) m \\dot{q}^2 - (1/2) k q^2.",
                                    "Verifique que L depende de q e \\dot{q} corretamente."
                                  ],
                                  "verification": "Confirme que L = \\frac{1}{2} m \\dot{q}^2 - \\frac{1}{2} k q^2 está escrito sem termos de amortecimento no L.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Diagrama do sistema massa-mola-amortecedor"
                                  ],
                                  "tips": "Lembre-se: apenas forças conservativas entram no Lagrangiano; o amortecedor será tratado nas equações de movimento.",
                                  "learningObjective": "Compreender a composição do Lagrangiano para sistemas com um grau de liberdade.",
                                  "commonMistakes": "Incluir o termo de amortecimento -c \\dot{q} diretamente no Lagrangiano (isso é incorreto para a formulação padrão)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o momento conjugado p",
                                  "subSteps": [
                                    "Lembre a definição: p = \\frac{\\partial L}{\\partial \\dot{q}}.",
                                    "Diferencie L em relação a \\dot{q}: \\frac{\\partial L}{\\partial \\dot{q}} = m \\dot{q}.",
                                    "Atribua p = m \\dot{q}.",
                                    "Expresse \\dot{q} em termos de p: \\dot{q} = \\frac{p}{m} (para uso posterior).",
                                    "Verifique dimensionalmente: p tem unidades de momento (kg m^2 / s)."
                                  ],
                                  "verification": "Verifique se p = m \\dot{q} foi derivado corretamente da derivada parcial.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora para verificação numérica opcional"
                                  ],
                                  "tips": "Use derivada parcial: trate q como constante ao derivar em \\dot{q}.",
                                  "learningObjective": "Dominar o cálculo do momento conjugado a partir do Lagrangiano.",
                                  "commonMistakes": "Confundir com momento linear p = m v sem contexto generalizado ou esquecer a derivada parcial."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formar a expressão inicial do Hamiltoniano H = p \\dot{q} - L",
                                  "subSteps": [
                                    "Escreva a definição: H = p \\dot{q} - L.",
                                    "Substitua L: H = p \\dot{q} - \\left( \\frac{1}{2} m \\dot{q}^2 - \\frac{1}{2} k q^2 \\right).",
                                    "Substitua p = m \\dot{q}: p \\dot{q} = m \\dot{q}^2, então H = m \\dot{q}^2 - \\frac{1}{2} m \\dot{q}^2 + \\frac{1}{2} k q^2 = \\frac{1}{2} m \\dot{q}^2 + \\frac{1}{2} k q^2.",
                                    "Reconheça que isso é a energia total T + V.",
                                    "Mantenha em termos mistos por enquanto."
                                  ],
                                  "verification": "Confirme que H = \\frac{p^2}{2m} + \\frac{1}{2} k q^2 após simplificação parcial (mas ainda pode ter \\dot{q}).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software simbólico como SymPy para verificação"
                                  ],
                                  "tips": "Simplifique algébricamente passo a passo para evitar erros de sinal.",
                                  "learningObjective": "Entender a transição Legendre do Lagrangiano para o Hamiltoniano.",
                                  "commonMistakes": "Erro de sinal em H = p \\dot{q} - L (lembre: menos L)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Expressar o Hamiltoniano em coordenadas canônicas (q, p)",
                                  "subSteps": [
                                    "Substitua \\dot{q} = \\frac{p}{m} na expressão de H.",
                                    "T = \\frac{1}{2} m \\left( \\frac{p}{m} \\right)^2 = \\frac{p^2}{2m}.",
                                    "V permanece \\frac{1}{2} k q^2.",
                                    "Assim, H(q, p) = \\frac{p^2}{2m} + \\frac{1}{2} k q^2.",
                                    "Verifique independência de \\dot{q}."
                                  ],
                                  "verification": "H final deve ser função apenas de q e p: H = \\frac{p^2}{2m} + \\frac{1}{2} k q^2.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis"
                                  ],
                                  "tips": "A Hamiltoniana é a energia total expressa em momentos conjugados.",
                                  "learningObjective": "Transformar H para forma canônica, pronta para equações de Hamilton.",
                                  "commonMistakes": "Esquecer de quadrado em (p/m)^2 ou inverter m no denominador."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar as equações de Hamilton e contexto dissipativo",
                                  "subSteps": [
                                    "Calcule \\dot{q} = \\frac{\\partial H}{\\partial p} = \\frac{p}{m}.",
                                    "Calcule \\dot{p} = -\\frac{\\partial H}{\\partial q} = -k q.",
                                    "Confirme que reproduz as EOMs: m \\ddot{q} + k q = 0 (parte conservativa).",
                                    "Nota sobre amortecedor: adicione termo dissipativo na equação de \\dot{p}: \\dot{p} = -k q - c \\dot{q}.",
                                    "Compare com Lagrange para consistência."
                                  ],
                                  "verification": "Equações de Hamilton coincidem com derivadas do H e EOMs originais (sem damping no H).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Referência às equações de Lagrange"
                                  ],
                                  "tips": "As verificações confirmam a transformação correta.",
                                  "learningObjective": "Validar a formulação Hamiltoniana e sua relação com damping em aeroespaciais.",
                                  "commonMistakes": "Negar o sinal em \\dot{p} = -\\partial H / \\partial q."
                                }
                              ],
                              "practicalExample": "Para m=10 kg, k=100 N/m, c=2 Ns/m: L = 5 \\dot{x}^2 - 50 x^2. Então p = 10 \\dot{x}, \\dot{x} = p/10, H = (p)(p/10) - L = p^2/10 - 5 (p/10)^2 + 50 x^2 = p^2/20 + 50 x^2. Verificação: \\partial H / \\partial p = p/10 = \\dot{x}, \\partial H / \\partial x = 100 x (então \\dot{p} = -100 x).",
                              "finalVerifications": [
                                "H é expresso apenas em q e p, sem \\dot{q}?",
                                "\\partial H / \\partial p = \\dot{q} = p/m correto?",
                                "H = T + V na forma canônica?",
                                "Equações de Hamilton reproduzem EOMs conservativas m \\ddot{q} + k q = 0?",
                                "Dimensionalmente consistente (energia: Joules)?",
                                "Independente do tempo explicitamente?"
                              ],
                              "assessmentCriteria": [
                                "Correção na derivada de p = \\partial L / \\partial \\dot{q} (sem erros algébricos).",
                                "Expressão precisa de H = p \\dot{q} - L com simplificação correta.",
                                "Substituição adequada de \\dot{q} = p/m sem inversões.",
                                "Verificações finais mostram consistência com EOMs.",
                                "Clareza na distinção entre parte conservativa e dissipativa."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Derivadas parciais e transformações de Legendre.",
                                "Física Clássica: Formulação variacional e conservação de energia.",
                                "Engenharia de Controle: Linearização Hamiltoniana para análise de estabilidade.",
                                "Computação Científica: Simulação de dinâmica via integração numérica de equações de Hamilton (ex: Python com SciPy).",
                                "Engenharia Aeroespacial: Modelagem de vibrações estruturais."
                              ],
                              "realWorldApplication": "Na dinâmica de estruturas aeroespaciais, a formulação Hamiltoniana modela vibrações em asas e fuselagens (ex: análise de flutter aeroelástico), onde H descreve a energia conservativa de massa-mola, e termos de damping/airload são adicionados para prever instabilidades críticas em aeronaves."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.1.1.5.2.2",
                            "name": "Aplicar equações canônicas de Hamilton",
                            "description": "Derivar dq/dt = ∂H/∂p e dp/dt = -∂H/∂q, verificando equivalência com as equações de Lagrange e resolvendo para movimento livre ou forçado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e derivar as equações canônicas de Hamilton",
                                  "subSteps": [
                                    "Revise o Lagrangiano L = T - V, onde T é energia cinética e V é potencial.",
                                    "Introduza a transformação de Legendre para momentum canônico p = ∂L/∂(dq/dt).",
                                    "Defina o Hamiltoniano H(q, p) = p*(dq/dt) - L.",
                                    "Derive dq/dt = ∂H/∂p e dp/dt = -∂H/∂q usando princípios variacionais.",
                                    "Escreva as equações em forma matricial para clareza."
                                  ],
                                  "verification": "Confirme que as derivações batem com fórmulas padrão em um livro-texto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Mecânica Clássica (Goldstein ou similar)",
                                    "Papel e lápis",
                                    "Calculadora simbólica (Wolfram Alpha)"
                                  ],
                                  "tips": "Use notação clara para coordenadas generalizadas q e p; visualize geometricamente no espaço de fase.",
                                  "learningObjective": "Compreender a origem das equações canônicas a partir do princípio Hamiltoniano.",
                                  "commonMistakes": [
                                    "Confundir p com velocidade diretamente",
                                    "Esquecer o sinal negativo em dp/dt",
                                    "Não expressar dq/dt em termos de H"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o Hamiltoniano para um sistema com um grau de liberdade",
                                  "subSteps": [
                                    "Escolha um sistema simples, como massa-mola: T = (1/2)m (dq/dt)^2, V = (1/2)k q^2.",
                                    "Calcule p = ∂L/∂(dq/dt) = m (dq/dt).",
                                    "Expresse dq/dt = p/m e substitua em H = p*(dq/dt) - L para obter H = p^2/(2m) + (1/2)k q^2.",
                                    "Verifique que H é conservado (dH/dt = 0).",
                                    "Repita para movimento livre (k=0)."
                                  ],
                                  "verification": "H deve ser função apenas de q e p, sem velocidades explícitas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de exercícios",
                                    "Software simbólico como SymPy ou Mathematica"
                                  ],
                                  "tips": "Sempre verifique dimensionalidade: H tem unidades de energia.",
                                  "learningObjective": "Construir H corretamente para sistemas conservativos com 1 DoF.",
                                  "commonMistakes": [
                                    "Erro no cálculo de p",
                                    "Não inverter corretamente dq/dt em termos de p",
                                    "Incluir termos dependentes de tempo prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar equações canônicas e resolver para movimento livre",
                                  "subSteps": [
                                    "Para movimento livre: dq/dt = ∂H/∂p = p/m, dp/dt = -∂H/∂q = 0.",
                                    "Integre: p = constante, q(t) = q0 + (p/m)t.",
                                    "Compare com solução Lagrangiana: d²q/dt² = 0.",
                                    "Plote trajetórias no espaço de fase (q vs p): retas.",
                                    "Simule numericamente para validar."
                                  ],
                                  "verification": "Solução deve coincidir com movimento uniforme retilíneo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "MATLAB ou Python (SciPy odeint)",
                                    "Gráficos de espaço de fase"
                                  ],
                                  "tips": "Use condições iniciais variadas para testar robustez.",
                                  "learningObjective": "Resolver EDOs Hamiltonianas para casos simples e visualizar fase space.",
                                  "commonMistakes": [
                                    "Invertar sinais das equações",
                                    "Não reconhecer p constante",
                                    "Ignorar condições iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar equivalência com Lagrange e estender a movimento forçado",
                                  "subSteps": [
                                    "Para oscilador harmônico: dq/dt = p/m, dp/dt = -k q; mostre d²q/dt² + (k/m)q = 0 (equação Lagrange).",
                                    "Introduza força externa: modifique V ou adicione termo em dp/dt = -∂H/∂q + Q.",
                                    "Resolva numericamente para forçamento senoidal.",
                                    "Compare soluções Lagrange e Hamilton para precisão numérica.",
                                    "Analise estabilidade no espaço de fase."
                                  ],
                                  "verification": "Equações de segunda ordem derivadas devem coincidir exatamente.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Python/MATLAB para simulação",
                                    "Referência de equações de Lagrange"
                                  ],
                                  "tips": "Para forçado, use H não-autônomo se Q explícito.",
                                  "learningObjective": "Demonstrar equivalência e aplicar a sistemas dissipativos/forçados.",
                                  "commonMistakes": [
                                    "Não derivar segunda ordem corretamente",
                                    "Confundir forças generalizadas Q",
                                    "Erros em integração numérica"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar a contexto aeroespacial e sintetizar",
                                  "subSteps": [
                                    "Modele vibração de uma viga como sistema 1 DoF aproximado.",
                                    "Derive H para flutter inicial ou aeroelasticidade simples.",
                                    "Simule resposta forçada por vento.",
                                    "Compare com dados experimentais ou literatura.",
                                    "Documente relatório com gráficos."
                                  ],
                                  "verification": "Soluções estáveis/instáveis condizem com teoria aeroelástica.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Artigos sobre aeroelasticidade",
                                    "Software FEM básico como ANSYS Student"
                                  ],
                                  "tips": "Comece com modelo linearizado para simplicidade.",
                                  "learningObjective": "Integrar Hamiltoniano em problemas reais de dinâmica aeroespacial.",
                                  "commonMistakes": [
                                    "Sobrestimar DoF em modelos reais",
                                    "Ignorar acoplamentos não-lineares",
                                    "Falta de validação"
                                  ]
                                }
                              ],
                              "practicalExample": "Modelagem Hamiltoniana de um oscilador harmônico representando a flexão de uma asa de aeronave: derive H = p^2/(2m) + (1/2) k q^2, aplique equações para prever frequências de flutter sob forçamento aerodinâmico senoidal, simulando em Python para visualizar elipses no espaço de fase e prever instabilidades.",
                              "finalVerifications": [
                                "Equações dq/dt = ∂H/∂p e dp/dt = -∂H/∂q derivadas corretamente.",
                                "Hamiltoniano H conservado para sistemas sem dissipação.",
                                "Soluções coincidem com equações de Lagrange de segunda ordem.",
                                "Simulações numéricas produzem trajetórias coerentes no espaço de fase.",
                                "Aplicação a movimento forçado inclui forças generalizadas Q adequadamente.",
                                "Relatório inclui gráficos e comparações quantitativas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de H (100% correto).",
                                "Correta aplicação e integração das EDOs Hamiltonianas.",
                                "Equivalência demonstrada com Lagrange via derivação analítica.",
                                "Qualidade das simulações numéricas e visualizações.",
                                "Relevância ao contexto aeroespacial com exemplo prático.",
                                "Clareza no relatório, evitando erros comuns listados."
                              ],
                              "crossCurricularConnections": [
                                "Física Quântica: Mecânica Hamiltoniana como base para o formalismo quântico.",
                                "Controle de Sistemas: Espaço de fase para análise de estabilidade em controle ótimo.",
                                "Programação Numérica: Integração de EDOs com SciPy/MATLAB.",
                                "Engenharia Aeroespacial: Modelagem de aeroelasticidade e flutter.",
                                "Matemática Computacional: Transformadas de Legendre e simulações."
                              ],
                              "realWorldApplication": "Em engenharia aeroespacial, as equações de Hamilton são usadas para simular dinâmica de estruturas flexíveis como asas de aviões, prevendo instabilidades de flutter durante o design de aeronaves, otimizando controle ativo via análise de espaço de fase em softwares como NASTRAN ou simulações de voo em tempo real."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "57.1.1.5.1"
                            ]
                          },
                          {
                            "id": "57.1.1.5.2.3",
                            "name": "Comparar formulações Lagrange e Hamilton",
                            "description": "Analisar vantagens da formulação Hamiltoniana para sistemas conservativos em contextos aeroespaciais, como simulações numéricas de vibrações estruturais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos das Formulações Lagrangeana e Hamiltoniana",
                                  "subSteps": [
                                    "Estude a formulação Lagrangeana: L = T - V, onde equações são d/dt(∂L/∂q̇) - ∂L/∂q = 0.",
                                    "Estude a formulação Hamiltoniana: H = T + V, com equações q̇ = ∂H/∂p e ṗ = -∂H/∂q.",
                                    "Identifique diferenças chave: Lagrange usa coordenadas generalizadas q e velocidades q̇; Hamilton usa q e momentos conjugados p.",
                                    "Revise transformação de Legendre para passar de Lagrange para Hamilton.",
                                    "Liste propriedades para sistemas conservativos: energia conservada em ambas."
                                  ],
                                  "verification": "Resuma em um quadro comparativo as diferenças entre L e H, incluindo variáveis e estrutura das EDOs.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Livro de Mecânica Clássica (Goldstein), notas de aula, SymPy ou MATLAB para exemplos simbólicos.",
                                  "tips": "Use diagramas de fase para visualizar Hamiltoniana como mais simétrica.",
                                  "learningObjective": "Compreender as bases matemáticas e diferenças conceituais das duas formulações.",
                                  "commonMistakes": "Confundir momentos p com quantidades físicas diretas como momento linear; sempre derive p = ∂L/∂q̇."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar um Sistema Conservativo com Ambas as Formulações",
                                  "subSteps": [
                                    "Escolha um sistema com 1 grau de liberdade, ex: oscilador harmônico mẍ + kx = 0.",
                                    "Derive equações Lagrangeanas: T = (1/2)mẋ², V = (1/2)kx².",
                                    "Transforme para Hamiltoniana: p = mẋ, H = p²/(2m) + (1/2)kx².",
                                    "Escreva as equações Hamiltonianas e verifique equivalência com Lagrangeanas.",
                                    "Implemente simbolicamente em software para validar."
                                  ],
                                  "verification": "Obtenha as mesmas EDOs de movimento de ambas formulações para o exemplo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Python com SymPy, MATLAB Symbolic Toolbox, papel e lápis para derivação manual.",
                                  "tips": "Mantenha o sistema conservativo (sem fricção) para destacar simetria Hamiltoniana.",
                                  "learningObjective": "Aplicar ambas formulações a um exemplo simples e confirmar equivalência.",
                                  "commonMistakes": "Esquecer de aplicar transformação de Legendre corretamente, levando a H incorreto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Vantagens da Formulação Hamiltoniana",
                                  "subSteps": [
                                    "Analise simetria: Hamiltonianas são simétricas em q e p, facilitando métodos numéricos simétricos.",
                                    "Discuta conservação: H é energia total, naturalmente conservada em integradores simétricos como Verlet.",
                                    "Compare estabilidade numérica: Hamiltoniana preserva estrutura simplética melhor que Lagrangeana.",
                                    "Avalie para sistemas acoplados: Hamilton facilita separação de variáveis canônicas.",
                                    "Liste vantagens em aeroespacial: melhor para simulações longas de vibrações sem dissipação artificial."
                                  ],
                                  "verification": "Crie uma tabela com 5 vantagens da Hamiltoniana sobre Lagrangeana para sistemas conservativos.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Artigos sobre integradores simpléticos (Hairer), exemplos numéricos em MATLAB.",
                                  "tips": "Pense em estabilidade de longo prazo: Hamiltoniana evita derivação de energia.",
                                  "learningObjective": "Identificar e justificar vantagens específicas da Hamiltoniana em contextos conservativos.",
                                  "commonMistakes": "Ignorar que vantagens são mais pronunciadas em simulações numéricas, não analíticas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Contexto Aeroespacial: Simulações de Vibrações Estruturais",
                                  "subSteps": [
                                    "Modele uma viga aeroespacial simples como sistema conservativo com 1 DOF (ex: flexão modal).",
                                    "Formule Hamiltoniana para vibrações estruturais: H = ∫ (T + V) dx.",
                                    "Simule numericamente com integrador simplético (ex: leapfrog) vs. método padrão.",
                                    "Compare resultados: energia conservada, precisão em tempos longos.",
                                    "Analise vantagens: redução de erros em simulações de flutter ou vibrações em asas."
                                  ],
                                  "verification": "Gere gráficos de simulação mostrando conservação de energia superior na Hamiltoniana.",
                                  "estimatedTime": "2 horas",
                                  "materials": "MATLAB ou Python (SciPy para ODEs), código de integrador simplético pronto.",
                                  "tips": "Use coordenadas modais para reduzir DOFs em estruturas reais.",
                                  "learningObjective": "Demonstrar vantagens práticas em aplicações aeroespaciais reais.",
                                  "commonMistakes": "Usar integradores não-simétricos, mascarando vantagens da Hamiltoniana."
                                }
                              ],
                              "practicalExample": "Modelagem de vibrações em uma asa de aeronave: use Hamiltoniana para simular o primeiro modo de flexão, comparando com Lagrangeana em MATLAB. Observe que a simulação Hamiltoniana mantém energia constante por 1000 períodos, enquanto Lagrangeana deriva 5% em energia.",
                              "finalVerifications": [
                                "Capacidade de derivar H a partir de L para qualquer sistema conservativo 1 DOF.",
                                "Tabela comparativa completa com pelo menos 5 vantagens da Hamiltoniana.",
                                "Simulação numérica mostrando conservação de energia superior.",
                                "Explicação verbal das vantagens em contextos aeroespaciais.",
                                "Identificação correta de quando usar cada formulação.",
                                "Gráficos de fase simétricos para o exemplo prático."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação das equações Hamiltonianas (sem erros algébricos).",
                                "Profundidade da análise de vantagens, com referências a simetria e estabilidade.",
                                "Qualidade da simulação numérica (gráficos claros, conservação demonstrada).",
                                "Relevância ao contexto aeroespacial (exemplos de vibrações estruturais).",
                                "Clareza na tabela comparativa e verificações finais.",
                                "Uso correto de terminologia (simplético, canônico, etc.)."
                              ],
                              "crossCurricularConnections": [
                                "Programação Numérica: Implementação de integradores em Python/MATLAB.",
                                "Física Computacional: Métodos simétricos para dinâmica.",
                                "Engenharia Aeroespacial: Análise de flutter e aeroelasticidade.",
                                "Matemática Aplicada: Equações diferenciais ordinárias e transformações canônicas."
                              ],
                              "realWorldApplication": "Em simulações de vibrações estruturais de satélites ou asas de aviões, a formulação Hamiltoniana permite previsões precisas de longo prazo sem dissipação numérica artificial, essencial para certificação de aeronaves pela FAA ou simulações de missões espaciais da NASA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "57.1.1.5.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "57.1.1.5.3",
                        "name": "Resposta Dinâmica sob Excitações em Sistemas com Um Grau de Liberdade",
                        "description": "Análise da resposta transitória e estacionária de sistemas modelados por Lagrange ou Hamilton sob excitações harmônicas, periódicas, arbitrárias, de base, incluindo transmissão e isolamento de vibrações em estruturas aeroespaciais.",
                        "specificSkills": [
                          {
                            "id": "57.1.1.5.3.1",
                            "name": "Resolver para excitação harmônica",
                            "description": "Determinar resposta particular e homogênea para força F(t) = F_0 cos(ωt), calcular amplificação dinâmica e fator de fase, aplicando a um sistema de asa simplificado.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "57.1.1.5.1"
                            ]
                          },
                          {
                            "id": "57.1.1.5.3.2",
                            "name": "Analisar excitações de base e isolamento de vibrações",
                            "description": "Modelar excitação de base y_b(t) para transmissibilidade de vibrações em componentes aeroespaciais, calcular razão de transmissão TR e condições de isolamento (ω/ω_n > √2).",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "57.1.1.5.1"
                            ]
                          },
                          {
                            "id": "57.1.1.5.3.3",
                            "name": "Tratar excitações arbitrárias via Duhamel",
                            "description": "Aplicar integral de convolução de Duhamel para resposta a excitações arbitrárias, incluindo amortecimento viscoso, e interpretar resultados para cargas aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "57.1.1.5.1"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.2",
                "name": "Resposta Dinâmica de Sistemas com Um Grau de Liberdade (SDOF)",
                "description": "Estuda a resposta dinâmica de sistemas estruturais a condições iniciais, excitações harmônicas, periódicas, arbitrárias, incluindo excitações de base, transmissão e isolamento de vibrações.",
                "totalSkills": 48,
                "atomicTopics": [
                  {
                    "id": "10.1.2.1",
                    "name": "Resposta a Condições Iniciais",
                    "description": "Análise da resposta livre de sistemas SDOF sem amortecimento e com amortecimento sob condições iniciais de deslocamento e velocidade.",
                    "individualConcepts": [
                      {
                        "id": "57.1.2.1.1",
                        "name": "Resposta Livre Sem Amortecimento em Sistemas SDOF",
                        "description": "Análise da resposta dinâmica livre de sistemas com um grau de liberdade (SDOF) sem amortecimento, sob condições iniciais de deslocamento e velocidade inicial, resultando em movimento harmônico simples.",
                        "specificSkills": [
                          {
                            "id": "57.1.2.1.1.1",
                            "name": "Derivação da Equação de Movimento Livre Sem Amortecimento",
                            "description": "Derivar a equação diferencial de segundo ordem mẍ + kx = 0 para um sistema massa-mola sem amortecimento, utilizando princípios de Newton ou Lagrange, e identificar a frequência natural ω_n = √(k/m).",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.1.2.1.1.2",
                            "name": "Solução Geral do Movimento Harmônico Simples",
                            "description": "Obter e interpretar a solução geral x(t) = A cos(ω_n t) + B sin(ω_n t), ou equivalentemente x(t) = C cos(ω_n t - φ), destacando o período T = 2π/ω_n e a independência da amplitude das condições iniciais.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.1.2.1.1.3",
                            "name": "Determinação de Constantes com Condições Iniciais",
                            "description": "Aplicar condições iniciais x(0) = x_0 e ẋ(0) = v_0 para calcular as constantes A e B, resultando em x(t) = x_0 cos(ω_n t) + (v_0 / ω_n) sin(ω_n t), com exemplos numéricos para estruturas aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.1.2.1.1.4",
                            "name": "Análise Gráfica e Interpretação Física",
                            "description": "Plotar e interpretar gráficos de deslocamento, velocidade e aceleração versus tempo, relacionando com vibrações livres em componentes aeroespaciais como painéis ou asas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Equações de Movimento para Vibração Livre Sem Amortecimento em SDOF",
                                  "subSteps": [
                                    "Derive a equação diferencial para um sistema SDOF sem amortecimento: mẍ + kx = 0.",
                                    "Resolva para a solução geral: x(t) = A cos(ωt + φ), onde ω = √(k/m).",
                                    "Identifique condições iniciais: x(0) = x₀, ẋ(0) = v₀ para determinar A e φ.",
                                    "Expresse velocidade v(t) = dx/dt e aceleração a(t) = d²x/dt².",
                                    "Calcule período T = 2π/ω e frequência f = 1/T."
                                  ],
                                  "verification": "Confirme que as equações derivadas correspondem à forma padrão e que as condições iniciais são satisfeitas numericamente para t=0.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de dinâmica (ex: Thomson), calculadora, papel e lápis ou software como MATLAB/Octave.",
                                  "tips": "Use convenções de sinal consistentes (ex: positivo para cima) para evitar confusão em fases.",
                                  "learningObjective": "Compreender matematicamente o movimento harmônico simples em SDOF sem amortecimento.",
                                  "commonMistakes": "Esquecer o sinal negativo na aceleração restauradora ou confundir ω com 2πf."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Plotar Gráfico de Deslocamento versus Tempo",
                                  "subSteps": [
                                    "Escolha parâmetros realistas: m=1 kg, k=100 N/m → ω=10 rad/s.",
                                    "Defina condições iniciais: x(0)=0.1 m, v(0)=0 m/s → x(t)=0.1 cos(10t).",
                                    "Gere pontos de dados para t de 0 a 2s com Δt=0.01s (200 pontos).",
                                    "Plote x(t) usando ferramenta gráfica, rotulando eixos (tempo em s, deslocamento em m).",
                                    "Identifique amplitude, período e fase no gráfico."
                                  ],
                                  "verification": "O gráfico mostra oscilação senoidal com amplitude 0.1m e período ~0.628s; verifique com fórmula T=2π/ω.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de plotagem (Excel, Python/Matplotlib, MATLAB), tabela de valores calculados.",
                                  "tips": "Use escala adequada nos eixos para visualizar múltiplos ciclos sem distorção.",
                                  "learningObjective": "Dominar a geração e visualização gráfica do deslocamento em vibração livre.",
                                  "commonMistakes": "Plotar seno em vez de cosseno sem ajustar fase, ou escalas erradas que mascaram o período."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar e Plotar Gráficos de Velocidade e Aceleração",
                                  "subSteps": [
                                    "Derive v(t) = -Aω sin(ωt + φ) e a(t) = -Aω² cos(ωt + φ) dos parâmetros anteriores.",
                                    "Calcule valores numéricos para os mesmos intervalos de tempo.",
                                    "Plote v(t) e a(t) no mesmo gráfico ou subgráficos, com escalas apropriadas (v em m/s, a em m/s²).",
                                    "Observe defasagens: velocidade defasada 90° do deslocamento, aceleração 180°.",
                                    "Adicione curvas de deslocamento para comparação qualitativa."
                                  ],
                                  "verification": "Confirme defasagens: máximo de v quando x=0, máximo de a oposto a x máximo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Mesmo software de plotagem, derivadas analíticas anotadas.",
                                  "tips": "Normalizar amplitudes (dividir v por ω, a por ω²) para sobrepor curvas e destacar formas.",
                                  "learningObjective": "Visualizar relações cinemáticas entre posição, velocidade e aceleração em osciladores.",
                                  "commonMistakes": "Erro no sinal das derivadas ou plotar sem considerar fatores de escala (ω amplifica v e a)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Gráficos Fisicamente e Relacionar com Componentes Aeroespaciais",
                                  "subSteps": [
                                    "Analise energia: energia total constante (1/2 k A²), transferindo entre cinética e potencial.",
                                    "Interprete picos: deslocamento máximo = energia potencial máxima; velocidade máxima = energia cinética máxima.",
                                    "Relacione com painel de asa: ω natural determina risco de ressonância com turbulência.",
                                    "Discuta implicações: vibrações livres iniciais por manobra podem excitar modos naturais.",
                                    "Simule variação: altere x₀ ou v₀ e observe mudanças nos gráficos."
                                  ],
                                  "verification": "Escreva um parágrafo explicando como um pico de aceleração em t=π/(2ω) corresponde a passagem pela posição de equilíbrio com velocidade máxima.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Diagramas de painéis/asas vibrando, vídeo de flutter (YouTube ou simulação).",
                                  "tips": "Pense em termos de forças: F = -kx explica aceleração oposta ao deslocamento.",
                                  "learningObjective": "Conectar representações gráficas a interpretações físicas e aplicações em aeroelasticidade.",
                                  "commonMistakes": "Ignorar contexto aeroespacial ou confundir vibração livre com forçada/amortecida."
                                }
                              ],
                              "practicalExample": "Simule uma asa de aeronave com m=10 kg, k=1000 N/m (ω≈10 rad/s). Após uma rajada inicial (x(0)=0.05m, v(0)=0), plote x(t), v(t), a(t) para 1s. Interprete: aceleração pico de ~50 m/s² pode causar fadiga estrutural se ressoar.",
                              "finalVerifications": [
                                "Gráficos mostram oscilações senoidais com defasagens corretas (90° v-x, 180° a-x).",
                                "Período calculado do gráfico coincide com T=2π/ω (±5%).",
                                "Interpretação física liga máximos/mínimos a estados de energia.",
                                "Exemplo aeroespacial identifica risco de vibração em painéis.",
                                "Simulação com condições iniciais alteradas produz gráficos consistentes.",
                                "Energia total conservada verificada numericamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão das equações derivadas e plotagens (sem erros de sinal ou escala).",
                                "Clareza e rotulagem completa dos gráficos (eixos, legendas, unidades).",
                                "Profundidade da interpretação física (energia, defasagens, forças).",
                                "Relevância da conexão com aeroespacial (ex: flutter em asas).",
                                "Criatividade em simulações variadas e verificações quantitativas.",
                                "Completude da documentação (equações, parâmetros, conclusões)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções trigonométricas, derivadas e análise de fases.",
                                "Programação: Scripts em Python/MATLAB para automação de plots e simulações.",
                                "Engenharia Mecânica: Modelagem de sistemas dinâmicos e análise modal.",
                                "Física Geral: Conservação de energia em osciladores harmônicos."
                              ],
                              "realWorldApplication": "Em design de aeronaves, engenheiros usam esses gráficos para prever vibrações livres em asas ou painéis após distúrbios (ex: gust loads), evitando ressonância que leva a flutter catastrófico, como no incidente do Lockheed Electra, otimizando rigidez (k) e massa (m) para elevar ω natural acima de frequências de excitação."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "57.1.2.1.2",
                        "name": "Resposta Livre Com Amortecimento em Sistemas SDOF",
                        "description": "Análise da resposta livre de sistemas SDOF com amortecimento viscoso sob condições iniciais, abrangendo os casos subamortecido, crítico e superamortecido, com ênfase em decaimento exponencial.",
                        "specificSkills": [
                          {
                            "id": "57.1.2.1.2.1",
                            "name": "Derivação da Equação com Amortecimento Viscoso",
                            "description": "Derivar a equação mẍ + cẋ + kx = 0, definir o fator de amortecimento ζ = c/(2√(km)) e a frequência amortecida ω_d = ω_n √(1 - ζ²), contextualizando em modelagem de estruturas aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [],
                              "practicalExample": "",
                              "finalVerifications": [],
                              "assessmentCriteria": [],
                              "crossCurricularConnections": [],
                              "realWorldApplication": ""
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.1.2.1.2.2",
                            "name": "Soluções para Casos Subamortecido, Crítico e Superamortecido",
                            "description": "Obter soluções analíticas: subamortecido x(t) = e^{-ζω_n t} (A cos(ω_d t) + B sin(ω_d t)); crítico x(t) = (A + B t) e^{-ω_n t}; superamortecido x(t) = A e^{r1 t} + B e^{r2 t}, com r1, r2 raízes da equação característica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Equação de Movimento e Formar a Equação Característica",
                                  "subSteps": [
                                    "Escreva a equação diferencial ordinária (EDO) de segunda ordem para um sistema SDOF com amortecimento: m ÿ + c ẏ + k y = 0.",
                                    "Defina os parâmetros normalizados: ω_n = sqrt(k/m) (frequência natural) e ζ = c / (2 sqrt(k m)) (fator de amortecimento).",
                                    "Reescreva a EDO na forma padrão: ÿ + 2 ζ ω_n ẏ + ω_n² y = 0.",
                                    "Formule a equação característica: r² + 2 ζ ω_n r + ω_n² = 0.",
                                    "Calcule o discriminante: D = (ζ ω_n)² - ω_n² = ω_n² (ζ² - 1)."
                                  ],
                                  "verification": "Verifique se a equação característica e o discriminante estão corretos comparando com referências padrão.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de dinâmica estrutural (ex: Chopra)",
                                    "Papel e caneta",
                                    "Calculadora simbólica ou software como MATLAB"
                                  ],
                                  "tips": "Sempre normalize os parâmetros para facilitar a classificação dos casos.",
                                  "learningObjective": "Compreender a estrutura matemática fundamental das respostas amortecidas em SDOF.",
                                  "commonMistakes": [
                                    "Confundir o coeficiente de amortecimento c com 2 ζ ω_n diretamente",
                                    "Erro no cálculo do discriminante (esquecer ω_n²)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Classificar os Casos de Amortecimento Baseado no Fator ζ",
                                  "subSteps": [
                                    "Defina subamortecido: 0 < ζ < 1 (D < 0, raízes complexas conjugadas).",
                                    "Defina crítico: ζ = 1 (D = 0, raiz real dupla em r = -ω_n).",
                                    "Defina superamortecido: ζ > 1 (D > 0, raízes reais distintas r1, r2 < 0).",
                                    "Calcule as raízes para cada caso: subamortecido r = -ζ ω_n ± j ω_d (ω_d = ω_n √(1 - ζ²)); crítico r = -ω_n; superamortecido r1,2 = -ζ ω_n ± ω_n √(ζ² - 1).",
                                    "Crie uma tabela comparativa dos casos com exemplos numéricos de ζ."
                                  ],
                                  "verification": "Classifique corretamente 3 exemplos com valores de ζ diferentes e liste as raízes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha Excel ou tabela impressa",
                                    "Referência de tabela de amortecimento"
                                  ],
                                  "tips": "Lembre-se: amortecimento crítico é o limite entre oscilatório e aperiódico.",
                                  "learningObjective": "Identificar e diferenciar os três regimes de amortecimento.",
                                  "commonMistakes": [
                                    "Confundir subamortecido com superamortecido no sinal do discriminante",
                                    "Esquecer que ω_d é imaginário apenas conceitualmente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a Solução Analítica para Caso Subamortecido",
                                  "subSteps": [
                                    "Assuma a solução geral baseada nas raízes complexas: x(t) = e^{-ζ ω_n t} (A cos(ω_d t) + B sin(ω_d t)), com ω_d = ω_n √(1 - ζ²).",
                                    "Verifique que satisfaz a EDO substituindo x(t), ẋ(t) e ÿ(t).",
                                    "Discuta o decaimento exponencial e a oscilação persistente.",
                                    "Aplique condições iniciais x(0) = x0, ẋ(0) = v0 para encontrar A = x0 e B = (v0 + ζ ω_n x0)/ω_d.",
                                    "Plote ou esboce x(t) para ζ = 0.5 e compare com não amortecido."
                                  ],
                                  "verification": "Substitua na EDO e confirme que ÿ + 2ζω_n ẏ + ω_n² y = 0.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de plotagem (MATLAB ou Python com Matplotlib)",
                                    "Papel para derivação"
                                  ],
                                  "tips": "Use identidades trigonométricas para simplificar a verificação.",
                                  "learningObjective": "Dominar a forma oscilatória amortecida e aplicação de condições iniciais.",
                                  "commonMistakes": [
                                    "Erro no cálculo de B (esquecer o termo ζω_n x0)",
                                    "Confundir ω_d com ω_n"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar a Solução para Caso Crítico",
                                  "subSteps": [
                                    "Para raiz dupla r = -ω_n, a solução geral é x(t) = (A + B t) e^{-ω_n t}.",
                                    "Derive ẋ(t) = B e^{-ω_n t} + (A + B t) (-ω_n) e^{-ω_n t} e verifique na EDO.",
                                    "Aplique condições iniciais: A = x0, B = v0 + ω_n x0.",
                                    "Analise o comportamento: retorno ao equilíbrio sem oscilar, no tempo mínimo.",
                                    "Compare graficamente com subamortecido próximo (ζ ≈1)."
                                  ],
                                  "verification": "Confirme que as condições iniciais geram os coeficientes corretos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Gráficos de referência"
                                  ],
                                  "tips": "O termo B t causa o 'pico' característico antes do decaimento.",
                                  "learningObjective": "Entender o caso limite de amortecimento ótimo.",
                                  "commonMistakes": [
                                    "Esquecer o fator t na solução geral",
                                    "Erro na derivada de produto"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Derivar a Solução para Caso Superamortecido e Sintetizar",
                                  "subSteps": [
                                    "Raízes reais r1,2 = -ζ ω_n ± ω_n √(ζ² - 1); solução x(t) = A e^{r1 t} + B e^{r2 t}.",
                                    "Verifique satisfação da EDO e aplique condições iniciais para resolver sistema 2x2: A + B = x0; A r1 + B r2 = v0.",
                                    "Analise: decaimento mais lento que crítico, sem oscilação.",
                                    "Resolva um problema numérico completo para os três casos.",
                                    "Sintetize: tabela com formas, condições de validade e gráficos comparativos."
                                  ],
                                  "verification": "Resolva sistema para A e B e plote x(t) para ζ=2.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB ou Python para resolução numérica",
                                    "Tabela de síntese"
                                  ],
                                  "tips": "Rotule r1 como a mais negativa (decaimento mais rápido).",
                                  "learningObjective": "Completar o domínio das soluções analíticas e compará-las.",
                                  "commonMistakes": [
                                    "Invertar r1 e r2",
                                    "Erro no sistema linear de condições iniciais"
                                  ]
                                }
                              ],
                              "practicalExample": "Sistema massa-mola-amortecedor: m=1 kg, k=100 N/m (ω_n=10 rad/s), c=20 Ns/m (ζ=1, crítico). Condições: x(0)=0.1 m, ẋ(0)=0. Solução: x(t)=(0.1 + t) e^{-10 t}. Verifique limite t→∞ e máximo em t=0.1 s.",
                              "finalVerifications": [
                                "Deriva corretamente as três formas de solução a partir da equação característica.",
                                "Aplica condições iniciais para encontrar A e B em todos os casos.",
                                "Classifica corretamente o regime dado ζ e justifica com discriminante.",
                                "Verifica que cada solução satisfaz a EDO original.",
                                "Compara graficamente os comportamentos para ζ=0.5, 1 e 2.",
                                "Resolve um problema numérico completo com valores reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação das raízes e formas gerais (30%).",
                                "Correção na aplicação de condições iniciais (25%).",
                                "Compreensão qualitativa dos comportamentos (20%).",
                                "Verificações matemáticas e gráficos (15%).",
                                "Síntese comparativa e tabela (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Solução de EDOs lineares homogêneas de 2a ordem.",
                                "Física: Modelos de osciladores amortecidos em mecânica clássica.",
                                "Engenharia Mecânica: Análise de vibrações em estruturas.",
                                "Controle de Sistemas: Projeto de amortecedores para estabilidade."
                              ],
                              "realWorldApplication": "Em aeroelasticidade, modela o amortecimento em asas de aeronaves para prevenir flutter (oscilações autoexcitadas), garantindo segurança em manobras; usado no design de landing gear para absorver impactos sem oscilações residuais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.1.2.1.2.3",
                            "name": "Aplicação de Condições Iniciais nos Casos Amortecidos",
                            "description": "Calcular constantes A e B para cada caso usando x(0) = x_0 e ẋ(0) = v_0, com exemplos de decaimento em vibrações de fuselagens ou hélices aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o Caso de Amortecimento e Forma Geral da Solução",
                                  "subSteps": [
                                    "Determine o valor do fator de amortecimento ζ com base nos parâmetros do sistema (m, c, k).",
                                    "Classifique o sistema como subamortecido (ζ < 1), criticamente amortecido (ζ = 1) ou superamortecido (ζ > 1).",
                                    "Escreva a forma geral da solução x(t) para o caso identificado: subamortecido (x(t) = e^{-ζω_n t} (A cos(ω_d t) + B sen(ω_d t))), crítico (x(t) = (A + B t) e^{-ω_n t}) ou superamortecido (x(t) = A e^{r_1 t} + B e^{r_2 t}).",
                                    "Calcule as frequências ou raízes características necessárias (ω_d = ω_n √(1 - ζ²), r1/r2 = -ζω_n ± ω_n √(ζ² - 1)).",
                                    "Anote os valores iniciais x(0) = x_0 e ẋ(0) = v_0."
                                  ],
                                  "verification": "Confirme que a forma da solução corresponde ao ζ calculado e que as raízes ou frequências estão corretas comparando com fórmulas padrão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Fórmulas de sistemas SDOF amortecidos",
                                    "Calculadora ou software simbólico como Mathematica/SymPy",
                                    "Papel e lápis para anotações"
                                  ],
                                  "tips": "Sempre verifique unidades consistentes para m, c, k para evitar erros em ζ.",
                                  "learningObjective": "Compreender e selecionar corretamente a solução analítica para cada regime de amortecimento em sistemas SDOF.",
                                  "commonMistakes": [
                                    "Confundir subamortecido com superamortecido",
                                    "Esquecer de calcular ω_d corretamente",
                                    "Usar ζ incorreto devido a erro em c_cr = 2√(km)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a Primeira Condição Inicial: x(0) = x_0",
                                  "subSteps": [
                                    "Substitua t = 0 na equação x(t) para obter x(0) = A (para todos os casos, pois termos com sen(0)=0, t=0 ou e^0=1 simplificam).",
                                    "Para subamortecido: A = x_0.",
                                    "Para crítico: A = x_0.",
                                    "Para superamortecido: A + B * 1 (mas como e^0=1 para ambos, isole A se possível, geralmente A = x_0 após simplificação inicial).",
                                    "Registre o valor de A obtido."
                                  ],
                                  "verification": "Verifique se x(0) calculado com A retorna exatamente x_0.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Equação x(t) anotada do step 1",
                                    "Calculadora"
                                  ],
                                  "tips": "Lembre-se que em t=0, funções trigonométricas e exponenciais se simplificam drasticamente.",
                                  "learningObjective": "Aplicar corretamente a condição de posição inicial para determinar a constante A.",
                                  "commonMistakes": [
                                    "Esquecer o fator e^{-ζω_n *0} =1",
                                    "Confundir A com termos dependentes de B em superamortecido"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a Segunda Condição Inicial: ẋ(0) = v_0",
                                  "subSteps": [
                                    "Derive x(t) para obter ẋ(t): subamortecido (ẋ(t) = -ζω_n e^{-ζω_n t} (A cos + B sen) + e^{-ζω_n t} (-A ω_d sen + B ω_d cos)), crítico (ẋ(t) = B e^{-ω_n t} + (A + B t)(-ω_n) e^{-ω_n t}), superamortecido (ẋ(t) = A r1 e^{r1 t} + B r2 e^{r2 t}).",
                                    "Substitua t=0 e isole B: subamortecido B = (v_0 + ζω_n x_0)/ω_d, crítico B = v_0 + ω_n x_0, superamortecido B = (v_0 - r1 x_0)/(r2 - r1).",
                                    "Substitua o A já conhecido do step 2.",
                                    "Simplifique a expressão para B.",
                                    "Escreva a solução completa x(t) com A e B determinados."
                                  ],
                                  "verification": "Calcule ẋ(0) com os A e B encontrados e confirme que equals v_0.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Derivadas das soluções padrão",
                                    "Software para derivação simbólica opcional"
                                  ],
                                  "tips": "Faça a derivada passo a passo e substitua t=0 antes de simplificar para evitar erros algébricos.",
                                  "learningObjective": "Derivar e aplicar a condição de velocidade inicial para determinar a constante B.",
                                  "commonMistakes": [
                                    "Erro na derivada do produto (regra da cadeia)",
                                    "Esquecer termos de produto em ẋ(t)",
                                    "Divisão por zero em superamortecido se r1=r2 (mas crítico é separado)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Aplicar em Exemplo Aeroespacial",
                                  "subSteps": [
                                    "Escolha parâmetros realistas: ex. fuselagem com m=1000 kg, k=10^5 N/m, c variando para ζ=0.5 (sub), 1 (crítico), 1.5 (super), x_0=0.1 m, v_0=0.5 m/s.",
                                    "Calcule A e B para cada caso.",
                                    "Plote ou tabule x(t) para t=0 a 10s e verifique decaimento.",
                                    "Compare respostas: subamortecido oscila e decai, crítico retorna rápido sem oscilar, superamortecido decai lentamente sem oscilar.",
                                    "Discuta implicações para vibrações em hélices ou fuselagens."
                                  ],
                                  "verification": "Gráficos mostram x(0)=x_0, ẋ(0)=v_0 e comportamento físico esperado (decaimento).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de plotagem como MATLAB/Python (Matplotlib) ou Excel",
                                    "Parâmetros de exemplo aeroespaciais"
                                  ],
                                  "tips": "Use scripts prontos para plotar para focar na física, não na programação.",
                                  "learningObjective": "Validar a solução em contexto aeroespacial e interpretar resultados.",
                                  "commonMistakes": [
                                    "Parâmetros irreais levando a ζ inválido",
                                    "Plot errada sem verificar condições iniciais"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma hélice de aeronave, após uma rajada de vento, a vibração inicial é x(0)=0.05 m (deslocamento da lâmina) e v(0)=0.2 m/s (velocidade). Com ζ=0.3 (subamortecido), calcule A e B para prever tempo até decaimento seguro (<0.01 m), evitando fadiga estrutural.",
                              "finalVerifications": [
                                "x(0) = x_0 exatamente para todos os casos.",
                                "ẋ(0) = v_0 após substituição de A e B.",
                                "Solução x(t) mostra decaimento exponencial correto.",
                                "Classificação de ζ consistente com gráfico de x(t).",
                                "Valores de A e B numéricos coerentes com unidades.",
                                "Verificação cruzada: simulação numérica matches analítica em t=0 e t pequeno."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação do caso de amortecimento (100% correto).",
                                "Cálculo exato de A e B usando condições iniciais (erro <1%).",
                                "Derivação correta de ẋ(t) sem erros algébricos.",
                                "Interpretação física adequada do decaimento em contexto aeroespacial.",
                                "Gráficos ou tabelas mostram condições iniciais e comportamento esperado.",
                                "Explicação clara de implicações reais (ex. fadiga em fuselagens)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Solução de EDOs lineares de 2a ordem com coeficientes constantes.",
                                "Física: Princípios de osciladores amortecidos e energia dissipada.",
                                "Engenharia: Análise modal em estruturas aeroespaciais (FEA como ANSYS).",
                                "Programação: Simulação numérica em Python/MATLAB para validação.",
                                "Controle: Base para controladores PID em estabilização de vibrações."
                              ],
                              "realWorldApplication": "Previsão de decaimento de vibrações em fuselagens de aviões após turbulência ou em hélices de drones/helikopteros, otimizando design para evitar ressonância e fadiga material, essencial para certificação FAA/EASA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.1.2.1.2.4",
                            "name": "Comparação entre Casos e Log-Decreto",
                            "description": "Comparar respostas gráficas dos três casos, calcular log-decrémento δ = ln(x_n / x_{n+1}) = 2πζ / √(1 - ζ²) para subamortecido, e discutir relevância em ensaios de vibração estrutural.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e Plotar Respostas Gráficas dos Três Casos de Amortecimento",
                                  "subSteps": [
                                    "Revise as equações de resposta livre para sistemas SDOF: sem amortecimento (ζ=0), subamortecido (0<ζ<1), amortecimento crítico (ζ=1) e sobreamortecido (ζ>1).",
                                    "Selecione valores típicos: ω_n = 1 rad/s, ζ = 0 (sem), 0.1 (sub), 1 (crítico), 1.5 (sobre); condições iniciais x(0)=1, v(0)=0.",
                                    "Use software como MATLAB/Python/Mathematica para plotar x(t) vs t para cada caso em um gráfico comparativo (0 a 20s).",
                                    "Ajuste escalas para visualizar decaimento e oscilações claramente.",
                                    "Anote características: oscilações persistentes (sem), decaimento oscilante (sub), decaimento sem oscilação (crítico/sobre)."
                                  ],
                                  "verification": "Gráficos gerados mostram diferenças claras: persistência sem amortecimento, envelope exponencial subamortecido, decaimento rápido crítico/sobreamortecido.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de plotagem (MATLAB, Python com Matplotlib/NumPy, ou Excel avançado), equações de referência de livro-texto de dinâmica.",
                                  "tips": "Use log-scale no eixo y para visualizar envelopes de decaimento no subamortecido.",
                                  "learningObjective": "Identificar visualmente os efeitos do amortecimento na resposta temporal de SDOF.",
                                  "commonMistakes": "Esquecer fase inicial ou unidades inconsistentes em ω_n; plotar apenas um caso sem comparação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar e Calcular o Log-Decréscimo para Caso Subamortecido",
                                  "subSteps": [
                                    "Derive o log-decréscimo δ = ln(x_n / x_{n+1}), onde x_n e x_{n+1} são picos consecutivos no gráfico subamortecido.",
                                    "Mostre que δ ≈ 2πζ / √(1 - ζ²) para ζ <<1, aproximando o envelope e^{-ζω_n t}.",
                                    "Do gráfico do Step 1, extraia pelo menos 3 pares de picos consecutivos (ex: primeiros 3 ciclos).",
                                    "Calcule δ médio: δ = (1/N) Σ ln(x_n / x_{n+1}) para N ciclos.",
                                    "Inverta para encontrar ζ = δ / √((2π)^2 + δ^2)."
                                  ],
                                  "verification": "Cálculo de δ converge para valor teórico (ex: para ζ=0.1, δ≈0.628); ζ recuperado com erro <5%.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Gráficos do Step 1, calculadora ou script Python para extração de picos (scipy.signal.find_peaks).",
                                  "tips": "Ignore picos iniciais transitórios; use cursor de zoom para precisão em software.",
                                  "learningObjective": "Dominar o cálculo prático do log-decréscimo como medida de amortecimento.",
                                  "commonMistakes": "Confundir picos com vales; não aproximar para múltiplos ciclos, levando a δ impreciso."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Respostas Gráficas e Quantificar Diferenças",
                                  "subSteps": [
                                    "Sobreponha gráficos normalizados (divididos por x_max) para comparar decaimento relativo.",
                                    "Calcule métricas: número de ciclos até 1/e de amplitude (sem: infinito; sub: 1/(ζω_n); crítico: tempo de pico).",
                                    "Discuta qualitativamente: estabilidade (sobreamortecido mais estável mas lento), overshoot (subamortecido oscila).",
                                    "Crie tabela comparativa: ζ, δ (se aplicável), tempo de assentamento (2% critério).",
                                    "Valide numericamente: simule variação de ζ e observe tendências."
                                  ],
                                  "verification": "Tabela e gráficos mostram tendências corretas: decaimento aumenta com ζ; δ proporcional a ζ.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Gráficos e cálculos anteriores, planilha Excel para tabela.",
                                  "tips": "Normalize por amplitude inicial para foco em decaimento, não excitação.",
                                  "learningObjective": "Analisar quantitativa e qualitativamente impactos do amortecimento em respostas dinâmicas.",
                                  "commonMistakes": "Comparar escalas absolutas sem normalizar; ignorar efeitos de frequência amortecida."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Relevância em Ensaios de Vibração Estrutural",
                                  "subSteps": [
                                    "Explique testes livres: excitação inicial (pluck, hammer), registro de decay para estimar ζ via δ.",
                                    "Descreva aplicação aeroespacial: testes modais em asas/paineis para fadiga/flutter.",
                                    "Calcule exemplo: estrutura com f_n=10Hz (ω_n=62.8 rad/s), meça δ=0.2 → ζ≈0.032.",
                                    "Discuta limitações: ruído em medidas reais, não-linearidades.",
                                    "Relacione a critérios de design: ζ>0.02 para controle de vibração em aeronaves."
                                  ],
                                  "verification": "Relatório resume corretamente uso de δ em testes, com exemplo numérico coerente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Referências: NASA TM on vibration testing, artigos sobre modal analysis.",
                                  "tips": "Busque vídeos de 'free vibration decay test' para visualização intuitiva.",
                                  "learningObjective": "Conectar teoria de SDOF a práticas experimentais em engenharia aeroespacial.",
                                  "commonMistakes": "Generalizar sem contexto aeroespacial; superestimar precisão de δ em testes ruidosos."
                                }
                              ],
                              "practicalExample": "Em um teste de vibração livre de uma viga cantilever representando uma asa de UAV: excitação por deslocamento inicial de 5mm, registro via acelerômetro. Extraia picos: x1=4.8mm, x2=3.9mm → δ=ln(4.8/3.9)=0.208. Para ω_n=50 rad/s, ζ=δ/√(4π²+δ²)≈0.033. Compare com simulação subamortecida para validar modelo.",
                              "finalVerifications": [
                                "Gráficos comparativos mostram decaimento progressivo com ζ crescente.",
                                "Cálculo de δ médio de pelo menos 3 ciclos com erro <10% do teórico.",
                                "ζ recuperado via fórmula inversa coincide com valor assumido.",
                                "Tabela de comparação lista tempos de assentamento corretos.",
                                "Discussão identifica 3 aplicações específicas em testes estruturais.",
                                "Exemplo prático inclui valores numéricos realistas de um teste hipotético."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos plots: eixos rotulados, escalas adequadas, legendas claras (20%).",
                                "Correção matemática: derivação e cálculos de δ/ζ sem erros (30%).",
                                "Profundidade da comparação: qualitativa + quantitativa com métricas (20%).",
                                "Relevância prática: ligação clara a ensaios aeroespaciais (15%).",
                                "Clareza e organização: gráficos legíveis, tabela estruturada (10%).",
                                "Originalidade: insights sobre limitações ou extensões (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: funções trigonométricas, logaritmos naturais, aproximações assintóticas.",
                                "Física: osciladores harmônicos amortecidos, conservação de energia.",
                                "Programação: simulação numérica (ODE solvers como ode45), análise de sinais (picos).",
                                "Engenharia Mecânica: análise modal experimental, controle de vibrações.",
                                "Estatística: tratamento de ruído em medidas de picos."
                              ],
                              "realWorldApplication": "Em ensaios de qualificação de estruturas aeroespaciais (ex: Boeing 787 wings), o log-decréscimo é medido em testes de vibração livre para estimar damping ratio ζ, validando modelos FEM para previsão de fadiga e prevenção de flutter crítico em voo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.2",
                    "name": "Resposta a Excitações Harmônicas",
                    "description": "Solução da equação de movimento para forças senoidais, incluindo fenômeno de ressonância e diagrama de Bode.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.2.1",
                        "name": "Equação de Movimento e Solução Particular para Excitações Harmônicas",
                        "description": "Formulação da equação diferencial de segundo ordem para sistemas SDOF submetidos a forças senoidais F(t) = F0 cos(ωt) ou F(t) = F0 sin(ωt), incluindo a solução particular estacionária assumindo forma harmônica.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.1.1",
                            "name": "Derivar a equação de movimento para excitação harmônica",
                            "description": "Aplicar o princípio de equilíbrio dinâmico ou Lagrange para obter mẍ + cẋ + kx = F0 cos(ωt), identificando os parâmetros massa (m), amortecimento (c), rigidez (k) e frequência de excitação (ω).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o sistema SDOF com amortecimento e excitação harmônica",
                                  "subSteps": [
                                    "Desenhe o diagrama esquemático de um sistema massa-mola-amortecedor (SDOF) com força externa harmônica F(t) = F0 cos(ωt).",
                                    "Identifique as componentes: massa m, rigidez k, amortecedor c, posição x(t), velocidade ẋ(t), aceleração ẍ(t).",
                                    "Explique o significado físico de cada parâmetro: m (inércia), c (dissipação de energia), k (restaurador), ω (frequência da força externa).",
                                    "Defina as condições de contorno iniciais e o referencial inercial.",
                                    "Discuta diferenças entre excitação harmônica e livre vibração."
                                  ],
                                  "verification": "Desenhe corretamente o diagrama e rotule todos os parâmetros com suas unidades (ex: m em kg, k em N/m).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de dinâmica (ex: Thomson 'Vibrações e Ondas')",
                                    "Software de desenho como Draw.io"
                                  ],
                                  "tips": [
                                    "Use convenções consistentes de sinal: positivo para deslocamento para a direita.",
                                    "Visualize o sistema como uma asa simplificada vibrando."
                                  ],
                                  "learningObjective": "Entender a configuração física do sistema SDOF sob excitação harmônica.",
                                  "commonMistakes": [
                                    "Confundir ω (excitação) com ωn (natural).",
                                    "Esquecer o amortecedor viscoso c.",
                                    "Ignorar a direção da força externa."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a equação usando o princípio de equilíbrio dinâmico (D'Alembert)",
                                  "subSteps": [
                                    "Aplique a 2ª lei de Newton: soma de forças = m ẍ.",
                                    "Some forças: inercial (-m ẍ), amortecimento (-c ẋ), elástica (-k x), externa (F0 cos(ωt)).",
                                    "Reorganize para m ẍ + c ẋ + k x = F0 cos(ωt).",
                                    "Verifique dimensionalmente: [m ẍ] = kg m/s² = N, similar para outros termos.",
                                    "Discuta o princípio de D'Alembert como equilíbrio dinâmico."
                                  ],
                                  "verification": "Escreva a equação final e derive cada termo passo a passo em um papel.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora simbólica (ex: SymPy online)",
                                    "Video tutorial sobre D'Alembert"
                                  ],
                                  "tips": [
                                    "Trate a força inercial como uma força fictícia para equilíbrio.",
                                    "Sempre inclua sinais corretos baseados no diagrama."
                                  ],
                                  "learningObjective": "Derivar a EDO de 2ª ordem via abordagem newtoniana.",
                                  "commonMistakes": [
                                    "Sinal errado no amortecimento (deve ser -c ẋ para oposição ao movimento).",
                                    "Esquecer de mover m ẍ para o lado esquerdo.",
                                    "Confundir F0 sin(ωt) com cos(ωt)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a equação usando o formalismo de Lagrange",
                                  "subSteps": [
                                    "Defina a energia cinética T = (1/2) m ẋ².",
                                    "Defina a energia potencial V = (1/2) k x² (amortecimento não conservativo tratado separadamente).",
                                    "Calcule a Lagrangiana L = T - V.",
                                    "Aplique a equação de Lagrange: d/dt (∂L/∂ẋ) - ∂L/∂x = Q (força generalizada), onde Q = F0 cos(ωt) - c ẋ.",
                                    "Simplifique para obter m ẍ + c ẋ + k x = F0 cos(ωt)."
                                  ],
                                  "verification": "Compare a equação obtida com a do método anterior; devem coincidir.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Folha de derivadas parciais",
                                    "Software MATLAB/SymPy para Lagrangiana",
                                    "Referência: Goldstein 'Mecânica Clássica'"
                                  ],
                                  "tips": [
                                    "Amortecimento entra como força não conservativa Q_nc = -c ẋ + F0 cos(ωt).",
                                    "Pratique ∂L/∂ẋ = m ẋ."
                                  ],
                                  "learningObjective": "Dominar a derivação variacional para sistemas dissipativos.",
                                  "commonMistakes": [
                                    "Esquecer o termo de Rayleigh para dissipação (∂R/∂ẋ = c ẋ).",
                                    "Erro em d/dt (∂L/∂ẋ) = m ẍ.",
                                    "Confundir L com Hamiltoniana."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar parâmetros e interpretar a equação final",
                                  "subSteps": [
                                    "Liste parâmetros: m (massa), c (coef. amortecimento), k (constante elástica), F0 (amplitude força), ω (frequência excitação).",
                                    "Calcule frequência natural ωn = sqrt(k/m) e razão de amortecimento ζ = c/(2 sqrt(m k)).",
                                    "Discuta regimes: subamortecido, crítico, sobreamortecido.",
                                    "Resolva para solução particular xp(t) = D cos(ωt - φ) e discuta amplificação.",
                                    "Verifique limites: c=0 (sem amortecimento), ω=ωn (ressonância)."
                                  ],
                                  "verification": "Rotule todos os parâmetros na equação e compute ωn para um exemplo numérico (m=1kg, k=100N/m).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel para cálculos",
                                    "Gráficos de resposta em frequência",
                                    "Simulador online de SDOF"
                                  ],
                                  "tips": [
                                    "Use unidades SI consistentes para evitar erros.",
                                    "Plote H(ω) = 1 / (k - m ω² + i c ω) para insight."
                                  ],
                                  "learningObjective": "Interpretar fisicamente cada termo e prever comportamento.",
                                  "commonMistakes": [
                                    "Confundir ζ com c diretamente.",
                                    "Ignorar fase φ na solução forçada.",
                                    "Erro em ωn = sqrt(k/m)."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma asa de aeronave modelada como SDOF, uma rajada de vento harmônica F(t) = 1000 cos(2π*10 t) N excita a estrutura com m=500kg, c=100 Ns/m, k=10^5 N/m. Derive a equação para prever vibrações e fadiga.",
                              "finalVerifications": [
                                "Derivação correta via equilíbrio dinâmico sem erros de sinal.",
                                "Derivação via Lagrange coincidente com a newtoniana.",
                                "Identificação precisa de m, c, k, F0, ω com unidades.",
                                "Cálculo correto de ωn e ζ para valores numéricos.",
                                "Explicação da ressonância quando ω ≈ ωn.",
                                "Verificação dimensional da equação completa."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (100% dos passos corretos).",
                                "Compreensão conceitual (explicação física de cada termo).",
                                "Consistência entre métodos (equações idênticas).",
                                "Profundidade na interpretação de parâmetros e regimes.",
                                "Criatividade no exemplo prático aeroespacial.",
                                "Clareza na documentação (diagramas e fórmulas legíveis)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações diferenciais lineares de 2ª ordem e soluções forçadas.",
                                "Física: Princípios variacionais vs. newtonianos em mecânica clássica.",
                                "Engenharia de Controle: Análise de Bode para sistemas lineares.",
                                "Computação: Simulação numérica em MATLAB/Simulink de respostas harmônicas.",
                                "Materiais: Efeitos de fadiga em estruturas sob vibração contínua."
                              ],
                              "realWorldApplication": "Na aeroelasticidade, essa equação é usada para prever flutter em asas de aviões, onde excitações harmônicas de vórtices ou turbulência podem amplificar vibrações até falha estrutural, guiando o design de dampers e análise de fadiga em aeronaves como o Boeing 737."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.2",
                            "name": "Determinar a solução particular estacionária",
                            "description": "Assumir solução x_p(t) = D cos(ωt - φ) e calcular amplitude D = F0 / |Z(jω)| e fase φ usando o módulo e argumento da impedância mecânica Z(jω) = -mω² + j c ω + k.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Assumir a forma da solução particular estacionária",
                                  "subSteps": [
                                    "Reconheça que para excitações harmônicas F(t) = F0 cos(ωt), a solução particular estacionária é da forma x_p(t) = D cos(ωt - φ), onde D é a amplitude e φ é a fase.",
                                    "Justifique a escolha dessa forma: ela corresponde à frequência de excitação ω, assumindo regime permanente (ignorando transitórios).",
                                    "Escreva a equação de movimento: mẍ + cẋ + kx = F0 cos(ωt).",
                                    "Expresse x_p(t) em termos de seno e cosseno para derivadas: ẋ_p = -D ω sin(ωt - φ), ẍ_p = -D ω² cos(ωt - φ).",
                                    "Substitua na equação e colete termos para preparar a comparação com a força."
                                  ],
                                  "verification": "Confirme que a forma assumida satisfaz a equação diferencial substituindo e obtendo coeficientes de cos(ωt) e sin(ωt) proporcionais a F0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora científica",
                                    "Livro-texto de dinâmica (opcional)"
                                  ],
                                  "tips": "Sempre use a convenção cos(ωt - φ) para alinhar com diagramas fasoriais padrão em engenharia.",
                                  "learningObjective": "Compreender e justificar a forma assumida para soluções estacionárias em sistemas SDOF sob excitação harmônica.",
                                  "commonMistakes": [
                                    "Usar sin(ωt) em vez de cos(ωt - φ)",
                                    "Esquecer o sinal negativo nas derivadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e calcular a impedância mecânica Z(jω)",
                                  "subSteps": [
                                    "Defina Z(jω) = -mω² + j c ω + k, derivada da substituição de x = Re[X e^{jωt}] na equação complexa.",
                                    "Escreva a equação complexa: (-mω² + j c ω + k) X = F0, onde X = D e^{-jφ}.",
                                    "Calcule a parte real: k - mω².",
                                    "Calcule a parte imaginária: c ω.",
                                    "Forme Z(jω) = (k - mω²) + j (c ω)."
                                  ],
                                  "verification": "Verifique se |Z(jω)| > 0 e arg(Z) está entre -π e π.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Folha de exercícios com valores de m, c, k, ω"
                                  ],
                                  "tips": "Lembre-se: Z(jω) é análoga à impedância elétrica Z(jω) = R + j(X_L - X_C).",
                                  "learningObjective": "Construir a impedância mecânica complexa a partir dos parâmetros do sistema.",
                                  "commonMistakes": [
                                    "Inverter o sinal de -mω²",
                                    "Esquecer o 'j' na parte amortecedora"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a amplitude D",
                                  "subSteps": [
                                    "Calcule o módulo |Z(jω)| = sqrt( (k - mω²)^2 + (c ω)^2 ).",
                                    "Aplique a fórmula D = F0 / |Z(jω)|.",
                                    "Substitua valores numéricos se disponíveis.",
                                    "Verifique unidades: D em metros se F0 em N, m em kg, etc.",
                                    "Compare com frequência natural ω_n = sqrt(k/m) para discutir amplificação."
                                  ],
                                  "verification": "Confirme que D diminui com amortecimento c e tem pico perto de ω ≈ ω_n.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora gráfica para sqrt",
                                    "Exemplo numérico impresso"
                                  ],
                                  "tips": "Use diagrama de Bode mentalmente: |Z| mínimo em ressonância para D máximo.",
                                  "learningObjective": "Determinar a amplitude de deslocamento estacionário usando o módulo da impedância.",
                                  "commonMistakes": [
                                    "Esquecer sqrt no módulo",
                                    "Dividir por Z em vez de |Z|"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular a fase φ",
                                  "subSteps": [
                                    "Calcule o argumento φ = arg(Z(jω)) = atan2( c ω , k - mω² ), onde atan2 considera o quadrante.",
                                    "Note que φ = -arg(Z(jω)) para x_p atrasar a força.",
                                    "Para ω << ω_n, φ ≈ 0°; ω >> ω_n, φ ≈ 180°; ressonância, φ ≈ 90°.",
                                    "Expresse φ em graus ou radianos conforme convenção.",
                                    "Verifique consistência com diagrama fasorial."
                                  ],
                                  "verification": "Plote φ vs ω: deve aumentar monotonicamente de 0 a 180°.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora com atan2",
                                    "Gráfico de fase de referência"
                                  ],
                                  "tips": "Use atan2(imag, real) para sinal correto; evite atan simples.",
                                  "learningObjective": "Determinar o atraso de fase usando o argumento da impedância.",
                                  "commonMistakes": [
                                    "Usar atan em vez de atan2 (erros de quadrante)",
                                    "Esquecer o sinal negativo para φ"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Montar e verificar a solução particular completa",
                                  "subSteps": [
                                    "Escreva x_p(t) = D cos(ωt - φ), com D e φ calculados.",
                                    "Substitua de volta na equação original para validar.",
                                    "Discuta condições: regime estacionário após t >> 1/ζω_n.",
                                    "Opcional: expresse em forma senoidal ou complexa.",
                                    "Registre valores finais em tabela."
                                  ],
                                  "verification": "Substituição na EDO resulta em identidade (esquerda = F0 cos(ωt)).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para substituição",
                                    "Software como MATLAB para plot (opcional)"
                                  ],
                                  "tips": "Sempre valide numericamente com um caso teste simples.",
                                  "learningObjective": "Sintetizar D e φ na solução estacionária e verificar consistência.",
                                  "commonMistakes": [
                                    "Confundir φ com -φ na forma final",
                                    "Ignorar regime estacionário"
                                  ]
                                }
                              ],
                              "practicalExample": "Para m=1 kg, c=0.2 Ns/m, k=100 N/m, F0=10 N, ω=9.8 rad/s: ω_n≈10 rad/s. Z(jω)= (100-1*96.04) + j(0.2*9.8) ≈ 3.96 + j1.96. |Z|≈4.42, D=10/4.42≈2.26 m. φ=atan2(1.96,3.96)≈26.3°. x_p(t)=2.26 cos(9.8t - 26.3°).",
                              "finalVerifications": [
                                "Calcula corretamente Z(jω) para valores dados.",
                                "Amplitude D bate com fórmula e unidades corretas.",
                                "Fase φ usa atan2 corretamente e está no intervalo esperado.",
                                "Solução x_p(t) substitui na EDO sem resíduos.",
                                "Discute qualitativamente comportamento em baixas/altas frequências.",
                                "Identifica ressonância aproximada."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de Z, |Z| e arg(Z) (erro <1%).",
                                "Correta justificativa da forma x_p(t).",
                                "Uso apropriado de convenções fasoriais.",
                                "Validação por substituição na EDO.",
                                "Interpretação física (ex: amplificação em ressonância).",
                                "Clareza na apresentação da solução final."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Números complexos, módulo e argumento.",
                                "Engenharia Elétrica: Analogia com circuitos RLC (impedância elétrica).",
                                "Programação: Simulação em Python/MATLAB de resposta harmônica.",
                                "Física Geral: Oscilações forçadas e ressonância.",
                                "Controle de Sistemas: Diagramas de Bode para magnitude e fase."
                              ],
                              "realWorldApplication": "Em aeroelasticidade, determina amplitudes de vibração de asas sob cargas harmônicas (ex: turbulência), essencial para evitar flutter e fadiga estrutural em aeronaves."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.3",
                            "name": "Calcular a solução geral incluindo transitória",
                            "description": "Combinar solução homogênea (decaindo exponencialmente) com particular, aplicando condições iniciais para determinar constantes e analisar o regime transitório versus estacionário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e formular a solução homogênea",
                                  "subSteps": [
                                    "Relembrar a equação característica da EDO homogênea: mẍ + cẋ + kx = 0.",
                                    "Resolver a equação característica para raízes (subamortecido, crítico ou sobreamortecido).",
                                    "Escrever a solução homogênea x_h(t) com constantes arbitrárias C1 e C2, considerando decaimento exponencial.",
                                    "Verificar se x_h(t) satisfaz a EDO homogênea.",
                                    "Analisar o fator de decaimento exponencial e sua relação com o regime transitório."
                                  ],
                                  "verification": "Substituir x_h(t) na EDO homogênea resulta em zero; plotar x_h(t) mostra decaimento para zero.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, calculadora científica, software de plotagem como Desmos ou MATLAB.",
                                  "tips": "Sempre normalize as raízes para frequência natural ω_n e razão de amortecimento ζ.",
                                  "learningObjective": "Compreender a natureza transitória da solução homogênea em sistemas SDOF.",
                                  "commonMistakes": "Esquecer o termo exponencial e^{-ζω_n t} ou confundir raízes complexas com reais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar a solução particular para excitação harmônica",
                                  "subSteps": [
                                    "Identificar a forma da excitação F(t) = F_0 cos(ωt) ou sen(ωt).",
                                    "Assumir forma particular x_p(t) = D cos(ωt - φ) ou componentes cos e sen.",
                                    "Calcular derivadas ẋ_p e ẍ_p e substituir na EDO não-homogênea.",
                                    "Resolver o sistema para amplitude D e fase φ usando módulo e argumento.",
                                    "Verificar limites: resposta em regime permanente quando ω << ω_n ou ω >> ω_n."
                                  ],
                                  "verification": "Substituir x_p(t) na EDO completa resulta no lado direito F(t)/m.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora com funções trigonométricas, tabela de fatores de amplificação.",
                                  "tips": "Use a forma complexa e^{iωt} para simplificar cálculos de amplitude e fase.",
                                  "learningObjective": "Dominar o método de coeficientes indeterminados para forçamentos harmônicos.",
                                  "commonMistakes": "Não dividir por m na amplitude ou ignorar o denominador |1 - (ω/ω_n)^2 + i(2ζω/ω_n)|."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formar a solução geral",
                                  "subSteps": [
                                    "Escrever x(t) = x_h(t) + x_p(t).",
                                    "Confirmar que x_h satisfaz homogênea e x_p a particular.",
                                    "Discutir como x_h decai exponencialmente, deixando x_p como regime estacionário.",
                                    "Plotar qualitativamente x(t) inicial vs longo prazo.",
                                    "Verificar linearidade: solução geral é soma única."
                                  ],
                                  "verification": "x(t) satisfaz EDO completa e condições de contorno iniciais (ainda não aplicadas).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Gráficos manuais ou software como Python/MATLAB para visualização.",
                                  "tips": "Lembre-se: solução geral é válida para todo t > 0.",
                                  "learningObjective": "Entender a superposição de soluções transitória e estacionária.",
                                  "commonMistakes": "Confundir x_p como total em vez de particular; esquecer soma."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar condições iniciais para determinar constantes",
                                  "subSteps": [
                                    "Dadas x(0) = x_0 e ẋ(0) = v_0.",
                                    "Calcular x_h(0) + x_p(0) = x_0 para C1, C2 (ajustar forma de x_h).",
                                    "Derivar ẋ(t), avaliar em t=0 para segunda equação.",
                                    "Resolver sistema linear 2x2 para C1 e C2.",
                                    "Substituir de volta em x(t)."
                                  ],
                                  "verification": "Verificar x(0) = x_0 e ẋ(0) = v_0 com valores numéricos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora matricial ou simbólica (SymPy), papel para sistema.",
                                  "tips": "Expanda sen/cos em t=0: cos(0)=1, sen(0)=0 para simplificar.",
                                  "learningObjective": "Aplicar condições iniciais corretamente em soluções combinadas.",
                                  "commonMistakes": "Derivar incorretamente ẋ_h(t) ou esquecer derivada de x_p(t)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar regimes transitório e estacionário",
                                  "subSteps": [
                                    "Identificar transitório: contribuição de x_h(t) que decai com τ = 1/(ζω_n).",
                                    "Estacionário: x_p(t) dominante para t >> τ.",
                                    "Calcular tempo de assentamento (e.g., 4-5 τ).",
                                    "Plotar x(t) vs t mostrando transição.",
                                    "Discutir impacto de ζ e ω/ω_n na transição."
                                  ],
                                  "verification": "Para t grande, |x_h(t)| < 1% de pico; matches x_p(t).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software de simulação (MATLAB ode45 ou Python scipy.integrate).",
                                  "tips": "Simule numericamente para validar analítica.",
                                  "learningObjective": "Diferenciar e quantificar regimes dinâmicos.",
                                  "commonMistakes": "Ignorar que transitório depende de condições iniciais, não só parâmetros."
                                }
                              ],
                              "practicalExample": "Para um sistema m=1 kg, k=100 N/m, c=2 Ns/m, F(t)=10 cos(5t) N, x(0)=0, ẋ(0)=0: ω_n=10 rad/s, ζ=0.1. Solução homogênea x_h=A e^{-t} cos(9.95t - ψ). Particular x_p ≈ 0.099 cos(5t - φ). Aplicar ICs dá A, ψ. Transitório decai em ~40s, estacionário amplificado por ressonância próxima.",
                              "finalVerifications": [
                                "Solução geral satisfaz EDO em todos os pontos testados.",
                                "Condições iniciais x(0) e ẋ(0) atendidas exatamente.",
                                "Plot de x(t) mostra decaimento transitório para estacionário.",
                                "Amplitude e fase de x_p coincidem com diagrama de Bode.",
                                "Simulação numérica sobrepõe solução analítica com erro <1%.",
                                "Tempo de assentamento calculado corretamente via ζω_n."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na solução homogênea e particular (sem erros algébricos).",
                                "Correta aplicação de condições iniciais e resolução de constantes.",
                                "Análise qualitativa/quantitativa clara de transitório vs estacionário.",
                                "Uso apropriado de formas trigonométricas e complexas.",
                                "Visualizações (plots) inclusas e interpretadas corretamente.",
                                "Identificação de erros potenciais e limitações (e.g., amortecimento baixo)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Resolução de EDOs lineares com coeficientes constantes.",
                                "Física: Dinâmica de osciladores amortecidos e ressonância.",
                                "Engenharia de Controle: Análise de estabilidade e resposta em frequência.",
                                "Programação: Simulação numérica com ODE solvers em Python/MATLAB."
                              ],
                              "realWorldApplication": "Em aeroelasticidade, calcular resposta transitória de asas a rajadas harmônicas para prever flutter ou fadiga; otimizar amortecedores em fuselagens para reduzir vibrações durante decolagem até cruzeiro estacionário."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.2",
                        "name": "Fenômeno de Ressonância em Sistemas SDOF",
                        "description": "Análise do comportamento da resposta em amplitude e fase quando a frequência de excitação ω se aproxima da frequência natural ω_n, destacando amplificação máxima e condições de amortecimento.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.2.1",
                            "name": "Identificar condições de ressonância",
                            "description": "Definir ressonância principal como ω ≈ ω_n (para amortecimento leve), calcular razão de amplificação máxima 1/(2ζ) onde ζ = c/(2√(km)) e discutir deslocamento de pico para ω > ω_n em sistemas amortecidos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Frequência Natural e Resposta Harmônica em SDOF",
                                  "subSteps": [
                                    "Calcule a frequência natural não amortecida ω_n = √(k/m), onde k é a rigidez e m a massa.",
                                    "Revise a equação de movimento para excitação harmônica: mẍ + cẋ + kx = F_0 cos(ωt).",
                                    "Derive ou memorize a razão de deslocamento em estado estacionário: |X|/X_st = 1 / √[(1 - r²)² + (2ζr)²], onde r = ω/ω_n e ζ = c/(2√(km)).",
                                    "Plote mentalmente ou esboce a curva de amplificação em função de r para ζ baixo.",
                                    "Identifique o pico na curva como indicador de ressonância."
                                  ],
                                  "verification": "Esboce corretamente a curva de amplificação |X|/X_st vs. r e rotule ω_n.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Caderno e lápis",
                                    "Calculadora",
                                    "Gráfico de resposta harmônica de referência"
                                  ],
                                  "tips": "Use r = ω/ω_n para normalizar e simplificar análises.",
                                  "learningObjective": "Compreender a base matemática da resposta dinâmica harmônica em SDOF.",
                                  "commonMistakes": "Confundir frequência natural ω_n com frequência amortecida ω_d = ω_n √(1-ζ²)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Identificar Condições de Ressonância Principal",
                                  "subSteps": [
                                    "Defina ressonância principal como a condição onde ω ≈ ω_n para sistemas com amortecimento leve (ζ < 0.1).",
                                    "Explique que nessa condição, a amplitude de oscilação atinge um máximo devido à coincidência de frequências.",
                                    "Discuta o critério qualitativo: quando a frequência de excitação é próxima à natural do sistema.",
                                    "Compare com ressonância em velocidade (ω = ω_n / √(1-2ζ²)) e aceleração, focando na principal.",
                                    "Aplique o conceito a um exemplo simples: pêndulo forçado."
                                  ],
                                  "verification": "Escreva a definição precisa e identifique ω ≈ ω_n em um gráfico de amplificação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha com equações de SDOF",
                                    "Software de plotagem como Desmos ou MATLAB (opcional)"
                                  ],
                                  "tips": "Para ζ → 0, o pico ocorre exatamente em r=1; visualize isso.",
                                  "learningObjective": "Identificar precisamente quando ocorre ressonância principal em sistemas levemente amortecidos.",
                                  "commonMistakes": "Ignorar o papel do amortecimento e assumir ressonância sempre em ω = ω_n."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Razão de Amplificação Máxima",
                                  "subSteps": [
                                    "Calcule o fator de amortecimento ζ = c / (2 √(k m)).",
                                    "Determine a amplificação máxima aproximada: 1/(2ζ) para ζ pequeno, derivada de maximizar |X|/X_st.",
                                    "Resolva analiticamente o máximo encontrando d/dr (|X|/X_st) = 0, confirmando ≈1/(2ζ) em r≈1.",
                                    "Compute numericamente para um exemplo: m=1kg, k=100N/m, c=0.2Ns/m → ζ=0.1, amplificação≈5.",
                                    "Valide com gráfico ou simulação."
                                  ],
                                  "verification": "Calcule corretamente 1/(2ζ) para valores dados e compare com fórmula exata.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Planilha Excel ou Python para cálculos",
                                    "Tabela de valores de exemplo"
                                  ],
                                  "tips": "A aproximação 1/(2ζ) é excelente para ζ<0.2; use para estimativas rápidas.",
                                  "learningObjective": "Calcular quantitativamente a magnitude da ressonância.",
                                  "commonMistakes": "Esquecer de normalizar X_st = F_0 / k ou errar a fórmula de ζ."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Deslocamento do Pico de Ressonância em Sistemas Amortecidos",
                                  "subSteps": [
                                    "Explique que para ζ>0, o pico de |X| ocorre em r >1, especificamente r_max ≈ 1 / √(1-2ζ²).",
                                    "Discuta como o amortecimento 'desloca' o pico para frequências de excitação maiores que ω_n.",
                                    "Compare curvas para ζ=0, 0.05, 0.2: observe estreitamento e deslocamento.",
                                    "Quantifique o deslocamento: para ζ pequeno, Δr ≈ 2ζ².",
                                    "Relacione ao fenômeno físico: fase e dissipação de energia."
                                  ],
                                  "verification": "Plote ou descreva curvas para diferentes ζ e identifique r>1 para o pico.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Software de simulação (MATLAB/Simulink ou Python Matplotlib)",
                                    "Referência teórica de Dinâmica"
                                  ],
                                  "tips": "Simule variações de ζ para visualizar o efeito intuitivamente.",
                                  "learningObjective": "Entender e discutir os efeitos do amortecimento na localização da ressonância.",
                                  "commonMistakes": "Assumir pico sempre em ω=ω_n, ignorando deslocamento em sistemas reais."
                                }
                              ],
                              "practicalExample": "Em uma hélice de aeronave com massa m=10kg, rigidez torsional k=1000N.m/rad e amortecimento c=20Ns/m (ζ≈0.1), calcule ω_n≈10 rad/s. Se o motor gira a 950 RPM (ω≈99 rad/s ≈ω_n), a amplitude vibracional máxima será ≈1/(2*0.1)=5 vezes a estática, risco de fadiga; adicione amortecedores para mitigar.",
                              "finalVerifications": [
                                "Defina corretamente ressonância como ω ≈ ω_n para ζ leve.",
                                "Calcule ζ e 1/(2ζ) com precisão para exemplo dado.",
                                "Identifique deslocamento do pico para ω > ω_n em gráfico.",
                                "Explique impacto físico da amplificação em estruturas aeroespaciais.",
                                "Compare aproximações vs. soluções exatas para ζ=0.05 e 0.2.",
                                "Resolva problema numérico completo de identificação de ressonância."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de ω_n, ζ e condição de ressonância (30%).",
                                "Correção nos cálculos de amplificação máxima e deslocamento (30%).",
                                "Qualidade de gráficos e visualizações de curvas (15%).",
                                "Profundidade na discussão de efeitos do amortecimento (15%).",
                                "Aplicação coerente a exemplo prático aeroespacial (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Física Geral: Oscilações harmônicas e amortecimento.",
                                "Engenharia Elétrica: Circuitos RLC análogos à ressonância mecânica.",
                                "Matemática: Análise de máximos em funções e derivadas.",
                                "Controle de Sistemas: Estabilidade e resposta em malha aberta."
                              ],
                              "realWorldApplication": "Em aeroelasticidade, identificar ressonância previne falhas como flutter em asas ou vibrações excessivas em fuselagens causadas por motores ou fluxo de ar harmônico, essencial para certificação de aeronaves pela FAA/EASA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.2",
                            "name": "Analisar curvas de resposta em amplitude e fase",
                            "description": "Plotar e interpretar |X(ω)/X_st| = 1 / √[(1 - (ω/ω_n)²)² + (2ζ ω/ω_n)²] e tan φ = 2ζ (ω/ω_n) / (1 - (ω/ω_n)²), identificando picos e transições de fase de 0° a 180°.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais e fórmulas de resposta harmônica",
                                  "subSteps": [
                                    "Relembrar os parâmetros chave: ω_n (frequência natural), ζ (razão de amortecimento), ω (frequência de excitação), X_st (amplitude estática).",
                                    "Derivar ou memorizar a fórmula de magnitude: |X(ω)/X_st| = 1 / √[(1 - (ω/ω_n)²)² + (2ζ ω/ω_n)²].",
                                    "Derivar ou memorizar a fórmula de fase: tan φ = 2ζ (ω/ω_n) / (1 - (ω/ω_n)²).",
                                    "Identificar regimes: ω << ω_n (resposta quasi-estática), ω ≈ ω_n (ressonância), ω >> ω_n (resposta inercial).",
                                    "Calcular manualmente valores para ζ=0.1, 0.5, 1.0 em pontos chave (ω/ω_n = 0, 1, 2)."
                                  ],
                                  "verification": "Listar corretamente as fórmulas e calcular 3 pontos de magnitude e fase com erro <5%.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Folha de papel, calculadora, livro-texto de dinâmica (ex: Thomson ou Rao), tabela de valores trigonométricos.",
                                  "tips": "Use r = ω/ω_n para simplificar notação e plotar vs. r.",
                                  "learningObjective": "Compreender os componentes matemáticos das curvas de resposta em amplitude e fase.",
                                  "commonMistakes": "Confundir ω_n com ω; esquecer o sinal da fase (de 0° a -180° para sistemas subamortecidos)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Plotar curvas de resposta em amplitude para diferentes valores de ζ",
                                  "subSteps": [
                                    "Definir range de r = ω/ω_n de 0 a 3 com 50 pontos.",
                                    "Implementar a fórmula de magnitude em software (ex: Python com NumPy/Matplotlib ou MATLAB).",
                                    "Plotar curvas para ζ = 0.05, 0.2, 0.5, 1.0 em gráfico logarítmico de magnitude vs. r (dB).",
                                    "Identificar picos: localização (r_peak ≈ 1/√(1-2ζ²)), magnitude máxima.",
                                    "Medir largura de banda em -3dB e fator de qualidade Q = ω_n / Δω."
                                  ],
                                  "verification": "Gerar plots com picos corretos (ex: para ζ=0.05, peak ~14 em r~1.04) e rotular eixos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Computador com Python (NumPy, Matplotlib) ou MATLAB, template de código pronto.",
                                  "tips": "Use escala log para amplitude para visualizar melhor picos altos em baixos ζ.",
                                  "learningObjective": "Dominar a plotagem e visualização da dependência da amplitude em ζ e r.",
                                  "commonMistakes": "Escala errada (linear vs log); não normalizar por X_st; plotar φ ao invés de |X|."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Plotar e interpretar curvas de resposta em fase",
                                  "subSteps": [
                                    "Implementar φ = atan2(2ζ r, 1 - r²) para capturar o quadrante correto (de 0° a -180°).",
                                    "Plotar φ vs. r para os mesmos ζ do Step 2.",
                                    "Identificar transições: φ= -90° em r=1; crossover de fase em r=1/√(1+2ζ²) e r=√(1+2ζ²).",
                                    "Comparar curvas de fase com amplitude: pico de amplitude em ~90° de defasagem.",
                                    "Simular animação de φ variando com ω para visualização dinâmica."
                                  ],
                                  "verification": "Plots mostram transição suave de 0° a -180° com φ=-90° exatamente em r=1 para todos ζ.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Mesmo software do Step 2, função atan2 documentada.",
                                  "tips": "Sempre use atan2(imag, real) para fase correta; plote em graus para intuição.",
                                  "learningObjective": "Entender como a fase revela o balanço entre rigidez, massa e amortecimento.",
                                  "commonMistakes": "Usar atan simples (perde sinal); inverter numerador/denominador da tan φ."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar curvas completas e identificar fenômenos chave",
                                  "subSteps": [
                                    "Sobrepor amplitude e fase no mesmo gráfico (amplitude em eixo duplo).",
                                    "Analisar ressonância: condições de pico, efeito de ζ na amplificação e damping.",
                                    "Identificar zonas: quasi-estática (φ~0°, |X|~1), ressonância (pico), inercial (φ~-180°, |X|~1/r²).",
                                    "Prever comportamentos: risco de fadiga em baixos ζ, estabilidade em altos ζ.",
                                    "Exercício: Dado plot, estimar ζ desconhecido de largura de banda ou peak."
                                  ],
                                  "verification": "Relatório descreve corretamente 5 características chave por curva, com estimativa de ζ <10% erro.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Plots gerados, régua para medições, template de relatório.",
                                  "tips": "Anote r_peak e |X|_max para tabela comparativa entre ζ.",
                                  "learningObjective": "Integrar amplitude e fase para análise qualitativa e quantitativa de ressonância.",
                                  "commonMistakes": "Ignorar escala log afetando largura de banda; confundir fase +180° com -180°."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar análise a cenários aeroespaciais",
                                  "subSteps": [
                                    "Escolher caso: asa com ω_n=10 Hz, ζ=0.02 sob turbulência harmônica.",
                                    "Plotar e interpretar curvas para prever amplitudes perigosas.",
                                    "Calcular fator de segurança: margem até peak = 1/ζ.",
                                    "Discutir mitigação: aumentar ζ via dampers.",
                                    "Validar com dados simulados ou experimentais de literatura."
                                  ],
                                  "verification": "Análise prevê corretamente zona de ressonância e recomendações.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Dados de exemplo (ex: de NASA reports), software de plotagem.",
                                  "tips": "Comece com ζ realista aeroespacial (0.01-0.05 para flutter).",
                                  "learningObjective": "Conectar teoria a aplicações práticas em aeroelasticidade.",
                                  "commonMistakes": "Usar ζ irreais (ex: >0.7 para estruturas leves); ignorar não-linearidades."
                                }
                              ],
                              "practicalExample": "Em uma asa de aeronave com frequência natural ω_n = 5 Hz e ζ = 0.03, plote as curvas para excitação de esteira vortical em ω = 4-6 Hz. Identifique o pico de amplitude em r ≈ 1.04 com amplificação ~17x, e fase cruzando -90° em ressonância, prevendo vibrações perigosas que podem levar a fadiga estrutural.",
                              "finalVerifications": [
                                "Plots de amplitude mostram picos decrescendo com ζ crescente.",
                                "Curvas de fase transitam monotonicamente de 0° a -180° com -90° em r=1.",
                                "Largura de banda Δr aumenta com ζ (ex: ζ=0.05: Δr~0.1; ζ=0.5: Δr~1).",
                                "Estimativa de ζ de plots com erro <15%.",
                                "Descrição correta de 3 zonas de resposta.",
                                "Identificação precisa de condições de ressonância."
                              ],
                              "assessmentCriteria": [
                                "Precisão das fórmulas e plots (sem erros numéricos >5%).",
                                "Qualidade visual dos gráficos (rótulos, escalas corretas, legendas).",
                                "Profundidade da interpretação (picos, fase, largura de banda).",
                                "Correta identificação de erros comuns e mitigação.",
                                "Aplicação contextual a aeroespacial com recomendações práticas.",
                                "Relatório claro e estruturado com cálculos suportados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa (resposta em números complexos X(ω) = X_st / (1 - r² + 2iζr)).",
                                "Programação: NumPy/Matplotlib para simulação e visualização de dados.",
                                "Física: Ondas e vibrações harmônicas, equações diferenciais lineares.",
                                "Engenharia de Controle: Diagramas de Bode semelhantes para sistemas de controle."
                              ],
                              "realWorldApplication": "Análise essencial para prevenir flutter e divergência em aeronaves (ex: Tacoma Narrows Bridge análogo), dimensionamento de dampers em satélites, e certificação FAA de estruturas aeroespaciais via testes de vibração harmônica."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.2.3",
                            "name": "Avaliar efeitos do amortecimento na ressonância",
                            "description": "Comparar respostas para ζ = 0 (ressonância infinita), ζ pequeno (Q-fator alto) e ζ crítico, relacionando com aplicações aeroespaciais como fadiga estrutural.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Equação de Resposta Harmônica em Sistemas SDOF",
                                  "subSteps": [
                                    "Derivar a equação de movimento para um sistema SDOF sob excitação harmônica: mẍ + cẋ + kx = F₀ cos(ωt).",
                                    "Obter a solução em regime permanente: x(t) = X cos(ωt - φ), onde X é a amplitude estática magnificada.",
                                    "Calcular a razão de amplificação |X/X_st| = 1 / √[(1 - r²)² + (2ζr)²], com r = ω/ω_n e ζ = c/(2√(km)).",
                                    "Identificar o papel do amortecimento ζ na denominação da amplitude.",
                                    "Plotar a curva de resposta em amplitude vs. r para ζ fixo."
                                  ],
                                  "verification": "Plotar corretamente a curva de resposta harmônica e identificar o pico de ressonância em r=1.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Vibrações (ex: Thomson ou Rao), software MATLAB/Python com NumPy/Matplotlib"
                                  ],
                                  "tips": [
                                    "Use números adimensionais (r e ζ) para generalizar; normalize a amplitude por X_st = F₀/k."
                                  ],
                                  "learningObjective": "Dominar a formulação matemática da resposta harmônica e sua dependência em ζ e r.",
                                  "commonMistakes": [
                                    "Confundir amplitude dinâmica com estática",
                                    "Esquecer o fator de magnificação na ressonância",
                                    "Plotar sem normalizar"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Caso Sem Amortecimento (ζ = 0)",
                                  "subSteps": [
                                    "Simplificar a equação para ζ=0: |X/X_st| = 1 / |1 - r²|.",
                                    "Identificar ressonância em r=1, onde amplitude tende ao infinito.",
                                    "Calcular a fase φ: 0° para r<1, 180° para r>1.",
                                    "Simular numericamente ou plotar a curva, destacando o pico infinito.",
                                    "Discutir implicações físicas: energia acumulada ilimitada sem dissipação."
                                  ],
                                  "verification": "Explicar e demonstrar matematicamente a divergência da amplitude em r=1 para ζ=0.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Calculadora simbólica (SymPy ou MATLAB Symbolic), papel e lápis para derivações"
                                  ],
                                  "tips": [
                                    "Lembre-se: sem amortecimento, o sistema oscila com amplitude crescente indefinidamente na ressonância."
                                  ],
                                  "learningObjective": "Compreender o fenômeno de ressonância pura e sua instabilidade prática.",
                                  "commonMistakes": [
                                    "Ignorar a transição abrupta de fase em r=1",
                                    "Confundir com resposta transitória",
                                    "Não reconhecer infinitude como limite teórico"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Efeitos de Amortecimento Pequeno e Crítico",
                                  "subSteps": [
                                    "Para ζ pequeno (ex: 0.01): calcular Q = 1/(2ζ) alto, pico em r ≈1, amplitude máxima ≈ Q.",
                                    "Plotar curvas para ζ=0.01, 0.05 e ζ_crítico=1, observando redução do pico e alargamento da banda.",
                                    "Calcular localização do pico: r_pico ≈ 1 / √(1 - 2ζ²) para ζ<1/√2.",
                                    "Analisar fator de qualidade Q e largura de banda Δr ≈ 2ζ.",
                                    "Comparar numericamente amplitudes em r=1 para diferentes ζ."
                                  ],
                                  "verification": "Gerar plots comparativos mostrando pico alto e estreito para ζ pequeno vs. sem pico para ζ=1.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de plotagem (MATLAB, Python Matplotlib, ou Excel avançado)",
                                    "Tabelas de valores de ζ típicos"
                                  ],
                                  "tips": [
                                    "Use log scale para amplitude para visualizar Q-fator; teste ζ=0.707 para máximo r_pico."
                                  ],
                                  "learningObjective": "Quantificar como ζ controla a severidade da ressonância via Q-fator e deslocamento do pico.",
                                  "commonMistakes": [
                                    "Confundir ζ_crítico com sobreamortecido",
                                    "Errar fórmula de Q como 1/ζ em vez de 1/(2ζ)",
                                    "Não plotar múltiplas curvas para comparação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar com Aplicações Aeroespaciais e Fadiga Estrutural",
                                  "subSteps": [
                                    "Explicar fadiga: ciclos de alta amplitude em ressonância (ζ pequeno) causam acúmulo de dano.",
                                    "Discutir exemplos: vibrações de motores em asas (flutter ou buzz), painéis de fuselagem.",
                                    "Calcular vida útil aproximada via curva S-N e amplitudes de ressonância.",
                                    "Propor mitigação: aumentar ζ com dampers viscoelásticos ou redesenho.",
                                    "Analisar trade-offs: alto ζ reduz ressonância mas aumenta massa/drag."
                                  ],
                                  "verification": "Descrever um caso aeroespacial onde baixo ζ levou a falha e como ζ crítico mitiga.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Artigos sobre flutter (ex: NASA reports), software ANSYS para simulação básica"
                                  ],
                                  "tips": [
                                    "Relacione Q alto com 'buffeting' em aeronaves; consulte casos históricos como Tacoma Narrows (análoga)."
                                  ],
                                  "learningObjective": "Aplicar conceitos de amortecimento em contextos reais de engenharia aeroespacial.",
                                  "commonMistakes": [
                                    "Subestimar efeitos cumulativos da fadiga",
                                    "Ignorar não-linearidades em amplitudes reais",
                                    "Confundir ressonância com instabilidade aerodinâmica"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma viga representando uma asa de avião com ω_n=100 rad/s, F₀=1000N, variando ζ de 0 a 1. Plote respostas e calcule tensão máxima em r=1 para ζ=0.02 (Q≈25), mostrando risco de fadiga com 10^6 ciclos.",
                              "finalVerifications": [
                                "Plotar e interpretar curvas de resposta para ζ=0, 0.02 e 1.",
                                "Calcular corretamente Q-fator e localização do pico para ζ pequeno.",
                                "Explicar infinitude em ζ=0 e ausência de pico em ζ crítico.",
                                "Relacionar alto Q com acelerações elevadas e fadiga em estruturas aeroespaciais.",
                                "Propor método para evitar ressonância via ajuste de ζ.",
                                "Demonstrar compreensão da fase e largura de banda."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas fórmulas de amplitude e Q-fator (90% correto).",
                                "Qualidade e legibilidade dos plots comparativos (rótulos, escalas adequadas).",
                                "Profundidade na análise qualitativa de efeitos de ζ.",
                                "Relevância e acurácia das conexões com fadiga estrutural aeroespacial.",
                                "Criatividade em exemplos práticos e mitigação.",
                                "Capacidade de explicar trade-offs de design (ex: massa vs. amortecimento)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Soluções analíticas de EDOs lineares e análise assintótica.",
                                "Física: Conservação de energia em osciladores amortecidas.",
                                "Engenharia de Materiais: Mecânica da fadiga e curvas S-N.",
                                "Ciência da Computação: Simulação numérica e visualização de dados.",
                                "Engenharia Aeroespacial: Controle de flutter e vibroacústica."
                              ],
                              "realWorldApplication": "Em aeronaves como o Boeing 737, amortecedores ajustáveis nas asas evitam ressonância com frequências de turbinas (ζ≈0.05), prevenindo fadiga que poderia causar falhas estruturais após milhões de ciclos de voo, economizando bilhões em manutenção."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.3",
                        "name": "Diagrama de Bode para Resposta Harmônica",
                        "description": "Representação logarítmica da função de transferência em magnitude (dB) e fase (graus) versus frequência normalizada, facilitando análise de ganho e estabilidade em estruturas aeroespaciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.3.1",
                            "name": "Construir o diagrama de Bode de magnitude",
                            "description": "Plotar 20 log |H(j r)| onde r = ω/ω_n e H(j r) = 1 / [k (-r² + j 2ζ r + 1)], aproximando assíntotas: regime baixo r<<1 (0 dB), corte em r=1 (-40 dB/década) e pico em r ≈ 1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a Função de Transferência e Parâmetros do Sistema SDOF",
                                  "subSteps": [
                                    "Identifique a função de transferência H(s) = 1 / [k (s²/ω_n² + 2ζ s/ω_n + 1)] para o sistema SDOF.",
                                    "Substitua s = jω para obter H(jω) = 1 / [k (-(ω/ω_n)² + j 2ζ (ω/ω_n) + 1)].",
                                    "Defina a variável normalizada r = ω/ω_n.",
                                    "Especifique valores numéricos para k, ζ (ex: 0.05-0.7) e ω_n (ex: 1 rad/s para simplificação).",
                                    "Calcule |H(jr)| = 1 / |k (-r² + j 2ζ r + 1)| explicitamente."
                                  ],
                                  "verification": "Confirme que a expressão de |H(jr)| está correta comparando com fórmula padrão de magnitude para SDOF.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou caderno",
                                    "Calculadora científica",
                                    "Tabela de referência para funções de transferência SDOF"
                                  ],
                                  "tips": "Sempre normalize com r para generalizar o diagrama independentemente de ω_n.",
                                  "learningObjective": "Compreender a forma analítica da magnitude da resposta harmônica em função de r.",
                                  "commonMistakes": "Esquecer o fator k na denominação ou confundir o sinal no termo -r²."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a Magnitude em dB e Identificar Pontos Críticos",
                                  "subSteps": [
                                    "Compute a magnitude em dB: 20 log10 |H(jr)| para vários valores de r (ex: 0.1, 0.5, 1, 1.5, 2, 10).",
                                    "Identifique o regime de baixa frequência (r << 1): |H(jr)| ≈ 1/k → 20 log(1/k) dB (plano 0 dB se k=1).",
                                    "Localize a frequência de ressonância r_res ≈ 1 / sqrt(1 - 2ζ²) e o pico de magnitude.",
                                    "Calcule o fator de amplificação no pico: |H(j r_res)| ≈ 1 / (k * 2ζ sqrt(1 - ζ²)).",
                                    "Anote valores exatos para pelo menos 10 pontos de r em escala logarítmica."
                                  ],
                                  "verification": "Verifique se para r→0, magnitude → 20 log(1/k) dB e para r→∞, cai como -40 dB/década.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou software como Python/MATLAB para log10 e sqrt",
                                    "Planilha Excel para tabulação"
                                  ],
                                  "tips": "Use escala log para r desde 10^-2 até 10^2 para capturar todos os regimes.",
                                  "learningObjective": "Dominar o cálculo numérico da magnitude em dB e localização do pico de ressonância.",
                                  "commonMistakes": "Usar log em vez de log10 ou esquecer o 20 multiplicador para dB."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir as Assíntotas Aproximadas",
                                  "subSteps": [
                                    "Desenhe o eixo log r (x) vs. magnitude dB (y) em papel log-log.",
                                    "Trace assíntota baixa frequência: linha horizontal em 20 log(1/k) dB para r < 0.1.",
                                    "Trace assíntota de corte em r=1 (ω_n), com inclinação -40 dB/década para r > 1.",
                                    "Adicione correção para pico de ressonância: linha vertical em r≈1 subindo até o máximo estimado.",
                                    "Ajuste a assíntota de alta frequência alinhando em r=1 com -40 dB/déc."
                                  ],
                                  "verification": "Confirme que assíntotas se encontram em r=1 com descontinuidade de 0 dB e inclinação correta.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel milimetrado log-log",
                                    "Régua e lápis",
                                    "Software de plotagem como Desmos ou MATLAB"
                                  ],
                                  "tips": "Comece pelas assíntotas principais antes de adicionar o pico para manter simplicidade.",
                                  "learningObjective": "Aprender a aproximar o diagrama de Bode com assíntotas de baixa e alta frequência.",
                                  "commonMistakes": "Confundir inclinação (-20 dB/déc para 1º ordem, mas -40 para 2º ordem) ou posicionar corte errado."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Plotar o Diagrama Completo e Validar",
                                  "subSteps": [
                                    "Plote os pontos calculados exatos sobre as assíntotas.",
                                    "Conecte os pontos com curva suave, mostrando desvio máximo no pico (≈3 dB para ζ baixo).",
                                    "Rotule eixos: log10(r) horizontal, 20 log|H| vertical; marque ω_n, r_res, pico.",
                                    "Compare com diagrama exato gerado numericamente.",
                                    "Anote largura de banda ou Q-factor se aplicável."
                                  ],
                                  "verification": "O diagrama deve mostrar plano baixo, pico próximo a r=1 e decaimento -40 dB/déc; erro <5% nos pontos chave.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráfico semi-log ou software (Python matplotlib, MATLAB bode)",
                                    "Valores tabulados do step 2"
                                  ],
                                  "tips": "Use cores diferentes: vermelho para exato, azul para assíntotas.",
                                  "learningObjective": "Integrar cálculos e assíntotas em um diagrama de Bode preciso e interpretável.",
                                  "commonMistakes": "Não escalar corretamente os eixos log ou ignorar o pico para ζ > 0.707 (sem pico)."
                                }
                              ],
                              "practicalExample": "Para um sistema SDOF com k=1, ζ=0.1, ω_n=10 rad/s: Calcule |H(jr)| para r=0.1 (≈0 dB), r=1 (pico ≈20 dB), r=10 (-40 dB). Assíntotas: 0 dB até r=1, então -40 dB/déc. Plote mostrando pico em r≈0.995.",
                              "finalVerifications": [
                                "Assíntota baixa frequência é horizontal em 20 log(1/k) dB.",
                                "Corte em r=1 com inclinação exata de -40 dB/década.",
                                "Pico de ressonância localizado corretamente próximo a r=1 para ζ<0.707.",
                                "Curva exata segue assíntotas com desvio máximo de 3 dB no pico.",
                                "Eixos rotulados corretamente com escala log em r.",
                                "Valores numéricos batem com cálculos manuais em 3 pontos chave."
                              ],
                              "assessmentCriteria": [
                                "Precisão das assíntotas (inclinação e interseção: 30%)",
                                "Localização e altura do pico de ressonância (25%)",
                                "Cálculos numéricos corretos para |H(jr)| em dB (20%)",
                                "Qualidade visual do plot (rótulos, escalas: 15%)",
                                "Explicação coerente das aproximações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções complexas, logaritmos decimais e escalas log-log.",
                                "Física: Dinâmica de osciladores harmônicos e amortecimento.",
                                "Engenharia de Controle: Análise de frequência para estabilidade.",
                                "Programação: Uso de bibliotecas como numpy/matplotlib para automação."
                              ],
                              "realWorldApplication": "Em aeroelasticidade, usado para prever vibrações ressonantes em asas de aeronaves sob cargas harmônicas (ex: turbulência), evitando flutter crítico ao identificar faixas de frequência perigosas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.3.2",
                            "name": "Construir o diagrama de Bode de fase",
                            "description": "Plotar φ(r) = -atan[2ζ r / (1 - r²)], com assíntotas de 0° (r<<1), -90° (r>>1) e transição rápida em r=1 para ζ pequeno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a fórmula da fase e suas assíntotas",
                                  "subSteps": [
                                    "Revise a fórmula φ(r) = -atan[2ζ r / (1 - r²)], onde r = ω/ω_n é a razão de frequências e ζ é o fator de amortecimento.",
                                    "Identifique os limites assintóticos: para r << 1, φ ≈ 0°; para r >> 1, φ ≈ -90°.",
                                    "Analise o comportamento na ressonância (r ≈ 1): transição rápida para ζ pequeno.",
                                    "Calcule manualmente φ para r=0.1, r=1 e r=10 com ζ=0.1 para validar assíntotas.",
                                    "Anote as características qualitativas da curva de fase."
                                  ],
                                  "verification": "Confirme que os valores calculados aproximam-se das assíntotas: φ(0.1)≈0°, φ(10)≈-90°.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Folha de papel, calculadora científica, tabela de valores trigonométricos.",
                                  "tips": "Use a aproximação tan(θ)≈θ para pequenos ângulos em r<<1.",
                                  "learningObjective": "Compreender matematicamente o comportamento assintótico da fase em função de r e ζ.",
                                  "commonMistakes": "Confundir o sinal negativo da fase ou ignorar o denominador (1 - r²) que causa singularidade em r=1."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar pontos de cálculo e computar φ(r)",
                                  "subSteps": [
                                    "Escolha um valor de ζ (ex: 0.1 para subamortecido) e defina intervalo de r logarítmico: 0.1, 0.2, 0.5, 0.8, 1.0, 1.2, 2, 5, 10.",
                                    "Calcule o argumento do atan: num = 2ζ r, den = 1 - r² para cada r.",
                                    "Compute φ(r) = -atan(num/den) em graus usando calculadora.",
                                    "Registre os pares (r, φ(r)) em uma tabela organizada por escala log em r.",
                                    "Verifique cálculos cruzando com software como Python/MATLAB para pelo menos 3 pontos."
                                  ],
                                  "verification": "Tabela completa com pelo menos 8 pontos onde φ diminui monotonicamente de ~0° a ~-90°.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora ou planilha Excel/Google Sheets, papel quadriculado.",
                                  "tips": "Use escala log para r desde o início para facilitar o plot posterior.",
                                  "learningObjective": "Dominar o cálculo numérico preciso da fase para múltiplos valores de r.",
                                  "commonMistakes": "Erro no sinal do denominador (use abs(den) se necessário, mas compute corretamente); arredondamento excessivo em atan."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Plotar os pontos e assíntotas no diagrama de Bode",
                                  "subSteps": [
                                    "Desenhe eixos: eixo x log(r) de 10^{-1} a 10^1, eixo y φ em graus de 0° a -100°.",
                                    "Marque e plote os pontos calculados (r, φ(r)) com símbolos distintos.",
                                    "Desenhe assíntotas: linha horizontal 0° para r<0.3, -90° para r>3, linha vertical em r=1 como referência.",
                                    "Conecte pontos com curva suave manualmente, respeitando a transição rápida perto de r=1.",
                                    "Adicione rótulos, título 'Diagrama de Bode de Fase para ζ=0.1' e legenda."
                                  ],
                                  "verification": "Gráfico contém todos os pontos plotados corretamente, assíntotas visíveis e curva suave interpolando-os.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel milimetrado ou software de plotagem (Matplotlib, Desmos), régua, compasso.",
                                  "tips": "Para escala log, use papel semilog ou marque ticks logarítmicos manualmente.",
                                  "learningObjective": "Construir visualmente o diagrama de Bode de fase com precisão gráfica.",
                                  "commonMistakes": "Plotar r em escala linear em vez de log; ignorar a curvatura suave entre assíntotas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar, interpretar e refinar o diagrama",
                                  "subSteps": [
                                    "Compare a curva com assíntotas: verifique defasagem máxima ~ -ζ*90° perto de r=1.",
                                    "Interprete: discuta impacto em sistemas aeroespaciais (ex: fase em flutter).",
                                    "Refina adicionando 2-3 pontos extras perto de r=1 se transição não for nítida.",
                                    "Teste sensibilidade variando ζ (ex: ζ=0.5) e replote rapidamente.",
                                    "Documente observações em anotações no gráfico."
                                  ],
                                  "verification": "Diagrama reflete corretamente transição rápida para ζ pequeno; interpretações anotadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Gráfico anterior, calculadora para pontos extras.",
                                  "tips": "Para ζ pequeno, a fase cai quase verticalmente em r=1 – destaque isso.",
                                  "learningObjective": "Interpretar o diagrama de fase e validar sua precisão.",
                                  "commonMistakes": "Subestimar a rapidez da transição para ζ baixo; não anotar interpretações."
                                }
                              ],
                              "practicalExample": "Para um sistema SDOF de asas de aeronave com ζ=0.1 (subamortecido), calcule e plote φ(r) para r de 0.1 a 10. Resultado: fase começa em 0°, cai rapidamente para -90° em torno de r=1, aproximando assíntotas. Use para prever defasagem em excitações harmônicas como turbulência.",
                              "finalVerifications": [
                                "Fórmula φ(r) aplicada corretamente sem erros aritméticos em todos os pontos.",
                                "Assíntotas plotadas precisamente: 0° para r<<1, -90° para r>>1.",
                                "Curva de fase mostra transição abrupta em r=1 para ζ pequeno.",
                                "Escala log em r e graduação em graus no eixo y corretas.",
                                "Gráfico completo com rótulos, legenda e título.",
                                "Interpretação qualitativa anotada (ex: implicações para ressonância)."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos numéricos (erro <5% vs. referência).",
                                "Qualidade gráfica: legibilidade, escalas corretas e suavidade da curva.",
                                "Compreensão das assíntotas e comportamento qualitativo.",
                                "Número e distribuição adequada de pontos calculados.",
                                "Inclusão de interpretações e refinamentos sensíveis a ζ.",
                                "Documentação completa de passos e materiais usados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções trigonométricas (atan), escalas logarítmicas e aproximações assintóticas.",
                                "Física: Dinâmica de osciladores amortecidos e resposta em frequência.",
                                "Programação: Implementação em Python/MATLAB para automação de plots (numpy, matplotlib).",
                                "Engenharia: Análise de sistemas de controle e estabilidade aeroespacial."
                              ],
                              "realWorldApplication": "Em aeroelasticidade, o diagrama de Bode de fase é essencial para prever flutter em asas de aviões, onde a defasagem entre força aerodinâmica e movimento estrutural leva a instabilidades catastróficas; usado no design de aeronaves como o Boeing 737 para evitar ressonâncias harmônicas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.3",
                    "name": "Resposta a Excitações Periódicas",
                    "description": "Decomposição em séries de Fourier e superposição de respostas harmônicas para cargas periódicas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.3.1",
                        "name": "Decomposição em Séries de Fourier de Cargas Periódicas",
                        "description": "Representação de funções periódicas arbitrárias como soma de senos e cossenos harmônicos usando séries de Fourier, identificando o período fundamental e os coeficientes de Fourier para cargas em sistemas SDOF.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.1.1",
                            "name": "Identificar o Período Fundamental e Harmônicos",
                            "description": "Determinar o período fundamental T de uma carga periódica f(t) e calcular as frequências harmônicas ω_n = n * 2π/T para decomposição em componentes senoidais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos de Funções Periódicas e Período Fundamental",
                                  "subSteps": [
                                    "Defina função periódica: f(t + T) = f(t) para todo t, onde T é o período.",
                                    "Explique período fundamental como o menor T > 0 que satisfaz a condição.",
                                    "Diferencie período fundamental de múltiplos inteiros dele.",
                                    "Estude exemplos: senoide (T=2π/ω), onda quadrada, dente de serra.",
                                    "Revise relação entre período T, frequência f=1/T e frequência angular ω=2π/T."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a definição de período fundamental e dê um exemplo correto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráficos de funções periódicas (seno, quadrada, triangular)",
                                    "Video introdutório sobre periodicidade (YouTube ou Khan Academy)",
                                    "Folha de anotações"
                                  ],
                                  "tips": "Visualize sempre graficamente; o período é a distância entre repetições idênticas.",
                                  "learningObjective": "Compreender e definir precisamente o período fundamental de uma função periódica.",
                                  "commonMistakes": [
                                    "Confundir período com amplitude.",
                                    "Escolher múltiplo do período fundamental como T.",
                                    "Ignorar a menor repetição positiva."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o Período Fundamental em Gráficos e Fórmulas",
                                  "subSteps": [
                                    "Analise gráfico: meça distância horizontal entre dois picos consecutivos idênticos.",
                                    "Para funções compostas, encontre o maior denominador comum nos períodos individuais.",
                                    "Use fórmula: para f(t) = g(t mod T), T é explícito.",
                                    "Pratique com gráficos ambíguos: confirme repetição exata em múltiplos ciclos.",
                                    "Registre T com unidades (ex: segundos) e justifique escolha."
                                  ],
                                  "verification": "Identifique T corretamente em 3 gráficos fornecidos, justificando cada um.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Gráficos impressos ou digitais de cargas periódicas (onda quadrada, pulso retangular)",
                                    "Régua ou software como Desmos/GeoGebra",
                                    "Exemplos de problemas resolvidos"
                                  ],
                                  "tips": "Conte ciclos completos (pelo menos 2-3) para confirmar periodicidade.",
                                  "learningObjective": "Aplicar métodos gráficos e analíticos para determinar T de f(t) dada.",
                                  "commonMistakes": [
                                    "Medir de vale a pico em vez de ciclo completo.",
                                    "Assumir T baseado em uma única oscilação.",
                                    "Não verificar se é o menor T."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Frequências Harmônicas a Partir do Período Fundamental",
                                  "subSteps": [
                                    "Lembre fórmula: ω_n = n * (2π / T), onde n=1,2,3,...",
                                    "Calcule ω_1 (fundamental), ω_2 (primeiro harmônico), até n=5.",
                                    "Converta para f_n = n / T se necessário.",
                                    "Liste harmônicos em tabela: n, ω_n, descrição (fundamental, 2ª harmônica, etc.).",
                                    "Verifique unidades: rad/s para ω_n."
                                  ],
                                  "verification": "Calcule e liste ω_n para n=1 a 5 dado T=4s, sem erros de cálculo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Planilha Excel ou papel para tabela",
                                    "Fórmulas anotadas"
                                  ],
                                  "tips": "Sempre comece com ω_1 = 2π/T; multiplique por n sequencialmente.",
                                  "learningObjective": "Calcular precisamente as frequências harmônicas para decomposição de Fourier.",
                                  "commonMistakes": [
                                    "Usar ω_n = n * ω ao invés de n * 2π/T.",
                                    "Confundir rad/s com Hz.",
                                    "Esquecer fator 2π."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Aplicar Identificação em Exemplo Completo",
                                  "subSteps": [
                                    "Escolha f(t) exemplo e identifique T.",
                                    "Calcule harmônicos e plote espectro básico.",
                                    "Compare com decomposição conhecida.",
                                    "Discuta importância em análise de vibrações.",
                                    "Resolva variação: altere T e recalcule."
                                  ],
                                  "verification": "Resolva um problema completo: identifique T e 3 harmônicos, com justificativa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software plotador (MATLAB, Python Matplotlib ou Desmos)",
                                    "Exemplo problema: f(t) quadrada com T=2s",
                                    "Template de relatório"
                                  ],
                                  "tips": "Plote para visualizar; harmônicos aparecem como picos em ω_n.",
                                  "learningObjective": "Integrar identificação de T e cálculo de harmônicos em contexto prático.",
                                  "commonMistakes": [
                                    "Não validar com gráfico após cálculo.",
                                    "Erro propagado de T incorreto."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma carga aerodinâmica periódica f(t) representada por uma onda quadrada: f(t) = 1 para 0 ≤ t < 1s, f(t) = -1 para 1s ≤ t < 2s, repetindo a cada 2s. O período fundamental T=2s. Harmônicos: ω1=π rad/s, ω2=2π rad/s, ω3=3π rad/s, etc. Use para decompor em senoides na análise de resposta SDOF.",
                              "finalVerifications": [
                                "Identifica corretamente T em gráficos complexos com múltiplos ciclos.",
                                "Calcula ω_n exatos para n=1-5 sem erros aritméticos.",
                                "Justifica escolha de T como fundamental (menor positivo).",
                                "Lista harmônicos em tabela com unidades corretas.",
                                "Aplica conceito a exemplo não-senoidal.",
                                "Explica relação com séries de Fourier."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de T (100% correto em 4/5 exemplos).",
                                "Correção matemática nos cálculos de ω_n (erro <1%).",
                                "Qualidade da justificativa e verificação gráfica.",
                                "Completude da tabela de harmônicos (n=1-5 mínimo).",
                                "Clareza na explicação de conceitos fundamentais.",
                                "Aplicação contextual em aeroelasticidade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries de Fourier e análise harmônica.",
                                "Física: Ondas mecânicas e vibrações em sistemas SDOF.",
                                "Engenharia Aeroespacial: Análise de flutter e resposta a cargas periódicas.",
                                "Processamento de Sinais: Espectro de frequência em dados vibracionais.",
                                "Informática: Simulações numéricas em Python/MATLAB."
                              ],
                              "realWorldApplication": "Na dinâmica de estruturas aeroespaciais, identificar o período fundamental de cargas aerodinâmicas periódicas (ex: buffeting em asas) permite decompor em harmônicos para análise em domínio de frequência, prevendo ressonâncias e fadiga em aeronaves, essencial para certificação de segurança pela FAA/EASA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.2",
                            "name": "Calcular Coeficientes de Fourier a_n e b_n",
                            "description": "Computar os coeficientes de Fourier a_0, a_n = (2/T) ∫ f(t) cos(nωt) dt e b_n = (2/T) ∫ f(t) sen(nωt) dt para uma dada função periódica f(t) no intervalo [0, T].",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a função periódica e definir parâmetros fundamentais",
                                  "subSteps": [
                                    "Analise a função f(t) dada e confirme seu período T.",
                                    "Calcule a frequência angular fundamental ω = 2π/T.",
                                    "Defina o intervalo de integração [0, T].",
                                    "Esboce graficamente f(t) para visualizar simetrias (par, ímpar).",
                                    "Prepare ferramentas para integração simbólica ou numérica."
                                  ],
                                  "verification": "Lista completa de parâmetros (T, ω, f(t)) anotada e gráfico esboçado corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora gráfica",
                                    "Software como MATLAB ou Python (SymPy)"
                                  ],
                                  "tips": "Explore simetrias: funções pares simplificam bn=0, ímpares an=0.",
                                  "learningObjective": "Dominar setup inicial para decomposição de Fourier.",
                                  "commonMistakes": [
                                    "Confundir intervalo [0,T] com [-T/2,T/2]",
                                    "Erro no cálculo de ω",
                                    "Ignorar periodicidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o coeficiente a0 (termo constante)",
                                  "subSteps": [
                                    "Escreva a fórmula: a0 = (1/T) ∫_0^T f(t) dt.",
                                    "Integre f(t) sobre [0,T].",
                                    "Multiplique pelo fator 1/T.",
                                    "Simplifique a expressão analiticamente.",
                                    "Verifique dimensionalmente o resultado."
                                  ],
                                  "verification": "Valor de a0 computado e igual à média de f(t) ao longo de um período.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Folha de cálculo",
                                    "Tabelas de integrais indefinidas",
                                    "Software de simbólico (ex: Wolfram Alpha)"
                                  ],
                                  "tips": "a0/2 é o termo DC na série; compare com valor médio gráfico.",
                                  "learningObjective": "Computar com precisão o componente médio da função periódica.",
                                  "commonMistakes": [
                                    "Usar 2/T em vez de 1/T para a0",
                                    "Limites de integração errados",
                                    "Esquecer simplificação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular os coeficientes a_n para n = 1, 2, ...",
                                  "subSteps": [
                                    "Escreva a fórmula: a_n = (2/T) ∫_0^T f(t) cos(n ω t) dt.",
                                    "Escolha valores específicos de n (ex: 1 a 5).",
                                    "Compute a integral para cada n, usando integração por partes se necessário.",
                                    "Aplique o fator 2/T e simplifique.",
                                    "Registre valores numéricos aproximados para verificação."
                                  ],
                                  "verification": "Coeficientes a_n decrescem com n e coincidem com simetria par da função.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Calculadora simbólica",
                                    "Livro de tabelas de integrais de Fourier",
                                    "Python/MATLAB para plotar"
                                  ],
                                  "tips": "Para funções pares, bn=0; integre por partes repetidamente para polinômios.",
                                  "learningObjective": "Dominar cálculo dos componentes cosseno na expansão de Fourier.",
                                  "commonMistakes": [
                                    "Fator 1/T em vez de 2/T",
                                    "Erro no argumento cos(n ω t)",
                                    "Não truncar para n finito"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular os coeficientes b_n para n = 1, 2, ...",
                                  "subSteps": [
                                    "Escreva a fórmula: b_n = (2/T) ∫_0^T f(t) sin(n ω t) dt.",
                                    "Para cada n selecionado, compute a integral.",
                                    "Aplique o fator 2/T e simplifique analiticamente.",
                                    "Compare com simetria ímpar (an=0 para funções ímpares).",
                                    "Calcule módulo |c_n| = sqrt(a_n² + b_n²) para amplitude."
                                  ],
                                  "verification": "Série parcial reconstrói f(t) com erro pequeno em pontos testados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Mesmos do step 3",
                                    "Gráficos para superposição"
                                  ],
                                  "tips": "Use propriedades de ortogonalidade para validação numérica.",
                                  "learningObjective": "Computar componentes seno e validar decomposição completa.",
                                  "commonMistakes": [
                                    "Confundir sen com cos",
                                    "Fator incorreto",
                                    "Integração indefinida sem limites"
                                  ]
                                }
                              ],
                              "practicalExample": "Para f(t) = t no intervalo [0, 2π] (onda dente de serra, T=2π, ω=1): a0 = π, a_n = 0 (por simetria ímpar em [-π,π]), b_n = (-1)^{n+1} * 2/n. Compute para n=1: b1 = 2, n=2: b2 = -1.",
                              "finalVerifications": [
                                "Coeficientes a0, a_n, b_n calculados corretamente para pelo menos 3 valores de n.",
                                "Reconstrução da série de Fourier parcial aproxima f(t) em 5 pontos do intervalo.",
                                "Simetrias exploradas e aplicadas para simplificação.",
                                "Valores numéricos coincidem com resultados conhecidos ou software.",
                                "Gráfico da soma parcial vs. f(t) mostra convergência.",
                                "Dimensões e unidades consistentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas integrais (erro <1%).",
                                "Correta aplicação de fórmulas e fatores normalizadores.",
                                "Uso efetivo de simetrias para redução computacional.",
                                "Validação por reconstrução gráfica ou numérica.",
                                "Clareza na documentação de cálculos passo a passo.",
                                "Eficiência no tempo e recursos utilizados."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de vibrações e ressonância em estruturas aeroespaciais.",
                                "Engenharia: Modelagem de cargas periódicas em asas de aeronaves.",
                                "Matemática: Teoria de séries e análise harmônica.",
                                "Computação: Implementação numérica em Python/MATLAB para FFT.",
                                "Mecânica: Resposta dinâmica SDOF a excitações periódicas."
                              ],
                              "realWorldApplication": "Em dinâmica aeroelástica, calcular coeficientes de Fourier de cargas aerodinâmicas periódicas (ex: buffeting em asas) para prever resposta vibracional de estruturas SDOF, evitando fadiga e flutter em aeronaves."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.3.1.3",
                            "name": "Reconstruir a Função Periódica pela Série de Fourier",
                            "description": "Escrever a expressão f(t) ≈ a_0/2 + Σ [a_n cos(nωt) + b_n sen(nωt)] e verificar a aproximação para funções como dente de serra ou quadrada em contextos aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os Fundamentos da Série de Fourier",
                                  "subSteps": [
                                    "Estude a fórmula geral da série de Fourier para funções periódicas: f(t) ≈ a₀/2 + Σ [aₙ cos(nωt) + bₙ sin(nωt)] de n=1 a ∞.",
                                    "Identifique os períodos T e a frequência fundamental ω = 2π/T.",
                                    "Revise as fórmulas dos coeficientes: a₀ = (2/T) ∫ f(t) dt, aₙ = (2/T) ∫ f(t) cos(nωt) dt, bₙ = (2/T) ∫ f(t) sin(nωt) dt.",
                                    "Entenda condições de convergência, como função piecewise contínua.",
                                    "Examine exemplos simples como onda senoidal pura."
                                  ],
                                  "verification": "Resuma verbalmente ou por escrito os componentes da série e fórmulas dos coeficientes com precisão.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de texto de análise de Fourier",
                                    "Notas de aula sobre resposta dinâmica SDOF",
                                    "Calculadora gráfica ou software como MATLAB/Octave"
                                  ],
                                  "tips": [
                                    "Comece com funções pares/ímpares para simplificar cálculos.",
                                    "Use simetria para zerar coeficientes desnecessários.",
                                    "Visualize gráficos da função original."
                                  ],
                                  "learningObjective": "Compreender a estrutura matemática da série de Fourier e seus coeficientes para funções periódicas.",
                                  "commonMistakes": [
                                    "Confundir ω com 2πf.",
                                    "Esquecer o fator 1/2 em a₀.",
                                    "Ignorar limites de integração corretos (um período)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e Analisar a Função Periódica",
                                  "subSteps": [
                                    "Escolha uma função periódica relevante ao contexto aeroespacial, como onda quadrada (carga alternada em estrutura) ou dente de serra (vibração induzida).",
                                    "Defina o período T, amplitude e fase da função.",
                                    "Desenhe ou plote a função manualmente ou via software para um período completo.",
                                    "Classifique se é par, ímpar ou mista para otimizar cálculos.",
                                    "Calcule manualmente os primeiros coeficientes a₀, a₁, b₁ para verificação inicial."
                                  ],
                                  "verification": "Produza um gráfico da função e liste propriedades (T, ω, simetria) com cálculos iniciais corretos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel milimetrado ou software de plotagem (Python/MATLAB)",
                                    "Tabelas de integrais Fourier comuns",
                                    "Exemplos de cargas periódicas em aeroelasticidade"
                                  ],
                                  "tips": [
                                    "Para onda quadrada: pares → só bₙ; ímpares → só aₙ.",
                                    "Use intervalos simétricos [-T/2, T/2] para facilitar.",
                                    "Salve plots para comparação posterior."
                                  ],
                                  "learningObjective": "Analisar propriedades de funções periódicas típicas em dinâmicas aeroespaciais.",
                                  "commonMistakes": [
                                    "Definir período incorreto.",
                                    "Não normalizar amplitude adequadamente.",
                                    "Confundir seno com cosseno em classificações par/ímpar."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e Escrever a Série de Fourier",
                                  "subSteps": [
                                    "Compute sistematicamente a₀, aₙ (n=1 a N, onde N=5-10 harmônicos) e bₙ usando integrais analíticas ou numéricas.",
                                    "Escreva a expressão truncada da série: f(t) ≈ a₀/2 + Σ [aₙ cos(nωt) + bₙ sin(nωt)] para n=1 a N.",
                                    "Implemente o cálculo em software para precisão (ex: função fft em MATLAB para verificação).",
                                    "Teste a série em pontos específicos (t=0, T/4, etc.) comparando com f(t) original.",
                                    "Ajuste N até convergência visual satisfatória."
                                  ],
                                  "verification": "Forneça a expressão escrita da série com coeficientes numéricos corretos para pelo menos 5 harmônicos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software numérico (MATLAB, Python com NumPy/SciPy)",
                                    "Tabela de integrais indefinidas",
                                    "Planilha Excel para somas parciais"
                                  ],
                                  "tips": [
                                    "Comece com poucos harmônicos e adicione gradualmente.",
                                    "Use fórmulas fechadas conhecidas para onda quadrada/dente de serra.",
                                    "Automatize com script para eficiência."
                                  ],
                                  "learningObjective": "Calcular coeficientes e montar a aproximação truncada da série de Fourier.",
                                  "commonMistakes": [
                                    "Erros em limites de integração.",
                                    "Arredondamento excessivo em coeficientes.",
                                    "Esquecer termos seno/cosseno necessários."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Avaliar a Aproximação",
                                  "subSteps": [
                                    "Plote a função original vs. aproximações parciais (N=1,3,5,10) sobre vários períodos.",
                                    "Calcule erros RMS ou máximo entre f(t) e série em pontos discretos.",
                                    "Analise overshoot (Gibbs phenomenon) perto de descontinuidades.",
                                    "Discuta implicações em contextos aeroespaciais, como resposta de estruturas a cargas periódicas.",
                                    "Otimize N para equilíbrio entre precisão e complexidade computacional."
                                  ],
                                  "verification": "Gere gráficos comparativos e relatório de erros com conclusão sobre convergência.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de plotagem (MATLAB plot, Python matplotlib)",
                                    "Templates de relatório de análise Fourier"
                                  ],
                                  "tips": [
                                    "Use logscale para erro vs. N.",
                                    "Compare com fft embutida para validação.",
                                    "Foque em regiões críticas como picos."
                                  ],
                                  "learningObjective": "Validar numericamente e visualmente a reconstrução da função periódica.",
                                  "commonMistakes": [
                                    "Ignorar Gibbs phenomenon.",
                                    "Plotar poucos períodos.",
                                    "Não quantificar erros adequadamente."
                                  ]
                                }
                              ],
                              "practicalExample": "Em dinâmica aeroespacial, reconstrua uma onda quadrada f(t) = 1 para 0 < t < T/2, -1 para T/2 < t < T (carga alternada em flap de asa). Calcule coeficientes bₙ = 4/(nπ) para n ímpar, escreva série truncada a N=9 e plote para verificar resposta em sistema SDOF.",
                              "finalVerifications": [
                                "A série truncada reproduz fielmente a função original em pelo menos 90% dos pontos testados.",
                                "Coeficientes aₙ e bₙ calculados coincidem com fórmulas analíticas conhecidas (erro <1%).",
                                "Gráficos mostram convergência com aumento de N, incluindo Gibbs phenomenon.",
                                "Erros RMS diminuem monotonicamente com N.",
                                "Expressão escrita da série é correta e inclui termos até N especificado.",
                                "Aplicação contextualizada a cargas periódicas em aeroelasticidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos de coeficientes (90%+ correto).",
                                "Qualidade dos gráficos comparativos e análise de erros.",
                                "Correção da expressão matemática da série.",
                                "Profundidade da discussão sobre convergência e limitações.",
                                "Relevância ao contexto aeroespacial (exemplos de cargas).",
                                "Organização e clareza do relatório final."
                              ],
                              "crossCurricularConnections": [
                                "Física: Análise de vibrações e ressonância em estruturas.",
                                "Programação: Implementação numérica com Python/MATLAB para FFT.",
                                "Matemática: Integrais improprias e séries infinitas.",
                                "Engenharia: Modelagem de cargas em simulações CFD/FEM aeroespaciais."
                              ],
                              "realWorldApplication": "Na aeroelasticidade, séries de Fourier decompõem cargas periódicas (ex: buffeting em asas) para prever respostas dinâmicas em sistemas SDOF, otimizando design contra fadiga e flutter em aeronaves."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.2",
                        "name": "Resposta Harmônica de Sistemas SDOF",
                        "description": "Solução da equação de movimento mẍ + cẋ + kx = F_0 cos(ωt) para excitações senoidais, incluindo solução particular estacionária e transiente.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.2.1",
                            "name": "Derivar a Solução Estacionária para Excitação Harmônica",
                            "description": "Obter a resposta particular x_p(t) = D cos(ωt - φ), onde D = F_0 / k / sqrt((1 - r^2)^2 + (2ζr)^2) e r = ω/ω_n, φ = atan(2ζr/(1 - r^2)), com ζ amortecimento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estabelecer a Equação de Movimento para o Sistema SDOF com Excitação Harmônica",
                                  "subSteps": [
                                    "Escreva a equação geral de movimento para um sistema de um grau de liberdade (SDOF): m ÿ + c ẏ + k y = F(t).",
                                    "Substitua a força de excitação harmônica: F(t) = F₀ cos(ωt).",
                                    "Expresse em termos não-dimensionais introduzindo ω_n = √(k/m) e ζ = c/(2√(km)).",
                                    "Divida a equação por k para obter a forma padrão: ÿ/ω_n² + 2ζ (ẏ/ω_n) + y = (F₀/k) cos(ωt).",
                                    "Defina r = ω/ω_n como a razão de frequências."
                                  ],
                                  "verification": "Confirme que a equação está na forma padrão com todos os termos corretos e não-dimensionais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou software de equações como LaTeX/MathType",
                                    "Referência ao textbook de dinâmica de estruturas aeroespaciais"
                                  ],
                                  "tips": "Sempre normalize as equações para facilitar comparações com gráficos de resposta em frequência.",
                                  "learningObjective": "Compreender e formular corretamente a equação diferencial governante para excitação harmônica.",
                                  "commonMistakes": [
                                    "Esquecer o sinal da força ou usar sin em vez de cos",
                                    "Erro na definição de ζ ou ω_n",
                                    "Não dividir por k para normalizar"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Assumir a Forma da Solução Particular Estacionária",
                                  "subSteps": [
                                    "Ignore a solução homogênea transitória e foque na particular estacionária x_p(t).",
                                    "Assuma x_p(t) = A cos(ωt) + B sin(ωt), compatível com a excitação harmônica.",
                                    "Alternativamente, use a forma polar x_p(t) = D cos(ωt - φ) para amplitude e fase.",
                                    "Calcule as derivadas: ẋ_p = -A ω sin(ωt) + B ω cos(ωt); ÿ_p = -A ω² cos(ωt) - B ω² sin(ωt).",
                                    "Prepare para substituição na equação diferencial."
                                  ],
                                  "verification": "Verifique se as derivadas tempo de x_p estão corretas diferenciando manualmente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora simbólica como Wolfram Alpha para verificação",
                                    "Folha de derivadas trigonométricas"
                                  ],
                                  "tips": "Use a forma A cos + B sin primeiro para evitar confusão com φ; converta depois.",
                                  "learningObjective": "Selecionar e derivar corretamente a forma assumida da solução particular.",
                                  "commonMistakes": [
                                    "Usar forma errada como senoidal pura",
                                    "Erros de sinal nas derivadas de segunda ordem",
                                    "Confundir com solução total"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Substituir na Equação Diferencial e Igualar Coeficientes",
                                  "subSteps": [
                                    "Substitua x_p, ẋ_p e ÿ_p na equação m ÿ + c ẏ + k x = F₀ cos(ωt).",
                                    "Agrupe termos em cos(ωt) e sin(ωt): (k - mω²) A + (cω) B = F₀ para cos; -(cω) A + (k - mω²) B = 0 para sin.",
                                    "Resolva o sistema linear para A e B: A = F₀ (k - mω²) / [(k - mω²)² + (cω)²]; B = F₀ (cω) / [(k - mω²)² + (cω)²].",
                                    "Normalize: D = F₀/k / √[(1 - r²)² + (2ζr)²]; φ = atan[2ζr / (1 - r²)].",
                                    "Confirme a forma x_p(t) = D cos(ωt - φ)."
                                  ],
                                  "verification": "Iguale os coeficientes e resolva; verifique se A e B levam às expressões normalizadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Matriz para resolver sistema 2x2",
                                    "Software como MATLAB para simulação numérica opcional"
                                  ],
                                  "tips": "Divida tudo por mω_n² para normalizar durante a substituição.",
                                  "learningObjective": "Aplicar método de coeficientes indeterminados para derivar A, B, D e φ.",
                                  "commonMistakes": [
                                    "Sinais errados nos termos de amortecimento",
                                    "Denominador incorreto no sistema",
                                    "Esquecer fatorização para D"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e Verificar a Solução Estacionária",
                                  "subSteps": [
                                    "Analise limites: D → F₀/k quando ω→0 (estático); D→0 quando ω→∞.",
                                    "Verifique ressonância: máximo D em r ≈ √(1 - 2ζ²).",
                                    "Compare φ: 0° em baixa frequência, 90° em ressonância, 180° em alta.",
                                    "Plote ou esboce curvas de D vs r e φ vs r para visualização.",
                                    "Confirme independência da solução particular das condições iniciais."
                                  ],
                                  "verification": "Calcule D e φ para valores específicos de ζ e r; compare com fórmulas padrão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráficos de resposta em frequência de textbooks",
                                    "Python/MATLAB para plotar"
                                  ],
                                  "tips": "Use aproximações para ζ pequeno comum em aeroestruturas.",
                                  "learningObjective": "Interpretar o significado físico de D e φ na resposta estacionária.",
                                  "commonMistakes": [
                                    "Confundir φ com defasagem de força",
                                    "Ignorar casos r<1 vs r>1 para atan",
                                    "Não normalizar corretamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma viga de asa de avião modelada como SDOF com m=100 kg, k=10^5 N/m, c=200 Ns/m, F₀=1000 N, ω=50 rad/s: Calcule ω_n≈31.6 rad/s, r≈1.58, ζ≈0.001, então D≈0.02 m e φ≈170°, prevendo deflexão estacionária sob vibração harmônica do motor.",
                              "finalVerifications": [
                                "Equação diferencial corretamente formulada com termos normalizados.",
                                "Forma assumida x_p(t) = D cos(ωt - φ) derivada com derivadas precisas.",
                                "Expressões exatas para D = F₀/k / √[(1-r²)² + (2ζr)²] e φ = atan(2ζr/(1-r²)).",
                                "Verificação numérica para um caso específico coincide com solução simulada.",
                                "Interpretação física de amplitude e fase correta.",
                                "Identificação de casos especiais (baixa/alta frequência, ressonância)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de A, B, D e φ (sem erros algébricos).",
                                "Correta normalização com r e ζ.",
                                "Uso apropriado do método de coeficientes indeterminados.",
                                "Interpretação física e limites analisados.",
                                "Clareza na apresentação com passos lógicos.",
                                "Aplicação correta em exemplo numérico aeroespacial."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Solução de EDOs lineares com coeficientes constantes e método de variação de parâmetros.",
                                "Física: Oscilações forçadas e conceitos de ressonância em mecânica clássica.",
                                "Engenharia de Controle: Análise de frequência e diagramas de Bode para sistemas similares.",
                                "Programação: Simulação numérica em Python (SciPy) para validar derivação analítica.",
                                "Estatística: Análise de incertezas em parâmetros como ζ medida experimentalmente."
                              ],
                              "realWorldApplication": "Em aeroelasticidade, essa derivação prevê a resposta estacionária de componentes como asas ou fuselagens a cargas harmônicas de motores ou turbulência, essencial para evitar fadiga estrutural e flutter em aeronaves como o Boeing 787."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.2.2",
                            "name": "Analisar Fator de Amplificação e Fase",
                            "description": "Plotar e interpretar curvas de amplificação |X/F_0| vs r e fase φ vs r, identificando ressonância em r=1 (sem amortecimento) e efeitos do amortecimento ζ em estruturas aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Equações Teóricas do Fator de Amplificação e Fase",
                                  "subSteps": [
                                    "Derive a equação do fator de amplificação |X/F_0| = 1 / |1 - r² + i(2ζr)| para sistemas SDOF harmônicos.",
                                    "Explique o parâmetro r = ω/ω_n como razão de frequências.",
                                    "Defina a fase φ = atan2(2ζr, 1 - r²) e seu significado físico.",
                                    "Discuta condições sem amortecimento (ζ=0): ressonância em r=1.",
                                    "Liste efeitos iniciais do amortecimento ζ na amplitude e fase."
                                  ],
                                  "verification": "Escreva as equações corretas e identifique ressonância em r=1 sem ζ.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Dinâmica de Estruturas",
                                    "Folha de derivação matemática",
                                    "Calculadora simbólica como SymPy"
                                  ],
                                  "tips": "Use convenções padrão de notação; visualize graficamente antes de plotar.",
                                  "learningObjective": "Compreender as fórmulas matemáticas fundamentais para análise de resposta harmônica.",
                                  "commonMistakes": [
                                    "Confundir r com ω_n",
                                    "Esquecer o módulo na amplitude",
                                    "Ignorar o sinal na fase"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Plotar Curvas Sem Amortecimento (ζ=0)",
                                  "subSteps": [
                                    "Configure eixo x como r (0 a 3), eixo y como |X/F_0| e φ.",
                                    "Plote |X/F_0| = 1 / |1 - r²| , mostrando pico infinito em r=1.",
                                    "Plote φ: 0° para r<1, 180° para r>1, salto em r=1.",
                                    "Anote pontos chave: r=0 (|X/F_0|=1, φ=0°), r=1 (ressonância).",
                                    "Valide o gráfico com software ou mão livre."
                                  ],
                                  "verification": "Gere gráfico com pico em r=1 e mudança de fase de 0° a 180°.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de plotagem (Matlab, Python Matplotlib, ou Excel)",
                                    "Papel milimetrado"
                                  ],
                                  "tips": "Use escala logarítmica para amplitude se necessário para visualização.",
                                  "learningObjective": "Dominar a plotagem e identificação visual de ressonância sem amortecimento.",
                                  "commonMistakes": [
                                    "Não capturar o salto de fase em r=1",
                                    "Escala inadequada no eixo y"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar Amortecimento e Plotar Curvas com ζ > 0",
                                  "subSteps": [
                                    "Escolha valores de ζ: 0.01, 0.05, 0.2 (leve a crítico).",
                                    "Plote |X/F_0| para cada ζ, mostrando pico deslocado para r<1 e amplitude finita.",
                                    "Plote φ para cada ζ, observando transição suave de 0° a -180°.",
                                    "Compare curvas: amplitude máxima diminui com ζ crescente.",
                                    "Identifique largura de banda e fator de qualidade Q ≈ 1/(2ζ)."
                                  ],
                                  "verification": "Gráficos mostram picos finitos e fases suaves para ζ>0.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Mesmo software de plotagem",
                                    "Tabelas de valores ζ típicos em aeroespacial"
                                  ],
                                  "tips": "Plote múltiplas curvas no mesmo gráfico para comparação direta.",
                                  "learningObjective": "Analisar impacto quantitativo do amortecimento nas curvas de resposta.",
                                  "commonMistakes": [
                                    "Usar ζ negativo",
                                    "Confundir deslocamento do pico (r_peak ≈ 1 - ζ²/2)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Curvas no Contexto de Estruturas Aeroespaciais",
                                  "subSteps": [
                                    "Relacione r=1 com frequências de excitação de turbulência ou motores.",
                                    "Discuta ressonância: risco de fadiga em asas ou fuselagem.",
                                    "Avalie efeitos de ζ: amortecedores reduzem picos, mas alteram fase (controle de flutter).",
                                    "Calcule exemplos numéricos para uma viga aeroespacial (ω_n=10 Hz, ζ=0.02).",
                                    "Conclua com recomendações de design: ζ ótimo ~0.05 para estruturas."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como ζ mitiga ressonância em asas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Casos de estudo aeroespaciais",
                                    "Dados de propriedades de materiais (alumínio, compósitos)"
                                  ],
                                  "tips": "Use unidades consistentes (Hz para frequências).",
                                  "learningObjective": "Aplicar interpretação das curvas a problemas reais em aeroelasticidade.",
                                  "commonMistakes": [
                                    "Ignorar contexto dinâmico (ex: aerodinâmica acoplada)",
                                    "Superestimar ζ crítico"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma asa de aeronave com ω_n = 5 Hz, simule excitação harmônica de motor em ω = 5 Hz (r=1). Sem ζ, amplitude infinita leva a flutter; com ζ=0.05, pico |X/F_0|≈10, fase -90°, permitindo design seguro com amortecedores.",
                              "finalVerifications": [
                                "Plotar corretamente curvas |X/F_0| e φ para ζ=0 e ζ=0.1.",
                                "Identificar ressonância em r=1 sem amortecimento.",
                                "Explicar deslocamento do pico de amplitude para r < 1 com ζ > 0.",
                                "Calcular fase em r=√2 para ζ=0.05.",
                                "Relacionar largura de banda com ζ.",
                                "Discutir implicações para fadiga estrutural."
                              ],
                              "assessmentCriteria": [
                                "Precisão das equações derivadas (100% correto).",
                                "Qualidade visual e legendas dos gráficos (clareza, escalas adequadas).",
                                "Interpretação correta de ressonância e efeitos de ζ.",
                                "Cálculos numéricos exatos para exemplos dados.",
                                "Conexão explícita com aplicações aeroespaciais.",
                                "Ausência de erros comuns em fase e amplitude."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e funções trigonométricas.",
                                "Física: Oscilações harmônicas e teoria de controle.",
                                "Engenharia Mecânica: Vibrações e modelagem finita de elementos.",
                                "Ciência de Materiais: Propriedades de amortecimento em compósitos.",
                                "Programação: Scripts em Python/Matlab para automação de plots."
                              ],
                              "realWorldApplication": "Em projetos de aeronaves como o Boeing 787, análise de fator de amplificação e fase previne flutter divergente durante voo, otimizando ζ via materiais viscoelásticos para certificação FAA, reduzindo massas e custos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.3.2.3",
                            "name": "Incluir Solução Transiente e Condições Iniciais",
                            "description": "Combinar solução homogênea x_h(t) = e^{-ζω_n t} (A cos(ω_d t) + B sen(ω_d t)) com particular, determinando constantes A e B via condições iniciais x(0) e ẋ(0).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Recordar e Escrever a Solução Homogênea",
                                  "subSteps": [
                                    "Identifique os parâmetros do sistema: fator de amortecimento ζ, frequência natural ω_n e frequência amortecida ω_d = ω_n √(1 - ζ²).",
                                    "Escreva a forma geral da solução homogênea: x_h(t) = e^{-ζ ω_n t} (A cos(ω_d t) + B sin(ω_d t)).",
                                    "Verifique se ω_d está corretamente calculado para subamortecimento (ζ < 1).",
                                    "Anote os valores numéricos de ζ, ω_n e ω_d para o problema específico.",
                                    "Confirme que a solução homogênea satisfaz a equação diferencial homogênea."
                                  ],
                                  "verification": "A solução x_h(t) deve satisfazer a EDO homogênea quando derivadas são substituídas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta, calculadora para ω_d",
                                  "tips": "Sempre use a forma exata de ω_d para evitar erros numéricos.",
                                  "learningObjective": "Entender a estrutura da resposta transiente subamortecida.",
                                  "commonMistakes": "Confundir ω_n com ω_d ou usar fórmula errada para ω_d."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar a Solução Particular",
                                  "subSteps": [
                                    "Revise a excitação harmônica: f(t) = F cos(ω t) ou similar.",
                                    "Escreva a solução particular assumida: x_p(t) = C cos(ω t) + D sin(ω t).",
                                    "Substitua x_p e suas derivadas na EDO não-homogênea para encontrar C e D em termos de parâmetros do sistema.",
                                    "Calcule os valores numéricos de C e D usando massa m, rigidez k, amortecimento c, F e ω.",
                                    "Confirme que x_p(t) é uma solução particular válida."
                                  ],
                                  "verification": "Substituir x_p na EDO completa deve resultar em f(t) no lado direito.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora ou software simbólico como Mathematica/MATLAB",
                                  "tips": "Mantenha símbolos até o final para clareza.",
                                  "learningObjective": "Dominar a derivação da solução particular para forçantes harmônicos.",
                                  "commonMistakes": "Esquecer o termo de amortecimento nas derivadas ou errar os coeficientes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formar a Solução Geral",
                                  "subSteps": [
                                    "Some as soluções: x(t) = x_h(t) + x_p(t).",
                                    "Expanda explicitamente: x(t) = e^{-ζ ω_n t} (A cos(ω_d t) + B sin(ω_d t)) + C cos(ω t) + D sin(ω t).",
                                    "Calcule a derivada temporal ẋ(t) para uso nas condições iniciais.",
                                    "Verifique que a solução geral satisfaz a EDO linear.",
                                    "Prepare para aplicação das condições iniciais."
                                  ],
                                  "verification": "A derivada ẋ(t) deve ser computada corretamente para ICs.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel para derivação simbólica",
                                  "tips": "Use notação clara para diferenciar homogênea e particular.",
                                  "learningObjective": "Construir a solução total combinando componentes.",
                                  "commonMistakes": "Esquecer de somar x_h e x_p ou errar na derivada do termo exponencial."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Condições Iniciais x(0) e ẋ(0)",
                                  "subSteps": [
                                    "Em t=0: x(0) = A + C = valor dado (ex: x_0).",
                                    "Calcule ẋ(0): derive x(t) e avalie em t=0, resultando em -ζ ω_n A + ω_d B + ω (-C sin(0) + D cos(0)) wait, compute fully.",
                                    "Forme o sistema de equações: A + C = x(0); [-ζ ω_n A + ω_d B + deriv terms from xp] = ẋ(0).",
                                    "Resolva o sistema linear 2x2 para A e B.",
                                    "Substitua valores numéricos e simplifique."
                                  ],
                                  "verification": "Verifique se x(0) e ẋ(0) da solução com A,B calculados coincidem com dados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora para resolver sistema linear",
                                  "tips": "Escreva o sistema matricial para resolver eficientemente.",
                                  "learningObjective": "Aplicar ICs para determinar constantes arbitrárias.",
                                  "commonMistakes": "Ignorar contribuições de x_p em ẋ(0)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Interpretar a Solução Completa",
                                  "subSteps": [
                                    "Substitua A e B na x(t) final.",
                                    "Plote ou avalie x(t) em alguns pontos para checar continuidade.",
                                    "Analise o comportamento: transiente decai, particular persiste.",
                                    "Compare com solução numérica se possível.",
                                    "Discuta implicações físicas (ex: overshoot inicial)."
                                  ],
                                  "verification": "x(0) e ẋ(0) devem bater exatamente; transiente deve decair.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Gráfica ou MATLAB para plot",
                                  "tips": "Sempre normalize unidades de tempo e deslocamento.",
                                  "learningObjective": "Validar e interpretar a resposta dinâmica completa.",
                                  "commonMistakes": "Não verificar numericamente as ICs após resolução."
                                }
                              ],
                              "practicalExample": "Para um sistema SDOF com m=1 kg, k=100 N/m (ω_n=10 rad/s), c=2 Ns/m (ζ=0.1), f(t)=(10 cos(3t)) N, x(0)=0, ẋ(0)=0. Solução homogênea: e^{-t} (A cos(9.95 t) + B sin(9.95 t)). Particular: calcule C≈0.098, D≈0.029. Então A=-C≈-0.098, B=(ẋ(0) + ζω_n A - ω D)/ω_d ≈ valor calculado. x(t) final satisfaz ICs.",
                              "finalVerifications": [
                                "x(0) da solução equals condição inicial dada.",
                                "ẋ(0) da solução equals velocidade inicial dada.",
                                "Transiente decai exponencialmente (ver em t grande).",
                                "Solução particular domina em regime permanente.",
                                "Nenhuma inconsistência numérica ou singularidade.",
                                "Derivadas de segunda ordem levam à EDO original."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da solução homogênea e particular (100% correta).",
                                "Correta aplicação e resolução das condições iniciais (sem erros algébricos).",
                                "Verificação explícita de x(0) e ẋ(0).",
                                "Interpretação física da transiente vs. permanente.",
                                "Clareza na apresentação da solução final.",
                                "Eficiência no número de passos e cálculos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sistemas lineares de equações e EDOs lineares.",
                                "Física: Oscilações amortecidas e ressonância.",
                                "Engenharia: Análise modal em estruturas.",
                                "Programação: Simulação numérica em MATLAB/Python.",
                                "Controle: Estados iniciais em sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Em aeroelasticidade, modela vibrações iniciais de asas de aeronaves sob cargas harmônicas (ex: turbulência), prevendo overshoot transiente que pode levar a fadiga estrutural ou flutter; usado no design de dampers para estabilizar resposta."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.3",
                        "name": "Superposição de Respostas Harmônicas",
                        "description": "Cálculo da resposta total de SDOF a carga periódica decompondo em harmônicas e somando linearmente as respostas estacionárias de cada componente.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.3.1",
                            "name": "Decompor Carga Periódica e Calcular Resposta Total",
                            "description": "Para f(t) = Σ F_n cos(nωt + ψ_n), calcular x(t) = Σ D_n cos(nωt - φ_n), onde cada D_n e φ_n da resposta harmônica individual.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Decompor a carga periódica f(t) em componentes harmônicas via série de Fourier",
                                  "subSteps": [
                                    "Identificar o período T da função f(t) e calcular a frequência fundamental ω = 2π/T.",
                                    "Calcular os coeficientes de Fourier F_n e fases ψ_n para os primeiros N harmônicos (ex: n=1 a 5), usando fórmulas a_n = (2/T) ∫ f(t) cos(nωt) dt e b_n = (2/T) ∫ f(t) sin(nωt) dt, então F_n = sqrt(a_n² + b_n²) e ψ_n = atan2(b_n, a_n).",
                                    "Listar explicitamente cada F_n e ψ_n em uma tabela.",
                                    "Verificar a reconstrução aproximada de f(t) somando os harmônicos iniciais.",
                                    "Explorar simetrias (par/impar) para simplificar cálculos."
                                  ],
                                  "verification": "Coeficientes F_n e ψ_n calculados corretamente e tabela completa; reconstrução de f(t) com erro <5% nos primeiros harmônicos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Calculadora científica ou software (MATLAB/Python)",
                                    "Tabelas de integrais Fourier",
                                    "Papel e lápis para esboços gráficos",
                                    "Exemplo de f(t) periódico (onda quadrada ou dente de serra)"
                                  ],
                                  "tips": "Comece com poucos harmônicos (N=3-5) para validar; use simetria da função para zerar coeficientes desnecessários.",
                                  "learningObjective": "Dominar a decomposição de funções periódicas em séries harmônicas para análise dinâmica.",
                                  "commonMistakes": "Erros nos limites de integração (0 a T), esquecer o fator 2/T, ou confundir seno/cosseno nas fases."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a amplitude D_n e fase φ_n da resposta estacionária para cada harmônica",
                                  "subSteps": [
                                    "Para cada n, definir ω_n = n ω e a força harmônica F_n cos(nω t + ψ_n).",
                                    "Calcular a amplitude D_n = F_n / sqrt( (k - m ω_n²)^2 + (c ω_n)^2 ), onde m, c, k são parâmetros do SDOF.",
                                    "Determinar a fase φ_n = atan2( c ω_n, k - m ω_n² ).",
                                    "Registrar D_n e φ_n em tabela para todos n.",
                                    "Identificar possíveis ressonâncias (quando ω_n ≈ ω_natural = sqrt(k/m))."
                                  ],
                                  "verification": "Tabela com D_n e φ_n corretos; verificar unidades consistentes e ausência de divisões por zero.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Parâmetros SDOF conhecidos (m, c, k)",
                                    "Calculadora ou spreadsheet (Excel)",
                                    "Fórmulas de resposta SDOF impressas"
                                  ],
                                  "tips": "Use a forma polar para facilitar; plote |H(jω_n)| para visualizar amplificação.",
                                  "learningObjective": "Aplicar fórmulas de resposta harmônica estacionária em sistemas SDOF.",
                                  "commonMistakes": "Confundir φ_n com ψ_n, erro no sinal do denominador (k - mω²), ou esquecer o módulo na amplitude."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Superpor as respostas harmônicas para obter a resposta total x(t)",
                                  "subSteps": [
                                    "Escrever x(t) = Σ_{n=1}^N D_n cos(n ω t - φ_n).",
                                    "Expandir explicitamente para os primeiros N termos.",
                                    "Avaliar x(t) em pontos específicos (ex: t=0, t=T/4) e comparar com solução numérica se disponível.",
                                    "Plotar x(t) vs f(t) para visualização da resposta.",
                                    "Discutir truncamento de harmônicos e convergência."
                                  ],
                                  "verification": "Expressão x(t) final correta; gráfico mostra resposta defasada e atenuada corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de plotagem (MATLAB, Python Matplotlib ou Desmos)",
                                    "Tabelas de D_n e φ_n do passo anterior"
                                  ],
                                  "tips": "Use N suficiente para convergência; fase -φ_n garante defasagem correta.",
                                  "learningObjective": "Compreender o princípio de superposição linear em respostas dinâmicas periódicas.",
                                  "commonMistakes": "Esquecer o sinal negativo na fase (-φ_n), somar incorretamente os argumentos, ou incluir termo DC se não houver."
                                }
                              ],
                              "practicalExample": "Considere um sistema SDOF (m=1 kg, k=1000 N/m, c=5 Ns/m) sujeito a f(t) onda quadrada periódica com T=1s, amplitude 10N (f(t)=10 para 0<t<T/2, -10 para T/2<t<T). Decomponha em 5 harmônicos: F1≈12.73N ψ1=0, F3≈4.24N ψ3=π, etc. Calcule D1≈0.127m φ1≈0.35rad, etc. Então x(t)≈0.127 cos(2πt -0.35) + 0.004 cos(6πt -π +φ3) + ...",
                              "finalVerifications": [
                                "x(t) satisfaz aproximadamente a EDO mx'' + cx' + kx = f(t) em pontos amostrados.",
                                "Resposta x(t) apresenta defasagem progressiva com frequência.",
                                "Ausência de crescimento ilimitado (sem ressonância exata).",
                                "Convergência ao aumentar N harmônicos.",
                                "Energia média compatível com entrada.",
                                "Valores em t=0 e picos condizem com amplitudes D_n."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos coeficientes Fourier >95% (comparado com analítico ou software).",
                                "Cálculos de D_n e φ_n exatos até 3 casas decimais.",
                                "Expressão x(t) superposta correta sem erros de sinal ou índice.",
                                "Interpretação física adequada (ressonância, defasagem).",
                                "Gráficos claros e rotulados corretamente.",
                                "Tratamento de truncamento e limitações discutido."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries de Fourier e análise complexa.",
                                "Programação: Implementação numérica em Python/MATLAB para decomposição e simulação.",
                                "Física: Princípios de vibrações e amortecimento.",
                                "Engenharia de Controle: Filtros dinâmicos e resposta em frequência."
                              ],
                              "realWorldApplication": "Na dinâmica aeroespacial, decompõe cargas aerodinâmicas periódicas (ex: buffeting em asas) para prever vibrações em estruturas de aeronaves, evitando fadiga e flutter crítico durante o projeto de estabilizadores ou hélices."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1.3",
                              "10.1.2.3.2.2"
                            ]
                          },
                          {
                            "id": "10.1.2.3.3.2",
                            "name": "Aplicar em Exemplos Aeroespaciais",
                            "description": "Resolver numericamente resposta de estrutura SDOF (ex.: painel de asa) a carga periódica como motor ou fluxo turbulento, usando MATLAB ou similar para somar 10 primeiros harmônicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o Modelo SDOF e a Excitação Periódica",
                                  "subSteps": [
                                    "Identificar parâmetros da estrutura SDOF: massa (m), rigidez (k) e amortecimento (c) para um painel de asa.",
                                    "Definir a frequência natural ω_n = sqrt(k/m) e o fator de amortecimento ζ = c/(2*sqrt(k*m)).",
                                    "Especificar a carga periódica F(t) = Σ F_n * cos(n*ω*t + φ_n) para n=1 a 10, modelando motor ou fluxo turbulento.",
                                    "Escolher valores realistas: ex. m=10 kg, k=1000 N/m, c=10 Ns/m, ω=2π*10 rad/s (RPM motor)."
                                  ],
                                  "verification": "Verificar se equação de movimento mẍ + cẋ + kx = F(t) está corretamente formulada e parâmetros consistentes com exemplo aeroespacial.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB ou Octave instalado",
                                    "Documentação de dinâmica de estruturas aeroespaciais",
                                    "Folha de cálculo para parâmetros"
                                  ],
                                  "tips": "Use unidades SI consistentes para evitar erros dimensionais.",
                                  "learningObjective": "Compreender e parametrizar um sistema SDOF aeroespacial sujeito a excitação periódica.",
                                  "commonMistakes": "Confundir frequência de excitação ω com natural ω_n; ignorar fases φ_n na carga."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Respostas Harmônicas Individuais",
                                  "subSteps": [
                                    "Implementar fórmula de resposta harmônica: X_n(ω_n) = F_n / |k - m( nω )^2 + i c nω| para amplitude e fase.",
                                    "Escrever script MATLAB para loop sobre n=1 a 10, calculando magnitude e fase de cada harmônico.",
                                    "Definir função de transferência H(nω) = 1 / (k - m (nω)^2 + 1i * c * nω)."
                                  ],
                                  "verification": "Plotar |H(j nω)| vs n para visualizar picos de ressonância.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Editor MATLAB (ou Jupyter com Octave)",
                                    "Exemplos de código de resposta harmônica SDOF"
                                  ],
                                  "tips": "Use complexos no MATLAB com '1i' para facilitar cálculos de magnitude e fase.",
                                  "learningObjective": "Dominar cálculo analítico-numérico de respostas harmônicas estacionárias.",
                                  "commonMistakes": "Esquecer termo imaginário no denominador; usar ω em vez de nω."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Somar as 10 Primeiras Respostas Harmônicas",
                                  "subSteps": [
                                    "Gerar x(t) = Σ |X_n| cos(nω t + θ_n) para t em malha temporal (dt=ω/100).",
                                    "Implementar soma no MATLAB com loop ou vectorização: x = real(sum(X_n .* exp(1i*(nω*t + θ_n)))).",
                                    "Garantir pelo menos 10 períodos para estacionariedade (T_total = 10/(ω/2π))."
                                  ],
                                  "verification": "Verificar se soma converge e amplitude total faz sentido (não explode).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Script MATLAB do passo anterior",
                                    "Função fft() para validação espectral"
                                  ],
                                  "tips": "Vectorize com meshgrid para eficiência em grandes vetores t.",
                                  "learningObjective": "Aplicar superposição linear para resposta periódica composta.",
                                  "commonMistakes": "Erro de índice em loop (off-by-one); soma sem normalizar tempo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar, Plotar e Validar Resultados",
                                  "subSteps": [
                                    "Plotar x(t), F(t) e envelope de deslocamento.",
                                    "Calcular FFT de x(t) e comparar com harmônicos teóricos.",
                                    "Verificar estabilidade: damping ratio afeta decaimento transitório (ignorado aqui)."
                                  ],
                                  "verification": "Espectro FFT deve coincidir com amplitudes |X_n| calculadas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB plotting functions (plot, fft, semilogy)",
                                    "Referência: painel de asa com flutter suprimido"
                                  ],
                                  "tips": "Use subplot para múltiplos gráficos; labels com unidades.",
                                  "learningObjective": "Interpretar numericamente resposta dinâmica aeroespacial.",
                                  "commonMistakes": "Escala errada em plots; ignorar aliasing na FFT (use dt pequeno)."
                                }
                              ],
                              "practicalExample": "Simular painel de asa (m=5kg, k=2000N/m, ζ=0.02) sob fluxo turbulento modelado como F(t)= Σ_{n=1}^{10} 10/n * cos(n*2π*50 t) N, com ω=2π*50 rad/s (turbulência). Plotar deslocamento pico ~1cm.",
                              "finalVerifications": [
                                "Resposta estacionária atingida após poucos períodos.",
                                "Picos harmônicos no espectro coincidem com cálculo teórico.",
                                "Amplitude total < limite de fadiga estrutural (ex. 2% deformação).",
                                "Fases corretas: defasagem ~90° em ressonância.",
                                "Código roda sem erros e é reproduzível.",
                                "Validação com solução analítica para n=1."
                              ],
                              "assessmentCriteria": [
                                "Precisão da soma harmônica: erro <1% vs FFT.",
                                "Eficiência do código: tempo execução <5s para 10^5 pontos.",
                                "Interpretação física: identificar risco de ressonância.",
                                "Documentação no script: comentários em 80% linhas.",
                                "Generalidade: código parametrizável para outros casos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries de Fourier e números complexos.",
                                "Programação: Loops vectorizados e análise numérica em MATLAB.",
                                "Física: Equações diferenciais lineares e amortecimento.",
                                "Engenharia Mecânica: Vibrações em estruturas aeronáuticas.",
                                "Ciência de Materiais: Limites de fadiga sob carregamento dinâmico."
                              ],
                              "realWorldApplication": "No design de asas de aeronaves, prever vibrações induzidas por motores ou turbulência para evitar fadiga e flutter, otimizando suportes e amortecedores em ferramentas como NASTRAN/MATLAB."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.4",
                    "name": "Resposta a Excitações Arbitrárias",
                    "description": "Aplicação do integral de convolução de Duhamel para determinação da resposta a forças não periódicas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.4.1",
                        "name": "Função de Resposta ao Impulso (h(t))",
                        "description": "A função de resposta ao impulso, também conhecida como função unitária de resposta, representa a resposta de um sistema SDOF a uma força impulsiva unitária aplicada em t=0. Ela é fundamental para a superposição linear em sistemas lineares.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.1.1",
                            "name": "Derivar a função h(t) para sistema SDOF não amortecido",
                            "description": "Derivar analiticamente a expressão da função de resposta ao impulso h(t) = (1/(m ω_n)) sin(ω_n t) para um sistema com um grau de liberdade sem amortecimento, partindo da equação de movimento m ÿ + k y = δ(t).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estabelecer a equação de movimento para o sistema SDOF não amortecido",
                                  "subSteps": [
                                    "Defina o sistema SDOF não amortecido com massa m e rigidez k.",
                                    "Escreva a equação diferencial: m ÿ + k y = f(t), onde f(t) é a força externa.",
                                    "Identifique ω_n = sqrt(k/m) como a frequência natural.",
                                    "Confirme condições iniciais em t=0-: y(0-) = 0 e ý(0-) = 0.",
                                    "Discuta o significado físico de cada termo."
                                  ],
                                  "verification": "Verifique se a equação está corretamente escrita e ω_n definida.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de dinâmica de estruturas (capítulo SDOF)"
                                  ],
                                  "tips": "Sempre normalize a equação dividindo por m para obter ÿ + ω_n² y = f(t)/m.",
                                  "learningObjective": "Compreender a formulação matemática básica do sistema SDOF.",
                                  "commonMistakes": [
                                    "Esquecer de definir ω_n",
                                    "Confundir com sistema amortecido (termo c ý)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar a excitação de impulso δ(t) e determinar condições iniciais pós-impulso",
                                  "subSteps": [
                                    "Substitua f(t) = δ(t) na equação: m ÿ + k y = δ(t).",
                                    "Integre a equação de t=0- a t=0+ para capturar o efeito do impulso.",
                                    "Mostre que y(0+) = y(0-) = 0 (deslocamento não muda).",
                                    "Mostre que m [ý(0+) - ý(0-)] = 1, logo ý(0+) = 1/m.",
                                    "Explique o salto na velocidade devido ao impulso unitário."
                                  ],
                                  "verification": "Confirme ý(0+) = 1/m e y(0+) = 0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora para simulações numéricas opcionais",
                                    "Gráfico de δ(t)"
                                  ],
                                  "tips": "Lembre-se: ∫ δ(t) dt = 1, afetando apenas a derivada primeira (velocidade).",
                                  "learningObjective": "Aplicar propriedades da função delta de Dirac em EDPs.",
                                  "commonMistakes": [
                                    "Assumir que o impulso afeta o deslocamento diretamente",
                                    "Ignorar o salto na velocidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver a equação homogênea com condições iniciais pós-impulso",
                                  "subSteps": [
                                    "Para t > 0, a equação é homogênea: ÿ + ω_n² y = 0.",
                                    "Solução geral: y(t) = A cos(ω_n t) + B sin(ω_n t).",
                                    "Aplique y(0+) = 0 → A = 0.",
                                    "Aplique ý(0+) = 1/m → B ω_n = 1/m → B = 1/(m ω_n).",
                                    "Obtenha h(t) = y(t) = [1/(m ω_n)] sin(ω_n t)."
                                  ],
                                  "verification": "Substitua h(t) na equação original e verifique se satisfaz ICs.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de derivadas trigonométricas",
                                    "Software como MATLAB para plotar h(t)"
                                  ],
                                  "tips": "Derive ý(t) = [1/m] cos(ω_n t) para confirmar ý(0+) = 1/m.",
                                  "learningObjective": "Resolver EDOs lineares com condições iniciais específicas.",
                                  "commonMistakes": [
                                    "Erro no cálculo de B (esquecer ω_n na derivada)",
                                    "Usar cos em vez de sin"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e interpretar a função h(t) derivada",
                                  "subSteps": [
                                    "Confirme dimensionalmente: h(t) tem unidades de 1/força * tempo (correto para resposta a impulso).",
                                    "Plote h(t) e observe oscilações harmônicas puras.",
                                    "Discuta propriedades: h(t) = 0 para t<0, normalizada para ∫ h(t) dt relacionado à estática.",
                                    "Compare com resposta a degrau unitário (integral de h(t)).",
                                    "Resuma a derivação em uma equação final clara."
                                  ],
                                  "verification": "h(t) = (1/(m ω_n)) sin(ω_n t) para t ≥ 0, e 0 otherwise.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Gráfico de sin(ω_n t)",
                                    "Tabela de unidades físicas"
                                  ],
                                  "tips": "Use simulação numérica para validar analiticamente.",
                                  "learningObjective": "Interpretar e validar resultados analíticos.",
                                  "commonMistakes": [
                                    "Esquecer o fator 1/ω_n",
                                    "Não especificar t ≥ 0"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema com m=1 kg e k=10000 N/m (ω_n=100 rad/s), derive h(t) = (1/100) sin(100 t) = 0.01 sin(100 t) m/N·s. Simule em Python plotando h(t) de 0 a 0.1s, confirmando oscilações com amplitude 0.01 e período 2π/100 ≈ 0.063s.",
                              "finalVerifications": [
                                "Expressão final h(t) = (1/(m ω_n)) sin(ω_n t) para t ≥ 0.",
                                "Condições iniciais corretas: y(0+)=0, ý(0+)=1/m.",
                                "Solução satisfaz a EDO homogênea para t>0.",
                                "Dimensionalmente consistente.",
                                "Comportamento oscilatório harmônico sem decaimento.",
                                "Integral inicial confirma resposta a degrau."
                              ],
                              "assessmentCriteria": [
                                "Correção na aplicação do impulso δ(t) e salto na velocidade.",
                                "Solução geral da EDO homogênea precisa.",
                                "Aplicação correta das condições iniciais.",
                                "Forma final exata da expressão h(t).",
                                "Verificação dimensional e interpretação física.",
                                "Clareza na derivação passo a passo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Resolução de EDOs lineares e transformadas de Laplace.",
                                "Física: Dinâmica newtoniana e osciladores harmônicos.",
                                "Programação: Simulação numérica em Python/MATLAB de h(t).",
                                "Engenharia: Análise de vibrações em estruturas aeroespaciais.",
                                "Controle: Base para funções de transferência em sistemas lineares."
                              ],
                              "realWorldApplication": "Em aeroelasticidade, h(t) modela a resposta instantânea de asas a rajadas de vento (impulsos aerodinâmicos), essencial para prever flutter e fadiga em aeronaves como o Boeing 787, onde simulações baseadas em h(t) validam estabilidade dinâmica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.2",
                            "name": "Derivar h(t) para sistema SDOF amortecido",
                            "description": "Obter a expressão da função h(t) para sistema subamortecido com amortecimento viscoso, h(t) = (1/(m ω_d)) e^(-ζ ω_n t) sin(ω_d t), onde ω_d = ω_n √(1-ζ²), a partir da solução da equação m ÿ + c ẏ + k y = δ(t).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir parâmetros do sistema SDOF e equação característica",
                                  "subSteps": [
                                    "Identifique os parâmetros: massa m, amortecimento c, rigidez k.",
                                    "Defina frequências naturais: ω_n = √(k/m), razão de amortecimento ζ = c/(2√(km)).",
                                    "Escreva a equação diferencial: m ÿ + c ẏ + k y = δ(t).",
                                    "Determine o regime subamortecido: ζ < 1.",
                                    "Calcule ω_d = ω_n √(1 - ζ²)."
                                  ],
                                  "verification": "Confirme que ω_n, ζ e ω_d estão corretamente expressos em termos de m, c, k.",
                                  "estimatedTime": "20 min",
                                  "materials": [
                                    "Folha de papel ou software de equações (ex: Mathematica, MATLAB)",
                                    "Tabela de parâmetros SDOF"
                                  ],
                                  "tips": "Sempre normalize com ω_n para simplificar cálculos.",
                                  "learningObjective": "Compreender os parâmetros fundamentais e condições para subamortecimento.",
                                  "commonMistakes": [
                                    "Confundir ω_n com ω_d",
                                    "Esquecer de verificar ζ < 1"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Obter a solução homogênea geral para o sistema subamortecido",
                                  "subSteps": [
                                    "Escreva a equação característica: m r² + c r + k = 0.",
                                    "Encontre as raízes complexas: r = -ζ ω_n ± i ω_d.",
                                    "Forme a solução geral: y(t) = e^(-ζ ω_n t) [A cos(ω_d t) + B sen(ω_d t)].",
                                    "Alternativamente, use forma senoidal: y(t) = C e^(-ζ ω_n t) sen(ω_d t + φ), mas prefira forma com A e B para condições iniciais.",
                                    "Confirme que é solução homogênea (sem forçamento)."
                                  ],
                                  "verification": "Substitua y(t) na equação diferencial e verifique que satisfaz para t > 0.",
                                  "estimatedTime": "25 min",
                                  "materials": [
                                    "Calculadora simbólica ou papel para raízes quadráticas",
                                    "Livro de dinâmica (ex: Thomson)"
                                  ],
                                  "tips": "Use identidades trigonométricas para manter consistência.",
                                  "learningObjective": "Derivar a solução homogênea para raízes complexas conjugadas.",
                                  "commonMistakes": [
                                    "Raízes reais em vez de complexas",
                                    "Sinal errado no expoente de amortecimento"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar condições iniciais induzidas pelo impulso unitário δ(t)",
                                  "subSteps": [
                                    "Determine condições iniciais: y(0⁺) = 0 (deslocamento contínuo), ẏ(0⁺) = 1/m (impulso muda velocidade).",
                                    "Aplique y(0) = 0: A = 0.",
                                    "Calcule ẏ(t) e aplique ẏ(0) = 1/m para encontrar B.",
                                    "Simplifique: ẏ(t) = e^(-ζ ω_n t) [(-ζ ω_n A + ω_d B) cos(ω_d t) + ...] no t=0 leva a B = 1/(m ω_d).",
                                    "Obtenha h(t) = y(t) = [1/(m ω_d)] e^(-ζ ω_n t) sen(ω_d t)."
                                  ],
                                  "verification": "Verifique limites: h(0) = 0, ∫ h(t) dt inicial dá velocidade 1/m.",
                                  "estimatedTime": "30 min",
                                  "materials": [
                                    "Software de derivação (ex: SymPy Python)",
                                    "Gráfico de h(t) para visualização"
                                  ],
                                  "tips": "Cuidado com derivada do produto: use regra do produto para ẏ(t).",
                                  "learningObjective": "Aplicar corretamente condições de salto no impulso Dirac.",
                                  "commonMistakes": [
                                    "y(0⁺) ≠ 0",
                                    "ẏ(0⁺) = 1 em vez de 1/m"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e generalizar a expressão de h(t)",
                                  "subSteps": [
                                    "Confirme a forma final: h(t) = (1/(m ω_d)) e^(-ζ ω_n t) sen(ω_d t).",
                                    "Verifique casos limites: ζ → 0 (não amortecido), ω_d → ω_n.",
                                    "Compare com literatura ou software numérico.",
                                    "Discuta propriedades: envelope decrescente, oscilações.",
                                    "Estenda para superamortecido se aplicável (mas foque subamortecido)."
                                  ],
                                  "verification": "Plote h(t) e integre para resposta a degrau.",
                                  "estimatedTime": "15 min",
                                  "materials": [
                                    "MATLAB ou Python para plotar h(t)",
                                    "Referência: Clough & Penzien"
                                  ],
                                  "tips": "Use Laplace para validar: ℒ{δ(t)} = 1, H(s) = 1/(m s² + c s + k).",
                                  "learningObjective": "Validar derivação e entender comportamento físico.",
                                  "commonMistakes": [
                                    "Fator 1/(m ω_n) em vez de 1/(m ω_d)",
                                    "Sen em vez de cos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para m=1 kg, k=100 N/m, c=4 Ns/m: ω_n=10 rad/s, ζ=0.2, ω_d≈9.8 rad/s. Derive h(t) = (1/(1*9.8)) e^(-2t) sen(9.8 t) e plote para t=0-2s, verificando pico inicial ~0.1 m/s.",
                              "finalVerifications": [
                                "h(0)=0 e ẏ(0)=1/m confirmados.",
                                "Expressão bate com fórmula padrão para subamortecido.",
                                "Plota mostra decaimento exponencial e oscilações com ω_d.",
                                "Limite ζ=0 recupera sen(ω_n t)/ (m ω_n).",
                                "Integração numérica de h(t) dá resposta correta a degrau.",
                                "Derivada parcial em parâmetros altera h(t) fisicamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na equação característica e raízes.",
                                "Correção das condições iniciais para δ(t).",
                                "Simplificação correta para B=1/(m ω_d).",
                                "Forma final exata sem erros algébricos.",
                                "Explicação física do resultado.",
                                "Validação com gráfico ou limite."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Soluções de EDOs lineares com coeficientes constantes.",
                                "Física: Oscilações amortecidas em sistemas mecânicos.",
                                "Engenharia de Controle: Funções de transferência em malha aberta.",
                                "Processamento de Sinais: Resposta impulsional em filtros.",
                                "Programação: Simulação numérica em Python/MATLAB."
                              ],
                              "realWorldApplication": "Em aeroelasticidade, h(t) modela resposta de asas a rajadas turbulentas (impulsos), essencial para flutter avoidance em aeronaves como Boeing 787, prevendo vibrações estruturais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.4.1.3",
                            "name": "Interpretar propriedades da função h(t)",
                            "description": "Analisar as propriedades da h(t), como causalidade (h(t)=0 para t<0), duração infinita em sistemas estáveis e dependência dos parâmetros modais (ω_n, ζ), relacionando com contextos aeroespaciais como vibrações de painéis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Causalidade da Função h(t)",
                                  "subSteps": [
                                    "Revise a definição de função de resposta ao impulso h(t) como a resposta de deslocamento a um impulso unitário em t=0.",
                                    "Analise graficamente h(t) para diferentes sistemas SDOF, identificando que h(t)=0 para t<0.",
                                    "Derive matematicamente a condição de causalidade a partir da equação diferencial do sistema mẍ + cẋ + kx = δ(t).",
                                    "Compare com funções não causais para destacar a importância física em sistemas reais.",
                                    "Plote h(t) usando software para um sistema subamortecido e confirme h(t)=0 para t<0."
                                  ],
                                  "verification": "Confirme que todos os gráficos mostram h(t)=0 para t<0 e explique verbalmente o motivo físico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Dinâmica de Estruturas (ex: Clough & Penzien)",
                                    "Software MATLAB ou Python (SciPy)",
                                    "Papel e lápis para esboços"
                                  ],
                                  "tips": "Sempre normalize o tempo pela frequência natural ω_n para comparações claras.",
                                  "learningObjective": "Compreender e demonstrar que h(t) é causal devido à natureza física de sistemas reais.",
                                  "commonMistakes": [
                                    "Assumir h(t) ≠ 0 para t<0 em simulações numéricas",
                                    "Confundir causalidade com simetria da função"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Duração da Resposta h(t) em Sistemas Estáveis",
                                  "subSteps": [
                                    "Classifique sistemas SDOF como subamortecidos (ζ<1), criticamente amortecidos (ζ=1) e superamortecidos (ζ>1).",
                                    "Derive expressões analíticas para h(t) em cada caso e observe que em sistemas estáveis (ζ>0), h(t) decai para zero mas tem duração teoricamente infinita.",
                                    "Simule numericamente h(t) para ζ=0.1 e ζ=0.5, plotando até t=100/ω_n para ver o decaimento.",
                                    "Discuta implicações físicas: oscilações persistentes em baixa amortecimento vs. resposta rápida em alto amortecimento.",
                                    "Compare com sistemas instáveis (ζ<0) onde h(t) diverge."
                                  ],
                                  "verification": "Gere plots mostrando decaimento exponencial e confirme que h(t) → 0 como t → ∞ para ζ>0.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "MATLAB/SciPy para simulações",
                                    "Tabelas de fórmulas de resposta ao impulso",
                                    "Calculadora gráfica"
                                  ],
                                  "tips": "Use escala logarítmica no eixo y para visualizar melhor o decaimento exponencial.",
                                  "learningObjective": "Interpretar como a estabilidade garante duração finita prática apesar de teoricamente infinita.",
                                  "commonMistakes": [
                                    "Ignorar o decaimento exponencial e assumir duração finita exata",
                                    "Confundir instabilidade com superamortecimento"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Examinar Dependência dos Parâmetros Modais ω_n e ζ",
                                  "subSteps": [
                                    "Escreva a forma geral de h(t) para sistema subamortecido: h(t) = (1/(m ω_d)) e^(-ζ ω_n t) sin(ω_d t), onde ω_d = ω_n √(1-ζ²).",
                                    "Varie ω_n fixando ζ=0.2 e plote h(t): observe que maior ω_n comprime o tempo da resposta.",
                                    "Varie ζ fixando ω_n=1 rad/s e plote: observe redução de oscilações e decaimento mais rápido com ζ maior.",
                                    "Calcule métricas quantitativas: tempo de pico, overshoot e tempo de assentamento como funções de ω_n e ζ.",
                                    "Crie uma tabela comparativa de h(t) para combinações de parâmetros."
                                  ],
                                  "verification": "Explique como mudanças em ω_n e ζ alteram amplitude, frequência e decaimento em plots personalizados.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Software de plotagem (MATLAB/Python)",
                                    "Folhas de derivação analítica",
                                    "Planilha Excel para tabelas"
                                  ],
                                  "tips": "Normalize h(t) pela massa m para isolar efeitos de ω_n e ζ.",
                                  "learningObjective": "Relacionar parâmetros modais diretamente às características observáveis de h(t).",
                                  "commonMistakes": [
                                    "Esquecer fator 1/m na amplitude",
                                    "Confundir ω_n com ω_d na interpretação de frequência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar Propriedades de h(t) com Contextos Aeroespaciais",
                                  "subSteps": [
                                    "Identifique um exemplo: vibrações de painéis aeroespaciais sob impacto (ex: detritos espaciais simulados por impulso).",
                                    "Modele o painel como SDOF com parâmetros reais (ω_n ≈ 100 rad/s, ζ ≈ 0.01 para estruturas leves).",
                                    "Interprete h(t): causalidade garante predição futura sem passado, baixa ζ explica vibrações persistentes (flutter risk).",
                                    "Simule resposta e discuta mitigação: aumentar ζ via amortecedores.",
                                    "Compare com dados experimentais ou literatura aeroespacial."
                                  ],
                                  "verification": "Descreva verbalmente ou em relatório como propriedades de h(t) impactam design de painéis.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Artigos sobre aeroelasticidade (ex: Bisplinghoff)",
                                    "Software de simulação",
                                    "Vídeos de testes de vibração"
                                  ],
                                  "tips": "Pesquise valores reais de ζ para estruturas aeroespaciais (geralmente <0.05).",
                                  "learningObjective": "Aplicar interpretação de h(t) a problemas reais de dinâmica aeroespacial.",
                                  "commonMistakes": [
                                    "Superestimar ζ em estruturas leves",
                                    "Ignorar efeitos não-lineares em aplicações reais"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um painel de asa de satélite (m=1 kg, k=10000 N/m, c=20 Ns/m → ω_n=100 rad/s, ζ=0.1) sujeito a um impacto de micrometeorito modelado como δ(t). Plote h(t), identifique causalidade (h(t)=0 para t<0), oscilações decaindo infinitamente mas praticamente até 10s, e explique como ζ baixo causa vibrações prolongadas que podem excitar modos aeroelásticos.",
                              "finalVerifications": [
                                "Explicar corretamente causalidade com justificativa física.",
                                "Plotar h(t) para ζ>0 mostrando decaimento para zero.",
                                "Prever qualitativamente efeitos de aumentar ω_n ou ζ.",
                                "Relacionar propriedades a risco de fadiga em painéis aeroespaciais.",
                                "Derivar h(t) analiticamente para caso subamortecido.",
                                "Diferenciar respostas estáveis vs. instáveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação e interpretação de causalidade (30%)",
                                "Correção nas análises de duração e parâmetros modais (30%)",
                                "Qualidade e legibilidade de plots/simulações (20%)",
                                "Relevância das conexões aeroespaciais (10%)",
                                "Clareza na explicação verbal/escrita (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformadas de Laplace para derivação de h(t).",
                                "Física: Princípios de conservação e dissipação de energia em osciladores.",
                                "Engenharia Mecânica: Projeto de amortecedores para controle de vibrações.",
                                "Ciência de Materiais: Influência de propriedades do material em ζ.",
                                "Controle de Sistemas: Uso de h(t) em análise de controlabilidade."
                              ],
                              "realWorldApplication": "Em aeronaves e satélites, interpretar h(t) permite prever vibrações induzidas por impactos (ex: granizo ou detritos), otimizando designs para evitar fadiga estrutural e flutter, como no desenvolvimento de painéis compostos com amortecimento integrado para missões espaciais de longa duração."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.2",
                        "name": "Integral de Convolução de Duhamel",
                        "description": "O integral de Duhamel expressa a resposta particular de um sistema SDOF a uma excitação arbitrária p(t) como uma convolução temporal da força com a função h(t), permitindo o tratamento de forças não periódicas ou irregulares.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.2.1",
                            "name": "Formular o integral de Duhamel para resposta particular",
                            "description": "Escrever a fórmula x_p(t) = ∫_0^t h(t-τ) p(τ) dτ para a resposta particular a uma força arbitrária p(t), justificando a superposição linear e a propriedade de convolução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a resposta ao impulso unitário h(t)",
                                  "subSteps": [
                                    "Lembre-se da equação diferencial para SDOF: mẍ + cẋ + kx = p(t)",
                                    "Identifique a resposta x(t) quando p(t) = δ(t), o impulso unitário",
                                    "Derive ou recorde h(t) = (1/mω_d) e^{-ζω_n t} sin(ω_d t) para t ≥ 0, onde ω_d = ω_n √(1-ζ²)",
                                    "Verifique as propriedades causais de h(t): h(t)=0 para t<0",
                                    "Esboce graficamente h(t) para um sistema subamortecido"
                                  ],
                                  "verification": "Escreva a expressão exata de h(t) e confirme que ela satisfaz a equação para impulso unitário",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Equação diferencial SDOF anotada",
                                    "Tabela de fórmulas de dinâmica",
                                    "Gráfica de h(t) exemplo"
                                  ],
                                  "tips": "Use o método de Laplace ou variação de parâmetros para derivar h(t) se necessário; foque na normalização para impulso unitário",
                                  "learningObjective": "Compreender h(t) como a resposta green's function para o sistema SDOF",
                                  "commonMistakes": [
                                    "Confundir h(t) com resposta a degrau unitário",
                                    "Esquecer o fator 1/m na amplitude",
                                    "Ignorar condições iniciais zero"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar superposição linear para forças em degraus",
                                  "subSteps": [
                                    "Expresse p(t) como soma de degraus infinitesimais: p(t) = ∫_0^t dp(τ) onde dp(τ) = p'(τ) dτ",
                                    "Resposta a um degrau unitário em τ é H(t-τ) = ∫_0^{t-τ} h(s) ds",
                                    "Some linearmente: x_p(t) ≈ Σ H(t-τ_i) Δp_i para aproximação discreta",
                                    "Tome limite para integral: x_p(t) = ∫_0^t H(t-τ) p'(τ) dτ",
                                    "Integre por partes para converter em forma de convolução com h(t)"
                                  ],
                                  "verification": "Derive a relação entre resposta a degrau e h(t), mostrando x_p(t) = ∫_0^t h(t-τ) p'(τ) dτ + h(t) p(0)",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gráficos de p(t) em degraus",
                                    "Software de plotagem como MATLAB ou Python (Matplotlib)",
                                    "Papel para esboços discretos"
                                  ],
                                  "tips": "Pense em p(t) como 'escada' de degraus pequenos; visualize animações de superposição",
                                  "learningObjective": "Justificar superposição linear para discretização de p(t) arbitrária",
                                  "commonMistakes": [
                                    "Esquecer limites de integração de 0 a t",
                                    "Confundir p(τ) com p'(τ)",
                                    "Não considerar causalidade (τ > t)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar o integral de Duhamel na forma convolução",
                                  "subSteps": [
                                    "Comece da equação mẍ + cẋ + kx = p(t) com x(0)=ẋ(0)=0",
                                    "Use variação de parâmetros: solução particular x_p(t) = u_1(t) y_1(t) + u_2(t) y_2(t)",
                                    "Aplique condições para obter u_1' y_1 + u_2' y_2 = 0 e u_1' ẏ_1 + u_2' ẏ_2 = p(t)/m",
                                    "Resolva o sistema usando Wronskiano, levando a convolução",
                                    "Simplifique para x_p(t) = ∫_0^t h(t-τ) p(τ) dτ"
                                  ],
                                  "verification": "Escreva a fórmula final x_p(t) = ∫_0^t h(t-τ) p(τ) dτ e verifique dimensionalmente",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas de variação de parâmetros",
                                    "Exemplos resolvidos de EDOs lineares",
                                    "Calculadora simbólica como SymPy"
                                  ],
                                  "tips": "Lembre que h(t) incorpora os efeitos de amortecimento e rigidez; teste com p(t)=δ(t) para recuperar h(t)",
                                  "learningObjective": "Derivar formalmente o integral de Duhamel via métodos clássicos",
                                  "commonMistakes": [
                                    "Inverter limites de integração",
                                    "Usar h(τ-t) em vez de h(t-τ)",
                                    "Esquecer fator de massa m em h(t)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificar propriedades de superposição e convolução",
                                  "subSteps": [
                                    "Explique linearidade: sistema LTI implica x_p(t) = L[p(t)] onde L é linear",
                                    "Mostre convolução: resposta = h * p = ∫ h(t-τ) p(τ) dτ",
                                    "Verifique commudatividade: h*p = p*h (para extensões adequadas)",
                                    "Discuta propriedade causal: depende só de p(τ) para τ ≤ t",
                                    "Aplique a exemplo simples como p(t)=P_0 para t>0, recuperando solução conhecida"
                                  ],
                                  "verification": "Justifique por que a fórmula satisfaz a EDO original via Leibniz rule para derivadas sob integral",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de propriedades de convolução",
                                    "Exemplos numéricos em Excel ou Python",
                                    "Livro de referência em dinâmica (ex: Thomson)"
                                  ],
                                  "tips": "Diferencie a fórmula sob o integral para verificar que ẍ_p + ... = p(t)/m",
                                  "learningObjective": "Compreender as fundações matemáticas e físicas do integral de Duhamel",
                                  "commonMistakes": [
                                    "Confundir com transformada de Laplace (embora relacionada)",
                                    "Ignorar condições iniciais na justificativa",
                                    "Não testar com casos conhecidos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma viga de asa de aeronave modelada como SDOF com m=10 kg, c=2 Ns/m, k=100 N/m, e força aerodinástica p(t)=10 sin(5t) N, compute x_p(t) usando Duhamel com h(t) calculada, plotando a resposta para t=0 a 10s em Python.",
                              "finalVerifications": [
                                "Escreve corretamente x_p(t) = ∫_0^t h(t-τ) p(τ) dτ",
                                "Deriva h(t) para sistema dado",
                                "Justifica superposição para p(t) arbitrária",
                                "Verifica fórmula diferenciando sob o integral",
                                "Aplica a exemplo numérico simples",
                                "Explica causalidade e propriedades LTI"
                              ],
                              "assessmentCriteria": [
                                "Precisão na fórmula e limites de integração (30%)",
                                "Correta derivação/justificativa de superposição (25%)",
                                "Uso apropriado de h(t) e suas propriedades (20%)",
                                "Verificação via EDO ou exemplos (15%)",
                                "Clareza na explicação escrita (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de EDOs lineares e convolução",
                                "Física: Princípios de dinâmica newtoniana e lineares",
                                "Engenharia: Simulações numéricas em MATLAB/Python para aeroelasticidade",
                                "Computação: Implementação de integrais numéricas (quadrature)",
                                "Controle: Extensão a sistemas MIMO e controle ativo"
                              ],
                              "realWorldApplication": "Em aeroelasticidade, o integral de Duhamel modela a resposta de estruturas aeronáuticas a cargas gust de vento ou turbulência, essencial para certificação de fadiga em asas de aviões como o Boeing 787, evitando flutter catastrófico."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.1.3"
                            ]
                          },
                          {
                            "id": "10.1.2.4.2.2",
                            "name": "Calcular resposta para excitação em degrau unitário",
                            "description": "Aplicar o integral de Duhamel para calcular a resposta a uma força em degrau unitário H(t), obtendo x(t) = ∫_0^t h(τ) dτ, e simplificar para casos não amortecido e amortecido.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a função impulso h(t) para sistemas SDOF não amortecido e amortecido",
                                  "subSteps": [
                                    "Recordar a equação de movimento geral: m ÿ + c ẏ + k y = f(t)",
                                    "Derivar ou recordar h(t) para caso não amortecido: h(t) = (1/(m ω)) sin(ω t), onde ω = √(k/m)",
                                    "Derivar ou recordar h(t) para caso amortecido: h(t) = (1/(m ω_d)) e^{-ζ ω_n t} sin(ω_d t), onde ω_n = √(k/m), ω_d = ω_n √(1-ζ²)",
                                    "Verificar unidades e condições iniciais: h(0)=0, h'(0)=1/m",
                                    "Esboçar graficamente h(t) para ambos os casos"
                                  ],
                                  "verification": "Escrever corretamente as expressões de h(t) para os dois casos e verificar h'(0)=1/m",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel, lápis, calculadora, tabela de fórmulas de dinâmica",
                                  "tips": "Use ω_n e ζ como parâmetros padrão para evitar confusões com ω",
                                  "learningObjective": "Compreender a resposta ao impulso como base para o integral de Duhamel",
                                  "commonMistakes": "Confundir ω (não amortecido) com ω_n (amortecido) ou esquecer o fator 1/m"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar e calcular a resposta x(t) para excitação em degrau unitário no caso não amortecido",
                                  "subSteps": [
                                    "Escrever a convolução para f(t)=H(t): x(t) = ∫_0^t h(τ) dτ",
                                    "Substituir h(τ) = (1/(m ω)) sin(ω τ)",
                                    "Calcular o integral: ∫ sin(ω τ) dτ = (-1/ω) cos(ω τ)",
                                    "Avaliar limites de 0 a t: x(t) = (1/(m ω²)) [1 - cos(ω t)]",
                                    "Verificar condições iniciais: x(0)=0, ẋ(0)=0"
                                  ],
                                  "verification": "Obter x(t) = (1/k) [1 - cos(ω t)] (pois ω²=k/m) e plotar a resposta",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora simbólica ou software como Mathematica/MATLAB, papel quadriculado",
                                  "tips": "Integre por partes se necessário e simplifique usando k = m ω²",
                                  "learningObjective": "Aplicar integral de Duhamel para obter resposta em degrau não amortecido",
                                  "commonMistakes": "Esquecer os limites do integral ou sinal negativo na integração de sin"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar e calcular a resposta x(t) para excitação em degrau unitário no caso amortecido",
                                  "subSteps": [
                                    "Reescrever x(t) = ∫_0^t h(τ) dτ com h(τ) amortecido",
                                    "Substituir h(τ) = (1/(m ω_d)) e^{-ζ ω_n τ} sin(ω_d τ)",
                                    "Calcular o integral usando integração por partes duas vezes ou fórmula padrão",
                                    "Simplificar: x(t) = (1/k) [1 - e^{-ζ ω_n t} (cos(ω_d t) + (ζ ω_n / ω_d) sin(ω_d t)) ]",
                                    "Analisar comportamento assintótico: x(∞) = 1/k"
                                  ],
                                  "verification": "Confirmar que x(t) tende a 1/k para t→∞ e condições iniciais zero",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software de cálculo simbólico (SymPy ou MATLAB), notas de fórmulas",
                                  "tips": "Use a identidade de ângulo para simplificar o termo exponencial-senoidal",
                                  "learningObjective": "Dominar o cálculo do integral de Duhamel para sistemas amortecidos",
                                  "commonMistakes": "Erro no coeficiente de amortecimento no termo sin ou confusão entre ω_n e ω_d"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar, interpretar e comparar as respostas obtidas",
                                  "subSteps": [
                                    "Comparar x(t) não amortecido vs. amortecido graficamente",
                                    "Verificar limites: t=0, t→∞, máxima deslocamento",
                                    "Interpretar fisicamente: oscilação persistente vs. decaimento",
                                    "Discutir generalizações para forças arbitrárias",
                                    "Resolver um problema numérico simples para validação"
                                  ],
                                  "verification": "Gráficos coincidem com soluções analíticas conhecidas e condições físicas",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Gráficos em Excel/MATLAB, exemplos numéricos",
                                  "tips": "Plote para ζ=0.1 e compare com não amortecido",
                                  "learningObjective": "Interpretar resultados no contexto de dinâmica estrutural",
                                  "commonMistakes": "Ignorar decaimento exponencial ou prever amplitude errada"
                                }
                              ],
                              "practicalExample": "Considere m=1 kg, k=100 N/m (ω=10 rad/s), ζ=0.1. Para não amortecido: x(t)=(1/100)[1-cos(10t)]. Para amortecido: ω_n=10, ω_d≈9.95, x(t)=(1/100)[1 - e^{-t} (cos(9.95t) + 0.1005 sin(9.95t))]. Calcule x(0.5s) e plote até t=2s.",
                              "finalVerifications": [
                                "x(0)=0 e ẋ(0)=0 para ambos casos",
                                "x(t→∞)=1/k (deslocamento estático)",
                                "Não amortecido oscila indefinidamente com amplitude 2/k",
                                "Amortecido decai para 1/k sem overshoot excessivo",
                                "Gráficos mostram frequência correta (ω ou ω_d)",
                                "Cálculos numéricos coincidem com simulação numérica"
                              ],
                              "assessmentCriteria": [
                                "Expressões de h(t) corretas e completas",
                                "Integração precisa com limites corretos",
                                "Simplificações algébricas adequadas (ex: 1/(m ω²)=1/k)",
                                "Verificação de condições iniciais e assintóticas",
                                "Interpretação física clara e comparação entre casos",
                                "Exemplo prático resolvido sem erros aritméticos"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Técnicas de integração indefinida e por partes",
                                "Física: Oscilações forçadas e amortecimento viscoso",
                                "Programação: Implementação numérica do integral de convolução em Python/MATLAB",
                                "Engenharia de Controle: Análise de resposta em degrau para estabilidade",
                                "Engenharia Aeroespacial: Modelagem de flutter e vibrações estruturais"
                              ],
                              "realWorldApplication": "Em aeroelasticidade, calcular a resposta de uma asa de aeronave a uma carga súbita como uma rajada de vento (modelada como degrau unitário), prevendo deslocamentos para evitar fadiga estrutural ou instabilidades como flutter durante o voo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.3",
                        "name": "Resposta Total a Excitações Arbitrárias",
                        "description": "A resposta total combina a solução homogênea (devida a condições iniciais) com a particular obtida pelo integral de Duhamel, aplicável a cargas irregulares em estruturas aeroespaciais como rajadas de vento.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.3.1",
                            "name": "Determinar resposta total incluindo condições iniciais",
                            "description": "Combinar x(t) = x_h(t) + x_p(t), onde x_h(t) satisfaz condições iniciais x(0) e ẋ(0), ajustando constantes para compatibilidade com o integral de Duhamel.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular a solução homogênea x_h(t) e identificar condições iniciais",
                                  "subSteps": [
                                    "Recordar a equação diferencial do sistema SDOF: mẍ + cẋ + kx = f(t).",
                                    "Derivar ou recordar a solução homogênea x_h(t) = A cos(ω_d t) + B sen(ω_d t), onde ω_d = ω_n √(1-ζ²).",
                                    "Identificar as condições iniciais dadas: x(0) e ẋ(0).",
                                    "Listar os parâmetros do sistema: massa m, amortecimento c, rigidez k, frequência natural ω_n e fator de amortecimento ζ.",
                                    "Verificar se o sistema está subamortecido, crítico ou superamortecido e ajustar a forma de x_h(t) conforme necessário."
                                  ],
                                  "verification": "Confirmar que x_h(0) = A e ẋ_h(0) = ω_d B correspondem às condições iniciais iniciais (ainda sem ajuste final).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora científica",
                                    "Livro-texto de dinâmica (cap. SDOF)",
                                    "Software simbólico como Mathematica ou SymPy (opcional)"
                                  ],
                                  "tips": "Sempre normalize as condições iniciais dividindo por m para obter velocidades iniciais normalizadas.",
                                  "learningObjective": "Compreender a estrutura da solução homogênea e seu papel em satisfazer condições iniciais.",
                                  "commonMistakes": [
                                    "Esquecer de considerar o amortecimento na forma de x_h(t)",
                                    "Confundir ω_n com ω_d",
                                    "Não normalizar f(t)/m no integral de Duhamel"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a solução particular x_p(t) usando o integral de Duhamel",
                                  "subSteps": [
                                    "Escrever o integral de Duhamel: x_p(t) = (1/(m ω_d)) ∫[0 to t] f(τ) e^{-ζ ω_n (t-τ)} sen(ω_d (t-τ)) dτ.",
                                    "Identificar a função de influência h(t-τ) = (1/(m ω_d)) e^{-ζ ω_n (t-τ)} sen(ω_d (t-τ)).",
                                    "Para f(t) arbitrária, representar como convolução ou calcular numericamente se necessário.",
                                    "Simplificar para casos comuns (ex: degrau, impulso, harmônica) se aplicável.",
                                    "Verificar que x_p(0) = 0 e ẋ_p(0) = 0, pois inicia em repouso."
                                  ],
                                  "verification": "Calcular x_p(0) e ẋ_p(0); ambos devem ser zero.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora ou MATLAB para integração numérica",
                                    "Tabelas de integrais de Duhamel pré-computadas"
                                  ],
                                  "tips": "Use a propriedade da convolução para excitações conhecidas; memorize formas para degrau unitário.",
                                  "learningObjective": "Dominar o cálculo do integral de Duhamel para excitações arbitrárias.",
                                  "commonMistakes": [
                                    "Esquecer o fator 1/m na função de influência",
                                    "Invertar os limites de integração",
                                    "Não usar a variável de convolução τ corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a solução total x(t) = x_h(t) + x_p(t)",
                                  "subSteps": [
                                    "Escrever explicitamente x(t) = A cos(ω_d t) + B sen(ω_d t) + x_p(t).",
                                    "Expandir ẋ(t) = -A ω_d sen(ω_d t) + B ω_d cos(ω_d t) + ẋ_p(t).",
                                    "Garantir continuidade em t=0: x(0) = x_h(0) + x_p(0) = A.",
                                    "Verificar que x_p contribui zero nas derivadas iniciais.",
                                    "Discutir compatibilidade: constantes A e B serão ajustadas para compensar x_p."
                                  ],
                                  "verification": "Substituir t=0 em x(t) e ẋ(t) e confirmar estrutura antes de resolver constantes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Folha de fórmulas de dinâmica SDOF"
                                  ],
                                  "tips": "Anote x(t) e ẋ(t) lado a lado para facilitar aplicação de condições iniciais.",
                                  "learningObjective": "Entender a superposição da solução total e o papel de cada componente.",
                                  "commonMistakes": [
                                    "Atribuir condições iniciais diretamente a x_p(t)",
                                    "Esquecer de derivar ẋ_p(t) corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar condições iniciais e determinar constantes A e B",
                                  "subSteps": [
                                    "Em t=0: x(0) = A + x_p(0) = x(0)_dado → A = x(0)_dado (já que x_p(0)=0).",
                                    "Derivar ẋ(t) e em t=0: ẋ(0) = B ω_d + ẋ_p(0) = ẋ(0)_dado → B = [ẋ(0)_dado - ẋ_p(0)] / ω_d.",
                                    "Calcular ẋ_p(0) se necessário (geralmente zero para t>0).",
                                    "Substituir A e B na solução total.",
                                    "Simplificar a expressão final de x(t)."
                                  ],
                                  "verification": "Substituir t=0 na solução final e confirmar x(0) e ẋ(0) exatos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Papel para derivações",
                                    "Software para plotar x(t) vs tempo"
                                  ],
                                  "tips": "Sempre verifique numericamente com valores de exemplo para validar A e B.",
                                  "learningObjective": "Resolver sistema de equações para constantes usando superposição.",
                                  "commonMistakes": [
                                    "Não subtrair contribuição de ẋ_p(0) ao calcular B",
                                    "Confundir unidades de velocidade inicial"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e validar a solução total",
                                  "subSteps": [
                                    "Verificar se x(t) satisfaz a EDO original substituindo em mẍ + cẋ + kx =? f(t).",
                                    "Plotar ou tabular x(t) para t>0 e observar comportamento físico (ex: oscilações amortecidas).",
                                    "Comparar com casos especiais (ex: f(t)=0 → só x_h).",
                                    "Analisar limites: t→0 e t→∞.",
                                    "Documentar a solução final com todas as constantes determinadas."
                                  ],
                                  "verification": "Solução atende EDO, condições iniciais e limites físicos esperados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "MATLAB ou Python para simulação numérica",
                                    "Gráficos de resposta"
                                  ],
                                  "tips": "Use simulação numérica (ex: ode45 no MATLAB) para validar analítica.",
                                  "learningObjective": "Validar rigorosamente a solução completa.",
                                  "commonMistakes": [
                                    "Ignorar verificação da EDO",
                                    "Erros de sinal em derivações"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema SDOF subamortecido com m=1 kg, k=4 N/m (ω_n=2 rad/s), ζ=0.1, f(t)=sen(3t) u(t) N, x(0)=0.5 m, ẋ(0)=0 m/s. Calcule x_h(t) = A cos(1.905 t) + B sen(1.905 t), x_p(t) via Duhamel, determine A=0.5, B ≈ -0.1 (ajustado), e obtenha x(t) final. Plote para validar.",
                              "finalVerifications": [
                                "x(0) e ẋ(0) atendem exatamente às condições dadas.",
                                "x_p(0)=0 e ẋ_p(0)=0 confirmados.",
                                "Solução satisfaz a EDO mẍ + cẋ + kx = f(t) para t>0.",
                                "Comportamento assintótico correto (amortecimento para t→∞ se ζ>0).",
                                "Constantes A e B calculadas corretamente via sistema linear.",
                                "Gráfico de x(t) mostra transientes iniciais + resposta forçada."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo do integral de Duhamel (erro <5%).",
                                "Correta aplicação de condições iniciais em x_h(t).",
                                "Verificação completa da EDO e limites iniciais.",
                                "Interpretação física da solução (transiente vs estacionária).",
                                "Clareza na derivação passo a passo e simplificações.",
                                "Validação numérica ou gráfica quando aplicável."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Integração por partes e convolução em EDOs lineares.",
                                "Física: Princípio de superposição em osciladores harmônicos.",
                                "Engenharia de Controle: Resposta a entradas arbitrárias em sistemas de controle.",
                                "Engenharia Civil: Vibrações em edifícios sob cargas sísmicas.",
                                "Computação: Implementação numérica em Python/MATLAB para simulações."
                              ],
                              "realWorldApplication": "Em aeroelasticidade, determinar a resposta total de uma asa a rajadas turbulentas (f(t) arbitrária), incluindo deformação inicial x(0) e velocidade ẋ(0), para prever flutter e evitar falhas estruturais em aeronaves."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.2.2"
                            ]
                          },
                          {
                            "id": "10.1.2.4.3.2",
                            "name": "Aplicar numericamente para força arbitrária",
                            "description": "Implementar aproximação numérica do integral de Duhamel usando método de trapezoidal ou Simpson para uma força p(t) dada discretamente, como em simulações de vibrações aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar parâmetros do sistema SDOF e dados da força arbitrária",
                                  "subSteps": [
                                    "Definir massa (m), rigidez (k) e amortecimento (c) para calcular ω_n = sqrt(k/m) e ζ = c/(2 sqrt(k m)).",
                                    "Estabelecer vetor de tempo discreto t (ex: dt = 0.01 s, T_total = 10 s).",
                                    "Fornecer vetor de força p(t) discretizado (ex: carga sinusoidal ou de simulação aeroespacial).",
                                    "Criar arrays NumPy para t, p_t e inicializar resposta y(t) = 0.",
                                    "Verificar unidades consistentes (SI)."
                                  ],
                                  "verification": "Parâmetros calculados corretamente e arrays têm mesmo comprimento; imprimir shapes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Python com NumPy; editor de código (Jupyter Notebook recomendado).",
                                  "tips": "Use np.linspace para t e np.zeros para y.",
                                  "learningObjective": "Compreender e preparar dados iniciais para integração numérica em SDOF.",
                                  "commonMistakes": "Unidades inconsistentes; dt muito grande causando imprecisão."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a função de resposta ao impulso unitário h(t)",
                                  "subSteps": [
                                    "Calcular frequência amortecida ω_d = ω_n * sqrt(1 - ζ²).",
                                    "Implementar h(τ) = (1/(m ω_d)) * exp(-ζ ω_n τ) * sin(ω_d τ) para τ >= 0.",
                                    "Criar função vetorizada que recebe τ e retorna h(τ).",
                                    "Testar h(τ) para valores isolados e plotar para verificação.",
                                    "Garantir h(τ) = 0 para τ < 0."
                                  ],
                                  "verification": "Plot de h(τ) mostra oscilação amortecida correta; h(0) ≈ 0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "NumPy, Matplotlib para plot.",
                                  "tips": "Use np.where(tau >= 0, formula, 0) para vetorização.",
                                  "learningObjective": "Implementar corretamente o kernel de Duhamel para SDOF.",
                                  "commonMistakes": "Esquecer fator 1/(m ω_d); sinal errado no expoente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar método de integração numérica (Trapezoidal ou Simpson)",
                                  "subSteps": [
                                    "Escolher Trapezoidal: ∫ f ≈ dt/2 * (f_i + f_{i+1}) + soma anteriores.",
                                    "Para cada t_i, calcular ∫_0^{t_i} p(τ) h(t_i - τ) dτ discretamente.",
                                    "Criar loop ou vetorizado: para i in range(len(t)), integral += trapezoidal(p[:i+1] * h(t[i] - t[:i+1])).",
                                    "Implementar função trapezoidal_rule(input_array).",
                                    "Otimizar com convolução NumPy se possível (np.convolve).",
                                    "verification"
                                  ],
                                  "verification": "Testar integral simples conhecido (ex: ∫ sin = 1 - cos); erro < 1%.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "NumPy (np.trapz ou manual).",
                                  "tips": "Use np.trapz para simplicidade inicial.",
                                  "learningObjective": "Aplicar Trapezoidal/Simpson em convolução temporal.",
                                  "commonMistakes": "Índices errados no loop (off-by-one); não inverter t-τ."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular e armazenar a resposta total y(t)",
                                  "subSteps": [
                                    "Para cada t_i, y[i] = integral calculado no step anterior.",
                                    "Aplicar condições iniciais se y(0)=0, dy(0)=0.",
                                    "Armazenar y em array e calcular velocidade se necessário.",
                                    "Plotar p(t) vs y(t) para visualização.",
                                    "Comparar com resposta analítica para caso simples (opcional)."
                                  ],
                                  "verification": "y(t) inicia em 0 e oscila com amortecimento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Matplotlib.",
                                  "tips": "Vetorize o loop com meshgrid se performance baixa.",
                                  "learningObjective": "Montar resposta de Duhamel numérica completa.",
                                  "commonMistakes": "Acumular integral sem reset; fator de escala esquecido."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar resultados e analisar sensibilidade",
                                  "subSteps": [
                                    "Refinar dt e comparar convergência (erro relativo).",
                                    "Testar com Simpson (np.simps) vs Trapezoidal.",
                                    "Analisar picos, período e fator de qualidade Q.",
                                    "Exportar dados ou animação da resposta.",
                                    "Documentar código com comentários."
                                  ],
                                  "verification": "Erro de convergência < 0.5% ao halvar dt.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Matplotlib, SciPy para simps.",
                                  "tips": "Use loglog para plot de erro vs dt.",
                                  "learningObjective": "Garantir precisão e robustez da implementação.",
                                  "commonMistakes": "Ignorar aliasing temporal; ζ >1 sem ajuste."
                                }
                              ],
                              "practicalExample": "Em uma simulação de vibrações de uma asa de aeronave sob rajada de vento modelada como p(t) discreta (amostra a 100 Hz por 20s), calcular y(t) usando Trapezoidal com dt=0.005s, identificando risco de flutter.",
                              "finalVerifications": [
                                "Código executa sem erros para dados de entrada válidos.",
                                "Resposta y(t) exibe amortecimento e frequência corretos.",
                                "Integral converge com refinamento de malha temporal.",
                                "Comparação com np.convolve(h flipped, p) coincide.",
                                "Plot mostra coerência física (sem explosão numérica).",
                                "Tempo de execução razoável (<5s para N=2000)."
                              ],
                              "assessmentCriteria": [
                                "Precisão da integração (erro <1% vs analítico simples).",
                                "Eficiência computacional (O(N^2) otimizado para O(N log N)).",
                                "Correção da função h(t) (verificação unitária).",
                                "Clareza do código (comentários, funções modulares).",
                                "Análise de sensibilidade a dt e ζ incluída.",
                                "Visualizações informativas e legíveis."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Métodos de quadratura (Trapezoidal/Simpson).",
                                "Programação: Vetorização NumPy, otimização de loops.",
                                "Física: Dinâmica linear, convolução em sistemas LTI.",
                                "Engenharia Aeroespacial: Simulações de aeroelasticidade.",
                                "Análise de Dados: Validação e plotting com Matplotlib."
                              ],
                              "realWorldApplication": "Simulações de resposta estrutural em aeronaves a cargas aerodinâmicas arbitrárias (ex: turbulência, manobras), prevendo fadiga, flutter ou falhas em projetos da Embraer/ Boeing."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.2.4.3.3",
                            "name": "Analisar resposta em contextos aeroespaciais",
                            "description": "Interpretar resultados do integral de Duhamel para excitações como turbulência atmosférica em asas, relacionando com referências como Meirovitch e Rao.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a formulação do Integral de Duhamel para sistemas SDOF",
                                  "subSteps": [
                                    "Derivar a equação de movimento para um sistema SDOF sob excitação arbitrária: mẍ + cẋ + kx = p(t).",
                                    "Introduzir a função de resposta ao impulso h(t) = (1/mω_d) e^{-ζω_n t} sin(ω_d t), onde ω_d = ω_n √(1-ζ²).",
                                    "Escrever o integral de Duhamel: x(t) = ∫_0^t p(τ) h(t-τ) dτ.",
                                    "Discutir a resposta total como superposição de respostas impulsivas.",
                                    "Verificar unidades e condições iniciais (x(0)=0, ẋ(0)=0)."
                                  ],
                                  "verification": "Derivar corretamente o integral de Duhamel e resolvê-lo para p(t) constante, comparando com solução analítica conhecida.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro Meirovitch 'Elements of Vibration Analysis', caderno, calculadora simbólica (SymPy ou Mathematica).",
                                  "tips": "Sempre normalize o tempo com ω_n para simplificar cálculos numéricos.",
                                  "learningObjective": "Compreender a base matemática do método de Duhamel para respostas dinâmicas.",
                                  "commonMistakes": "Confundir h(t) com a resposta unitária passo; ignorar o fator 1/mω_d."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar excitações aeroespaciais como turbulência atmosférica em asas",
                                  "subSteps": [
                                    "Descrever turbulência como p(t) estocástico, modelado por espectro de von Kármán ou Dryden.",
                                    "Relacionar com aerodinâmica: p(t) ≈ L ρ V² C_L α(t), onde α(t) é variação de ângulo de ataque devido a rajadas.",
                                    "Simplificar para SDOF: considerar heaving ou pitching de uma seção de asa.",
                                    "Obter dados de referência: espectros de turbulência de ESDU ou NASA.",
                                    "Discretizar p(t) para integração numérica se necessário."
                                  ],
                                  "verification": "Construir um modelo simplificado de p(t) para rajada de vento e plotar sua forma espectral.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Rao 'Vibration of Continuous Systems', software MATLAB/Python para plotar espectros, dados de turbulência online.",
                                  "tips": "Use funções de potência espectral para caracterizar turbulência em vez de waveforms arbitrárias.",
                                  "learningObjective": "Mapear excitações reais aeroespaciais para forças de entrada no modelo SDOF.",
                                  "commonMistakes": "Negligenciar coeficientes aerodinâmicos dinâmicos (como Teodorsen); assumir p(t) determinístico."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e interpretar a resposta usando o integral de Duhamel",
                                  "subSteps": [
                                    "Implementar numericamente o integral de Duhamel via convolução: x[n] = sum p[k] h[n-k] Δt.",
                                    "Analisar resposta em domínio do tempo: picos, overshoots, decaimento.",
                                    "Transformar para frequência: usar FFT para comparar com função de transferência H(ω).",
                                    "Interpretar: amplitudes de resposta vs. frequência natural; efeitos de amortecimento.",
                                    "Quantificar fadiga: calcular RMS de x(t) para cargas cíclicas."
                                  ],
                                  "verification": "Computar x(t) para p(t)=rajada sinusoidal e verificar matching com solução exata.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "MATLAB ou Python (SciPy.signal.convolve), exemplos de código de Meirovitch.",
                                  "tips": "Use trapezoidal rule para integração precisa em p(t) irregular.",
                                  "learningObjective": "Aplicar Duhamel para obter e interpretar respostas transitórias e estacionárias.",
                                  "commonMistakes": "Erro de truncamento em convolução; confundir resposta total com particular."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar resultados com referências e contextos aeroespaciais",
                                  "subSteps": [
                                    "Comparar com Meirovitch (Cap. 6): validação para aeroelasticidade.",
                                    "Consultar Rao (Cap. 8): aplicações em painéis e asas.",
                                    "Discutir implicações: risco de flutter, cargas de manobra.",
                                    "Avaliar sensibilidade: variar ζ, ω_n em relação a velocidades de voo.",
                                    "Documentar limitações do modelo SDOF vs. MDOF."
                                  ],
                                  "verification": "Escrever relatório resumindo concordância com exemplos de livros e implicações práticas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Cópias de Meirovitch e Rao, artigos AIAA sobre gust loads.",
                                  "tips": "Crie tabela comparativa de resultados numéricos vs. analíticos das referências.",
                                  "learningObjective": "Conectar teoria a literatura padrão e aplicações aeroespaciais.",
                                  "commonMistakes": "Ignorar não-linearidades aerodinâmicas; generalizar SDOF para estruturas complexas."
                                }
                              ],
                              "practicalExample": "Analisar a resposta heaving de uma seção de asa NACA 0012 sob turbulência Dryden (V=100 m/s, alt=5000m), usando m=10 kg/m, k=10^5 N/m, c=200 Ns/m. Compute x(t) via Duhamel, plote deslocamentos e calcule fator de pico de 2.5, validando com dados de Rao.",
                              "finalVerifications": [
                                "Derivação correta do integral de Duhamel para SDOF.",
                                "Modelo preciso de p(t) para turbulência em asas.",
                                "Cálculo numérico de x(t) com erro <1% vs. analítico.",
                                "Interpretação qualitativa e quantitativa da resposta.",
                                "Referenciação adequada a Meirovitch e Rao.",
                                "Análise de sensibilidade a parâmetros."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação e implementação (30%).",
                                "Relevância do modelo aeroespacial (25%).",
                                "Profundidade na interpretação de resultados (20%).",
                                "Integração com referências bibliográficas (15%).",
                                "Clareza na documentação e visualizações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Integração numérica e transformadas de Fourier.",
                                "Física: Dinâmica de vibrações e amortecimento.",
                                "Engenharia Aeronáutica: Aerodinâmica não-estacionária e cargas gust.",
                                "Computação: Programação numérica em MATLAB/Python."
                              ],
                              "realWorldApplication": "Previsão de cargas dinâmicas em asas de aeronaves comerciais devido a turbulência, essencial para certificação FAA/EASA (FAR 25.341), evitando fadiga estrutural e otimizando design de dampers."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.4.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.5",
                    "name": "Excitações de Base",
                    "description": "Modelagem de sistemas SDOF sujeitos a acelerações de base e cálculo da resposta relativa e absoluta.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.5.1",
                        "name": "Modelagem de Sistemas SDOF com Excitações de Base",
                        "description": "Modelagem dinâmica de um sistema com um grau de liberdade sujeito a acelerações impostas na base, incluindo derivação da equação de movimento e representação cinemática.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.1.1",
                            "name": "Derivar a equação de movimento para excitação de base",
                            "description": "Utilizando o princípio de Lagrange ou forças fictícias, derivar a equação diferencial de segunda ordem para um sistema massa-mola-amortecedor sujeito a aceleração vertical Ÿ_g(t) na base, expressando mẍ + c(ẋ - ẏ_g) + k(x - y_g) = 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o sistema físico e coordenadas",
                                  "subSteps": [
                                    "Descreva o sistema massa-mola-amortecedor com excitação de base ŷ_g(t).",
                                    "Defina coordenadas: x como deslocamento absoluto da massa, y_g como deslocamento da base.",
                                    "Introduza coordenada relativa z = x - y_g para simplificação.",
                                    "Identifique parâmetros: m (massa), c (amortecimento), k (rigidez).",
                                    "Desenhe um diagrama esquemático do sistema."
                                  ],
                                  "verification": "Diagrama completo com todas as variáveis rotuladas e coordenadas definidas corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software de desenho como Draw.io ou papel quadriculado"
                                  ],
                                  "tips": "Use setas para velocidades e acelerações para visualizar movimentos relativos.",
                                  "learningObjective": "Compreender a configuração cinemática do sistema SDOF com excitação de base.",
                                  "commonMistakes": [
                                    "Confundir coordenadas absolutas e relativas",
                                    "Esquecer de incluir amortecedor",
                                    "Não rotular forças claramente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escolher e preparar o método de Lagrange",
                                  "subSteps": [
                                    "Revise o princípio de Lagrange: L = T - V, onde T é energia cinética, V é potencial.",
                                    "Decida usar coordenada generalizada q = x (absoluta) ou q = z (relativa); prefira absoluta para simplicidade.",
                                    "Expresse velocidades: ẋ para massa, ẏ_g para base.",
                                    "Liste energias: T = (1/2)m ẋ², V = (1/2)k (x - y_g)².",
                                    "Inclua dissipação para amortecedor: Q = -c (ẋ - ẏ_g)."
                                  ],
                                  "verification": "Expressões corretas para T, V e Q anotadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de anotações",
                                    "Referência rápida de mecânica lagrangiana"
                                  ],
                                  "tips": "Verifique unidades: todas devem ser consistentes (Joules para energias).",
                                  "learningObjective": "Preparar componentes energéticos necessários para derivação lagrangiana.",
                                  "commonMistakes": [
                                    "Usar velocidade relativa incorretamente em T",
                                    "Esquecer termo de dissipação Q",
                                    "Confundir V com deformação absoluta"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a equação usando equações de Lagrange",
                                  "subSteps": [
                                    "Escreva Lagrangiano L = (1/2)m ẋ² - (1/2)k (x - y_g)².",
                                    "Calcule d/dt (∂L/∂ẋ) = m ẍ.",
                                    "Calcule ∂L/∂x = -k (x - y_g).",
                                    "Aplique equação: d/dt (∂L/∂ẋ) - ∂L/∂x + ∂R/∂ẋ = 0, onde R = (1/2)c (ẋ - ẏ_g)², ∂R/∂ẋ = c (ẋ - ẏ_g).",
                                    "Simplifique para m ẍ + c (ẋ - ẏ_g) + k (x - y_g) = 0."
                                  ],
                                  "verification": "Equação derivada matches exatamente a forma alvo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora simbólica como SymPy ou papel para derivadas"
                                  ],
                                  "tips": "Expanda termos passo a passo para evitar erros algébricos.",
                                  "learningObjective": "Aplicar formalismo lagrangiano a sistemas com excitação não conservativa.",
                                  "commonMistakes": [
                                    "Erro no sinal de ∂L/∂x",
                                    "Esquecer força não conservativa do amortecedor",
                                    "Derivada temporal incorreta"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar com método alternativo e interpretar",
                                  "subSteps": [
                                    "Use forças fictícias em frame acelerado da base: força inercial -m ẏ_g.",
                                    "Equilibre forças: m ẍ = -k (x - y_g) - c (ẋ - ẏ_g) - m ẏ_g, rearranje para forma idêntica.",
                                    "Compare ambas derivações para consistência.",
                                    "Interprete: equação em termos relativos z̈ + (c/m) ż + (k/m) z = - ÿ_g.",
                                    "Discuta linearidade e ordem da EDO."
                                  ],
                                  "verification": "Verificação alternativa confirma equação principal; interpretação escrita.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Diagrama de forças livres",
                                    "Referência de dinâmica não inercial"
                                  ],
                                  "tips": "Frame não inercial ajuda a visualizar intuição física.",
                                  "learningObjective": "Validar derivação via múltiplos métodos e ganhar insight físico.",
                                  "commonMistakes": [
                                    "Sinal errado na força fictícia",
                                    "Não rearranjar para forma padrão",
                                    "Ignorar interpretação relativa"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um suporte de motor de aeronave, a base vibra com aceleração ŷ_g(t) devido a turbulência. Derive a equação para prever deslocamento x do motor, usando m=100kg, c=200Ns/m, k=1000N/m, garantindo que o motor não ressoe.",
                              "finalVerifications": [
                                "Equação final é mẍ + c(ẋ - ẏ_g) + k(x - y_g) = 0.",
                                "Termos relativos corretos para mola e amortecedor.",
                                "Verificação via forças fictícias matches Lagrange.",
                                "Lagrangiano L = T - V corretamente formulado.",
                                "Dissipação Q incluída adequadamente.",
                                "Interpretação em coordenada relativa z fornecida."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na derivação (sem erros de sinal ou expansão).",
                                "Correta formulação de energias cinética e potencial.",
                                "Inclusão e tratamento correto da força dissipativa.",
                                "Validação cruzada com método alternativo.",
                                "Clareza no diagrama e anotações.",
                                "Interpretação física da equação final."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e EDOs de segunda ordem.",
                                "Física Geral: Princípios de conservação de energia e frames não inerciais.",
                                "Engenharia Mecânica: Análise de vibrações e controle ativo.",
                                "Programação: Implementação numérica em Python/MATLAB para solução.",
                                "Física Computacional: Simulações de dinâmica molecular semelhantes."
                              ],
                              "realWorldApplication": "Modelagem de isoladores sísmicos em edifícios ou suportes de equipamentos em aeronaves/veículos, prevendo respostas a vibrações de base para design de sistemas anti-vibração e prevenção de falhas estruturais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.2",
                            "name": "Representar cinematicamente a excitação de base",
                            "description": "Definir as coordenadas absolutas x(t) e y_g(t) da massa e da base, respectivamente, e introduzir a coordenada relativa z(t) = x(t) - y_g(t) para simplificar a análise de vibrações transmitidas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Desenhar o diagrama esquemático do sistema SDOF com excitação de base",
                                  "subSteps": [
                                    "Identifique os componentes principais: massa m, mola k e amortecedor c conectados à base móvel.",
                                    "Desenhe a base como uma plataforma horizontal com movimento y_g(t).",
                                    "Posicione a massa acima da base, conectada via mola e amortecedor.",
                                    "Marque as direções positivas para o movimento horizontal.",
                                    "Adicione rótulos para forças e deslocamentos iniciais."
                                  ],
                                  "verification": "Verifique se o diagrama mostra claramente a base se movendo independentemente da massa, com setas indicando direções.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel quadriculado, lápis, régua, software de desenho como Draw.io ou papel e caneta.",
                                  "tips": "Use escala consistente para facilitar cálculos posteriores; inclua uma legenda para símbolos.",
                                  "learningObjective": "Compreender visualmente a configuração do sistema com base excitada.",
                                  "commonMistakes": "Confundir direção do movimento da base com o da massa; esquecer de indicar y_g(t) como função do tempo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir as coordenadas absolutas x(t) e y_g(t)",
                                  "subSteps": [
                                    "Defina x(t) como o deslocamento absoluto da massa em relação a um referencial inercial fixo.",
                                    "Defina y_g(t) como o deslocamento absoluto da base em relação ao mesmo referencial inercial.",
                                    "Escreva as expressões: x(t) para massa, y_g(t) para base.",
                                    "Derive as velocidades: ᴖx/ᴗt e ᴖy_g/ᴗt.",
                                    "Derive as acelerações: ᴖ²x/ᴗt² e ᴖ²y_g/ᴗt²."
                                  ],
                                  "verification": "Confirme que x(t) e y_g(t) são medidos do mesmo ponto fixo e que suas derivadas estão corretas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Caderno de exercícios, calculadora simbólica ou software como Mathematica/SymPy.",
                                  "tips": "Sempre especifique o referencial inercial para evitar ambiguidades.",
                                  "learningObjective": "Estabelecer as posições absolutas do sistema para análise dinâmica.",
                                  "commonMistakes": "Medir x(t) relativo à base em vez de absoluto; ignorar a dependência temporal."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir a coordenada relativa z(t) = x(t) - y_g(t)",
                                  "subSteps": [
                                    "Escreva z(t) = x(t) - y_g(t) como deslocamento relativo da massa em relação à base.",
                                    "Expresse velocidades relativas: ᴖz/ᴗt = ᴖx/ᴗt - ᴖy_g/ᴗt.",
                                    "Expresse acelerações relativas: ᴖ²z/ᴗt² = ᴖ²x/ᴗt² - ᴖ²y_g/ᴗt².",
                                    "Substitua nas expressões absolutas: x(t) = z(t) + y_g(t).",
                                    "Verifique dimensionalmente que z(t) tem unidades de comprimento."
                                  ],
                                  "verification": "Teste com valores numéricos simples: se y_g(t)=0, z(t)=x(t); se x(t)=y_g(t), z(t)=0.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de papel para derivações, software de álgebra simbólica.",
                                  "tips": "Use notação vetorial se o movimento for 2D, mas foque em 1D para SDOF.",
                                  "learningObjective": "Simplificar a representação cinemática usando coordenadas relativas.",
                                  "commonMistakes": "Invertar o sinal em z(t) = y_g(t) - x(t); esquecer de derivar corretamente as acelerações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a representação cinemática à equação de movimento",
                                  "subSteps": [
                                    "Escreva a equação absoluta: m ᴖ²x/ᴗt² + c ᴖx/ᴗt + k x = 0 (sem força externa).",
                                    "Substitua acelerações: m (ᴖ²z/ᴗt² + ᴖ²y_g/ᴗt²) + c (ᴖz/ᴗt + ᴖy_g/ᴗt) + k z = 0.",
                                    "Simplifique assumindo velocidades relativas puras para amortecimento.",
                                    "Identifique o termo de excitação: -m ᴖ²y_g/ᴗt² como força equivalente.",
                                    "Discuta como isso transmite vibrações da base para a massa."
                                  ],
                                  "verification": "A equação final deve ser m ᴖ²z/ᴗt² + c ᴖz/ᴗt + k z = -m ᴖ²y_g/ᴗt².",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Livro-texto de dinâmica (ex: Thomson), MATLAB para simulação opcional.",
                                  "tips": "Mantenha o foco na cinemática; a dinâmica vem como consequência.",
                                  "learningObjective": "Demonstrar como a coordenada relativa simplifica a análise de vibrações transmitidas.",
                                  "commonMistakes": "Não isolar corretamente o termo de excitação; confundir deslocamentos com acelerações."
                                }
                              ],
                              "practicalExample": "Em uma asa de aeronave, a base (fuselagem) vibra devido a turbulência y_g(t) = A sin(ωt). A massa (dica de controle) tem deslocamento x(t), e z(t) = x(t) - y_g(t) permite modelar a transmissão de vibrações para evitar fadiga estrutural.",
                              "finalVerifications": [
                                "Diagrama esquemático correto com x(t), y_g(t) e z(t) rotulados.",
                                "Derivações corretas de velocidades e acelerações relativas.",
                                "Equação de movimento em coordenadas relativas com termo de excitação -m ÿ_g(t).",
                                "Exemplo numérico simples resolvido sem erros.",
                                "Explicação clara de como z(t) simplifica a análise.",
                                "Identificação de pelo menos duas aplicações aeroespaciais."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições de coordenadas absolutas e relativas (30%).",
                                "Corretude das derivações cinemáticas (25%).",
                                "Clareza do diagrama e representações gráficas (20%).",
                                "Aplicação à equação de movimento (15%).",
                                "Compreensão da simplificação para vibrações transmitidas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo diferencial (derivadas de segunda ordem).",
                                "Física: Cinemática e dinâmica de partículas.",
                                "Engenharia Mecânica: Análise de vibrações e isolamento.",
                                "Programação: Simulação em MATLAB/Python para validação."
                              ],
                              "realWorldApplication": "Modelagem de vibrações em edifícios durante terremotos, isolamento de motores em aviões ou análise de fadiga em asas aeroespaciais sob turbulência, permitindo projetar amortecedores para reduzir transmissão de vibrações da base para estruturas críticas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.3",
                            "name": "Formular a equação em termos de resposta relativa",
                            "description": "Reescrever a equação de movimento na forma mż + cż + kz = -mŸ_g(t), destacando que a excitação atua como uma força inercial equivalente à aceleração de base.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a equação de movimento absoluta para SDOF com excitação de base",
                                  "subSteps": [
                                    "Lembre-se da equação absoluta de movimento para um sistema SDOF: m ü + c ú + k u = 0 (sem excitação externa inicialmente).",
                                    "Identifique a excitação de base: a base se move com deslocamento y_g(t), então a posição absoluta u = z + y_g, onde z é a resposta relativa.",
                                    "Escreva a equação considerando a aceleração absoluta ü = z̈ + ÿ_g.",
                                    "Substitua na equação de equilíbrio dinâmico: m(z̈ + ÿ_g) + c(ż + ý_g) + k z = 0.",
                                    "Expanda para obter m z̈ + c ż + k z = -m ÿ_g - c ý_g."
                                  ],
                                  "verification": "Confirme que a equação expandida inclui todos os termos de aceleração, velocidade e deslocamento absolutos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Folha de papel, calculadora, notas de aula sobre SDOF.",
                                  "tips": "Desenhe um diagrama esquemático do sistema massa-mola-amortecedor com base móvel para visualizar.",
                                  "learningObjective": "Compreender a origem da equação absoluta antes da transformação relativa.",
                                  "commonMistakes": "Esquecer de incluir o termo de amortecimento na velocidade da base (ý_g)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e introduzir a resposta relativa",
                                  "subSteps": [
                                    "Defina z(t) = u(t) - y_g(t) como a resposta relativa (deslocamento da massa em relação à base).",
                                    "Derive as derivadas: ż = ú - ý_g e z̈ = ü - ÿ_g.",
                                    "Substitua essas definições na equação absoluta expandida.",
                                    "Observe que os termos de amortecimento c ý_g e deslocamento k y_g não aparecem na forma final simplificada.",
                                    "Simplifique assumindo que o amortecedor e a mola estão conectados à base, ignorando termos diretos de y_g."
                                  ],
                                  "verification": "Verifique se z é corretamente definido como diferença entre absoluto e base.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Diagrama do sistema SDOF impresso ou desenhado.",
                                  "tips": "Use setas no diagrama para indicar direções de deslocamentos absolutos e relativos.",
                                  "learningObjective": "Estabelecer a definição precisa de resposta relativa e suas derivadas.",
                                  "commonMistakes": "Confundir z com deslocamento absoluto ou inverter a subtração (u - y_g vs y_g - u)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a equação em termos de resposta relativa",
                                  "subSteps": [
                                    "Partindo de m(z̈ + ÿ_g) + c ż + k z = 0 (assumindo amortecedor só na relativa).",
                                    "Reorganize: m z̈ + c ż + k z = - m ÿ_g.",
                                    "Identifique -m ÿ_g(t) como a força inercial equivalente.",
                                    "Escreva a forma final: m z̈ + c ż + k z = -m ÿ_g(t).",
                                    "Confirme que não há termos de velocidade ou deslocamento da base na equação relativa final."
                                  ],
                                  "verification": "A equação resultante deve ser exatamente mż + cż + kz = -mŸ_g(t).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Lápis, borracha, software simbólico como SymPy (opcional).",
                                  "tips": "Trabalhe algebricamente passo a passo, isolando termos relativos à esquerda.",
                                  "learningObjective": "Derivar matematicamente a equação relativa a partir da absoluta.",
                                  "commonMistakes": "Incluir erroneamente termos c ý_g ou k y_g na equação final."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar fisicamente a força inercial equivalente",
                                  "subSteps": [
                                    "Explique que -m ÿ_g(t) representa a força inercial devida à aceleração da base, como se a massa experimentasse uma aceleração oposta.",
                                    "Compare com elevador acelerando: passageiro sente força fictícia.",
                                    "Discuta implicações em aeroespacial: aceleração da fuselagem atua como excitação para componentes.",
                                    "Verifique unidades: lado esquerdo (força), -m ÿ_g tem unidades de massa * aceleração = força.",
                                    "Aplique a um exemplo simples: calcule para ÿ_g constante."
                                  ],
                                  "verification": "Descreva verbalmente ou por escrito o significado físico de cada termo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Exemplo numérico simples, vídeo de demonstração de base excitada.",
                                  "tips": "Pense em referência não-inercial: forças fictícias surgem.",
                                  "learningObjective": "Interpretar a equação como força inercial equivalente à aceleração de base.",
                                  "commonMistakes": "Interpretar Ÿ_g como força direta em vez de aceleração gerando inercial."
                                }
                              ],
                              "practicalExample": "Considere um suporte de motor em uma aeronave onde a fuselagem acelera verticalmente com Ÿ_g(t) = 5 sin(ωt) m/s². Formule a equação para o deslocamento relativo z do motor: m z̈ + c ż + k z = -m * 5 sin(ωt), permitindo análise de vibrações isoladas.",
                              "finalVerifications": [
                                "A equação está na forma exata mż + cż + kz = -mŸ_g(t)?",
                                "As derivadas de z estão corretamente relacionadas às absolutas?",
                                "O termo -mŸ_g(t) é identificado como força inercial?",
                                "Unidades de ambos os lados da equação são consistentes (força)?",
                                "Diagrama esquemático mostra claramente u, y_g e z?",
                                "Exemplo numérico simples resolve corretamente para z?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação algébrica (sem erros de sinal ou termos extras).",
                                "Correta definição e uso de resposta relativa z(t).",
                                "Interpretação física clara da força inercial equivalente.",
                                "Capacidade de aplicar a um exemplo aeroespacial concreto.",
                                "Verificação de unidades e consistência dimensional.",
                                "Explicação verbal fluida dos passos e implicações."
                              ],
                              "crossCurricularConnections": [
                                "Física Geral: Referenciais não-inerciais e forças fictícias.",
                                "Controle de Sistemas: Modelagem para design de amortecedores ativos.",
                                "Programação/Engenharia Computacional: Implementação em simulações MATLAB/Simulink.",
                                "Matemática: Equações diferenciais lineares com forçantes.",
                                "Engenharia Mecânica: Análise de vibrações em veículos terrestres (ex: terremotos)."
                              ],
                              "realWorldApplication": "Em aeronaves, essa formulação é essencial para modelar vibrações em suportes de motores ou painéis devido a acelerações da fuselagem durante manobras, permitindo o design de isoladores que previnem fadiga estrutural e ressonância em flutter aeroelástico."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.2",
                        "name": "Cálculo da Resposta Absoluta e Relativa",
                        "description": "Determinação das respostas dinâmica absoluta e relativa de sistemas SDOF sob excitações harmônicas de base, incluindo soluções no domínio do tempo e frequência.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.2.1",
                            "name": "Calcular a resposta absoluta para excitação harmônica",
                            "description": "Para Ÿ_g(t) = Y_g ω² sen(ωt), obter a solução particular da resposta absoluta x(t) em termos de amplitude, fase e razão de frequência ω/ω_n, considerando amortecimento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar parâmetros do sistema e da excitação",
                                  "subSteps": [
                                    "Determine a frequência natural ω_n = sqrt(k/m) do sistema SDOF.",
                                    "Identifique o coeficiente de amortecimento ζ = c / (2 sqrt(k m)).",
                                    "Extraia da excitação Ÿ_g(t) = Y_g ω² sen(ωt) os valores de Y_g (amplitude da aceleração), ω (frequência de excitação) e a forma sen(ωt).",
                                    "Calcule a razão de frequência r = ω / ω_n.",
                                    "Confirme unidades consistentes (ex: rad/s para frequências)."
                                  ],
                                  "verification": "Lista de parâmetros anotada com valores e r calculado corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Equação da excitação dada, propriedades do sistema (m, k, c), calculadora.",
                                  "tips": "Sempre normalize frequências em rad/s para evitar erros de conversão de Hz.",
                                  "learningObjective": "Compreender e extrair corretamente os parâmetros fundamentais para análise dinâmica.",
                                  "commonMistakes": "Confundir ω com f (Hz), esquecer de calcular r explicitamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever a equação de movimento para resposta absoluta",
                                  "subSteps": [
                                    "Escreva a EDO: m ÿ + c ẋ + k x = -m Ÿ_g(t).",
                                    "Substitua Ÿ_g(t): m ÿ + c ẋ + k x = -m Y_g ω² sen(ωt).",
                                    "Divida por k para normalizar: ÿ + 2ζω_n ẋ + ω_n² x = -Y_g ω² sen(ωt).",
                                    "Identifique a força equivalente como uma excitação harmônica com amplitude Y_g ω²."
                                  ],
                                  "verification": "EDO escrita corretamente na forma padrão, com sinal negativo na força inercial.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Folha de papel ou software de equações (ex: LaTeX, Mathcad), referência de dinâmica SDOF.",
                                  "tips": "Lembre-se: resposta absoluta x(t) inclui o termo inercial da base.",
                                  "learningObjective": "Formular precisamente a equação governante para excitação de base.",
                                  "commonMistakes": "Omitir o sinal negativo em -m Ÿ_g ou confundir com resposta relativa."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar a amplitude da resposta X",
                                  "subSteps": [
                                    "Assuma solução particular x_p(t) = X sen(ωt - φ).",
                                    "Use a fórmula padrão para amplitude: X = Y_g * (r²) / sqrt( (1 - r²)² + (2 ζ r)² ), onde r = ω/ω_n.",
                                    "Calcule o denominador passo a passo: primeiro (1 - r²), depois (2 ζ r), elevações ao quadrado e soma.",
                                    "Verifique limite estático: quando r→0, X → Y_g.",
                                    "Compute numericamente se valores dados."
                                  ],
                                  "verification": "Fórmula de X derivada ou aplicada corretamente, com valor numérico se aplicável.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora científica, tabela de fórmulas de vibração.",
                                  "tips": "Memorize o fator r² no numerador, característico da excitação acelerométrica.",
                                  "learningObjective": "Aplicar a fórmula de amplificação dinâmica para excitação de base.",
                                  "commonMistakes": "Usar fórmula de força direta (sem r²) ou inverter numerador/denominador."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular a fase φ",
                                  "subSteps": [
                                    "Use tan φ = (2 ζ r) / |1 - r²| , com φ no quadrante correto.",
                                    "Determine o sinal: φ = atan2(2 ζ r, 1 - r²) para convenção sen(ωt - φ).",
                                    "Calcule componentes: imaginário 2 ζ r, real 1 - r².",
                                    "Verifique comportamentos: φ→0 para r<<1, φ→180° para r>>1.",
                                    "Expresse φ em graus ou radianos conforme contexto."
                                  ],
                                  "verification": "Valor de φ calculado com atan2 correto e consistente com gráfico de fase.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora com função atan2, gráfico de referência de fase.",
                                  "tips": "Use atan2 para capturar o quadrante; evite atan simples.",
                                  "learningObjective": "Determinar o defasamento considerando amortecimento e r.",
                                  "commonMistakes": "Usar tan φ sem considerar sinal de (1 - r²), levando a fase errada."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Montar e verificar a solução particular x(t)",
                                  "subSteps": [
                                    "Escreva x(t) = X sen(ωt - φ), com X e φ em termos de Y_g, r, ζ.",
                                    "Substitua de volta na EDO para validar (opcional, mas recomendado).",
                                    "Discuta solução completa: x(t) = x_h(t) + x_p(t), mas foque em particular.",
                                    "Anote limitações: solução particular para regime permanente.",
                                    "Compare com resposta relativa se contexto exigir."
                                  ],
                                  "verification": "Expressão final x(t) com amplitude, fase e argumentos corretos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Software de simulação (ex: MATLAB) para plot opcional.",
                                  "tips": "Sempre especifique 'solução particular' para regime steady-state.",
                                  "learningObjective": "Sintetizar amplitude e fase na forma final da resposta.",
                                  "commonMistakes": "Esquecer de especificar 'particular' ou incluir transientes."
                                }
                              ],
                              "practicalExample": "Para um sistema com m=10 kg, k=1000 N/m, c=20 Ns/m, Ÿ_g(t)=0.5 * (10 rad/s)² sen(10t) m/s². Calcule: ω_n≈10 rad/s, ζ=0.1, r=1. X≈0.5*(1) / sqrt((0)^2 + (0.2)^2)=0.5/0.2=2.5 m, φ=atan2(0.2,0)=90°. x(t)=2.5 sen(10t - 90°).",
                              "finalVerifications": [
                                "Amplitude X possui fator r² no numerador e denominador correto.",
                                "Fase φ usa atan2 com 2ζr e (1-r²) nos argumentos corretos.",
                                "Solução x(t) está na forma X sen(ωt - φ) com unidades consistentes.",
                                "Limites especiais (r=0, r>>1) verificados qualitativamente.",
                                "Equação de movimento derivada corretamente da excitação de base.",
                                "Parâmetros r e ζ identificados sem erros numéricos."
                              ],
                              "assessmentCriteria": [
                                "Precisão da fórmula de amplitude (pontos totais por termos corretos).",
                                "Correção no cálculo da fase, incluindo quadrante.",
                                "Clareza na derivação passo a passo da EDO.",
                                "Validação com exemplo numérico ou gráfico.",
                                "Uso apropriado de convenções (sen vs cos, rad vs graus).",
                                "Identificação correta de solução particular vs completa."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Solução de EDOs lineares não-homogêneas com coeficientes constantes.",
                                "Física: Análise de vibrações forçadas e ressonância.",
                                "Engenharia de Controle: Diagramas de Bode para magnitude e fase.",
                                "Programação: Simulação numérica em Python/MATLAB para validar resposta.",
                                "Aeroelasticidade: Aplicação em flutter e resposta a rajadas harmônicas."
                              ],
                              "realWorldApplication": "Em aeronaves, calcular a resposta absoluta de painéis de fuselagem a vibrações harmônicas da base (turbulência ou motores), previnindo fadiga estrutural e otimizando design para evitar ressonância perto de ω_n."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.2.2",
                            "name": "Determinar a resposta relativa z(t)",
                            "description": "Resolver mż + cż + kz = -m Y_g ω² sen(ωt) para obter a amplitude relativa |Z|/Y_g e comparar com a resposta estática, enfatizando regiões de isolamento (ω > √2 ω_n).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a equação de movimento absoluta para excitação de base",
                                  "subSteps": [
                                    "Identifique os componentes do sistema SDOF: massa m, amortecimento c, rigidez k e deslocamento absoluto y(t).",
                                    "Escreva a equação governante: m ÿ + c ý + k y = -m Ÿ_g, onde Ÿ_g é a aceleração da base.",
                                    "Expresse Ÿ_g como aceleração harmônica: Ÿ_g = Y_g ω² sin(ωt), resultando em m ÿ + c ý + k y = -m Y_g ω² sin(ωt).",
                                    "Defina os parâmetros não-dimensionais: razão de amortecimento ζ = c/(2√(km)), frequência natural ω_n = √(k/m).",
                                    "Verifique a consistência das unidades e notação (sen para sin)."
                                  ],
                                  "verification": "Escreva corretamente a equação absoluta e defina todos os parâmetros com suas expressões.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de dinâmica estrutural (ex: Chopra), caderno de anotações, calculadora.",
                                  "tips": "Desenhe um diagrama esquemático do sistema massa-mola-amortecedor com base móvel para visualização.",
                                  "learningObjective": "Entender a formulação do problema em coordenadas absolutas.",
                                  "commonMistakes": "Confundir sin(ωt) com cos(ωt); esquecer o sinal negativo na força de inércia da base."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir coordenada relativa e derivar equação para z(t)",
                                  "subSteps": [
                                    "Defina o deslocamento relativo z(t) = y(t) - Y_g(t), com Y_g(t) = Y_g sin(ωt).",
                                    "Calcule as derivadas: ż = ý - Ÿ_g, z̈ = ÿ - Ÿ̈_g.",
                                    "Substitua na equação absoluta: m (z̈ + Ÿ̈_g) + c (ż + Ÿ_g) + k (z + Y_g) = -m Ÿ̈_g.",
                                    "Simplifique: m z̈ + c ż + k z = -m Ÿ̈_g - c Ÿ_g - k Y_g.",
                                    "Para harmônica, Ÿ̈_g = -Y_g ω² sin(ωt), Ÿ_g = Y_g ω cos(ωt), mas foque no regime permanente onde o termo c Ÿ_g é desprezível em muitos casos.",
                                    "Obtenha a equação final: m z̈ + c ż + k z = 0 + termos forçantes efetivos, mas na verdade m z̈ + c ż + k z = -k Y_g sin(ωt) - c Y_g ω cos(ωt) ≈ -k Y_g sin(ωt) para ζ pequeno."
                                  ],
                                  "verification": "Derive e escreva a equação de movimento em termos de z(t) corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel milimetrado, lápis, referência de texto sobre vibrações (ex: Thomson).",
                                  "tips": "Use a convenção sin(ωt) consistentemente; pratique a substituição diferencial passo a passo.",
                                  "learningObjective": "Dominar a transformação para coordenadas relativas em excitações de base.",
                                  "commonMistakes": "Erros na diferenciação de Y_g(t); ignorar termo de amortecimento inicialmente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver a equação diferencial para z(t) em regime permanente",
                                  "subSteps": [
                                    "Assuma solução particular z_p(t) = Z sin(ωt + φ), onde Z é amplitude, φ fase.",
                                    "Substitua na equação m z̈ + c ż + k z = -m Y_g ω² sin(ωt).",
                                    "Derive: [-m ω² Z sin(ωt + φ) - c ω Z cos(ωt + φ) + k Z sin(ωt + φ)] = -m Y_g ω² sin(ωt).",
                                    "Balanceie coeficientes de sin e cos para encontrar |Z| e φ.",
                                    "Obtenha amplitude |Z| = (k Y_g) / √[(k - m ω²)² + (c ω)²] ou em termos adimensionais.",
                                    "Simplifique para razão relativa |Z|/Y_g = √[1 + (2 ζ r)²] / √[(1 - r²)² + (2 ζ r)²], onde r = ω/ω_n."
                                  ],
                                  "verification": "Escreva a expressão exata de z(t) e verifique balanceamento de harmônicos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora científica, software como MATLAB para verificação numérica opcional.",
                                  "tips": "Use método de equação característica para solução homogênea primeiro, depois particular.",
                                  "learningObjective": "Aplicar método de solução estacionária para EDOs lineares forçadas.",
                                  "commonMistakes": "Confundir amplitude absoluta vs relativa; erro no denominador da razão de transmissão."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular amplitude relativa |Z|/Y_g e comparar com resposta estática",
                                  "subSteps": [
                                    "Expresse |Z|/Y_g = |k / (k - m ω² + i c ω)| = √[1 + (2ζr)^2] / √[(1-r^2)^2 + (2ζr)^2].",
                                    "Compare com resposta estática: para ω=0, |Z|/Y_g → 1.",
                                    "Plote ou analise o gráfico de |Z|/Y_g vs r para ζ fixo (ex: ζ=0.05).",
                                    "Identifique regiões: amplificação perto de r=1, isolamento para r > √2.",
                                    "Discuta critério de isolamento: |Z|/Y_g < 1 quando ω > √2 ω_n aproximadamente para ζ baixo.",
                                    "Calcule numericamente para r=2, verifique |Z|/Y_g <<1."
                                  ],
                                  "verification": "Gere gráfico ou tabela mostrando |Z|/Y_g <1 para ω > √2 ω_n.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Excel ou Python/MATLAB para plotar curvas de resposta.",
                                  "tips": "Normalize tudo por ω_n; foque em ζ=5% típico para estruturas.",
                                  "learningObjective": "Interpretar razões de amplitude e identificar zonas de isolamento.",
                                  "commonMistakes": "Confundir |Y|/Y_g com |Z|/Y_g; ignorar fase na amplitude."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e verificar regiões de isolamento de vibrações",
                                  "subSteps": [
                                    "Derive condição analítica para |Z|/Y_g <1: aproximadamente r > √2 para ζ<<1.",
                                    "Compare com resposta absoluta |Y|/Y_g que amplifica perto da ressonância.",
                                    "Discuta vantagens da relativa em isolamento de base (ex: edifícios, aviões).",
                                    "Realize sensibilidade: varie ζ e observe mudança no ponto √2 ω_n.",
                                    "Resuma: isolamento efetivo em altas frequências reduz transmissão de vibrações.",
                                    "Teste com valores: m=1, k=1, c=0.1, ω_n=1, ω=2, Y_g=0.01."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que ω > √2 ω_n proporciona isolamento.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Gráficos gerados previamente, relatório de análise.",
                                  "tips": "Pense em termos de razão de frequência r para generalidade.",
                                  "learningObjective": "Aplicar conceitos a design de isoladores.",
                                  "commonMistakes": "Achar isolamento em baixas frequências; confundir com controle ativo."
                                }
                              ],
                              "practicalExample": "Considere um montante de aeronave com m=100 kg, k=10^5 N/m (ω_n≈31.6 rad/s), ζ=0.02, base vibrando com Y_g=0.001 m a ω=100 rad/s (r≈3.16 >√2). Calcule |Z|/Y_g ≈0.3, mostrando redução de 70% na vibração relativa vs estática.",
                              "finalVerifications": [
                                "Derivação correta da equação m z̈ + c ż + k z = -m Y_g ω² sin(ωt).",
                                "Expressão precisa de |Z|/Y_g em função de r e ζ.",
                                "Gráfico de |Z|/Y_g vs r com identificação de região ω > √2 ω_n.",
                                "Comparação quantitativa com caso estático (|Z|/Y_g=1).",
                                "Explicação física do isolamento em altas frequências.",
                                "Cálculo numérico para exemplo específico com valores corretos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação da equação relativa (20%).",
                                "Correção na fórmula de amplitude |Z|/Y_g (25%).",
                                "Análise qualitativa e quantitativa das regiões de isolamento (20%).",
                                "Uso correto de parâmetros adimensionais r e ζ (15%).",
                                "Clareza no gráfico e comparações (10%).",
                                "Exemplo prático resolvido sem erros (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Solução de EDOs lineares com coeficientes constantes.",
                                "Física: Princípios de dinâmica newtoniana e harmônicos forçados.",
                                "Engenharia de Controle: Projeto de isoladores passivos.",
                                "Computação: Simulação numérica em MATLAB/Python para validação."
                              ],
                              "realWorldApplication": "Projeto de isoladores de vibração em fuselagens de aeronaves para reduzir fadiga estrutural causada por turbulências (frequências altas), ou em prédios contra terremotos, garantindo |z| << Y_g em ω >> ω_n."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.2.3",
                            "name": "Analisar transmissibilidade de vibrações",
                            "description": "Calcular o fator de transmissibilidade TR = |X|/Y_g para resposta absoluta e TR_rel = |Z|/Y_g para relativa, plotar curvas TR vs. ω/ω_n para diferentes ζ, e interpretar para design de isoladores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Transmissibilidade de Vibrações",
                                  "subSteps": [
                                    "Revise as equações de movimento para sistemas SDOF sob excitação de base: mẍ + c(ẋ - ẏ_g) + k(x - y_g) = 0.",
                                    "Defina transmissibilidade absoluta TR = |X|/|Y_g| e relativa TR_rel = |Z|/|Y_g|, onde Z = X - Y_g.",
                                    "Explique o papel do fator de amortecimento ζ e da razão de frequência ω/ω_n nas curvas de TR.",
                                    "Identifique regimes: isolamento (ω/ω_n > √2), ressonância (ω/ω_n ≈ 1) e aceleração rígida (ω/ω_n << 1).",
                                    "Estude soluções em domínio de frequência usando números complexos."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre TR absoluta e relativa, citando equações chave.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Dinâmica de Estruturas Aeroespaciais (ex: ST-57)",
                                    "Notas de aula sobre SDOF",
                                    "Calculadora simbólica (Mathematica ou MATLAB)"
                                  ],
                                  "tips": "Use diagramas de corpo livre para visualizar deslocamentos absolutos e relativos.",
                                  "learningObjective": "Dominar definições e origens matemáticas de TR e TR_rel em excitações de base.",
                                  "commonMistakes": [
                                    "Confundir deslocamento absoluto X com relativo Z",
                                    "Ignorar o sinal de fase nas magnitudes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar e Calcular Fórmulas de Transmissibilidade",
                                  "subSteps": [
                                    "Derive TR = √[(1 + (2ζ r)^2) / ((1 - r^2)^2 + (2ζ r)^2)] onde r = ω/ω_n para resposta absoluta.",
                                    "Derive TR_rel = √[(r^4) / ((1 - r^2)^2 + (2ζ r)^2)] para resposta relativa.",
                                    "Calcule valores numéricos para ζ = 0.1, 0.5, 1.0 em r = 0.5, 1.0, 2.0, 5.0.",
                                    "Compare TR e TR_rel em uma tabela para diferentes r e ζ.",
                                    "Valide cálculos com software ou planilha."
                                  ],
                                  "verification": "Produza uma tabela com 9 cálculos corretos de TR e TR_rel para 3 valores de ζ e 3 de r.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Planilha Excel ou Python (NumPy)",
                                    "Fórmulas anotadas",
                                    "Gráficos de referência de livros-textos"
                                  ],
                                  "tips": "Lembre-se: para TR_rel, o numerador é r^4, essencial para isolamento em altas frequências.",
                                  "learningObjective": "Calcular precisamente TR e TR_rel para cenários variados.",
                                  "commonMistakes": [
                                    "Erro no numerador de TR_rel (usar 1 em vez de r^4)",
                                    "Esquecer de usar magnitudes | |"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Plotar e Analisar Curvas de Transmissibilidade",
                                  "subSteps": [
                                    "Gere curvas TR vs. r para ζ = 0.05, 0.2, 0.5, 1.0 usando software de plotagem.",
                                    "Sobreponha curvas de TR absoluta e relativa no mesmo gráfico.",
                                    "Identifique picos de ressonância, cruzamentos em r=√2 e assíntotas em altas frequências.",
                                    "Anote slopes assintóticos: TR ~ 1/r^2 para absoluta em alto r; TR_rel ~ 1/r^2.",
                                    "Exporte gráficos com legendas claras."
                                  ],
                                  "verification": "Crie e interprete um gráfico com 4 curvas de TR vs. r, destacando 3 características chave.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB, Python (Matplotlib) ou GNU Octave",
                                    "Dados tabulares do Step 2"
                                  ],
                                  "tips": "Use log-log scale para visualizar assíntotas claramente em baixas e altas frequências.",
                                  "learningObjective": "Visualizar e descrever comportamento de TR para diferentes níveis de amortecimento.",
                                  "commonMistakes": [
                                    "Escala linear em vez de log para r, obscurecendo isolamento",
                                    "Legendas confusas entre TR e TR_rel"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Curvas para Design de Isoladores de Vibrações",
                                  "subSteps": [
                                    "Para design aeroespacial, selecione ζ para minimizar TR em faixas de ω/ω_n relevantes (ex: motores).",
                                    "Analise: para isolamento, opere em r > √2 com ζ baixo para TR <1.",
                                    "Compare designs: ζ alto reduz pico mas piora isolamento em alto r.",
                                    "Proponha isolador para vibração de base em fuselagem: calcule r necessário para TR=0.1.",
                                    "Discuta trade-offs: custo, peso vs. performance."
                                  ],
                                  "verification": "Escreva um relatório curto recomendando ζ e r para um isolador com TR<0.2 em r>3.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Gráficos do Step 3",
                                    "Casos de estudo aeroespaciais",
                                    "Papel para esboços"
                                  ],
                                  "tips": "Considere excitações reais: turbulência causa ω altas, então priorize TR_rel.",
                                  "learningObjective": "Aplicar análise TR ao design prático de isoladores em estruturas aeroespaciais.",
                                  "commonMistakes": [
                                    "Recomendar ζ=0 para todos casos (pico infinito em ressonância)",
                                    "Ignorar resposta relativa para componentes internos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma asa de aeronave sujeita a vibrações de base do fluxo turbulento (Y_g), calcule TR para um suporte de motor com ω_n=10 Hz, ζ=0.1, em ω=50 Hz (r=5). Plote curvas e confirme TR_abs <0.1 para isolamento efetivo, evitando fadiga estrutural.",
                              "finalVerifications": [
                                "Calcula corretamente TR e TR_rel para 5 pares (r, ζ) dados.",
                                "Gera e descreve curvas precisas com 4 valores de ζ.",
                                "Identifica corretamente regimes de isolamento e ressonância.",
                                "Propõe design viável de isolador com justificativa baseada em TR.",
                                "Explica diferenças entre TR absoluta e relativa em contexto aeroespacial.",
                                "Valida resultados com software sem erros numéricos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações e cálculos (30%)",
                                "Qualidade e correção dos gráficos de TR vs. r (25%)",
                                "Profundidade na interpretação para design (20%)",
                                "Clareza na documentação e verificações (15%)",
                                "Integração de conceitos SDOF e excitação de base (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e funções de transferência em domínio de frequência.",
                                "Física: Ondas e vibrações, amortecimento viscoso.",
                                "Engenharia Mecânica: Projeto de sistemas de isolamento ativo/passivo.",
                                "Computação: Programação numérica para simulações (MATLAB/Python).",
                                "Materiais: Seleção de elastômeros para ζ desejado."
                              ],
                              "realWorldApplication": "No design de aeronaves, analisa transmissibilidade para isoladores de motores e eletrônicos, minimizando vibrações transmitidas da fuselagem para componentes sensíveis, prevenindo falhas por fadiga e melhorando conforto de voo."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.6",
                    "name": "Transmissão e Isolamento de Vibrações",
                    "description": "Conceitos de transmissibilidade de força e movimento, e técnicas de isolamento vibracional em estruturas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.6.1",
                        "name": "Transmissibilidade de Força",
                        "description": "Conceito fundamental que descreve a relação entre a força excitante aplicada a um sistema SDOF e a força transmitida para a base de suporte, considerando amortecimento e razão de frequência.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.6.1.1",
                            "name": "Derivação da expressão de transmissibilidade de força",
                            "description": "Derivar matematicamente a fórmula de transmissibilidade de força TR_F = |F_T / F_0| = sqrt(1 + (2ζr)^2) / sqrt((1 - r^2)^2 + (2ζr)^2), onde r é a razão de frequência e ζ o fator de amortecimento, para um sistema massa-mola-amortecedor sob excitação harmônica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o modelo do sistema massa-mola-amortecedor (SDOF) com excitação harmônica",
                                  "subSteps": [
                                    "Desenhe o diagrama esquemático do sistema SDOF: massa m conectada a uma mola k e amortecedor c, com força excitadora F_0 sin(ωt) aplicada na massa.",
                                    "Identifique as forças atuantes: força inercial -mẍ, força de mola -kx, força de amortecimento -cẋ, e força excitadora F_0 sin(ωt).",
                                    "Defina os parâmetros não-dimensionais: razão de frequência r = ω/ω_n onde ω_n = sqrt(k/m), e fator de amortecimento ζ = c/(2 sqrt(k m)).",
                                    "Explique o conceito de força transmitida F_T como a soma da força de mola e amortecedor: F_T = kx + cẋ.",
                                    "Discuta o regime permanente, ignorando transientes."
                                  ],
                                  "verification": "Desenhe corretamente o diagrama do sistema e liste todos os parâmetros com suas definições.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis para diagrama",
                                    "Referência: Livro de Dinâmica de Rao ou Chopra"
                                  ],
                                  "tips": "Use setas para indicar direções das forças e rotule todos os componentes claramente.",
                                  "learningObjective": "Compreender a configuração física e parâmetros do sistema SDOF sob excitação harmônica.",
                                  "commonMistakes": [
                                    "Confundir força excitadora com força transmitida",
                                    "Esquecer de definir r e ζ corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever e analisar a equação de movimento",
                                  "subSteps": [
                                    "Aplique a 2ª Lei de Newton: mẍ + cẋ + kx = F_0 sin(ωt).",
                                    "Divida pela massa para forma padrão: ẍ + 2ζω_n ẋ + ω_n² x = (F_0/m) sin(ωt).",
                                    "Introduza a razão de frequência r = ω/ω_n e reescreva em termos não-dimensionais.",
                                    "Verifique as unidades para garantir consistência.",
                                    "Discuta o significado físico de cada termo."
                                  ],
                                  "verification": "Escreva a equação corretamente em ambas as formas e identifique todos os termos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou software como MATLAB/SymPy",
                                    "Folha de equações"
                                  ],
                                  "tips": "Sempre normalize pela massa para facilitar comparações.",
                                  "learningObjective": "Dominar a formulação da equação governante do sistema.",
                                  "commonMistakes": [
                                    "Erro no sinal das forças restauradoras",
                                    "Confundir ω com ω_n ao definir r"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Obter a solução em regime permanente",
                                  "subSteps": [
                                    "Assuma solução harmônica x(t) = X sin(ωt - φ), onde X é amplitude de deslocamento.",
                                    "Substitua na equação de movimento e separe termos sin e cos usando identidades trigonométricas.",
                                    "Equacione coeficientes para obter X = F_0 / (k sqrt((1 - r²)² + (2ζr)²)).",
                                    "Derive também a fase φ = atan(2ζr / (1 - r²)).",
                                    "Verifique limites: r<<1 (X ≈ F_0/k) e r>>1 (X ≈ 0)."
                                  ],
                                  "verification": "Calcule X corretamente para um caso numérico simples (ex: ζ=0.1, r=1).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de álgebra simbólica",
                                    "Tabela de identidades trigonométricas"
                                  ],
                                  "tips": "Use método de fasores ou complexo para simplificar: F_0 e^{iωt}.",
                                  "learningObjective": "Resolver analiticamente para amplitudes em estado estacionário.",
                                  "commonMistakes": [
                                    "Erro na substituição de derivadas: ẋ = ω X cos(ωt - φ)",
                                    "Esquecer o módulo no denominador"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Expressar a força transmitida F_T e sua amplitude",
                                  "subSteps": [
                                    "Defina F_T(t) = k x(t) + c ẋ(t).",
                                    "Substitua x(t) e ẋ(t) = ω X cos(ωt - φ).",
                                    "Simplifique: F_T(t) = k X sin(ωt - φ) + c ω X cos(ωt - φ).",
                                    "Encontre amplitude F_T: |F_T| = X sqrt(k² + (c ω)²) = X k sqrt(1 + (2ζr)²).",
                                    "Verifique dimensionalmente."
                                  ],
                                  "verification": "Derive a expressão de |F_T| em termos de X, k, ζ, r.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel para expansões trigonométricas"
                                  ],
                                  "tips": "Fatore k X para clareza.",
                                  "learningObjective": "Calcular a força transmitida dinamicamente.",
                                  "commonMistakes": [
                                    "Confundir ẋ com -ω X sin",
                                    "Erro no fator c ω = 2 ζ sqrt(k m) ω"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Derivar a transmissibilidade de força TR_F",
                                  "subSteps": [
                                    "Defina TR_F = |F_T / F_0|.",
                                    "Substitua |F_T| e X: TR_F = [sqrt(1 + (2ζr)²) / sqrt((1 - r²)² + (2ζr)²)].",
                                    "Simplifique algebricamente e verifique identidade.",
                                    "Plote ou discuta curvas TR_F vs r para ζ variados.",
                                    "Compare com transmissibilidade de deslocamento."
                                  ],
                                  "verification": "Obtenha a fórmula final exata e teste para ζ=0 (TR_F = |1/(1-r²)|).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráfico de TR_F pronto para verificação",
                                    "Software de plotagem como Python/MATLAB"
                                  ],
                                  "tips": "Lembre que F_0 é amplitude, não pico.",
                                  "learningObjective": "Completar a derivação da fórmula de transmissibilidade.",
                                  "commonMistakes": [
                                    "Esquecer o módulo absoluto",
                                    "Erro na simplificação da fração"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma hélice de aeronave, derive TR_F para r=1.5 e ζ=0.05, calculando quanto da vibração do motor (F_0=1000N) é transmitida à fuselagem, usando m=10kg, k=10000N/m, c=50Ns/m.",
                              "finalVerifications": [
                                "Recita corretamente a fórmula TR_F sem consultar notas.",
                                "Deriva a fórmula do zero em menos de 30 minutos.",
                                "Calcula TR_F numericamente para valores dados com erro <1%.",
                                "Explica o impacto de ζ e r na curva TR_F.",
                                "Identifica condições de isolamento (TR_F <1)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (100% dos passos corretos).",
                                "Clareza na explicação de cada step (uso de diagramas e unidades).",
                                "Compreensão conceitual (explica limites assintóticos).",
                                "Habilidade em verificação numérica e gráfica.",
                                "Aplicação a exemplo prático sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra complexa e análise harmônica.",
                                "Física: Oscilações forçadas e ressonância.",
                                "Engenharia Mecânica: Projeto de isoladores de vibração.",
                                "Controle de Sistemas: Análise de estabilidade em malha fechada.",
                                "Programação: Simulação numérica em Python/MATLAB."
                              ],
                              "realWorldApplication": "Projeto de suportes de motor em aeronaves para minimizar transmissão de vibrações harmônicas da hélice à estrutura, evitando fadiga e ruído na cabine, essencial em aviação comercial como no Boeing 737."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.1.2",
                            "name": "Análise de curvas de transmissibilidade de força",
                            "description": "Interpretar e analisar gráficos de transmissibilidade de força em função da razão de frequência r, identificando regiões de isolamento (r > sqrt(2)) e amplificação (r < sqrt(2)), com ênfase em aplicações aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Transmissibilidade de Força",
                                  "subSteps": [
                                    "Defina transmissibilidade de força (TR) como a razão entre a força transmitida para a base e a força excitante aplicada ao sistema SDOF.",
                                    "Explique a razão de frequência r = ω/ω_n, onde ω é a frequência de excitação e ω_n é a frequência natural do sistema.",
                                    "Identifique os regimes: amplificação (r < √2, TR > 1) e isolamento (r > √2, TR < 1).",
                                    "Discuta o papel do fator de amortecimento ζ na modificação da curva TR.",
                                    "Revise equações básicas de movimento para SDOF sob força harmônica."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e desenhe um esboço qualitativo da curva TR vs. r.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro-texto de Vibrações Mecânicas (ex: Rao ou Thomson)",
                                    "Folha de papel e caneta para esboços"
                                  ],
                                  "tips": "Comece com analogias cotidianas, como um carro em uma estrada irregular, para visualizar transmissão de vibrações.",
                                  "learningObjective": "Entender os fundamentos teóricos da transmissibilidade de força em sistemas SDOF.",
                                  "commonMistakes": [
                                    "Confundir TR de força com TR de deslocamento",
                                    "Ignorar o efeito do amortecimento na transição em r=√2"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar e Analisar a Fórmula da Transmissibilidade de Força",
                                  "subSteps": [
                                    "Derive a equação de TR para força: TR = |1 + (2ζr i)/(r² - 1 + 2ζr i)|, simplificando para módulo.",
                                    "Simplifique para casos sem amortecimento (ζ=0): TR = 1 / |1 - r²|.",
                                    "Calcule valores limite: TR→∞ em r=1 (ressonância), TR=1 em r=√2.",
                                    "Plote numericamente TR vs. r para ζ=0, 0.05, 0.2 usando software ou calculadora.",
                                    "Compare curvas para diferentes ζ e observe o deslocamento do pico de ressonância."
                                  ],
                                  "verification": "Derive a fórmula em um caderno e gere um gráfico com pelo menos 3 valores de ζ, marcando r=√2.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software MATLAB/Python (ou Excel para plotagem)",
                                    "Caderno de derivadas"
                                  ],
                                  "tips": "Use aproximações assintóticas para r<<1 (TR≈1) e r>>1 (TR≈1/r²) para validar plots.",
                                  "learningObjective": "Dominar a derivação matemática e o comportamento paramétrico da TR.",
                                  "commonMistakes": [
                                    "Erro na fórmula complexa (esquecer o denominador correto)",
                                    "Plotar log-log incorretamente sem normalizar"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar Gráficos de Transmissibilidade de Força",
                                  "subSteps": [
                                    "Analise o eixo x (r logarítmico) e y (TR logarítmico) em curvas típicas.",
                                    "Identifique regiões: r<√2 (amplificação, perto de 1), r=√2 (transição), r>√2 (isolamento decrescente).",
                                    "Marque pontos críticos: ressonância (máximo TR), crossover em r=√2.",
                                    "Interprete inclinações: -40 dB/década para r>>1 em sistemas amortecidos.",
                                    "Pratique leitura de curvas reais de dados experimentais ou simulados."
                                  ],
                                  "verification": "Dado um gráfico de TR vs. r, anote regiões, valores em r=1 e r=√2, e efeitos de ζ.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Gráficos de exemplo de livros ou online (ex: NASA tech reports)",
                                    "Ferramenta de plotagem como Desmos ou MATLAB"
                                  ],
                                  "tips": "Use escala log-log para visualizar melhor as regiões de isolamento de alta frequência.",
                                  "learningObjective": "Capacitar a leitura e interpretação precisa de curvas TR experimentais e teóricas.",
                                  "commonMistakes": [
                                    "Confundir isolamento de força com deslocamento",
                                    "Ignorar escala logarítmica ao estimar TR"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Análise em Contextos Aeroespaciais",
                                  "subSteps": [
                                    "Discuta aplicações: isoladores de vibração em motores de aeronaves ou hélices.",
                                    "Calcule r para um sistema real: ex. ω_n=100 Hz, excitação de motor em 200 Hz (r=2>√2, isolamento).",
                                    "Avalie trade-offs: alto ζ reduz pico mas piora isolamento em alta r.",
                                    "Simule um caso aeroespacial: monte de motor com falha em r≈1 levando a fadiga estrutural.",
                                    "Proponha designs: escolher ω_n baixa para r>>√2 em frequências operacionais."
                                  ],
                                  "verification": "Resolva um problema aeroespacial: dado ω_n e faixa de ω, recomende se isola ou amplifica.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Casos de estudo aeroespaciais (ex: artigos AIAA)",
                                    "Software de simulação como ANSYS ou Python"
                                  ],
                                  "tips": "Relacione com aeroelasticidade: vibrações transmitidas podem excitar modos flutter.",
                                  "learningObjective": "Aplicar conceitos de TR a problemas reais em dinâmica aeroespacial.",
                                  "commonMistakes": [
                                    "Subestimar efeitos não-lineares em mounts reais",
                                    "Não considerar direção da força (axial vs. shear)"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um motor de turbina de aeronave com ω_n do mount=50 Hz e rotações do compressor gerando excitação em 150 Hz (r=3>√2), analise a curva TR para ζ=0.1: TR≈0.2, significando 80% de isolamento de vibrações para a fuselagem, prevenindo fadiga.",
                              "finalVerifications": [
                                "Derivar corretamente a fórmula TR e plotar curvas para 3 valores de ζ.",
                                "Identificar precisamente regiões de amplificação e isolamento em um gráfico dado.",
                                "Calcular r e TR para um cenário aeroespacial real.",
                                "Explicar impacto de ζ no design de isoladores.",
                                "Propor melhorias em um sistema com TR>1 em operação.",
                                "Interpretar dados experimentais vs. teóricos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação e fórmulas (90% correto).",
                                "Qualidade e legibilidade de gráficos/plots.",
                                "Correta identificação de regiões críticas (r=√2, ressonância).",
                                "Relevância e profundidade de aplicações aeroespaciais.",
                                "Análise de trade-offs (ζ vs. isolamento).",
                                "Clareza em verificações e exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e plotagem log-log.",
                                "Física: Dinâmica de vibrações e amortecimento.",
                                "Engenharia Mecânica: Design de sistemas SDOF.",
                                "Ciência de Materiais: Seleção de elastômeros para mounts.",
                                "Controle de Sistemas: Integração com feedback ativo."
                              ],
                              "realWorldApplication": "No design de aeronaves, como no Boeing 787, análise de curvas TR otimiza isoladores de motores para reduzir transmissão de vibrações de alta frequência (r>√2), minimizando ruído na cabine, fadiga estrutural e melhorando conforto e longevidade."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.1.3",
                            "name": "Cálculo numérico de transmissibilidade de força",
                            "description": "Realizar cálculos numéricos para determinar TR_F em diferentes valores de r e ζ, utilizando equações derivadas e ferramentas computacionais simples, aplicadas a componentes estruturais como suportes de motores em aeronaves.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar fundamentos teóricos da transmissibilidade de força",
                                  "subSteps": [
                                    "Estude a equação de transmissibilidade de força (TR_F) para sistemas SDOF: TR_F = √[(1 + (2ζr)²) / ((1 - r²)² + (2ζr)²)], onde r = ω/ω_n e ζ é o fator de amortecimento.",
                                    "Identifique os parâmetros chave: frequência de excitação ω, frequência natural ω_n e ζ.",
                                    "Revise derivação da equação a partir das equações de movimento do sistema massa-mola-amortecedor.",
                                    "Compile uma tabela de valores típicos de r (0.1 a 3.0) e ζ (0.01 a 0.5) para estruturas aeroespaciais.",
                                    "Anote condições de ressonância (r ≈ 1) e isolamento (r > √2)."
                                  ],
                                  "verification": "Resuma as equações em um documento e teste compreensão calculando TR_F manualmente para r=1, ζ=0 (deve ser indefinido ou infinito).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Dinâmica de Estruturas (ex: Clough & Penzien)",
                                    "Folha de papel ou caderno",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Use diagramas de corpo livre para visualizar forças transmitidas.",
                                  "learningObjective": "Compreender a base matemática da TR_F e seus parâmetros dependentes.",
                                  "commonMistakes": [
                                    "Confundir TR_F com transmissibilidade de deslocamento",
                                    "Ignorar o sinal de r² na denominação",
                                    "Usar ζ >1 sem contexto over-damped"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar ferramenta computacional para cálculos numéricos",
                                  "subSteps": [
                                    "Escolha uma ferramenta simples: Excel, Google Sheets ou script Python básico com NumPy.",
                                    "Crie colunas para r (de 0.1 a 3.0, passo 0.1), ζ (valores fixos: 0.05, 0.1, 0.2), ω_n (ex: 100 rad/s).",
                                    "Implemente fórmulas: r = ω/ω_n, numerador = 1 + (2*ζ*r)^2, denominador = (1 - r^2)^2 + (2*ζ*r)^2, TR_F = SQRT(numerador/denominador).",
                                    "Adicione gráficos: TR_F vs r para diferentes ζ.",
                                    "Valide com cálculo manual para r=2, ζ=0.1 (TR_F ≈ 0.25)."
                                  ],
                                  "verification": "Execute a ferramenta e confirme que para r=√2 ≈1.414, ζ=0, TR_F=1.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Microsoft Excel ou Google Sheets",
                                    "Python com NumPy (opcional)",
                                    "Tutorial rápido de fórmulas Excel"
                                  ],
                                  "tips": "Use funções IF para evitar divisão por zero perto de r=1.",
                                  "learningObjective": "Dominar implementação numérica de equações não-lineares em ferramentas acessíveis.",
                                  "commonMistakes": [
                                    "Erro de sintaxe em fórmulas (ex: ^2 como **2 em Python)",
                                    "Escala errada em gráficos",
                                    "Não normalizar r corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar cálculos para cenários variados e analisar resultados",
                                  "subSteps": [
                                    "Calcule TR_F para 3 valores de ζ (0.05, 0.1, 0.3) sobre r=0.1 a 3.0.",
                                    "Identifique picos de ressonância e regiões de isolamento (TR_F <1).",
                                    "Compare resultados: como ζ afeta o pico e a frequência de isolamento.",
                                    "Gere tabela e plots: inclua r crítico onde TR_F=1.",
                                    "Calcule para caso específico: ω_n=200 rad/s (suporte motor), ω=400 rad/s, ζ=0.1."
                                  ],
                                  "verification": "Verifique se para ζ=0.1, r=1, TR_F >10 e diminui para r>1.5.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramenta configurada do Step 2",
                                    "Papel milimetrado para sketches",
                                    "Software de plotagem (Excel charts)"
                                  ],
                                  "tips": "Varie ζ logaritmicamente para capturar comportamentos em baixos amortecimentos.",
                                  "learningObjective": "Aplicar cálculos numéricos para explorar dependências paramétricas.",
                                  "commonMistakes": [
                                    "Usar passos grandes em r perto de 1",
                                    "Interpretar erroneamente isolamento para r<1",
                                    "Esquecer unidades consistentes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a componente estrutural real: suporte de motor em aeronave",
                                  "subSteps": [
                                    "Defina parâmetros reais: m=50kg (motor), k=1e6 N/m → ω_n=√(k/m)≈447 rad/s, ζ=0.05-0.15.",
                                    "Simule vibração do motor em ω=1000-3000 rpm (converta para rad/s).",
                                    "Calcule TR_F e força transmitida F_t = TR_F * F_0.",
                                    "Avalie: selecione ζ ótimo para minimizar F_t em regime operacional.",
                                    "Documente relatório com plots e recomendações de design."
                                  ],
                                  "verification": "Confirme que com ζ=0.1, TR_F<0.2 para r>2, reduzindo fadiga estrutural.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Dados reais de aeronaves (ex: manuais Boeing)",
                                    "Ferramenta do Step 2",
                                    "Template de relatório"
                                  ],
                                  "tips": "Considere não-linearidades reais como pré-carga, mas foque em linear primeiro.",
                                  "learningObjective": "Integrar cálculos em contexto engenharia aeroespacial prático.",
                                  "commonMistakes": [
                                    "Ignorar conversão rpm para rad/s (ω=2πN/60)",
                                    "Subestimar faixa operacional de motores",
                                    "Não considerar direção da força"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e sintetizar resultados com sensibilidade",
                                  "subSteps": [
                                    "Realize análise de sensibilidade: varie ω_n ±10%, observe impacto em TR_F.",
                                    "Compare com literatura ou software avançado (ex: ANSYS modal).",
                                    "Otimize ζ para mínimo TR_F em r operacional típico (r=2-3).",
                                    "Crie dashboard interativo no Excel para inputs variáveis.",
                                    "Escreva conclusões sobre trade-offs amortecimento vs isolamento."
                                  ],
                                  "verification": "Dashboard deve reproduzir TR_F=0.1 para r=3, ζ=0.2.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Excel avançado com Data Tables",
                                    "Referências acadêmicas em vibrações aeroespaciais"
                                  ],
                                  "tips": "Use goal seek no Excel para encontrar ζ ótimo.",
                                  "learningObjective": "Desenvolver habilidades de validação e otimização numérica.",
                                  "commonMistakes": [
                                    "Overfitting a um único ponto",
                                    "Não validar contra casos analíticos conhecidos",
                                    "Ignorar incertezas em parâmetros"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um suporte de motor de aeronave com ω_n=450 rad/s, ζ=0.1 e excitação do motor em 2000 rpm (ω≈209 rad/s, r≈0.46), calcule TR_F≈1.8, indicando amplificação; aumente ζ para 0.2 e recalcule TR_F≈1.1 para melhor isolamento.",
                              "finalVerifications": [
                                "Tabelas de TR_F corretas para r=0.5,1,1.5,2,2.5 e ζ=0.05,0.1,0.2.",
                                "Gráficos mostram pico em r≈1 e isolamento para r>√2.",
                                "Cálculo para caso real: F_t < 20% F_0 em regime operacional.",
                                "Análise de sensibilidade varia TR_F <10% com ±10% em parâmetros.",
                                "Relatório resume otimizações de ζ.",
                                "Validação contra equação analítica para ζ=0 (TR_F=1/|1-r²|)."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erro <1% em cálculos manuais vs ferramenta.",
                                "Cobertura paramétrica: pelo menos 30 pontos de r e 3 ζ.",
                                "Qualidade de visualizações: gráficos legíveis com legendas.",
                                "Aplicação contextual: ligação clara com suportes de motores.",
                                "Análise crítica: identificação de trade-offs e recomendações.",
                                "Documentação: relatório completo com fórmulas e referências.",
                                "Eficiência: uso correto de ferramentas sem erros de implementação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Métodos numéricos, análise de funções e otimização.",
                                "Programação: Scripts em Python/Excel para automação computacional.",
                                "Física: Dinâmica vibracional e equações diferenciais.",
                                "Engenharia de Materiais: Seleção de amortecedores baseados em ζ.",
                                "Design Aeronáutico: Integração em CAD/FEM para validação."
                              ],
                              "realWorldApplication": "Em aeronaves, otimizar suportes de motores reduz transmissão de vibrações para fuselagem, minimizando fadiga estrutural, ruído e falhas prematuras, essencial para certificação FAA/EASA em vibroacústica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.6.2",
                        "name": "Transmissibilidade de Movimento",
                        "description": "Medida da transmissão de deslocamentos ou acelerações da base de excitação para a massa em sistemas SDOF, crucial para isolamento em estruturas aeroespaciais sujeitas a vibrações de base.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.6.2.1",
                            "name": "Derivação da transmissibilidade de deslocamento",
                            "description": "Derivar a fórmula TR_X = |X / Y_0| = sqrt(1 + (2ζr)^2) / sqrt((1 - r^2)^2 + (2ζr)^2) para excitação de base harmônica Y(t) = Y_0 sin(ωt), destacando similaridades com transmissibilidade de força.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estabelecer a equação de movimento para SDOF com excitação de base harmônica",
                                  "subSteps": [
                                    "Defina as variáveis: massa m, rigidez k, amortecimento c, posição absoluta da massa X(t), posição da base Y(t) = Y_0 sin(ωt).",
                                    "Escreva a soma de forças: força inercial -m Ẍ, força de amortecimento -c (Ẋ - Ẏ), força elástica -k (X - Y) = 0.",
                                    "Rearranje para m Ẍ + c (Ẋ - Ẏ) + k (X - Y) = 0.",
                                    "Verifique unidades e sinais físicos.",
                                    "Introduza frequências: ω_n = sqrt(k/m), ζ = c / (2 sqrt(k m)), r = ω / ω_n."
                                  ],
                                  "verification": "Equação escrita corretamente como m Ẍ + c (Ẋ - Ẏ) + k (X - Y) = 0, com definições de parâmetros não-dimensionais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de vibrações mecânicas (ex: Rao ou Inman)",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Visualize o sistema: mola e damper conectados entre massa e base móvel.",
                                  "learningObjective": "Modelar fisicamente o sistema SDOF sob excitação de base e introduzir parâmetros normalizados.",
                                  "commonMistakes": [
                                    "Confundir X absoluta com deslocamento relativo",
                                    "Esquecer sinal negativo em termos de Ẏ e Y",
                                    "Definir r incorretamente como ω_n / ω"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Transformar em equação de resposta forçada padrão",
                                  "subSteps": [
                                    "Rearranje: m Ẍ + c Ẋ + k X = c Ẏ + k Y.",
                                    "Calcule Ẏ(t) = ω Y_0 cos(ωt).",
                                    "Escreva f(t) = k Y_0 sin(ωt) + c ω Y_0 cos(ωt).",
                                    "Expresse f(t) na forma harmônica F sin(ωt + φ), identificando F e φ.",
                                    "Confirme que é uma excitação harmônica equivalente."
                                  ],
                                  "verification": "f(t) = k Y_0 sin(ωt) + c ω Y_0 cos(ωt) escrito corretamente na forma padrão.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software simbólico como Mathematica ou SymPy (opcional)",
                                    "Tabela de fasores"
                                  ],
                                  "tips": "Use fasores para representar sin e cos como partes imaginária/real de e^{jωt}.",
                                  "learningObjective": "Reconhecer a excitação de base como força equivalente harmônica.",
                                  "commonMistakes": [
                                    "Erro no cálculo de Ẏ(t)",
                                    "Omitir fator ω em c Ẏ",
                                    "Confundir fase de sin e cos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a amplitude da força excitante F",
                                  "subSteps": [
                                    "Calcule F = sqrt( (k Y_0)^2 + (c ω Y_0)^2 ).",
                                    "Substitua c = 2 ζ sqrt(k m), ω = r ω_n, ω_n^2 = k/m.",
                                    "Simplifique: F = k Y_0 sqrt(1 + (2 ζ r)^2 ).",
                                    "Verifique dimensionalmente: F tem unidades de força.",
                                    "Discuta interpretação física de cada termo."
                                  ],
                                  "verification": "F = k Y_0 sqrt(1 + (2 ζ r)^2 ) derivado corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Folha com identidades trigonométricas",
                                    "Software de álgebra simbólica"
                                  ],
                                  "tips": "Fatore k Y_0 para normalizar desde o início.",
                                  "learningObjective": "Derivar a amplitude não-dimensional da excitação equivalente.",
                                  "commonMistakes": [
                                    "Erro em c ω = 2 ζ m ω_n ω",
                                    "Esquecer sqrt em F",
                                    "Não normalizar por k"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar a amplitude da resposta X e a transmissibilidade TR_X",
                                  "subSteps": [
                                    "Lembre a amplitude para força harmônica: |X| = F / sqrt( (k - m ω^2)^2 + (c ω)^2 ).",
                                    "Simplifique denominador: k sqrt( (1 - r^2)^2 + (2 ζ r)^2 ).",
                                    "Substitua F: |X| = [k Y_0 sqrt(1 + (2 ζ r)^2 )] / [k sqrt( (1 - r^2)^2 + (2 ζ r)^2 )].",
                                    "Simplifique: TR_X = |X / Y_0| = sqrt(1 + (2 ζ r)^2 ) / sqrt( (1 - r^2)^2 + (2 ζ r)^2 ).",
                                    "Compare com TR_força, destacando identidade formal."
                                  ],
                                  "verification": "Fórmula TR_X derivada exatamente como dada, com comparação explícita à transmissibilidade de força.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Gráficos de TR_força vs r para comparação visual"
                                  ],
                                  "tips": "Divida numerador e denominador por k desde o início para evitar erros.",
                                  "learningObjective": "Obter a fórmula final e compreender sua similaridade com TR_força.",
                                  "commonMistakes": [
                                    "Erro no denominador (k - m ω^2 = k(1 - r^2))",
                                    "Não cancelar k corretamente",
                                    "Confundir TR_X com TR relativa"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma montagem de motor de aeronave, a fuselagem vibra como base Y(t) = 0.1 sin(2π*50 t) mm devido a turbulência (ω=314 rad/s). Usando m=10 kg, k=10^5 N/m, ζ=0.05, derive TR_X para verificar se a vibração transmitida ao motor excede 0.05 mm, projetando isoladores adequados.",
                              "finalVerifications": [
                                "Fórmula TR_X = sqrt(1 + (2ζr)^2) / sqrt((1 - r^2)^2 + (2ζr)^2) derivada sem erros algébricos.",
                                "Amplitude F = k Y_0 sqrt(1 + (2ζr)^2) calculada corretamente.",
                                "Similaridade com transmissibilidade de força destacada conceitualmente.",
                                "Parâmetros r, ζ usados consistentemente em todo o processo.",
                                "Verificação numérica para r=1, ζ=0: TR_X ≈1.",
                                "Interpretação física: TR_X >1 perto de ressonância."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação matemática (sem erros em simplificações).",
                                "Correta identificação da força equivalente f(t).",
                                "Uso apropriado de variáveis não-dimensionais.",
                                "Explicação clara da similaridade com TR_força.",
                                "Capacidade de aplicar a exemplo prático com números.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e fasores para soluções harmônicas.",
                                "Física: Princípios newtonianos e equações diferenciais lineares.",
                                "Engenharia Mecânica: Projeto de isoladores e análise modal.",
                                "Computação: Simulação em MATLAB/Python para validar derivação.",
                                "Controle de Sistemas: Analogia com funções de transferência."
                              ],
                              "realWorldApplication": "Na aeroelasticidade, essa derivação é essencial para projetar isoladores de vibração em montagens de motores de aviões ou hélices de drones, minimizando transmissão de vibrações da fuselagem (devido a rajadas de vento ou desbalanceamento rotativo) para instrumentos sensíveis, evitando fadiga estrutural e melhorando conforto de voo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.2.2",
                            "name": "Interpretação de transmissibilidade de aceleração",
                            "description": "Analisar a transmissibilidade de aceleração da massa em relação à base, identificando condições para isolamento efetivo (r >> sqrt(2)) em cenários como vibrações de fuselagem em aeronaves.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Transmissibilidade em Sistemas SDOF",
                                  "subSteps": [
                                    "Revise o modelo de sistema com um grau de liberdade (SDOF) composto por massa, mola e amortecedor.",
                                    "Defina transmissibilidade de aceleração como a razão entre a aceleração da massa e a aceleração da base.",
                                    "Identifique os parâmetros chave: frequência natural ω_n, razão de frequência r = ω/ω_n e razão de amortecimento ζ.",
                                    "Estude o papel da base excitada em vibrações forçadas.",
                                    "Compare transmissibilidade de deslocamento, velocidade e aceleração."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre transmissibilidade de deslocamento e aceleração, citando as fórmulas básicas.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Livro-texto de Dinâmica de Estruturas (ex: Clough & Penzien)",
                                    "Notas de aula sobre SDOF",
                                    "Software de simulação como MATLAB ou Python (SymPy)"
                                  ],
                                  "tips": "Comece com diagramas esquemáticos para visualizar o sistema massa-base.",
                                  "learningObjective": "Dominar os fundamentos teóricos da transmissibilidade de aceleração em SDOF.",
                                  "commonMistakes": [
                                    "Confundir transmissibilidade de aceleração com deslocamento",
                                    "Ignorar o efeito do amortecimento ζ na curva",
                                    "Não normalizar pela frequência natural"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar e Calcular a Fórmula de Transmissibilidade de Aceleração",
                                  "subSteps": [
                                    "Derive a equação de movimento para base excitada: mẍ + c(ẋ - ẏ) + k(x - y) = 0.",
                                    "Obtenha a solução em domínio de frequência para aceleração da massa.",
                                    "Escreva a fórmula: TR_a = |Ẍ / Ý| = sqrt( (1 + (2ζr)^2) / ((1 - r^2)^2 + (2ζr)^2) ) * r^2.",
                                    "Calcule numericamente TR_a para valores de r e ζ variados usando uma planilha ou código.",
                                    "Plote TR_a vs r para ζ fixo (ex: 0.05)."
                                  ],
                                  "verification": "Forneça a derivação passo a passo e calcule TR_a para r=1, ζ=0.1 (resposta esperada ≈ 1).",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Caderno de derivadas",
                                    "Excel ou Python (NumPy/Matplotlib)",
                                    "Referência: Meirovitch - Fundamentals of Vibration"
                                  ],
                                  "tips": "Use aproximações para r<<1 e r>>1 para validar cálculos.",
                                  "learningObjective": "Capacitar-se a derivar e computar TR_a com precisão.",
                                  "commonMistakes": [
                                    "Erro na fase da solução complexa",
                                    "Esquecer o fator r^2 na aceleração",
                                    "Usar fórmula errada de deslocamento"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Interpretar Gráficos de Transmissibilidade e Identificar Regiões Críticas",
                                  "subSteps": [
                                    "Analise o gráfico log-log de TR_a vs r: picos em r≈1, queda para r>sqrt(2).",
                                    "Identifique a região de isolamento: TR_a <1 quando r > sqrt(2) ≈1.414.",
                                    "Discuta o efeito de ζ: amortecimento alto reduz pico mas aumenta r para isolamento.",
                                    "Marque condições r >> sqrt(2) para isolamento efetivo (TR_a <<1).",
                                    "Compare com cenários reais de vibrações de fuselagem."
                                  ],
                                  "verification": "Desenhe e anote o gráfico de TR_a para ζ=0.05, destacando r=sqrt(2) e explicando isolamento.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Gráficos pré-gerados ou MATLAB",
                                    "Papel milimetrado",
                                    "Artigo sobre vibrações aeroespaciais"
                                  ],
                                  "tips": "Use escalas logarítmicas para melhor visualização de regiões assintóticas.",
                                  "learningObjective": "Interpretar visualmente comportamentos dinâmicos e condições de isolamento.",
                                  "commonMistakes": [
                                    "Confundir sqrt(2) com 2",
                                    "Ignorar assíntota para r>>1 (TR_a ≈ 1/r^2)",
                                    "Não considerar ζ variável"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Interpretação em Cenários de Isolamento de Vibrações em Aeronaves",
                                  "subSteps": [
                                    "Selecione um caso: vibrações de fuselagem devido a motores (f≈100 Hz).",
                                    "Estime ω_n para isolador e calcule r.",
                                    "Verifique se r >> sqrt(2) para isolamento efetivo de acelerações na cabine.",
                                    "Simule variação de parâmetros para otimizar isolamento.",
                                    "Discuta trade-offs: isolamento vs rigidez estrutural."
                                  ],
                                  "verification": "Resolva um problema numérico: dado ω=200 rad/s, ω_n=20 rad/s, ζ=0.1, confirme isolamento e calcule TR_a.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Dados reais de aeronaves (NASA reports)",
                                    "Simulador online de vibrações",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Considere frequências múltiplas em aeronaves para análise realista.",
                                  "learningObjective": "Aplicar conceitos a problemas práticos de engenharia aeroespacial.",
                                  "commonMistakes": [
                                    "Subestimar frequências de excitação real",
                                    "Não validar unidades de frequência",
                                    "Ignorar efeitos não-lineares"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma aeronave comercial, motores geram vibrações a 150 Hz na fuselagem. Projetando um isolador com ω_n=30 rad/s (≈4.8 Hz), r=150*2π/30≈31.4 >> sqrt(2), resultando em TR_a≈1/(31.4)^2≈0.001, reduzindo acelerações na cabine de 10g para 0.01g.",
                              "finalVerifications": [
                                "Explicar verbalmente a fórmula de TR_a e suas assíntotas.",
                                "Plotar e interpretar gráfico de TR_a para ζ=0.05 e 0.2.",
                                "Calcular r necessário para TR_a<0.1 dado ζ=0.1.",
                                "Identificar condições r>>sqrt(2) em um diagrama.",
                                "Aplicar a um caso de vibração de aeronave com números corretos.",
                                "Discutir limitações do modelo SDOF."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação e cálculo de TR_a (90% correto).",
                                "Interpretação correta de gráficos e regiões de isolamento.",
                                "Identificação precisa de r >> sqrt(2) com justificativa.",
                                "Aplicação prática relevante a aeroespacial.",
                                "Clareza em explicações e avoidance de erros comuns.",
                                "Criatividade em exemplos reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e transformadas de Fourier.",
                                "Física Geral: Oscilações forçadas e ressonância.",
                                "Engenharia Mecânica: Projeto de isoladores de vibração.",
                                "Controle de Sistemas: Estabilidade e resposta em frequência.",
                                "Ciência de Materiais: Propriedades de amortecedores."
                              ],
                              "realWorldApplication": "Projeto de montagens de motores em aeronaves para isolar vibrações da fuselagem, reduzindo fadiga estrutural e melhorando conforto de passageiros; similarmente em edifícios sísmicos e equipamentos médicos sensíveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.2.3",
                            "name": "Comparação entre transmissibilidades de força e movimento",
                            "description": "Comparar graficamente e conceitualmente as curvas de TR_F e TR_X, explicando implicações para o design de estruturas aeroespaciais sob excitações de base.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Transmissibilidade em Sistemas SDOF",
                                  "subSteps": [
                                    "Defina transmissibilidade de força (TR_F) como a razão entre a força transmitida para a base e a força excitante.",
                                    "Defina transmissibilidade de movimento (TR_X) como a razão entre a amplitude de deslocamento da massa e o deslocamento da base.",
                                    "Identifique as condições de excitação de base típicas em estruturas aeroespaciais, como vibrações do solo durante lançamento.",
                                    "Revise a equação de movimento para SDOF sob excitação de base: mẍ + c(ẋ - ẏ) + k(x - y) = 0, onde y é o deslocamento da base.",
                                    "Explique o papel do fator de amplificação dinâmica (r = ω/ω_n) em ambas as transmissibilidades."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre TR_F e TR_X, citando as definições exatas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro-texto de Dinâmica de Estruturas (ex: Clough & Penzien)",
                                    "Notas de aula sobre SDOF",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Use diagramas esquemáticos para visualizar o sistema massa-mola-amortecedor com base móvel.",
                                  "learningObjective": "Compreender as definições e contextos físicos de TR_F e TR_X em vibrações forçadas por base.",
                                  "commonMistakes": [
                                    "Confundir excitação de força direta com excitação de base",
                                    "Ignorar o efeito do amortecimento em baixas frequências"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar as Fórmulas Analíticas para TR_F e TR_X",
                                  "subSteps": [
                                    "Derive TR_X = |X/Y| = √[(1 + (2ζr)^2) / ((1 - r^2)^2 + (2ζr)^2)], onde r = ω/ω_n e ζ é o fator de amortecimento.",
                                    "Derive TR_F = |F_T/F_0| = √[(1 + (2ζr)^2) / ((1 - r^2)^2 + (2ζr)^2)] * |1 - r^2|, destacando a diferença multiplicativa.",
                                    "Calcule numericamente TR_F e TR_X para ζ = 0.05, 0.1 e r de 0 a 3.",
                                    "Compare as expressões assintóticas: para r >> 1, TR_X ≈ 1/(r^2), TR_F ≈ 1.",
                                    "Discuta como o amortecimento afeta o pico de ressonância em cada curva."
                                  ],
                                  "verification": "Escreva as fórmulas derivadas e verifique com valores tabelados de um livro-texto.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software simbólico como Mathematica ou SymPy",
                                    "Planilha Excel para cálculos numéricos",
                                    "Papel e lápis para derivação"
                                  ],
                                  "tips": "Comece com o caso não amortecido (ζ=0) para simplificar a intuição antes de adicionar amortecimento.",
                                  "learningObjective": "Dominar as expressões matemáticas exatas e suas diferenças chave entre TR_F e TR_X.",
                                  "commonMistakes": [
                                    "Esquecer o termo |1 - r^2| em TR_F",
                                    "Confundir deslocamento relativo com absoluto na derivação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e Comparar Graficamente as Curvas de TR_F e TR_X",
                                  "subSteps": [
                                    "Plote TR_X vs. r para ζ = 0, 0.05, 0.2 em escala logarítmica.",
                                    "Plote TR_F vs. r nas mesmas condições, sobrepondo as curvas de TR_X.",
                                    "Identifique graficamente regiões: isolamento (r > √2), ressonância (r ≈ 1) e amplificação.",
                                    "Marque os pontos onde TR_F = 1 e TR_X = 1, explicando transições.",
                                    "Gere gráficos para diferentes ζ e anote mudanças qualitativas."
                                  ],
                                  "verification": "Produza pelo menos 3 gráficos comparativos e descreva 3 diferenças visuais chave.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB ou Python (Matplotlib) para plotagem",
                                    "Templates de script prontos para transmissibilidade"
                                  ],
                                  "tips": "Use escala log-log para melhor visualização das caudas assintóticas em altas frequências.",
                                  "learningObjective": "Visualizar e interpretar graficamente as diferenças entre curvas de transmissibilidade.",
                                  "commonMistakes": [
                                    "Plotar em escala linear, perdendo detalhes em r > 2",
                                    "Não normalizar corretamente os eixos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Implicações Conceituais e para Design Aeroespacial",
                                  "subSteps": [
                                    "Explique conceitualmente por que TR_F ≈ 1 para r >> 1 (massa 'flutua'), mas TR_X decai.",
                                    "Discuta implicações para isolamento de vibrações: prefira alto r para TR_X baixa em payloads sensíveis.",
                                    "Aplique a design de suportes de motores em aeronaves: minimize TR_F para reduzir fadiga estrutural.",
                                    "Considere excitações de base em lançadores espaciais e trade-offs entre ζ e ω_n.",
                                    "Sintetize: TR_X para proteção de componentes frágeis, TR_F para integridade da estrutura."
                                  ],
                                  "verification": "Escreva um relatório de 300 palavras ligando gráficos a decisões de design reais.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Artigos sobre aeroelasticidade (ex: NASA reports)",
                                    "Casos de estudo de falhas por vibração em foguetes"
                                  ],
                                  "tips": "Relacione sempre de volta aos gráficos: 'Veja como em r=3, TR_F=1 significa...'.",
                                  "learningObjective": "Conectar análise teórica a implicações práticas no design de estruturas aeroespaciais.",
                                  "commonMistakes": [
                                    "Generalizar isolamento sem especificar TR_F vs TR_X",
                                    "Ignorar efeitos não-lineares em aplicações reais"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um satélite montado em um lançador como o Falcon 9, compare TR_X para proteger eletrônicos sensíveis das vibrações da base (decolagem) e TR_F para evitar transmissão de força ao casco do foguete, otimizando o suporte isolador para r > √2 e ζ ≈ 0.1.",
                              "finalVerifications": [
                                "Explicar verbalmente as diferenças entre TR_F e TR_X sem consultar notas.",
                                "Plotar manualmente curvas aproximadas para ζ=0.1 e identificar regiões chave.",
                                "Calcular TR_X e TR_F para r=0.5, 1.5, 3 com erro <5%.",
                                "Discutir 2 implicações específicas para design de asas de aeronaves.",
                                "Identificar em um gráfico real qual curva é TR_F vs TR_X.",
                                "Propor um isolador para uma aplicação aeroespacial dada frequência de excitação."
                              ],
                              "assessmentCriteria": [
                                "Precisão das fórmulas derivadas (100% correto).",
                                "Qualidade e legibilidade dos gráficos comparativos (legendas, escalas corretas).",
                                "Profundidade da análise conceitual (ligações claras entre gráficos e física).",
                                "Relevância das implicações ao contexto aeroespacial (exemplos específicos).",
                                "Completude dos cálculos numéricos e verificações.",
                                "Clareza na comunicação escrita/oral das diferenças chave."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e funções de transferência.",
                                "Física: Dinâmica clássica e teoria de vibrações.",
                                "Engenharia Mecânica: Projeto de isoladores e análise modal.",
                                "Ciência de Materiais: Seleção de amortecedores viscoelásticos.",
                                "Computação: Programação numérica para simulações (MATLAB/Python)."
                              ],
                              "realWorldApplication": "No design de hélices de turbinas a gás ou suportes de aviônicos em caças, engenheiros usam essa comparação para minimizar vibrações transmitidas durante manobras, prevenindo fadiga e falhas catastróficas, como visto no incidente de vibração no Boeing 787."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.6.3",
                        "name": "Técnicas de Isolamento Vibracional",
                        "description": "Métodos e critérios para projetar isoladores vibracionais que minimizem a transmissão de vibrações em estruturas aeroespaciais, baseados em escolha de rigidez, amortecimento e razão de frequência.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.6.3.1",
                            "name": "Critérios para isolamento efetivo",
                            "description": "Definir e aplicar o critério r > sqrt(2) para isolamento vibracional, calculando rigidez k e frequência natural ω_n necessária para um isolador dado uma frequência de excitação ω.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de transmissibilidade vibracional em sistemas SDOF",
                                  "subSteps": [
                                    "Revise a equação de movimento de um sistema SDOF com excitação harmônica: mẍ + cẋ + kx = F0 sin(ωt).",
                                    "Defina a razão de frequência r = ω / ω_n, onde ω_n = sqrt(k/m).",
                                    "Estude a função de transmissibilidade de força T(r) ≈ |1 / (1 - r²)| para amortecimento desprezível.",
                                    "Identifique que T(r) < 1 ocorre quando r > sqrt(2), indicando isolamento efetivo.",
                                    "Plote graficamente T(r) para visualizar a região de isolamento."
                                  ],
                                  "verification": "Capacidade de explicar verbalmente ou por escrito por que T(r) diminui para r > sqrt(2) e reproduzir o gráfico qualitativo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de dinâmica (ex: Thomson), calculadora gráfica, software de plotagem (Matlab ou Python com Matplotlib).",
                                  "tips": "Comece com ζ=0 para simplificar; foque na intuição física da ressonância.",
                                  "learningObjective": "Entender a base teórica da transmissibilidade e o papel de r na atenuação de vibrações.",
                                  "commonMistakes": "Confundir transmissibilidade de deslocamento com a de força; ignorar o efeito do amortecimento."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e derivar o critério r > sqrt(2) para isolamento efetivo",
                                  "subSteps": [
                                    "Derive a condição T(r) < 1 a partir de T(r) = sqrt(1 + (2ζr)²) / sqrt((1 - r²)² + (2ζr)²) ≈ 1 / |1 - r²| para ζ baixo.",
                                    "Resolva |1 - r²| > 1, levando a r > sqrt(2).",
                                    "Discuta o significado físico: frequência natural deve ser bem inferior à de excitação.",
                                    "Compare com região de ressonância (r ≈ 1) e amplificação.",
                                    "Calcule numericamente T(r) para r=1, r=sqrt(2) e r=2."
                                  ],
                                  "verification": "Resolver exercício: dado r=1.5, calcule T(r) aproximado e confirme se isola.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de papel para derivação, calculadora científica, tabela de valores de T(r).",
                                  "tips": "Use aproximação para ζ<0.1; memorize sqrt(2) ≈ 1.414 como limite.",
                                  "learningObjective": "Dominar a definição matemática e física do critério de isolamento efetivo.",
                                  "commonMistakes": "Esquecer o módulo absoluto em |1 - r²|; aplicar critério sem considerar massa."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a frequência natural ω_n necessária dado ω de excitação",
                                  "subSteps": [
                                    "Dado ω, aplique r > sqrt(2), logo ω_n < ω / sqrt(2).",
                                    "Escolha margem de segurança, ex: r = 1.5 a 2, definindo ω_n = ω / r.",
                                    "Verifique unidades: ω em rad/s, converter Hz se necessário (ω = 2πf).",
                                    "Calcule ω_n para exemplos variados (baixa e alta frequência).",
                                    "Avalie impacto de incertezas em ω (faixa operacional)."
                                  ],
                                  "verification": "Dado ω=100 rad/s, calcule ω_n máx para isolamento e justifique escolha de r.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora, tabela de conversão Hz-rad/s.",
                                  "tips": "Sempre use rad/s para consistência; adote r_min = sqrt(2) + margem.",
                                  "learningObjective": "Aplicar o critério para determinar ω_n requerida em isoladores.",
                                  "commonMistakes": "Confundir ω (rad/s) com f (Hz); escolher r muito próximo de sqrt(2) sem margem."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar a rigidez k do isolador dado ω_n e massa m",
                                  "subSteps": [
                                    "Use ω_n = sqrt(k/m), rearranjando para k = m ω_n².",
                                    "Integre com passo anterior: k = m (ω / r)² com r > sqrt(2).",
                                    "Calcule para m conhecida, verificando rigidez realista (ex: k baixa para isoladores macios).",
                                    "Considere limitações práticas: deflexão estática δ = mg/k < limite.",
                                    "Otimize k minimizando T(r) para faixa de ω."
                                  ],
                                  "verification": "Dado m=10 kg, ω=100 rad/s, r=1.8, calcule k e verifique r > sqrt(2).",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Calculadora, software de simulação (ex: MATLAB para validar T(r)).",
                                  "tips": "Verifique unidades SI (k em N/m); isole numericamente para precisão.",
                                  "learningObjective": "Calcular parâmetros práticos do isolador para isolamento efetivo.",
                                  "commonMistakes": "Esquecer o quadrado em ω_n²; usar g em deflexão sem consistência."
                                }
                              ],
                              "practicalExample": "Em uma aeronave, um motor de 50 kg opera a 120 Hz (ω ≈ 754 rad/s). Para isolar vibrações da fuselagem, calcule ω_n < 754 / sqrt(2) ≈ 533 rad/s e k = 50 * (533)^2 ≈ 1.42e7 N/m, garantindo r ≈ 1.414+ e T(r)<1.",
                              "finalVerifications": [
                                "Define corretamente r = ω / ω_n e o critério r > sqrt(2).",
                                "Calcula ω_n e k com precisão numérica para dados fornecidos.",
                                "Interpreta graficamente a região de isolamento em curva T(r).",
                                "Identifica limitações práticas como deflexão estática.",
                                "Aplica critério em exemplo aeroespacial real."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos (erro <5%).",
                                "Compreensão conceitual demonstrada em explicações.",
                                "Uso correto de unidades e aproximações.",
                                "Aplicação prática com margem de segurança.",
                                "Análise de erros comuns evitados.",
                                "Integração com contexto de dinâmica aeroespacial."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra e análise de funções (derivadas de T(r)).",
                                "Física: Oscilações harmônicas e ressonância.",
                                "Engenharia Mecânica: Projeto de sistemas passivos.",
                                "Controle de Sistemas: Comparação com isoladores ativos."
                              ],
                              "realWorldApplication": "No design de aeronaves, esse critério é usado para isoladores de motores e hélices, reduzindo fadiga estrutural, ruído na cabine e melhorando conforto em voo, como nos amortecedores de vibração em helicópteros ou aviões comerciais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.3.2",
                            "name": "Projeto de isoladores com amortecimento ótimo",
                            "description": "Determinar o valor ótimo de ζ que minimiza a transmissibilidade em altas frequências, utilizando ζ_opt ≈ 0.5 para isolamento de força, e aplicando a exemplos de montagens de equipamentos em satélites.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão de Transmissibilidade e Amortecimento em Isoladores",
                                  "subSteps": [
                                    "Estude a definição de transmissibilidade de força (TR) em sistemas SDOF com isoladores: TR = |F_transmitida / F_aplicada|.",
                                    "Revise as equações de movimento para um sistema massa-mola-amortecedor sob excitação harmônica.",
                                    "Analise o gráfico de TR vs. razão de frequência (r = ω/ω_n), identificando regiões de isolamento (r >> 1).",
                                    "Entenda o papel do fator de amortecimento ζ na curva de TR, especialmente como ζ afeta o pico de ressonância e o comportamento em altas frequências.",
                                    "Calcule TR para ζ = 0 (sem amortecimento) e compare com casos amortecidos."
                                  ],
                                  "verification": "Responda corretamente a 5 perguntas sobre as equações e gráficos de TR, com pelo menos 90% de acerto.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Dinâmica de Estruturas Aeroespaciais (ST-57)",
                                    "Software MATLAB ou Python para plotar curvas de TR",
                                    "Folhas de cálculo com equações de SDOF"
                                  ],
                                  "tips": "Use plots logarítmicos para visualizar melhor o comportamento assintótico em altas frequências.",
                                  "learningObjective": "Compreender como a transmissibilidade varia com ζ e r em isoladores vibracionais.",
                                  "commonMistakes": [
                                    "Confundir transmissibilidade de força com deslocamento",
                                    "Ignorar a dependência quadrática de TR em ζ para r >> 1"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Análise da Minimização de Transmissibilidade em Altas Frequências",
                                  "subSteps": [
                                    "Derive a expressão assintótica de TR para r >> 1: TR ≈ √(1 + (2ζ r)^2) / (2ζ r).",
                                    "Simplifique para o comportamento dominante: TR ≈ 1 / (2ζ) em altas frequências.",
                                    "Identifique que para minimizar TR, ζ deve ser maximizado, mas equilibrado com o pico de ressonância.",
                                    "Estude o trade-off: ζ alto reduz TR em altas f, mas aumenta o pico em r ≈ 1.",
                                    "Analise numericamente curvas de TR para diferentes ζ (0.1, 0.3, 0.5, 0.7) usando software."
                                  ],
                                  "verification": "Gere e interprete plots de TR para 4 valores de ζ, explicando o mínimo em altas f.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Script MATLAB/Python para curvas de Bode de TR",
                                    "Tabelas de valores assintóticos de TR"
                                  ],
                                  "tips": "Foque na região r > √2, onde o isolamento começa a ser efetivo.",
                                  "learningObjective": "Analisar matematicamente como ζ influencia TR em altas frequências.",
                                  "commonMistakes": [
                                    "Usar aproximação errada para TR em r >> 1",
                                    "Maximizar ζ sem considerar ressonância"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinação do Valor Ótimo de ζ (ζ_opt ≈ 0.5)",
                                  "subSteps": [
                                    "Revise literatura ou derive que para isolamento de força, ζ_opt ≈ 0.5 minimiza TR máxima em r > 1.",
                                    "Calcule ζ_opt resolvendo d(TR)/dζ = 0 para a região de interesse.",
                                    "Justifique ζ_opt ≈ 0.5: equilibra redução de TR em altas f com controle do pico de ressonância.",
                                    "Compare ζ_opt para isolamento de força vs. deslocamento (diferentes valores).",
                                    "Valide com simulações: compute TR_max para ζ de 0.4 a 0.6."
                                  ],
                                  "verification": "Demonstre cálculo de ζ_opt com erro < 5% do valor teórico e plot de validação.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Equações derivadas de TR",
                                    "Calculadora simbólica como SymPy",
                                    "Referências aeroespaciais sobre isoladores"
                                  ],
                                  "tips": "Use critério de minimização de TR no intervalo r = 1.4 a 10 para otimização prática.",
                                  "learningObjective": "Determinar e justificar ζ_opt ≈ 0.5 para isolamento ótimo de vibrações.",
                                  "commonMistakes": [
                                    "Confundir ζ_opt para força com deslocamento (≈0.707)",
                                    "Ignorar dependência do intervalo de frequência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicação Prática em Montagens de Equipamentos em Satélites",
                                  "subSteps": [
                                    "Selecione um exemplo: montagem de giroscópio em satélite com ω_n = 10 Hz, excitação de lançamento em 50-100 Hz.",
                                    "Calcule k e c necessários para ζ = 0.5, dado m = 5 kg.",
                                    "Simule resposta do sistema e compute redução de força transmitida (>90%).",
                                    "Avalie sensibilidade: varie ζ ±0.1 e compare TR.",
                                    "Documente projeto: especificações de isolador (borracha ou fluido com ζ=0.5)."
                                  ],
                                  "verification": "Produza relatório com cálculos, simulações e gráficos mostrando TR < 0.2 em altas f.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Dados reais de vibrações de lançamento (NASA/ESA)",
                                    "Software ANSYS ou Simulink para SDOF",
                                    "Planilhas de projeto de isoladores"
                                  ],
                                  "tips": "Considere não-linearidades reais, mas inicie com modelo linear SDOF.",
                                  "learningObjective": "Aplicar ζ_opt em projeto real de isoladores para satélites.",
                                  "commonMistakes": [
                                    "Subestimar massa efetiva",
                                    "Não converter unidades de frequência corretamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Projeto de isoladores para um giroscópio de 5 kg em um satélite, com frequência natural de 10 Hz. Excitação de lançamento em 80 Hz (r=8). Usando ζ=0.5, selecione mola k=10^5 N/m e amortecedor c=500 Ns/m, reduzindo TR de 1 para ~0.125, protegendo o equipamento de vibrações excessivas.",
                              "finalVerifications": [
                                "Cálculo preciso de ζ_opt ≈ 0.5 com derivação ou simulação.",
                                "Plots de TR mostrando mínimo em altas frequências para ζ=0.5.",
                                "Aplicação correta em exemplo de satélite com redução de TR >80%.",
                                "Justificativa do trade-off ressonância vs. isolamento.",
                                "Relatório documentado com todos os parâmetros do isolador.",
                                "Validação numérica contra valores teóricos assintóticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de TR e ζ_opt (erro <5%).",
                                "Qualidade e correção dos plots e simulações.",
                                "Profundidade na análise de trade-offs e justificativas.",
                                "Relevância e realismo da aplicação em satélites.",
                                "Completude da documentação e verificações.",
                                "Criatividade em conexões com cenários aeroespaciais reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização univariada e análise assintótica.",
                                "Física: Dinâmica de vibrações e equações diferenciais.",
                                "Engenharia Mecânica: Projeto de componentes elastoméricos.",
                                "Ciência de Materiais: Seleção de materiais com ζ controlado.",
                                "Controle de Sistemas: Amortecimento em laços de feedback."
                              ],
                              "realWorldApplication": "Em satélites, isoladores com ζ≈0.5 minimizam transmissão de vibrações do lançador (ex: Falcon 9) para equipamentos sensíveis como giroscópios e eletrônicos, garantindo integridade durante acelerações de até 10g e frequências de 20-100 Hz, essencial para missões como James Webb Space Telescope."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.3.3",
                            "name": "Aplicação em estruturas aeroespaciais",
                            "description": "Aplicar conceitos de isolamento para reduzir vibrações em componentes como painéis de aeronaves ou instrumentos sensíveis, calculando redução percentual de transmissão com base em parâmetros reais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão de Conceitos Fundamentais de Isolamento Vibracional em SDOF",
                                  "subSteps": [
                                    "Relembrar a equação de transmissibilidade (TR) para sistemas isolados: TR = |1 / (1 - (ω/ω_n)^2)| onde ω é frequência de excitação e ω_n é frequência natural do isolador.",
                                    "Entender o regime de isolamento: operação ideal quando ω > √2 ω_n para TR <1.",
                                    "Discutir fatores como amortecimento e rigidez do isolador em contextos aeroespaciais.",
                                    "Analisar gráficos de TR vs. razão de frequências para identificar zonas de isolamento.",
                                    "Calcular ω_n a partir de massa m e rigidez k: ω_n = √(k/m)."
                                  ],
                                  "verification": "Resolva 3 problemas simples de TR e confirme que TR diminui em altas frequências.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Livro de dinâmica estrutural (ex: Chopra), calculadora científica, software MATLAB ou Python para plotar curvas TR.",
                                  "tips": "Sempre normalize frequências pela razão r = ω/ω_n para simplificar cálculos.",
                                  "learningObjective": "Compreender matematicamente como o isolamento reduz transmissão de vibrações.",
                                  "commonMistakes": "Confundir TR com amplificação (regime de ressonância) ou ignorar unidades em ω_n."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificação de Componentes Aeroespaciais Críticos para Isolamento",
                                  "subSteps": [
                                    "Listar componentes como painéis de fuselagem, hélices, instrumentos de navegação e antenas satélite.",
                                    "Analisar fontes de vibração: motores, fluxo aerodinâmico, lançamento de foguetes.",
                                    "Avaliar impactos: fadiga estrutural, ruído em cabines, falha em sensores sensíveis.",
                                    "Pesquisar casos reais: vibrações em Boeing 787 ou fairings de SpaceX.",
                                    "Definir requisitos: redução mínima de 80-95% em transmissão para frequências operacionais."
                                  ],
                                  "verification": "Crie um relatório com 5 componentes listados, suas fontes de vibração e impactos potenciais.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Artigos da AIAA ou NASA sobre vibrações aeroespaciais, imagens/diagramas de aeronaves.",
                                  "tips": "Priorize componentes com massas baixas e sensibilidades altas para ganhos rápidos de isolamento.",
                                  "learningObjective": "Reconhecer aplicações práticas de isolamento em estruturas aeroespaciais reais.",
                                  "commonMistakes": "Subestimar vibrações multifrequenciais; focar só em motores, ignorar aeroelásticas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definição de Parâmetros Reais e Modelagem do Sistema Isolado",
                                  "subSteps": [
                                    "Selecionar parâmetros: massa do componente (ex: 10 kg para painel), frequência de excitação (ex: 200 Hz de motor).",
                                    "Escolher isolador: rigidez k para ω_n ≈ ω/5 (ex: k = m ω_n²).",
                                    "Incluir amortecimento realista (ζ=0.05-0.1) e ajustar modelo SDOF.",
                                    "Desenhar diagrama esquemático: base vibrante → isolador → massa.",
                                    "Validar parâmetros com dados reais de catálogos (ex: LORD isoladores aeroespaciais)."
                                  ],
                                  "verification": "Monte um modelo com parâmetros numéricos e calcule ω_n preliminar.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Catálogos de isoladores (LORD, Barry Controls), Excel ou Python para cálculos iniciais.",
                                  "tips": "Use razão r >3 para isolamento efetivo; teste sensibilidade variando m e k.",
                                  "learningObjective": "Modelar sistemas aeroespaciais reais como SDOF com parâmetros autênticos.",
                                  "commonMistakes": "Escolher k muito rígida levando a r<√2; ignorar massa do isolador."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Cálculo da Redução Percentual de Transmissão",
                                  "subSteps": [
                                    "Calcular TR sem isolamento (TR0 ≈1 para base rígida).",
                                    "Computar TR com isolador: TR = √[1 + (2ζr)^2] / |(1-r²)^2 + (2ζr)^2|^{0.5} para força transmissível.",
                                    "Redução % = 100 * (1 - TR/TR0).",
                                    "Iterar para otimizar k e ζ visando >90% redução.",
                                    "Plotar resultados e interpretar para faixas de frequência."
                                  ],
                                  "verification": "Obtenha redução >85% para ω=200 Hz com ω_n=40 Hz.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "MATLAB/Simulink ou Python (SciPy) para simulações, papel para cálculos manuais.",
                                  "tips": "Aproximação para ζ baixo e r>>1: TR ≈ 1/r²; valide com simulação.",
                                  "learningObjective": "Executar cálculos precisos de redução vibracional com parâmetros reais.",
                                  "commonMistakes": "Usar fórmula errada de TR (força vs. movimento); arredondar prematuramente."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validação, Interpretação e Relatório de Aplicação",
                                  "subSteps": [
                                    "Comparar com dados experimentais ou literatura (ex: testes shaker table).",
                                    "Analisar limitações: não-linearidades, multi-DOF reais.",
                                    "Preparar relatório: parâmetros, cálculos, gráficos, recomendações.",
                                    "Simular variação de parâmetros para robustez.",
                                    "Discutir escalabilidade para estruturas complexas."
                                  ],
                                  "verification": "Relatório completo com gráficos mostrando redução >90% e discussões.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Software de plotagem (Matplotlib), templates de relatório LaTeX ou Word.",
                                  "tips": "Inclua análise de sensibilidade para credibilidade profissional.",
                                  "learningObjective": "Interpretar resultados e comunicar aplicações aeroespaciais efetivamente.",
                                  "commonMistakes": "Ignorar efeitos de temperatura/altitude em propriedades do isolador."
                                }
                              ],
                              "practicalExample": "Para um painel de fuselagem de 5 kg em uma aeronave sujeita a vibrações do motor a 150 Hz, instale um isolador com k= 2e5 N/m (ω_n=28 Hz, r=5.4). Calcule TR≈0.035, redução de 96.5%: TR = 1/(r²) ≈1/29.",
                              "finalVerifications": [
                                "Transmissibilidade calculada corretamente <0.1 para r>3.",
                                "Redução percentual >85% confirmada com parâmetros reais.",
                                "Gráficos de TR vs. r mostram zona de isolamento clara.",
                                "Modelo SDOF validado contra aproximações.",
                                "Relatório inclui interpretação física dos resultados.",
                                "Sensibilidade a variações de ±20% em parâmetros testada."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de ω_n, r e TR (erro <5%).",
                                "Seleção adequada de parâmetros reais e realismo do modelo.",
                                "Profundidade na análise de substeps e verificações.",
                                "Clareza nos gráficos e interpretação de resultados.",
                                "Identificação correta de erros comuns e limitações.",
                                "Criatividade em conexões com aplicações aeroespaciais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Solução de equações diferenciais harmônicas e análise assintótica.",
                                "Física: Princípios de dinâmica newtoniana e ondas mecânicas.",
                                "Engenharia de Materiais: Seleção de elastômeros e propriedades viscoelásticas.",
                                "Computação: Simulações numéricas em MATLAB/Python e otimização.",
                                "Design Aeroespacial: Integração com FEM para multi-DOF."
                              ],
                              "realWorldApplication": "Em aeronaves como o Airbus A350, isoladores reduzem vibrações de motores em painéis, prevenindo fadiga e melhorando conforto; em satélites da NASA, protegem giroscópios durante lançamento, garantindo precisão orbital com reduções >95% em transmissões acima de 50 Hz."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.6.3.4",
                            "name": "Análise de limitações do isolamento SDOF",
                            "description": "Discutir limitações como transmissibilidade unitária em r=1 e efeitos em baixas frequências, propondo soluções híbridas para estruturas aeroespaciais complexas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Transmissibilidade e Isolamento SDOF",
                                  "subSteps": [
                                    "Estudar a definição de transmissibilidade (TR) como razão entre força transmitida e força excitante.",
                                    "Derivar a equação de TR para um isolador SDOF sem amortecimento: TR = |1 / (1 - r²)| onde r = ω/ω_n.",
                                    "Analisar o gráfico de TR vs. r, identificando picos em r≈1 e região de isolamento para r>>√2.",
                                    "Discutir o papel do amortecimento viscoso na modificação da curva TR.",
                                    "Calcular TR para cenários específicos de frequências baixas (r<1)."
                                  ],
                                  "verification": "Gerar gráfico de TR vs. r usando software como MATLAB ou Python (Matplotlib) e confirmar picos e comportamentos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de texto de dinâmica (ex: Thomson 'Vibration and Shock Handbook'), software de plotagem (MATLAB/Python), calculadora científica"
                                  ],
                                  "tips": "Comece com equações não amortecidas para simplicidade, depois adicione ζ (fator de amortecimento).",
                                  "learningObjective": "Compreender matematicamente como TR se comporta em isoladores SDOF.",
                                  "commonMistakes": [
                                    "Confundir TR de deslocamento com TR de força; ignorar unidades de frequência."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Limitações Específicas do Isolamento SDOF",
                                  "subSteps": [
                                    "Explicar transmissibilidade unitária ou próxima de 1 em r=1 devido à ressonância.",
                                    "Analisar falta de isolamento em baixas frequências (r<<1, TR≈1), onde vibrações são transmitidas diretamente.",
                                    "Discutir efeitos em estruturas aeroespaciais: fadiga, ruído e falhas em componentes sensíveis como eletrônicos.",
                                    "Quantificar limitações com exemplos numéricos: calcular TR para r=0.5, 1 e 2.",
                                    "Listar limitações adicionais como sensibilidade a variações de massa e não-linearidades."
                                  ],
                                  "verification": "Escrever um relatório curto (1 página) listando 5 limitações com equações e gráficos de suporte.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Artigos sobre vibrações aeroespaciais (ex: NASA reports), papel e lápis para esboços, Excel para cálculos simples"
                                  ],
                                  "tips": "Use analogias como 'amortecedor de carro' para visualizar ressonância em r=1.",
                                  "learningObjective": "Identificar e quantificar limitações chave do isolamento SDOF em contextos reais.",
                                  "commonMistakes": [
                                    "Subestimar impactos em baixas frequências; confundir r com frequência absoluta."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Impactos em Estruturas Aeroespaciais Complexas",
                                  "subSteps": [
                                    "Modelar uma estrutura aeroespacial simples (ex: painel de satélite) como SDOF acoplado.",
                                    "Simular transmissão de vibrações de motores ou lançamentos para r=1 e baixas freq.",
                                    "Avaliar consequências: vibrações excessivas levando a falhas por fadiga ou desalinhamento.",
                                    "Comparar com dados reais de missões espaciais (ex: vibrações em Ariane ou Falcon).",
                                    "Documentar métricas como aceleração RMS transmitida."
                                  ],
                                  "verification": "Executar simulação numérica básica e plotar resposta em frequência.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Software ANSYS ou Simulink para simulação, dados de testes de vibração da NASA/ESA"
                                  ],
                                  "tips": "Foquem em frequências de lançamento típicas (5-50 Hz) para relevância aeroespacial.",
                                  "learningObjective": "Conectar limitações teóricas a problemas práticos em aeroespacial.",
                                  "commonMistakes": [
                                    "Ignorar acoplamentos modais em estruturas reais; usar modelos muito simplificados."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Propor e Avaliar Soluções Híbridas",
                                  "subSteps": [
                                    "Descrever soluções híbridas: combinar isoladores passivos SDOF com ativas (controle piezoelétrico).",
                                    "Integrar múltiplos DOF ou materiais viscoelásticos para baixas frequências.",
                                    "Projetar um sistema híbrido conceitual para estrutura aeroespacial (ex: montagem de payload).",
                                    "Simular performance híbrida vs. SDOF puro, medindo redução em TR.",
                                    "Discutir trade-offs: custo, peso, confiabilidade em vácuo/extremos."
                                  ],
                                  "verification": "Criar diagrama esquemático e tabela comparativa de TR antes/depois.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Literatura sobre controle ativo de vibrações (ex: Preumont 'Vibration Control of Active Structures'), CAD software básico"
                                  ],
                                  "tips": "Priorize soluções leves para aeroespacial; valide com equações de controle PID simples.",
                                  "learningObjective": "Desenvolver propostas inovadoras para superar limitações SDOF.",
                                  "commonMistakes": [
                                    "Propor soluções não viáveis em peso/espaço; negligenciar estabilidade do controle ativo."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um satélite como o Hubble, vibrações de giroscópios em baixa frequência (r<1) causam desalinhamento de espelhos. Uma solução híbrida usa isoladores passivos SDOF para altas freq. + atuadores piezoelétricos ativos para baixas freq., reduzindo TR de 1.2 para 0.3 em r=0.8.",
                              "finalVerifications": [
                                "Explicar corretamente TR unitária em r=1 com equação derivada.",
                                "Identificar pelo menos 3 limitações em baixas frequências com exemplos numéricos.",
                                "Propor uma solução híbrida viável com diagrama.",
                                "Simular e mostrar redução de TR >30% em cenários críticos.",
                                "Discutir 2 trade-offs reais para aeroespacial.",
                                "Gráfico de TR comparativo gerado e analisado."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: 30% (equações e gráficos corretos).",
                                "Profundidade de análise de limitações: 25% (cobertura completa com quantificação).",
                                "Criatividade e viabilidade da solução híbrida: 20%.",
                                "Conexão com aplicações aeroespaciais: 15%.",
                                "Clareza de comunicação (relatório/diagramas): 10%."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Solução de EDOs e análise de Fourier para respostas em frequência.",
                                "Física: Princípios de ondas e ressonância em meios elásticos.",
                                "Engenharia de Materiais: Seleção de viscoelásticos para isoladores híbridos.",
                                "Controle Automático: Feedback ativo para supressão de vibrações."
                              ],
                              "realWorldApplication": "Nas estruturas de lançamento de foguetes como SpaceX Falcon 9, análise de limitações SDOF permite soluções híbridas que reduzem vibrações em payloads sensíveis, prevenindo falhas em missões bilionárias e estendendo vida útil de satélites em órbita."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.3",
                "name": "Sistemas com Múltiplos Graus de Liberdade (MDOF) e Análise Modal",
                "description": "Aborda o cálculo de frequências naturais, ortogonalidade dos modos de vibração, coordenadas naturais e solução por análise modal em sistemas com dois ou mais graus de liberdade.",
                "totalSkills": 44,
                "atomicTopics": [
                  {
                    "id": "10.1.3.1",
                    "name": "Cálculo de Frequências Naturais em Sistemas MDOF",
                    "description": "Métodos para determinar as frequências naturais de vibração em sistemas com dois ou mais graus de liberdade.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.1.1",
                        "name": "Formulação das Equações de Movimento em Sistemas MDOF",
                        "description": "Derivação das equações diferenciais de movimento para sistemas com múltiplos graus de liberdade utilizando princípios variacionais como Lagrange ou matrizes de massa e rigidez.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.1.1",
                            "name": "Derivar equações de Lagrange para sistema com 2 GDL",
                            "description": "Aplicar o princípio de Lagrange para obter as equações de movimento acopladas de um sistema estrutural aeroespacial com dois graus de liberdade, identificando energia cinética e potencial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o sistema físico e selecionar coordenadas generalizadas",
                                  "subSteps": [
                                    "Descreva o sistema com 2 GDL, como duas massas conectadas por molas em um modelo aeroespacial (ex: seção de asa com plunge h(t) e pitch θ(t)).",
                                    "Escolha coordenadas generalizadas q1 = h, q2 = θ, expressando posições x, y, z de massas ou pontos em termos de q1, q2 e tempo.",
                                    "Desenhe um diagrama esquemático mostrando deslocamentos, molas, massas e referências inerciais.",
                                    "Verifique se as coordenadas capturam todos os GDL relevantes e são independentes.",
                                    "Liste premissas: pequenas deformações, linearidade, ausência de forças dissipativas inicialmente."
                                  ],
                                  "verification": "Diagrama completo com posições expressas corretamente em função de q1(t) e q2(t).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis para diagrama",
                                    "Livro de referência (ex: Meirovitch - Principles and Techniques of Vibrations)",
                                    "Software de desenho (opcional, como Draw.io)"
                                  ],
                                  "tips": [
                                    "Use coordenadas que minimizem acoplamento inicial para insight.",
                                    "Garanta ortogonalidade se possível para simplificar."
                                  ],
                                  "learningObjective": "Selecionar coordenadas generalizadas adequadas que descrevam fielmente a cinemática do sistema.",
                                  "commonMistakes": [
                                    "Escolher coordenadas dependentes, violando independência.",
                                    "Ignorar rotações em sistemas com pitch.",
                                    "Confundir coordenadas locais com globais."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a energia cinética total T",
                                  "subSteps": [
                                    "Expresse as velocidades lineares e angulares de cada massa ou elemento em termos de q1_dot, q2_dot.",
                                    "Compute T = ∑ (1/2 m_i v_i² + 1/2 I_i ω_i²), onde v_i e ω_i derivam das coordenadas.",
                                    "Para sistema aeroespacial 2DOF: T = 1/2 m (ḣ + b/2 θ_dot)² + 1/2 I θ_dot² (exemplo plunge-pitch).",
                                    "Expanda os quadrados para identificar termos de massa inercial m11, m12, m22.",
                                    "Verifique simetria da matriz de massa (m12 = m21)."
                                  ],
                                  "verification": "Expressão de T quadrática em q_dot1, q_dot2, com coeficientes corretos e simétricos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Calculadora simbólica (SymPy ou Mathematica)",
                                    "Folha de cálculo para expansão algébrica"
                                  ],
                                  "tips": [
                                    "Use vetores posição r = [x(q), y(q)] para v = dr/dt.",
                                    "Mantenha termos simbólicos até o final."
                                  ],
                                  "learningObjective": "Formular a energia cinética corretamente, revelando acoplamentos inerciais.",
                                  "commonMistakes": [
                                    "Esquecer termos cruzados como ḣ θ_dot.",
                                    "Usar velocidades absolutas em vez de relativas ao referencial.",
                                    "Negligenciar momento de inércia para rotações."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a energia potencial total V",
                                  "subSteps": [
                                    "Identifique fontes de potencial: elástica (molos k), gravitacional (se relevante), aerodinâmica (aproximada).",
                                    "Expresse deformações em termos de q1, q2: ex: δ1 = q1, δ2 = q2 - q1 para molas em série.",
                                    "Compute V = 1/2 ∑ k_i δ_i², expandindo para matriz de rigidez k11, k12, k22.",
                                    "Para aeroespacial: V = 1/2 k_h h² + 1/2 k_θ θ² + k_{hθ} h θ.",
                                    "Confirme que V é quadrática em q1, q2, sem velocidades."
                                  ],
                                  "verification": "V corretamente quadrática em q1 e q2, com matriz de rigidez simétrica.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Referência teórica para potenciais em estruturas",
                                    "SymPy para manipulação simbólica"
                                  ],
                                  "tips": [
                                    "Comece com sistema massa-mola simples para validar.",
                                    "Inclua acoplamento geométrico se aplicável."
                                  ],
                                  "learningObjective": "Modelar energia potencial capturando rigidez e acoplamentos estáticos.",
                                  "commonMistakes": [
                                    "Incluir termos dependentes de velocidades em V.",
                                    "Erro em deformações relativas entre massas.",
                                    "Esquecer acoplamento potencial em sistemas assimétricos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular o Lagrangiano e derivar as equações de movimento",
                                  "subSteps": [
                                    "Defina L = T - V.",
                                    "Para cada qi (i=1,2): compute ∂L/∂q_i_dot, então d/dt(∂L/∂q_i_dot).",
                                    "Compute ∂L/∂q_i = ∂T/∂q_i - ∂V/∂q_i (T geralmente independente de q).",
                                    "Escreva EOM: d/dt(∂L/∂q_i_dot) - ∂L/∂q_i = Q_i (Q_i=0 se conservativo).",
                                    "Reorganize em forma matricial: [M] {q_ddot} + [K] {q} = {Q}.",
                                    "Verifique linearidade e acoplamento."
                                  ],
                                  "verification": "Equações finais acopladas corretas, na forma padrão M q_ddot + K q = 0.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "SymPy ou MATLAB Symbolic para derivadas",
                                    "Papel para validação manual"
                                  ],
                                  "tips": [
                                    "Derive para q1 e q2 separadamente, depois matricialize.",
                                    "Teste com sistema 1DOF conhecido."
                                  ],
                                  "learningObjective": "Aplicar princípio variacional de Lagrange para obter EOM acopladas.",
                                  "commonMistakes": [
                                    "Erro no sinal: L = T - V.",
                                    "Confundir ∂/∂q com ∂/∂q_dot na derivada temporal.",
                                    "Não expandir corretamente d/dt de termos acoplados."
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma seção de asa típica (2DOF): plunge h(t) e pitch θ(t) em torno de elastocenter. Posição do CG: x = x_ac + b (h/b + θ/2), y = h. T = 1/2 m (ḣ)^2 + m x_b b ḣ θ_dot + 1/2 I θ_dot^2. V = 1/2 k_h h^2 + 1/2 k_θ θ^2. Derive EOM mostrando acoplamento inercial m x_b b.",
                              "finalVerifications": [
                                "Energia cinética T é quadrática positiva definida em velocidades.",
                                "Energia potencial V é quadrática positiva definida em deslocamentos.",
                                "Matrizes de massa [M] e rigidez [K] são simétricas.",
                                "Equações de Lagrange reproduzem forma Newton-Euler para caso conhecido.",
                                "Frequências naturais calculadas via det([K] - ω²[M]) = 0 fazem sentido físico.",
                                "Ausência de termos lineares em velocidades (sem amortecimento inicial)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas expressões de T e V (100% coeficientes corretos).",
                                "Corretude das derivadas parciais e temporais (verificação simbólica).",
                                "Forma matricial final clara e acoplada adequadamente.",
                                "Validação com sistema simples (ex: 1DOF reduzido).",
                                "Clareza e organização na derivação passo a passo.",
                                "Identificação de termos de acoplamento e seu significado físico."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e derivadas parciais.",
                                "Física: Mecânica lagrangiana vs. newtoniana.",
                                "Engenharia Computacional: Implementação em FEM ou simulações (MATLAB).",
                                "Controle de Sistemas: Linearização para controlabilidade.",
                                "Aerodinâmica: Inclusão de forças não-conservativas Q_aero."
                              ],
                              "realWorldApplication": "Na análise aeroelástica de asas de aeronaves, derivar EOM 2DOF (plunge-pitch) para prever instabilidades como flutter, essencial para certificação de segurança em projetos da Boeing ou Embraer."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.2",
                            "name": "Montar matrizes de massa [M] e rigidez [K]",
                            "description": "Construir as matrizes simétricas de massa e rigidez para um sistema MDOF a partir do modelo físico, considerando massas concentradas e molas em estruturas como vigas ou painéis aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o modelo físico e graus de liberdade (DOFs)",
                                  "subSteps": [
                                    "Analise o diagrama esquemático da estrutura (ex: viga com massas concentradas e molas).",
                                    "Defina os DOFs principais (ex: deslocamentos verticais em cada massa para movimento flexural).",
                                    "Atribua coordenadas generalizadas (q1, q2, ..., qn) aos DOFs.",
                                    "Liste massas (m_i) e propriedades das molas (k_ij).",
                                    "Desenhe o sistema livre-corpo destacando forças de inércia e elásticas."
                                  ],
                                  "verification": "Crie um esboço do modelo com DOFs numerados e legendas claras; confirme que o número de DOFs corresponde ao tamanho das matrizes esperadas (n x n).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Diagrama da estrutura",
                                    "Papel e lápis ou software de desenho (ex: Draw.io)",
                                    "Referência teórica sobre MDOF"
                                  ],
                                  "tips": "Comece sempre pelo menor número de DOFs possível para validar entendimento antes de sistemas complexos.",
                                  "learningObjective": "Compreender a representação física de um sistema MDOF e mapear DOFs para coordenadas generalizadas.",
                                  "commonMistakes": [
                                    "Confundir DOFs rotacionais com translacionais",
                                    "Ignorar acoplamentos entre DOFs adjacentes",
                                    "Esquecer massas distribuídas aproximadas como concentradas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a matriz de massa [M]",
                                  "subSteps": [
                                    "Inicialize [M] como matriz n x n diagonal ou com termos fora da diagonal se houver acoplamento inercial.",
                                    "Preencha elementos da diagonal: M_ii = soma das massas associadas ao DOF i.",
                                    "Adicione termos fora da diagonal para massas rotacionais ou acopladas: M_ij = integral de ρ φ_i φ_j dV (aproximação para massas concentradas).",
                                    "Para massas concentradas: M_ii = m_i se DOF i corresponde à massa i.",
                                    "Verifique simetria: M_ij = M_ji."
                                  ],
                                  "verification": "Some todos os elementos da matriz [M] e confirme que o traço equals total de massa do sistema.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Planilha ou MATLAB/Python para matrizes",
                                    "Exemplo numérico simples (2 DOFs)",
                                    "Livro de dinâmica estrutural (ex: Clough & Penzien)"
                                  ],
                                  "tips": "Use funções de modo normalizadas (φ_i) se aplicável; teste com sistema 1 DOF para validar.",
                                  "learningObjective": "Montar [M] corretamente refletindo a distribuição inercial do sistema.",
                                  "commonMistakes": [
                                    "Usar massas inconsistentes com DOFs",
                                    "Esquecer fatores de 1/2 em massas rotacionais",
                                    "Não simetrizar a matriz"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a matriz de rigidez [K]",
                                  "subSteps": [
                                    "Inicialize [K] como matriz n x n esparsa.",
                                    "Para molas diretas: K_ii += k_i (rigidez local do DOF i).",
                                    "Para acoplamentos: K_ij -= k_ij (força restauradora entre DOFs i e j).",
                                    "Use diagrama de deformações unitárias: aplique deslocamento unitário em DOF j e calcule forças em i.",
                                    "Confirme simetria e semi-definida positiva."
                                  ],
                                  "verification": "Aplique teste de rigidez: para deslocamento unitário em um DOF, verifique forças esperadas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de álgebra linear (MATLAB ou SymPy)",
                                    "Exemplos de vigas Euler-Bernoulli",
                                    "Calculadora para sistemas pequenos"
                                  ],
                                  "tips": "Desenhe vetores de deslocamento unitário para visualizar acoplamentos.",
                                  "learningObjective": "Derivar [K] a partir de energias potenciais ou forças elásticas.",
                                  "commonMistakes": [
                                    "Sinal errado nos termos fora da diagonal",
                                    "Confundir rigidez com massa",
                                    "Ignorar rigidez geométrica em grandes deslocamentos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e finalizar as matrizes [M] e [K]",
                                  "subSteps": [
                                    "Escreva as matrizes finais em forma matricial.",
                                    "Verifique propriedades: simetria, [M] definida positiva, [K] semi-definida positiva.",
                                    "Calcule autovalores para frequências naturais aproximadas e compare com analítico.",
                                    "Gere código para montar matrizes automaticamente.",
                                    "Documente suposições (ex: massas concentradas, sem amortecimento)."
                                  ],
                                  "verification": "Resolva [K]{q} = λ[M]{q} para modo fundamental e confirme valor físico plausível.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB/Python com eig()",
                                    "Sistema de teste conhecido (ex: 2 massas-spring)"
                                  ],
                                  "tips": "Sempre normalize modos para facilitar comparações.",
                                  "learningObjective": "Garantir integridade das matrizes para análise modal subsequente.",
                                  "commonMistakes": [
                                    "Erros de transcrição numérica",
                                    "Não verificar definitude",
                                    "Matrizes não simétricas devido a erros de sinal"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma viga aeroespacial com 2 massas concentradas (m1=10kg, m2=15kg) conectadas por 3 molas (k1=1000N/m, k2=2000N/m, k3=1500N/m): [M] = diag([10,15]); [K] = [[k1+k2, -k2], [-k2, k2+k3]].",
                              "finalVerifications": [
                                "Matrizes são simétricas e do tamanho correto (n x n).",
                                "Traço de [M] equals massa total.",
                                "Autovalores de [M]^{-1}[K] são positivos reais.",
                                "Teste com deslocamento unitário reproduz forças esperadas.",
                                "Código automatizado gera mesmas matrizes para input padrão.",
                                "Frequências naturais batem com solução analítica para n=2."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de DOFs e propriedades físicas (30%).",
                                "Correção na montagem de [M] e [K], incluindo acoplamentos (40%).",
                                "Validações matemáticas e físicas aplicadas (20%).",
                                "Clareza na documentação e código (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Linear: Operações com matrizes, autovalores e simetria.",
                                "Programação: Implementação em Python/MATLAB para automação FEM.",
                                "Física: Princípios de Lagrange para derivação energética.",
                                "Engenharia de Materiais: Influência de propriedades em k_ij."
                              ],
                              "realWorldApplication": "Em painéis de asas de aeronaves, montar [M] e [K] permite análise modal para prever flutter aeroelástico, evitando falhas catastróficas em voo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.3",
                            "name": "Representar o sistema em forma matricial",
                            "description": "Escrever as equações de movimento na forma [M]{ẍ} + [K]{x} = {0}, verificando propriedades de simetria e positiva definitividade das matrizes para sistemas aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e derivar equações de movimento para sistemas MDOF",
                                  "subSteps": [
                                    "Revise as equações de movimento para sistemas de um grau de liberdade (SDOF) usando o princípio dos trabalhos virtuais ou Lagrangiano.",
                                    "Estenda o conceito para múltiplos graus de liberdade (MDOF), identificando coordenadas generalizadas q_i.",
                                    "Escreva as equações desacopladas na forma ∑ m_{ij} ÿ_j + ∑ k_{ij} y_j = 0 para cada i.",
                                    "Identifique os termos de massa inercial e rigidez elástica.",
                                    "Pratique com um sistema simples de 2 DOF."
                                  ],
                                  "verification": "Escrever corretamente as equações desacopladas para um sistema 2DOF sem erros.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Dinâmica de Estruturas (ex: Clough & Penzien)",
                                    "Papel quadriculado",
                                    "Calculadora"
                                  ],
                                  "tips": "Use notação matricial desde o início para facilitar a transição.",
                                  "learningObjective": "Compreender a origem física das equações de movimento em coordenadas generalizadas.",
                                  "commonMistakes": [
                                    "Confundir termos de massa com rigidez; ignorar acoplamentos entre DOF."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Montar as matrizes de massa [M] e rigidez [K]",
                                  "subSteps": [
                                    "Defina a matriz de massa [M] a partir dos coeficientes m_{ij} das equações desacopladas.",
                                    "Defina a matriz de rigidez [K] a partir dos coeficientes k_{ij}.",
                                    "Verifique que as equações assumem a forma [M]{ÿ} + [K]{y} = {0}.",
                                    "Aplique a um modelo físico aeroespacial, como flexão torsional de uma seção de asa.",
                                    "Escreva explicitamente [M] e [K] para um sistema 2x2."
                                  ],
                                  "verification": "Montar [M] e [K] corretas para um sistema conhecido, confirmando dimensões n x n.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software MATLAB ou Python (NumPy)",
                                    "Exemplos de problemas de vibrações aeroespaciais"
                                  ],
                                  "tips": "Desenhe o sistema esquematicamente para visualizar acoplamentos.",
                                  "learningObjective": "Construir matrizes [M] e [K] a partir de princípios energéticos ou forças.",
                                  "commonMistakes": [
                                    "Erros nos índices das matrizes; esquecer termos de acoplamento."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Escrever o sistema na forma matricial padrão [M]{ẍ} + [K]{x} = {0}",
                                  "subSteps": [
                                    "Substitua {ÿ} por {ẍ} e {y} por {x} para notação padrão em deslocamento.",
                                    "Confirme que o vetor de forças é nulo para sistema livre não amortecido.",
                                    "Escreva a equação vetorial completa para o sistema MDOF.",
                                    "Teste com um exemplo numérico simples, computando elementos matriciais.",
                                    "Documente a forma final em LaTeX ou software de edição."
                                  ],
                                  "verification": "A equação matricial reproduz as equações escalares originais ao expandir.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Editor LaTeX (Overleaf)",
                                    "Folha de exercícios com sistemas MDOF"
                                  ],
                                  "tips": "Use colchetes para matrizes e chaves para vetores consistentemente.",
                                  "learningObjective": "Padronizar a representação matricial para análise modal futura.",
                                  "commonMistakes": [
                                    "Usar notação inconsistente; inverter [M] e [K]."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar propriedades de simetria das matrizes [M] e [K]",
                                  "subSteps": [
                                    "Verifique simetria: confirme que M_{ij} = M_{ji} e K_{ij} = K_{ji} para todo i,j.",
                                    "Justifique fisicamente: simetria surge de conservação de energia e momento.",
                                    "Compute transposições manualmente para matrizes pequenas.",
                                    "Use software para matrizes maiores: if M == M.T.",
                                    "Discuta implicações para autovalores reais."
                                  ],
                                  "verification": "Matrizes [M] e [K] satisfazem M^T = M e K^T = K.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB/Python para transposição",
                                    "Teorema de Maxwell-Betti"
                                  ],
                                  "tips": "Explique violações potenciais em sistemas não conservativos.",
                                  "learningObjective": "Reconhecer simetria como propriedade fundamental em sistemas estruturais.",
                                  "commonMistakes": [
                                    "Assumir simetria sem verificar; confundir com diagonalidade."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar positiva definitividade de [M] e [K]",
                                  "subSteps": [
                                    "Defina positiva definitividade: x^T M x > 0 para todo x ≠ 0, similar para K.",
                                    "Compute todos os menores principais (testes de Sylvester).",
                                    "Verifique autovalores positivos usando software.",
                                    "Interprete fisicamente: massa positiva e rigidez positiva.",
                                    "Aplique a um exemplo aeroespacial e resolva dúvidas."
                                  ],
                                  "verification": "Todos autovalores de [M] e [K] são positivos; testes de menores confirmados.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Eigenvalue solver em MATLAB",
                                    "Tabela de menores principais"
                                  ],
                                  "tips": "Para [K], rigidez zero indica mecanismo instável.",
                                  "learningObjective": "Garantir estabilidade dinâmica via propriedades matriciais.",
                                  "commonMistakes": [
                                    "Confundir positiva definida com semi-definida; erros em autovalores negativos."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma viga em flexão representando uma asa de aeronave com 2 DOF (flexão e torção). Derive [M] = [[m1, m12]; [m12, m2]] e [K] = [[k1, k12]; [k12, k2]] a partir de energias cinética e potencial, escreva [M]{ẍ} + [K]{x} = {0}, verifique simetria (m12=m21) e positiva definitividade (autovalores >0).",
                              "finalVerifications": [
                                "Equações escalares são reproduzidas pela forma matricial.",
                                "[M] e [K] são simétricas (M^T = M, K^T = K).",
                                "Todos autovalores de [M] e [K] são positivos.",
                                "Menores principais confirmam positiva definitividade.",
                                "Aplicação correta a um sistema aeroespacial 2DOF.",
                                "Notação consistente e sem erros dimensionais."
                              ],
                              "assessmentCriteria": [
                                "Correção na montagem de [M] e [K] (peso 30%).",
                                "Verificação precisa de simetria (peso 20%).",
                                "Testes corretos de positiva definitividade (peso 25%).",
                                "Forma matricial padrão escrita adequadamente (peso 15%).",
                                "Justificativa física das propriedades (peso 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: propriedades de matrizes simétricas e autovalores.",
                                "Programação: uso de NumPy/MATLAB para verificações numéricas.",
                                "Física: princípios de conservação de energia em vibrações.",
                                "Engenharia Computacional: preparação para métodos numéricos modais."
                              ],
                              "realWorldApplication": "Na análise modal de estruturas aeroespaciais, como prevenção de flutter em asas de aviões, onde a forma matricial permite computar frequências naturais e modos, essencial para certificação de aeronaves pela ANAC/FAA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.2",
                        "name": "Solução do Problema de Autovalores para Frequências Naturais",
                        "description": "Resolução do problema generalizado de autovalores para determinar as frequências naturais e modos de vibração em sistemas MDOF sem amortecimento.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.2.1",
                            "name": "Formular a equação característica det([K] - ω²[M]) = 0",
                            "description": "Estabelecer e resolver a equação determinantal para um sistema com 2 ou 3 GDL, calculando as raízes ω_n que representam as frequências naturais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Montar as Matrizes de Massa [M] e Rigidez [K] para o Sistema MDOF",
                                  "subSteps": [
                                    "Identifique os graus de liberdade (GDL) do sistema (2 ou 3).",
                                    "Defina as massas concentradas ou distribuídas equivalentes para cada GDL.",
                                    "Construa a matriz de massa [M] diagonal ou acoplada com base nas massas.",
                                    "Determine os coeficientes de rigidez das molas ou elementos elásticos entre GDL.",
                                    "Monte a matriz de rigidez [K] simétrica considerando acoplamentos."
                                  ],
                                  "verification": "Verifique se [M] é simétrica positiva definida e [K] simétrica positiva semi-definida; teste com autovalores positivos para [M].",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel quadriculado, calculadora científica, software como MATLAB ou Python (NumPy) para validação.",
                                  "tips": "Comece com um diagrama esquemático do sistema para visualizar acoplamentos.",
                                  "learningObjective": "Compreender como representar dinamicamente um sistema MDOF em forma matricial.",
                                  "commonMistakes": "Esquecer acoplamentos off-diagonal em [K]; inverter massas entre GDL."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estabelecer a Equação de Movimento Livre Não Amortecido",
                                  "subSteps": [
                                    "Escreva a equação diferencial para cada GDL: m ü + k u = 0.",
                                    "Generalize para vetor de deslocamentos {u} e acelerações {ü}.",
                                    "Formule [M]{ü} + [K]{u} = {0}.",
                                    "Confirme que não há forçamentos externos ou amortecimento.",
                                    "Divida por uma massa de referência se necessário para normalizar."
                                  ],
                                  "verification": "A equação deve ser [M]{ü} + [K]{u} = 0; teste dimensionalmente (força = massa * aceleração).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de anotações, lápis, referências de livros de vibrações (ex: Rao ou Meirovitch).",
                                  "tips": "Use notação consistente: colchetes para matrizes, chaves para vetores.",
                                  "learningObjective": "Dominar a forma padrão da equação de movimento em sistemas MDOF.",
                                  "commonMistakes": "Incluir termos de amortecimento indevidamente; confundir deslocamento com aceleração."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Assumir Solução Harmônica e Derivar a Equação de Autovalores",
                                  "subSteps": [
                                    "Assuma solução {u} = {φ} sen(ωt) ou cos(ωt), onde {φ} é o modo.",
                                    "Calcule aceleração {ü} = -ω² {φ} sen(ωt).",
                                    "Substitua na equação de movimento: [-ω² [M] + [K]] {φ} sen(ωt) = 0.",
                                    "Ignore o fator temporal não nulo: ([K] - ω² [M]) {φ} = 0.",
                                    "Conclua que para soluções não triviais, det([K] - ω² [M]) = 0."
                                  ],
                                  "verification": "A matriz dinâmica [K] - ω² [M] deve levar a determinante zero para autovalores ω².",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Calculadora matricial, MATLAB para simular solução assumida.",
                                  "tips": "Lembre-se: ω é frequência natural angular (rad/s), não Hz.",
                                  "learningObjective": "Entender a origem física da equação característica via separação variáveis.",
                                  "commonMistakes": "Esquecer o sinal negativo na aceleração harmônica; tratar ω como escalar inicial."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Expandir para Sistemas de 2-3 GDL",
                                  "subSteps": [
                                    "Para 2 GDL, escreva explicitamente det([K]_{2x2} - ω² [M]_{2x2}) = 0.",
                                    "Expanda o determinante: (k11 - ω² m11)(k22 - ω² m22) - (k12)^2 = 0.",
                                    "Para 3 GDL, use software ou expansão manual do det 3x3.",
                                    "Identifique raízes ω_n como frequências naturais.",
                                    "Valide com caso conhecido (sistema desacoplado)."
                                  ],
                                  "verification": "Resolva polinômio para ω² > 0 reais; compare com frequências analíticas simples.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Software de álgebra simbólica (SymPy ou MATLAB Symbolic), exemplos resolvidos.",
                                  "tips": "Normalizar [M] para identidade facilita (generalized eigenvalue problem).",
                                  "learningObjective": "Aplicar a equação em problemas concretos de baixa dimensão.",
                                  "commonMistakes": "Erro de sinal em ω²; não verificar simetria das matrizes."
                                }
                              ],
                              "practicalExample": "Considere um sistema de 2 massas m1 = m2 = 1 kg conectadas por molas k1 = k2 = k12 = 1 N/m. Monte [M] = diag(1,1), [K] = [[2,-1],[-1,1]]. Formule det([[2,-1],[-1,1]] - ω² [[1,0],[0,1]]) = (2-ω²)(1-ω²) - 1 = 0, resolvendo ω1² ≈ 0.618, ω2² ≈ 2.382.",
                              "finalVerifications": [
                                "Matrizes [M] e [K] são simétricas e corretamente dimensionadas (nxn para n GDL).",
                                "A equação característica é det([K] - ω² [M]) = 0, com ω² como autovalores.",
                                "Para 2 GDL, polinômio quadrático resolvido corretamente.",
                                "Raízes ω_n são reais e positivas.",
                                "Verificação numérica via software coincide com analítica.",
                                "Modos {φ} não triviais encontrados para cada ω_n."
                              ],
                              "assessmentCriteria": [
                                "Precisão na montagem de [M] e [K] (sem erros dimensionais).",
                                "Correta derivação da equação característica passo a passo.",
                                "Habilidade em expandir determinante para 2-3 GDL.",
                                "Interpretação física das frequências naturais ω_n.",
                                "Uso adequado de ferramentas computacionais para validação.",
                                "Clareza na documentação do processo."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Problema de autovalores generalizados.",
                                "Física Clássica: Vibrações livres harmônicas.",
                                "Programação: Implementação em MATLAB/Python para det().",
                                "Engenharia Mecânica: Análise modal em estruturas."
                              ],
                              "realWorldApplication": "Na aeroelasticidade, essa equação é usada para prever frequências naturais de asas de aeronaves, evitando ressonâncias com turbulência que causam flutter catastrófico, como no caso do Tacoma Narrows Bridge adaptado a estruturas aeroespaciais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.2.2",
                            "name": "Calcular frequências naturais e modos normais",
                            "description": "Resolver numericamente ou analiticamente o problema de autovalores generalizado, obtendo as frequências ω_n e os vetores modais {φ_n} normalizados para sistemas estruturais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular o Problema de Autovalores Generalizado",
                                  "subSteps": [
                                    "Derive a equação de movimento para um sistema MDOF: [M]{¨u} + [C]{˙u} + [K]{u} = {F}.",
                                    "Para análise modal livre não amortecida, simplifique para [M]{¨u} + [K]{u} = 0.",
                                    "Assuma solução harmônica {u} = {φ} sin(ωt), levando ao problema generalizado [K]{φ} - ω²[M]{φ} = 0.",
                                    "Escreva na forma padrão (K - ω²M){φ} = 0 ou reformule como autovalores generalizados.",
                                    "Identifique matrizes de massa [M] e rigidez [K] para o sistema estrutural específico."
                                  ],
                                  "verification": "Confirme que a equação [K]{φ} = ω²[M]{φ} está corretamente formulada e as matrizes [M] e [K] são simétricas positivas definidas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de dinâmica estrutural (ex: Clough & Penzien), papel e lápis ou MATLAB para matrizes simbólicas.",
                                  "tips": "Sempre verifique simetria das matrizes para garantir propriedades ortogonais dos modos.",
                                  "learningObjective": "Compreender a origem matemática do problema de autovalores em sistemas MDOF.",
                                  "commonMistakes": "Confundir [M] e [K] ou esquecer que ω² é o autovalor, não ω."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Resolver Analiticamente para Sistemas Pequenos (2-3 DOF)",
                                  "subSteps": [
                                    "Monte [M] e [K] para um sistema de 2 DOF, como uma viga com duas massas.",
                                    "Calcule o determinante |[K] - ω²[M]| = 0 para encontrar ω²_1 e ω²_2.",
                                    "Para cada ω²_n, resolva ([K] - ω²_n [M]){φ_n} = 0 para obter {φ_n}.",
                                    "Escolha uma componente de {φ_n} arbitrária e normalize escalarmente.",
                                    "Verifique ortogonalidade: {φ_m}^T [M] {φ_n} = 0 para m ≠ n."
                                  ],
                                  "verification": "Os autovalores ω_n² devem ser reais e positivos, e autovetores ortogonais em relação a [M].",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora simbólica ou software como Mathematica/MATLAB, exemplos de problemas resolvidos.",
                                  "tips": "Use expansão de determinantes para sistemas pequenos para praticar.",
                                  "learningObjective": "Dominar solução analítica e propriedades modais básicas.",
                                  "commonMistakes": "Erros em cálculos de determinante ou normalização inconsistente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Solução Numérica para Sistemas Maiores",
                                  "subSteps": [
                                    "Gere matrizes [M] e [K] numéricas para um sistema >3 DOF (ex: malha finita de viga).",
                                    "Use função eig generalizada no MATLAB: [V, D] = eig(K, M) para obter ω² em D e {φ} em V.",
                                    "Ordene os modos por frequência crescente: sort(D) e reordene V.",
                                    "Extraia ω_n = sqrt(diag(D)) e vetores modais {φ_n}.",
                                    "Valide com plot de modos animados ou MAC (Modal Assurance Criterion)."
                                  ],
                                  "verification": "Frequências devem coincidir com solução analítica para sub-sistemas conhecidos.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "MATLAB ou Python (SciPy.linalg.eig), script de exemplo para MDOF.",
                                  "tips": "Condicione as matrizes com cond([M], [K]) < 1e12 para precisão numérica.",
                                  "learningObjective": "Aplicar métodos numéricos eficientes para problemas reais.",
                                  "commonMistakes": "Não ordenar modos ou ignorar problemas de ill-conditioning em [M]."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Normalizar Vetores Modais e Interpretar Resultados",
                                  "subSteps": [
                                    "Normalize cada {φ_n} tal que {φ_n}^T [M] {φ_n} = 1 (normalização em massa).",
                                    "Calcule frequências cíclicas f_n = ω_n / (2π) em Hz.",
                                    "Plote os modos deformados para visualização (ex: deformação nodal).",
                                    "Verifique ortonormalidade: {φ_m}^T [M] {φ_n} = δ_mn e {φ_m}^T [K] {φ_n} = ω_n² δ_mn.",
                                    "Documente os resultados em tabela: ω_n, f_n, {φ_n}."
                                  ],
                                  "verification": "Matriz de massa modal deve ser identidade após normalização.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB para plots modais, template de relatório.",
                                  "tips": "Use normalização em massa para simplificar redução modal posterior.",
                                  "learningObjective": "Garantir propriedades ortogonais para análises avançadas.",
                                  "commonMistakes": "Normalizar em deslocamento unitário ao invés de massa, perdendo ortogonalidade."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Validar os Modos Obtidos",
                                  "subSteps": [
                                    "Substitua {φ_n} e ω_n na equação original: erro < 1e-6.",
                                    "Compare com frequências analíticas ou experimentais conhecidas.",
                                    "Calcule MAC entre modos computados e referência: MAC > 0.95.",
                                    "Analise sensibilidade a perturbações em [M]/[K].",
                                    "Gere relatório com gráficos de frequências e modos."
                                  ],
                                  "verification": "Todos os checks de erro e MAC passam com tolerância numérica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Script de validação MATLAB, dados experimentais de benchmark.",
                                  "tips": "Sempre valide numericamente para detectar modos espúrios.",
                                  "learningObjective": "Desenvolver confiança nos resultados através de verificações robustas.",
                                  "commonMistakes": "Ignorar modos rígidos (ω=0) ou modos locais mal capturados."
                                }
                              ],
                              "practicalExample": "Para uma asa simplificada modelada como viga Euler-Bernoulli com 4 massas puntiformes (4 DOF), monte [M] diagonal 4x4 e [K] tridiagonal, resolva para obter 4 frequências naturais (ex: 5.2 Hz, 12.1 Hz, 28.4 Hz, 45.7 Hz) e plote os modos de flexão.",
                              "finalVerifications": [
                                "Frequências ω_n são reais, positivas e ordenadas crescentemente.",
                                "Vetores modais {φ_n} satisfazem ortonormalidade em [M] e [K].",
                                "Normalização {φ_n}^T [M] {φ_n} = 1 para todos n.",
                                "Verificação residual da equação de autovalores < 1e-8.",
                                "MAC entre modos > 0.99.",
                                "Coincidência com solução analítica para sub-sistema 2 DOF."
                              ],
                              "assessmentCriteria": [
                                "Precisão das frequências calculadas (erro < 1%).",
                                "Correta formulação e implementação do problema generalizado.",
                                "Normalização e ortogonalidade verificadas corretamente.",
                                "Uso eficiente de ferramentas numéricas sem erros de condicionamento.",
                                "Interpretação física dos modos (ex: flexão vs torção).",
                                "Relatório completo com plots e validações."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Problemas de autovalores generalizados e decomposição modal.",
                                "Programação Numérica: Implementação em MATLAB/Python para eig solvers.",
                                "Física de Vibrações: Interpretação de modos em estruturas contínuas.",
                                "Engenharia Computacional: Modelagem por elementos finitos para [M] e [K].",
                                "Estatística: Análise de sensibilidade e MAC para validação."
                              ],
                              "realWorldApplication": "Em projetos aeroespaciais, como análise modal de asas de aeronaves (ex: Boeing 787), para prever flutter aeroelástico, otimizar design contra ressonâncias e certificar fadiga estrutural via normas FAA."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.2.3",
                            "name": "Verificar ortogonalidade dos modos",
                            "description": "Demonstrar a ortogonalidade dos modos de vibração em relação às matrizes [M] e [K], calculando φ_i^T [M] φ_j = 0 e φ_i^T [K] φ_j = 0 para i ≠ j.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Ortogonalidade Modal",
                                  "subSteps": [
                                    "Defina ortogonalidade em análise modal: vetores modais φ_i e φ_j são ortogonais se φ_i^T [M] φ_j = 0 e φ_i^T [K] φ_j = 0 para i ≠ j.",
                                    "Explique o significado físico: modos independentes em termos de massa e rigidez.",
                                    "Revise propriedades dos autovetores generalizados do problema [K]φ = ω²[M]φ.",
                                    "Identifique o papel das matrizes [M] (massa) e [K] (rigidez) na ortogonalidade."
                                  ],
                                  "verification": "Resuma em um parágrafo as definições e propriedades, confirmando com equações chave.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de dinâmica estrutural, notas de aula, calculadora.",
                                  "tips": "Use diagramas para visualizar modos de vibração ortogonais como 'perpendiculares' no espaço modal.",
                                  "learningObjective": "Compreender o conceito teórico de ortogonalidade e sua derivação matemática.",
                                  "commonMistakes": "Confundir ortogonalidade com [M]=[I] ou ignorar a generalidade para [M] não-diagonal."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar Matrizes e Vetores Modais do Sistema",
                                  "subSteps": [
                                    "Obtenha ou monte as matrizes [M] e [K] de um sistema MDOF simples (ex: 2 DOF).",
                                    "Resolva o problema de autovalores para obter frequências ω_i, ω_j e vetores φ_i, φ_j (use software ou manualmente).",
                                    "Normalize os vetores modais se necessário (ex: φ_i^T [M] φ_i = 1).",
                                    "Selecione pares i ≠ j para verificação.",
                                    "Documente todos os valores em uma tabela organizada."
                                  ],
                                  "verification": "Confirme que [K]φ_i = ω_i² [M]φ_i para cada modo, listando valores.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "MATLAB/Python (para autovalores), papel quadriculado, planilha Excel.",
                                  "tips": "Comece com sistema 2x2 para simplicidade; verifique simetria de [M] e [K].",
                                  "learningObjective": "Preparar dados precisos para cálculos de ortogonalidade.",
                                  "commonMistakes": "Usar vetores não-normalizados sem ajuste ou erros na solução de autovalores."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Produtos de Ortogonalidade para [M] e [K]",
                                  "subSteps": [
                                    "Calcule φ_i^T [M] φ_j: multiplique φ_i^T * [M] * φ_j.",
                                    "Calcule φ_i^T [K] φ_j: multiplique φ_i^T * [K] * φ_j.",
                                    "Execute os cálculos matriciais passo a passo (transposta, multiplicação).",
                                    "Registre valores numéricos com precisão (tolerância 10^-6 para zero).",
                                    "Repita para múltiplos pares i,j se aplicável."
                                  ],
                                  "verification": "Os resultados devem ser próximos de zero (ex: |valor| < 10^-10); anote discrepâncias.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software numérico (MATLAB eig, numpy.linalg), calculadora matricial.",
                                  "tips": "Use funções built-in como dot() em Python para evitar erros manuais.",
                                  "learningObjective": "Executar cálculos matriciais precisos para verificar ortogonalidade.",
                                  "commonMistakes": "Erros em transpostas (φ_i^T vs φ_i) ou ordem de multiplicação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resultados e Verificar Propriedades Relacionadas",
                                  "subSteps": [
                                    "Confirme φ_i^T [M] φ_i = 1 e φ_i^T [K] φ_i = ω_i² (ortogonalidade consigo mesmo).",
                                    "Analise se violações indicam erros numéricos ou no modelo.",
                                    "Discuta implicações: redução modal, coordenadas modais.",
                                    "Gere gráfico de modos para visualização qualitativa."
                                  ],
                                  "verification": "Relatório com tabela de resultados e conclusão: 'Ortogonalidade confirmada'.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software de plotagem (MATLAB plotmode), relatório template.",
                                  "tips": "Use tolerâncias numéricas para flutuações de ponto flutuante.",
                                  "learningObjective": "Interpretar resultados e conectar à teoria modal.",
                                  "commonMistakes": "Ignorar auto-ortogonalidade ou atribuir erros numéricos a falhas teóricas."
                                }
                              ],
                              "practicalExample": "Para um sistema 2 DOF com [M] = [[2,0],[0,1]], [K] = [[3, -1],[-1,2]], resolva autovalores: ω1≈0.854, φ1=[0.851;0.526]; ω2≈1.535, φ2=[0.526;-0.851]. Calcule φ1^T [M] φ2 ≈ 1.11e-16 ≈0 e φ1^T [K] φ2 ≈ 2.22e-16 ≈0, confirmando ortogonalidade.",
                              "finalVerifications": [
                                "φ_i^T [M] φ_j = 0 para todo i ≠ j dentro de tolerância numérica.",
                                "φ_i^T [K] φ_j = 0 para todo i ≠ j dentro de tolerância numérica.",
                                "Auto-ortogonalidade: φ_i^T [M] φ_i = 1 e φ_i^T [K] φ_i = ω_i².",
                                "Vetores modais satisfazem equação de autovalores.",
                                "Sem discrepâncias >10^-10 indicando erros de cálculo.",
                                "Relatório inclui tabela de resultados e interpretação."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos matriciais (erro <10^-10).",
                                "Correta preparação e normalização de dados.",
                                "Interpretação física/teórica adequada.",
                                "Uso eficiente de ferramentas numéricas.",
                                "Clareza no relatório e visualizações.",
                                "Identificação de erros comuns e correções."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: produtos escalares generalizados e autovalores.",
                                "Física: princípios de vibração e independência modal.",
                                "Programação: implementação numérica em MATLAB/Python.",
                                "Engenharia Aeroespacial: análise modal de estruturas."
                              ],
                              "realWorldApplication": "Em projetos de asas de aeronaves, verifica-se ortogonalidade para decoplar equações modais, reduzindo complexidade em simulações de flutter e fadiga vibracional, garantindo estabilidade estrutural."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.3",
                        "name": "Aplicações e Exemplos em Estruturas Aeroespaciais",
                        "description": "Aplicação prática dos métodos para calcular frequências naturais em modelos simplificados de asas, fuselagens ou painéis aeroespaciais com 2-3 GDL.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.3.1",
                            "name": "Resolver exemplo de sistema 2 GDL acoplado",
                            "description": "Calcular analiticamente as duas frequências naturais e modos para um sistema massa-mola clássico representando flexão e torção de uma asa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o modelo físico e coordenadas generalizadas",
                                  "subSteps": [
                                    "Desenhe o diagrama esquemático do sistema 2 GDL acoplado representando flexão (h) e torção (θ) de uma asa.",
                                    "Identifique as massas (m_h para flexão, m_θ para torção), rigidezes (k_h, k_θ) e acoplamento (k_{hθ}).",
                                    "Defina as coordenadas generalizadas: h (deslocamento vertical) e θ (rotação angular).",
                                    "Atribua valores numéricos de exemplo: m_h = m_θ = 1 kg, k_h = 4 N/m, k_θ = 4 N·m/rad, k_{hθ} = k_{θh} = 1 N/rad.",
                                    "Escreva as posições de equilíbrio e assuma pequenas deformações lineares."
                                  ],
                                  "verification": "Diagrama completo com coordenadas, massas e rigidezes rotuladas corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora",
                                    "Referência de diagrama de asa acoplada"
                                  ],
                                  "tips": "Use convenções padrão de sinal para h positiva para cima e θ positiva no sentido horário.",
                                  "learningObjective": "Compreender a representação física do acoplamento flexão-torção em estruturas aeroespaciais.",
                                  "commonMistakes": [
                                    "Esquecer o termo de acoplamento k_{hθ}",
                                    "Confundir unidades de rigidez (N/m vs N·m/rad)",
                                    "Não linearizar para pequenas amplitudes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar as equações de movimento",
                                  "subSteps": [
                                    "Use o método de Lagrange: defina energia cinética T = (1/2) m_h ḣ² + (1/2) m_θ (r ḣ + r² θ̇)², onde r é raio de giração.",
                                    "Defina energia potencial V = (1/2) k_h h² + (1/2) k_θ θ² + k_{hθ} h θ.",
                                    "Calcule as equações: d/dt (∂L/∂q̇) - ∂L/∂q = 0 para q = h, θ.",
                                    "Escreva na forma matricial: M {¨q} + K {q} = 0, identificando matrizes M e K.",
                                    "Verifique simetria das matrizes M e K."
                                  ],
                                  "verification": "Equações de movimento na forma padrão M {¨q} + K {q} = 0 com coeficientes corretos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Tabela de identidades de Lagrange"
                                  ],
                                  "tips": "Expanda termos quadráticos cuidadosamente no T para capturar acoplamento inercial se presente.",
                                  "learningObjective": "Dominar a derivação Lagrangiana para sistemas acoplados.",
                                  "commonMistakes": [
                                    "Erro no cálculo de ∂T/∂ḣ ou ∂V/∂θ",
                                    "Omitir acoplamento na energia potencial",
                                    "Não assumir movimento harmônico livre"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular o problema de autovalores",
                                  "subSteps": [
                                    "Assuma solução harmônica {q} = {φ} e^{iωt}, levando a (K - ω² M) {φ} = 0.",
                                    "Escreva as matrizes explícitas: M = [[m_h, 0], [0, m_θ]], K = [[k_h, k_{hθ}], [k_{θh}, k_θ]].",
                                    "Para o exemplo numérico: M = [[1,0],[0,1]], K = [[4,1],[1,4]].",
                                    "Formule a equação característica: det(K - λ M) = 0, onde λ = ω².",
                                    "Expanda o determinante para obter o polinômio quadrático em λ."
                                  ],
                                  "verification": "Matrizes M e K corretas e equação característica polinomial anotada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Papel quadriculado"
                                  ],
                                  "tips": "Confirme que M é diagonal para massas concentradas sem acoplamento inercial.",
                                  "learningObjective": "Entender a formulação matricial do problema modal.",
                                  "commonMistakes": [
                                    "Erro na posição dos termos de acoplamento em K",
                                    "Confundir λ = ω² com ω",
                                    "Determinante incorreto para 2x2"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver para frequências naturais",
                                  "subSteps": [
                                    "Resolva o polinômio: para exemplo, det = (4-λ)^2 - 1 = 0 → λ² - 8λ + 15 = 0.",
                                    "Calcule raízes: λ1 = 3, λ2 = 5 → ω1 = √3 rad/s, ω2 = √5 rad/s.",
                                    "Verifique que frequências são reais e positivas.",
                                    "Ordene ω1 < ω2 como primeira e segunda modos.",
                                    "Discuta ordenação por frequência crescente."
                                  ],
                                  "verification": "Frequências ω1 e ω2 calculadas com valores numéricos precisos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Fórmula quadrática"
                                  ],
                                  "tips": "Use fórmula quadrática: λ = [tr(K/M) ± √(discriminante)] / 2 para insight.",
                                  "learningObjective": "Calcular analiticamente frequências em sistemas 2DOF.",
                                  "commonMistakes": [
                                    "Erro aritmético na resolução quadrática",
                                    "Raízes negativas (indicando instabilidade)",
                                    "Não extrair raiz quadrada para ω"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Determinar os modos normais e interpretar",
                                  "subSteps": [
                                    "Para cada λi, resolva (K - λi M) {φi} = 0 para vetor próprio {φi}.",
                                    "Exemplo: Para λ1=3, [1,1;1,1]{φ}=0 → φ1 = [1, -1]^T; para λ2=5, φ2=[1,1]^T.",
                                    "Normalize os modos (ex: norma euclidiana 1).",
                                    "Interprete: modo 1 (antisimétrico: flexão oposta torção), modo 2 (simétrico).",
                                    "Verifique ortogonalidade: φ1^T M φ2 = 0."
                                  ],
                                  "verification": "Modos φ1 e φ2 corretos, normalizados e ortogonais verificados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Papel para vetores"
                                  ],
                                  "tips": "Escolha componente livre como 1 para simplicidade na normalização.",
                                  "learningObjective": "Extrair e interpretar formas modais físicas.",
                                  "commonMistakes": [
                                    "Vetores próprios incorretos",
                                    "Esquecer normalização ou ortogonalidade",
                                    "Má interpretação física dos modos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para m_h = m_θ = 1 kg, k_h = k_θ = 4, k_{hθ} = 1: ω1 = √3 ≈ 1.732 rad/s (modo antisimétrico φ1 = [1, -1]), ω2 = √5 ≈ 2.236 rad/s (modo simétrico φ2 = [1, 1]). Isso simula uma asa típica onde o modo 1 é torção-flexão destrutiva, risco para flutter.",
                              "finalVerifications": [
                                "Frequências reais e positivas com ω1 < ω2.",
                                "Matrizes M e K simétricas e positivas definidas.",
                                "Modos ortogonais em relação a M: φ1^T M φ2 = 0.",
                                "Solução satisfaz equação (K - ω² M) φ = 0 numericamente.",
                                "Interpretação física coerente com flexão-torção de asa.",
                                "Unidades consistentes em todas as quantidades."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de λ, ω e φ (erro < 1%).",
                                "Correta derivação Lagrangiana e formulação matricial.",
                                "Identificação clara de acoplamentos e seus efeitos nos modos.",
                                "Interpretação física relevante ao contexto aeroespacial.",
                                "Verificações de ortogonalidade e positividez realizadas.",
                                "Apresentação organizada com diagramas e passos sequenciais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (autovalores/vetores próprios).",
                                "Física: Dinâmica clássica e vibrações livres.",
                                "Engenharia Mecânica: Análise modal de estruturas.",
                                "Computação: Preparação para solvers numéricos como MATLAB eig()."
                              ],
                              "realWorldApplication": "Na aeroelasticidade, esse cálculo identifica frequências de flexão-torção em asas de aeronaves, prevendo riscos de flutter (ressonância destrutiva), essencial para certificação de aviões como Boeing 787, onde acoplamentos podem levar a instabilidades catastróficas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.3.2",
                            "name": "Analisar sistema 3 GDL em estruturas aeroespaciais",
                            "description": "Aplicar o método matricial para determinar as três frequências naturais de um modelo com três massas, interpretando relevância para modos de vibração de aeronaves.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir e modelar o sistema físico com 3 graus de liberdade (GDL)",
                                  "subSteps": [
                                    "Desenhe o diagrama esquemático do sistema, representando três massas conectadas por molas e amortecedores, com condições de contorno típicas de estruturas aeroespaciais (ex.: fixo-livre).",
                                    "Identifique os graus de liberdade: deslocamentos verticais das massas m1, m2 e m3.",
                                    "Atribua parâmetros reais: massas (ex.: m1=10kg, m2=15kg, m3=20kg), rigidezes das molas (ex.: k1=1000N/m, k2=800N/m, k3=1200N/m).",
                                    "Defina o sistema de coordenadas e equações de equilíbrio para pequenos deslocamentos.",
                                    "Documente suposições: movimento harmônico livre, sem amortecimento inicial."
                                  ],
                                  "verification": "Verifique se o diagrama inclui todos os elementos (massas, molas, suportes) e se os GDL estão claramente rotulados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel milimetrado, lápis, régua; software de desenho como Draw.io (opcional).",
                                  "tips": "Use dimensões proporcionais para visualizar melhor a estrutura como uma seção de asa de aeronave.",
                                  "learningObjective": "Compreender a representação física de um sistema MDOF e mapear parâmetros para análise modal.",
                                  "commonMistakes": "Esquecer de considerar acoplamento entre massas ou confundir GDL com componentes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir as matrizes de massa [M] e rigidez [K]",
                                  "subSteps": [
                                    "Derive as equações de movimento para cada massa usando o princípio da energia virtual ou Newton-Euler.",
                                    "Monte a matriz de massa [M] diagonal com elementos m1, m2, m3.",
                                    "Monte a matriz de rigidez [K] tridiagonal simétrica, incorporando contribuições de molas adjacentes.",
                                    "Valide simetria e positivos definitos das matrizes.",
                                    "Escreva a equação geral [M]{ü} + [K]{u} = 0."
                                  ],
                                  "verification": "Confirme que [M] é diagonal e [K] simétrica calculando det([K]) > 0 e traços positivos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora científica, planilha Excel ou MATLAB para matrizes.",
                                  "tips": "Anote coeficientes passo a passo para evitar erros aritméticos; teste com sistema 1 GDL conhecido.",
                                  "learningObjective": "Dominar a formulação matricial de sistemas MDOF a partir de modelos físicos.",
                                  "commonMistakes": "Erros nos sinais das rigidezes off-diagonal ou inclusão errada de amortecedores."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver o problema de autovalores para frequências naturais",
                                  "subSteps": [
                                    "Formule a equação padrão |[K] - ω²[M]| = 0 ou resolva o problema generalizado [K]{φ} = ω²[M]{φ}.",
                                    "Calcule o polinômio característico de 3ª ordem e encontre as raízes ω1², ω2², ω3².",
                                    "Determine as frequências naturais f_i = ω_i / (2π) em Hz.",
                                    "Calcule os autovetores (modos) normalizando-os.",
                                    "Use software para validação numérica se manual for complexo."
                                  ],
                                  "verification": "As frequências devem satisfazer ω1 < ω2 < ω3 e somar corretamente pelo teorema de traço.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Software MATLAB/Python (eig() ou numpy.linalg.eig), calculadora para polinômio cúbico.",
                                  "tips": "Para polinômio, use fórmula de Cardano ou solver numérico; normalize modos pela massa.",
                                  "learningObjective": "Aplicar álgebra linear para extrair frequências e modos de vibração.",
                                  "commonMistakes": "Confundir autovalores com frequências angulares ou não normalizar modos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e relevância para estruturas aeroespaciais",
                                  "subSteps": [
                                    "Classifique os modos: 1º (flexão global), 2º (torção), 3º (flexão local).",
                                    "Compare frequências com faixas críticas de aeronaves (ex.: 1-10 Hz para flutter).",
                                    "Discuta implicações: ressonância com turbulência, fadiga estrutural.",
                                    "Sugira modificações (ex.: aumentar rigidez) e reanalise.",
                                    "Relacione com exemplos reais como painéis de fuselagem."
                                  ],
                                  "verification": "Explique verbalmente ou por relatório como cada modo afeta a aeronave.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Gráficos de modos (MATLAB plot), referências de livros de aeroelasticidade.",
                                  "tips": "Visualize modos com animações para melhor compreensão.",
                                  "learningObjective": "Conectar análise modal teórica a falhas dinâmicas em voo.",
                                  "commonMistakes": "Ignorar ordenação crescente de frequências ou superestimar modos sem contexto."
                                }
                              ],
                              "practicalExample": "Em uma seção de asa de aeronave simplificada com três massas (m1=10kg na raiz, m2=15kg intermediária, m3=20kg na ponta) conectadas por vigas com rigidezes k1=1000N/m, k2=800N/m, k3=1200N/m. Calcule ω1≈5 rad/s (flexão), ω2≈12 rad/s (torção), ω3≈20 rad/s (flexão local), identificando risco de ressonância com rajadas de vento a 2Hz.",
                              "finalVerifications": [
                                "As três frequências naturais foram calculadas com precisão numérica <1%.",
                                "Modos de vibração foram plotados e classificados corretamente.",
                                "Matrizes [M] e [K] foram validadas como simétricas e definidas positivas.",
                                "Interpretação inclui pelo menos duas implicações aeroespaciais.",
                                "Resultados foram comparados com solução analítica para sistema similar.",
                                "Relatório resume passos e conclusões de forma clara."
                              ],
                              "assessmentCriteria": [
                                "Precisão na montagem de matrizes (sem erros aritméticos).",
                                "Correção no cálculo de autovalores e autovetores.",
                                "Profundidade na interpretação de modos para vibrações de aeronaves.",
                                "Uso adequado de unidades (rad/s ou Hz) e normalização.",
                                "Criatividade em conexões com aplicações reais.",
                                "Clareza na documentação e visualizações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (autovalores) e polinômios.",
                                "Física: Dinâmica de vibrações e osciladores acoplados.",
                                "Engenharia Mecânica: Análise de elementos finitos (FEM) básica.",
                                "Computação: Programação numérica em MATLAB/Python.",
                                "Aerodinâmica: Interação fluido-estrutura (flutter)."
                              ],
                              "realWorldApplication": "Na certificação de aeronaves como o Boeing 787, análise modal de asas com MDOF previne flutter catastrófico, otimizando massas e rigidezes para evitar ressonâncias com vórtices de esteira durante voo."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.2",
                    "name": "Ortogonalidade dos Modos de Vibração",
                    "description": "Propriedades de ortogonalidade entre os modos normais de vibração em sistemas estruturais MDOF.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.2.1",
                        "name": "Definição e Propriedades Básicas da Ortogonalidade Modal",
                        "description": "Conceitos fundamentais de ortogonalidade entre modos normais de vibração em sistemas MDOF, incluindo a independência modal e as condições matemáticas básicas.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.1.1",
                            "name": "Identificar modos ortogonais em sistemas MDOF",
                            "description": "Reconhecer e definir modos de vibração ortogonais como vetores próprios normalizados que satisfazem condições de perpendicularidade em sistemas estruturais sem amortecimento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Sistemas MDOF e Equações de Movimento",
                                  "subSteps": [
                                    "Estude a equação de movimento para sistemas MDOF sem amortecimento: [M]{ẍ} + [K]{x} = 0.",
                                    "Identifique as matrizes de massa [M] e rigidez [K] em um sistema de 2 ou 3 graus de liberdade.",
                                    "Reformule a equação em forma padrão assumindo solução harmônica {x} = {φ} sin(ωt).",
                                    "Derive a equação de autovalores: ([K] - ω²[M]){φ} = 0.",
                                    "Discuta o significado físico de autovalores (ω²) e autovetores {φ} (modos de vibração)."
                                  ],
                                  "verification": "Resuma em um diagrama as componentes da equação de movimento e identifique [M], [K], ω e {φ}.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Dinâmica de Estruturas (ex: Clough & Penzien)",
                                    "Software MATLAB ou Python para matrizes",
                                    "Folha de papel e calculadora"
                                  ],
                                  "tips": "Comece com um sistema simples de 2 DOF para visualizar as massas e molas.",
                                  "learningObjective": "Compreender a base matemática para análise modal em MDOF.",
                                  "commonMistakes": [
                                    "Confundir [M] com [K]",
                                    "Esquecer a suposição de solução harmônica"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Vetores Próprios e Normalização em Análise Modal",
                                  "subSteps": [
                                    "Calcule autovalores e autovetores para um sistema MDOF de 2 DOF usando det([K] - ω²[M]) = 0.",
                                    "Extraia os modos de vibração {φ₁} e {φ₂} e normalize-os pela massa: {φᵢ}ᵀ[M]{φⱼ} = δᵢⱼ.",
                                    "Verifique a normalização modal: some os elementos ponderados pela massa para obter 1.",
                                    "Compare modos não-normalizados vs. normalizados em termos de amplitude.",
                                    "Implemente o cálculo em software para validar manualmente."
                                  ],
                                  "verification": "Produza matrizes de autovalores/autovetores normalizados para um exemplo dado.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB ou Python (NumPy/SciPy)",
                                    "Exemplos de problemas de sistemas 2-DOF",
                                    "Planilha Excel para cálculos manuais"
                                  ],
                                  "tips": "Use funções como eig() no MATLAB para automação, mas entenda o processo manual.",
                                  "learningObjective": "Dominar o cálculo e normalização de modos como vetores próprios.",
                                  "commonMistakes": [
                                    "Normalizar pela norma euclidiana em vez de massa-ortogonal",
                                    "Ignorar a multiplicidade de autovalores"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Propriedades de Ortogonalidade Modal",
                                  "subSteps": [
                                    "Defina ortogonalidade de massa: {φᵢ}ᵀ[M]{φⱼ} = 0 para i ≠ j.",
                                    "Defina ortogonalidade de rigidez: {φᵢ}ᵀ[K]{φⱼ} = 0 para i ≠ j.",
                                    "Prove matematicamente usando a equação de autovalores para ambos os modos.",
                                    "Calcule os produtos escalares para pares de modos em um exemplo numérico.",
                                    "Discuta implicações: desacoplamento modal na análise de vibrações livres."
                                  ],
                                  "verification": "Demonstre numericamente que dois modos satisfazem ambas as condições de perpendicularidade.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notas de aula sobre análise modal",
                                    "Software para multiplicação de matrizes",
                                    "Gráficos de modos de vibração"
                                  ],
                                  "tips": "Visualize ortogonalidade como vetores perpendiculares em espaço modal.",
                                  "learningObjective": "Reconhecer condições matemáticas e físicas de ortogonalidade.",
                                  "commonMistakes": [
                                    "Confundir ortogonalidade com normalização",
                                    "Aplicar em sistemas com amortecimento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e Verificar Modos Ortogonais em um Sistema Exemplo",
                                  "subSteps": [
                                    "Monte um sistema MDOF realista (ex: viga com 2 massas) e defina [M] e [K].",
                                    "Resolva para modos, normalize e teste ortogonalidade para todos os pares.",
                                    "Identifique modos ortogonais plotando animações de vibração.",
                                    "Compare com modos não-ortogonais (ex: alterando [M]) para contrastar.",
                                    "Documente o processo em um relatório curto com cálculos e plots."
                                  ],
                                  "verification": "Apresente um conjunto completo de modos ortogonais verificados para um sistema dado.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software ANSYS ou MATLAB Vibration Toolbox",
                                    "Exemplo de viga Euler-Bernoulli discreta",
                                    "Ferramentas de plotagem (Matplotlib)"
                                  ],
                                  "tips": "Animações ajudam a 'ver' a perpendicularidade nodal.",
                                  "learningObjective": "Aplicar conceitos para identificar ortogonalidade em prática.",
                                  "commonMistakes": [
                                    "Erros de arredondamento em cálculos numéricos",
                                    "Selecionar modos incorretos"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um sistema de duas massas iguais m conectadas por molas k: [M] = m*I, [K] = k[[2,-1],[-1,1]]. Autovalores ω₁² = 0.5k/m, ω₂² = 1.5k/m. Modos {φ₁} = [1,1]ᵀ/√(2m), {φ₂} = [1,-1]ᵀ/√(2m). Verifique: φ₁ᵀ M φ₂ = 0, φ₁ᵀ K φ₂ = 0.",
                              "finalVerifications": [
                                "Define corretamente modos ortogonais como vetores próprios normalizados.",
                                "Calcula com precisão ortogonalidade de massa e rigidez para pares de modos.",
                                "Normaliza modos corretamente usando matriz de massa.",
                                "Identifica ortogonalidade em sistemas MDOF de 2-3 DOF.",
                                "Explica implicações físicas do desacoplamento modal.",
                                "Demonstra via software e manualmente."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de autovalores/vetores (erro <1%).",
                                "Correta aplicação de normalização modal.",
                                "Verificação explícita de ambas ortogonalidades com produtos escalares zero.",
                                "Clareza na explicação de conceitos e exemplos.",
                                "Uso adequado de ferramentas computacionais.",
                                "Identificação de erros comuns e correções."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Autovalores e ortogonalidade de matrizes.",
                                "Física Clássica: Vibrações harmônicas e princípios variacionais.",
                                "Engenharia Mecânica: Análise de estruturas dinâmicas.",
                                "Computação: Solução numérica de problemas de autovalores.",
                                "Matemática Numérica: Estabilidade e precisão em eigendecomposição."
                              ],
                              "realWorldApplication": "Em aeroelasticidade, identificar modos ortogonais em asas de aeronaves permite análise modal desacoplada para prever flutter e fadiga estrutural, essencial no design de aviões como o Boeing 787."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.2",
                            "name": "Calcular produto escalar modal zero",
                            "description": "Demonstrar que o produto escalar entre modos distintos é zero, utilizando vetores modais φ_i e φ_j para i ≠ j em equações de movimento desacopladas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Equações de Movimento Desacopladas e Vetores Modais",
                                  "subSteps": [
                                    "Relembre as equações de movimento gerais para sistemas MDOF: M ü + K u = 0.",
                                    "Explique o processo de análise modal: assumir solução harmônica u = φ sin(ωt).",
                                    "Derive a equação generalizada: (K - ω² M) φ = 0.",
                                    "Identifique os autovetores φ_i como vetores modais ortogonais.",
                                    "Discuta a importância da ortogonalidade para desacoplamento modal."
                                  ],
                                  "verification": "Escreva as equações desacopladas e liste propriedades dos modos ortogonais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de dinâmica estrutural, papel e caneta, calculadora.",
                                  "tips": "Use notação matricial consistente para evitar confusão entre escalares e vetores.",
                                  "learningObjective": "Compreender a base teórica da ortogonalidade modal em sistemas vibratórios.",
                                  "commonMistakes": "Confundir vetor modal com vetor de deslocamento físico; assumir ortogonalidade sem matriz de massa."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o Produto Escalar Modal",
                                  "subSteps": [
                                    "Defina o produto escalar modal como φ_i^T M φ_j, onde M é a matriz de massa.",
                                    "Explique que para i = j, é a massa modal m_i = φ_i^T M φ_i ≠ 0.",
                                    "Estabeleça que para i ≠ j, φ_i^T M φ_j = 0 (ortogonalidade).",
                                    "Derive brevemente a partir da equação autovalor: φ_j^T (K - ω_j² M) φ_i = 0.",
                                    "Mostre simetria: φ_i^T K φ_j = ω_j² φ_i^T M φ_j = 0."
                                  ],
                                  "verification": "Escreva a definição matemática e prove ortogonalidade para K também.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Folha de anotações, software simbólico como SymPy ou MATLAB.",
                                  "tips": "Lembre-se: ortogonalidade é em relação a M e K, não ao produto euclidiano padrão.",
                                  "learningObjective": "Dominar a definição precisa e propriedades do produto escalar modal.",
                                  "commonMistakes": "Usar produto escalar simples φ_i · φ_j em vez de φ_i^T M φ_j; ignorar normalização."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar e Calcular Produto Escalar para Modos Distintos",
                                  "subSteps": [
                                    "Escolha um sistema exemplo com 2 DOF e calcule matrizes M e K.",
                                    "Resolva o problema de autovalores para obter φ_1 e φ_2.",
                                    "Compute φ_1^T M φ_2 explicitamente, multiplicando matrizes.",
                                    "Verifique numericamente se o resultado é zero (dentro de tolerância numérica).",
                                    "Repita para φ_1^T K φ_2 e confirme consistência."
                                  ],
                                  "verification": "Obtenha valor exato ou próximo de zero para i ≠ j.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora matricial, MATLAB ou Python (NumPy), exemplo de sistema 2 DOF.",
                                  "tips": "Normalizar modos para simplificar cálculos; use precisão dupla em software.",
                                  "learningObjective": "Executar cálculo prático do produto escalar modal.",
                                  "commonMistakes": "Erro de transposição (φ_i M φ_j em vez de φ_i^T); arredondamento levando a valores pequenos não-zero."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar e Verificar Ortogonalidade em Equações Desacopladas",
                                  "subSteps": [
                                    "Substitua u = Σ q_k φ_k nas equações originais.",
                                    "Multiplique por φ_i^T e integre: obtenha equações desacopladas ÿ_i + ω_i² y_i = 0.",
                                    "Mostre que coeficientes cruzados são zero devido a φ_i^T M φ_j = 0.",
                                    "Discuta implicações para análise modal reduzida.",
                                    "Teste com variação de parâmetros do sistema."
                                  ],
                                  "verification": "Derive equações desacopladas sem termos cruzados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel para derivação, software para simulação dinâmica.",
                                  "tips": "Visualize modos com animações para intuição geométrica da ortogonalidade.",
                                  "learningObjective": "Aplicar ortogonalidade para desacoplar equações de movimento.",
                                  "commonMistakes": "Esquecer de premultiplicar por φ_i^T; confundir coordenadas modais com físicas."
                                }
                              ],
                              "practicalExample": "Para um sistema massa-mola 2 DOF com M = [[2,0],[0,1]] kg e K = [[3,-1],[-1,2]] N/m, os modos são φ1 = [1,1]^T / sqrt(2), φ2 = [1,-1]^T / sqrt(2). Calcule φ1^T M φ2 = (1/sqrt(2))[1,1] M [1,-1]^T / sqrt(2) = 0, confirmando ortogonalidade.",
                              "finalVerifications": [
                                "φ_i^T M φ_j = 0 para todo i ≠ j.",
                                "φ_i^T K φ_j = 0 para i ≠ j.",
                                "Massa modal φ_i^T M φ_i > 0.",
                                "Equações desacopladas sem termos cruzados.",
                                "Cálculo numérico dentro de 1e-10 de zero.",
                                "Normalização consistente dos modos."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na definição e derivação.",
                                "Cálculo correto em exemplo numérico.",
                                "Explicação clara da implicação em desacoplamento.",
                                "Identificação de erros comuns e prevenção.",
                                "Uso apropriado de notação matricial.",
                                "Conexão com contexto aeroespacial."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Autovalores e autovetores ortogonais.",
                                "Física: Princípios de vibrações e ondas.",
                                "Engenharia Mecânica: Análise de estruturas dinâmicas.",
                                "Programação: Implementação em MATLAB/Python para análise modal."
                              ],
                              "realWorldApplication": "Em aeroelasticidade, essa ortogonalidade permite desacoplar modos de vibração de asas de aeronaves, facilitando previsão de flutter e fadiga estrutural em projetos da Boeing ou Embraer."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.2.1.3",
                            "name": "Normalizar modos de vibração",
                            "description": "Aplicar normalização modal para que φ_i^T M φ_i = 1 e φ_i^T K φ_i = ω_i², preparando para análise modal em estruturas aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar ortogonalidade modal e propriedades das matrizes M e K",
                                  "subSteps": [
                                    "Relembrar que modos de vibração são autovetores da equação generalizada [K - ω²M]φ = 0",
                                    "Verificar ortogonalidade: φ_i^T M φ_j = 0 e φ_i^T K φ_j = 0 para i ≠ j",
                                    "Calcular escalares modais: α_i = φ_i^T M φ_i e β_i = φ_i^T K φ_i",
                                    "Entender que sem normalização, α_i ≠ 1 e β_i ≠ ω_i²",
                                    "Estudar exemplos de sistemas MDOF simples como vigas ou pêndulos acoplados"
                                  ],
                                  "verification": "Resuma em um parágrafo as propriedades ortogonais e identifique α_i e β_i em um exemplo dado",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Dinâmica de Estruturas (ex: Clough & Penzien)",
                                    "Notas de aula sobre análise modal",
                                    "Software Matlab ou Python com NumPy"
                                  ],
                                  "tips": "Comece com sistemas 2DOF para visualização intuitiva das formas modais",
                                  "learningObjective": "Compreender as propriedades pré-normalização dos modos de vibração",
                                  "commonMistakes": [
                                    "Confundir ortogonalidade com normalização",
                                    "Ignorar que M e K são simétricas positivas definidas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a fórmula de normalização modal",
                                  "subSteps": [
                                    "Partir da condição desejada: φ_i^T M φ_i = 1",
                                    "Definir o vetor normalizado como φ̂_i = φ_i / sqrt(φ_i^T M φ_i)",
                                    "Verificar a segunda condição: φ̂_i^T K φ̂_i = ω_i²",
                                    "Demonstrar matematicamente usando ortogonalidade: φ̂_i^T K φ̂_i = (φ_i^T K φ_i) / (φ_i^T M φ_i) = ω_i²",
                                    "Generalizar para normalização mútua ou outras convenções"
                                  ],
                                  "verification": "Derive a fórmula φ̂_i = φ_i / sqrt(α_i) e prove que β̂_i = ω_i²",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Folha de papel para derivações",
                                    "Calculadora simbólica como SymPy",
                                    "Referência: Chopra - Dynamics of Structures"
                                  ],
                                  "tips": "Use notação matricial consistente e verifique com transposições corretas",
                                  "learningObjective": "Dominar a derivação matemática da normalização",
                                  "commonMistakes": [
                                    "Esquecer a raiz quadrada no denominador",
                                    "Não dividir tanto M quanto K implicitamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar normalização em um sistema numérico",
                                  "subSteps": [
                                    "Escolher um sistema 2DOF com M e K conhecidas e modos φ_i não normalizados",
                                    "Computar α_i = φ_i^T M φ_i",
                                    "Calcular φ̂_i = φ_i / sqrt(α_i)",
                                    "Verificar numericamente φ̂_i^T M φ̂_i ≈ 1 e φ̂_i^T K φ̂_i ≈ ω_i²",
                                    "Implementar em código para automação"
                                  ],
                                  "verification": "Forneça os valores normalizados e mostre que as condições são satisfeitas com erro < 1e-6",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Matlab/Octave script",
                                    "Python com NumPy/SciPy",
                                    "Exemplo de matrizes M = [[2,0],[0,1]], K = [[3, -1],[-1,2]]"
                                  ],
                                  "tips": "Use precisão numérica alta e normalize todos os modos sequencialmente",
                                  "learningObjective": "Executar normalização computacional com precisão",
                                  "commonMistakes": [
                                    "Erro de arredondamento em sqrt",
                                    "Aplicar normalização só para M ignorando K"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e interpretar resultados em contexto aeroespacial",
                                  "subSteps": [
                                    "Analisar impacto na resposta modal: q̈_i + ω_i² q_i = φ̂_i^T F",
                                    "Comparar massas modais generalizadas antes/depois (devem ser 1)",
                                    "Discutir uso em redução modal ou simulações de flutter",
                                    "Testar com modos de uma viga cantilever simulada",
                                    "Documentar processo em relatório curto"
                                  ],
                                  "verification": "Gere gráficos de formas modais normalizadas vs originais e confirme condições",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software ANSYS ou similar para modos reais",
                                    "Template de relatório LaTeX"
                                  ],
                                  "tips": "Sempre plote formas modais para validação visual",
                                  "learningObjective": "Aplicar normalização em cenários práticos de engenharia aeroespacial",
                                  "commonMistakes": [
                                    "Não considerar modos complexos em sistemas não-proporcionais",
                                    "Ignorar normalização em simulações dinâmicas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema 2DOF com M = [[2, 0], [0, 1]], K = [[3, -1], [-1, 2]], modos φ1 = [1, 1]^T (ω1²=1), φ2 = [1, -1]^T (ω2²=3). Compute α1 = φ1^T M φ1 = 3, φ̂1 = [1,1]^T / sqrt(3) ≈ [0.577, 0.577]^T. Verifique φ̂1^T M φ̂1 = 1 e φ̂1^T K φ̂1 = 1.",
                              "finalVerifications": [
                                "φ_i^T M φ_i = 1 para todos os modos",
                                "φ_i^T K φ_i = ω_i² para todos os modos",
                                "Ortogonalidade preservada: φ_i^T M φ_j = 0 (i≠j)",
                                "Formas modais escaladas corretamente em plot",
                                "Massa modal generalizada unitária em equação modal desacoplada",
                                "Código reproduz resultados com erro numérico mínimo"
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (100% correta)",
                                "Correção numérica nos cálculos (erro < 1e-6)",
                                "Clareza na explicação de subpassos",
                                "Adequação de exemplos ao contexto aeroespacial",
                                "Implementação computacional funcional e comentada",
                                "Interpretação correta das implicações práticas"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Normalização de autovetores e produtos internos",
                                "Física: Teoria de vibrações livres e forçadas",
                                "Programação: Manipulação matricial em Python/Matlab",
                                "Engenharia Mecânica: Análise de estruturas dinâmicas",
                                "Controle: Preparação para modos em sistemas de controle ativo"
                              ],
                              "realWorldApplication": "Na análise modal de asas de aeronaves, normalizar modos permite simulações precisas de aeroelasticidade, como previsão de flutter em projetos da Embraer ou Boeing, onde massas modais unitárias facilitam a integração de cargas aerodinâmicas em equações desacopladas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.2",
                        "name": "Ortogonalidade em Matrizes de Massa e Rigidez",
                        "description": "Propriedades de ortogonalidade específicas das matrizes de massa [M] e rigidez [K] com relação aos vetores modais em sistemas MDOF.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.2.1",
                            "name": "Verificar ortogonalidade em massa",
                            "description": "Calcular φ_i^T M φ_j = 0 para i ≠ j, explicando como isso desacopla as equações de movimento em coordenadas modais para vibrações estruturais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Matrizes de Massa e Modos de Vibração",
                                  "subSteps": [
                                    "Estude a equação de movimento para sistemas MDOF: M ü + K u = 0.",
                                    "Identifique a matriz de massa M como simétrica positiva definida.",
                                    "Revise vetores modais φ_i como autovetores da equação generalizada (K - ω² M) φ = 0.",
                                    "Entenda que modos ortogonais satisfazem condições de ortogonalidade.",
                                    "Anote exemplos de sistemas MDOF simples, como uma viga com 2 graus de liberdade."
                                  ],
                                  "verification": "Resuma em um parágrafo os papéis de M e φ_i na análise modal.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Dinâmica de Estruturas (ex: Clough & Penzien)",
                                    "Notas de aula sobre MDOF",
                                    "Calculadora matricial ou MATLAB/Octave"
                                  ],
                                  "tips": "Visualize M como representando inércias distribuídas em estruturas aeroespaciais.",
                                  "learningObjective": "Compreender o contexto matemático da ortogonalidade em vibrações estruturais.",
                                  "commonMistakes": [
                                    "Confundir matriz de massa M com rigidez K",
                                    "Ignorar simetria de M"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Ortogonalidade em Massa Matematicamente",
                                  "subSteps": [
                                    "Escreva a definição: φ_i^T M φ_j = 0 para i ≠ j.",
                                    "Explique φ_i^T como transposta (vetor linha).",
                                    "Discuta por que isso ocorre: modos são autovetores ortogonais em espaço ponderado por M.",
                                    "Derive brevemente a partir da equação modal generalizada.",
                                    "Compare com ortogonalidade em rigidez: φ_i^T K φ_j = 0."
                                  ],
                                  "verification": "Escreva a fórmula e prove para um caso i=j (normalização).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Folha de papel para derivações",
                                    "Software como SymPy para manipulação simbólica"
                                  ],
                                  "tips": "Lembre-se: é produto escalar no espaço inner product <φ_i, φ_j>_M = φ_i^T M φ_j.",
                                  "learningObjective": "Dominar a definição exata e sua origem teórica.",
                                  "commonMistakes": [
                                    "Esquecer o transposto φ_i^T",
                                    "Confundir com produto escalar euclidiano φ_i · φ_j"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar Cálculo Numérico de Ortogonalidade em Massa",
                                  "subSteps": [
                                    "Selecione matriz M (ex: 2x2 diagonal ou full para sistema real).",
                                    "Obtenha vetores modais φ_i e φ_j de análise modal prévia.",
                                    "Calcule M φ_j (multiplicação matricial).",
                                    "Multiplique por φ_i^T (produto vetor-matriz).",
                                    "Verifique se resultado é aproximadamente zero (tolerância numérica 1e-10)."
                                  ],
                                  "verification": "Produza output numérico mostrando φ_i^T M φ_j ≈ 0.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB/Python com NumPy",
                                    "Exemplo de matrizes de um sistema 2DOF"
                                  ],
                                  "tips": "Use funções prontas como dot(phi_i.T, M @ phi_j) no Python.",
                                  "learningObjective": "Executar verificação computacional com precisão.",
                                  "commonMistakes": [
                                    "Erros de indexação em vetores",
                                    "Não normalizar modos antes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar Desacoplamento das Equações em Coordenadas Modais",
                                  "subSteps": [
                                    "Transforme coordenadas: u = Φ q, onde Φ = [φ_1, φ_2, ...].",
                                    "Substitua na equação MDOF: Φ^T M Φ q̈ + Φ^T K Φ q = 0.",
                                    "Use ortogonalidade: Φ^T M Φ = diagonal (m_i δ_ij).",
                                    "Mostre que equações desacoplam em ÿ_i + ω_i² y_i = 0.",
                                    "Discuta benefícios: análise independente por modo."
                                  ],
                                  "verification": "Derive as equações desacopladas em um exemplo 2DOF.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel para derivações matriciais",
                                    "Software para expansão simbólica"
                                  ],
                                  "tips": "Φ^T M Φ é matriz diagonal devido à ortogonalidade.",
                                  "learningObjective": "Conectar verificação ao desacoplamento modal prático.",
                                  "commonMistakes": [
                                    "Esquecer premultiplicação por Φ^T",
                                    "Não reconhecer diagonalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar e Validar em Exemplo Prático",
                                  "subSteps": [
                                    "Monte sistema 2DOF: ex. viga com M = [[2,0],[0,1]], modos φ1=[1,1], φ2=[1,-1] (normalizados).",
                                    "Calcule φ1^T M φ2 explicitamente à mão.",
                                    "Verifique numericamente e interprete desacoplamento.",
                                    "Analise impacto em resposta vibratória.",
                                    "Documente em relatório curto."
                                  ],
                                  "verification": "Relatório com cálculos, resultado zero e equações desacopladas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Calculadora",
                                    "Planilha Excel ou Jupyter Notebook"
                                  ],
                                  "tips": "Para modos exatos, resultado deve ser exatamente zero.",
                                  "learningObjective": "Integrar todos conceitos em aplicação hands-on.",
                                  "commonMistakes": [
                                    "Modos não normalizados levando a valores pequenos mas não zero",
                                    "Erro em multiplicação matricial"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma asa de aeronave modelada como sistema 2DOF (flexão e torção), com M = [[m11, m12], [m21, m22]] obtida de elementos finitos, e modos φ1 = [1, 0.5]^T (flexão), φ2 = [0.5, 1]^T (torção). Calcule φ1^T M φ2 = [1, 0.5] M [0.5; 1] = 0, confirmando desacoplamento para análise de flutter aeroelástica.",
                              "finalVerifications": [
                                "Calcule corretamente φ_i^T M φ_j = 0 para i≠j em exemplo dado.",
                                "Derive equações desacopladas mostrando diagonalidade de Φ^T M Φ.",
                                "Explique verbalmente o papel na análise modal.",
                                "Identifique erros numéricos comuns em verificação.",
                                "Aplique a um sistema 3DOF simples.",
                                "Discuta implicações para vibrações estruturais aeroespaciais."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática no cálculo (erro <1e-12).",
                                "Clareza na derivação do desacoplamento.",
                                "Correta interpretação física (desacoplamento de modos).",
                                "Uso adequado de ferramentas computacionais.",
                                "Identificação de erros comuns e prevenção.",
                                "Conexão com aplicações reais em aeroelasticidade."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Produtos matriciais e autovalores.",
                                "Engenharia Mecânica: Análise de vibrações MDOF.",
                                "Física: Princípios de ortogonalidade em osciladores acoplados.",
                                "Computação: Programação numérica em MATLAB/Python.",
                                "Engenharia Aeroespacial: Modelagem de estruturas flexíveis."
                              ],
                              "realWorldApplication": "Na certificação de aeronaves (ex: Boeing 787), engenheiros verificam ortogonalidade em massa dos modos de uma asa via FEM (NASTRAN) para desacoplar respostas vibratórias, previnindo ressonâncias em flutter e fadiga estrutural durante voo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.2.2.2",
                            "name": "Verificar ortogonalidade em rigidez",
                            "description": "Demonstrar φ_i^T K φ_j = 0 para i ≠ j, relacionando com frequências naturais distintas em problemas de dinâmica aeroespacial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Ortogonalidade Modal",
                                  "subSteps": [
                                    "Defina ortogonalidade em rigidez como φ_i^T K φ_j = 0 para i ≠ j, onde φ_i e φ_j são vetores modais e K é a matriz de rigidez.",
                                    "Explique a relação com o problema de autovalores: (K - ω_i^2 M) φ_i = 0, destacando que modos com frequências distintas (ω_i ≠ ω_j) são ortogonais.",
                                    "Revise matriz de rigidez K para um sistema MDOF simples, como uma viga com 2 graus de liberdade.",
                                    "Discuta implicações em dinâmica aeroespacial, como desacoplamento modal em vibrações estruturais.",
                                    "Identifique pré-requisitos: multiplicação matricial, autovalores e autovetores."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e forneça um exemplo esquemático de K e φ.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro de dinâmica estrutural (ex: Clough & Penzien)",
                                    "Papel e lápis",
                                    "Calculadora matricial"
                                  ],
                                  "tips": "Use notação consistente: sempre especifique i ≠ j para evitar confusão com ortogonalidade em massa.",
                                  "learningObjective": "Compreender a base teórica da ortogonalidade em rigidez e sua ligação com frequências naturais.",
                                  "commonMistakes": [
                                    "Confundir ortogonalidade em rigidez com massa (φ_i^T M φ_j = 0)",
                                    "Ignorar normalização dos modos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar um Exemplo Numérico de Sistema MDOF",
                                  "subSteps": [
                                    "Escolha um sistema 2-DOF: ex., m1 = m2 = 1 kg, k1 = k2 = 1 N/m, k_c = 0.5 N/m.",
                                    "Monte as matrizes M (massa) e K (rigidez): M = diag(1,1), K = [[1.5, -0.5], [-0.5, 1.5]].",
                                    "Resolva o problema generalizado de autovalores para obter ω1, ω2, φ1, φ2 usando software ou manualmente.",
                                    "Normalize os modos (ex: φ_i^T M φ_i = 1).",
                                    "Verifique ω1 ≠ ω2 para garantir ortogonalidade esperada."
                                  ],
                                  "verification": "Apresente as matrizes M, K, frequências e modos calculados com precisão numérica.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software MATLAB/Python (eig)",
                                    "Planilha Excel para matrizes pequenas"
                                  ],
                                  "tips": "Para 2-DOF, resolva analiticamente primeiro para validação: ω^2 = (k_total ± sqrt(...))/m.",
                                  "learningObjective": "Preparar dados numéricos reais para verificação de ortogonalidade.",
                                  "commonMistakes": [
                                    "Erros na montagem de K (sinais errados em acoplamentos)",
                                    "Não normalizar modos antes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e Verificar Ortogonalidade em Rigidez",
                                  "subSteps": [
                                    "Calcule φ1^T K φ2: multiplique transpose(φ1) * K * φ2.",
                                    "Repita para φ2^T K φ1 (deve ser simétrico).",
                                    "Compare o resultado com zero (tolerância numérica ~1e-10).",
                                    "Calcule também φ1^T K φ1 = ω1^2 (propriedade modal) para validação.",
                                    "Registre valores exatos e discuta discrepâncias numéricas."
                                  ],
                                  "verification": "Mostre o produto matricial passo a passo igual a zero (ou próximo).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "MATLAB/Python para multiplicação matricial",
                                    "Papel para passos manuais"
                                  ],
                                  "tips": "Use funções como dot(phi1.T, K @ phi2) no Python para eficiência.",
                                  "learningObjective": "Executar o cálculo de ortogonalidade e interpretar resultados.",
                                  "commonMistakes": [
                                    "Erro de transposição: esquecer ^T",
                                    "Usar modos não normalizados levando a valores não-zero"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Resultados e Relacionar com Dinâmica Aeroespacial",
                                  "subSteps": [
                                    "Explique por que φ_i^T K φ_j = 0 permite desacoplamento das EDOs modais.",
                                    "Relacione com frequências distintas: prove que se ω_i = ω_j, ortogonalidade pode falhar.",
                                    "Discuta aplicações: análise modal de painéis de asas ou fuselagens.",
                                    "Simule variação: altere K para ω_i ≈ ω_j e observe perda de ortogonalidade.",
                                    "Conclua com importância em aeroelasticidade (ex: flutter)."
                                  ],
                                  "verification": "Escreva um relatório curto ligando cálculo à teoria e aplicações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Artigos sobre análise modal aeroespacial",
                                    "Software ANSYS/NASTRAN introdutório"
                                  ],
                                  "tips": "Visualize modos com plots de deformação para intuição.",
                                  "learningObjective": "Conectar verificação matemática a contextos práticos em engenharia aeroespacial.",
                                  "commonMistakes": [
                                    "Ignorar tolerâncias numéricas em software",
                                    "Não relacionar a frequências reais"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema 2-DOF com M = [[1,0],[0,1]], K = [[2,-1],[-1,2]], os modos são φ1 = [1,1]/sqrt(2), φ2 = [1,-1]/sqrt(2), ω1=1, ω2=3. Calcule φ1^T K φ2 = [0.707,0.707] * [[2,-1],[-1,2]] * [0.707,-0.707]^T = 0, confirmando ortogonalidade.",
                              "finalVerifications": [
                                "φ_i^T K φ_j = 0 (numéricamente) para todos i ≠ j.",
                                "Modos normalizados corretamente (φ_i^T M φ_i = 1).",
                                "Frequências naturais distintas calculadas com precisão.",
                                "Cálculos manuais coincidem com software.",
                                "Relatório inclui interpretação física.",
                                "Simulação de variação mostra impacto em ortogonalidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos matriciais (erro < 1e-8).",
                                "Correta montagem de M e K para o exemplo.",
                                "Explicação clara da relação com frequências naturais.",
                                "Identificação de erros comuns e como evitá-los.",
                                "Aplicação contextualizada em aeroespacial.",
                                "Relatório estruturado com visualizações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Linear: autovalores e ortogonalidade de autovetores.",
                                "Física: vibrações harmônicas e equações diferenciais.",
                                "Engenharia Mecânica: análise de elementos finitos (FEM).",
                                "Computação: programação numérica em MATLAB/Python.",
                                "Física Aplicada: aeroelasticidade e estabilidade dinâmica."
                              ],
                              "realWorldApplication": "Em projetos de aeronaves, verifica-se ortogonalidade para desacoplar modos de vibração em análises modais de asas, previnindo ressonâncias que levam a flutter catastrófico, como no caso histórico do Tacoma Narrows Bridge adaptado a estruturas aeroespaciais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.2.2.3",
                            "name": "Derivar condições de ortogonalidade do problema de autovalores",
                            "description": "Derivar matematicamente as propriedades de ortogonalidade a partir da equação generalizada (K - ω²M)φ = 0 para sistemas conservativos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Recordar a equação do problema de autovalores generalizado",
                                  "subSteps": [
                                    "Defina o problema de vibração livre para sistemas MDOF: M ü + K u = 0.",
                                    "Assuma solução harmônica u(t) = φ sin(ωt + θ), levando à equação (K - ω² M) φ = 0.",
                                    "Explique que K e M são matrizes simétricas positivas definidas para sistemas conservativos.",
                                    "Identifique ω² como autovalor e φ como autovetor modal.",
                                    "Escreva a equação em forma padrão: K φ = ω² M φ."
                                  ],
                                  "verification": "Escreva corretamente a equação generalizada e identifique os papéis de K, M, ω² e φ.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Folha de papel, lápis, livro de dinâmica estrutural (capítulo de análise modal).",
                                  "tips": "Sempre normalize a solução assumindo amplitude unitária para simplificar.",
                                  "learningObjective": "Compreender a origem física e matemática da equação de autovalores em vibrações.",
                                  "commonMistakes": "Confundir a equação com o problema padrão de autovalores (sem M); esquecer a dependência em ω²."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escrever equações para dois modos distintos",
                                  "subSteps": [
                                    "Considere dois autovetores φ_i e φ_j com autovalores distintos ω_i² ≠ ω_j².",
                                    "Escreva: (K - ω_i² M) φ_i = 0 e (K - ω_j² M) φ_j = 0.",
                                    "Multiplique a primeira equação à esquerda por φ_j^T: φ_j^T K φ_i - ω_i² φ_j^T M φ_i = 0.",
                                    "Multiplique a segunda à esquerda por φ_i^T: φ_i^T K φ_j - ω_j² φ_i^T M φ_j = 0.",
                                    "Note que, pela simetria de K e M, φ_j^T K φ_i = φ_i^T K φ_j e φ_j^T M φ_i = φ_i^T M φ_j."
                                  ],
                                  "verification": "Escreva as duas equações multiplicadas e destaque a simetria das matrizes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Caderno de exercícios, calculadora simbólica (opcional, como Mathematica ou papel).",
                                  "tips": "Use transposta (^T) consistentemente para escalares resultantes.",
                                  "learningObjective": "Preparar as expressões escalares necessárias para a derivação da ortogonalidade.",
                                  "commonMistakes": "Esquecer a transposta ou assumir K e M não-simétricas; inverter os autovalores."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar as condições de ortogonalidade",
                                  "subSteps": [
                                    "Subtraia as equações multiplicadas: φ_j^T K φ_i - φ_i^T K φ_j = ω_i² φ_j^T M φ_i - ω_j² φ_i^T M φ_j.",
                                    "Pela simetria, o lado esquerdo é zero: 0 = (ω_i² - ω_j²) φ_j^T M φ_i.",
                                    "Como ω_i² ≠ ω_j², conclua φ_j^T M φ_i = 0 (ortogonalidade em M).",
                                    "Repita para ortogonalidade em K: do lado direito similar, φ_i^T K φ_j = 0.",
                                    "Generalize: para i ≠ j, φ_i^T M φ_j = 0 e φ_i^T K φ_j = 0."
                                  ],
                                  "verification": "Mostre matematicamente que ambos os produtos escalares são zero para i ≠ j.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel quadriculado para alinhar equações, referência de álgebra linear.",
                                  "tips": "Fatore (ω_i² - ω_j²) explicitamente para isolar o termo de ortogonalidade.",
                                  "learningObjective": "Derivar rigorosamente as propriedades de ortogonalidade usando simetria e distinção de autovalores.",
                                  "commonMistakes": "Dividir por zero se ω_i² = ω_j² (modos repetidos); ignorar simetria das matrizes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e discutir condições para sistemas conservativos",
                                  "subSteps": [
                                    "Confirme que a derivação requer K e M simétricas (conservatividade: sem amortecimento, energia conservada).",
                                    "Discuta normalização modal: φ_i^T M φ_i = 1, φ_i^T K φ_i = ω_i².",
                                    "Aplique a um exemplo 2DOF simples para validar.",
                                    "Explique implicações: desacoplamento modal nas coordenadas modais.",
                                    "Liste limitações: não vale para modos complexos ou não-conservativos."
                                  ],
                                  "verification": "Aplique a derivação a um sistema 2DOF e compute produtos escalares numericamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software MATLAB/Python para eigensolve (opcional), exemplo numérico impresso.",
                                  "tips": "Use modos normalizados para verificar φ_i^T M φ_j ≈ 0 numericamente.",
                                  "learningObjective": "Entender pré-condições e aplicações práticas da ortogonalidade modal.",
                                  "commonMistakes": "Aplicar derivação a sistemas com amortecimento (C ≠ 0); confundir ortogonalidade com normalização."
                                }
                              ],
                              "practicalExample": "Considere um sistema 2DOF com M = diag(1,1), K = [[2,-1],[-1,2]]. Resolva autovalores: ω1²=1, φ1=[1,1]^T/sqrt(2); ω2²=3, φ2=[1,-1]^T/sqrt(2). Verifique φ1^T M φ2 = 0 e φ1^T K φ2 = 0.",
                              "finalVerifications": [
                                "Derivação escrita completa sem erros algébricos.",
                                "Produtos escalares φ_i^T M φ_j = 0 e φ_i^T K φ_j = 0 para i≠j mostrados.",
                                "Exemplo numérico 2DOF resolvido com verificação numérica.",
                                "Condições de simetria e conservatividade explicitadas.",
                                "Normalização modal demonstrada.",
                                "Implicações para desacoplamento modal explicadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (100% dos passos corretos).",
                                "Uso correto de simetria de matrizes.",
                                "Tratamento de autovalores distintos.",
                                "Aplicação válida a exemplo concreto.",
                                "Explicação clara de pré-condições conservativas.",
                                "Identificação de limitações (ex: modos repetidos)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Problemas de autovalores generalizados e propriedades de simetria.",
                                "Física: Conservação de energia em osciladores acoplados.",
                                "Engenharia Computacional: Implementação de solvers modais em FEM (Finite Element Method).",
                                "Controle de Sistemas: Desacoplamento modal para controle vibracional."
                              ],
                              "realWorldApplication": "Na análise modal de asas de aeronaves, a ortogonalidade permite reduzir o modelo full-order a um conjunto de equações SDOF desacopladas, essencial para prever flutter aeroelástico e otimizar estruturas leves em aviação."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.3",
                        "name": "Aplicações da Ortogonalidade na Análise Modal",
                        "description": "Uso prático das propriedades de ortogonalidade para expansão modal, solução de respostas dinâmicas e modelagem aeroelástica.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.3.1",
                            "name": "Expandir deslocamentos em coordenadas modais",
                            "description": "Expressar o vetor de deslocamento x(t) = Φ q(t), onde Φ contém modos ortogonais, para desacoplar equações em análise modal de estruturas MDOF.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar equações de movimento para sistemas MDOF",
                                  "subSteps": [
                                    "Lembre as equações gerais de movimento: Mẍ + Cẋ + Kx = F(t), onde M, C, K são matrizes de massa, amortecimento e rigidez.",
                                    "Discuta acoplamento nas equações para sistemas com múltiplos graus de liberdade.",
                                    "Identifique a necessidade de desacoplamento para análise simplificada.",
                                    "Revise o problema de autovalores para encontrar frequências e modos naturais.",
                                    "Verifique ortogonalidade inicial das matrizes M e K com os modos."
                                  ],
                                  "verification": "Escreva as EOM acopladas para um sistema 2DOF e identifique termos de acoplamento.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Dinâmica de Estruturas (Clough & Penzien)",
                                    "Matlab ou Python para matrizes"
                                  ],
                                  "tips": "Comece com sistemas simples de 2 DOF para visualizar acoplamento.",
                                  "learningObjective": "Compreender o acoplamento nas EOM de sistemas MDOF e motivação para análise modal.",
                                  "commonMistakes": [
                                    "Confundir EOM livres com forçadas",
                                    "Ignorar propriedades simétricas de M e K"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir matriz de modos modais Φ e suas propriedades de ortogonalidade",
                                  "subSteps": [
                                    "Defina Φ como matriz cujas colunas são os vetores modais φ_i, soluções do problema de autovalores.",
                                    "Estabeleça ortogonalidade: φ_i^T M φ_j = 0 e φ_i^T K φ_j = 0 para i ≠ j.",
                                    "Normalize os modos: φ_i^T M φ_i = 1 (modos generalizados).",
                                    "Discuta completude: qualquer deslocamento x pode ser expandido como combinação linear dos modos.",
                                    "Verifique numericamente para um exemplo 2DOF."
                                  ],
                                  "verification": "Calcule φ_i^T M φ_j para modos de um sistema e confirme nulidade para i≠j.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de análise modal (ANSYS ou Matlab Vibration Toolbox)",
                                    "Folha de cálculo para autovalores"
                                  ],
                                  "tips": "Use decomposição espectral para obter Φ automaticamente.",
                                  "learningObjective": "Dominar propriedades de ortogonalidade dos modos de vibração.",
                                  "commonMistakes": [
                                    "Não normalizar modos",
                                    "Confundir ortogonalidade em M com K"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a expansão modal do vetor de deslocamento",
                                  "subSteps": [
                                    "Expresse x(t) = Φ q(t), onde q(t) é o vetor de coordenadas modais.",
                                    "Justifique pela completude dos modos: x = ∑ φ_i q_i.",
                                    "Discuta premissa de linearidade e pequenos deslocamentos.",
                                    "Escreva as derivadas: ẋ = Φ q̇, ẍ = Φ q̈.",
                                    "Verifique dimensionalidade: x (n x 1) = Φ (n x m) q (m x 1)."
                                  ],
                                  "verification": "Para um sistema conhecido, escreva x(t) em termos de Φ e q(t).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notas de aula sobre análise modal",
                                    "Exemplos resolvidos de MDOF"
                                  ],
                                  "tips": "Visualize Φ como base de rotação para coordenadas modais desacopladas.",
                                  "learningObjective": "Aplicar expansão modal para transformar coordenadas físicas em modais.",
                                  "commonMistakes": [
                                    "Esquecer que Φ tem n linhas e r colunas (r ≤ n)",
                                    "Assumir q(t) = x(t)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Desacoplar as equações de movimento usando coordenadas modais",
                                  "subSteps": [
                                    "Substitua x = Φ q nas EOM: M Φ q̈ + C Φ q̇ + K Φ q = F.",
                                    "Pré-multiplique por φ_k^T: φ_k^T M Φ q̈ + ... = φ_k^T F.",
                                    "Use ortogonalidade para obter m_k q̈_k + c_k q̇_k + k_k q_k = Q_k(t), onde m_k=1, k_k=ω_k².",
                                    "Identifique Q_k(t) = φ_k^T F(t) como força modal.",
                                    "Confirme desacoplamento: equações SDOF independentes."
                                  ],
                                  "verification": "Derive as EOM desacopladas para um sistema 2DOF e resolva uma.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Matlab para simulação modal",
                                    "Problemas de exercício de análise modal"
                                  ],
                                  "tips": "Mantenha normalização para simplificar coeficientes modais.",
                                  "learningObjective": "Derivar e interpretar equações desacopladas em coordenadas modais.",
                                  "commonMistakes": [
                                    "Esquecer pré-multiplicação por φ_k^T",
                                    "Não usar ortogonalidade corretamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma viga bi-suportada com duas massas m1 e m2, calcule modos φ1 = [1,1]^T / √(2m), φ2 = [1,-1]^T / √(2m) (normalizados). Expanda x(t) = φ1 q1(t) + φ2 q2(t). Substitua nas EOM para obter q̈1 + ω1² q1 = Q1(t)/m1 e similar para q2, desacopladas.",
                              "finalVerifications": [
                                "Escreve corretamente x(t) = Φ q(t) e justifica ortogonalidade.",
                                "Deriva EOM desacopladas sem erros matemáticos.",
                                "Calcula forças modais Q_k para uma carga dada.",
                                "Interpreta q_k como amplitudes modais.",
                                "Simula resposta modal em software e compara com física.",
                                "Explica redução dimensional para sistemas grandes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação matemática da expansão modal (80%).",
                                "Compreensão conceitual de desacoplamento (90%).",
                                "Capacidade de aplicar em exemplo numérico (85%).",
                                "Identificação correta de propriedades ortogonais.",
                                "Clareza na derivação das EOM modais.",
                                "Uso adequado de normalização modal."
                              ],
                              "crossCurricularConnections": [
                                "Engenharia de Controle: Transformada modal para desacoplamento em controladores.",
                                "Processamento de Sinais: Análise em componentes principais (PCA similar a modos).",
                                "Engenharia Mecânica: Redução de modelo em simulações FEM.",
                                "Física Quântica: Expansão em autovetores (análoga).",
                                "Inteligência Artificial: Decomposição em modos para redes neurais recorrentes."
                              ],
                              "realWorldApplication": "Na análise aeroelástica de asas de aeronaves, a expansão modal reduz modelos MDOF complexos (milhares de DOF de FEM) a poucas coordenadas modais dominantes, permitindo prever flutter e prever fadiga estrutural em voo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.2.3.2",
                            "name": "Aplicar em respostas a excitações",
                            "description": "Utilizar ortogonalidade para calcular forças modais p_i(t) = φ_i^T f(t) em respostas harmônicas ou arbitrárias em sistemas aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar propriedades de ortogonalidade dos modos de vibração",
                                  "subSteps": [
                                    "Recordar que os modos normais φ_i satisfazem φ_i^T M φ_j = δ_ij e φ_i^T K φ_j = ω_i² δ_ij",
                                    "Explicar a ortogonalidade em termos de decomposição modal da resposta",
                                    "Derivar a importância para decoupling das equações de movimento",
                                    "Identificar como a ortogonalidade permite projeção de forças externas",
                                    "Praticar com matrizes de massa e rigidez de um sistema MDOF simples"
                                  ],
                                  "verification": "Resolver um exercício simples de verificação de ortogonalidade e explicar o resultado",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Dinâmica de Estruturas (ex: Clough & Penzien)",
                                    "Notas de aula sobre análise modal",
                                    "Software MATLAB ou Python para matrizes"
                                  ],
                                  "tips": "Sempre normalize os modos antes de calcular projeções para evitar erros de escala",
                                  "learningObjective": "Compreender as propriedades matemáticas da ortogonalidade que habilitam a análise modal",
                                  "commonMistakes": "Confundir ortogonalidade modal com ortogonalidade vetorial simples sem considerar M e K"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a projeção modal da força de excitação f(t)",
                                  "subSteps": [
                                    "Partir da equação de movimento M ü + C u̇ + K u = f(t)",
                                    "Projetar no modo i: multiplicar por φ_i^T e usar ortogonalidade",
                                    "Obter a equação modal: m_i ü_i + c_i u̇_i + k_i u_i = p_i(t), onde p_i(t) = φ_i^T f(t)",
                                    "Discutir generalização para amortecimento proporcional",
                                    "Implementar numericamente a projeção em um exemplo 2-DOF"
                                  ],
                                  "verification": "Derivar manualmente p_i(t) e validar com código computacional",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Folha de derivação",
                                    "MATLAB/SciPy para simulação modal",
                                    "Exemplos de sistemas aeroespaciais"
                                  ],
                                  "tips": "Use vetores coluna para φ_i e linha para φ_i^T para clareza matricial",
                                  "learningObjective": "Derivar e compreender a força modal p_i(t) = φ_i^T f(t)",
                                  "commonMistakes": "Esquecer de premultiplicar por φ_i^T ou usar modos não normalizados"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular respostas modais para excitações harmônicas",
                                  "subSteps": [
                                    "Assumir f(t) = F cos(ωt), logo p_i(t) = (φ_i^T F) cos(ωt)",
                                    "Resolver a equação modal no estado estacionário: u_i(t) = H_i(ω) p_i(ω)",
                                    "Calcular função de transferência modal H_i(ω) = 1 / (k_i - ω² m_i + i ω c_i)",
                                    "Superpor respostas modais para obter u(t) = Σ φ_i u_i(t)",
                                    "Plotar respostas e analisar ressonâncias"
                                  ],
                                  "verification": "Comparar resposta modal com solução full-order para validar",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de simulação (MATLAB Vibration Toolbox)",
                                    "Dados de uma viga cantilever simulando asa"
                                  ],
                                  "tips": "Verifique unidades consistentes em frequências e amplitudes",
                                  "learningObjective": "Aplicar cálculo de p_i(t) em excitações harmônicas e obter respostas",
                                  "commonMistakes": "Ignorar fase na resposta harmônica ou superposição incorreta de modos"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estender para excitações arbitrárias e validar aplicação",
                                  "subSteps": [
                                    "Para f(t) arbitrária, calcular p_i(t) = φ_i^T f(t) ponto a ponto ou via FFT",
                                    "Integrar numericamente as equações modais (Newmark ou modo state-space)",
                                    "Comparar com simulação temporal full-order",
                                    "Analisar contribuição de cada modo na resposta total",
                                    "Aplicar a um caso aeroespacial real, como excitação gust em painel"
                                  ],
                                  "verification": "Gerar gráficos de u(t) modal vs. físico com erro <1%",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código Python/MATLAB pronto para MDOF",
                                    "Dados experimentais de aeroelasticidade"
                                  ],
                                  "tips": "Use Duhamel integral para intuição em respostas transitórias",
                                  "learningObjective": "Generalizar o uso de p_i(t) para qualquer excitação em contextos aeroespaciais",
                                  "commonMistakes": "Subestimar truncagem modal (sempre incluir >95% massa modal)"
                                }
                              ],
                              "practicalExample": "Em uma asa simplificada modelada como viga com 3 DOF, excitada por força aerodinâmica harmônica f(t) = [0, 50 cos(10t), 0]^T N. Modos φ1 = [0.3, 1, 0.7]^T, φ2 = [-1, 0, 1]^T normalizados. Calcule p1(t) = φ1^T f(t) = 50 cos(10t) N e resolva u1(t), contribuindo para resposta em flexão.",
                              "finalVerifications": [
                                "Cálculo correto de p_i(t) para excitação dada coincide com referência",
                                "Respostas modais somadas reproduzem solução full-order com erro <0.5%",
                                "Identificação de modo dominante em ressonância",
                                "Gráficos de p_i(t) e u_i(t) mostram comportamento físico coerente",
                                "Explicação verbal da redução dimensional via modais",
                                "Validação numérica com diferentes truncagens modais"
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de p_i(t) (100% corretude)",
                                "Eficiência computacional demonstrada (tempo de simulação modal vs full)",
                                "Interpretação física das forças modais e respostas",
                                "Capacidade de generalizar para novos sistemas aeroespaciais",
                                "Qualidade de visualizações e análise de erros",
                                "Criatividade em aplicações práticas propostas"
                              ],
                              "crossCurricularConnections": [
                                "Análise de Vibrações e Controle Ativo de Estruturas",
                                "Dinâmica de Fluidos Computacional (CFD) para forças aerodinâmicas",
                                "Simulações Numéricas e Programação (MATLAB/Python)",
                                "Engenharia Aeroespacial: Flutter e Aeroelasticidade",
                                "Matemática Aplicada: Álgebra Linear e Transformadas"
                              ],
                              "realWorldApplication": "Na certificação de aeronaves, projeta-se cargas aerodinâmicas (gust, turbulence) nos modos estruturais para prever fadiga e flutter, otimizando design de asas e fuselagens em simuladores como NASTRAN ou ZAERO."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.2.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.3",
                    "name": "Coordenadas Naturais (Modais)",
                    "description": "Definição e uso de coordenadas modais para representar o movimento em termos dos modos de vibração.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.3.1",
                        "name": "Definição de Coordenadas Modais",
                        "description": "Conceito fundamental das coordenadas naturais ou modais, que representam o movimento de um sistema MDOF como uma combinação linear dos modos de vibração naturais.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.1.1",
                            "name": "Definir coordenadas modais",
                            "description": "Explicar a definição de coordenadas modais como as amplitudes generalizadas associadas a cada modo de vibração natural em sistemas com múltiplos graus de liberdade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Sistemas com Múltiplos Graus de Liberdade (MDOF) e Modos de Vibração",
                                  "subSteps": [
                                    "Definir MDOF como sistemas com mais de um grau de liberdade, como edifícios ou asas flexíveis.",
                                    "Derivar as equações de movimento acopladas usando princípios de Lagrange ou Newton.",
                                    "Identificar frequências naturais (ω_n) e vetores modais (φ) resolvendo o problema de autovalores [M]{φ} = (1/ω²)[K]{φ}."
                                  ],
                                  "verification": "Escrever as equações de movimento para um sistema MDOF de 2 DOF e listar suas frequências e modos naturais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Dinâmica de Estruturas (ex: Clough & Penzien), MATLAB ou Python para autovalores"
                                  ],
                                  "tips": "Use animações GIF de modos de vibração para visualizar o movimento nodal.",
                                  "learningObjective": "Entender a base matemática dos modos naturais em sistemas MDOF.",
                                  "commonMistakes": "Confundir modos naturais com frequências de excitação externa."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Coordenadas Generalizadas",
                                  "subSteps": [
                                    "Explicar coordenadas generalizadas (q_i) como variáveis independentes que descrevem o estado do sistema via função de Lagrange L = T - V.",
                                    "Mostrar como coordenadas generalizadas desacoplam equações em alguns casos, reduzindo complexidade.",
                                    "Discutir amplitudes generalizadas como coeficientes que escalam os modos."
                                  ],
                                  "verification": "Reescrever as equações de movimento de um sistema MDOF em termos de coordenadas generalizadas q(t).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Notas de Mecânica Analítica, software simbólico como SymPy"
                                  ],
                                  "tips": "Comece com um sistema de 1 DOF para contrastar com MDOF.",
                                  "learningObjective": "Dominar o conceito de generalização de coordenadas para vibrações.",
                                  "commonMistakes": "Assumir que coordenadas generalizadas são sempre cartesianas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Especificamente Coordenadas Modais",
                                  "subSteps": [
                                    "Definir coordenadas modais η_i(t) como as amplitudes generalizadas associadas ao i-ésimo modo: {x} = [Φ]{η}, onde [Φ] é a matriz modal.",
                                    "Explicar que cada η_i representa a contribuição do modo i na resposta total.",
                                    "Derivar as equações desacopladas: m_i η̈_i + k_i η_i = Q_i(t), com m_i = φ_i^T M φ_i."
                                  ],
                                  "verification": "Escrever a transformação modal {x} = [Φ]{η} e listar as propriedades ortogonais dos modos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Artigo sobre análise modal, calculadora matricial ou MATLAB"
                                  ],
                                  "tips": "Normalize os modos para φ_i^T M φ_j = δ_ij para simplificar.",
                                  "learningObjective": "Definir precisamente coordenadas modais como amplitudes modais generalizadas.",
                                  "commonMistakes": "Confundir coordenadas modais com os vetores modais em si."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Aplicar a Definição em um Exemplo Simples",
                                  "subSteps": [
                                    "Aplicar a definição a um sistema de 2 massas-spring: calcular [Φ] e expressar x1, x2 em termos de η1, η2.",
                                    "Simular numericamente a resposta usando coordenadas modais.",
                                    "Comparar resposta modal com resposta física para validar."
                                  ],
                                  "verification": "Resolver um problema numérico e plotar modos separados vs. resposta acoplada.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "MATLAB/Simulink para simulação, planilha Excel para cálculos manuais"
                                  ],
                                  "tips": "Use massas iguais e rigidezes simétricas para modos simétricos/antissimétricos claros.",
                                  "learningObjective": "Aplicar coordenadas modais para desacoplar vibrações.",
                                  "commonMistakes": "Esquecer normalização modal, levando a massas generalizadas erradas."
                                }
                              ],
                              "practicalExample": "Em uma viga cantilever modelada com 2 DOF (translação e rotação na ponta), as coordenadas modais η1 e η2 capturam o primeiro modo flexural (η1 alto, η2 baixo) e o segundo modo torsional, permitindo análise separada de flutter aeroelástico.",
                              "finalVerifications": [
                                "Explicar verbalmente coordenadas modais como amplitudes generalizadas por modo.",
                                "Derivar {x} = [Φ]{η} para um sistema 2 DOF.",
                                "Identificar equações desacopladas em coordenadas modais.",
                                "Diferenciar coordenadas modais de coordenadas físicas.",
                                "Aplicar em um exemplo com números: calcular η para dada {x}."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição: associa corretamente a modos naturais (90%+).",
                                "Correção matemática: derivação de transformação modal sem erros.",
                                "Compreensão conceitual: explica desacoplamento e ortogonalidade.",
                                "Aplicação prática: resolve exemplo numérico corretamente.",
                                "Clareza na comunicação: usa terminologia técnica adequada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (autovalores, diagonalização).",
                                "Física: Mecânica vibratória e ondas estacionárias.",
                                "Engenharia Mecânica: Análise de estruturas e controle ativo.",
                                "Computação: Métodos numéricos e simulações FEM (Finite Element Method).",
                                "Aeroespacial: Aeroelasticidade e estabilidade de flight."
                              ],
                              "realWorldApplication": "Na análise de asas de aeronaves, coordenadas modais desacoplam as equações de movimento estrutural-aerodinâmico, permitindo prever instabilidades como flutter e otimizar designs para missões espaciais ou aviões comerciais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.2",
                            "name": "Interpretar representação modal do deslocamento",
                            "description": "Descrever como o vetor de deslocamentos físicos {x} é expresso como {x} = [Φ] {q}, onde [Φ] é a matriz de modos e {q} o vetor de coordenadas modais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes básicos da representação modal",
                                  "subSteps": [
                                    "Defina o vetor de deslocamentos físicos {x} como um vetor que representa as deslocações em todos os graus de liberdade (DOF) do sistema.",
                                    "Explique a matriz de modos [Φ] como uma matriz cujas colunas são os vetores modais (modos normais) obtidos da análise modal.",
                                    "Descreva o vetor de coordenadas modais {q} como as amplitudes generalizadas que descrevem a contribuição de cada modo ao movimento total.",
                                    "Revise o conceito de graus de liberdade múltiplos (MDOF) em estruturas aeroespaciais.",
                                    "Identifique como {x}, [Φ] e {q} interagem na equação de transformação modal."
                                  ],
                                  "verification": "Liste corretamente as definições de {x}, [Φ] e {q} e esboce um diagrama simples mostrando sua relação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de dinâmica de estruturas (ex: Clough & Penzien), notas de aula sobre análise modal, calculadora.",
                                  "tips": "Use analogias como 'modos' sendo 'padrões de dança' independentes que combinam para formar o movimento total.",
                                  "learningObjective": "Entender os significados físicos e matemáticos dos componentes da equação modal.",
                                  "commonMistakes": "Confundir [Φ] com a matriz de massa ou rigidez; assumir que {q} representa deslocamentos físicos diretos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar e interpretar a equação {x} = [Φ] {q}",
                                  "subSteps": [
                                    "Comece com a solução geral da equação de movimento desacoplada nos modos normais.",
                                    "Mostre matematicamente como a superposição linear de modos leva à equação {x} = [Φ] {q}.",
                                    "Interprete que cada coluna de [Φ] escalada por q_i contribui para o deslocamento total.",
                                    "Discuta ortogonalidade dos modos: [Φ]^T [M] [Φ] = diagonal.",
                                    "Escreva a equação em componentes: x_i = sum(Φ_{i j} q_j) para i=1 a n DOF."
                                  ],
                                  "verification": "Derive a equação passo a passo em um papel e explique verbalmente o papel de cada termo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta, software MATLAB ou Python para visualizar matrizes, vídeo tutorial sobre análise modal.",
                                  "tips": "Pense na equação como uma 'mudança de base': de coordenadas físicas para modais, similar a coordenadas polares em 2D.",
                                  "learningObjective": "Dominar a derivação e interpretação conceitual da transformação modal.",
                                  "commonMistakes": "Esquecer que [Φ] é ortogonal em relação à massa; tratar modos como acoplados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a equação em um exemplo numérico simples",
                                  "subSteps": [
                                    "Considere um sistema MDOF com 2 DOF: defina matrizes de massa [M] e rigidez [K].",
                                    "Calcule autovalores e autovetores para obter [Φ].",
                                    "Dado {q} = [q1; q2], compute {x} = [Φ] {q} numericamente.",
                                    "Plote {x} para diferentes {q}, mostrando contribuição modal.",
                                    "Verifique normalização: confirme que os modos estão mass-normalizados."
                                  ],
                                  "verification": "Resolva o exemplo numérico e compare resultados com software; o erro deve ser <1%.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB/Python com NumPy/SciPy, planilha Excel para cálculos manuais, exemplo de viga de 2 DOF.",
                                  "tips": "Comece com n=2 DOF para simplicidade; use cores diferentes para plotar contribuições de cada modo.",
                                  "learningObjective": "Executar cálculos práticos para visualizar a representação modal.",
                                  "commonMistakes": "Erro em normalização dos modos; inverter ordem das colunas de [Φ]."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar implicações em dinâmica aeroespacial",
                                  "subSteps": [
                                    "Relacione com aeroelasticidade: como modos modais afetam flutter em asas.",
                                    "Discuta redução modal: truncar modos de alta frequência.",
                                    "Explique como {q} evolui no tempo via equações desacopladas.",
                                    "Compare com coordenadas físicas: vantagens da representação modal.",
                                    "Identifique aplicações em simulações de estruturas de aeronaves."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo 3 implicações aeroespaciais e justifique com a equação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Artigos sobre análise modal em asas (ex: NASA reports), simulador ANSYS ou NASTRAN básico.",
                                  "tips": "Ligue à resposta em frequência: picos modais em curvas de flutter.",
                                  "learningObjective": "Conectar a teoria à prática em engenharia aeroespacial.",
                                  "commonMistakes": "Ignorar efeitos de amortecimento; superestimar precisão com poucos modos."
                                }
                              ],
                              "practicalExample": "Em uma asa de aeronave modelada com 4 DOF (flexão e torção), a matriz [Φ] (4x4) tem colunas como [0.1; 0.8; 0.2; 0.9] para o primeiro modo de flexão. Para {q} = [1; 0.5; 0; 0], compute {x} = [Φ] {q}, resultando em deslocamentos dominados pelo primeiro modo, simulando vibração em voo.",
                              "finalVerifications": [
                                "Derivar corretamente {x} = [Φ] {q} a partir de princípios modais.",
                                "Interpretar numericamente um exemplo com 3 DOF.",
                                "Explicar ortogonalidade e normalização de [Φ].",
                                "Identificar contribuições modais em um gráfico de deslocamento.",
                                "Discutir limitações como truncamento modal.",
                                "Aplicar a um contexto aeroespacial simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação da equação (90% correto).",
                                "Compreensão conceitual: explicar significado físico sem erros.",
                                "Habilidade computacional: cálculos numéricos exatos.",
                                "Profundidade de interpretação: ligar a aplicações reais.",
                                "Clareza na comunicação: diagramas e explicações concisas.",
                                "Identificação de erros comuns e como evitá-los."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Linear: autovalores, autovetores e diagonalização.",
                                "Física: superposição de movimentos harmônicos independentes.",
                                "Programação: implementação em Python/MATLAB para análise modal.",
                                "Engenharia Mecânica: vibrações e controle ativo.",
                                "Aerodinâmica: interação modal com cargas fluidas em flutter."
                              ],
                              "realWorldApplication": "Na certificação de aeronaves, engenheiros usam essa representação para simular respostas modais a turbulência, prevendo instabilidades como flutter divergente em asas de aviões comerciais, otimizando design para segurança e eficiência."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.3",
                            "name": "Identificar vantagens das coordenadas modais",
                            "description": "Listar e justificar as vantagens das coordenadas modais, como simplificação das equações de movimento e decoplamento em sistemas não amortecidos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar equações de movimento em coordenadas físicas",
                                  "subSteps": [
                                    "Estude a forma geral das equações de movimento para sistemas MDOF: [M]{¨x} + [C]{˙x} + [K]{x} = {F}.",
                                    "Identifique os desafios em coordenadas físicas: acoplamento entre graus de liberdade devido a [M], [C] e [K] não diagonais.",
                                    "Analise um exemplo simples de 2 DOF para visualizar o acoplamento nas equações.",
                                    "Discuta limitações em sistemas não amortecidos (C=0), onde o acoplamento persiste em [M] e [K].",
                                    "Registre as principais dificuldades: resolução complexa e simulações computacionais intensivas."
                                  ],
                                  "verification": "Escreva as equações acopladas para um sistema 2 DOF e destaque termos de acoplamento.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Dinâmica de Estruturas (ex: Clough & Penzien)",
                                    "Software MATLAB ou Python para matrizes",
                                    "Papel e caneta para derivação"
                                  ],
                                  "tips": "Comece com sistemas pequenos (2-3 DOF) para visualizar o acoplamento antes de generalizar.",
                                  "learningObjective": "Compreender por que as coordenadas físicas levam a equações acopladas e complexas.",
                                  "commonMistakes": [
                                    "Ignorar o papel do amortecimento no acoplamento",
                                    "Confundir coordenadas físicas com modais prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir transformação para coordenadas modais",
                                  "subSteps": [
                                    "Defina as coordenadas modais usando os vetores modais {Φ} da análise modal: {x} = [Φ]{q}.",
                                    "Derive a transformação das equações: premultiplicar por [Φ]^T para obter [¨q] + [Ω^2]{q} = {Q} em sistemas não amortecidos.",
                                    "Explique como [Φ]^T[M][Φ] = [I] (massa unitária) e [Φ]^T[K][Φ] = [Ω^2] (diagonal).",
                                    "Verifique ortogonalidade dos modos para sistemas não amortecidos.",
                                    "Pratique a transformação em um exemplo numérico simples."
                                  ],
                                  "verification": "Transforme manualmente as equações de um sistema 2 DOF para modais e confirme diagonalização.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Planilhas MATLAB com funções eig()",
                                    "Exemplos resolvidos de análise modal",
                                    "Calculadora matricial online"
                                  ],
                                  "tips": "Use propriedades de ortogonalidade para simplificar cálculos: memorize [Φ]^T[M][Φ] = I.",
                                  "learningObjective": "Dominar a transformação matemática que leva ao decoplamento modal.",
                                  "commonMistakes": [
                                    "Esquecer de normalizar os modos para massa unitária",
                                    "Aplicar transformação em sistemas amortecidos sem Rayleigh"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Listar e justificar vantagens principais",
                                  "subSteps": [
                                    "Vantagem 1: Decoplamento - cada modo vibra independentemente, simplificando solução.",
                                    "Vantagem 2: Simplificação computacional - reduz de N equações acopladas para N independentes.",
                                    "Vantagem 3: Interpretação física intuitiva - modos representam comportamentos naturais da estrutura.",
                                    "Vantagem 4: Redução de modelo - truncar modos de alta frequência para análise eficiente.",
                                    "Vantagem 5: Facilita análise de aeroelasticidade (ex: flutter modal).",
                                    "Justifique cada uma com fórmulas: de [M]{¨x} + [K]{x} = 0 para ¨q_r + ω_r² q_r = 0."
                                  ],
                                  "verification": "Crie uma tabela comparando coordenadas físicas vs modais com pelo menos 5 vantagens justificadas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Artigos sobre análise modal em aeroelasticidade",
                                    "Tabela comparativa em Excel",
                                    "Vídeos tutoriais sobre modos normais"
                                  ],
                                  "tips": "Associe cada vantagem a uma economia prática, como tempo de CPU em simulações.",
                                  "learningObjective": "Identificar e justificar pelo menos 5 vantagens das coordenadas modais.",
                                  "commonMistakes": [
                                    "Listar vantagens sem justificativa matemática",
                                    "Confundir com métodos de componentes modais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e validar vantagens em exemplo prático",
                                  "subSteps": [
                                    "Monte um modelo 2 DOF de uma viga cantilever (massa m1, m2; rigidez k1, k2, k12).",
                                    "Resolva em coordenadas físicas e modais, comparando esforço computacional.",
                                    "Simule resposta temporal para força externa e observe decoplamento modal.",
                                    "Discuta escalabilidade para sistemas reais (ex: asas com 100+ DOF).",
                                    "Conclua com limitações (ex: amortecimento proporcional necessário)."
                                  ],
                                  "verification": "Gere gráficos de resposta modal vs física mostrando independência dos modos.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "MATLAB/Simulink para simulação dinâmica",
                                    "Modelo FEM simples (ex: ANSYS Student)",
                                    "Dados de propriedades de materiais aeroespaciais"
                                  ],
                                  "tips": "Use modshape plots para visualizar vantagens intuitivamente.",
                                  "learningObjective": "Aplicar conceitos para validar vantagens em contexto aeroespacial.",
                                  "commonMistakes": [
                                    "Não normalizar modos corretamente",
                                    "Ignorar truncamento de modos em aplicações reais"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma asa simplificada modelada como sistema 2 DOF (flexão e torção), as coordenadas físicas resultam em equações acopladas: 2¨x1 + 0.5¨x2 + 3x1 + x2 = F1; 0.5¨x1 + ¨x2 + x1 + 4x2 = F2. Transformando para modais com Φ = [[1, 0.8], [0.8, -1]] normalizado, obtém-se ¨q1 + 1.2 q1 = Q1 e ¨q2 + 5.8 q2 = Q2, decopladas e fáceis de integrar para análise de flutter.",
                              "finalVerifications": [
                                "Liste 5 vantagens com justificativa matemática.",
                                "Transforme corretamente equações de 2 DOF para modais.",
                                "Explique decoplamento em sistemas não amortecidos.",
                                "Compare tempo de simulação física vs modal.",
                                "Identifique aplicação em aeroelasticidade.",
                                "Crie tabela de prós/contras vs coordenadas físicas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação da transformação modal (80% correto).",
                                "Número e profundidade de vantagens justificadas (mínimo 4 com fórmulas).",
                                "Correta interpretação de decoplamento e simplificação.",
                                "Uso adequado de exemplo prático com cálculos numéricos.",
                                "Conexão clara com contexto aeroespacial.",
                                "Ausência de erros comuns como confusão com amortecimento."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de autovalores e diagonalização de matrizes simétricas.",
                                "Engenharia Mecânica: Vibrações e análise modal em estruturas.",
                                "Física: Princípios de osciladores harmônicos desacoplados.",
                                "Computação: Redução dimensional em simulações numéricas (FEM).",
                                "Engenharia Aeroespacial: Modelagem de flutter e resposta dinâmica."
                              ],
                              "realWorldApplication": "Na análise de aeroelasticidade de aeronaves, coordenadas modais decoplam os modos de flexão/torção de asas, permitindo prever flutter crítico com simulações eficientes, essencial para certificação FAA/EASA e otimização de designs como o Boeing 787."
                            },
                            "estimatedTime": "0.25 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.2",
                        "name": "Ortogonalidade dos Modos de Vibração",
                        "description": "Propriedades de ortogonalidade dos vetores modais em relação às matrizes de massa [M] e rigidez [K], fundamentais para o uso de coordenadas modais.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.2.1",
                            "name": "Enunciar propriedades de ortogonalidade modal",
                            "description": "Formular as condições de ortogonalidade: φ_i^T [M] φ_j = 0 e φ_i^T [K] φ_j = 0 para i ≠ j, e os valores modais de massa e rigidez.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Análise Modal em Sistemas MDOF",
                                  "subSteps": [
                                    "Recordar a equação de movimento geral: [M]{¨u} + [K]{u} = {F}.",
                                    "Explicar que a análise modal diagonaliza o sistema usando vetores modais {φ_i}.",
                                    "Definir coordenadas modais {q(t)} onde {u(t)} = [Φ]{q(t)}.",
                                    "Discutir a importância da ortogonalidade para desacoplar as equações modais.",
                                    "Derivar brevemente a equação modal desacoplada."
                                  ],
                                  "verification": "Escrever corretamente a equação de movimento em coordenadas modais e identificar o papel da ortogonalidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notas de aula sobre dinâmica de estruturas, livro de texto (ex: Clough & Penzien), calculadora.",
                                  "tips": "Use diagramas de um sistema 2DOF para visualizar os modos.",
                                  "learningObjective": "Compreender o contexto da análise modal onde a ortogonalidade é essencial.",
                                  "commonMistakes": "Confundir vetores modais com autovetores genéricos sem normalização."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Ortogonalidade em Espaços Vetoriais com Matrizes de Massa e Rigidez",
                                  "subSteps": [
                                    "Definir ortogonalidade escalar: {φ_i}^T {φ_j} = 0 para i ≠ j em espaço euclidiano.",
                                    "Generalizar para espaço ponderado por [M]: {φ_i}^T [M] {φ_j} = 0.",
                                    "Explicar por que [M] é usada (métrica de massa).",
                                    "Introduzir similarmente {φ_i}^T [K] {φ_j} = 0.",
                                    "Derivar geometricamente usando o problema de autovalores generalizado."
                                  ],
                                  "verification": "Calcular {φ_i}^T [M] {φ_j} para vetores modais conhecidos e confirmar zero.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Matriz de massa e rigidez de exemplo 2DOF, software MATLAB ou Python (NumPy).",
                                  "tips": "Pense em [M] e [K] como produtos internos em espaços físicos.",
                                  "learningObjective": "Dominar as definições matemáticas de ortogonalidade modal.",
                                  "commonMistakes": "Esquecer a transposição {φ_i}^T ou confundir com produto escalar simples."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular Condições de Ortogonalidade para i ≠ j",
                                  "subSteps": [
                                    "Escrever explicitamente: {φ_i}^T [M] {φ_j} = 0 e {φ_i}^T [K] {φ_j} = 0 para i ≠ j.",
                                    "Verificar com um exemplo numérico de sistema 2DOF.",
                                    "Explicar implicações: desacoplamento das equações modais.",
                                    "Discutir normalização: escalar modos para conveniência.",
                                    "Resolver um problema simples para praticar."
                                  ],
                                  "verification": "Formular as duas equações corretas e computar para um exemplo dado.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Exemplo numérico impresso ou em spreadsheet, MATLAB para verificação.",
                                  "tips": "Sempre verifique simetria de [M] e [K] (propriedade essencial).",
                                  "learningObjective": "Aplicar e enunciar condições de ortogonalidade off-diagonal.",
                                  "commonMistakes": "Invertar índices i e j ou omitir uma das matrizes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir Valores Modais de Massa e Rigidez para i = j",
                                  "subSteps": [
                                    "Introduzir valores modais: m_i = {φ_i}^T [M] {φ_i} e k_i = {φ_i}^T [K] {φ_i}.",
                                    "Explicar que ω_i² = k_i / m_i (frequência natural ao quadrado).",
                                    "Normalizar modos para m_i = 1 (modo mass-normalizado).",
                                    "Calcular para exemplo 2DOF e verificar consistência.",
                                    "Discutir generalizações para amortecimento."
                                  ],
                                  "verification": "Calcular m_i e k_i corretamente e relacionar com ω_i.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Mesmo exemplo do Step 3, tabela para registrar valores.",
                                  "tips": "Lembre: para i=j, não é zero, mas diagonal positivo definido.",
                                  "learningObjective": "Enunciar e calcular valores modais de massa e rigidez.",
                                  "commonMistakes": "Confundir com autovalores ou assumir zero na diagonal."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar e Verificar Propriedades Completas",
                                  "subSteps": [
                                    "Resumir todas propriedades: off-diagonal zero, diagonal m_i e k_i.",
                                    "Derivar equações modais desacopladas usando ortogonalidade.",
                                    "Aplicar a um caso aeroespacial simples (ex: viga cantilever).",
                                    "Testar com software para múltiplos modos.",
                                    "Autoavaliar compreensão."
                                  ],
                                  "verification": "Escrever o conjunto completo de propriedades e derivar equação modal.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software ANSYS ou MATLAB modal analysis toolbox.",
                                  "tips": "Use plots de modos para visualizar ortogonalidade nodal.",
                                  "learningObjective": "Sintetizar todas as propriedades de ortogonalidade modal.",
                                  "commonMistakes": "Ignorar normalização ao calcular valores modais."
                                }
                              ],
                              "practicalExample": "Considere uma viga cantilever modelada com 2 DOF (translação e rotação na ponta). Compute os modos φ1 = [1, 0]^T e φ2 = [0, 1]^T com [M] = diag(1,1) e [K] apropriada. Verifique φ1^T M φ2 = 0, φ1^T K φ2 = 0, m1=1, k1=ω1².",
                              "finalVerifications": [
                                "Enunciar corretamente as condições para i≠j.",
                                "Calcular valores modais m_i e k_i para um sistema dado.",
                                "Explicar por que ortogonalidade desacopla as equações.",
                                "Verificar numericamente com 2-3 modos.",
                                "Relacionar ω_i² = k_i / m_i.",
                                "Discutir impacto de normalização."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação das equações de ortogonalidade (100%).",
                                "Correção nos cálculos de m_i e k_i (exemplo numérico).",
                                "Explicação clara do desacoplamento modal.",
                                "Uso correto de notação matricial (transposta, etc.).",
                                "Identificação de erros comuns evitados.",
                                "Aplicação a contexto aeroespacial."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Problema de autovalores generalizado.",
                                "Física: Princípios de vibração e osciladores acoplados.",
                                "Engenharia Computacional: Implementação em FEM (Finite Element Method).",
                                "Controle de Sistemas: Modos em análise de estabilidade."
                              ],
                              "realWorldApplication": "Na análise de aeroelasticidade de asas de aeronaves, a ortogonalidade modal permite desacoplar vibrações em modos independentes, facilitando previsão de flutter e fadiga estrutural em projetos como o Boeing 787."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.2",
                            "name": "Verificar ortogonalidade em exemplo numérico",
                            "description": "Aplicar as propriedades de ortogonalidade para normalizar modos de vibração em um sistema MDOF simples com 2 graus de liberdade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o sistema MDOF com 2 graus de liberdade",
                                  "subSteps": [
                                    "Escolha massas iguais m1 = m2 = 1 kg para simplicidade.",
                                    "Defina constantes de rigidez: k1 = 2 N/m entre massa 1 e suporte, k2 = 1 N/m entre massas, k3 = 1 N/m entre massa 2 e suporte.",
                                    "Construa a matriz de massa M = [[1, 0], [0, 1]].",
                                    "Construa a matriz de rigidez K = [[3, -1], [-1, 2]].",
                                    "Verifique se M e K são simétricas e positivas definidas."
                                  ],
                                  "verification": "Matrizes M e K estão corretamente definidas e simétricas.",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "Papel e lápis",
                                    "Calculadora"
                                  ],
                                  "tips": "Use unidades consistentes (SI) para evitar erros dimensionais.",
                                  "learningObjective": "Modelar um sistema físico simples como equações matriciais.",
                                  "commonMistakes": "Esquecer o acoplamento entre massas na matriz K."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Resolver o problema de autovalores generalizados",
                                  "subSteps": [
                                    "Formule a equação (K - λ M) φ = 0 para λ1 e λ2.",
                                    "Resolva para autovalores: λ1 ≈ 0.5858, λ2 ≈ 3.4142 (frequências ao quadrado).",
                                    "Encontre autovetores: φ1 ≈ [0.8507, 0.5257]^T, φ2 ≈ [-0.5257, 0.8507]^T.",
                                    "Use software como MATLAB (eig(K,M)) ou resolva manualmente.",
                                    "Armazene os modos não normalizados."
                                  ],
                                  "verification": "Autovalores positivos e autovetores linealmente independentes obtidos.",
                                  "estimatedTime": "40 minutes",
                                  "materials": [
                                    "MATLAB ou Python (NumPy/SciPy)",
                                    "Papel para cálculos manuais"
                                  ],
                                  "tips": "Verifique soluções com det(K - λ M) = 0.",
                                  "learningObjective": "Aplicar análise modal uncoupled para MDOF.",
                                  "commonMistakes": "Confundir autovalores padrão com generalizados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar ortogonalidade dos modos",
                                  "subSteps": [
                                    "Calcule φ1^T M φ2.",
                                    "Calcule φ1^T K φ2.",
                                    "Confirme que ambos os escalares são aproximadamente zero (dentro de tolerância numérica 1e-10).",
                                    "Repita para φ2^T M φ1 e φ2^T K φ1 (deve ser simétrico).",
                                    "Documente os valores exatos obtidos."
                                  ],
                                  "verification": "Produtos escalares φi^T M φj = 0 e φi^T K φj = 0 para i ≠ j.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Calculadora matricial",
                                    "Software numérico"
                                  ],
                                  "tips": "Use transposição correta (φ^T é linha).",
                                  "learningObjective": "Compreender propriedades ortogonais inerentes aos modos normais.",
                                  "commonMistakes": "Não transpor o vetor (usar φ1 * M * φ2 em vez de φ1^T M φ2)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Normalizar os modos de vibração",
                                  "subSteps": [
                                    "Calcule fatores de normalização: αi = 1 / sqrt(φi^T M φi).",
                                    "Aplique φi_norm = αi * φi para i=1,2.",
                                    "Verifique φi_norm^T M φi_norm = 1 e φi_norm^T M φj_norm = 0 (i≠j).",
                                    "Confirme também ortogonalidade em K: φi_norm^T K φj_norm = 0 (i≠j).",
                                    "Salve os modos normalizados."
                                  ],
                                  "verification": "Modos satisfazem φi^T M φj = δij (delta de Kronecker).",
                                  "estimatedTime": "25 minutes",
                                  "materials": [
                                    "Software para operações matriciais"
                                  ],
                                  "tips": "Normalização em M é padrão para análise modal.",
                                  "learningObjective": "Transformar modos em base ortonormal para decoplamento.",
                                  "commonMistakes": "Normalizar apenas em norma euclidiana (ignorando M)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e interpretar os resultados",
                                  "subSteps": [
                                    "Compare frequências naturais: ω1 = sqrt(λ1), ω2 = sqrt(λ2).",
                                    "Visualize os modos (desenhe deslocamentos nodais).",
                                    "Discuta implicações: modos uncoupled permitem superposição linear.",
                                    "Teste sensibilidade a erros numéricos.",
                                    "Resuma em tabela: modos, escalares de ortogonalidade."
                                  ],
                                  "verification": "Tabela de verificação completa com valores próximos de zero/uno esperados.",
                                  "estimatedTime": "20 minutes",
                                  "materials": [
                                    "Papel para gráficos",
                                    "Software de plotagem"
                                  ],
                                  "tips": "Modo 1: em fase; Modo 2: em oposição.",
                                  "learningObjective": "Interpretar resultados modais no contexto físico.",
                                  "commonMistakes": "Ignorar tolerâncias numéricas em verificações."
                                }
                              ],
                              "practicalExample": "Para o sistema 2DOF com M = [[1,0],[0,1]], K = [[3,-1],[-1,2]], os modos não normalizados são φ1 = [0.8507, 0.5257]^T e φ2 = [-0.5257, 0.8507]^T. Após verificação, φ1^T M φ2 ≈ 0, φ1^T K φ2 ≈ 0. Normalizando, φ1_norm ≈ [0.9749, 0.2225]^T, satisfazendo φ1_norm^T M φ1_norm = 1.",
                              "finalVerifications": [
                                "φ1^T M φ2 = 0 (tolerância 1e-10)",
                                "φ1^T K φ2 = 0 (tolerância 1e-10)",
                                "Após normalização, φi^T M φi = 1 para i=1,2",
                                "φi^T M φj = 0 para i≠j",
                                "Frequências ω1 < ω2 e modos fisicamente coerentes",
                                "Matrizes M e K simétricas positivas definidas"
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos autovalores e autovetores (erro <1%)",
                                "Cálculos corretos de produtos escalares com transposição adequada",
                                "Normalização exata em norma de massa",
                                "Interpretação física dos modos (fase e forma)",
                                "Documentação clara com tabelas e verificações",
                                "Uso apropriado de tolerâncias numéricas"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Problemas de autovalores generalizados e ortogonalidade",
                                "Programação Numérica: Implementação em MATLAB/Python para análise modal",
                                "Física Clássica: Equações de vibração harmônica livre",
                                "Engenharia Computacional: Pré-processamento para simulações FEM"
                              ],
                              "realWorldApplication": "Em aeroelasticidade, verificar ortogonalidade de modos em análises modais de asas de aeronaves permite decoplamento de equações de movimento, essencial para prever flutter e otimizar estruturas leves em aviões comerciais."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.3.2.3",
                            "name": "Normalizar matriz de modos",
                            "description": "Demonstrar o processo de normalização modal usando ortogonalidade para obter uma matriz modal unitária em massa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar Matrizes de Massa e Modos Não Normalizados",
                                  "subSteps": [
                                    "Obtenha a matriz de massa M do sistema MDOF a partir do modelo finito elemento ou equações de movimento.",
                                    "Realize a análise modal para extrair os vetores modais não normalizados Φ (matriz cujas colunas são os modos φ_i).",
                                    "Verifique as propriedades de ortogonalidade básica: confirme que Φ^T K Φ é diagonal (ortogonalidade em rigidez).",
                                    "Documente as dimensões: M é n x n, Φ é n x m (m modos).",
                                    "Armazene em software como MATLAB ou Python (NumPy) para cálculos numéricos."
                                  ],
                                  "verification": "Matrizes M e Φ estão corretamente definidas e Φ satisfaz a equação eigen (K φ_i = ω_i² M φ_i).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de análise modal (MATLAB, ANSYS), equações do sistema MDOF.",
                                  "tips": "Use modos de baixa frequência para simplificar em análises iniciais.",
                                  "learningObjective": "Entender a base de dados necessária para normalização modal.",
                                  "commonMistakes": "Confundir matriz de massa com rigidez ou usar modos não ordenados por frequência."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Massas Modais",
                                  "subSteps": [
                                    "Para cada modo i, compute a massa modal m_i = φ_i^T M φ_i, onde φ_i é a i-ésima coluna de Φ.",
                                    "Forme o vetor diagonal das massas modais [m_1, m_2, ..., m_m].",
                                    "Verifique se m_i > 0 para todos os modos (propriedade física esperada).",
                                    "Calcule as raízes quadradas sqrt(m_i) para uso posterior.",
                                    "Salve como matriz diagonal Μ_modal = diag(m_i)."
                                  ],
                                  "verification": "Matriz diagonal Μ_modal com entradas positivas e consistentes com energias modais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora matricial ou script Python/MATLAB (ex: phi.T @ M @ phi).",
                                  "tips": "Automatize com loop for i in range(m): m_i = phi[:,i].T @ M @ phi[:,i].",
                                  "learningObjective": "Dominar o cálculo da massa modal usando ortogonalidade.",
                                  "commonMistakes": "Esquecer transposição (φ_i^T) ou usar produto escalar simples em vez de quadrático."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Normalizar os Vetores Modais",
                                  "subSteps": [
                                    "Para cada modo i, normalize φ_i_norm = φ_i / sqrt(m_i).",
                                    "Substitua as colunas de Φ pela versão normalizada para obter Φ_norm.",
                                    "Confirme numericamente que ||φ_i_norm||_M = 1, onde norma em massa é sqrt(φ^T M φ).",
                                    "Arredonde valores para precisão numérica (ex: 1e-10).",
                                    "Gere a matriz completa Φ_norm."
                                  ],
                                  "verification": "Cada coluna satisfaz φ_i_norm^T M φ_i_norm = 1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Mesmo software do Step 1, com funções de normalização.",
                                  "tips": "Use broadcasting em NumPy: scales = 1/np.sqrt(np.diag(Phi.T @ M @ Phi)); Phi_norm = Phi @ np.diag(scales).",
                                  "learningObjective": "Aplicar escalonamento para unitariedade em massa.",
                                  "commonMistakes": "Dividir por m_i em vez de sqrt(m_i), resultando em Φ^T M Φ = Μ_modal^{-1} ≠ I."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Validar a Matriz Modal Unitária",
                                  "subSteps": [
                                    "Compute Φ_norm^T M Φ_norm e confirme que é a identidade I (dentro de tolerância numérica).",
                                    "Verifique ortogonalidade em rigidez: Φ_norm^T K Φ_norm deve ser diagonal com ω_i².",
                                    "Calcule normas modais unitárias e compare com original.",
                                    "Teste em um subconjunto de modos para eficiência.",
                                    "Documente desvios e ajuste se necessário (ex: re-ortogonalização Gram-Schmidt)."
                                  ],
                                  "verification": "Φ_norm^T M Φ_norm ≈ I (erro < 1e-8), e propriedades modais preservadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Software com verificação matricial.",
                                  "tips": "Use np.allclose(Phi_norm.T @ M @ Phi_norm, np.eye(m)) para validação automática.",
                                  "learningObjective": "Garantir qualidade da normalização via verificações.",
                                  "commonMistakes": "Ignorar erros numéricos de condicionamento em M ill-condicionada."
                                }
                              ],
                              "practicalExample": "Para um sistema 2DOF com M = [[2,0],[0,1]] kg e Φ não norm = [[1],[2]] para modo 1, [[-1],[1]] para modo 2: m1 = [1,2]^T M [1,2] = 6, sqrt(m1)=√6≈2.45, φ1_norm=[1/2.45,2/2.45]≈[0.408,0.816]; similar para modo 2. Então Φ_norm^T M Φ_norm = [[1,0],[0,1]].",
                              "finalVerifications": [
                                "Φ_norm^T M Φ_norm = I (identidade unitária).",
                                "Cada massa modal normalizada é 1.",
                                "Frequências modais ω_i preservadas.",
                                "Ortogonalidade em rigidez mantida (diagonal).",
                                "Erro numérico global < 1e-6.",
                                "Modos ordenados por frequência crescente."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de massas modais (erro < 1%).",
                                "Correta aplicação de normalização (unitariedade verificada).",
                                "Explicação conceitual da ortogonalidade usada.",
                                "Eficiência computacional no exemplo prático.",
                                "Identificação e correção de erros comuns.",
                                "Documentação clara dos passos e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição eigen e ortogonalização.",
                                "Física: Princípios de vibração e energia modal.",
                                "Programação: Manipulação matricial em Python/MATLAB.",
                                "Engenharia Mecânica: Modelagem de estruturas aeroespaciais."
                              ],
                              "realWorldApplication": "Na análise de flutter de asas de aeronaves, a matriz modal normalizada unitária em massa permite coordenadas modais desacopladas para simulações dinâmicas eficientes, prevendo instabilidades aeroelásticas em projetos da Boeing ou Embraer."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.3",
                        "name": "Transformação e Uso na Análise Modal",
                        "description": "Aplicação prática da transformação para coordenadas modais na solução das equações de movimento de sistemas estruturais aeroespaciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.3.1",
                            "name": "Realizar transformação modal das equações de movimento",
                            "description": "Derivar a transformação [M]{¨x} + [K]{x} = {F} para equações desacopladas em coordenadas modais: [I]{¨q} + [Λ]{q} = {Φ}^T {F}.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Resolver o problema de autovalores generalizado para obter modos e frequências naturais",
                                  "subSteps": [
                                    "Escreva as matrizes de massa [M] e rigidez [K] do sistema MDOF.",
                                    "Formule o problema generalizado [K]{φ} = ω²[M]{φ}, onde ω² são autovalores e {φ} autovetores.",
                                    "Use método analítico para sistemas pequenos ou numérico (ex: MATLAB eig) para sistemas maiores.",
                                    "Calcule as frequências naturais ω_i = √λ_i para cada modo i.",
                                    "Ordene os modos por frequência crescente."
                                  ],
                                  "verification": "Confirme que [K]{φ_i} = λ_i [M]{φ_i} para cada modo i, com λ_i = ω_i².",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Matrizes [M] e [K] do sistema, software como MATLAB ou Python (NumPy/SciPy), papel e calculadora.",
                                  "tips": "Sempre verifique simetria positiva definida de [M] e [K] para garantir modos reais.",
                                  "learningObjective": "Dominar a extração de modos naturais de sistemas MDOF.",
                                  "commonMistakes": "Confundir autovalores de [K] com os generalizados; ignorar multiplicidade de modos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir e normalizar a matriz modal [Φ]",
                                  "subSteps": [
                                    "Monte a matriz [Φ] cujas colunas são os autovetores {φ_i}.",
                                    "Normalize os modos para ortonormalidade: {φ_i}^T [M] {φ_j} = δ_ij e {φ_i}^T [K] {φ_j} = λ_i δ_ij.",
                                    "Ajuste escalares para que [Φ]^T [M] [Φ] = [I] e [Φ]^T [K] [Φ] = [Λ] (diagonal).",
                                    "Verifique dimensionalidade: [Φ] é n x n para n graus de liberdade.",
                                    "Armazene [Λ] como diagonal com λ_i = ω_i²."
                                  ],
                                  "verification": "Compute [Φ]^T [M] [Φ] == [I] e [Φ]^T [K] [Φ] == [Λ]; tolerância numérica < 1e-6.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Matriz [Φ] não normalizada, MATLAB/Python para normalização, tabela de verificação.",
                                  "tips": "Use normalização em massa para simplicidade em análises aeroespaciais.",
                                  "learningObjective": "Compreender a ortonormalidade modal essencial para desacoplamento.",
                                  "commonMistakes": "Esquecer normalização, levando a [Φ]^T [M] [Φ] ≠ [I]; inverter linhas/colunas de [Φ]."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a transformação modal nas equações de movimento originais",
                                  "subSteps": [
                                    "Defina a transformação {x} = [Φ] {q}, onde {q} são coordenadas modais.",
                                    "Substitua nas EOM: [M] [Φ] {¨q} + [K] [Φ] {q} = {F}.",
                                    "Pré-multiplique por [Φ]^T: [Φ]^T [M] [Φ] {¨q} + [Φ]^T [K] [Φ] {q} = [Φ]^T {F}.",
                                    "Simplifique usando ortonormalidade: [I] {¨q} + [Λ] {q} = [Φ]^T {F}.",
                                    "Identifique forças modais {Φ}^T {F}."
                                  ],
                                  "verification": "A equação resultante deve ser [I]{¨q} + [Λ]{q} = {Φ}^T {F}, sem acoplamento.",
                                  "estimatedTime": "1 hora",
                                  "materials": "EOM originais, [Φ], [Λ], {F}, software para multiplicação matricial.",
                                  "tips": "Visualize graficamente: modos transformam coordenadas físicas em independentes.",
                                  "learningObjective": "Executar a substituição modal corretamente para desacoplamento.",
                                  "commonMistakes": "Não pré-multiplicar por [Φ]^T, mantendo acoplamento; erro em derivadas {¨x} = [Φ]{¨q}."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e interpretar as equações modais desacopladas",
                                  "subSteps": [
                                    "Confirme que cada equaçaõ modal é independente: ¨q_i + ω_i² q_i = φ_i^T F.",
                                    "Analise resposta: cada modo oscila independentemente.",
                                    "Compare com solução física: some contribuições modais q_i φ_i para {x}.",
                                    "Teste com excitação modal seletiva (ex: F alinhado com φ_i).",
                                    "Documente limitações (ex: amortecimento não incluído)."
                                  ],
                                  "verification": "Simule numericamente e confirme que soma modal reconstrói {x} com erro < 1%.",
                                  "estimatedTime": "0.5 horas",
                                  "materials": "Software de simulação (MATLAB ode45), gráficos de modos.",
                                  "tips": "Use truncamento modal para aproximação em sistemas grandes.",
                                  "learningObjective": "Interpretar significado físico das coordenadas modais.",
                                  "commonMistakes": "Ignorar forças modais não-zero; assumir todos modos contribuem igualmente."
                                }
                              ],
                              "practicalExample": "Para um sistema 2DOF com [M] = diag(1,1), [K] = [[2,-1],[-1,1]], resolva autovalores: ω1≈0.765, φ1=[0.85,0.53]; ω2≈1.618, φ2=[0.53,-0.85]. Normalize [Φ], aplique transformação em {F}=[1,0]^T, obtenha ¨q1 + 0.585 q1 = 0.85, ¨q2 + 2.618 q2 = 0.53.",
                              "finalVerifications": [
                                "[Φ]^T [M] [Φ] = [I] (identidade).",
                                "[Φ]^T [K] [Φ] = [Λ] (diagonal com ω_i²).",
                                "Equações finais: [I]{¨q} + [Λ]{q} = [Φ]^T {F} sem termos cruzados.",
                                "Reconstrução: [Φ]{q} ≈ {x} original em simulação livre.",
                                "Forças modais corretas para excitação dada.",
                                "Modos ordenados por frequência crescente."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (sem erros algébricos).",
                                "Correta normalização modal verificada numericamente.",
                                "Desacoplamento completo demonstrado.",
                                "Interpretação física das coordenadas q_i.",
                                "Uso adequado de ferramentas computacionais.",
                                "Documentação clara de passos e verificações."
                              ],
                              "crossCurricularConnections": [
                                "Física: Osciladores harmônicos desacoplados.",
                                "Computação: Solvers de autovalores (eigendecomposition).",
                                "Engenharia de Controle: Decoplamento para design de controladores.",
                                "Matemática: Álgebra linear avançada e ortogonalidade."
                              ],
                              "realWorldApplication": "Em aeroelasticidade, transforma equações de flutter de asas de aeronaves em modos independentes, permitindo análise de instabilidades modais e otimização estrutural para evitar vibrações catastróficas em aviões."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.1.2",
                              "10.1.3.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.3.3.2",
                            "name": "Resolver resposta dinâmica em coordenadas modais",
                            "description": "Calcular a resposta livre ou forçada de um sistema MDOF usando coordenadas modais, somando contribuições modais independentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Realizar Análise Modal do Sistema MDOF",
                                  "subSteps": [
                                    "Montar as matrizes de massa [M] e rigidez [K] do sistema físico.",
                                    "Resolver o problema de autovalores para obter frequências naturais ω_n e vetores modais φ_n.",
                                    "Normalizar os modos modais (ortogonalidade: φ_i^T M φ_j = δ_ij).",
                                    "Verificar a completude dos modos (número de modos igual ao número de DOF).",
                                    "Calcular matriz modal de massa e rigidez diagonalizadas."
                                  ],
                                  "verification": "Confirme que as matrizes modais são diagonais e que os modos satisfazem as condições de ortogonalidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de análise modal (MATLAB, ANSYS), calculadora matricial, papel e lápis.",
                                  "tips": "Use decomposição espectral para sistemas pequenos; para grandes, métodos iterativos como Lanczos.",
                                  "learningObjective": "Compreender e aplicar análise modal para desacoplar o sistema MDOF.",
                                  "commonMistakes": "Esquecer normalização dos modos, levando a contribuições modais incorretas; confundir massa e rigidez."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Transformar o Problema para Coordenadas Modais",
                                  "subSteps": [
                                    "Definir a transformação modal: {x} = [Φ] {q}, onde {q} são coordenadas modais.",
                                    "Projetar forças externas: {Q} = [Φ]^T {F(t)} para cargas forçadas.",
                                    "Transformar condições iniciais: {q(0)} = [Φ]^{-1} {x(0)}, ḟ{q(0)} = [Φ]^{-1} ẋ(0).",
                                    "Verificar se as equações modais estão desacopladas: m̂_i q̈_i + k̂_i q_i = Q_i(t).",
                                    "Identificar resposta livre (Q=0) ou forçada."
                                  ],
                                  "verification": "As equações resultantes devem ser SISO independentes para cada modo i.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "MATLAB para multiplicação matricial, tabela de propriedades do sistema.",
                                  "tips": "Use modos mass-normalizados para simplificar (m̂_i = 1).",
                                  "learningObjective": "Dominar a transformação uncoupled das equações de movimento.",
                                  "commonMistakes": "Erro na projeção de forças (não usar [Φ]^T); inverter matriz modal incorretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver Equações Modais Individuais",
                                  "subSteps": [
                                    "Para resposta livre: Resolver q_i(t) = A_i cos(ω_i t) + B_i sin(ω_i t), com A_i, B_i de condições iniciais.",
                                    "Para resposta forçada harmônica: q_i(t) = (Q_i / (k̂_i - m̂_i ω^2)) cos(ω t) ou Duhamel para transitória.",
                                    "Aplicar método de Duhamel para cargas arbitrárias: q_i(t) = ∫ h_i(t-τ) Q_i(τ) dτ.",
                                    "Calcular coeficientes usando condições iniciais transformadas.",
                                    "Plotar respostas modais q_i(t) para inspeção."
                                  ],
                                  "verification": "Verifique que cada q_i(t) satisfaz sua equação diferencial modal.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB/Octave para integração numérica (ode45), fórmulas analíticas.",
                                  "tips": "Para harmônicos, verifique ressonância (ω ≈ ω_n); use filtros modais.",
                                  "learningObjective": "Resolver analítica e numericamente equações modais desacopladas.",
                                  "commonMistakes": "Ignorar amortecimento modal; erros em coeficientes iniciais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Resposta Física Somando Contribuições Modais",
                                  "subSteps": [
                                    "Calcular {x(t)} = Σ φ_i q_i(t) para i=1 a N (todos os modos).",
                                    "Truncar modos superiores se necessário (verificar convergência).",
                                    "Calcular respostas em deslocamento, velocidade e aceleração.",
                                    "Plotar {x(t)} e comparar com solução direta (se possível).",
                                    "Analisar participação modal (modal effective mass)."
                                  ],
                                  "verification": "A soma modal deve satisfazer as equações originais no espaço físico.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de plotagem (MATLAB plot), verificador de equilíbrio dinâmico.",
                                  "tips": "Use 6-10 primeiros modos para precisão em estruturas; cheque energia modal.",
                                  "learningObjective": "Reconstruir resposta física a partir de componentes modais.",
                                  "commonMistakes": "Não truncar modos adequadamente, causando oscilações espúrias; soma errada de fases."
                                }
                              ],
                              "practicalExample": "Considere um edifício de 2 andares modelado como MDOF com m1=m2=1000 kg, k1=k2=10^5 N/m, carga harmônica F(t)=100 sin(5t) N no 2º DOF. Obtenha modos, transforme, resolva q1(t), q2(t), some para x(t).",
                              "finalVerifications": [
                                "Equações modais estão desacopladas e resolvidas corretamente.",
                                "Soma modal reproduz resposta física com erro <1%.",
                                "Condições iniciais preservadas na transformação.",
                                "Análise de convergência com mais modos.",
                                "Plots de q_i(t) e x(t) mostram comportamento físico realista.",
                                "Verificação de equilíbrio: M ẍ + K x = F(t)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na análise modal (frequências e modos corretos: ±5%).",
                                "Correção na transformação modal e projeção de cargas.",
                                "Solução analítica/numérica das equações modais sem erros.",
                                "Síntese modal convergente e verificada.",
                                "Interpretação física da resposta (ressonâncias, participações).",
                                "Eficiência computacional (truncamento justificado)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (autovalores), integrais de convolução (Duhamel).",
                                "Controle de Sistemas: Decoplamiento modal similar a diagonalização em controle.",
                                "Programação: Implementação numérica em MATLAB/Python para simulações.",
                                "Aeroelasticidade: Aplicação em flutter (modos acoplados).",
                                "Física: Princípios de vibrações e superposição modal."
                              ],
                              "realWorldApplication": "Em projetos aeroespaciais, usado para prever vibrações de asas ou fuselagem sob turbulência ou motores, otimizando design para evitar fadiga e ressonâncias em aeronaves como o Boeing 787."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.3.3.3",
                            "name": "Aplicar em contexto aeroespacial",
                            "description": "Exemplificar o uso de coordenadas modais em modelagem de estruturas aeroespaciais, como asas ou fuselagens, para análise de vibrações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o modelo físico da estrutura aeroespacial",
                                  "subSteps": [
                                    "Identifique a geometria da estrutura, como uma asa modelada como viga cantilever com comprimento L, seção transversal uniforme e propriedades materiais (E, ρ).",
                                    "Defina os graus de liberdade (DOF), tipicamente flexão transversal e torção para asas simples.",
                                    "Estabeleça condições de contorno: empotrada na raiz (u(0)=0, u'(0)=0) e livre na ponta.",
                                    "Calcule as matrizes de massa [M] e rigidez [K] elementares usando métodos de elementos finitos (FEM) ou Rayleigh-Ritz.",
                                    "Monte o sistema global MDOF com n DOFs."
                                  ],
                                  "verification": "Verifique se as matrizes [M] e [K] são simétricas positivas definidas e se as condições de contorno estão corretamente aplicadas.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Software FEM como ANSYS ou MATLAB; referências em Dinâmica de Estruturas (ex: Clough & Penzien).",
                                  "tips": "Comece com poucos elementos (2-4) para simplicidade inicial.",
                                  "learningObjective": "Compreender a discretização de estruturas contínuas em modelos MDOF relevantes para aeroespacial.",
                                  "commonMistakes": "Ignorar torção acoplada em asas; usar propriedades erradas de materiais (ex: alumínio vs compósitos)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular equações de movimento no domínio físico",
                                  "subSteps": [
                                    "Escreva a equação geral: [M]{ü} + [K]{u} = {F}(t), onde {u} são deslocamentos físicos.",
                                    "Assuma movimento harmônico livre: {u} = {φ} sin(ωt), levando ao problema de autovalores [K]{φ} - ω²[M]{φ} = 0.",
                                    "Resolva para modos {φ_r} e frequências ω_r (r=1 a n) usando decomposição espectral ou solvers numéricos.",
                                    "Normalize os modos (ex: massa unitária: {φ_r}^T [M] {φ_r} = 1).",
                                    "Valide com frequências analíticas para viga Euler-Bernoulli."
                                  ],
                                  "verification": "Confirme que os autovalores ω_r² são positivos e modos ortogonais: {φ_i}^T [M] {φ_j} = 0 para i≠j.",
                                  "estimatedTime": "3 horas",
                                  "materials": "MATLAB ou Python (NumPy/SciPy para eig); planilhas para casos simples.",
                                  "tips": "Use funções built-in como eig() no MATLAB para eficiência.",
                                  "learningObjective": "Dominar a formulação do problema modal no espaço físico para estruturas aeroespaciais.",
                                  "commonMistakes": "Não normalizar modos, levando a respostas modais incorretas; confundir frequências com períodos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar transformação para coordenadas modais",
                                  "subSteps": [
                                    "Construa a matriz modal [Φ] = [{φ_1}, {φ_2}, ..., {φ_n}].",
                                    "Defina transformação: {u} = [Φ]{q}, onde {q} são coordenadas modais.",
                                    "Substitua na equação: [Φ]^T [M] [Φ] {q̈} + [Φ]^T [K] [Φ] {q} = [Φ]^T {F}.",
                                    "Diagonalize: [Φ]^T [M] [Φ] = [I] (massa unitária), [Φ]^T [K] [Φ] = [Λ] (diagonal com ω_r²).",
                                    "Simplifique para n equações desacopladas: q̈_r + ω_r² q_r = Q_r(t), onde Q_r = {φ_r}^T {F}."
                                  ],
                                  "verification": "Verifique se [Φ]^T [M] [Φ] é identidade e [Φ]^T [K] [Φ] diagonal.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Código MATLAB/Python para transformação; calculadora matricial.",
                                  "tips": "Trunque para primeiros m < n modos se n grande, justificando com energia modal.",
                                  "learningObjective": "Executar a transformação modal uncoupling o sistema MDOF.",
                                  "commonMistakes": "Erro na transposição [Φ]^T; assumir ortogonalidade sem normalização."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar análise de vibrações e exemplificar",
                                  "subSteps": [
                                    "Simule excitação (ex: força harmônica na ponta da asa F(t) = F_0 cos(Ωt)).",
                                    "Calcule respostas modais q_r(t) = (Q_r / (ω_r² - Ω²)) cos(Ωt) para estado estacionário.",
                                    "Reconstrua resposta física {u}(t) = Σ [φ_r] q_r(t) (primeiros modos dominantes).",
                                    "Analise picos de ressonância perto de ω_r e deformações modais em fuselagem/asa.",
                                    "Compare com simulações FEM comerciais para validação."
                                  ],
                                  "verification": "Plot de {u}(t) mostra modos contribuindo corretamente; ausência de acoplamento.",
                                  "estimatedTime": "3 horas",
                                  "materials": "MATLAB Simulink ou Python (Matplotlib para plots); dados de asas reais (ex: NACA 0012).",
                                  "tips": "Amortecimento leve (ζ=0.01) para realismo: q̈_r + 2ζω_r q̇_r + ω_r² q_r = Q_r.",
                                  "learningObjective": "Interpretar análise vibracional em coordenadas modais para contextos aeroespaciais.",
                                  "commonMistakes": "Incluir todos modos (ruído numérico); ignorar contribuições de modos superiores."
                                }
                              ],
                              "practicalExample": "Modelar uma asa cantilever de alumínio (L=2m, EI=1e6 Nm², ρA=10 kg/m) com 4 DOFs. Aplicar força F=100N cos(50t) na ponta. Transformar para modais, calcular resposta: modo 1 domina em baixa freq., deformação máxima 5cm na ponta.",
                              "finalVerifications": [
                                "Matrizes modais diagonalizadas corretamente.",
                                "Resposta física reconstruída soma contribuições modais precisas.",
                                "Identificação de frequências críticas para flutter em asas.",
                                "Validação numérica vs analítica para viga simples.",
                                "Explicação qualitativa de uncoupling modal.",
                                "Aplicação correta a fuselagem como casca cilíndrica."
                              ],
                              "assessmentCriteria": [
                                "Precisão das matrizes [M], [K] e [Φ] (erro <1%).",
                                "Correta diagonalização e normalização modal.",
                                "Interpretação física das respostas vibracionais.",
                                "Uso apropriado de truncamento modal.",
                                "Clareza em plots e relatórios de análise.",
                                "Identificação de riscos aeroespaciais (ex: ressonância)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição espectral e autovalores.",
                                "Física: Ondas e vibrações em contínuos.",
                                "Engenharia Mecânica: Elementos Finitos (FEM).",
                                "Computação: Programação numérica em MATLAB/Python.",
                                "Aerodinâmica: Acoplamento aeroelástico (flutter)."
                              ],
                              "realWorldApplication": "Em design de aeronaves (ex: Boeing 787), coordenadas modais reduzem modelos FEM de milhões DOFs para ~10 modais dominantes, acelerando análise de vibrações induzidas por turbulência, evitando fadiga estrutural e instabilidades como flutter em asas/fuselagens."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.4",
                    "name": "Solução por Análise Modal",
                    "description": "Aplicação da análise modal para resolver respostas dinâmicas em sistemas com múltiplos graus de liberdade.",
                    "individualConcepts": [
                      {
                        "id": "57.2.3.1",
                        "name": "Ortogonalidade dos Modos de Vibração Natural",
                        "description": "Propriedades de ortogonalidade das funções modais em sistemas com múltiplos graus de liberdade, incluindo matrizes de massa e rigidez modais.",
                        "specificSkills": [
                          {
                            "id": "57.2.3.1.1",
                            "name": "Calcular frequências naturais e vetores modais",
                            "description": "Resolver o problema de autovalores para obter frequências naturais e modos de vibração de sistemas MDOF modelados por matrizes de massa e rigidez.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Construir as matrizes de massa [M] e rigidez [K] do sistema MDOF",
                                  "subSteps": [
                                    "Identifique os graus de liberdade (DOF) do sistema.",
                                    "Derive as equações de movimento usando princípios de Lagrange ou Newton.",
                                    "Monte a matriz de massa [M] considerando massas concentradas ou distribuídas.",
                                    "Monte a matriz de rigidez [K] baseada nas constantes de mola ou elementos finitos.",
                                    "Verifique a simetria e positividade das matrizes."
                                  ],
                                  "verification": "As matrizes [M] e [K] devem ser simétricas e positivas definidas; teste multiplicando por vetores de teste.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software MATLAB ou Python (NumPy/SciPy)",
                                    "Papel e lápis para derivação manual",
                                    "Exemplos de sistemas 2DOF ou 3DOF"
                                  ],
                                  "tips": "Comece com sistemas simples de 2 DOF para validar antes de sistemas complexos.",
                                  "learningObjective": "Compreender como formular as matrizes fundamentais para análise modal.",
                                  "commonMistakes": [
                                    "Esquecer acoplamentos entre DOFs",
                                    "Inverter unidades de massa ou rigidez",
                                    "Não considerar condições de contorno"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular o problema de autovalores generalizado",
                                  "subSteps": [
                                    "Escreva a equação de movimento livre: [M]{¨x} + [K]{x} = 0.",
                                    "Assuma solução harmônica {x} = {φ} sin(ωt).",
                                    "Derive a equação padrão: ([K] - ω²[M]){φ} = 0.",
                                    "Reformule como problema generalizado: [K]{φ} = ω²[M]{φ}.",
                                    "Confirme que é um problema de autovalores não padrão devido à [M]."
                                  ],
                                  "verification": "A equação deve ser ([K] - λ[M]){φ} = 0, onde λ = ω².",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de dinâmica estrutural (ex: Clough & Penzien)",
                                    "Calculadora simbólica como SymPy"
                                  ],
                                  "tips": "Lembre-se: ω é a frequência circular (rad/s), não f em Hz.",
                                  "learningObjective": "Dominar a transformação da equação dinâmica em problema matricial de autovalores.",
                                  "commonMistakes": [
                                    "Confundir ω com f (frequência cíclica)",
                                    "Esquecer o fator ω²",
                                    "Assumir [M] identidade prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver numericamente os autovalores e autovetores",
                                  "subSteps": [
                                    "Use função eig() no MATLAB ou scipy.linalg.eig() no Python para problema generalizado.",
                                    "Extraia autovalores λ_i = ω_i² e autovetores {φ_i}.",
                                    "Ordene os modos por frequência crescente (λ crescente).",
                                    "Calcule frequências naturais ω_n = sqrt(λ_n) e f_n = ω_n / (2π).",
                                    "Normalize os vetores modais (ex: φ^T M φ = 1)."
                                  ],
                                  "verification": "Todos os autovalores devem ser reais e positivos; verifique [K]φ = ω²[M]φ para cada modo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB ou Python com SciPy",
                                    "Script de exemplo para eig generalizado"
                                  ],
                                  "tips": "Para sistemas grandes, use métodos iterativos como Lanczos para eficiência.",
                                  "learningObjective": "Aplicar solvers numéricos para extrair modos e frequências com precisão.",
                                  "commonMistakes": [
                                    "Usar eig padrão em vez de generalizado",
                                    "Não ordenar modos",
                                    "Erros numéricos em sistemas mal-condicionados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e verificar frequências naturais e vetores modais",
                                  "subSteps": [
                                    "Plote os modos de vibração (forma modal) para visualização.",
                                    "Verifique ortogonalidade: φ_i^T [M] φ_j = 0 e φ_i^T [K] φ_j = 0 para i ≠ j.",
                                    "Calcule massas e rigidezes modais: m_i = φ_i^T [M] φ_i.",
                                    "Analise dominância de modos (participação modal).",
                                    "Compare com resultados analíticos para sistemas pequenos."
                                  ],
                                  "verification": "Ortogonalidade deve ser satisfeita com tolerância 1e-6; plots devem mostrar deformações físicas realistas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de plotagem (MATLAB plot ou Matplotlib)",
                                    "Tabelas de resultados esperados"
                                  ],
                                  "tips": "Use animação de modos para intuição física.",
                                  "learningObjective": "Validar e interpretar resultados modais no contexto físico.",
                                  "commonMistakes": [
                                    "Ignorar normalização",
                                    "Interpretar modos complexos como reais",
                                    "Não verificar ortogonalidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um sistema 2DOF com m1 = m2 = 1 kg, k1 = k2 = 1 N/m, k_c = 0.5 N/m. Matrizes: [M] = diag(1,1), [K] = [[1.5, -0.5], [-0.5, 1.5]]. Resolva: λ1 ≈ 0.586, ω1 ≈ 0.765 rad/s; λ2 ≈ 2.414, ω2 ≈ 1.553 rad/s. Vetores: φ1 = [0.85, 0.53]^T normalizado.",
                              "finalVerifications": [
                                "Resolver corretamente [K]φ = ω²[M]φ para todos os modos.",
                                "Frequências em ordem crescente e vetores ortogonais.",
                                "Plots de modos mostram movimento físico coerente.",
                                "Comparação com solução analítica para 2DOF com erro <1%.",
                                "Cálculo correto de frequências em Hz e rad/s.",
                                "Normalização modal verificada."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica dos autovalores (<1e-6 erro relativo).",
                                "Correta formulação das matrizes [M] e [K].",
                                "Uso apropriado de solvers generalizados.",
                                "Verificação completa de ortogonalidade.",
                                "Interpretação física dos modos.",
                                "Eficiência computacional para sistemas >3 DOF."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Problemas de autovalores generalizados.",
                                "Programação Computacional: Uso de MATLAB/Python para engenharia.",
                                "Física: Oscilações harmônicas e princípios variacionais.",
                                "Engenharia Aeroespacial: Análise de flutter e vibrações de asas.",
                                "Matemática Numérica: Métodos iterativos para autovalores."
                              ],
                              "realWorldApplication": "Na análise de asas de aeronaves, calcular frequências naturais e modos modais previne ressonância com turbulência ou motores, evitando flutter catastrófico, como no caso do Lockheed Electra."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.2.3.1.2",
                            "name": "Verificar ortogonalidade modal",
                            "description": "Demonstrar a ortogonalidade dos modos em relação às matrizes de massa [M] e rigidez [K], calculando produtos escalares modais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de ortogonalidade modal",
                                  "subSteps": [
                                    "Estudar a definição de ortogonalidade nos modos de vibração natural: vetores modais φ_i e φ_j são ortogonais em relação a [M] se φ_i^T [M] φ_j = 0 para i ≠ j.",
                                    "Analisar a propriedade para a matriz de rigidez [K]: φ_i^T [K] φ_j = 0 para i ≠ j.",
                                    "Entender que para i = j, os produtos são não-nulos e usados para normalização modal.",
                                    "Revisar a equação de autovalores [K]φ = ω²[M]φ e como ela implica ortogonalidade.",
                                    "Exemplificar com um sistema de 2 graus de liberdade (DOF)."
                                  ],
                                  "verification": "O aluno explica verbalmente ou por escrito as propriedades de ortogonalidade para [M] e [K], citando as condições matemáticas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Dinâmica de Estruturas (ex: Clough & Penzien)",
                                    "Notas de aula sobre análise modal",
                                    "Software simbólico como SymPy ou MATLAB"
                                  ],
                                  "tips": "Visualize os modos como vetores em um espaço ponderado por [M] e [K], semelhantes a bases ortogonais em álgebra linear.",
                                  "learningObjective": "Compreender as propriedades matemáticas da ortogonalidade modal em sistemas MDOF.",
                                  "commonMistakes": [
                                    "Confundir ortogonalidade em [M] com [K]",
                                    "Ignorar a distinção entre i=j e i≠j",
                                    "Esquecer que as matrizes são simétricas positivas definidas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar as matrizes de massa [M], rigidez [K] e vetores modais",
                                  "subSteps": [
                                    "Obter ou montar as matrizes [M] e [K] para um sistema MDOF conhecido (ex: viga ou estrutura aeroespacial).",
                                    "Realizar análise modal para extrair frequências naturais ω_i e vetores modais φ_i (usando eigenvalores).",
                                    "Normalizar os vetores modais se necessário (ex: φ_i^T [M] φ_i = 1).",
                                    "Selecionar pares de modos i e j para verificação (incluindo i=j).",
                                    "Documentar todos os dados em uma tabela ou matriz."
                                  ],
                                  "verification": "Verificar se as matrizes e vetores foram corretamente montados comparando com solução analítica de um exemplo simples.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB ou Python (NumPy/SciPy)",
                                    "Exemplo de sistema 2-3 DOF de um livro-texto",
                                    "Planilha Excel para matrizes pequenas"
                                  ],
                                  "tips": "Use funções prontas como eig() no MATLAB para análise modal rápida e valide com cálculos manuais.",
                                  "learningObjective": "Preparar dados precisos para cálculos de ortogonalidade.",
                                  "commonMistakes": [
                                    "Erro na montagem de [M] ou [K] (ex: unidades inconsistentes)",
                                    "Vetores modais não normalizados adequadamente",
                                    "Selecionar modos incorretos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular os produtos escalares modais",
                                  "subSteps": [
                                    "Computar φ_i^T [M] φ_j para todos pares i,j.",
                                    "Computar φ_i^T [K] φ_j para os mesmos pares.",
                                    "Usar multiplicação matricial: primeiro [M]φ_j, depois produto escalar com φ_i.",
                                    "Automatizar com script se múltiplos modos.",
                                    "Registrar resultados em tabela (ex: matriz de ortogonalidade)."
                                  ],
                                  "verification": "Os cálculos manuais coincidem com resultados computacionais dentro de 1% de tolerância numérica.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": [
                                    "Calculadora matricial ou MATLAB/Python",
                                    "Papel e lápis para 2 DOF",
                                    "Script de verificação pronto"
                                  ],
                                  "tips": "Aproveite simetria: φ_i^T [M] φ_j = φ_j^T [M] φ_i para reduzir cálculos.",
                                  "learningObjective": "Executar cálculos precisos de produtos escalares modais.",
                                  "commonMistakes": [
                                    "Erro de transposição (φ_i^T vs φ_i)",
                                    "Problemas numéricos em software (escalonamento)",
                                    "Arredondamento excessivo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e verificar ortogonalidade",
                                  "subSteps": [
                                    "Verificar se φ_i^T [M] φ_j ≈ 0 para i ≠ j (tolerância 10^-6).",
                                    "Confirmar φ_i^T [K] φ_j ≈ 0 para i ≠ j e relacionar com ω_i² δ_ij.",
                                    "Analisar diagonal: valores modais de massa e rigidez.",
                                    "Discutir implicações para desacoplamento modal.",
                                    "Relatar conclusão: 'Ortogonalidade confirmada' ou identificar erros."
                                  ],
                                  "verification": "Produzir relatório com tabela de resultados e conclusão clara sobre ortogonalidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Tabela de resultados",
                                    "Critérios de tolerância numérica",
                                    "Software de plotagem para modos"
                                  ],
                                  "tips": "Use tolerâncias relativas para sistemas grandes; plote modos para intuição visual.",
                                  "learningObjective": "Interpretar resultados e validar ortogonalidade modal.",
                                  "commonMistakes": [
                                    "Tolerância inadequada para 'zero'",
                                    "Ignorar off-diagonais pequenas mas não-zero",
                                    "Não relacionar com teoria"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um sistema 2DOF com [M] = [[2,0],[0,1]] kg, [K] = [[3, -1],[-1,2]] N/m. Modos: φ1 = [1,1]^T / sqrt(3), φ2 = [1,-1]^T / sqrt(2). Calcule φ1^T [M] φ1 = 1, φ1^T [M] φ2 ≈ 0, φ1^T [K] φ1 = 2, φ1^T [K] φ2 ≈ 0, confirmando ortogonalidade.",
                              "finalVerifications": [
                                "Cálculo correto de produtos escalares para exemplo 2DOF.",
                                "Identificação precisa de ortogonalidade (zero off-diagonal).",
                                "Explicação da relação φ_i^T [K] φ_j = ω_i² φ_i^T [M] φ_j.",
                                "Relatório com tabela de resultados e tolerâncias.",
                                "Aplicação a um sistema 3DOF simples.",
                                "Discussão de normalização modal."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos (erro < 10^-4).",
                                "Compreensão conceitual demonstrada em explicações.",
                                "Uso correto de ferramentas computacionais.",
                                "Interpretação adequada de resultados numéricos.",
                                "Relatório estruturado e completo.",
                                "Identificação de erros comuns e correções."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Produtos escalares e autovalores.",
                                "Física: Teoria de vibrações livres.",
                                "Engenharia Mecânica: Análise de estruturas.",
                                "Computação: Programação numérica (MATLAB/Python).",
                                "Matemática Numérica: Tolerâncias e estabilidade."
                              ],
                              "realWorldApplication": "Na análise modal de asas de aeronaves ou fuselagens, verificar ortogonalidade permite desacoplar equações de movimento, facilitando simulações de aeroelasticidade e previsão de flutter em projetos da Embraer ou Boeing."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.2.3.1.3",
                            "name": "Normalizar modos de vibração",
                            "description": "Aplicar normalização modal (massa unitária) para obter matrizes modais identidade, facilitando a análise.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Modos de Vibração e Ortogonalidade",
                                  "subSteps": [
                                    "Estude as propriedades de ortogonalidade dos modos próprios em relação às matrizes de massa (M) e rigidez (K).",
                                    "Defina massa modal como o escalar μ_i = φ_i^T M φ_i, onde φ_i é o vetor de modo i.",
                                    "Explique a importância da normalização para obter massa modal unitária (μ_i = 1).",
                                    "Discuta como a normalização resulta em matrizes modais de identidade, facilitando o desacoplamento das equações.",
                                    "Revise exemplos simples de sistemas MDOF para ilustrar modos não normalizados."
                                  ],
                                  "verification": "Resuma em um parágrafo as propriedades de ortogonalidade e o propósito da normalização modal.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Notas de aula sobre análise modal",
                                    "Livro 'Dinâmica de Estruturas' (Clough & Penzien)",
                                    "Software MATLAB ou Python (NumPy)"
                                  ],
                                  "tips": [
                                    "Sempre verifique a simetria das matrizes M e K.",
                                    "Use notação consistente para transpostas (φ^T)."
                                  ],
                                  "learningObjective": "Compreender a base teórica da ortogonalidade e massa modal para preparar a normalização.",
                                  "commonMistakes": [
                                    "Confundir ortogonalidade com M e K invertida.",
                                    "Esquecer que modos são normalizados apenas em massa, não em rigidez."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Massas Modais para Modos Não Normalizados",
                                  "subSteps": [
                                    "Obtenha os vetores de modo próprios φ_i de uma análise modal prévia (ex: autovalores de [K - ω²M]φ = 0).",
                                    "Monte a matriz de massa M do sistema (ex: para uma estrutura aeroespacial discreta).",
                                    "Compute μ_i = φ_i^T M φ_i para cada modo i usando multiplicação matricial.",
                                    "Registre as massas modais para todos os modos relevantes (primeiros N modos).",
                                    "Valide os cálculos com propriedades conhecidas de sistemas simples."
                                  ],
                                  "verification": "Liste as massas modais calculadas e confirme que são escalares positivos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Matrizes M e K de um exemplo MDOF",
                                    "Calculadora matricial ou MATLAB",
                                    "Planilha Excel para verificação manual"
                                  ],
                                  "tips": [
                                    "Normalizar φ_i por uma componente (ex: φ_{i1}=1) antes para simplificar.",
                                    "Use loops em código para múltiplos modos."
                                  ],
                                  "learningObjective": "Dominar o cálculo preciso da massa modal para qualquer conjunto de modos.",
                                  "commonMistakes": [
                                    "Erro de indexação em φ_i^T.",
                                    "Usar φ_i não escalado corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Normalização Modal (Massa Unitária)",
                                  "subSteps": [
                                    "Determine o fator de escala para cada modo: α_i = 1 / sqrt(μ_i).",
                                    "Multiplique o vetor de modo por α_i: φ_i_norm = α_i * φ_i.",
                                    "Repita para todos os modos, formando a matriz modal Φ_norm = [φ_1_norm, φ_2_norm, ...].",
                                    "Confirme numericamente que μ_i_norm = φ_i_norm^T M φ_i_norm = 1 para cada i.",
                                    "Armazene os modos normalizados para uso posterior."
                                  ],
                                  "verification": "Verifique que todas as massas modais normalizadas são iguais a 1 (tolerância 1e-6).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código MATLAB/Python pronto para normalização",
                                    "Exemplo de modos de uma viga cantilever"
                                  ],
                                  "tips": [
                                    "Raiz quadrada no denominador garante unitariedade.",
                                    "Automatize com função para eficiência."
                                  ],
                                  "learningObjective": "Executar a normalização modal corretamente para obter modos com massa unitária.",
                                  "commonMistakes": [
                                    "Esquecer a raiz quadrada no fator α_i.",
                                    "Normalizar rigidez em vez de massa."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Matrizes Modais e Aplicar em Análise Desacoplada",
                                  "subSteps": [
                                    "Forme as matrizes modais: Massa Modal M_modal = Φ_norm^T M Φ_norm (deve ser I).",
                                    "Verifique Rigidez Modal K_modal = Φ_norm^T K Φ_norm (deve ser diagonal com ω_i²).",
                                    "Teste o desacoplamento das equações: M_modal^{-1} K_modal diagonal.",
                                    "Aplique em uma simulação simples de resposta dinâmica.",
                                    "Documente os resultados em um relatório curto."
                                  ],
                                  "verification": "Confirme que M_modal é identidade e K_modal é diagonal.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de análise modal (ANSYS ou código customizado)",
                                    "Relatório template"
                                  ],
                                  "tips": [
                                    "Use tolerâncias numéricas para flutuações de arredondamento.",
                                    "Visualize modos com animações."
                                  ],
                                  "learningObjective": "Validar a normalização e entender seu impacto na análise modal.",
                                  "commonMistakes": [
                                    "Ignorar erros numéricos em verificações.",
                                    "Confundir ordem dos modos."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um sistema MDOF de 2 DOF modelando uma asa simplificada: M = [[2,0],[0,1]], K = [[3, -1],[-1,2]], modos φ1=[1,1.414]^T (ω1=1), φ2=[1,-0.707]^T (ω2=√2). Compute μ1=φ1^T M φ1 ≈4, α1=1/√4=0.5, φ1_norm=[0.5,0.707]^T. Repita para φ2, obtendo Φ_norm tal que Φ_norm^T M Φ_norm = I.",
                              "finalVerifications": [
                                "Cada massa modal μ_i = 1.",
                                "Matriz de massa modal Φ^T M Φ = I (identidade).",
                                "Matriz de rigidez modal Φ^T K Φ diagonal com elementos ω_i².",
                                "Equações desacopladas: ÿ + Ω² y = Φ^T f.",
                                "Sem erros numéricos acima de 1e-6 em verificações.",
                                "Modos normalizados preservam forma original (escalados)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de μ_i (erro <1%).",
                                "Fator de escala α_i correto com raiz quadrada.",
                                "Verificação completa de matrizes modais identidade/diagonal.",
                                "Explicação clara dos benefícios na análise.",
                                "Aplicação correta em exemplo prático.",
                                "Identificação e correção de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Diagonalização de matrizes simétricas e vetores próprios.",
                                "Programação Computacional: Implementação numérica em MATLAB/Python (SciPy).",
                                "Física: Análise de osciladores harmônicos acoplados.",
                                "Engenharia de Controle: Transformadas modais para sistemas lineares.",
                                "Estatística: Análise de erros numéricos em simulações."
                              ],
                              "realWorldApplication": "Na aeroelasticidade de aeronaves, a normalização modal simplifica a análise de flutter e resposta vibracional em asas e fuselagens, permitindo predições precisas de instabilidades dinâmicas durante o projeto de aviões comerciais e militares."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "57.2.3.2",
                        "name": "Transformação para Coordenadas Modais",
                        "description": "Conversão das coordenadas físicas para coordenadas modais usando a matriz modal, decoplando as equações de movimento.",
                        "specificSkills": [
                          {
                            "id": "57.2.3.2.1",
                            "name": "Executar transformação modal",
                            "description": "Aplicar a matriz de modos [Φ] para transformar equações acopladas em coordenadas modais desacopladas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar as matrizes do sistema e a matriz de modos",
                                  "subSteps": [
                                    "Identificar e listar as matrizes de massa [M], amortecimento [C] e rigidez [K] do sistema MDOF.",
                                    "Obter a matriz de modos [Φ] a partir da análise modal prévia, garantindo que contenha os vetores modais normalizados.",
                                    "Verificar as propriedades ortogonais: [Φ]^T [M] [Φ] = [I] e [Φ]^T [K] [Φ] = [Ω]^2, onde [Ω] é diagonal.",
                                    "Confirmar dimensões: [Φ] deve ser n x n para n graus de liberdade.",
                                    "Documentar unidades e condições de contorno do sistema."
                                  ],
                                  "verification": "Matrizes [M], [C], [K] e [Φ] estão corretamente definidas e satisfazem ortogonalidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Matrizes do sistema fornecidas",
                                    "Software de álgebra linear (MATLAB ou Python com NumPy)",
                                    "Papel e calculadora matricial"
                                  ],
                                  "tips": "Sempre normalize os modos para simplificar cálculos; use software para verificação rápida.",
                                  "learningObjective": "Preparar com precisão os dados necessários para a transformação modal.",
                                  "commonMistakes": [
                                    "Usar modos não normalizados",
                                    "Ignorar dimensões incompatíveis",
                                    "Esquecer propriedades ortogonais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a transformação para coordenadas modais",
                                  "subSteps": [
                                    "Estabelecer a relação de transformação: {x} = [Φ] {q}, onde {x} são coordenadas físicas e {q} modais.",
                                    "Determinar a transformação inversa: {q} = [Φ]^T [M] {x} (para modos mass-ortogonais).",
                                    "Expressar velocidades e acelerações: {ẋ} = [Φ] {q̇} e {ẍ} = [Φ] {q̈}.",
                                    "Verificar se a transformação preserva a energia do sistema.",
                                    "Anotar as frequências modais ω_i dos valores próprios."
                                  ],
                                  "verification": "Relações {x} = [Φ] {q} e derivadas estão corretamente escritas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Matriz [Φ] do passo anterior",
                                    "Folha de anotações",
                                    "Software para multiplicação matricial"
                                  ],
                                  "tips": "Lembre-se: para modos ortonormais em massa, [Φ]^T [M] [Φ] = [I]; isso simplifica.",
                                  "learningObjective": "Compreender e aplicar a relação fundamental entre coordenadas físicas e modais.",
                                  "commonMistakes": [
                                    "Confundir {x} = [Φ] {q} com {q} = [Φ] {x}",
                                    "Esquecer transposição em [Φ]^T",
                                    "Não derivar velocidades/acelerações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Substituir nas equações de movimento originais",
                                  "subSteps": [
                                    "Partir das equações acopladas: [M] {ẍ} + [C] {ẋ} + [K] {x} = {F}.",
                                    "Substituir {ẍ}, {ẋ}, {x} pelas expressões modais e premultiplicar por [Φ]^T.",
                                    "Simplificar: obter [I] {q̈} + [Φ]^T [C] [Φ] {q̇} + [Ω]^2 {q} = [Φ]^T {F}.",
                                    "Verificar se as matrizes modais de massa e rigidez são diagonais; amortecimento pode não ser.",
                                    "Calcular forças modais {Q} = [Φ]^T {F}."
                                  ],
                                  "verification": "Equações resultantes estão desacopladas em massa e rigidez (matrizes diagonais).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Equações originais",
                                    "Software MATLAB/Python para substituição simbólica ou numérica",
                                    "Calculadora matricial"
                                  ],
                                  "tips": "Premultiplique por [Φ]^T primeiro para explorar ortogonalidade; pratique com sistema 2DOF.",
                                  "learningObjective": "Executar a substituição matricial para desacoplar as equações.",
                                  "commonMistakes": [
                                    "Esquecer premultiplicação por [Φ]^T",
                                    "Erro em derivadas de {q}",
                                    "Não simplificar usando [I] e [Ω]^2"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e interpretar as equações modais",
                                  "subSteps": [
                                    "Confirmar diagonalidade das matrizes modais de massa e rigidez.",
                                    "Analisar a matriz de amortecimento modal [C_modal] = [Φ]^T [C] [Φ]; se diagonal, sistema totalmente desacoplado.",
                                    "Resolver equações modais independentes para cada modo: m_i q̈_i + c_i q̇_i + k_i q_i = Q_i.",
                                    "Comparar frequências modais com análise inicial.",
                                    "Discutir implicações para resposta dinâmica do sistema."
                                  ],
                                  "verification": "Equações modais estão corretas e desacopladas; resultados batem com verificação numérica.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Equações do passo 3",
                                    "Software para eigenvalores",
                                    "Gráficos de modos"
                                  ],
                                  "tips": "Use plot de modos para visualização; teste com excitação modal seletiva.",
                                  "learningObjective": "Validar a transformação e interpretar resultados em coordenadas modais.",
                                  "commonMistakes": [
                                    "Assumir amortecimento sempre diagonal",
                                    "Ignorar modos residuais",
                                    "Não comparar com original"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema 2DOF com [M] = [[2,0],[0,1]] kg, [K] = [[3, -1],[-1,2]] N/m, [Φ] = [[0.85, -0.53],[0.53, 0.85]] (modos normalizados). Substitua {x} = [Φ]{q} nas equações [M]{ẍ} + [K]{x} = 0, obtenha q̈_1 + (1.2)^2 q_1 = 0 e q̈_2 + (2.1)^2 q_2 = 0 (desacopladas).",
                              "finalVerifications": [
                                "Matrizes modais de massa e rigidez são identidade e diagonal, respectivamente.",
                                "Frequências modais coincidem com análise eigen.",
                                "Transformação inversa recupera coordenadas físicas corretamente.",
                                "Energia total preservada na transformação.",
                                "Forças modais calculadas corretamente para carga externa.",
                                "Equações modais independentes para cada modo."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas operações matriciais (multiplicação, transposição).",
                                "Correta aplicação de ortogonalidade para simplificação.",
                                "Identificação de graus de desacoplamento (massa, rigidez, amortecimento).",
                                "Verificação numérica ou simbólica sem erros aritméticos.",
                                "Interpretação física dos resultados modais.",
                                "Documentação clara dos passos e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: operações com matrizes, autovalores e autovetores.",
                                "Física: dinâmica de vibrações e equações de Lagrange.",
                                "Programação: implementação em MATLAB/Python para análise numérica.",
                                "Engenharia Mecânica: modelagem de estruturas MDOF.",
                                "Controle de Sistemas: modos dominantes em resposta transitória."
                              ],
                              "realWorldApplication": "Na aeroelasticidade de aeronaves, transforma equações acopladas de uma asa flexível em modais desacoplados para prever instabilidades como flutter, permitindo simulações eficientes de vibrações em fuselagem ou hélices."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.2.3.2.2",
                            "name": "Formar matrizes modais",
                            "description": "Construir as matrizes modais de massa, rigidez e amortecimento (Rayleigh) após transformação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Obter e preparar a matriz de modos modais Φ",
                                  "subSteps": [
                                    "Realize a análise de autovalores para as matrizes de massa M e rigidez K do sistema MDOF, obtendo frequências naturais ω e vetores modais não normalizados.",
                                    "Monte a matriz Φ cujas colunas são os vetores modais φ_i para i=1 a n (número de graus de liberdade).",
                                    "Verifique a dimensionalidade: Φ deve ser n x n para sistema não amortecido ou aproximado.",
                                    "Armazene as frequências ω em um vetor diagonal Ω = diag(ω_1, ω_2, ..., ω_n).",
                                    "Confirme que os modos estão ordenados por frequência crescente."
                                  ],
                                  "verification": "Matriz Φ é quadrada n x n, det(Φ) ≠ 0, e modos ordenados por ω crescente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Matrizes M e K do sistema físico",
                                    "Software como MATLAB ou Python (NumPy/SciPy)",
                                    "Calculadora para sistemas pequenos"
                                  ],
                                  "tips": "Use funções prontas como eig() no MATLAB para eficiência em sistemas grandes.",
                                  "learningObjective": "Compreender como extrair modos modais de equações de movimento desacopladas.",
                                  "commonMistakes": [
                                    "Esquecer de ordenar modos por frequência",
                                    "Incluir modos rígidos sem tratamento especial",
                                    "Usar Φ transposta incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Normalizar os vetores modais usando o quociente de Rayleigh",
                                  "subSteps": [
                                    "Para cada modo i, calcule a massa modal μ_i = φ_i^T M φ_i.",
                                    "Normalize φ_i ← φ_i / sqrt(μ_i) para que μ_i = 1.",
                                    "Verifique o quociente de Rayleigh: ω_i² ≈ (φ_i^T K φ_i) / (φ_i^T M φ_i) = φ_i^T K φ_i (já que massa modal=1).",
                                    "Atualize a matriz Φ com os modos normalizados.",
                                    "Confirme rigidez modal κ_i = φ_i^T K φ_i ≈ ω_i²."
                                  ],
                                  "verification": "Para cada modo, φ_i^T M φ_i = 1 e φ_i^T K φ_i = ω_i².",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Matriz Φ não normalizada",
                                    "Matrizes M e K",
                                    "Script de programação para loop sobre modos"
                                  ],
                                  "tips": "Automatize com loop for em código para evitar erros manuais em múltiplos modos.",
                                  "learningObjective": "Dominar a normalização modal para decoupling unitário.",
                                  "commonMistakes": [
                                    "Normalizar pela norma euclidiana em vez de massa modal",
                                    "Esquecer de atualizar todas as colunas de Φ",
                                    "Erro de sinal no sqrt"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formar as matrizes modais de massa e rigidez",
                                  "subSteps": [
                                    "Calcule a matriz modal de massa M_modal = Φ^T M Φ.",
                                    "Calcule a matriz modal de rigidez K_modal = Φ^T K Φ.",
                                    "Verifique que M_modal é identidade (ou diagonal unitária) devido à normalização.",
                                    "Confirme que K_modal é diagonal com elementos κ_ii = ω_i².",
                                    "Armazene em formato diagonal para eficiência computacional."
                                  ],
                                  "verification": "M_modal ≈ I (identidade), K_modal diagonal com diag(ω²).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Φ normalizada",
                                    "Matrizes M e K originais",
                                    "Ferramentas matriciais (MATLAB mtimes ou @)"
                                  ],
                                  "tips": "Use multiplicação matricial eficiente; para sistemas grandes, aproveite simetria.",
                                  "learningObjective": "Aplicar transformação modal para diagonalizar matrizes físicas.",
                                  "commonMistakes": [
                                    "Erro na transposição: usar Φ M Φ em vez de Φ^T",
                                    "Não verificar diagonalidade",
                                    "Arredondamento numérico ignorado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formar a matriz modal de amortecimento Rayleigh",
                                  "subSteps": [
                                    "Defina o modelo Rayleigh: C = α M + β K, onde α e β são escalares obtidos de frequências de amortecimento conhecidas.",
                                    "Calcule α e β usando duas frequências de referência: α = 2 ξ1 ω1 - β ω1², resolvendo sistema para ξ1, ξ2 conhecidos.",
                                    "Forme C_modal = Φ^T C Φ = α (Φ^T M Φ) + β (Φ^T K Φ) = α M_modal + β K_modal.",
                                    "Como M_modal = I e K_modal diagonal, C_modal será diagonal com γ_ii = α + β ω_i².",
                                    "Verifique que os fatores de amortecimento modais ξ_i = γ_ii / (2 ω_i) aproximam os valores físicos."
                                  ],
                                  "verification": "C_modal diagonal, ξ_i consistentes com modelo Rayleigh (±10% de erro típico).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "α e β do modelo Rayleigh",
                                    "M_modal e K_modal",
                                    "Vetores de frequências ω"
                                  ],
                                  "tips": "Escolha frequências dominantes para α e β minimizando erro em todo espectro.",
                                  "learningObjective": "Integrar amortecimento proporcional em coordenadas modais.",
                                  "commonMistakes": [
                                    "Confundir α e β",
                                    "Aplicar Φ^T C Φ sem simplificar para Rayleigh",
                                    "Ignorar que C_modal é diagonal apenas se Rayleigh"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema 2DOF de uma viga cantilever com M = diag(1,1) kg, K = [[2,-1],[-1,1]] N/m, ω1=1 rad/s, φ1=[1,1.414]^T normalizado, ω2=2.414 rad/s, φ2=[1,-0.707]^T. Após normalização, M_modal = I, K_modal=diag(1,5.828). Com Rayleigh α=0.1, β=0.01, C_modal=diag(0.11, 0.158).",
                              "finalVerifications": [
                                "M_modal é identidade ou diagonal unitária.",
                                "K_modal diagonal com elementos ω_i².",
                                "C_modal diagonal com γ_ii = α + β ω_i².",
                                "Ortogonalidade: φ_i^T M φ_j = 0 para i≠j.",
                                "Fatores modais ξ_i consistentes com Rayleigh.",
                                "Energia modal preservada: trace(M_modal)=trace(M)."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nas matrizes modais (±1% erro).",
                                "Correta normalização (massa modal=1).",
                                "Diagonalidade verificada (off-diagonais <1e-6).",
                                "Cálculo correto de α/β para Rayleigh.",
                                "Verificação de propriedades modais.",
                                "Eficiência computacional demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Linear: autovalores, diagonalização.",
                                "Programação Numérica: manipulação matricial em Python/MATLAB.",
                                "Física: princípios de vibrações e amortecimento.",
                                "Engenharia Computacional: simulações FEM.",
                                "Controle de Sistemas: redução modal para controle."
                              ],
                              "realWorldApplication": "Em análise aeroelástica de asas de aeronaves, as matrizes modais permitem simular respostas vibratórias desacopladas, prevendo flutter e fadiga estrutural em projetos como o Boeing 787."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.2.3.2.3",
                            "name": "Projetar forças de excitação modal",
                            "description": "Calcular as forças modais generalizadas a partir das forças físicas usando ortogonalidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Análise Modal e Ortogonalidade",
                                  "subSteps": [
                                    "Estude a definição de modos normais e vetores modais φ_i para sistemas MDOF.",
                                    "Revise a propriedade de ortogonalidade: φ_i^T * M * φ_j = 0 para i ≠ j, e φ_i^T * K * φ_j = 0.",
                                    "Entenda as forças físicas F(t) aplicadas nos graus de liberdade do sistema.",
                                    "Identifique a transformação modal: forças generalizadas Q_i(t) = φ_i^T * F(t).",
                                    "Pratique com um exemplo simples de 2 DOF para visualizar a projeção."
                                  ],
                                  "verification": "Resuma em um diagrama ou parágrafo como a ortogonalidade garante a desacoplagem modal.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de dinâmica estrutural (ex: Clough & Penzien), notas de aula sobre MDOF, calculadora simbólica como MATLAB ou Python (SymPy).",
                                  "tips": "Use animações de modos para visualizar a ortogonalidade em movimento.",
                                  "learningObjective": "Compreender a base teórica da projeção de forças físicas para coordenadas modais via ortogonalidade.",
                                  "commonMistakes": "Confundir massa generalizada com forças generalizadas; ignorar normalização dos modos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o Sistema e Representar Forças Físicas",
                                  "subSteps": [
                                    "Descreva o sistema MDOF: número de DOF, matrizes de massa M e rigidez K resolvidas.",
                                    "Obtenha os vetores modais φ_i dos autovalores/autovetores.",
                                    "Especifique as forças físicas F(t) em cada DOF (ex: cargas puntiformes, distribuídas discretizadas).",
                                    "Normalizar os modos se necessário (ortogonalidade com M).",
                                    "Monte a matriz de forças F como vetor coluna para compatibilidade."
                                  ],
                                  "verification": "Confirme que φ_i^T * M * φ_i = 1 (normalização) e dimensões de F combinam com DOF.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de análise modal (ANSYS, MATLAB Vibration Toolbox), planilha para matrizes.",
                                  "tips": "Discritize cargas distribuídas em forças nodais equivalentes para simplicidade.",
                                  "learningObjective": "Preparar dados do sistema para cálculo preciso das forças modais.",
                                  "commonMistakes": "Usar modos não normalizados levando a escalas erradas; mismatch de dimensões em F."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Forças Modais Generalizadas Q_i",
                                  "subSteps": [
                                    "Para cada modo i relevante (primeiros modos dominantes), compute Q_i(t) = φ_i^T * F(t).",
                                    "Realize o produto matricial: transposta do modo vezes vetor de força.",
                                    "Se F(t) for harmônica, Q_i(t) será harmônica na mesma frequência.",
                                    "Calcule para múltiplos modos e plote Q_i vs tempo ou frequência.",
                                    "Verifique soma de contribuições modais aproximando movimento físico."
                                  ],
                                  "verification": "Q_i deve ser zero para modos ortogonais à excitação (teste com F alinhado a um modo).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB/Python (NumPy para multiplicação matricial), exemplo numérico de viga cantilever.",
                                  "tips": "Automatize com loop em código para múltiplos modos e tempos.",
                                  "learningObjective": "Executar a projeção modal de forças com precisão numérica.",
                                  "commonMistakes": "Erro de transposta (φ_i * F ao invés de φ_i^T * F); truncar modos insuficientes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Interpretar Resultados Modais",
                                  "subSteps": [
                                    "Compare resposta modal com solução física via transformação inversa: u ≈ Σ φ_i q_i.",
                                    "Analise participação modal: |Q_i| indica excitação por modo.",
                                    "Teste sensibilidade a truncagem de modos altos.",
                                    "Documente equações e resultados em relatório.",
                                    "Discuta implicações para resposta dinâmica."
                                  ],
                                  "verification": "Erro de reconstrução < 5% para primeiros 3 modos em comparação com solução exata.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Gráficos MATLAB (plot de modos e respostas), relatório template.",
                                  "tips": "Use critérios de convergência modal (participação cumulativa >95%).",
                                  "learningObjective": "Interpretar forças modais no contexto de análise dinâmica real.",
                                  "commonMistakes": "Interpretar Q_i sem contexto de massa modal; ignorar amortecimento."
                                }
                              ],
                              "practicalExample": "Para uma viga cantilever aeroespacial com 10 elementos finitos (10 DOF), aplique carga aerodinâmica distribuída F(z,t) = p(z) sin(ωt). Compute φ_1 (primeiro modo flexão), então Q_1(t) = φ_1^T F(t). Resultado: Q_1 ≈ 0.85 p L sin(ωt), onde L é comprimento, validado por simulação FEM.",
                              "finalVerifications": [
                                "Q_i = 0 para modos ortogonais à direção de F.",
                                "Normalização: φ_i^T M φ_i = 1.",
                                "Reconstrução: movimento físico ≈ soma φ_i q_i com erro <2%.",
                                "Participação modal: soma |Γ_i| >90% para excitação total.",
                                "Consistência temporal: Q_i harmônica se F harmônica.",
                                "Dimensões corretas: Q_i escalar por modo."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos de Q_i (erro <1%).",
                                "Correta aplicação de ortogonalidade e normalização.",
                                "Interpretação física das forças modais dominantes.",
                                "Validação via reconstrução modal.",
                                "Documentação clara de passos e código.",
                                "Eficiência computacional para sistemas grandes."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: produtos matriciais e autovalores.",
                                "Física: Princípios de dinâmica newtoniana em coordenadas desacopladas.",
                                "Engenharia Computacional: Métodos numéricos FEM e simulações.",
                                "Controle de Sistemas: Excitação em controle modal ativo.",
                                "Aerodinâmica: Cargas fluid-estrutura em flutter."
                              ],
                              "realWorldApplication": "Em análise de flutter de asas de aeronaves, projetar forças modais de pressão aerodinâmica permite simular respostas desacopladas, otimizando design contra instabilidades vibratórias em voo supersônico."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "57.2.3.3",
                        "name": "Solução das Equações Modais Decopladas",
                        "description": "Resolução independente das equações modais para diferentes tipos de excitação em estruturas aeroespaciais.",
                        "specificSkills": [
                          {
                            "id": "57.2.3.3.1",
                            "name": "Resolver resposta a condições iniciais",
                            "description": "Determinar a resposta livre em coordenadas modais para condições iniciais de deslocamento e velocidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar condições iniciais físicas e propriedades modais",
                                  "subSteps": [
                                    "Revise as condições iniciais dadas: vetor de deslocamentos iniciais u(0) e velocidades iniciais \u001d(u)(0).",
                                    "Obtenha a matriz de modos Φ (vetores modais normalizados em massa) e as frequências naturais ω_i para cada modo i.",
                                    "Confirme que os modos estão normalizados: φ_i^T M φ_j = δ_ij, onde M é a matriz de massa.",
                                    "Liste todos os modos relevantes (geralmente os primeiros N modos para aproximação).",
                                    "Anote as dimensões do sistema (número de graus de liberdade n)."
                                  ],
                                  "verification": "Verifique se u(0), \u001d(u)(0), Φ e ω_i estão corretamente listados e unidades consistentes.",
                                  "estimatedTime": "15-20 minutes",
                                  "materials": [
                                    "Matriz de massa M",
                                    "Matriz de modos Φ",
                                    "Frequências ω_i",
                                    "Cond. iniciais u(0) e \u001d(u)(0)",
                                    "Calculadora ou software como MATLAB"
                                  ],
                                  "tips": "Sempre verifique a normalização dos modos para evitar erros de escala.",
                                  "learningObjective": "Compreender a ponte entre coordenadas físicas e modais.",
                                  "commonMistakes": [
                                    "Esquecer normalização em massa",
                                    "Confundir u(0) com q(0)",
                                    "Usar modos não ortogonais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular coordenadas modais iniciais de deslocamento q_i(0)",
                                  "subSteps": [
                                    "Para cada modo i: compute q_i(0) = φ_i^T M u(0).",
                                    "Multiplique o vetor modal φ_i pela matriz M e pelo vetor u(0).",
                                    "Some os componentes escalares resultantes.",
                                    "Repita para todos os modos i = 1 a N.",
                                    "Armazene em vetor q(0) = [q_1(0), q_2(0), ..., q_N(0)]^T."
                                  ],
                                  "verification": "Verifique q(0) ≈ Φ^T M u(0) para o vetor completo; erro deve ser <1%.",
                                  "estimatedTime": "20-25 minutes",
                                  "materials": [
                                    "Matrizes M, Φ, u(0)",
                                    "Software de álgebra linear (MATLAB, Python NumPy)"
                                  ],
                                  "tips": "Use transposição correta: φ_i é coluna, φ_i^T é linha.",
                                  "learningObjective": "Dominar a projeção modal para deslocamentos iniciais.",
                                  "commonMistakes": [
                                    "Erro na multiplicação matricial",
                                    "Não transpor φ_i",
                                    "Ignorar massa M"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular coordenadas modais iniciais de velocidade \u001d(q_i)(0)",
                                  "subSteps": [
                                    "Para cada modo i: compute \u001d(q_i)(0) = φ_i^T M \u001d(u)(0).",
                                    "Aplique a mesma projeção usada para q_i(0), mas com \u001d(u)(0).",
                                    "Repita para todos os modos i = 1 a N.",
                                    "Armazene em vetor \u001d(q)(0) = [\u001d(q_1)(0), ..., \u001d(q_N)(0)]^T.",
                                    "Verifique se velocidades zero em físicas implicam \u001d(q)(0)=0."
                                  ],
                                  "verification": "Confirme \u001d(q)(0) ≈ Φ^T M \u001d(u)(0); teste com \u001d(u)(0)=0.",
                                  "estimatedTime": "15-20 minutes",
                                  "materials": [
                                    "Matrizes M, Φ, \u001d(u)(0)",
                                    "Software de álgebra linear"
                                  ],
                                  "tips": "Reutilize código do Step 2 para eficiência.",
                                  "learningObjective": "Aplicar projeção modal consistentemente para velocidades.",
                                  "commonMistakes": [
                                    "Confundir com q(0)",
                                    "Dividir por ω_i prematuramente",
                                    "Erros de sinal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular a resposta modal livre q(t) para cada modo",
                                  "subSteps": [
                                    "Para cada i: escreva q_i(t) = q_i(0) cos(ω_i t) + [\u001d(q_i)(0) / ω_i] sin(ω_i t).",
                                    "Substitua os valores computados de q_i(0) e \u001d(q_i)(0).",
                                    "Monte o vetor q(t) = [q_1(t), q_2(t), ..., q_N(t)]^T.",
                                    "Opcionalmente, obtenha resposta física u(t) = Φ q(t) para validação.",
                                    "Expresse em forma simbólica ou numérica para t específico."
                                  ],
                                  "verification": "Avalie em t=0: q(0) deve coincidir; derivada em t=0: \u001d(q)(0) correto.",
                                  "estimatedTime": "25-30 minutes",
                                  "materials": [
                                    "Valores q(0), \u001d(q)(0), ω_i",
                                    "Software de plotagem (MATLAB ode45 para simulação)"
                                  ],
                                  "tips": "Lembre: solução geral de \u001d\u001d(q) + ω² q = 0.",
                                  "learningObjective": "Derivar e aplicar solução analítica de oscilador uncoupled.",
                                  "commonMistakes": [
                                    "Esquecer /ω_i no termo sin",
                                    "Usar sen/cos invertidos",
                                    "Soma errada de modos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema 2DOF (m1=m2=1kg, k1=k2=2kN/m, k_c=0): modos φ1=[0.85,0.53]^T, φ2=[-0.53,0.85]^T (norm. massa), ω1=1.25 rad/s, ω2=1.85 rad/s. Condições: u(0)=[0.01,0]^T m, \u001d(u)(0)=[0,0.05]^T m/s. Compute q1(0)=φ1^T M u(0)≈0.0073, q2(0)≈0.0027; \u001d(q1)(0)≈0.0265, \u001d(q2)(0)≈0.0425. Então q1(t)=0.0073 cos(1.25t) + (0.0265/1.25) sin(1.25t), similar para q2(t).",
                              "finalVerifications": [
                                "q(t=0) = q(0) computado exatamente.",
                                "\u001d(q)(t=0) = \u001d(q)(0) computado.",
                                "Resposta satisfaz equações modais decopladas: \u001d\u001d(q_i) + ω_i² q_i = 0.",
                                "Energia modal conservada: (1/2) \u001d(q_i)^2 + (1/2) ω_i² q_i^2 constante.",
                                "Aproximação modal captura >95% da resposta física em t iniciais.",
                                "Sem crescimento artificial (diferente de forçada)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na projeção modal (erro <0.1%).",
                                "Correta formulação da solução livre (termos cos/sin exatos).",
                                "Verificação inicial correta (q(0), \u001d(q)(0)).",
                                "Uso apropriado de N modos (convergência).",
                                "Expressão clara de q(t) simbólica/numérica.",
                                "Identificação de erros potenciais mitigados."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Projeção ortogonal e decomposição modal.",
                                "Cálculo Diferencial: Solução de EDOs lineares homogêneas.",
                                "Física: Conservação de energia em osciladores desacoplados.",
                                "Programação: Implementação numérica em Python/MATLAB para validação.",
                                "Engenharia de Controle: Estados iniciais em análise de estabilidade."
                              ],
                              "realWorldApplication": "Em aeroelasticidade, prever vibrações transitórias em asas de aeronaves após manobras ou turbulência inicial, evitando fadiga estrutural; usado em simulações de lançamento de satélites para resposta de painéis flexíveis a vibrações iniciais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.2.3.3.2",
                            "name": "Calcular resposta harmônica modal",
                            "description": "Obter a resposta em regime permanente para excitações harmônicas usando admitâncias modais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os dados modais do sistema",
                                  "subSteps": [
                                    "Identifique as frequências naturais modais (ω_r) e os vetores modais (φ_r) obtidos da análise modal prévia.",
                                    "Verifique a ortogonalidade dos modos: confirme que φ_r^T M φ_s = 0 para r ≠ s e φ_r^T M φ_r = 1 (modos normalizados em massa).",
                                    "Liste as massas modais (μ_r = φ_r^T M φ_r) e os coeficientes de amortecimento modal (ζ_r).",
                                    "Registre a matriz de rigidez e massa originais para referência cruzada.",
                                    "Documente o número de graus de liberdade (N) e modos relevantes a considerar (geralmente os primeiros N modos)."
                                  ],
                                  "verification": "Confirme que todos os modos têm frequências, vetores e propriedades normalizadas corretas comparando com resultados de software como MATLAB ou ANSYS.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Matriz de massa M e rigidez K do sistema",
                                    "Resultados de análise modal (frequências e modos)",
                                    "Software de cálculo numérico (MATLAB, Python com NumPy)"
                                  ],
                                  "tips": "Sempre normalize os modos em massa para simplificar cálculos; use funções prontas como eig() no MATLAB para validação.",
                                  "learningObjective": "Compreender e preparar os parâmetros modais essenciais para análise harmônica.",
                                  "commonMistakes": [
                                    "Esquecer de normalizar modos",
                                    "Incluir modos irrelevantes com frequências muito altas",
                                    "Confundir frequências naturais com circulares"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a excitação harmônica e forças modais",
                                  "subSteps": [
                                    "Especifique a excitação como F(t) = F_0 Re{ e^{iωt} }, onde F_0 é o vetor de amplitudes complexas e ω é a frequência de excitação.",
                                    "Projete as forças modais: Q_r(t) = φ_r^T F(t) = φ_r^T F_0 Re{ e^{iωt} } para cada modo r.",
                                    "Identifique a amplitude modal complexa Q_r0 = φ_r^T F_0.",
                                    "Verifique se a excitação está no regime permanente (ignorar transitórios).",
                                    "Escolha ω próxima a uma frequência modal para demonstrar ressonância."
                                  ],
                                  "verification": "Calcule Q_r0 para todos os modos e confirme que soma modal preserva a força total: ∑ Q_r0 φ_r ≈ F_0.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Vetor de força F_0",
                                    "Vetores modais φ_r",
                                    "Calculadora ou script Python/MATLAB"
                                  ],
                                  "tips": "Use números complexos desde o início para evitar erros de seno/cosseno; represente como F_0 e^{iωt}.",
                                  "learningObjective": "Dominar a projeção modal da excitação harmônica.",
                                  "commonMistakes": [
                                    "Usar forças reais em vez de complexas",
                                    "Esquecer o produto φ_r^T F_0",
                                    "Incluir fases incorretas na excitação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular as admitâncias modais",
                                  "subSteps": [
                                    "Para cada modo r, compute a admitância modal H_r(ω) = 1 / (k_r - ω² m_r + i ω c_r), onde k_r = μ_r ω_r², m_r = μ_r, c_r = 2 ζ_r ω_r μ_r.",
                                    "Simplifique para forma padrão: H_r(ω) = 1 / μ_r (ω_r² - ω² + i 2 ζ_r ω_r ω).",
                                    "Calcule magnitude |H_r(ω)| e fase arg(H_r(ω)) separadamente se necessário.",
                                    "Verifique limite em ω=0: H_r(0) ≈ 1/k_r (estática).",
                                    "Compare com função de transferência modal para consistência."
                                  ],
                                  "verification": "Plote |H_r(ω)| vs ω e confirme pico em ω_r com largura proporcional a ζ_r.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Propriedades modais (ω_r, ζ_r, μ_r)",
                                    "Fórmulas de admitância modal",
                                    "Gráficos em MATLAB (bode plot)"
                                  ],
                                  "tips": "Use números complexos no denominador; divida por μ_r para normalização.",
                                  "learningObjective": "Calcular corretamente as admitâncias modais para excitação harmônica.",
                                  "commonMistakes": [
                                    "Erro no sinal do termo inercial (-ω²)",
                                    "Confundir viscoso com histerético",
                                    "Esquecer fator μ_r"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Obter respostas modais e resposta total",
                                  "subSteps": [
                                    "Calcule a resposta modal η_r(t) = Re{ η_r0 e^{iωt} }, onde η_r0 = H_r(ω) Q_r0.",
                                    "Some as contribuições modais: x(t) = ∑ φ_r η_r(t).",
                                    "Extraia amplitudes e fases da resposta total complexa X(ω) = ∑ φ_r H_r(ω) Q_r0.",
                                    "Valide truncando modos altos: verifique convergência.",
                                    "Plote resposta em tempo e frequência para visualização."
                                  ],
                                  "verification": "Compare resposta total com solução direta (equações acopladas) para sistema pequeno (2-3 DOF).",
                                  "estimatedTime": "1 hora 30 minutos",
                                  "materials": [
                                    "Admitâncias H_r(ω)",
                                    "Forças modais Q_r0",
                                    "Software para soma modal e plotagem"
                                  ],
                                  "tips": "Mantenha tudo em domínio complexo até o final; use Re{} apenas para tempo real.",
                                  "learningObjective": "Sintetizar a resposta física a partir de contribuições modais.",
                                  "commonMistakes": [
                                    "Não somar modais corretamente",
                                    "Usar seno em vez de forma complexa",
                                    "Ignorar contribuições de modos próximos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e interpretar resultados",
                                  "subSteps": [
                                    "Calcule erro de truncagem modal e justifique número de modos usados.",
                                    "Analise sensibilidade a ω próximo a ω_r (ressonância).",
                                    "Compare magnitude máxima com fórmula aproximada para modo dominante.",
                                    "Documente fases relativas entre DOFs.",
                                    "Gere relatório com gráficos de resposta."
                                  ],
                                  "verification": "Resposta estática (ω=0) deve coincidir com K^{-1} F_0.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Resultados anteriores",
                                    "Solver direto para validação",
                                    "Ferramentas de plotagem"
                                  ],
                                  "tips": "Sempre valide com caso conhecido (1 DOF) antes de MDOF.",
                                  "learningObjective": "Interpretar e validar a resposta harmônica modal.",
                                  "commonMistakes": [
                                    "Truncar poucos modos",
                                    "Ignorar validação estática",
                                    "Interpretar fase incorretamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema de 2 DOF (viga cantilever simples) com M = diag(1,1) kg, K apropriada dando ω1=1 rad/s, ω2=3 rad/s, ζ=0.05, excitação F(t)=[100 cos(1.2t), 0]^T N. Calcule modos, projete Q_r0, admitâncias H_r(1.2), respostas η_r0 e x(t). Resultado esperado: pico na primeira massa devido à proximidade de frequências.",
                              "finalVerifications": [
                                "Admitâncias mostram pico em ω_r com atenuação por ζ_r.",
                                "Resposta total converge com 90% dos modos.",
                                "Estática (ω=0) bate com solução exata.",
                                "Fases modais diferem ~180° em anti-ressonância.",
                                "Magnitude em ressonância ~1/(2ζ_r) vezes estática.",
                                "Gráficos de FRF (Função de Resposta em Frequência) são suaves."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erro <1% vs solução direta.",
                                "Uso correto de números complexos em todos cálculos.",
                                "Justificativa de truncagem modal.",
                                "Interpretação física das respostas (ressonância, fase).",
                                "Clareza em documentação e gráficos.",
                                "Eficiência computacional (evitar loops desnecessários)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra complexa e funções de transferência.",
                                "Engenharia de Controle: Análise de frequência em laços fechados.",
                                "Física: Oscilações forçadas e princípios de superposição modal.",
                                "Programação: Implementação numérica em Python/MATLAB.",
                                "Engenharia Mecânica: Vibrações em estruturas aeroespaciais."
                              ],
                              "realWorldApplication": "Em aeronaves, calcular respostas harmônicas modais para prever vibrações induzidas por turbulência ou hélices em fuselagem/asa, evitando fadiga e flutter crítico durante certificação FAA/EASA."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.2.3.3.3",
                            "name": "Aplicar solução para excitações arbitrárias",
                            "description": "Usar convolução ou superposição modal para respostas a excitações periódicas ou arbitrárias em sistemas MDOF.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar as equações modais decopladas e representar a excitação arbitrária",
                                  "subSteps": [
                                    "Revisar as equações modais decopladas: η̈_r + 2ζ_r ω_r η̇_r + ω_r² η_r = Q_r(t), onde Q_r(t) é a força modal.",
                                    "Identificar a excitação arbitrária f(t) no espaço físico e projetá-la nos modos: Q_r(t) = φ_r^T M f(t).",
                                    "Verificar ortonormalidade dos modos para garantir decoplamento.",
                                    "Discretizar f(t) se necessário para simulações numéricas.",
                                    "Documentar unidades e condições iniciais (η(0), η̇(0))."
                                  ],
                                  "verification": "Confirme que Q_r(t) está corretamente projetado comparando com forças modais conhecidas para casos simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta, software MATLAB ou Python (NumPy/SciPy), matrizes modais do sistema MDOF.",
                                  "tips": "Sempre normalize os modos de massa para simplificar Q_r(t).",
                                  "learningObjective": "Compreender como excitações físicas se traduzem em forças modais decopladas.",
                                  "commonMistakes": "Esquecer a projeção φ_r^T M ou usar modos não ortonormais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escolher e configurar o método de solução: Convolução ou Superposição Modal",
                                  "subSteps": [
                                    "Avaliar natureza de f(t): periódica (superposição modal) ou transitória arbitrária (convolução de Duhamel).",
                                    "Para convolução: h_r(τ) = (1/ω_rd) e^{-ζ_r ω_r τ} sin(ω_rd τ), onde ω_rd = ω_r √(1-ζ_r²).",
                                    "Para superposição: expandir f(t) em série de Fourier se periódica.",
                                    "Implementar integral de convolução: η_r(t) = ∫ h_r(t-τ) Q_r(τ) dτ + termos iniciais.",
                                    "Decidir entre analítico ou numérico (ex: método de Newmark para integração)."
                                  ],
                                  "verification": "Teste com excitação unitária (delta de Dirac) para obter funções de influência corretas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora simbólica (SymPy), tabelas de funções de resposta unitária.",
                                  "tips": "Use convolução numérica com trapezoidal para excitações discretas.",
                                  "learningObjective": "Selecionar e formular o método apropriado para excitações arbitrárias.",
                                  "commonMistakes": "Confundir convolução com superposição ou ignorar amortecimento."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular as respostas modais individuais",
                                  "subSteps": [
                                    "Resolver numericamente ou analiticamente cada η_r(t) para todos os modos relevantes (geralmente 5-10 primeiros).",
                                    "Incluir condições iniciais: η_r(0) e η̇_r(0) via modais iniciais.",
                                    "Plotar respostas modais para identificar modos dominantes.",
                                    "Verificar estabilidade: respostas devem decair se ζ_r > 0.",
                                    "Calcular velocidades e acelerações modais se necessário."
                                  ],
                                  "verification": "Compare com solução exata para sistema SDOF equivalente.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "MATLAB/SciPy para integração numérica, gráficos de resposta temporal.",
                                  "tips": "Filtre modos com baixa participação modal para eficiência computacional.",
                                  "learningObjective": "Computar respostas decopladas com precisão para múltiplos modos.",
                                  "commonMistakes": "Truncar modos insuficientemente ou erros em integração numérica."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reconstruir a resposta física total e validar",
                                  "subSteps": [
                                    "Superpor respostas: x(t) = Φ η(t), onde Φ é matriz de modos.",
                                    "Calcular quantidades físicas: deslocamentos, tensões via [B] Φ η(t).",
                                    "Verificar equilíbrio: M ẍ + C ẋ + K x ≈ f(t).",
                                    "Analisar energia ou espectro de resposta.",
                                    "Documentar limitações (ex: linearidade assumida)."
                                  ],
                                  "verification": "Resíduo de equilíbrio < 1% da norma de f(t).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de visualização (MATLAB plots), matrizes M, C, K.",
                                  "tips": "Use modos complexos para rotações se aplicável.",
                                  "learningObjective": "Integrar respostas modais em solução física coerente.",
                                  "commonMistakes": "Erro na matriz Φ ou esquecer contribuições de modos rígidos."
                                }
                              ],
                              "practicalExample": "Em uma asa de aeronave modelada como viga MDOF com 4 modos, aplique convolução para uma excitação arbitrária f(t) representando uma rajada de vento medida (dados discretos de 100 pontos). Calcule deslocamentos na ponta da asa e verifique picos de resposta contra limites de fadiga.",
                              "finalVerifications": [
                                "Resposta satisfaz equação de movimento com resíduo < 1%.",
                                "Modos dominantes contribuem >90% da energia total.",
                                "Unidades consistentes em todas respostas físicas.",
                                "Convergência ao truncar número de modos.",
                                "Respostas iniciais e finais atendem condições de contorno.",
                                "Estabilidade numérica sem oscilações artificiais."
                              ],
                              "assessmentCriteria": [
                                "Precisão da projeção modal de f(t) (erro < 5%).",
                                "Correta formulação da função de resposta unitária.",
                                "Eficiência computacional (tempo de simulação razoável).",
                                "Justificativa da escolha entre convolução e superposição.",
                                "Qualidade dos gráficos e análise de resultados.",
                                "Identificação correta de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Integrais de convolução e análise de Fourier.",
                                "Programação: Implementação numérica em MATLAB/Python (SciPy ODE solvers).",
                                "Física: Princípios de vibrações amortecidas e análise modal.",
                                "Engenharia de Controle: Aplicação em supressão de vibrações ativas."
                              ],
                              "realWorldApplication": "Na certificação de aeronaves, prever respostas de estruturas aeroespaciais a rajadas de vento ou manobras abruptas, evitando flutter ou fadiga, como na análise de wings de aviões comerciais sob cargas gust conforme normas FAA."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.2.3.3.4",
                            "name": "Reconstruir resposta física",
                            "description": "Combinar respostas modais para obter deslocamentos, velocidades e acelerações no espaço físico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar dados modais e respostas modais",
                                  "subSteps": [
                                    "Reunir os vetores modais (φ_i) normalizados para cada modo relevante.",
                                    "Coletar as respostas modais desacopladas (η_i(t)) para deslocamento, velocidade e aceleração de cada modo.",
                                    "Identificar o número de modos a serem incluídos com base no percentual de massa modal (ex: 90-95%).",
                                    "Organizar dados em matrizes ou vetores para computação eficiente.",
                                    "Verificar unidades consistentes (ex: metros para deslocamento)."
                                  ],
                                  "verification": "Confirmar que todos os φ_i e η_i(t) estão corretamente dimensionados e sem erros de unidade.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Matriz de modos (Φ), funções η_i(t) de simulações anteriores, software como MATLAB ou Python (NumPy).",
                                  "tips": "Use modos até capturar 95% da massa modal para precisão sem sobrecarga computacional.",
                                  "learningObjective": "Entender a preparação de componentes modais para reconstrução precisa.",
                                  "commonMistakes": "Incluir modos irrelevantes levando a ruído; ignorar normalização dos modos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconstruir deslocamentos físicos",
                                  "subSteps": [
                                    "Aplicar a fórmula q(t) = Φ * η(t), onde q(t) é o vetor de deslocamentos físicos.",
                                    "Calcular a soma modal: q_j(t) = Σ φ_{j,i} * η_i(t) para cada grau de liberdade j.",
                                    "Computar numericamente em pontos de tempo discretos.",
                                    "Plotar curvas de deslocamento vs. tempo para visualização.",
                                    "Comparar contribuição de cada modo graficamente."
                                  ],
                                  "verification": "Verificar se q(t=0) = 0 para condições iniciais nulas e continuidade das curvas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Script MATLAB/Python com funções matrix multiplication e plotting (Matplotlib).",
                                  "tips": "Vetorize operações para eficiência em múltiplos DOFs.",
                                  "learningObjective": "Dominar a superposição modal para deslocamentos no espaço físico.",
                                  "commonMistakes": "Erro de indexação em loops; esquecer multiplicação matricial Φ * η."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconstruir velocidades e acelerações físicas",
                                  "subSteps": [
                                    "Derivar η̇_i(t) e η̈_i(t) das respostas modais (analítica ou numérica).",
                                    "Calcular velocidades: v(t) = Φ * η̇(t); acelerações: a(t) = Φ * η̈(t).",
                                    "Implementar derivação numérica se funções analíticas indisponíveis (diferenças finitas).",
                                    "Plotar v(t) e a(t) vs. tempo e verificar picos esperados.",
                                    "Analisar envelopes de resposta para máxima velocidade/aceleração."
                                  ],
                                  "verification": "Garantir que máximos de v(t) e a(t) correspondam a frequências modais dominantes.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Scripts de derivação (SymPy para simbólica ou NumPy gradient para numérica).",
                                  "tips": "Use derivação central para precisão em diferenças finitas.",
                                  "learningObjective": "Aplicar superposição para derivadas temporais em dinâmica.",
                                  "commonMistakes": "Derivação incorreta de η_i levando a fases erradas; escala inadequada em plots."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e analisar a resposta reconstruída",
                                  "subSteps": [
                                    "Comparar com solução direta do sistema acoplado (se disponível).",
                                    "Calcular erro modal de truncamento: ||q_exata - q_reconstruída|| / ||q_exata|| < 5%.",
                                    "Avaliar resposta em frequência via FFT para matching de picos modais.",
                                    "Documentar contribuições modais em tabela.",
                                    "Exportar resultados para relatório ou animação."
                                  ],
                                  "verification": "Erro de reconstrução abaixo de 5% e matching de frequências naturais.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ferramentas de FFT (SciPy FFT), solver full para benchmark.",
                                  "tips": "Animação 3D dos modos ajuda visualizar convergência.",
                                  "learningObjective": "Validar precisão da análise modal na reconstrução física.",
                                  "commonMistakes": "Ignorar truncamento modal causando discrepâncias; benchmark inadequado."
                                }
                              ],
                              "practicalExample": "Para uma viga cantilever de asa de aeronave com 4 DOFs sob excitação harmônica em 10 Hz: modos φ1=[0.1,0.4,0.7,0.9], φ2=[0.9,0.7,0.4,0.1]; η1(t)=sin(ωt)/ω², η2(t)=0.5*sin(2ωt)/(2ω)². Reconstruir q(t), v(t), a(t) em nó 3, obtendo pico de deslocamento 0.05m, velocidade 0.3m/s.",
                              "finalVerifications": [
                                "Deslocamentos q(t) contínuos e zero em t=0.",
                                "Velocidades e acelerações derivam corretamente de q(t).",
                                "Contribuições modais somam a resposta full com erro <5%.",
                                "Picos ocorrem em frequências modais esperadas.",
                                "Unidades físicas consistentes (m, m/s, m/s²).",
                                "Plots mostram convergência com mais modos."
                              ],
                              "assessmentCriteria": [
                                "Precisão da reconstrução (erro <5%).",
                                "Correta implementação de superposição modal.",
                                "Validação com benchmark full-system.",
                                "Análise de contribuições modais claras.",
                                "Visualizações e documentação completas.",
                                "Eficiência computacional demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Multiplicação matricial e decomposição modal.",
                                "Programação Numérica: Implementação em Python/MATLAB.",
                                "Física: Princípios de superposição em vibrações.",
                                "Engenharia de Controle: Uso em simulações de sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Em análise de aeroelasticidade, reconstruir respostas físicas de asas sob rajadas de vento para prever flutter ou fadiga estrutural em aeronaves como o Boeing 787."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.5",
                    "name": "Modelagem de Sistemas com Dois ou Mais Graus de Liberdade",
                    "description": "Formulação das equações de movimento para estruturas MDOF usando princípios variacionais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.5.1",
                        "name": "Princípio de Lagrange para Sistemas MDOF",
                        "description": "Formulação das equações de movimento para sistemas com múltiplos graus de liberdade utilizando o princípio variacional de Lagrange, incluindo a definição da função de Lagrange e derivação das equações generalizadas.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.1.1",
                            "name": "Definir a função de Lagrange para sistemas MDOF",
                            "description": "Explicar e construir a função de Lagrange L = T - V, onde T é a energia cinética total e V é a energia potencial total para um sistema com dois ou mais graus de liberdade, considerando massas concentradas e rigidez.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de energia cinética e potencial em sistemas mecânicos",
                                  "subSteps": [
                                    "Revise a definição de energia cinética T para um sistema SDOF: T = (1/2) m ᴖˢ²",
                                    "Revise a energia potencial V para SDOF: V = (1/2) k x²",
                                    "Estenda os conceitos para MDOF: T e V são funções das velocidades generalizadas ᴖˢ_i e coordenadas generalizadas q_i",
                                    "Identifique massas concentradas e elementos de rigidez em diagramas de sistemas MDOF",
                                    "Diferencie coordenadas generalizadas (ex: deslocamentos x1, x2) de velocidades generalizadas"
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre T e V em MDOF, com fórmulas básicas",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Dinâmica de Estruturas (ex: Clough & Penzien)",
                                    "Vídeos introdutórios sobre Lagrange em MDOF (YouTube/Khan Academy)",
                                    "Papel e lápis para esboços"
                                  ],
                                  "tips": "Comece com exemplos visuais de massas-spring para fixar ideias antes de generalizar",
                                  "learningObjective": "Entender T e V como somas de contribuições de cada grau de liberdade",
                                  "commonMistakes": [
                                    "Confundir velocidades generalizadas com deslocamentos",
                                    "Esquecer o fator 1/2 nas expressões quadráticas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a energia cinética total T para sistemas MDOF com massas concentradas",
                                  "subSteps": [
                                    "Expresse T como T = ∑ (1/2) m_i ᴖˢ_i² para massas independentes",
                                    "Considere acoplamentos cinéticos: T = (1/2) ∑∑ m_ij ᴖˢ_i ᴖˢ_j",
                                    "Derive expressões para um sistema de 2 DOF: T = (1/2) m1 ᴖˢ_1² + (1/2) m2 (ᴖˢ_1 + ᴖˢ_2)² se houver movimento relativo",
                                    "Calcule numericamente T para valores dados (ex: m1=1kg, m2=2kg, ᴖˢ_1=1m/s, ᴖˢ_2=0.5m/s)",
                                    "Verifique dimensionalidade: T deve ter unidades de Joules"
                                  ],
                                  "verification": "Calcule T corretamente para um sistema 2DOF fornecido e compare com solução modelo",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software MATLAB ou Python para verificação numérica",
                                    "Planilhas Excel para cálculos matriciais",
                                    "Exemplos de problemas de livros de vibrações"
                                  ],
                                  "tips": "Use matriz de massa [M] para generalizar: T = (1/2) {ᴖˢ}^T [M] {ᴖˢ}",
                                  "learningObjective": "Construir a expressão exata de T em termos de coordenadas generalizadas",
                                  "commonMistakes": [
                                    "Ignorar termos cruzados m_ij em sistemas acoplados",
                                    "Usar velocidades lineares em vez de generalizadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a energia potencial total V considerando elementos de rigidez",
                                  "subSteps": [
                                    "Expresse V para molas independentes: V = ∑ (1/2) k_i q_i²",
                                    "Inclua rigidez acoplada: V = (1/2) ∑∑ k_ij q_i q_j",
                                    "Para 2DOF com molas k1, k2, k_c (acoplamento): V = (1/2) k1 x1² + (1/2) k2 x2² + (1/2) kc (x2 - x1)²",
                                    "Expanda e reescreva em forma matricial [K]{q}",
                                    "Calcule V numericamente para valores de rigidez e deslocamentos dados"
                                  ],
                                  "verification": "Derive V para um sistema shear-building 2DOF e confira com diagrama de deformações",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Diagramas de sistemas MDOF impressos",
                                    "Calculadora simbólica (Mathematica/SymPy)",
                                    "Tutoriais sobre matriz de rigidez"
                                  ],
                                  "tips": "Desenhe deformações das molas para visualizar contribuições de V",
                                  "learningObjective": "Expressar V quadraticamente em coordenadas generalizadas",
                                  "commonMistakes": [
                                    "Erro no sinal de deformações relativas em molas acopladas",
                                    "Confundir rigidez com massa"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir a função de Lagrange L = T - V para um sistema MDOF completo",
                                  "subSteps": [
                                    "Combine T e V: escreva L = T(q˙, t) - V(q, t)",
                                    "Para 2DOF: substitua expressões de T e V em L",
                                    "Simplifique L destacando dependências em q_i e ᴖˢ_i",
                                    "Verifique se L é homogênea de grau 2 em velocidades (para conservatividade)",
                                    "Aplique em um exemplo completo e prepare para equações de movimento (próximo tópico)"
                                  ],
                                  "verification": "Escreva L completa para um sistema dado e derive dL/dq_i e dL/dᴖˢ_i corretamente",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Folhas de exercícios com sistemas MDOF",
                                    "Software para plotar T, V e L",
                                    "Referência: Princípios de Mecânica Analítica (Goldstein)"
                                  ],
                                  "tips": "Sempre subtraia V de T; lembre que L maximiza ação em caminhos reais",
                                  "learningObjective": "Definir L explicitamente e entender seu papel no princípio variacional",
                                  "commonMistakes": [
                                    "Esquecer o sinal: L = T + V (errado)",
                                    "Não expandir termos quadráticos completamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um sistema 2DOF com duas massas m1=10kg, m2=15kg, molas k1=1000N/m (suporte), k2=800N/m (entre massas), k3=1200N/m (suporte m2). Deslocamentos x1, x2. T = 0.5 m1 ᴖˢ1² + 0.5 m2 ᴖˢ2². V = 0.5 k1 x1² + 0.5 k2 (x2 - x1)² + 0.5 k3 x2². Logo L = T - V. Calcule para x1=0.1m, x2=0.05m, ᴖˢ1=2m/s, ᴖˢ2=1m/s.",
                              "finalVerifications": [
                                "Escreve corretamente L para um sistema 2DOF arbitrário",
                                "Identifica todos os termos cinéticos e potenciais sem erros",
                                "Calcula valores numéricos de T, V e L com precisão",
                                "Explica o papel de L nas equações de Euler-Lagrange",
                                "Distingue sistemas com acoplamento de independentes",
                                "Verifica unidades consistentes em L"
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de T e V (90% correto)",
                                "Completude dos termos cruzados em expressões acopladas",
                                "Correção do sinal em L = T - V",
                                "Capacidade de generalizar para n-DOF",
                                "Clareza na explicação oral/escrita do processo",
                                "Aplicação correta em exemplo prático"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e equações diferenciais",
                                "Física: Mecânica hamiltoniana e conservação de energia",
                                "Engenharia Mecânica: Análise de vibrações modais",
                                "Computação: Implementação em simulações FEM (Finite Element Method)",
                                "Controle: Formulação para sistemas dinâmicos lineares"
                              ],
                              "realWorldApplication": "Na análise de aeroelasticidade, define L para modelar vibrações de asas de aeronaves com múltiplos modos (ex: flapwise e chordwise), prevendo instabilidades como flutter em projetos da Embraer ou Boeing, otimizando rigidez e massa para segurança de voo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.2",
                            "name": "Derivar equações de movimento via Lagrange para 2 DOF",
                            "description": "Aplicar as equações de Lagrange d/dt (∂L/∂q̇_i) - ∂L/∂q_i = Q_i para derivar as equações diferenciais de segunda ordem acopladas para um sistema com dois graus de liberdade, como uma viga com massas em extremidades.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o sistema físico e coordenadas generalizadas",
                                  "subSteps": [
                                    "Selecione um sistema exemplo: uma viga flexível horizontal de comprimento L com massas m1 e m2 nas extremidades, sujeita a deslocamentos transversais.",
                                    "Defina as coordenadas generalizadas q1 (deslocamento da massa m1) e q2 (deslocamento da massa m2).",
                                    "Esboce o diagrama do sistema, indicando posições de equilíbrio e graus de liberdade.",
                                    "Expresse as posições cartesianas das massas em termos de q1 e q2, assumindo pequenas deformações.",
                                    "Identifique forças generalizadas Q1 e Q2 (geralmente zero para sistemas livres)."
                                  ],
                                  "verification": "Confirme que q1 e q2 são independentes e capturam todos os DOF; diagrama desenhado corretamente.",
                                  "estimatedTime": "30-45 minutes",
                                  "materials": [
                                    "Papel e lápis para diagrama",
                                    "Calculadora ou software simbólico (SymPy)"
                                  ],
                                  "tips": "Use coordenadas que minimizem acoplamentos iniciais; verifique se o sistema tem exatamente 2 DOF.",
                                  "learningObjective": "Entender como escolher coordenadas generalizadas adequadas para sistemas MDOF.",
                                  "commonMistakes": [
                                    "Confundir DOF com componentes cartesianas",
                                    "Ignorar acoplamentos cinemáticos",
                                    "Definir coordenadas dependentes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a energia cinética T",
                                  "subSteps": [
                                    "Expresse as velocidades das massas: v1 = dq1/dt para m1, considerando modo de deformação da viga.",
                                    "Para viga com massas pontuais, T = (1/2) m1 (dq1/dt)^2 + (1/2) m2 (dq2/dt)^2 + termos de rotação se aplicável.",
                                    "Inclua contribuição da viga se modelada com densidade distribuída (use forma modal aproximada).",
                                    "Escreva T explicitamente como função de q̇1, q̇2 (e q1, q2 se não holonômico).",
                                    "Verifique simetria e positividade de T."
                                  ],
                                  "verification": "T é quadrática em velocidades generalizadas e positiva definida.",
                                  "estimatedTime": "45-60 minutes",
                                  "materials": [
                                    "Folha de cálculo simbólica",
                                    "SymPy ou Mathematica para simplificação"
                                  ],
                                  "tips": "Assuma pequenas amplitudes para linearizar velocidades; teste com valores numéricos simples.",
                                  "learningObjective": "Dominar expressão da energia cinética em coordenadas generalizadas para sistemas acoplados.",
                                  "commonMistakes": [
                                    "Esquecer termos cruzados como q̇1 q̇2",
                                    "Confundir velocidades com deslocamentos",
                                    "Ignorar inércia rotacional"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a energia potencial V e formar o Lagrangiano L",
                                  "subSteps": [
                                    "Modele V para a viga: V = (1/2) k1 q1^2 + (1/2) k2 q2^2 + termos de acoplamento torsional/flexural.",
                                    "Para viga Euler-Bernoulli aproximada, use rigidez equivalente entre massas.",
                                    "Forme L = T - V.",
                                    "Simplifique expressões algébricas, identificando matrizes de massa [M] e rigidez [K].",
                                    "Confirme que L não depende explicitamente do tempo para sistemas autônomos."
                                  ],
                                  "verification": "L = T(q̇, q) - V(q); derivadas parciais bem definidas.",
                                  "estimatedTime": "45-60 minutes",
                                  "materials": [
                                    "Software simbólico obrigatório",
                                    "Tabelas de rigidez para vigas"
                                  ],
                                  "tips": "Use aproximações modais para vigas; mantenha símbolos genéricos m1,m2,k1,k2.",
                                  "learningObjective": "Construir corretamente o Lagrangiano para sistemas conservativos MDOF.",
                                  "commonMistakes": [
                                    "Inverter sinal de V",
                                    "Incluir dissipação em V",
                                    "Erros em rigidez acoplada"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar equações de Euler-Lagrange e obter EDOs finais",
                                  "subSteps": [
                                    "Para i=1: compute ∂L/∂q̇1, então d/dt(∂L/∂q̇1), ∂L/∂q1; forme d/dt(∂L/∂q̇1) - ∂L/∂q1 = Q1.",
                                    "Repita para i=2, obtendo equações acopladas.",
                                    "Substitua T e V para revelar forma matricial: [M]{q̈} + [K]{q} = {Q}.",
                                    "Linearize se necessário e resolva para acelerações.",
                                    "Verifique dimensionalidade e reciprocidade de Maxwell-Betti."
                                  ],
                                  "verification": "EDOs são de 2ª ordem, acopladas, com 2 equações independentes.",
                                  "estimatedTime": "60-90 minutes",
                                  "materials": [
                                    "SymPy para derivadas",
                                    "Matriz solver opcional"
                                  ],
                                  "tips": "Compute derivadas parciais sistematicamente; use chain rule com cuidado em d/dt.",
                                  "learningObjective": "Derivar EDOs de movimento via Lagrange para 2 DOF com precisão.",
                                  "commonMistakes": [
                                    "Erro no sinal da equação Lagrange",
                                    "Derivadas parciais trocadas",
                                    "Não linearizar termos quadráticos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e interpretar as equações derivadas",
                                  "subSteps": [
                                    "Substitua valores numéricos exemplo (m1=m2=1kg, k1=k2=1N/m) e resolva numericamente.",
                                    "Compare com método de Newton-Euler para validação.",
                                    "Identifique frequências naturais via det([K - ω²M])=0.",
                                    "Discuta modos normais e acoplamento.",
                                    "Documente equações finais em forma padrão."
                                  ],
                                  "verification": "Equações coincidem com literatura ou simulação; modos físicos fazem sentido.",
                                  "estimatedTime": "30-45 minutes",
                                  "materials": [
                                    "Solver numérico (MATLAB/Python)",
                                    "Referências de dinâmica estrutural"
                                  ],
                                  "tips": "Sempre teste limites (m2→0 recupera 1 DOF).",
                                  "learningObjective": "Validar derivação e interpretar resultados físicos.",
                                  "commonMistakes": [
                                    "Ignorar verificação numérica",
                                    "Má interpretação de modos",
                                    "Erros de unidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma viga de aço de 1m com massas de 0.5kg nas pontas. q1=y1(t), q2=y2(t). T=(1/2)m1 ẏ1² + (1/2)m2 ẏ2² + inércia viga. V=(1/2)(12EI/L³)q1² + (1/2)(12EI/L³)q2² - acoplamento. Derivação leva a [m] {ÿ} + [k] {y}=0, com ω1≈√(k/m), ω2 maior.",
                              "finalVerifications": [
                                "Energia cinética T é positiva definida em q̇1, q̇2.",
                                "Lagrangiano L = T - V correto.",
                                "Equações finais: m11 q̈1 + m12 q̈2 + k11 q1 + k12 q2 = Q1; similar para eq2.",
                                "Matrizes [M] simétrica positiva, [K] simétrica.",
                                "Validação numérica com caso conhecido (ex: pêndulo duplo).",
                                "Identificação correta de 2 frequências naturais."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas derivadas parciais (sem erros algébricos).",
                                "Correta identificação de acoplamentos em [M] e [K].",
                                "Linearização apropriada para pequenas oscilações.",
                                "Validação via método alternativo ou simulação.",
                                "Interpretação física das EDOs (modos, estabilidade).",
                                "Clareza na documentação e diagrama."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e derivadas parciais.",
                                "Programação: Implementar SymPy para automação de Lagrange.",
                                "Controle de Sistemas: Uso das EDOs em análise modal e controle ativo.",
                                "Engenharia Aeroespacial: Modelagem de aeroelasticidade em ST-57.",
                                "Física: Princípios de conservação de energia em MDOF."
                              ],
                              "realWorldApplication": "Modelagem de estruturas aeroespaciais flexíveis, como asas de aeronaves para prever flutter (instabilidade aeroelástica), essencial em certificação FAA para evitar falhas catastróficas como no caso histórico de Tacoma Narrows, adaptado a MDOF."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.5.1.3",
                            "name": "Generalizar para sistemas com n DOF",
                            "description": "Estender a formulação lagrangiana para sistemas com n graus de liberdade, obtendo a forma matricial [M]{q̈} + [K]{q} = {Q}, e discutir matrizes de massa e rigidez.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Formulação Lagrangiana para Sistemas Simples e Preparar Generalização",
                                  "subSteps": [
                                    "Revise as equações de Lagrange para sistemas com 1 DOF: L = T - V, d/dt(∂L/∂q̇) - ∂L/∂q = Q.",
                                    "Analise o caso de 2 DOF, identificando coordenadas generalizadas q1, q2 e velocidades q̇1, q̇2.",
                                    "Identifique padrões nas expressões cinéticas T (quadráticas em q̇) e potenciais V (em q).",
                                    "Defina notação matricial inicial: {q} = [q1, q2, ..., qn]^T, {q̇}, {q̈}.",
                                    "Esboce a estrutura geral esperada para T = (1/2){q̇}^T [M]{q̇}."
                                  ],
                                  "verification": "Escreva as equações para um sistema 2 DOF e confirme que T e V podem ser expressos em forma matricial.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Dinâmica (ex: Greenwood ou Meirovitch), caderno de anotações, calculadora simbólica (Mathematica ou SymPy).",
                                  "tips": "Use coordenadas generalizadas consistentes para evitar confusão em sistemas acoplados.",
                                  "learningObjective": "Compreender como a formulação escalar se estende para vetores de coordenadas generalizadas.",
                                  "commonMistakes": "Confundir coordenadas generalizadas com deslocamentos cartesianos; ignorar termos de acoplamento em T."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar Equações de Movimento para n DOF Usando Lagrange",
                                  "subSteps": [
                                    "Escreva o Lagrangiano geral L = T({q̇}, {q}) - V({q}).",
                                    "Calcule ∂L/∂q̇i = ∂T/∂q̇i para cada i=1 a n, formando o vetor de momentos generalizados.",
                                    "Derive d/dt(∂L/∂q̇i) = ∑ [m_ij q̈j + c_ij q̇j], onde m_ij são coeficientes de massa.",
                                    "Calcule ∂L/∂qi = -∂V/∂qi + termos de T se não quadrático.",
                                    "Obtenha a forma [M]{q̈} + [C]{q̇} + [K]{q} = {Q}, focando em casos sem amortecimento."
                                  ],
                                  "verification": "Derive explicitamente para n=2 e verifique se coincide com equações escalares conhecidas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software simbólico (MATLAB Symbolic ou Python SymPy), exemplos de sistemas MDOF de artigos aeroespaciais.",
                                  "tips": "Mantenha simetria das matrizes; teste com variações pequenas em q para validar derivadas.",
                                  "learningObjective": "Dominar a derivação das EOMs lagrangianas em forma vetorial para múltiplos DOF.",
                                  "commonMistakes": "Esquecer termos Coriolis em d/dt(∂L/∂q̇); assumir [M] constante quando depende de {q}."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formar e Interpretar Matrizes de Massa [M] e Rigidez [K]",
                                  "subSteps": [
                                    "Extraia [M] dos coeficientes ∂²T/∂q̇i∂q̇j, confirmando simetria e positividade definida.",
                                    "Extraia [K] de ∂²V/∂qi∂qj para potenciais quadráticos, ou linearize se não quadrático.",
                                    "Discuta propriedades: [M] inercial, invariante em tempo para sistemas rígidos; [K] geométrica/elasticidade.",
                                    "Verifique ortogonalidade ou modos principais se possível.",
                                    "Implemente numericamente para um exemplo simples (ex: massa-mola dupla)."
                                  ],
                                  "verification": "Construa [M] e [K] para um sistema conhecido e resolva autovalores para frequências naturais.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "MATLAB ou Python (NumPy/SciPy) para matrizes, template de código para MDOF.",
                                  "tips": "Use índices i,j sistematicamente para preencher matrizes; plote para visualizar acoplamentos.",
                                  "learningObjective": "Identificar e caracterizar as matrizes fundamentais na forma padrão das EOMs.",
                                  "commonMistakes": "Confundir [M] com matriz de covariância; não verificar simetria positiva definida de [M]."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Propriedades e Aplicar em Contexto Aeroespacial",
                                  "subSteps": [
                                    "Analise dependência de [M] e [K] em configurações (ex: rotação em aeroelasticidade).",
                                    "Discuta decomposição modal: [M]^{-1}[K] autovalores como ω².",
                                    "Compare com formulações Newton-Euler para validar.",
                                    "Aplique a um sistema aeroespacial simples (ex: ala com flexão e torção).",
                                    "Resuma limitações: linearidade, pequenas oscilações."
                                  ],
                                  "verification": "Simule resposta livre de um sistema 2 DOF e confirme modos com teoria modal.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Simulador (MATLAB Simulink ou Python ODEINT), paper sobre flutter de asas.",
                                  "tips": "Comece com sistemas desacoplados para intuition, depois acople.",
                                  "learningObjective": "Aplicar generalização a cenários reais e discutir matrizes em dinâmica estrutural.",
                                  "commonMistakes": "Ignorar não-linearidades em V para grandes deslocamentos; superestimar independência de [M]."
                                }
                              ],
                              "practicalExample": "Considere uma viga cantilever modelada com 2 DOF (flexão w e torção θ na ponta). Derive L = T(ẇ, θ̇, w, θ) - V(w, θ), obtenha [M] = [[m11, m12], [m21, m22]] com m12 ≠ 0 devido a inércia acoplada, [K] similar, e resolva [M]{q̈} + [K]{q} = 0 para modos de flutter potencial.",
                              "finalVerifications": [
                                "Derivação completa das EOMs para n DOF resulta em forma matricial correta.",
                                "Matrizes [M] e [K] são simétricas e positivas definidas para sistemas estáveis.",
                                "Exemplo numérico com n=2 reproduz frequências naturais conhecidas.",
                                "Discussão inclui propriedades como ortogonalidade modal.",
                                "Simulação confirma equações derivadas.",
                                "Identifica limitações para não-lineares ou amortecidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação lagrangiana generalizada (80% correto).",
                                "Correta identificação e preenchimento de [M] e [K] (com simetria).",
                                "Análise qualitativa das propriedades das matrizes (completa).",
                                "Exemplo prático resolvido com resultados numéricos válidos.",
                                "Conexão clara com aplicações aeroespaciais.",
                                "Ausência de erros comuns como termos Coriolis omitidos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Linear: autovalores de [M]^{-1}[K] para análise modal.",
                                "Programação Computacional: implementação em MATLAB/Python para simulações MDOF.",
                                "Controle de Sistemas: uso das matrizes em controladores state-space.",
                                "Física de Materiais: origem de [K] em propriedades elásticas.",
                                "Engenharia de Controle: estabilização de modos instáveis em flutter."
                              ],
                              "realWorldApplication": "Em aeroelasticidade, essa formulação modela asas de aeronaves com múltiplos DOF (flexão, torção, etc.), prevendo flutter crítico via análise modal de [M] e [K], essencial para certificação de segurança em projetos da Boeing ou Embraer."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.2",
                        "name": "Princípio de Hamilton para Sistemas MDOF",
                        "description": "Utilização do princípio de Hamilton para modelagem dinâmica de estruturas MDOF, envolvendo o Hamiltoniano e equações canônicas.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.2.1",
                            "name": "Construir o Hamiltoniano para MDOF",
                            "description": "Definir o Hamiltoniano H = ∑ p_i q̇_i - L, onde p_i são momentos generalizados, e transformá-lo em função de coordenadas generalizadas e momentos para sistemas com múltiplos DOF.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Derivar o Lagrangiano L para o sistema MDOF",
                                  "subSteps": [
                                    "Identifique as coordenadas generalizadas q_i para todos os graus de liberdade (ex: posições x1, x2 para duas massas).",
                                    "Calcule as energias cinéticas T = (1/2) ∑ m_i q̇_i² ou formas quadráticas para sistemas acoplados.",
                                    "Calcule as energias potenciais V(q) baseadas em forças conservativas (ex: molas k(q_i - q_j)²).",
                                    "Forme L = T(q, q̇) - V(q), garantindo dependência correta em q e q̇.",
                                    "Simplifique expressões algébricas para clareza."
                                  ],
                                  "verification": "Verifique se L é função de q e q̇ apenas, e se ∂L/∂t = 0 (sistema não dissipativo).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Laptop com software simbólico como SymPy ou Mathematica",
                                    "Papel e lápis para derivações",
                                    "Referência: Livro de Goldstein - Mecânica Clássica"
                                  ],
                                  "tips": "Comece com sistemas simples de 2 DOF para praticar antes de generalizar.",
                                  "learningObjective": "Construir corretamente o Lagrangiano como base para o Hamiltoniano.",
                                  "commonMistakes": [
                                    "Confundir T e V",
                                    "Esquecer termos cruzados em T para sistemas acoplados",
                                    "Incluir dependência explícita no tempo em L"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os momentos generalizados p_i",
                                  "subSteps": [
                                    "Para cada i, compute p_i = ∂L / ∂q̇_i usando regras de derivação parcial.",
                                    "Expresse p_i como função linear de q̇: p = M(q) q̇, onde M é a matriz de massa/inércia.",
                                    "Verifique simetria e positiva definitividade de M para estabilidade.",
                                    "Anote as expressões explícitas para cada p_i em termos de q e q̇.",
                                    "Teste com valores numéricos simples para validar."
                                  ],
                                  "verification": "Confirme que as equações de Euler-Lagrange emergem: dq̇_i/dt = ∂L/∂q_i - ∂H/∂q_i = 0 inicialmente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora simbólica online (Wolfram Alpha)",
                                    "Folhas de exercícios com sistemas 2DOF",
                                    "Documentação de SymPy para derivadas parciais"
                                  ],
                                  "tips": "Use notação matricial para múltiplos DOF para evitar erros de indexação.",
                                  "learningObjective": "Dominar a definição canônica de momentos generalizados.",
                                  "commonMistakes": [
                                    "Derivar incorretamente parciais em termos cruzados",
                                    "Confundir p_i com quantidades cinemáticas",
                                    "Ignorar dependência de q em M"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Expressar velocidades q̇_i em termos de p_i e q",
                                  "subSteps": [
                                    " Inverta a relação p = M(q) q̇ para obter q̇ = M^{-1}(q) p.",
                                    "Calcule a inversa da matriz M explicitamente para sistemas pequenos (2-3 DOF).",
                                    "Substitua nas expressões de T e L, expressando tudo em q e p.",
                                    "Verifique dimensionalmente: q̇ deve ter unidades de velocidade.",
                                    "Simplifique frações ou expressões matriciais resultantes."
                                  ],
                                  "verification": "Substitua de volta em p para recuperar a identidade original.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de álgebra linear (MATLAB ou Python NumPy)",
                                    "Tabelas de inversas matriciais 2x2/3x3",
                                    "Exemplos resolvidos de vibrações acopladas"
                                  ],
                                  "tips": "Para matrizes simétricas, use decomposição Cholesky se necessário para estabilidade numérica.",
                                  "learningObjective": "Realizar a transformação de Legendre para coordenadas canônicas.",
                                  "commonMistakes": [
                                    "Erro na inversão matricial",
                                    "Esquecer dependência de q na inversa",
                                    "Introduzir singularidades em M"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir e simplificar o Hamiltoniano H",
                                  "subSteps": [
                                    "Compute ∑ p_i q̇_i(p, q), que deve igualar 2T para Lagrangianos padrão.",
                                    "Subtraia L(q, q̇(p,q)): H = ∑ p_i q̇_i - L.",
                                    "Simplifique para H = T(q, p) + V(q), confirmando separabilidade.",
                                    "Escreva H explicitamente em coordenadas generalizadas e momentos.",
                                    "Verifique as equações de Hamilton: q̇_i = ∂H/∂p_i, ṗ_i = -∂H/∂q_i."
                                  ],
                                  "verification": "Simule numericamente as EDOs de Hamilton e compare trajetórias com Lagrange.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Solver numérico (SciPy odeint)",
                                    "Gráficos de fase para validação",
                                    "Referência: Lanczos - Variational Principles"
                                  ],
                                  "tips": "Sempre teste com sistema 1DOF conhecido (ex: harmônico) antes de MDOF.",
                                  "learningObjective": "Finalizar o Hamiltoniano canônico pronto para análise dinâmica.",
                                  "commonMistakes": [
                                    "Sinal errado em H = ∑p q̇ - L",
                                    "Não substituir completamente q̇",
                                    "Termos restantes em q̇ após inversão"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um sistema de duas massas m1=m2=1kg conectadas por molas k12=1N/m, k1=2N/m, k2=3N/m (modelo de asa flexível). Coordenadas q1=x1, q2=x2. Derive L = (1/2)(q̇1² + q̇2²) - [ (1/2)*2*q1² + (1/2)*1*(q1-q2)² + (1/2)*3*q2² ]. Calcule p1= q̇1, p2=q̇2 (M=Identidade). Então q̇1=p1, q̇2=p2. H = p1²/2 + p2²/2 + V(q).",
                              "finalVerifications": [
                                "H depende apenas de q e p, sem q̇ explícito.",
                                "∂H/∂p_i = q̇_i e ∂H/∂q_i = -ṗ_i coincidem com dinâmica conhecida.",
                                "H é conservado ao longo de trajetórias (dH/dt=0).",
                                "Para sistemas desacoplados, H reduz ao somatório de H_i simples.",
                                "Matriz Hessiana de H em p é positiva definida (estável).",
                                "Simulação numérica reproduz frequências modais corretas."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na derivação de L, p_i e inversão (sem erros de cálculo).",
                                "Correta aplicação da transformação Legendre (q̇ em termos de p).",
                                "Forma final de H separada em T(p,q) + V(q).",
                                "Validação via equações de Hamilton e conservação de energia.",
                                "Clareza na documentação com passos intermediários.",
                                "Generalização para n-DOF demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Mecânica Quântica: Hamiltoniano idêntico na formulação de Schrödinger.",
                                "Controle de Sistemas: Estados (q,p) para space-state em aeroespacial.",
                                "Análise Numérica: Integração de EDOs Hamiltonianas (Symplectic integrators).",
                                "Engenharia Aeroespacial: Modelagem modal de flutter em asas.",
                                "Física Computacional: Simulações N-body via Hamiltonianos."
                              ],
                              "realWorldApplication": "Em aeroelasticidade, constrói-se o Hamiltoniano para sistemas MDOF de asas (flexão-torção) para análise de estabilidade via métodos modais, prevendo flutter crítico em aeronaves como o Boeing 737 durante design de flaps."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1.3"
                            ]
                          },
                          {
                            "id": "10.1.3.5.2.2",
                            "name": "Derivar equações canônicas de Hamilton",
                            "description": "Obter as equações q̇_i = ∂H/∂p_i e ṗ_i = -∂H/∂q_i para um sistema com dois ou mais DOF, comparando com a formulação lagrangiana.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Formulação Lagrangiana para Sistemas com Múltiplos DOF",
                                  "subSteps": [
                                    "Defina coordenadas generalizadas q_i (i=1 a n) para um sistema com n graus de liberdade (DOF).",
                                    "Expresse energia cinética T como forma quadrática em q̇_i: T = (1/2) ∑ m_{ij} q̇_i q̇_j.",
                                    "Defina energia potencial V(q_i, t) e Lagrangiana L = T - V.",
                                    "Escreva equações de Euler-Lagrange: d/dt (∂L/∂q̇_i) - ∂L/∂q_i = 0 para cada i.",
                                    "Verifique com exemplo simples de 2 DOF, como duas massas ligadas por molas."
                                  ],
                                  "verification": "Escreva corretamente as equações de Euler-Lagrange para um sistema 2 DOF e resolva para acelerações.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro 'Classical Mechanics' de Goldstein (Cap. 2)",
                                    "Caderno e calculadora simbólica (Wolfram Alpha)"
                                  ],
                                  "tips": "Sempre expresse T em matriz de massa para clareza em MDOF.",
                                  "learningObjective": "Compreender a base lagrangiana como ponto de partida para transição hamiltoniana.",
                                  "commonMistakes": [
                                    "Confundir coordenadas generalizadas com cartesianas",
                                    "Esquecer termos cruzados em T para DOF acoplados",
                                    "Ignorar dependência temporal em V"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Momentos Conjugados e Transformação de Legendre",
                                  "subSteps": [
                                    "Defina momento conjugado p_i = ∂L / ∂q̇_i para cada i.",
                                    "Mostre que para T quadrático, p_i = ∑ m_{ij} q̇_j (vetor p = M q̇).",
                                    "Inverta para q̇_i em termos de p: q̇ = M^{-1} p.",
                                    "Expresse L em termos de q, p, t: L(q, p, t) via substituição.",
                                    "Verifique invertibilidade da transformação assumindo M positiva definida."
                                  ],
                                  "verification": "Calcule p_i e q̇_i para um sistema 2 DOF específico e confirme relação linear.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Software Mathematica ou SymPy para matrizes",
                                    "Notas de derivadas parciais"
                                  ],
                                  "tips": "Use notação matricial para evitar erros em somas para n>2.",
                                  "learningObjective": "Dominar a transição de velocidades para momentos canônicos.",
                                  "commonMistakes": [
                                    "Erro no cálculo de ∂L/∂q̇_i se T não quadrático",
                                    "Não inverter corretamente a matriz de massa",
                                    "Esquecer multiplicadores de Lagrange se constraints"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o Hamiltoniano e Derivar Equações Canônicas",
                                  "subSteps": [
                                    "Defina Hamiltoniano H(q, p, t) = ∑ p_i q̇_i - L(q, p, t).",
                                    "Mostre que H = T + V para sistemas padrão (homogêneos em velocidades).",
                                    "Derive q̇_i = ∂H / ∂p_i (diretamente da def.) e ṗ_i = - ∂H / ∂q_i (via teorema da função geradora).",
                                    "Escreva as equações canônicas para todos os DOF: sistema de 2n EDOs de 1ª ordem.",
                                    "Confirme conservação de H se L não explícito em t."
                                  ],
                                  "verification": "Derive H e equações para sistema 2 DOF e resolva numericamente um passo.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Livro 'Mechanics' de Landau (Seção 7)",
                                    "Python com NumPy/SciPy para verificação numérica"
                                  ],
                                  "tips": "Lembre: H é integral de movimento se ∂L/∂t = 0.",
                                  "learningObjective": "Aplicar princípio variacional de Hamilton para obter equações canônicas.",
                                  "commonMistakes": [
                                    "Sinal errado em ṗ_i",
                                    "Confundir H com L diretamente",
                                    "Não verificar ∂H/∂p_i = q̇_i explicitamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com Formulação Lagrangiana e Aplicar a Exemplo Prático",
                                  "subSteps": [
                                    "Compare número de EDOs: Lagrangiana (n de 2ª ordem) vs Hamiltoniana (2n de 1ª ordem).",
                                    "Mostre equivalência derivando E-L a partir de canônicas.",
                                    "Aplique a sistema 2 DOF (ex: pêndulo duplo): derive ambas formulações.",
                                    "Analise vantagens hamiltonianas: simetria, quantização, estabilidade numérica.",
                                    "Resolva numericamente e plote trajetórias para validação."
                                  ],
                                  "verification": "Obtenha mesmas soluções numéricas de ambas formulações para exemplo 2 DOF.",
                                  "estimatedTime": "90 minutos",
                                  "materials": [
                                    "MATLAB ou Python (odeint)",
                                    "Exemplo resolvido de pêndulo duplo"
                                  ],
                                  "tips": "Use métodos simétricos como Verlet para simulações hamiltonianas.",
                                  "learningObjective": "Avaliar superioridades da formulação hamiltoniana em MDOF.",
                                  "commonMistakes": [
                                    "Não normalizar soluções para comparação",
                                    "Ignorar singularidades em transformações",
                                    "Confundir ordem das equações"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um sistema de duas massas m1 e m2 conectadas por molas k12 e k23 a uma parede fixa, com DOF q1 (posição m1) e q2 (posição m2). Derive L = T - V, compute p1 = m1 q̇1 + c q̇2 (acoplado), H = (p1^2 / 2m1 + ...) + V(q1,q2), e equações canônicas. Compare trajetórias com E-L.",
                              "finalVerifications": [
                                "Equações canônicas derivadas corretamente: q̇_i = ∂H/∂p_i e ṗ_i = -∂H/∂q_i para todos DOF.",
                                "Hamiltoniano H expresso puramente em q, p, t sem q̇.",
                                "Transformação Legendre invertível e verificada numericamente.",
                                "Soluções coincidem com formulação lagrangiana em exemplo 2 DOF.",
                                "Conservação de H demonstrada para sistema autônomo.",
                                "Análise de estabilidade ou modos normais possível via H."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivadas parciais e transformações.",
                                "Correção na construção de H e verificação de propriedades.",
                                "Profundidade na comparação com Lagrangiana (equivalência, vantagens).",
                                "Uso correto de notação matricial para MDOF geral.",
                                "Validação numérica com código ou plots de trajetórias.",
                                "Identificação de erros comuns e precauções."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e transformações canônicas (geometria sinplética).",
                                "Física Quântica: Base para mecânica quântica via quantização de H.",
                                "Engenharia de Controle: Formulação para Hamilton-Jacobi-Bellman em controle ótimo.",
                                "Computação Científica: Integração simétrica de EDOs em simulações aeroespaciais."
                              ],
                              "realWorldApplication": "Na aeroelasticidade de asas de aeronaves, deriva equações de Hamilton para modelar vibrações modais acopladas (bend/torsion), prevendo flutter crítico e otimizando estruturas via análise de estabilidade hamiltoniana."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.5.2.3",
                            "name": "Comparar Lagrange e Hamilton em modelagem estrutural",
                            "description": "Analisar vantagens e equivalência das formulações variacionais de Lagrange e Hamilton na obtenção de equações de movimento para estruturas aeroespaciais MDOF.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos das Formulações de Lagrange e Hamilton",
                                  "subSteps": [
                                    "Estudar o princípio variacional de Lagrange para sistemas discretos com múltiplos graus de liberdade (MDOF).",
                                    "Derivar a equação de Lagrange geral: d/dt (∂L/∂q̇) - ∂L/∂q = 0, onde L = T - V.",
                                    "Introduzir o formalismo Hamiltoniano: definir momentos conjugados p = ∂L/∂q̇ e Hamiltoniano H = p q̇ - L.",
                                    "Analisar as equações de Hamilton: q̇ = ∂H/∂p, ṗ = -∂H/∂q.",
                                    "Identificar diferenças conceituais iniciais entre espaço de configuração (Lagrange) e espaço de fase (Hamilton)."
                                  ],
                                  "verification": "Escrever um resumo de 200 palavras comparando os princípios básicos e derivar equações para um oscilador simples SDOF com cada método.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Dynamics of Structures' de Anil K. Chopra ou 'Methods of Analytical Dynamics' de Meirovitch",
                                    "Notas de aula sobre Mecânica Lagrangiana e Hamiltoniana",
                                    "Software simbólico como Mathematica ou SymPy para derivações"
                                  ],
                                  "tips": "Visualize o Hamiltoniano como energia total em espaço de fase para melhor compreensão intuitiva.",
                                  "learningObjective": "Compreender as bases teóricas e diferenças conceituais das formulações variacionais.",
                                  "commonMistakes": [
                                    "Confundir velocidade generalizada q̇ com momento conjugado p",
                                    "Esquecer que H nem sempre é T + V em sistemas dissipativos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar Equações de Movimento para Sistema MDOF com Lagrange",
                                  "subSteps": [
                                    "Definir coordenadas generalizadas q_i para um sistema estrutural MDOF (ex: deslocamentos em uma treliça).",
                                    "Expressar energia cinética T e potencial V em termos de q_i e q̇_i.",
                                    "Aplicar o Lagrangiano L = T - V e derivar as equações acopladas para cada grau de liberdade.",
                                    "Linearizar as equações para pequenas vibrações em estruturas aeroespaciais.",
                                    "Verificar simetria e propriedades das matrizes de massa e rigidez resultantes."
                                  ],
                                  "verification": "Obter matrizes de massa [M] e rigidez [K] simétricas e positivas definidas para um sistema 2DOF.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Papel e lápis para derivações manuais",
                                    "MATLAB ou Python (SymPy) para validação simbólica",
                                    "Exemplos de problemas de estruturas MDOF de livros de dinâmica aeroespacial"
                                  ],
                                  "tips": "Use coordenadas modais iniciais para simplificar T e V em problemas aeroespaciais.",
                                  "learningObjective": "Dominar a derivação lagrangiana de EOM para sistemas estruturais MDOF.",
                                  "commonMistakes": [
                                    "Ignorar termos de acoplamento entre graus de liberdade",
                                    "Erro no cálculo de ∂T/∂q̇_i levando a matriz de massa incorreta"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar Equações de Movimento para o Mesmo Sistema com Hamilton",
                                  "subSteps": [
                                    "Partir das equações lagrangianas para definir momentos p_i = ∂L/∂q̇_i.",
                                    "Construir o Hamiltoniano H = Σ p_i q̇_i - L e expressá-lo em termos de q e p.",
                                    "Escrever as equações canônicas: q̇_i = ∂H/∂p_i, ṗ_i = -∂H/∂q_i.",
                                    "Converter para forma de segunda ordem e comparar com as lagrangianas.",
                                    "Analisar preservação da estrutura simétrica em problemas lineares."
                                  ],
                                  "verification": "Confirmar que as EOM hamiltonianas são matematicamente equivalentes às lagrangianas para o mesmo sistema.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Mesmos materiais do Step 2",
                                    "Referências sobre mecânica hamiltoniana em estruturas (ex: artigos AIAA)"
                                  ],
                                  "tips": "Transforme para variáveis de fase para visualizar trajetórias em software como MATLAB.",
                                  "learningObjective": "Aplicar o formalismo hamiltoniano a sistemas MDOF e verificar equivalência.",
                                  "commonMistakes": [
                                    "Erro na transformação L para H, resultando em H ≠ T + V",
                                    "Confundir ṗ com forças generalizadas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Vantagens, Desvantagens e Equivalência em Contextos Aeroespaciais",
                                  "subSteps": [
                                    "Listar vantagens de Lagrange: derivações analíticas diretas, bom para simetria.",
                                    "Listar vantagens de Hamilton: útil para métodos numéricos, controle ótimo, grandes MDOF.",
                                    "Discutir desvantagens: Lagrange sensível a escolha de coordenadas; Hamilton requer espaço de fase 2n.",
                                    "Analisar equivalência via teorema de Legendre e aplicações em aeroelasticidade.",
                                    "Avaliar cenários aeroespaciais onde um é preferível (ex: Hamilton em simulações CFD-estrutural)."
                                  ],
                                  "verification": "Criar uma tabela comparativa com pelo menos 5 critérios (precisão, computacional, etc.) e aplicar a um caso real.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Artigos sobre modelagem aeroelástica (ex: AIAA Journal)",
                                    "Planilha ou LaTeX para tabela comparativa"
                                  ],
                                  "tips": "Pense em extensões: Hamilton facilita quantização ou controle em aeronaves.",
                                  "learningObjective": "Analisar criticamente as formulações para modelagem estrutural aeroespacial.",
                                  "commonMistakes": [
                                    "Superestimar diferenças: ambos são equivalentes para sistemas conservativos",
                                    "Ignorar contextos numéricos onde Hamilton brilha"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma treliça aeroespacial 2DOF modelando painel de asa: m1 e m2 conectadas por molas k12 e k2, com deslocamentos q1 e q2. Derive EOM com Lagrange (obtém [M]{q̈} + [K]{q} = 0) e Hamilton (equações canônicas equivalentes). Compare tempo de derivação e implementação numérica em MATLAB para frequências modais.",
                              "finalVerifications": [
                                "Derivação correta e idêntica das EOM para sistema MDOF com ambos métodos.",
                                "Tabela comparativa completa de vantagens/desvantagens com exemplos aeroespaciais.",
                                "Identificação precisa da equivalência via transformação Legendre.",
                                "Análise de cenários onde Hamilton é superior (ex: integração numérica em grandes DOF).",
                                "Resolução numérica de um exemplo prático com validação de resultados.",
                                "Explicação clara de aplicações em aeroelasticidade MDOF."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações (30%)",
                                "Profundidade na comparação de vantagens e equivalência (25%)",
                                "Relevância a contextos aeroespaciais MDOF (20%)",
                                "Clareza e organização da tabela/explicação comparativa (15%)",
                                "Criatividade em exemplos práticos e verificações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e teoria de Lie groups",
                                "Controle de Sistemas: Hamiltoniano em controle ótimo LQR para estabilização aeroelástica",
                                "Programação Numérica: Implementação em FEM software (NASTRAN) usando ambos formalismos",
                                "Física Computacional: Simulações MD em materiais aeroespaciais",
                                "Otimização: Lagrangianos em problemas de design estrutural"
                              ],
                              "realWorldApplication": "Em projetos de aeronaves como o Boeing 787, formulações Hamiltonianas são usadas em solvers numéricos para análise aeroelástica de asas com milhares de DOF, enquanto Lagrange auxilia em modelos analíticos iniciais para validação modal, garantindo estabilidade flutter-free."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.3",
                        "name": "Aplicações em Estruturas Aeroespaciais MDOF",
                        "description": "Modelagem prática de sistemas estruturais aeroespaciais com dois ou mais graus de liberdade usando princípios variacionais, com foco em equações de movimento.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.3.1",
                            "name": "Modelar uma asa simplificada com 2 DOF",
                            "description": "Formular equações de movimento para um modelo de asa com graus de liberdade em flexão e torção usando Lagrange, identificando matrizes de massa e rigidez.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o modelo físico da asa simplificada com 2 DOF",
                                  "subSteps": [
                                    "Descreva a geometria da asa: comprimento, massa distribuída, rigidez em flexão e torção.",
                                    "Identifique os graus de liberdade: deslocamento vertical de flexão (h) no ponto médio e rotação de torção (θ) na seção elástica.",
                                    "Esboce o diagrama esquemático mostrando massas concentradas, molas de flexão (k_h) e torção (k_θ).",
                                    "Defina as posições de referência e suposições (asa rígida em seções, sem aerodinâmica inicialmente).",
                                    "Anote parâmetros chave: massa m, momento de inércia I, posições x_h e x_θ."
                                  ],
                                  "verification": "Diagrama completo desenhado com todos os DOF e parâmetros rotulados corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis ou software de desenho (ex: Draw.io)",
                                    "Referências sobre modelos de asa típicos (ex: livros de aeroelasticidade)"
                                  ],
                                  "tips": "Use um modelo beam-like simples para evitar complexidade inicial; comece com dimensões realistas de uma asa pequena.",
                                  "learningObjective": "Compreender e visualizar o sistema físico com dois graus de liberdade acoplados.",
                                  "commonMistakes": [
                                    "Confundir posições de h e θ; ignorar acoplamento inerente entre flexão e torção."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a energia cinética (T) usando coordenadas generalizadas",
                                  "subSteps": [
                                    "Expresse velocidades: ḣ para flexão e posição angular θ̇ para torção.",
                                    "Calcule velocidades lineares e angulares nos centros de massa considerando offsets x_h e x_θ.",
                                    "Formule T = (1/2) m (ḣ - x_h θ̇)^2 + (1/2) I θ̇^2 para massas e inércias.",
                                    "Expanda o termo cruzado para identificar acoplamento inercial.",
                                    "Verifique unidades e sinal dos termos cruzados."
                                  ],
                                  "verification": "Expressão de T quadrática em ḣ e θ̇ com coeficientes corretos de massa e acoplamento.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Calculadora simbólica (ex: SymPy ou Mathematica)",
                                    "Folha de cálculo para expansões algébricas"
                                  ],
                                  "tips": "Mantenha notação consistente; use vetores de deslocamento para generalidade.",
                                  "learningObjective": "Aplicar cinemática para expressar energia cinética em MDOF.",
                                  "commonMistakes": [
                                    "Esquecer o termo cruzado m x_h ḣ θ̇; erros de sinal em velocidades perpendiculares."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a energia potencial (V) para rigidez elástica",
                                  "subSteps": [
                                    "Defina deformações: h para flexão e θ para torção.",
                                    "Escreva V = (1/2) k_h h^2 + (1/2) k_θ θ^2, assumindo rigidez desacoplada inicialmente.",
                                    "Considere acoplamento de rigidez se aplicável (ex: termo k_hθ h θ).",
                                    "Expresse em termos das coordenadas generalizadas q = [h, θ].",
                                    "Confirme que V é quadrática sem velocidades."
                                  ],
                                  "verification": "V corretamente formada como forma quadrática positiva definida.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notas sobre propriedades de materiais aeroespaciais",
                                    "Tabelas de rigidez típicas para asas"
                                  ],
                                  "tips": "Use valores realistas para k_h e k_θ baseados em alumínio ou compósitos.",
                                  "learningObjective": "Modelar energia potencial em sistemas elásticos MDOF.",
                                  "commonMistakes": [
                                    "Incluir termos cinéticos em V; rigidez negativa ou não simétrica."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular o Lagrangiano e equações de movimento via Lagrange",
                                  "subSteps": [
                                    "Compute L = T - V.",
                                    "Calcule derivadas parciais: d/dt (∂L/∂q̇) - ∂L/∂q = 0 para q = h e θ.",
                                    "Derive as duas equações acopladas de segunda ordem.",
                                    "Escreva em forma matricial: M q̈ + K q = 0.",
                                    "Simplifique e verifique simetria das matrizes M e K."
                                  ],
                                  "verification": "Equações de movimento idênticas às de um sistema MDOF padrão com 2 DOF.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de álgebra simbólica",
                                    "Template de Lagrange para MDOF"
                                  ],
                                  "tips": "Automatize derivadas com SymPy para evitar erros algébricos.",
                                  "learningObjective": "Aplicar formalismo Lagrangiano para sistemas contínuos discretizados.",
                                  "commonMistakes": [
                                    "Erros na regra da cadeia para d/dt (∂L/∂q̇); esquecer ∂L/∂q̇ cruzado."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Identificar e extrair matrizes de massa (M) e rigidez (K)",
                                  "subSteps": [
                                    "Extraia M da forma quadrática de T: M = [[m, -m x_h], [-m x_h, I]] ajustado.",
                                    "Extraia K de V: K = [[k_h, 0], [0, k_θ]] ou com acoplamento.",
                                    "Verifique propriedades: M simétrica positiva definida, K também.",
                                    "Calcule determinantes ou autovalores para estabilidade.",
                                    "Documente matrizes finais com valores numéricos exemplo."
                                  ],
                                  "verification": "Matrizes M e K corretas, com autovalores reais positivos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB ou Python (NumPy) para verificação matricial",
                                    "Exemplos numéricos de asas reais"
                                  ],
                                  "tips": "Teste com valores específicos para validar (ex: m=1kg, x_h=0.2m).",
                                  "learningObjective": "Reconhecer forma canônica de equações MDOF e propriedades matriciais.",
                                  "commonMistakes": [
                                    "Assimetria em M devido a erros em T; K não diagonal quando deveria."
                                  ]
                                }
                              ],
                              "practicalExample": "Modelar a asa de um drone pequeno com span de 1m, m=0.5kg, I=0.01 kg m², x_h=0.3m, k_h=1000 N/m, k_θ=500 Nm/rad. Derivar M = [[0.5, -0.15], [-0.15, 0.01]] e K diagonal, simulando modos de flexão e torção.",
                              "finalVerifications": [
                                "Equações de movimento corretas em forma matricial.",
                                "Matriz de massa M simétrica com acoplamento inercial.",
                                "Matriz de rigidez K positiva definida.",
                                "Verificação numérica: autovalores de M^{-1}K reais positivos.",
                                "Diagrama inicial consistente com matrizes derivadas.",
                                "Unidades consistentes em todas as expressões."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de T e V (90% correto).",
                                "Correta aplicação do Lagrangiano sem erros algébricos.",
                                "Identificação explícita e correta de M e K.",
                                "Inclusão de acoplamento inercial se offsets ≠0.",
                                "Validação qualitativa (ex: modos físicos fazem sentido).",
                                "Clareza na documentação e diagramas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes, autovalores) e cálculo variacional.",
                                "Física: Mecânica lagrangiana e dinâmica de sistemas discretos.",
                                "Engenharia Mecânica: Modelagem de vigas e estruturas elásticas.",
                                "Programação: Implementação em Python/MATLAB para simulação modal.",
                                "Aerodinâmica: Extensão para flutter adicionando forças aéreas."
                              ],
                              "realWorldApplication": "Análise de aeroelasticidade em asas de aeronaves, como prevenção de flutter divergente em aviões comerciais (ex: Boeing 737), onde modelos 2 DOF identificam frequências naturais para design seguro contra vibrações catastróficas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.1.3"
                            ]
                          },
                          {
                            "id": "10.1.3.5.3.2",
                            "name": "Incorporar amortecimento em modelos MDOF",
                            "description": "Adicionar termos de amortecimento de Rayleigh às equações de movimento obtidas via princípios variacionais para estruturas aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar equações de movimento MDOF sem amortecimento via princípios variacionais",
                                  "subSteps": [
                                    "Recordar o princípio dos trabalhos virtuais ou princípio de Hamilton para sistemas discretos com múltiplos graus de liberdade (MDOF).",
                                    "Derivar as matrizes de massa [M] e rigidez [K] para um sistema MDOF representativo de estruturas aeroespaciais, como uma viga com dois DOF (translação e rotação).",
                                    "Escrever as equações de movimento na forma [M]{¨q} + [K]{q} = {F}, onde {q} são as coordenadas generalizadas.",
                                    "Verificar a ortogonalidade dos modos via análise modal básica.",
                                    "Aplicar a um exemplo simples de estrutura aeroespacial sem forças externas."
                                  ],
                                  "verification": "Derivar corretamente as equações sem amortecimento para um sistema de 2 DOF e validar com software numérico.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Dynamics of Structures' de Chopra",
                                    "MATLAB ou Python com NumPy/SciPy",
                                    "Folhas de papel para derivações manuais"
                                  ],
                                  "tips": "Use coordenadas generalizadas consistentes (ex: deslocamentos nodais) para facilitar a adição posterior de amortecimento.",
                                  "learningObjective": "Compreender a formulação variacional base para sistemas MDOF sem dissipação.",
                                  "commonMistakes": [
                                    "Confundir termos cinéticos com potenciais na Lagrangian",
                                    "Erros na montagem da matriz de massa simétrica",
                                    "Ignorar acoplamentos entre DOF"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o modelo de amortecimento de Rayleigh",
                                  "subSteps": [
                                    "Estudar a forma do amortecimento proporcional de Rayleigh: [C] = α[M] + β[K], onde α e β são coeficientes a determinar.",
                                    "Explicar a origem física: α relacionado a amortecimento viscoso de massa, β a amortecimento estrutural.",
                                    "Discutir hipóteses: amortecimento modal decoplado, válido para baixas frequências em estruturas aeroespaciais.",
                                    "Calcular α e β a partir de razões de amortecimento modal conhecidas (ex: ζ1 e ζ2 para dois modos).",
                                    "Verificar propriedades: [C] deve ser simétrica e positiva definida."
                                  ],
                                  "verification": "Montar [C] para um sistema conhecido e confirmar que os fatores de amortecimento modais são reproduzidos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Artigo clássico de Rayleigh sobre dissipação",
                                    "Planilhas Excel ou Jupyter Notebook para cálculos matriciais"
                                  ],
                                  "tips": "Escolha α e β para que o amortecimento afete principalmente os primeiros modos, comum em aeroelasticidade.",
                                  "learningObjective": "Dominar a definição e propriedades do amortecimento de Rayleigh em contextos MDOF.",
                                  "commonMistakes": [
                                    "Usar valores arbitrários para α/β sem base modal",
                                    "Confundir Rayleigh com amortecimento clássico (não proporcional)",
                                    "Negligenciar a dependência frequência"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar amortecimento nas equações via princípios variacionais",
                                  "subSteps": [
                                    "Estender o funcional variacional incluindo a dissipação de Rayleigh: δW_d = -∫ {˙q}^T [C] {˙q} dt.",
                                    "Derivar as equações modificadas: [M]{¨q} + [C]{˙q} + [K]{q} = {F}.",
                                    "Re-derivar usando Lagrange com termo dissipativo Rayleigh ou princípio de d'Alembert.",
                                    "Transformar para coordenadas modais: confirmar desacoplamento se [C] proporcional.",
                                    "Implementar em código para um sistema 2 DOF aeroespacial."
                                  ],
                                  "verification": "Obter equações finais com termo [C]{˙q} correto e simular resposta transitória.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software MATLAB/Simulink ou Python (SciPy odeint)",
                                    "Exemplos de código de dinâmica linear"
                                  ],
                                  "tips": "Mantenha consistência nas coordenadas; teste com α=0 ou β=0 para validar.",
                                  "learningObjective": "Aplicar princípios variacionais para incluir dissipação de forma rigorosa.",
                                  "commonMistakes": [
                                    "Inserir [C] arbitrariamente sem derivação variacional",
                                    "Erros no sinal do termo dissipativo",
                                    "Não verificar simetria de [C]"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e validar o modelo com amortecimento em estruturas aeroespaciais",
                                  "subSteps": [
                                    "Realizar análise modal complexa para raízes com parte real negativa (estabilidade).",
                                    "Simular resposta a excitação harmônica ou transitória e observar decaimento.",
                                    "Comparar com casos sem amortecimento: verificar atenuação de vibrações.",
                                    "Ajustar α/β baseado em dados experimentais típicos de estruturas aeroespaciais.",
                                    "Documentar sensibilidade do modelo a variações em [C]."
                                  ],
                                  "verification": "Gráficos de resposta temporal mostrando decaimento exponencial correto nos modos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Ferramentas de plotagem (Matplotlib)",
                                    "Dados de benchmark de flutter ou vibrações de asas"
                                  ],
                                  "tips": "Use modshapes para visualizar como o amortecimento afeta modos aeroelásticos críticos.",
                                  "learningObjective": "Avaliar o impacto do amortecimento na dinâmica de estruturas MDOF aeroespaciais.",
                                  "commonMistakes": [
                                    "Interpretar erroneamente raízes imaginárias como instáveis",
                                    "Escala errada nos gráficos de simulação",
                                    "Ignorar efeitos não-lineares em validação"
                                  ]
                                }
                              ],
                              "practicalExample": "Modelar uma seção de asa típica (2 DOF: plunge h e pitch α) com amortecimento de Rayleigh para simular supressão de flutter. Derive [M], [K] de uma viga Euler-Bernoulli, adicione [C] com ζ_h=0.02 e ζ_α=0.01, e simule resposta a rajada de vento.",
                              "finalVerifications": [
                                "Equações de movimento incluem corretamente [C]{˙q} derivado via variacional.",
                                "Matriz [C] é proporcional e reproduz fatores de amortecimento especificados.",
                                "Simulações mostram decaimento estável sem oscilações divergentes.",
                                "Análise modal confirma raízes com partes reais negativas.",
                                "Modelo aplicado com sucesso a exemplo aeroespacial realista.",
                                "Documentação inclui derivações e código reproduzível."
                              ],
                              "assessmentCriteria": [
                                "Precisão e rigor na derivação variacional (80% peso).",
                                "Correta montagem e propriedades de [C] (15% peso).",
                                "Qualidade das simulações e análises (validação numérica).",
                                "Relevância ao contexto aeroespacial (exemplos práticos).",
                                "Clareza na documentação de passos e resultados.",
                                "Identificação de limitações do modelo Rayleigh."
                              ],
                              "crossCurricularConnections": [
                                "Análise Modal e Vibrações em Engenharia Mecânica.",
                                "Aeroelasticidade e Controle Ativo de Flutter.",
                                "Simulações Numéricas em CFD e FEM.",
                                "Otimização de Parâmetros em Engenharia Aeroespacial."
                              ],
                              "realWorldApplication": "Em projetos de aeronaves, como o Boeing 787, o amortecimento de Rayleigh é incorporado em modelos MDOF de asas para prever e mitigar flutter durante o design, garantindo estabilidade em regime transônico e evitando falhas catastróficas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.5.3.3",
                            "name": "Resolver numericamente equações para 2 DOF",
                            "description": "Implementar solução numérica das equações de movimento MDOF para excitações iniciais ou harmônicas, usando métodos como Runge-Kutta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular as equações de movimento para um sistema 2 DOF",
                                  "subSteps": [
                                    "Escolha um modelo físico típico, como duas massas conectadas por molas e amortecedores.",
                                    "Derive as equações diferenciais de segunda ordem para cada grau de liberdade.",
                                    "Monte as matrizes de massa [M], amortecimento [C] e rigidez [K] no formato [M]{¨x} + [C]{˙x} + [K]{x} = {F(t)}.",
                                    "Defina condições iniciais {x(0)} e {˙x(0)} ou excitação harmônica F(t) = {A} sin(ωt).",
                                    "Verifique dimensionalidade e unidades das matrizes."
                                  ],
                                  "verification": "Matrizes [M], [C], [K] são simétricas positivas definidas e equações balanceadas.",
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "Livro de dinâmica estrutural (ex: Chopra)",
                                    "Papel e lápis ou software simbólico como SymPy"
                                  ],
                                  "tips": "Comece com sistema sem acoplamento para validar individualmente cada DOF.",
                                  "learningObjective": "Entender a modelagem matricial de sistemas MDOF.",
                                  "commonMistakes": [
                                    "Esquecer termos de acoplamento nas matrizes",
                                    "Inverter índices nas matrizes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Converter equações para forma de primeira ordem",
                                  "subSteps": [
                                    "Defina vetor de estado y = [{x}; {˙x}] com dimensão 4 para 2 DOF.",
                                    "Escreva o sistema como {˙y} = f(t, y) = [ {˙x}; -[M]^{-1}([C]{˙x} + [K]{x} - {F(t)}) ].",
                                    "Implemente função para calcular [M]^{-1} e f(t,y).",
                                    "Teste f(t,y) com valores iniciais simples.",
                                    "Inclua excitação harmônica em F(t)."
                                  ],
                                  "verification": "˙y calculado é consistente com equações originais para estado conhecido.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Python com NumPy ou MATLAB"
                                  ],
                                  "tips": "Use np.linalg.inv() com cuidado; prefira solvers lineares para eficiência.",
                                  "learningObjective": "Preparar sistema para solvers de EDOs numéricos.",
                                  "commonMistakes": [
                                    "Erro no sinal da aceleração",
                                    "Dimensões erradas no vetor de estado"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o método Runge-Kutta de ordem 4 (RK4)",
                                  "subSteps": [
                                    "Defina parâmetros: dt (passo de tempo), t_final, y0.",
                                    "Implemente loop temporal com os 4 estágios k1 = f(t,y), k2 = f(t+dt/2, y+dt/2 k1), etc.",
                                    "Atualize y_{n+1} = y_n + dt/6 (k1 + 2k2 + 2k3 + k4).",
                                    "Armazene histórico de y em arrays para plotting.",
                                    "Adicione tratamento para F(t) harmônica ou inicial."
                                  ],
                                  "verification": "Solução para oscilador simples (1 DOF) converge para analítica com dt pequeno.",
                                  "estimatedTime": "2-3 hours",
                                  "materials": [
                                    "Python (NumPy, Matplotlib) ou MATLAB"
                                  ],
                                  "tips": "Vectorize computações para velocidade; use dt adaptativo se possível.",
                                  "learningObjective": "Dominar implementação manual de integradores numéricos.",
                                  "commonMistakes": [
                                    "Fator 1/6 errado na atualização",
                                    "Não resetar tempo em k_i"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular e visualizar respostas para excitações específicas",
                                  "subSteps": [
                                    "Execute simulação para condições iniciais (ex: deslocamento em um DOF).",
                                    "Execute para excitação harmônica (ex: força sinusoidal em um DOF).",
                                    "Gere plots: deslocamentos, velocidades vs tempo; fase space.",
                                    "Compare com solução analítica para caso desacoplado.",
                                    "Analise modos de vibração observados."
                                  ],
                                  "verification": "Plots mostram comportamento físico esperado (oscilações amortecidas).",
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "Jupyter Notebook para interatividade"
                                  ],
                                  "tips": "Use subplots para múltiplas variáveis; normalize frequências.",
                                  "learningObjective": "Interpretar resultados dinâmicos de simulações MDOF.",
                                  "commonMistakes": [
                                    "Escala errada nos eixos",
                                    "Confundir DOFs nos plots"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar precisão e sensibilidade numérica",
                                  "subSteps": [
                                    "Teste convergência variando dt e compare com solução exata.",
                                    "Verifique conservação de energia em sistema sem amortecimento.",
                                    "Analise erro global com norma L2.",
                                    "Estude sensibilidade a parâmetros (m, k, c).",
                                    "Otimize código para estabilidade."
                                  ],
                                  "verification": "Erro < 1% para dt=0.01; energia conservada dentro de 0.1%.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Código anterior"
                                  ],
                                  "tips": "Calcule energia total E = 1/2 ˙x^T M ˙x + 1/2 x^T K x.",
                                  "learningObjective": "Avaliar robustez de soluções numéricas.",
                                  "commonMistakes": [
                                    "Ignorar acúmulo de erro numérico",
                                    "dt muito grande causando instabilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um sistema 2 DOF representando duas massas iguais (m=1 kg) conectadas por molas (k11=2, k12=-1, k22=2 N/m) sem amortecimento, com condição inicial x1(0)=1m, x2(0)=0, velocidades zero. Plote deslocamentos e verifique modos normais.",
                              "finalVerifications": [
                                "Código RK4 executa sem erros para múltiplas simulações.",
                                "Resultados convergem com refinamento de dt.",
                                "Energia mecânica é aproximadamente conservada em casos sem dissipação.",
                                "Respostas harmônicas mostram amplificação/resonância correta.",
                                "Plots incluem deslocamentos, velocidades e trajetórias de fase.",
                                "Comparação com solução analítica para 1 DOF coincide."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erro <1% vs referência.",
                                "Eficiência: tempo de execução razoável (<10s para t=10s).",
                                "Clareza do código: comentários e estrutura modular.",
                                "Qualidade visual: gráficos legíveis com labels e legendas.",
                                "Robustez: lida com diferentes condições iniciais/forçantes.",
                                "Análise: interpretação física dos resultados incluída."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Solução de EDOs rígidas.",
                                "Programação: Implementação de algoritmos iterativos em Python/MATLAB.",
                                "Física: Princípios de dinâmica linear e vibrações.",
                                "Engenharia de Controle: Preparação para análise de estabilidade.",
                                "Computação Científica: Uso de bibliotecas como SciPy para validação."
                              ],
                              "realWorldApplication": "Análise de vibrações em estruturas aeroespaciais como asas de aeronaves ou painéis de satélites sob cargas harmônicas (ex: turbulência), prevendo flutter ou fadiga para design seguro."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.5.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.4",
                "name": "Análise de Estruturas Contínuas e Método dos Elementos Finitos",
                "description": "Inclui métodos de análise da dinâmica de estruturas contínuas com parâmetros concentrados e análise dinâmica pelo Método de Elementos Finitos.",
                "totalSkills": 38,
                "atomicTopics": [
                  {
                    "id": "10.1.4.1",
                    "name": "Análise de Estruturas Contínuas com Parâmetros Concentrados",
                    "description": "Métodos para modelar e analisar dinamicamente estruturas contínuas utilizando massas, rigidezes e amortecimentos concentrados.",
                    "individualConcepts": [
                      {
                        "id": "57.3.1.1",
                        "name": "Modelagem de Estruturas Contínuas com Massas Concentradas",
                        "description": "Representação aproximada de estruturas contínuas, como vigas ou placas aeroespaciais, por meio de modelos discretos que concentram massas em pontos discretos ao longo da estrutura, preservando as propriedades dinâmicas essenciais.",
                        "specificSkills": [
                          {
                            "id": "57.3.1.1.1",
                            "name": "Identificar pontos de concentração de massa em estruturas contínuas",
                            "description": "Determinar locais ótimos para posicionar massas concentradas em vigas, placas ou cascas aeroespaciais, baseando-se em distribuições de massa reais e modos de vibração dominantes, para minimizar erros na aproximação dinâmica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Estruturas Contínuas e Modelagem com Massas Concentradas",
                                  "subSteps": [
                                    "Estude as equações diferenciais de vibração para vigas (Euler-Bernoulli), placas e cascas.",
                                    "Aprenda o conceito de aproximação lumped-mass, onde massas distribuídas são concentradas em pontos discretos.",
                                    "Analise impactos na precisão dinâmica: perda de precisão em modos altos vs. simplificação computacional.",
                                    "Revise matrizes de massa consistentes vs. lumpadas em métodos numéricos.",
                                    "Pratique derivando equações de movimento para uma viga com massa distribuída aproximada."
                                  ],
                                  "verification": "Resolva um problema simples de viga livre e compare frequências com solução exata (erro <5%).",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Livro 'Vibration of Continuous Systems' de Rao",
                                    "Software MATLAB ou Python (SciPy)",
                                    "Notas de aula sobre equações de vigas"
                                  ],
                                  "tips": "Comece com vigas uniformes para construir intuição antes de geometrias complexas.",
                                  "learningObjective": "Compreender os princípios teóricos da modelagem de massas concentradas em estruturas contínuas.",
                                  "commonMistakes": [
                                    "Confundir massas lumpadas com carregamentos pontuais",
                                    "Ignorar efeitos de rotação inercial",
                                    "Subestimar o número mínimo de massas necessárias"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Caracterizar Distribuições de Massa Reais em Componentes Aeroespaciais",
                                  "subSteps": [
                                    "Colete dados de massa de componentes reais: perfis de densidade em asas, fuselagens ou painéis compostos.",
                                    "Use CAD ou FEM para extrair distribuições volumétricas de massa (ex: ANSYS ou NASTRAN).",
                                    "Calcule o centro de massa e momentos de inércia para seções críticas.",
                                    "Identifique regiões de alta densidade: motores, atuadores, reforços estruturais.",
                                    "Crie histogramas ou curvas cumulativas de distribuição de massa ao longo da estrutura."
                                  ],
                                  "verification": "Gere um gráfico de distribuição de massa para uma viga de asa e identifique top 20% de massa concentrada.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Dados CAD de aeronaves (ex: modelo NACA airfoil)",
                                    "Software FEM como ANSYS Student",
                                    "Planilhas Excel para análise estatística"
                                  ],
                                  "tips": "Priorize dados reais de aeronaves; use literatura para estimativas se necessário.",
                                  "learningObjective": "Mapear distribuições de massa reais para identificar candidatos iniciais a concentrações.",
                                  "commonMistakes": [
                                    "Usar densidades uniformes em vez de reais",
                                    "Negligenciar variações locais devido a furações ou compostos",
                                    "Focar apenas em massa total, ignorando distribuição espacial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Modos de Vibração Dominantes",
                                  "subSteps": [
                                    "Realize análise modal em software FEM para obter modos e frequências naturais.",
                                    "Selecione modos dominantes: tipicamente os 3-5 primeiros modos de flexão/torção.",
                                    "Calcule formas modais (mode shapes) e identifique picos de deformação/amplitude.",
                                    "Avalie participação modal (modal mass) para priorizar modos energéticos.",
                                    "Compare com dados experimentais ou analíticos para validação."
                                  ],
                                  "verification": "Liste os 3 modos dominantes com frequências e nodos principais para uma placa retangular.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Software NASTRAN ou Abaqus",
                                    "Tutoriais de análise modal online",
                                    "Dados experimentais de shake table tests"
                                  ],
                                  "tips": "Visualize mode shapes em 3D para intuitivamente ver regiões críticas.",
                                  "learningObjective": "Extrair modos relevantes que guiam a colocação de massas para capturar dinâmica precisa.",
                                  "commonMistakes": [
                                    "Incluir modos irrelevantes de alta frequência",
                                    "Ignorar modos acoplados flexão-torção em asas",
                                    "Não normalizar formas modais corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Otimizar Posições de Massas Concentradas e Validar Precisão",
                                  "subSteps": [
                                    "Posicione massas nos picos de mode shapes dos modos dominantes, agrupando massas reais próximas.",
                                    "Use otimização: minimize erro em frequências/modais via algoritmo genético ou gradiente.",
                                    "Compare respostas dinâmicas: frequências, mode shapes entre modelo contínuo e lumpado.",
                                    "Calcule métricas de erro: MAC (Modal Assurance Criterion) > 0.9 para modos chave.",
                                    "Itere: refine posições se erro >5% em frequências fundamentais."
                                  ],
                                  "verification": "Demonstre redução de erro de 15% para 3% em frequências de uma viga com 5 massas otimizadas.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "MATLAB Optimization Toolbox",
                                    "Python com libraries como ModalPy e PyMOO",
                                    "Modelos FEM benchmark"
                                  ],
                                  "tips": "Comece com 4-6 massas; mais que isso perde vantagem da aproximação.",
                                  "learningObjective": "Determinar posições ótimas que minimizam erros na aproximação dinâmica.",
                                  "commonMistakes": [
                                    "Colocar massas uniformemente em vez de modal",
                                    "Não validar com múltiplos modos",
                                    "Sobrecarregar pontos levando a singularidades na matriz de massa"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma viga representando a longarina de uma asa de UAV (comprimento 2m, massa distribuída ρ=500 kg/m³), identifique modos de flexão dominantes via FEM. Posicione 4 massas concentradas nos picos do 1º e 2º modos (próximo a 0.25L, 0.5L, 0.75L), totalizando 80% da massa total, reduzindo erro em frequências de 12% para 3%.",
                              "finalVerifications": [
                                "Identifica corretamente picos de mode shapes em vigas/placas.",
                                "Posiciona massas capturando >75% da massa real com <5% erro em frequências.",
                                "Justifica escolhas baseadas em distribuições reais e modos dominantes.",
                                "Valida modelo lumpado vs. contínuo usando MAC >0.9.",
                                "Aplica a cascas aeroespaciais com torção acoplada.",
                                "Documenta processo com gráficos de mode shapes e erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de modos dominantes (frequências <2% erro).",
                                "Otimização eficaz: redução mínima de erro dinâmica (>10%).",
                                "Justificativa técnica robusta ligada a distribuições reais.",
                                "Uso correto de ferramentas FEM/otimização.",
                                "Cobertura de múltiplas estruturas (viga, placa, casca).",
                                "Análise de trade-offs computacionais vs. precisão."
                              ],
                              "crossCurricularConnections": [
                                "Análise Modal em Dinâmica de Aeronaves (ST-57).",
                                "Método dos Elementos Finitos para simulações (ST-57.3).",
                                "Otimização em Design Estrutural (Engenharia Aeroespacial).",
                                "Vibrações e Controle Ativo (Aeroelasticidade).",
                                "Programação Numérica para Automatização (Python/MATLAB)."
                              ],
                              "realWorldApplication": "No design de asas de aviões comerciais (ex: Boeing 787), otimizar massas concentradas acelera simulações dinâmicas em 50x, permitindo análise rápida de flutter e fadiga sob cargas reais, reduzindo custos de certificação FAA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.3.1.1.2",
                            "name": "Formular o modelo dinâmico com massas concentradas",
                            "description": "Derivar as equações de movimento para um sistema multi-graus de liberdade utilizando massas concentradas conectadas por elementos elásticos ideais, aplicando princípios variacionais como Lagrange ou Hamilton.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o modelo físico do sistema com massas concentradas",
                                  "subSteps": [
                                    "Identificar as massas concentradas (m_i) e suas posições de equilíbrio.",
                                    "Desenhar o diagrama esquemático do sistema, indicando conexões elásticas (mol as k_ij).",
                                    "Determinar os graus de liberdade (DOF) e coordenadas generalizadas (q_j).",
                                    "Especificar condições de contorno ou restrições cinemáticas.",
                                    "Listar suposições ideais: massas puntiformes, elementos elásticos sem massa, amortecimento nulo."
                                  ],
                                  "verification": "Produzir um diagrama completo com DOFs anotados e lista de coordenadas generalizadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel milimetrado ou software de desenho (ex: Draw.io)",
                                    "Referência: Livro de Dinâmica de Estruturas (ex: Clough & Penzien)"
                                  ],
                                  "tips": "Comece com sistemas de 2 DOF para visualização intuitiva antes de generalizar.",
                                  "learningObjective": "Modelar corretamente um sistema multi-DOF com massas concentradas e identificar coordenadas generalizadas.",
                                  "commonMistakes": [
                                    "Confundir deslocamentos translacionais com rotações",
                                    "Ignorar acoplamentos entre massas",
                                    "Esquecer de definir origem de equilíbrio"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Expressar a energia cinética (T) em termos das coordenadas generalizadas",
                                  "subSteps": [
                                    "Calcular velocidades das massas: v_i = dq_j/dt para cada massa.",
                                    "Formular T = Σ (1/2 m_i ||v_i||²), expandindo para coordenadas generalizadas.",
                                    "Obter a matriz de massa [M] tal que T = (1/2) {q̇}^T [M] {q̇}.",
                                    "Verificar simetria e positivos definitos de [M].",
                                    "Simplificar para sistemas lineares pequenos."
                                  ],
                                  "verification": "Derivar expressão quadrática de T e matriz [M] correta para um exemplo de 2 DOF.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Calculadora simbólica (ex: Mathematica ou SymPy)",
                                    "Folha de exercícios com sistemas modelo"
                                  ],
                                  "tips": "Use vetores de deslocamento para generalizar: x_i = Σ φ_{ij} q_j.",
                                  "learningObjective": "Derivar a forma cinética matricial para sistemas discretizados.",
                                  "commonMistakes": [
                                    "Erro em Jacobianas para velocidades",
                                    "Confundir matriz de massa com rigidez",
                                    "Não considerar acoplamentos cinéticos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Expressar a energia potencial (V) em termos das coordenadas generalizadas",
                                  "subSteps": [
                                    "Definir deformações elásticas nos elementos: δ_k = q_j - q_i para molas conectadas.",
                                    "Formular V = Σ (1/2 k_k δ_k²) para elementos elásticos lineares.",
                                    "Obter a matriz de rigidez [K] tal que V = (1/2) {q}^T [K] {q}.",
                                    "Verificar simetria e semi-definido positivo de [K].",
                                    "Incluir pré-tensões ou cargas se aplicável."
                                  ],
                                  "verification": "Derivar [K] correta e validar com equilíbrio estático [K]{q} = {F}.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de álgebra simbólica",
                                    "Tabelas de matrizes de rigidez para elementos"
                                  ],
                                  "tips": "Monte [K] por superposição de contribuições elementares.",
                                  "learningObjective": "Construir a forma potencial elástica matricial.",
                                  "commonMistakes": [
                                    "Sinais errados em deformações relativas",
                                    "Duplicar contribuições de rigidez",
                                    "Ignorar rigidez geométrica"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar princípios variacionais para derivar equações de movimento",
                                  "subSteps": [
                                    "Formular o Lagrangiano L = T - V.",
                                    "Aplicar equações de Lagrange: d/dt (∂L/∂q̇_j) - ∂L/∂q_j = Q_j (forças não conservativas).",
                                    "Derivar [M]{q̈} + [K]{q} = {Q} para o caso linear.",
                                    "Alternativa: Usar Hamiltoniano H = T + V e equações canônicas.",
                                    "Generalizar para não-lineares se necessário."
                                  ],
                                  "verification": "Obter equações desacopladas para modos normais em sistema simples.",
                                  "estimatedTime": "1,5 horas",
                                  "materials": [
                                    "Apostila de Mecânica Lagrangiana",
                                    "Exemplos resolvidos de multi-DOF"
                                  ],
                                  "tips": "Verifique com energia total conservada em ausência de dissipação.",
                                  "learningObjective": "Derivar EOMs dinâmicas via Lagrange ou Hamilton.",
                                  "commonMistakes": [
                                    "Erro no sinal do Lagrangiano (L = T - V)",
                                    "Derivadas parciais incorretas",
                                    "Confundir Q_j com forças inerciais"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e interpretar o modelo dinâmico",
                                  "subSteps": [
                                    "Verificar limites: regime estático ([M]=0) e frequências naturais.",
                                    "Calcular autovalores para modos e frequências: det([K] - ω²[M])=0.",
                                    "Simular numericamente uma solução (ex: resposta livre).",
                                    "Analisar sensibilidade a parâmetros (m, k).",
                                    "Documentar o modelo completo em forma matricial."
                                  ],
                                  "verification": "Resolver problema de autovalores e comparar com solução analítica conhecida.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "MATLAB ou Python (SciPy) para eigenvalues",
                                    "Gráficos de modos"
                                  ],
                                  "tips": "Use orthogonalidade dos modos para validação.",
                                  "learningObjective": "Validar o modelo e extrair insights dinâmicos.",
                                  "commonMistakes": [
                                    "Erro numérico em autovalores",
                                    "Interpretar modos físicos incorretamente",
                                    "Ignorar normalização"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma viga em flexão aproximada por 2 massas concentradas (m1 na raiz, m2 na ponta) conectadas por 2 molas equivalentes (k1, k2 derivadas da rigidez flexural EI). Deslocamentos verticais q1, q2. Derive T = (1/2)(m1 q̇1² + m2 q̇2²), V = (1/2)(k1 q1² + k2 (q2 - q1)²), aplique Lagrange para obter [M]{q̈} + [K]{q} = 0, e calcule frequências naturais.",
                              "finalVerifications": [
                                "Matriz [M] é simétrica e positiva definida.",
                                "Matriz [K] é simétrica e semi-definida positiva.",
                                "Equações reduzem corretamente ao caso de 1 DOF.",
                                "Frequências naturais ω_n crescem com rigidez e decrescem com massa.",
                                "Modos de vibração são ortogonais.",
                                "Solução numérica bate com analítica para sistema conhecido."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de T, V e EOMs (80%).",
                                "Clareza e organização do diagrama e passos (10%).",
                                "Validação correta com autovalores e interpretação física (10%).",
                                "Generalização para n-DOF demonstrada.",
                                "Ausência de erros dimensionais ou de sinal.",
                                "Uso adequado de notação matricial."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e autovalores.",
                                "Programação: Implementação em MATLAB/Python para simulação dinâmica.",
                                "Física Geral: Conservação de energia em osciladores acoplados.",
                                "Engenharia de Controle: Estados espaciais para simulação.",
                                "Análise Numérica: Método dos Elementos Finitos como extensão."
                              ],
                              "realWorldApplication": "Modelagem de flutter aeroelástico em asas de aeronaves, onde massas concentradas aproximam inércias distribuídas, permitindo prever instabilidades dinâmicas e otimizar designs para evitar ressonâncias críticas em voo."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.3.1.1.3",
                            "name": "Calcular massas equivalentes para aproximação lumped",
                            "description": "Computar valores de massas concentradas equivalentes a partir da densidade linear ou superficial da estrutura contínua, considerando fatores de correção para modos de flexão e torção em componentes aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Massas Distribuídas e Aproximação Lumped",
                                  "subSteps": [
                                    "Estude a diferença entre massas distribuídas contínuas e massas concentradas (lumped) em estruturas aeroespaciais.",
                                    "Revise equações de densidade linear (ρ_l = m/L) para vigas e densidade superficial (ρ_s = m/A) para placas.",
                                    "Identifique a necessidade de fatores de correção para modos de flexão (ex: 17/35 para vigas Euler-Bernoulli) e torção.",
                                    "Analise distribuições modais típicas em componentes como asas ou fuselagens.",
                                    "Compile fórmulas padrão para massas equivalentes em pontos nodais."
                                  ],
                                  "verification": "Resuma em um diagrama comparativo massas distribuídas vs. lumped, citando pelo menos 3 referências teóricas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro 'Vibration of Mechanical Systems' de Alok Sinha",
                                    "Notas de aula sobre dinâmica de estruturas aeroespaciais",
                                    "Calculadora ou software simbólico como Mathematica"
                                  ],
                                  "tips": "Use analogias com massas pontuais em circuitos elétricos para visualizar a aproximação.",
                                  "learningObjective": "Compreender os princípios teóricos que justificam a aproximação lumped mass em análises dinâmicas.",
                                  "commonMistakes": [
                                    "Confundir densidade linear com volumétrica",
                                    "Ignorar variações modais na distribuição de massa",
                                    "Não considerar simetria da estrutura"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Massa Total e Densidade Efetiva",
                                  "subSteps": [
                                    "Determine a massa total M da estrutura contínua integrando ρ_l dl ou ρ_s dA.",
                                    "Divida a estrutura em N elementos discretos e calcule massas elementares m_e = ρ_l * L_e.",
                                    "Posicione massas nodais iniciais sem correção: m_i = (m_e,i + m_e,i+1)/2.",
                                    "Verifique conservação de massa: soma(m_i) ≈ M.",
                                    "Ajuste para densidades não-uniformes usando integração numérica se necessário."
                                  ],
                                  "verification": "Confirme que a soma das massas nodais equals a massa total com erro <1%.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Planilha Excel ou MATLAB para cálculos",
                                    "Dados de exemplo de uma viga cantilever com ρ_l = 100 kg/m",
                                    "Papel milimetrado para esboços"
                                  ],
                                  "tips": "Sempre normalize unidades (kg, m) antes de prosseguir para evitar erros de escala.",
                                  "learningObjective": "Dominar o cálculo básico de massas equivalentes sem fatores modais.",
                                  "commonMistakes": [
                                    "Duplicar massas em nós compartilhados",
                                    "Usar comprimento total em vez de elementar",
                                    "Esquecer contribuições de ambos os lados do nó"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Fatores de Correção para Modos de Flexão e Torção",
                                  "subSteps": [
                                    "Para flexão: multiplique m_i por μ_b = 17/35 (viga) ou fatores finitos para placas.",
                                    "Para torção: use μ_t = 1/3 para barras uniformes ou valores tabulados para perfis aeroespaciais.",
                                    "Combine modos mistos: m_eq = α m_b + (1-α) m_t, onde α é fração modal.",
                                    "Incorpore efeitos de cisalhamento e rotação inercial se aplicável (GJ/A).",
                                    "Recalcule matriz de massa [M] lumped com fatores aplicados."
                                  ],
                                  "verification": "Compare frequências naturais aproximadas com soluções exatas (erro <5%).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software ANSYS ou NASTRAN para validação",
                                    "Tabelas de fatores de correção de Rao ou Meirovitch",
                                    "Script MATLAB para automação"
                                  ],
                                  "tips": "Consulte tabelas padrão para perfis I ou caixa em aeronaves para fatores realistas.",
                                  "learningObjective": "Aplicar correções modais precisas para melhorar a fidelidade do modelo lumped.",
                                  "commonMistakes": [
                                    "Aplicar fator de flexão a torção",
                                    "Usar fatores de viga em placas sem ajuste",
                                    "Negligenciar modos superiores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Integrar no Modelo Dinâmico",
                                  "subSteps": [
                                    "Monte equações de movimento [M]{¨q} + [K]{q} = {F} com massas corrigidas.",
                                    "Resolva autovalores para frequências e modos, comparando com contínuo.",
                                    "Realize análise de sensibilidade variando fatores de correção ±10%.",
                                    "Documente o modelo final com diagrama esquemático.",
                                    "Teste em software para convergência com mesh refinada."
                                  ],
                                  "verification": "Frequências modais coincidem com benchmark em <3% de erro relativo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB com toolbox Vibration",
                                    "Exemplo de asa NACA0012",
                                    "Benchmark de Timoshenko beam"
                                  ],
                                  "tips": "Use plot de modos para visualizar distribuição efetiva de massa.",
                                  "learningObjective": "Integrar massas lumped em análises dinâmicas completas e validar resultados.",
                                  "commonMistakes": [
                                    "Erro na montagem da matriz de massa",
                                    "Comparar com modelo sem correção",
                                    "Ignorar damping na validação"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma viga cantilever de asa (L=5m, ρ_l=50 kg/m), calcule 5 massas nodais lumped: m_total=250kg. Sem correção: m_i=50kg cada. Com flexão (17/35≈0.486): m_eq,i ajustadas para 24.3kg nos nós internos, preservando M e aproximando 1º modo em 10.2 Hz (exato: 10.5 Hz).",
                              "finalVerifications": [
                                "Soma das massas lumped equals massa total distribuída (±0.1%).",
                                "Frequências dos primeiros 3 modos dentro de 5% da solução analítica.",
                                "Distribuição modal visualmente similar ao contínuo.",
                                "Matriz de massa diagonal dominante e positiva definida.",
                                "Correções aplicadas corretamente para flexão/torção.",
                                "Análise de sensibilidade confirma estabilidade do modelo."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de densidade e massas elementares (erro <1%).",
                                "Correta aplicação de fatores modais com justificativa teórica.",
                                "Validação quantitativa com métricas de erro claras.",
                                "Clareza na documentação de steps e suposições.",
                                "Eficiência computacional demonstrada vs. modelo full.",
                                "Tratamento de casos não-uniformes ou 2D."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Integração numérica e autovalores (Álgebra Linear).",
                                "Física: Dinâmica de sistemas multi-graus de liberdade.",
                                "Engenharia Mecânica: Vibrações e métodos modais.",
                                "Computação: Programação em MATLAB para simulações dinâmicas.",
                                "Design Aeroespacial: Otimização de estruturas leves."
                              ],
                              "realWorldApplication": "Em projetos de aeronaves como o Boeing 787, massas lumped equivalentes aceleram simulações de flutter e fadiga em painéis de asa, reduzindo tempo de análise de dias para horas no NASTRAN, garantindo certificação FAA com precisão modal crítica para estabilidade em voo."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "57.3.1.2",
                        "name": "Incorporação de Rigidezes e Amortecimentos Concentrados",
                        "description": "Integração de molas e amortecedores concentrados nos modelos de massas puntiformes para capturar a rigidez flexural/torsional e dissipação de energia em estruturas contínuas aeroespaciais.",
                        "specificSkills": [
                          {
                            "id": "57.3.1.2.1",
                            "name": "Determinar rigidezes concentradas equivalentes",
                            "description": "Calcular constantes de rigidez para elementos concentrados que aproximem a rigidez distribuída de vigas Euler-Bernoulli ou placas, utilizando relações de energia potencial ou matrizes de flexibilidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Vigas Euler-Bernoulli e Teoria de Placas",
                                  "subSteps": [
                                    "Estude a equação diferencial da viga Euler-Bernoulli: EI d⁴w/dx⁴ = q(x).",
                                    "Revise o conceito de rigidez distribuída (EI constante ou variável) versus rigidez concentrada (k nodal).",
                                    "Analise a teoria de placas de Kirchhoff para flexão: ∇⁴w = q/D, onde D é a rigidez flexural.",
                                    "Identifique diferenças entre deformações distribuídas e aproximadas por elementos concentrados.",
                                    "Calcule manualmente a energia de deformação para uma viga simples sob carga pontual."
                                  ],
                                  "verification": "Resuma em um diagrama comparativo rigidez distribuída vs. concentrada, com fórmulas chave.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'Theory of Elastic Stability' de Timoshenko",
                                    "Notas de aula sobre Euler-Bernoulli",
                                    "Calculadora simbólica como SymPy ou Mathematica"
                                  ],
                                  "tips": "Use analogias mecânicas: rigidez distribuída como mola contínua, concentrada como mola discreta.",
                                  "learningObjective": "Compreender as bases teóricas para justificar aproximações de rigidez.",
                                  "commonMistakes": [
                                    "Confundir momento fletor com rigidez flexural",
                                    "Ignorar condições de contorno na equação diferencial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar Rigidez Equivalente Usando Energia Potencial para Vigas",
                                  "subSteps": [
                                    "Estabeleça o princípio de energia potencial mínima: δU + δV = 0, onde U é energia de deformação e V é potencial de cargas.",
                                    "Para uma viga dividida em n segmentos, expresse U = ∫ (EI/2) (d²w/dx²)² dx ao longo do comprimento.",
                                    "Aproxime o deslocamento w(x) por funções de forma lineares ou quadráticas nos nós.",
                                    "Equacione a rigidez concentrada k_eq tal que U_concentrada = U_distribuída para o mesmo deslocamento nodal.",
                                    "Resolva para k_eq = (∫ EI (d²φ/dx²)² dx) / (φ_nodal)², onde φ é a função de forma."
                                  ],
                                  "verification": "Derive a fórmula de k_eq para uma viga cantilever de comprimento L e compare com k = 3EI/L³.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Papel e lápis para derivações",
                                    "Software MATLAB ou Python para integração numérica",
                                    "Exemplos resolvidos de livros de elementos finitos"
                                  ],
                                  "tips": "Comece com funções de forma polinomiais simples para evitar complexidade inicial.",
                                  "learningObjective": "Dominar o método de energia para equivalência em vigas 1D.",
                                  "commonMistakes": [
                                    "Esquecer o fator 1/2 na energia de deformação",
                                    "Não normalizar corretamente os deslocamentos nodais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estender para Placas e Usar Matrizes de Flexibilidade",
                                  "subSteps": [
                                    "Adapte o método de energia para placas: U = ∫∫ (D/2) [(∇²w)² - 2(1-ν)(w_xx w_yy - w_xy²)] dA.",
                                    "Aproxime w(x,y) por funções de forma bidimensionais (ex: bilinear).",
                                    "Construa a matriz de flexibilidade [F] = ∫∫ [B]^T [D]^{-1} [B] dA, onde [B] é a matriz de curvatura.",
                                    "Inverta [F] para obter [K_eq], a matriz de rigidez equivalente concentrada.",
                                    "Compare resultados para uma placa quadrada simply supported."
                                  ],
                                  "verification": "Monte [K_eq] 2x2 para uma placa e verifique equilíbrio sob carga central.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Livro 'Finite Element Procedures' de Bathe",
                                    "MATLAB com toolbox de elementos finitos",
                                    "Planilhas Excel para matrizes pequenas"
                                  ],
                                  "tips": "Use simetria para reduzir dimensões em placas regulares.",
                                  "learningObjective": "Aplicar métodos energéticos e matriciais a estruturas 2D.",
                                  "commonMistakes": [
                                    "Erro no operador de bi-harmônico para placas",
                                    "Confundir flexibilidade [F] com rigidez [K]"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Validar em Exemplos Práticos",
                                  "subSteps": [
                                    "Selecione uma viga Euler-Bernoulli real de aeronave (ex: asa cantilever) e discretize em 2-3 nós.",
                                    "Calcule k_eq analiticamente e numéricamente, comparando erros <5%.",
                                    "Repita para uma placa de fuselage, usando propriedades de compósitos.",
                                    "Implemente em código para automação e sensibilidade a parâmetros (L, EI).",
                                    "Analise convergência ao refinar a malha."
                                  ],
                                  "verification": "Gráfico de erro vs. número de elementos, com k_eq convergindo para o exato.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Dados de materiais aeroespaciais (ex: alumínio 7075)",
                                    "Software ANSYS ou similar para validação"
                                  ],
                                  "tips": "Sempre normalize unidades (N/m para k em vigas).",
                                  "learningObjective": "Integrar teoria em simulações práticas com validação.",
                                  "commonMistakes": [
                                    "Unidades inconsistentes em energia",
                                    "Sobrestimar rigidez em aproximações grosseiras"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Testar Compreensão",
                                  "subSteps": [
                                    "Resolva um problema híbrido: viga com seção em placa.",
                                    "Discuta limitações (ex: cisalhamento em vigas Timoshenko).",
                                    "Crie um fluxograma do processo completo.",
                                    "Ensine o conceito a um par, respondendo dúvidas.",
                                    "Documente um relatório com derivações e código."
                                  ],
                                  "verification": "Relatório aprovado com todas as fórmulas derivadas e código funcional.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Template de relatório LaTeX",
                                    "Gravador de tela para explicação oral"
                                  ],
                                  "tips": "Explique como se fosse para um engenheiro júnior.",
                                  "learningObjective": "Consolidar conhecimento para aplicação independente.",
                                  "commonMistakes": [
                                    "Ignorar efeitos de Poisson em placas",
                                    "Não considerar modos de falha além da flexão"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma viga cantilever de L=1m, EI=1e6 Nm² sob ponta livre δ=1mm, derive k_eq=3EI/L³=3e6 N/m. Valide integrando U_dist = ∫(EI/2)(3δx²/L³ - ...) dx = (3EI δ²)/(2L³), igual a U_conc=(1/2)k δ².",
                              "finalVerifications": [
                                "Derivação correta de k_eq para viga cantilever coincide com 3EI/L³.",
                                "Matriz [K_eq] para placa simply supported é simétrica positiva definida.",
                                "Erro de aproximação <2% em exemplo numérico com 3 elementos.",
                                "Código Python reproduz resultados analíticos.",
                                "Explicação oral identifica limitações do modelo Euler-Bernoulli.",
                                "Relatório inclui gráficos de convergência."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações de energia (90%+ correto).",
                                "Correta implementação matricial sem erros de indexação.",
                                "Análise de erros e convergência quantitativa.",
                                "Clareza na documentação e exemplos práticos.",
                                "Integração de conceitos interdisciplinares (energia, matrizes).",
                                "Criatividade em extensão para casos reais aeroespaciais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e métodos de Rayleigh-Ritz.",
                                "Programação: Implementação numérica em Python/MATLAB para EFs.",
                                "Física: Princípios de conservação de energia em estruturas.",
                                "Engenharia de Materiais: Variação de EI em compósitos aeroespaciais.",
                                "Controle de Sistemas: Uso de k_eq em modelos dinâmicos de flutter."
                              ],
                              "realWorldApplication": "Em análise preliminar de asas de aeronaves, rigidezes concentradas equivalentes aceleram simulações de aeroelasticidade no software NASTRAN, reduzindo tempo de malha fina de dias para horas, essencial para certificação FAA em projetos como o Boeing 787."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.3.1.2.2",
                            "name": "Modelar amortecimento com parâmetros concentrados",
                            "description": "Incorporar amortecedores viscosos concentrados no modelo, definindo coeficientes de amortecimento de Rayleigh proporcional às massas e rigidezes, para simular dissipação em vibrações estruturais aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos do amortecimento viscoso Rayleigh",
                                  "subSteps": [
                                    "Estudar a equação de movimento para sistemas com amortecimento: M ü + C u̇ + K u = F.",
                                    "Explicar o modelo de Rayleigh: C = α M + β K, onde α e β são coeficientes proporcionais.",
                                    "Analisar como α domina baixas frequências e β altas frequências.",
                                    "Derivar ξ_i = α/(2 ω_i) + β ω_i / 2 para o fator de amortecimento modal.",
                                    "Resolver exemplos analíticos simples de sistemas SDOF e MDOF."
                                  ],
                                  "verification": "Resumir em um diagrama as relações entre α, β, frequências e ξ, com cálculos corretos para um exemplo dado.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'Dinâmica das Estruturas' de Clough & Penzien",
                                    "Apostilas de vibrações estruturais",
                                    "Software MATLAB para plotar curvas de ξ vs. ω"
                                  ],
                                  "tips": "Comece com sistemas de 1 grau de liberdade para intuitar antes de múltiplos.",
                                  "learningObjective": "Dominar a formulação matemática do amortecimento Rayleigh e sua interpretação física.",
                                  "commonMistakes": [
                                    "Confundir α com β nas faixas de frequência",
                                    "Ignorar a dependência modal do amortecimento",
                                    "Usar unidades inconsistentes em α e β"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir parâmetros concentrados para amortecedores viscosos",
                                  "subSteps": [
                                    "Identificar posições para amortecedores concentrados em modelos discretos (ex.: nós de elementos finitos).",
                                    "Calcular α proporcional à massa total: α = 2 ξ_ref ω_ref, para frequência de referência.",
                                    "Determinar β proporcional à rigidez: β = 2 ξ_ref / ω_ref.",
                                    "Escolher ξ_ref (tipicamente 0.02-0.05) e ω_ref baseada em modais dominantes aeroespaciais.",
                                    "Montar matriz C concentrada adicionando termos nos DOFs relevantes."
                                  ],
                                  "verification": "Calcular α e β para um sistema com ω1=10 rad/s, ω2=50 rad/s, ξ=0.03, e verificar C resultante.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Planilhas Excel ou MATLAB para cálculos matriciais",
                                    "Exemplos de problemas de vibrações aeroespaciais"
                                  ],
                                  "tips": "Use modais de interesse (primeiros 2-3) para escolher ω_ref e evitar superamortecimento em altos modos.",
                                  "learningObjective": "Selecionar e calcular coeficientes de Rayleigh para simular dissipação realista.",
                                  "commonMistakes": [
                                    "Escolher ω_ref inadequada levando a amortecimento excessivo em modais altos",
                                    "Não normalizar massas na matriz M"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar amortecedores concentrados no modelo estrutural discreto",
                                  "subSteps": [
                                    "Partir de um modelo existente com M e K (ex.: viga discretizada por EF).",
                                    "Adicionar elementos de amortecimento concentrado como molas viscosas nos nós selecionados.",
                                    "Atualizar a matriz global C somando contribuições locais: C_local = c [1; -1] [1 -1].",
                                    "Verificar simetria e positivos definitos de M, C e K.",
                                    "Implementar em código para equação geral com amortecimento."
                                  ],
                                  "verification": "Gerar matrizes M, C, K para um modelo de viga com 4 DOFs e plotar autovalores complexos.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Software ANSYS ou MATLAB Structural Dynamics Toolbox",
                                    "Código template para integração numérica Newmark"
                                  ],
                                  "tips": "Concentre amortecedores em áreas de alta deformação modal para eficiência.",
                                  "learningObjective": "Construir modelos dinâmicos realistas com dissipação concentrada.",
                                  "commonMistakes": [
                                    "Erro na montagem da matriz C levando a não-simetria",
                                    "Esquecer de transformar para coordenadas modais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular, analisar e validar o modelo com amortecimento",
                                  "subSteps": [
                                    "Executar análise de vibrações livres: resolver autovalores de (K - λ² M + i λ C).",
                                    "Simular resposta transitória a excitação (ex.: pulso aerodinâmico).",
                                    "Comparar decaimento com e sem amortecimento, medindo tempo de assentamento.",
                                    "Validar contra dados experimentais ou benchmarks aeroespaciais.",
                                    "Ajustar α e β iterativamente para matching de ξ modais."
                                  ],
                                  "verification": "Gráficos mostram decaimento exponencial com taxa correta (ex.: 5% crítico) e ausência de instabilidades.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "MATLAB ou Python (SciPy) para simulações dinâmicas",
                                    "Dados de benchmark de flutter em asas"
                                  ],
                                  "tips": "Use decomposição modal para eficiência em sistemas grandes.",
                                  "learningObjective": "Avaliar numericamente a eficácia do amortecimento em vibrações estruturais.",
                                  "commonMistakes": [
                                    "Instabilidade numérica por timestep inadequado",
                                    "Interpretação errada de partes reais/imaginárias dos autovalores"
                                  ]
                                }
                              ],
                              "practicalExample": "Modelar uma viga cantilever de 2m (representando raiz de asa de aeronave) discretizada em 5 elementos, adicionando amortecedor viscoso Rayleigh na raiz com α=0.5 Ns/m e β=0.001 s, simulando vibração induzida por rajada de vento e verificando dissipação em 10s.",
                              "finalVerifications": [
                                "Matriz C é positiva semi-definida e proporcional a M e K.",
                                "Fatores de amortecimento modais ξ_i estão entre 1-5% para modais aeroespaciais relevantes.",
                                "Simulação de vibração livre mostra decaimento sem oscilações residuais anômalas.",
                                "Resposta forçada exibe pico de resposta reduzido em 30-50% comparado ao não amortecido.",
                                "Autovalores têm partes imaginárias decrescentes corretamente.",
                                "Validação contra solução analítica para caso simples converge dentro de 5%."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação de C Rayleigh (α e β corretos).",
                                "Correta implementação matricial sem erros de montagem.",
                                "Análise modal revela ξ consistentes com especificações.",
                                "Simulações numéricas estáveis e convergentes.",
                                "Interpretação física das respostas (dissipação efetiva).",
                                "Capacidade de ajustar parâmetros para cenários reais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear e autovalores complexos.",
                                "Programação: Implementação numérica em MATLAB/Python para dinâmica.",
                                "Física: Mecânica clássica e dissipação de energia.",
                                "Engenharia Mecânica: Análise de elementos finitos.",
                                "Ciência de Materiais: Propriedades viscoelásticas reais."
                              ],
                              "realWorldApplication": "Em projetos aeroespaciais, como supressão de flutter em asas de aviões comerciais (ex.: Boeing 787), onde amortecedores concentrados simulam tratamentos passivos de vibração, prevenindo fadiga estrutural e ressonâncias catastróficas durante voo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.3.1.2.3",
                            "name": "Validar o modelo contra solução contínua exata",
                            "description": "Comparar frequências e modos do modelo lumped com soluções analíticas ou numéricas exatas para estruturas contínuas, avaliando precisão para diferentes números de parâmetros concentrados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o problema e derivar a solução contínua exata",
                                  "subSteps": [
                                    "Selecione uma estrutura contínua simples, como uma viga em flexão com rigidez ou amortecimento concentrado.",
                                    "Derive as equações diferenciais governantes para o sistema contínuo, incorporando os parâmetros concentrados.",
                                    "Resolva analiticamente ou numéricamente para obter frequências naturais e modos de vibração exatos.",
                                    "Implemente a solução exata em software como MATLAB ou Python para referência.",
                                    "Valide a implementação exata com casos conhecidos ou literatura."
                                  ],
                                  "verification": "Confirme que as frequências e modos exatos correspondem a soluções publicadas para o caso limite sem parâmetros concentrados.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Livro-texto de dinâmica estrutural, MATLAB/Python com bibliotecas simbólicas (SymPy), papel e lápis para derivação.",
                                  "tips": "Comece com um caso simples (viga livre) para testar a derivação antes de adicionar concentrações.",
                                  "learningObjective": "Entender e derivar soluções exatas para sistemas contínuos com singularidades.",
                                  "commonMistakes": "Ignorar condições de contorno nos pontos de concentração; equações diferenciais incorretas nas interfaces."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir modelos lumped com diferentes números de parâmetros concentrados",
                                  "subSteps": [
                                    "Discritize a estrutura contínua em N massas e molas, colocando parâmetros concentrados nos nós apropriados.",
                                    "Formule as matrizes de massa [M] e rigidez [K] para 3-5 valores crescentes de N (ex: 5, 10, 20 lumps).",
                                    "Inclua amortecimento concentrado se aplicável, formando [C].",
                                    "Verifique simetria e positivos definitos das matrizes.",
                                    "Salve os modelos em formato reutilizável (script ou função)."
                                  ],
                                  "verification": "Matrizes [M], [K] devem ser simétricas e de tamanho NxN; autovalores de [K] positivos.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": "Software de análise matricial (MATLAB, NumPy), planilha para discritização manual inicial.",
                                  "tips": "Use distribuição uniforme de massas para convergência rápida; posicione concentrações exatamente nos nós.",
                                  "learningObjective": "Criar discretizações lumped precisas que aproximem o contínuo.",
                                  "commonMistakes": "Distribuição desigual de massas levando a frequências enviesadas; esquecer termos de rotação em vigas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular frequências e modos para modelos lumped e exatos",
                                  "subSteps": [
                                    "Para cada modelo lumped, resolva o problema de autovalores generalizados: [K]φ = ω²[M]φ.",
                                    "Ordene frequências e modos por magnitude crescente.",
                                    "Compare os primeiros M modos (ex: M=5) com os exatos, computando erros relativos em frequências.",
                                    "Calcule MAC (Modal Assurance Criterion) para modos: MAC = |φ_exato^T φ_lumped|² / (||φ_exato||² ||φ_lumped||²).",
                                    "Plote frequências vs. N para observar convergência."
                                  ],
                                  "verification": "Erros relativos <5% para N alto; MAC >0.9 para modos convergidos.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "MATLAB eig() ou scipy.linalg.eig; scripts para MAC e plotting (Matplotlib).",
                                  "tips": "Normalizar modos pela massa para MAC preciso; foque nos primeiros modos onde convergência é crítica.",
                                  "learningObjective": "Aplicar análise modal e métricas de comparação de modos.",
                                  "commonMistakes": "Comparar modos não ordenados; normalização inconsistente levando a MAC baixo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar precisão, convergência e documentar resultados",
                                  "subSteps": [
                                    "Calcule métricas de erro: erro relativo médio, taxa de convergência (log-log plot).",
                                    "Analise impacto do número de lumps na precisão para diferentes posições de concentrações.",
                                    "Identifique regimes onde o modelo lumped é adequado (ex: erro <1%).",
                                    "Crie relatório com tabelas, gráficos e conclusões sobre limitações.",
                                    "Teste sensibilidade variando posição/intensidade dos parâmetros concentrados."
                                  ],
                                  "verification": "Gráficos mostram convergência monotônica; relatório explica thresholds de precisão.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Ferramentas de plotting avançado (MATLAB plot, Python seaborn), template de relatório LaTeX/Word.",
                                  "tips": "Use log-scale para plots de erro vs. N; inclua tabela de erros para clareza.",
                                  "learningObjective": "Interpretar resultados de validação e quantificar precisão.",
                                  "commonMistakes": "Sobreestimar convergência ignorando modos altos; não testar múltiplas configurações."
                                }
                              ],
                              "practicalExample": "Para uma viga cantilever de 1m com rigidez torsional concentrada no meio, derive frequências exatas via equações de Timoshenko. Construa modelos lumped com N=5,10,20. Compare os primeiros 3 modos: erro cai de 15% (N=5) para 0.5% (N=20), com MAC>0.95.",
                              "finalVerifications": [
                                "Frequências lumped convergem para exatas com N crescente (erro <1% para N>15).",
                                "MAC >0.9 para pelo menos 80% dos modos comparados.",
                                "Gráficos de convergência mostram inclinação log-log consistente com teoria O(1/N²).",
                                "Erros em modos de deformação <5% visualmente em animações.",
                                "Sensibilidade ao número/posição de concentrações documentada.",
                                "Relatório inclui código reproduzível."
                              ],
                              "assessmentCriteria": [
                                "Precisão quantitativa: erros relativos e MAC dentro de thresholds aceitos.",
                                "Análise qualitativa: explicação clara de convergência e limitações.",
                                "Robustez: testes com variações de N e configurações de concentrações.",
                                "Visualização: gráficos profissionais com legendas e escalas adequadas.",
                                "Documentação: passos reproduzíveis e referências teóricas.",
                                "Interpretação: ligação entre resultados e aplicação prática."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de autovalores e convergência numérica.",
                                "Programação: Implementação eficiente de solvers modais em Python/MATLAB.",
                                "Engenharia Civil: Validação similar para pontes com juntas concentradas.",
                                "Controle de Sistemas: Comparação de modelos reduzidos em aeroelasticidade."
                              ],
                              "realWorldApplication": "Em design de asas de aeronaves, validação de modelos lumped discretos contra FEM contínuo garante precisão em análises de flutter, reduzindo tempo computacional de horas para segundos sem perda de fidelidade para frequências críticas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "57.3.1.3",
                        "name": "Análise Dinâmica com Parâmetros Concentrados",
                        "description": "Resolução das equações de movimento do modelo discreto para obter frequências naturais, modos ortogonais e respostas a excitações, aplicável a análise modal de estruturas aeroespaciais.",
                        "specificSkills": [
                          {
                            "id": "57.3.1.3.1",
                            "name": "Resolver problema de autovalores para frequências naturais",
                            "description": "Montar e resolver a equação generalizada de autovalores [K]{φ} = ω²[M]{φ} para o sistema com matrizes de massa e rigidez concentradas, obtendo frequências e modos de vibração natural.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar o sistema e montar as matrizes de massa [M] e rigidez [K]",
                                  "subSteps": [
                                    "Definir os graus de liberdade (DOF) do sistema com parâmetros concentrados.",
                                    "Identificar massas concentradas e preencher a matriz diagonal [M].",
                                    "Determinar elementos de rigidez (molas, vigas discretizadas) e montar [K] considerando acoplamentos.",
                                    "Verificar simetria e positividade das matrizes."
                                  ],
                                  "verification": "Matrizes [M] e [K] são simétricas, [M] diagonal positiva e [K] positiva definida.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e calculadora",
                                    "Software como MATLAB ou Python (NumPy)"
                                  ],
                                  "tips": "Comece com 2 DOF para praticar; use unidades consistentes (SI).",
                                  "learningObjective": "Discretizar sistemas contínuos em modelo lumped-parameter.",
                                  "commonMistakes": "Ignorar acoplamentos off-diagonal em [K] ou usar massas incorretas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a equação generalizada de autovalores",
                                  "subSteps": [
                                    "Derivar a equação de movimento livre: [M]{¨φ} + [K]{φ} = {0}.",
                                    "Assumir solução harmônica {φ(t)} = {φ} sin(ωt + θ).",
                                    "Substituir e obter [K]{φ} = ω² [M]{φ}.",
                                    "Explicar que ω² são autovalores e {φ} autovetores."
                                  ],
                                  "verification": "Equação escrita na forma padrão [K]{φ} = λ [M]{φ} com λ = ω².",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de anotações",
                                    "Livro de dinâmica estrutural"
                                  ],
                                  "tips": "Lembre-se: solução trivial {φ}=0 é descartada; busque não-triviais.",
                                  "learningObjective": "Compreender a origem física do problema de autovalores.",
                                  "commonMistakes": "Confundir com equação padrão [A]{x}=λ{x} sem massa."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver numericamente o problema de autovalores",
                                  "subSteps": [
                                    "Verificar se [M] é diagonal; senão, usar solver generalizado.",
                                    "Implementar em software: eig([K],[M]) no MATLAB ou scipy.linalg.eigh em Python.",
                                    "Calcular autovalores λ_i = ω_i² e autovetores {φ_i}.",
                                    "Ordenar por λ crescente e extrair n modos (n=DOF).",
                                    "Normalizar modos: {φ_i}^T [M] {φ_i} = 1."
                                  ],
                                  "verification": "Autovalores reais positivos; autovetores ortogonais w.r.t. [M].",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB ou Python com SciPy/NumPy",
                                    "Exemplo de código pronto"
                                  ],
                                  "tips": "Use eigh para simétricos; teste com sistema conhecido.",
                                  "learningObjective": "Aplicar solvers numéricos para problemas generalizados.",
                                  "commonMistakes": "Usar eig padrão em vez de generalizado, levando a erros."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar frequências naturais e modos de vibração",
                                  "subSteps": [
                                    "Calcular frequências angulares ω_i = sqrt(λ_i) e cíclicas f_i = ω_i / (2π).",
                                    "Analisar forma modal {φ_i}: identificar nós e antinós.",
                                    "Plotar modos deformados vs. configuração rígida.",
                                    "Discutir acoplamento modal e rigidez/massa efetiva.",
                                    "Reportar top 3-5 modos dominantes."
                                  ],
                                  "verification": "Frequências crescentes; modos visualmente coerentes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software de plotagem (Matplotlib)"
                                  ],
                                  "tips": "Compare f1 com approx. analítica sqrt(k/m) para validação rápida.",
                                  "learningObjective": "Interpretar resultados modais fisicamente.",
                                  "commonMistakes": "Não normalizar modos ou interpretar amplitudes absolutas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e verificar os resultados",
                                  "subSteps": [
                                    "Verificar ortogonalidade: {φ_i}^T [M] {φ_j} = δ_ij e {φ_i}^T [K] {φ_j} = ω_i² δ_ij.",
                                    "Comparar com solução analítica para sistemas pequenos.",
                                    "Simular resposta livre e FFT para confirmar picos em ω_i.",
                                    "Analisar sensibilidade a variações em [M]/[K]."
                                  ],
                                  "verification": "Ortogonalidade numérica <1e-10; match com analítico <1%.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código de simulação temporal (odeint)"
                                  ],
                                  "tips": "Sempre cheque resíduos: ||[K]{φ} - ω²[M]{φ}|| ≈ 0.",
                                  "learningObjective": "Garantir confiabilidade dos resultados computacionais.",
                                  "commonMistakes": "Pular verificações, aceitando resultados numéricos cegamente."
                                }
                              ],
                              "practicalExample": "Sistema de 2 DOF: massas m1=m2=10 kg, molas k1=1000 N/m (base), k2=2000 N/m (entre massas). [M]=diag(10,10), [K]=[[1000+2000,-2000],[-2000,2000]]. Resolver para ω1≈5.7 rad/s, ω2≈17.3 rad/s; modos [1,1.41] e [1,-0.41] (normalizados).",
                              "finalVerifications": [
                                "Matrizes [M] e [K] corretas e simétricas.",
                                "Autovalores λ_i positivos reais ordenados.",
                                "Modos ortogonais w.r.t. [M] e [K].",
                                "Frequências coincidem com aproximações analíticas.",
                                "Resíduos do equação <1e-12.",
                                "Visualização de modos deformados coerente."
                              ],
                              "assessmentCriteria": [
                                "Correção na montagem de [M] e [K] (100%).",
                                "Implementação numérica sem erros de sintaxe ou lógica.",
                                "Interpretação física precisa dos modos.",
                                "Validações quantitativas e qualitativas completas.",
                                "Eficiência computacional e clareza no relatório.",
                                "Tratamento de casos com DOF>3."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Solução de problemas generalizados de autovalores.",
                                "Programação Computacional: Bibliotecas NumPy/SciPy e visualização.",
                                "Física Clássica: Oscilações harmônicas e normal modes.",
                                "Engenharia Mecânica: Análise modal em vibrações estruturais.",
                                "Controle de Sistemas: Polos em s=±jω para estabilidade."
                              ],
                              "realWorldApplication": "Em aeronáutica, calcula frequências naturais de asas e fuselagem para prever aeroelasticidade/flutter, evitando falhas catastróficas como no caso do Tacoma Narrows, otimizando design de aviões."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.3.1.3.2",
                            "name": "Aplicar ortogonalidade dos modos e coordenadas modais",
                            "description": "Utilizar propriedades de ortogonalidade das matrizes de massa e rigidez para desacoplar o sistema em coordenadas modais, facilitando a análise de resposta dinâmica a excitações harmônicas ou arbitrárias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de modos normais e propriedades de ortogonalidade",
                                  "subSteps": [
                                    "Identificar os modos normais de vibração de um sistema multi-graus de liberdade (MDOF).",
                                    "Explicar a ortogonalidade das funções modais em relação às matrizes de massa [M] e rigidez [K].",
                                    "Derivar matematicamente as relações de ortogonalidade: φ_i^T [M] φ_j = 0 e φ_i^T [K] φ_j = 0 para i ≠ j.",
                                    "Calcular massas e rigidezes modais generalizadas: m_i = φ_i^T [M] φ_i e k_i = φ_i^T [K] φ_i.",
                                    "Normalizar os modos para simplificar cálculos."
                                  ],
                                  "verification": "Listar corretamente as equações de ortogonalidade e calcular m_i e k_i para um exemplo simples de 2 DOF.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Matrizes de massa e rigidez de exemplo",
                                    "Software MATLAB ou Python (NumPy/SciPy)",
                                    "Livro de Dinâmica de Estruturas (ex: Clough & Penzien)"
                                  ],
                                  "tips": "Sempre verifique se os modos estão normalizados para massas modais unitárias, facilitando interpretações.",
                                  "learningObjective": "Compreender e derivar as propriedades de ortogonalidade das matrizes de massa e rigidez com vetores modais.",
                                  "commonMistakes": [
                                    "Confundir ortogonalidade com normalização.",
                                    "Esquecer de transpor os vetores modais (φ_i^T)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Transformar equações de movimento para coordenadas modais",
                                  "subSteps": [
                                    "Escrever as equações de movimento desacopladas no domínio físico: [M]{ẍ} + [K]{x} = {F(t)}.",
                                    "Introduzir a transformação modal: {x} = [Φ]{q}, onde [Φ] é a matriz de modos e {q} as coordenadas modais.",
                                    "Substituir na equação e usar ortogonalidade para desacoplar: m_i q̈_i + k_i q_i = φ_i^T {F(t)}.",
                                    "Verificar que o sistema agora é um conjunto de equações escalares independentes.",
                                    "Implementar numericamente a matriz de modos [Φ] e transformação em software."
                                  ],
                                  "verification": "Obter equações modais desacopladas idênticas às teóricas para um sistema teste.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Exemplo numérico de sistema MDOF (ex: viga com 3 massas)",
                                    "MATLAB script para extração de modos",
                                    "Folha de cálculo para verificação manual"
                                  ],
                                  "tips": "Use modos mass-normalizados para que m_i = 1, simplificando as equações para q̈_i + ω_i² q_i = Q_i(t).",
                                  "learningObjective": "Aplicar a transformação modal para desacoplar equações de movimento usando ortogonalidade.",
                                  "commonMistakes": [
                                    "Não premultiplicar por φ_i^T, perdendo o desacoplamento.",
                                    "Usar modos não ortogonais do solver."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar resposta dinâmica a excitações harmônicas",
                                  "subSteps": [
                                    "Para excitação harmônica F(t) = F_0 cos(Ωt), calcular a força modal Q_i(t) = φ_i^T F_0 cos(Ωt).",
                                    "Resolver a equação modal estacionária: q_i(t) = [1 / (k_i - m_i Ω²)] φ_i^T F_0 cos(Ωt).",
                                    "Reconstruir a resposta física: x(t) = Σ [φ_i q_i(t)].",
                                    "Plotar respostas modais e físicas, identificando ressonâncias em ω_i.",
                                    "Avaliar amplificações dinâmicas perto das frequências naturais."
                                  ],
                                  "verification": "Gráficos de resposta modal e física coincidem com solução exata para caso conhecido.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Script MATLAB para análise harmônica modal",
                                    "Dados de excitação harmônica sintética"
                                  ],
                                  "tips": "Foquem em uma moda dominante por vez para visualizar contribuições individuais.",
                                  "learningObjective": "Calcular e interpretar respostas modais a excitações harmônicas desacopladas.",
                                  "commonMistakes": [
                                    "Ignorar a fase na resposta harmônica.",
                                    "Somar respostas sem reconstrução modal."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estender para excitações arbitrárias e validar resultados",
                                  "subSteps": [
                                    "Para F(t) arbitrário, calcular Q_i(t) = φ_i^T F(t) e resolver via Duhamel ou FFT.",
                                    "Implementar solução temporal numérica para {q̈ + ω² q = Q(t)/m}.",
                                    "Reconstruir x(t) e comparar com solução direta no domínio físico.",
                                    "Verificar conservação de energia e ortogonalidade nos resultados.",
                                    "Analisar contribuição de cada modo à resposta total."
                                  ],
                                  "verification": "Erro entre solução modal e direta < 1% para validação numérica.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Histórico de força arbitrário (ex: pulso ou vento turbulento)",
                                    "Solver ODE45 no MATLAB",
                                    "Critérios de convergência"
                                  ],
                                  "tips": "Use truncamento modal (primeiros N modos) e avalie convergência aumentando N.",
                                  "learningObjective": "Aplicar coordenadas modais a excitações gerais e validar precisão.",
                                  "commonMistakes": [
                                    "Não truncar modos adequadamente, levando a oscilações espúrias.",
                                    "Erro na projeção modal Q_i(t)."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma viga cantilever aeroespacial modelada com 4 massas concentradas. Extraia modos via eigenvalue problem, aplique excitação harmônica na ponta simulando rajada de vento (Ω próximo a ω_1), e calcule deflexões modais para prever fadiga estrutural.",
                              "finalVerifications": [
                                "Equações modais estão desacopladas (matrizes diagonais).",
                                "Respostas modais individuais coincidem com soluções analíticas para casos simples.",
                                "Reconstrução da resposta física via soma modal é precisa (erro < 0.5%).",
                                "Identificação correta de ressonâncias e contribuições modais.",
                                "Validação numérica contra solução direta no domínio físico.",
                                "Interpretação física das massas/rigidezes modais."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de ortogonalidade (100% correto).",
                                "Implementação correta de transformação modal em código (sem erros).",
                                "Interpretação qualitativa das respostas dinâmicas.",
                                "Eficiência computacional demonstrada (redução de DOF via truncamento).",
                                "Capacidade de generalizar para novos sistemas.",
                                "Documentação clara de passos e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Vetores ortogonais, decomposição modal (eigenvalue problems).",
                                "Física: Teoria de vibrações livres e forçadas.",
                                "Engenharia de Controle: Decoplamento de sistemas para controle modal.",
                                "Computação Científica: Solvers numéricos para EDOs (Runge-Kutta).",
                                "Análise Numérica: Método dos Elementos Finitos para extração de modos."
                              ],
                              "realWorldApplication": "No design de asas de aeronaves, usa-se para analisar resposta a turbulência atmosférica, prevendo aeroelasticidade e evitando flutter crítico, otimizando peso e segurança em projetos da Boeing ou Embraer."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.3.1.3.3",
                            "name": "Analisar resposta a excitações de base e vibrações transmitidas",
                            "description": "Calcular fatores de amplificação e transmissibilidade de vibrações em modelos com parâmetros concentrados sujeitos a excitações de base, relevantes para isolamento vibratório em aeronaves.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o modelo de parâmetros concentrados com excitação de base",
                                  "subSteps": [
                                    "Revise o sistema massa-mola-amortecedor (MCK) de um grau de liberdade (GDL).",
                                    "Identifique a excitação de base como movimento harmônico y(t) = Y sin(ωt) na base do sistema.",
                                    "Defina coordenadas relativas x(t) = X sin(ωt - φ) para a massa em relação à base.",
                                    "Entenda os fatores de amplificação (FA) e transmissibilidade (TR) como razões de amplitudes.",
                                    "Discuta relevância para isolamento vibratório em aeronaves."
                                  ],
                                  "verification": "Desenhe o diagrama esquemático do sistema e rotule todas as variáveis corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de dinâmica estrutural (ex: Clough & Penzien), papel e caneta, vídeo tutorial sobre vibrações.",
                                  "tips": "Visualize a base se movendo e a massa respondendo; use animações online para intuitar.",
                                  "learningObjective": "Dominar a representação física do problema de excitação de base em modelos concentrados.",
                                  "commonMistakes": "Confundir excitação de força com excitação de base; ignorar o termo de amortecimento cinemático."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular as equações de movimento para excitação de base",
                                  "subSteps": [
                                    "Escreva a equação absoluta: m ÿ + c ẏ + k y = 0, onde y é deslocamento absoluto.",
                                    "Transforme para coordenada relativa: x = y - r, com r(t) = Y sin(ωt).",
                                    "Derive: m ẍ + c (ẋ + ṙ) + k x = -m r̈.",
                                    "Obtenha a forma padrão: ẍ + 2ζω_n ẋ + ω_n² x = -r̈.",
                                    "Solucione em regime permanente assumindo x(t) = X sin(ωt - φ)."
                                  ],
                                  "verification": "Derive e verifique a equação relativa comparando com referências padrão.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Software simbólico como MATLAB/SymPy, caderno de derivadas, tabela de frequências naturais.",
                                  "tips": "Use a convenção de coordenadas relativas para simplificar; memorize a forma -r̈ como aceleração de entrada.",
                                  "learningObjective": "Capacitar a derivação correta das EDOs para sistemas com base excitada.",
                                  "commonMistakes": "Erro no sinal do termo de aceleração de entrada; esquecer o amortecimento relativo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular fatores de amplificação e transmissibilidade",
                                  "subSteps": [
                                    "Calcule o módulo da resposta: FA = |X / Y| = |r̈ / ω_n² Y| / sqrt( (1 - β²)² + (2ζβ)² ), com β = ω/ω_n.",
                                    "Derive transmissibilidade de força TR = |F_transmitida / F_excitante| ≈ FA para isoladores.",
                                    "Plote curvas de FA e TR vs. razão de frequência β para ζ variados.",
                                    "Analise regiões: amplificação (β<√2), isolamento (β>√2).",
                                    "Verifique limites assintóticos: β→0 (FA→1), β→∞ (FA→0)."
                                  ],
                                  "verification": "Gere gráficos de FA e TR que coincidam com curvas padrão de livros-texto.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": "MATLAB ou Python (biblioteca control/matplotlib), planilhas Excel para cálculos iniciais.",
                                  "tips": "Normalise sempre por β; use log-log para visualizar assíntotas.",
                                  "learningObjective": "Computar e interpretar quantitativamente FA e TR em função de parâmetros do sistema.",
                                  "commonMistakes": "Confundir FA de deslocamento com TR de força; erro na fórmula para alto β."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em análise de isolamento vibratório para aeronaves",
                                  "subSteps": [
                                    "Selecione parâmetros reais: m=100kg (painel), k=10^5 N/m, c=2000 Ns/m para motor de aeronave.",
                                    "Calcule ω_n, ζ e avalie FA/TR para ω de turbulência (10-100 Hz).",
                                    "Otimize ζ e β para minimizar TR em frequências críticas.",
                                    "Interprete: reduza vibrações transmitidas ao cockpit em 80%.",
                                    "Simule variação de parâmetros e discuta sensibilidade."
                                  ],
                                  "verification": "Produza relatório com cálculos, gráficos e recomendações de design.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": "Software de simulação (MATLAB Simulink), dados reais de vibrações aeronáuticas (NASA reports).",
                                  "tips": "Comece com valores realistas de aeronaves; valide com literatura aeroespacial.",
                                  "learningObjective": "Aplicar conceitos para projetar isoladores vibratórios eficazes em contextos aeronáuticos.",
                                  "commonMistakes": "Usar unidades inconsistentes (SI vs imperial); subestimar efeitos não-lineares em alta amplitude."
                                }
                              ],
                              "practicalExample": "Em um suporte de motor de jato (m=500kg, ω_n=20 Hz, ζ=0.1), com excitação de base de 1mm a 50 Hz (β=2.5), calcule FA≈0.2 e TR≈0.15, garantindo que vibrações ao fuselagem sejam reduzidas em 85%, evitando fadiga e ruído no cockpit.",
                              "finalVerifications": [
                                "Derivação completa e correta das equações de movimento relativas.",
                                "Cálculo preciso de FA e TR com erro <1% vs. analítico.",
                                "Gráficos de resposta com interpretação de regiões de isolamento.",
                                "Aplicação numérica em exemplo aeronáutico com otimização básica.",
                                "Identificação correta de condições para bom isolamento (β>√2, ζ ótimo).",
                                "Relatório coeso relacionando teoria à prática aeroespacial."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações e fórmulas (30%).",
                                "Correção nos cálculos numéricos e gráficos (25%).",
                                "Profundidade na interpretação física e aeroespacial (20%).",
                                "Criatividade na aplicação prática e otimização (15%).",
                                "Clareza na documentação e verificações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Solução de equações diferenciais lineares e análise harmônica.",
                                "Física: Princípios de dinâmica newtoniana e amortecimento viscosa.",
                                "Engenharia de Controle: Projeto de isoladores como sistemas passivos.",
                                "Aeroelasticidade: Integração com flutter e resposta dinâmica de asas.",
                                "Materiais: Seleção de elásticos para k e c em ambientes aeronáuticos."
                              ],
                              "realWorldApplication": "Projeto de isoladores vibratórios em aeronaves comerciais (ex: Boeing 787), reduzindo transmissão de vibrações de motores/turbulência para estrutura primária, minimizando fadiga metálica, NVH (Noise, Vibration, Harshness) no cockpit e melhorando vida útil de componentes."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.2",
                    "name": "Formulação do Método dos Elementos Finitos para Dinâmica",
                    "description": "Desenvolvimento das equações de movimento discretizadas pelo MEF para problemas de vibração estrutural.",
                    "individualConcepts": [
                      {
                        "id": "57.2.3.1",
                        "name": "Princípios Variacionais para Formulação Dinâmica no MEF",
                        "description": "Aplicação dos princípios de Lagrange e Hamilton para derivar as equações de movimento discretizadas em estruturas contínuas para análise de vibrações.",
                        "specificSkills": [
                          {
                            "id": "57.2.3.1.1",
                            "name": "Derivar a equação de Lagrange para sistemas contínuos",
                            "description": "Desenvolver a função de Lagrange (L = T - V) para uma estrutura contínua, identificando energia cinética (T) e potencial (V), e aplicar a equação d/dt(∂L/∂q̇) - ∂L/∂q = Q para obter equações de movimento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Princípios Lagrangianos para Sistemas Discretos e Introduzir Sistemas Contínuos",
                                  "subSteps": [
                                    "Relembrar a formulação Lagrangiana para sistemas discretos: L = T - V, onde T é energia cinética e V é potencial.",
                                    "Entender a extensão para sistemas contínuos, onde graus de liberdade são infinitos, usando campos de deslocamento u(x,t).",
                                    "Definir coordenadas generalizadas q(t) como aproximações modais ou generalizadas para o campo contínuo.",
                                    "Discutir a densidade lagrangiana para sistemas contínuos: ℓ = (1/2)ρ|u̇|² - w(u).",
                                    "Estabelecer a ação S = ∫ℓ dt dV sobre o domínio."
                                  ],
                                  "verification": "Escrever corretamente a expressão da função de Lagrange para um sistema discreto simples (ex: pêndulo) e descrever verbalmente a diferença para contínuos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Mecânica Clássica (Goldstein ou similar)",
                                    "Notas de aula sobre Lagrangiano",
                                    "Calculadora simbólica (Mathematica/SymPy)"
                                  ],
                                  "tips": "Comece com exemplos familiares discretos para construir intuição antes de generalizar.",
                                  "learningObjective": "Compreender a transição conceitual de sistemas discretos para contínuos na formulação variacional.",
                                  "commonMistakes": [
                                    "Confundir coordenadas generalizadas com deslocamentos locais",
                                    "Ignorar a integração sobre o volume no contínuo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a Energia Cinética T para Estruturas Contínuas",
                                  "subSteps": [
                                    "Expressar o campo de velocidade u̇(x,t) em termos de coordenadas generalizadas: u̇(x,t) = Σ φ_i(x) q̇_i(t), onde φ_i são funções de forma.",
                                    "Calcular T = (1/2) ∫_V ρ |u̇|² dV = (1/2) q̇^T M q̇, identificando a matriz de massa M_{ij} = ∫_V ρ φ_i φ_j dV.",
                                    "Verificar ortogonalidade modal se aplicável (para modos normais).",
                                    "Exemplificar com uma viga Euler-Bernoulli: u(x,t) = Σ φ_n(x) q_n(t).",
                                    "Computar numericamente M para um caso simples com 2 modos."
                                  ],
                                  "verification": "Derivar explicitamente T para uma corda vibrante com dois modos e confirmar que é quadrática em q̇.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de álgebra simbólica",
                                    "Tabelas de funções de forma para vigas/cordas",
                                    "Papel e lápis para derivações"
                                  ],
                                  "tips": "Use funções de forma ortogonais para simplificar cálculos de M.",
                                  "learningObjective": "Dominar a expressão da energia cinética em termos de coordenadas generalizadas para contínuos.",
                                  "commonMistakes": [
                                    "Esquecer o fator 1/2 em T",
                                    "Não integrar corretamente sobre o domínio espacial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a Energia Potencial V para Estruturas Contínuos",
                                  "subSteps": [
                                    "Expressar o campo de deslocamento u(x,t) = Σ φ_i(x) q_i(t).",
                                    "Calcular V = (1/2) ∫_V ε^T D ε dV = (1/2) q^T K q, onde K_{ij} = ∫_V B_i^T D B_j dV (B é operador de strain).",
                                    "Para casos simples: V = (1/2) ∫ EI (u'')² dx para vigas.",
                                    "Incluir potenciais não conservativos ou gravitacionais se relevantes.",
                                    "Verificar simetria e positiva definitude de K."
                                  ],
                                  "verification": "Derivar V para uma placa em flexão com modos assumidos e mostrar independência temporal em q̇.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Referência em Elementos Finitos (Zienkiewicz)",
                                    "Matrizes de rigidez pré-computadas",
                                    "SymPy para strains"
                                  ],
                                  "tips": "Lembre-se que V depende apenas de q, não q̇, para sistemas conservativos.",
                                  "learningObjective": "Formular precisamente a energia potencial elástica em formulação modal.",
                                  "commonMistakes": [
                                    "Confundir strain com displacement",
                                    "Usar wrong operadores B para o elemento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar a Função de Lagrange L e Aplicar a Equação de Euler-Lagrange",
                                  "subSteps": [
                                    "Definir L(q, q̇, t) = T(q̇) - V(q).",
                                    "Calcular ∂L/∂q̇ = M q̇ (vetor momenta generalizados).",
                                    "Computar d/dt(∂L/∂q̇) = M q̈ + termos de variação se M(t) dependente.",
                                    "Calcular ∂L/∂q = -K q.",
                                    "Aplicar equação: M q̈ + K q = Q (forças generalizadas).",
                                    "Verificar para caso discreto como validação."
                                  ],
                                  "verification": "Obter equações de movimento M q̈ + K q = 0 para sistema livre e resolver eigenvalues para frequências.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Caderno de derivações",
                                    "Software para resolver EDOs (MATLAB/Octave)",
                                    "Exemplos resolvidos de aeroelasticidade"
                                  ],
                                  "tips": "Mantenha notação matricial para clareza em múltiplos DOFs.",
                                  "learningObjective": "Derivar as equações de movimento dinâmicas a partir de L usando princípios variacionais.",
                                  "commonMistakes": [
                                    "Erro no sinal de V em L",
                                    "Esquecer d/dt em ∂L/∂q̇ para M constante"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Interpretar as Equações de Movimento Obtidas",
                                  "subSteps": [
                                    "Comparar com equação de onda parcial original (ex: para corda: ρ u_tt = T u_xx).",
                                    "Discutir discretização via Galerkin para ligar ao MEF.",
                                    "Analisar modos normais: assumir q_n(t) = a_n cos(ω t + φ).",
                                    "Incluir amortecimento via Q não conservativo.",
                                    "Simular numericamente um caso com 3 modos."
                                  ],
                                  "verification": "Resolver para frequências naturais e comparar com solução analítica exata.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Solver numérico (Python SciPy)",
                                    "Gráficos de modos de vibração"
                                  ],
                                  "tips": "Use modais ortonormais para diagonalizar M e K.",
                                  "learningObjective": "Interpretar e validar a derivação no contexto de dinâmica estrutural.",
                                  "commonMistakes": [
                                    "Ignorar normalização das funções de forma",
                                    "Confundir forças generalizadas Q"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma asa de aeronave modelada como viga contínua em flexão-torção: derive L usando modos de flexão φ_b(x) e torção φ_θ(x), obtendo equações acopladas M q̈ + K q = Q_aero para análise de flutter.",
                              "finalVerifications": [
                                "Derivação correta de T e V em forma matricial para um sistema com 2-3 modos.",
                                "Aplicação da equação de Lagrange resulta em M q̈ + C q̇ + K q = Q.",
                                "Validação numérica: frequências naturais coincidem com analíticas (±5%).",
                                "Explicação verbal da ligação com MEF (Galerkin).",
                                "Identificação correta de Q para cargas aerodinâmicas.",
                                "Simulação simples mostra comportamento dinâmico esperado."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de ∂L/∂q̇ e d/dt(∂L/∂q̇) (100% correto).",
                                "Correta identificação de matrizes M e K com integrações espaciais.",
                                "Uso apropriado de funções de forma e coordenadas generalizadas.",
                                "Validação cruzada com casos conhecidos (ex: corda vibrante).",
                                "Clareza na documentação das derivações e simulações.",
                                "Compreensão conceitual demonstrada em explicações."
                              ],
                              "crossCurricularConnections": [
                                "Cálculo Variacional: Princípio de Hamilton para derivações alternativas.",
                                "Método dos Elementos Finitos: Discretização espacial via Galerkin.",
                                "Controle de Sistemas: Linearização para controlabilidade em aeroespacial.",
                                "Física Computacional: Simulações modais em CFD/CSB.",
                                "Matemática Aplicada: Autovalores para análise modal."
                              ],
                              "realWorldApplication": "Na análise de aeroelasticidade de asas de aviões ou painéis de satélites, essa derivação fornece equações de movimento para prever flutter crítico, evitando falhas catastróficas como no caso do Tacoma Narrows Bridge adaptado a estruturas aeroespaciais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.2.3.1.2",
                            "name": "Aplicar o Princípio de Hamilton no contexto dinâmico",
                            "description": "Formular o princípio de Hamilton usando o Hamiltoniano (H = T + V) e as equações canônicas para discretização inicial em problemas de vibração estrutural.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Hamiltoniano em Sistemas Dinâmicos",
                                  "subSteps": [
                                    "Defina energia cinética T como função das velocidades generalizadas q̇.",
                                    "Defina energia potencial V como função das coordenadas generalizadas q.",
                                    "Formule o Hamiltoniano H = T(q, q̇) + V(q) e expresse em termos de coordenadas canônicas (q, p), onde p = ∂L/∂q̇.",
                                    "Verifique a conservação de H para sistemas autônomos.",
                                    "Pratique transformação de Lagrangiano para Hamiltoniano em um sistema simples como oscilador harmônico."
                                  ],
                                  "verification": "Derive H corretamente para um oscilador harmônico e confirme H = p²/(2m) + (1/2)kq².",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro de Mecânica Clássica (Goldstein), caderno de anotações, calculadora simbólica (SymPy ou Mathematica).",
                                  "tips": "Sempre expresse T e V separadamente antes de somar para evitar confusões em transformações de Legendre.",
                                  "learningObjective": "Dominar a construção do Hamiltoniano a partir de T e V para preparação da formulação dinâmica.",
                                  "commonMistakes": "Confundir p com q̇ diretamente sem a transformação ∂L/∂q̇; esquecer dependências explícitas de q em T."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular o Princípio de Hamilton",
                                  "subSteps": [
                                    "Enuncie o princípio: δ∫(ṗq - H(q,p,t)) dt = 0 para variações δq e δp com condições de contorno fixas.",
                                    "Derive a identidade fundamental da mecânica Hamiltoniana a partir do princípio variacional.",
                                    "Expresse o princípio para sistemas contínuos em termos de campo Hamiltoniano.",
                                    "Adapte para problemas discretos iniciais em MEF.",
                                    "Escreva a forma integral para um intervalo de tempo finito."
                                  ],
                                  "verification": "Mostre que o princípio leva às equações canônicas ∂H/∂q = -ṗ e ∂H/∂p = q̇.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Notas de Dinâmica Avançada, software de álgebra simbólica, exemplos de problemas variacionais.",
                                  "tips": "Use a notação de Dirac para bra-ket em contextos avançados, mas foque em variações δ para clareza.",
                                  "learningObjective": "Aplicar o princípio variacional de Hamilton para gerar equações de movimento.",
                                  "commonMistakes": "Esquecer o termo ṗq na ação de Hamilton; confundir com princípio de Lagrange."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar as Equações Canônicas",
                                  "subSteps": [
                                    "A partir do princípio, isole variações δq e δp para obter q̇ = ∂H/∂p e ṗ = -∂H/∂q.",
                                    "Verifique simetria e propriedades de Poisson brackets.",
                                    "Estenda para múltiplas graus de liberdade em discretização MEF.",
                                    "Inclua termos dissipativos se aplicável (generalização).",
                                    "Teste em um sistema com 2 DOF, como uma treliça vibrante."
                                  ],
                                  "verification": "Resolva numericamente as equações para um caso simples e compare com solução Lagrangiana.",
                                  "estimatedTime": "4 horas",
                                  "materials": "MATLAB ou Python (SciPy) para integração numérica, exemplos de MEF dinâmico.",
                                  "tips": "Numere as equações explicitamente: escreva dq_i/dt = ∂H/∂p_i e dp_i/dt = -∂H/∂q_i.",
                                  "learningObjective": "Gerar equações de movimento canônicas a partir de H para dinâmica estrutural.",
                                  "commonMistakes": "Inverter os sinais nas equações canônicas; ignorar dependências cruzadas em H."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar à Discretização Inicial em Vibrações Estruturais",
                                  "subSteps": [
                                    "Discretize o contínuo usando MEF: defina nós, elementos e DOF.",
                                    "Construa H global como soma de H_elemento = T_e + V_e.",
                                    "Aplique equações canônicas na forma matricial: q̇ = M^{-1} p, ṗ = -K q (para linear).",
                                    "Implemente condições iniciais para vibração livre/forçada.",
                                    "Simule um problema simples como viga em flexão vibrante."
                                  ],
                                  "verification": "Obtenha frequências naturais corretas comparando com análise modal padrão.",
                                  "estimatedTime": "5 horas",
                                  "materials": "Software MEF (ANSYS ou código Python custom), dados de propriedades estruturais.",
                                  "tips": "Comece com malha grosseira para validar antes de refinar.",
                                  "learningObjective": "Integrar Hamiltoniano em formulação MEF para problemas dinâmicos iniciais.",
                                  "commonMistakes": "Não assemblar matrizes de massa/rigidez corretamente; ignorar modos não-lineares iniciais."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Interpretar Resultados",
                                  "subSteps": [
                                    "Compare soluções Hamiltonianas com métodos modais ou Newmark.",
                                    "Analise conservação de energia numérica.",
                                    "Identifique instabilidades em simulações de longo prazo.",
                                    "Otimize para aeroelasticidade (ex: adicionar aerodinâmica).",
                                    "Documente o processo em relatório."
                                  ],
                                  "verification": "Energia total H constante dentro de 1% de erro em simulação estável.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Ferramentas de plotagem (Matplotlib), benchmarks de literatura aeroespacial.",
                                  "tips": "Use esquemas simétricos como Verlet para preservar estrutura Hamiltoniana.",
                                  "learningObjective": "Verificar robustez da formulação em contextos reais de vibração.",
                                  "commonMistakes": "Sobrepor damping sem ajustar H; escalas numéricas inadequadas."
                                }
                              ],
                              "practicalExample": "Considere uma viga Euler-Bernoulli de comprimento L, módulo E, inércia I, massa por unidade ρA. Discretize em 2 elementos MEF. Construa H = (1/2) p^T M^{-1} p + (1/2) q^T K q. Aplique equações canônicas para vibração livre inicial q(0)=[0.01,0], p(0)=0. Resolva e plote modos de flexão.",
                              "finalVerifications": [
                                "Hamiltoniano H corretamente formulado como T + V em coordenadas canônicas.",
                                "Equações canônicas derivadas sem erros de sinal ou inversão.",
                                "Discretização MEF leva a frequências modais dentro de 5% do analítico.",
                                "Simulação numérica preserva energia em 99% ao longo de 10 períodos.",
                                "Relatório documenta todas as matrizes M e K explicitamente.",
                                "Aplicação inicial em vibração estrutural validada contra benchmark."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação do princípio e equações (90%+ correto).",
                                "Corretude na construção de H para MEF dinâmico.",
                                "Adequação da discretização e condições iniciais.",
                                "Análise de resultados com gráficos e comparações quantitativas.",
                                "Clareza na documentação de passos e verificações.",
                                "Criatividade em extensão para problemas aeroespaciais."
                              ],
                              "crossCurricularConnections": [
                                "Física Computacional: Integração numérica de EDOs Hamiltonianas (NumPy/SciPy).",
                                "Controle de Sistemas: Uso em estabilização de estruturas flexíveis via feedback.",
                                "Programação: Implementação em Python para simulações MEF.",
                                "Matemática Aplicada: Teoria de variedades simpléticas e brackets de Poisson.",
                                "Engenharia Aeroespacial: Modelagem de flutter em asas."
                              ],
                              "realWorldApplication": "Em aeroelasticidade, aplica-se para prever vibrações em painéis de satélites ou asas de aeronaves durante lançamento/manobras, evitando fadiga estrutural e ressonâncias catastróficas como no incidente de Tacoma Narrows, otimizando designs via simulações iniciais precisas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.2.3.1.3",
                            "name": "Discretizar o domínio usando funções de forma",
                            "description": "Introduzir aproximações de Galerkin com funções de forma para aproximar o deslocamento u(x,t) ≈ Σ N_i(x) q_i(t), preparando a base para a discretização MEF.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Fundamentais de Funções de Forma",
                                  "subSteps": [
                                    "Revise a necessidade de discretização em MEF: domínios contínuos requerem aproximação para solução numérica.",
                                    "Estude a aproximação de Galerkin: u(x,t) ≈ Σ N_i(x) q_i(t), onde N_i são funções de forma e q_i são graus de liberdade.",
                                    "Analise propriedades essenciais das funções de forma: unidade de partição (Σ N_i = 1), interpolação nodal (N_i(x_j) = δ_ij).",
                                    "Explore exemplos em 1D: funções lineares para elementos de barra.",
                                    "Discuta continuidade: C0 para deslocamentos em problemas de segunda ordem."
                                  ],
                                  "verification": "Resuma em um diagrama as propriedades das funções de forma e explique verbalmente a aproximação de Galerkin.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de MEF (ex: Bathe ou Zienkiewicz)",
                                    "Slides sobre princípios variacionais",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Comece com 1D para simplicidade; visualize funções de forma como 'chapéus' sobre nós.",
                                  "learningObjective": "Compreender o papel das funções de forma na aproximação de campos contínuos.",
                                  "commonMistakes": [
                                    "Confundir funções de forma com funções de base globais",
                                    "Ignorar a propriedade de partição da unidade",
                                    "Assumir continuidade desnecessária"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Derivar Funções de Forma para um Elemento 1D Simples",
                                  "subSteps": [
                                    "Selecione um elemento linear de 2 nós: comprimento L, nós em x=0 e x=L.",
                                    "Derive N1(x) = (L - x)/L e N2(x) = x/L.",
                                    "Verifique interpolação: N1(0)=1, N1(L)=0; N2(0)=0, N2(L)=1.",
                                    "Estenda para elemento quadrático de 3 nós: derive funções usando polinômios de Lagrange.",
                                    "Plote as funções em software como MATLAB ou Python (Matplotlib)."
                                  ],
                                  "verification": "Escreva as expressões matemáticas de N_i para elementos linear e quadrático, e plote-as corretamente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de plotagem (MATLAB/Python)",
                                    "Folha de cálculo para derivação",
                                    "Referência: fórmulas de Lagrange"
                                  ],
                                  "tips": "Use coordenadas naturais ξ ∈ [-1,1] para generalidade em elementos.",
                                  "learningObjective": "Derivar funções de forma locais para elementos finitos 1D.",
                                  "commonMistakes": [
                                    "Erros em normalização (Σ N_i ≠1)",
                                    "Confundir coordenadas locais e globais",
                                    "Não verificar interpolação nodal"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Funções de Forma para Aproximar o Deslocamento u(x,t)",
                                  "subSteps": [
                                    "Expresse u(x,t) = N1(x) q1(t) + N2(x) q2(t) para elemento linear.",
                                    "Substitua na forma fraca variacional: ∫ δu · (ρ ü + ∇·σ) dΩ = 0.",
                                    "Derive matriz de massa e rigidez elementares usando integração numérica (Gauss).",
                                    "Monte o sistema global para múltiplos elementos: u^h = N q.",
                                    "Implemente um exemplo numérico simples em código Python."
                                  ],
                                  "verification": "Gere a aproximação u(x,t) para um elemento e monte matrizes M^e e K^e para um problema de viga.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python com NumPy/SciPy",
                                    "Código template para MEF 1D",
                                    "Exemplo de viga cantilever"
                                  ],
                                  "tips": "Integre exatamente para elementos lineares; use 2 pontos de Gauss para quadráticos.",
                                  "learningObjective": "Construir a aproximação de Galerkin usando funções de forma no contexto dinâmico.",
                                  "commonMistakes": [
                                    "Esquecer dependência temporal em q_i(t)",
                                    "Montagem incorreta de matrizes globais",
                                    "Não mapear para coordenadas locais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Estender para Domínios Complexos",
                                  "subSteps": [
                                    "Verifique convergência: refinar malha reduz erro de aproximação.",
                                    "Estenda para 2D: funções bilineares em quadriláteros.",
                                    "Discuta hierarquia: lineares vs. quadráticas (trade-off precisão/custo).",
                                    "Analise isoparamétricos: geometria também aproximada por N_i.",
                                    "Teste em benchmark: onda em barra com condições de contorno."
                                  ],
                                  "verification": "Simule um problema dinâmico simples e compare com solução analítica (erro <5%).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código MEF open-source (ex: FEniCS ou SfePy)",
                                    "Benchmark problems PDF"
                                  ],
                                  "tips": "Sempre normalize ξ para evitar singularidades na integração.",
                                  "learningObjective": "Validar a discretização e entender extensões para problemas reais.",
                                  "commonMistakes": [
                                    "Sobrestimar precisão de malhas grosseiras",
                                    "Ignorar mapeamento isoparamétrico",
                                    "Erros em condições de contorno"
                                  ]
                                }
                              ],
                              "practicalExample": "Discretize uma viga cantilever de comprimento L=1m, seção retangular, sob carga dinâmica harmônica. Use 4 elementos lineares: defina nós, derive N_i, aproxime u(x,t), monte M e K, resolva M ü + K u = F(t) via Newmark.",
                              "finalVerifications": [
                                "Deriva corretamente funções de forma lineares e quadráticas em 1D.",
                                "Constrói aproximação u^h(x,t) = Σ N_i q_i para um elemento.",
                                "Monta matrizes elementares e globais sem erros.",
                                "Implementa simulação numérica em Python com resultados plausíveis.",
                                "Explica propriedades (partição da unidade, interpolação) em entrevista.",
                                "Compara solução numérica com analítica para benchmark simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão das derivações matemáticas (100% corretas).",
                                "Corretude da implementação computacional (erro <1% em benchmark).",
                                "Profundidade na explicação de conceitos (cobertura de todas propriedades).",
                                "Criatividade em extensão para 2D ou dinâmica não-linear.",
                                "Eficiência: tempo de simulação razoável para malha fina.",
                                "Documentação clara do processo (relatório com plots)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Polinômios de Lagrange e integração de Gauss.",
                                "Programação: Implementação numérica em Python/NumPy para MEF.",
                                "Física: Princípios variacionais e dinâmica de estruturas.",
                                "Engenharia Aeroespacial: Modelagem de flutter em asas.",
                                "Estatística: Análise de erro e convergência de malhas."
                              ],
                              "realWorldApplication": "Na análise aeroelástica de asas de aeronaves, discretiza o domínio da viga-like wingbox com funções de forma para prever deslocamentos dinâmicos sob cargas aerodinâmicas, evitando instabilidades como flutter durante o design de aviões comerciais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "57.2.3.2",
                        "name": "Matrizes Elementares de Massa, Rigidez e Amortecimento",
                        "description": "Cálculo das matrizes elementares [m^e], [k^e] e [c^e] a partir da discretização para problemas dinâmicos de vibração estrutural.",
                        "specificSkills": [
                          {
                            "id": "57.2.3.2.1",
                            "name": "Calcular a matriz de massa elementar",
                            "description": "Derivar a matriz de massa consistente [m^e] = ∫ ρ N^T N dV usando funções de forma N, diferenciando da massa lobar, para elementos como barras, vigas ou placas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Funções de Forma e Formulação de Elementos Finitos",
                                  "subSteps": [
                                    "Estude as funções de forma N para elementos lineares (ex: barra com 2 nós) e quadráticas.",
                                    "Revise a definição de densidade ρ e seu papel na inércia de massa.",
                                    "Entenda a diferença conceitual entre matriz de massa consistente e lobar.",
                                    "Identifique a equação geral [m^e] = ∫ ρ N^T N dV sobre o volume do elemento.",
                                    "Anote as propriedades esperadas da matriz de massa (simétrica, positiva definida)."
                                  ],
                                  "verification": "Resuma em um parágrafo as diferenças entre massa consistente e lobar, com exemplos de funções N.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Elementos Finitos (ex: Bathe ou Zienkiewicz), notas de aula sobre MEF.",
                                  "tips": "Use diagramas para visualizar funções de forma interpolando deslocamentos nos nós.",
                                  "learningObjective": "Compreender os componentes matemáticos da matriz de massa elementar.",
                                  "commonMistakes": "Confundir funções de forma com funções de interpolação global; ignorar dependência em ρ."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e Configurar o Elemento Específico",
                                  "subSteps": [
                                    "Escolha um elemento simples, como uma barra 1D com 2 nós e funções lineares N1 = 1-ξ, N2 = ξ.",
                                    "Defina o domínio de integração: comprimento L, seção transversal A, coordenada local ξ de -1 a 1.",
                                    "Especifique ρ (densidade constante) e propriedades geométricas.",
                                    "Escreva explicitamente N^T N para o elemento escolhido.",
                                    "Calcule o Jacobiano para transformação de coordenadas se necessário."
                                  ],
                                  "verification": "Desenhe o elemento com funções de forma plotadas e liste N^T N como matriz 2x2.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel milimetrado, software de plotagem (ex: MATLAB ou Python Matplotlib), tabela de funções de forma.",
                                  "tips": "Padronize ξ de 0 a 1 ou -1 a 1 para consistência com referências padrão.",
                                  "learningObjective": "Configurar corretamente o problema para um elemento específico.",
                                  "commonMistakes": "Usar funções de forma erradas para o tipo de elemento; esquecer fatores de escala como 2L para dξ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular e Avaliar a Integral da Matriz de Massa Consistente",
                                  "subSteps": [
                                    "Escreva a integral [m^e]_{ij} = ∫ ρ N_i N_j A dx de 0 a L.",
                                    "Transforme para coordenadas naturais: dx = (L/2) dξ se ξ de -1 a 1.",
                                    "Compute analiticamente cada termo: para barra linear, m11 = m22 = ρ A L / 3, m12 = m21 = ρ A L / 6.",
                                    "Verifique simetria e traço total igual a ρ A L (massa total).",
                                    "Geralize para vigas 2D ou placas, mencionando integração numérica se analítica complexa."
                                  ],
                                  "verification": "Calcule numericamente os elementos e confira contra fórmula conhecida: [m] = (ρ A L / 6) * [[2,1],[1,2]].",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora simbólica (ex: SymPy, Mathematica), software MEF (ex: ANSYS tutorial).",
                                  "tips": "Integre termo a termo; use propriedades de ortogonalidade das funções de forma.",
                                  "learningObjective": "Derivar analiticamente a matriz de massa consistente.",
                                  "commonMistakes": "Erro no Jacobiano (fator L/2); confundir com rigidez que usa gradientes B."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar da Matriz de Massa Lobar e Validar",
                                  "subSteps": [
                                    "Defina massa lobar: diagonal com massas concentradas nos nós (ex: [ρ A L / 2, 0; 0, ρ A L / 2]).",
                                    "Compare distribuição de massa: consistente distribui 1/3 por nó diagonal, vs. 1/2 lobar.",
                                    "Avalie impacto em frequências modais (consistente mais precisa para modos altos).",
                                    "Implemente em código simples para um elemento e plote modos.",
                                    "Teste com elemento diferente (ex: viga Euler-Bernoulli com N hermitianas)."
                                  ],
                                  "verification": "Mostre que traço é igual, mas off-diagonais diferem; compute erro em frequência fundamental.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python/MATLAB com NumPy para matriz e autovalores, exemplo de código MEF.",
                                  "tips": "Use autovalores para verificar precisão dinâmica.",
                                  "learningObjective": "Distinguir e justificar uso da massa consistente.",
                                  "commonMistakes": "Achar massas lobar 'melhor' por simplicidade; ignorar acoplamento inercial."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar e Verificar em Contexto Aeroespacial",
                                  "subSteps": [
                                    "Monte matriz de massa para malha simples de asa (ex: 3 barras).",
                                    "Inclua rotação inercial se aplicável (para dinâmica não-linear).",
                                    "Compare resultados com software comercial.",
                                    "Documente limitações (ex: para placas, use integração Gauss 2x2).",
                                    "Discuta escalabilidade para MEF dinâmico."
                                  ],
                                  "verification": "Gere plot de modos de vibração e confirme massa total preservada.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software FEA (ex: Abaqus student, FreeFEM), dados de asa NACA.",
                                  "tips": "Comece com malha grosseira para depuração rápida.",
                                  "learningObjective": "Integrar matriz em análise estrutural real.",
                                  "commonMistakes": "Não normalizar modos; esquecer consistência de unidades (kg para massa)."
                                }
                              ],
                              "practicalExample": "Para uma barra de aço (ρ=7850 kg/m³, A=0.01 m², L=1 m) com 2 nós: [m^e] = (ρ A L / 6) * [[2,1],[1,2]] = [[1308.33, 654.17],[654.17, 1308.33]] kg. Massa lobar seria diagonal [[1962.5, 0],[0, 1962.5]]. Use em equação {¨u} + [k]{u}=0 para frequências √(k11/m11) ≈ 1.24 * √(k11/(ρAL/2)).",
                              "finalVerifications": [
                                "Matriz é simétrica e positiva definida (autovalores >0).",
                                "Traço da matriz equals massa total do elemento ρ V.",
                                "Off-diagonais capturam acoplamento inercial corretamente.",
                                "Resultados coincidem com fórmulas analíticas padrão para barra/viga.",
                                "Frequências modais mais precisas que com massa lobar para o mesmo DOFs.",
                                "Implementação numérica converge com refinamento de malha."
                              ],
                              "assessmentCriteria": [
                                "Precisão analítica da integral (erro <1%).",
                                "Correta distinção conceitual consistente vs. lobar.",
                                "Validação numérica com software ou código próprio.",
                                "Explicação clara de propriedades geométricas/ρ na matriz.",
                                "Geralização para elementos 2D/3D demonstrada.",
                                "Análise de impacto em dinâmica (modos/frequências)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo integral multivariado e funções ortogonais.",
                                "Física: Princípios variacionais em dinâmica de continua.",
                                "Programação: Implementação numérica em Python/MATLAB para MEF.",
                                "Engenharia Aeroespacial: Análise modal de flutter em asas.",
                                "Computação Científica: Integração Gauss e métodos numéricos."
                              ],
                              "realWorldApplication": "Na análise de vibrações de painéis de fuselagem ou asas de aeronaves, a matriz de massa consistente é essencial para prever frequências naturais precisas em simulações MEF, evitando ressonâncias em regimes de voo supersônico e otimizando design contra aeroelasticidade."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.2.3.2.2",
                            "name": "Derivar a matriz de rigidez elementar dinâmica",
                            "description": "Obter a matriz de rigidez [k^e] = ∫ B^T D B dV, onde B é a matriz de deformação, adaptada para o contexto dinâmico sem inércia rotacional inicial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Matrizes B e D",
                                  "subSteps": [
                                    "Defina a matriz de deformação B para um elemento finito genérico, expressando as derivadas das funções de forma em termos de coordenadas locais.",
                                    "Explique a matriz constitutiva D para materiais isotrópicos ou anisotrópicos comuns em estruturas aeroespaciais, como compósitos.",
                                    "Discuta a integral de volume ∫ dV sobre o domínio do elemento, incluindo transformações de coordenadas (e.g., Jacobiano para elementos isoparamétricos)."
                                  ],
                                  "verification": "Escreva as expressões explícitas de B e D para um elemento de viga Timoshenko 2D e confirme simetria de D.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Finite Element Procedures' de Bathe; software MATLAB ou Python com NumPy/SciPy para matrizes simbólicas.",
                                  "tips": "Use funções de forma lineares ou quadráticas para simplicidade inicial; visualize B com plots de deformação.",
                                  "learningObjective": "Compreender os blocos de construção da matriz de rigidez elementar.",
                                  "commonMistakes": "Confundir B nodal com B de deformação; ignorar dependência de D no estado de tensão dinâmica."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar Formulação Estática e Dinâmica",
                                  "subSteps": [
                                    "Revise a matriz de rigidez estática [k^e]_static = ∫ B^T D B dV e identifique sua origem na minimização de energia potencial.",
                                    "Introduza o contexto dinâmico via equação de movimento [m] ü + [c] ú + [k] u = F, destacando que [k^e] permanece idêntica à estática sem efeitos de inércia rotacional.",
                                    "Explique a ausência inicial de inércia rotacional: rigidez deriva puramente de esforços elásticos, sem acoplamento geométrico dinâmico."
                                  ],
                                  "verification": "Derive qualitativamente por que [k^e] dinâmica equals [k^e] estática para vibrações lineares pequenas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notas de aula sobre dinâmica estrutural; vídeo Khan Academy sobre equações de movimento discretizadas.",
                                  "tips": "Compare equações modais estáticas vs dinâmicas para clareza; memorize que rigidez é 'tempo-invariante' em formulações lineares.",
                                  "learningObjective": "Distinguir adaptações mínimas de [k^e] para dinâmica linear.",
                                  "commonMistakes": "Assumir mudanças em D para dinâmica; incluir inércia rotacional prematuramente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar Explicitamente a Matriz de Rigidez [k^e] Dinâmica",
                                  "subSteps": [
                                    "Monte B^T D B simbolicamente para um elemento específico (e.g., barra ou placa 4 nós), expandindo termos.",
                                    "Avalie a integral numérica ou analítica: para elementos prismáticos, reduza a 1D ∫ A(x) dx; use Gauss quadrature para gerais.",
                                    "Verifique propriedades: simetria positiva definida, independência de frequência (sem rotação inicial)."
                                  ],
                                  "verification": "Compute [k^e] 4x4 para uma barra axial e confirme que det([k^e]) > 0 e simétrica.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software SymPy (Python) para álgebra simbólica; template de código FEM para rigidez.",
                                  "tips": "Comece com elemento 1D para depuração; normalize unidades (N/m para aeroespaciais).",
                                  "learningObjective": "Executar derivação passo a passo da integral [k^e] = ∫ B^T D B dV.",
                                  "commonMistakes": "Erro em transposição B^T; esquecer Jacobiano |J| na integral."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Interpretar a Matriz Derivada",
                                  "subSteps": [
                                    "Compare [k^e] derivada com soluções analíticas conhecidas (e.g., viga Euler-Bernoulli).",
                                    "Analise sensibilidade: efeitos de malha, material anisotrópico em D.",
                                    "Discuta montagem global: somar contribuições elementares sem sobreposições em nós compartilhados."
                                  ],
                                  "verification": "Resolva um problema modal simples (ω^2 [m] φ = [k] φ) e verifique frequências contra analítico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Solver FEM como ANSYS Student ou código FEniCS; benchmark de viga cantilever.",
                                  "tips": "Use escalonamento de condição para checar il-condicionamento; plote modos de vibração.",
                                  "learningObjective": "Aplicar e validar [k^e] em contexto dinâmico aeroespacial.",
                                  "commonMistakes": "Ignorar consistência de unidades entre [k] e [m]; superestimar convergência sem refinamento h/p."
                                }
                              ],
                              "practicalExample": "Para uma viga Timoshenko 2D de comprimento L=1m, E=70GPa, ν=0.3, derive [k^e] 4x4 (2 nós, 2 DOF/nó: v, θ). Use funções lineares N1=(1-ξ)/2, N2=(1+ξ)/2 (ξ∈[-1,1]). Compute ∫ B^T D B |J| dξ com D=[[E/(1-ν^2), νE/(1-ν^2),0]; ...] e valide com fórmula analítica k11=12EI/L^3.",
                              "finalVerifications": [
                                "Matriz [k^e] é simétrica e positiva definida (todos autovalores >0).",
                                "Recupera solução estática limite (F=[k]u) para carga estática.",
                                "Frequências modais convergem com refinamento de malha.",
                                "Independente de massas/inércia, focando puramente em rigidez elástica.",
                                "Consistente com teoria de vigas/clássicos para casos limite.",
                                "Elementos adjacentes montam corretamente sem gaps/overlaps."
                              ],
                              "assessmentCriteria": [
                                "Precisão da derivação simbólica de B^T D B (sem erros algébricos).",
                                "Correta avaliação da integral volumétrica com Jacobiano.",
                                "Demonstração de propriedades matriciais (simetria, definitude).",
                                "Validação numérica contra benchmarks analíticos (erro <1%).",
                                "Explicação clara da invariância dinâmica sem rotação.",
                                "Aplicação em montagem global com exemplo simples."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (autovalores), Cálculo integral (quadraturas Gauss).",
                                "Programação: Implementação em Python/MATLAB para FEM simbólico/numérico.",
                                "Física: Mecânica dos sólidos, teoria de elasticidade linear.",
                                "Engenharia de Materiais: Anisotropia em compósitos aeroespaciais."
                              ],
                              "realWorldApplication": "Em simulações aeroelásticas de asas de aeronaves (e.g., flutter analysis no Boeing 787), [k^e] dinâmica é essencial para prever vibrações estruturais sob cargas aerodinâmicas, evitando falhas catastróficas como as do Tacoma Narrows Bridge adaptado a aeroespacial."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.2.3.2.3",
                            "name": "Incorporar amortecimento de Rayleigh elementar",
                            "description": "Formular a matriz de amortecimento [c^e] = α [m^e] + β [k^e], explicando os parâmetros α e β para modelagem proporcional em vibrações estruturais aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Matrizes de Massa e Rigidez Elementares",
                                  "subSteps": [
                                    "Relembre a derivação da matriz de massa [m^e] para um elemento finito de viga ou barra.",
                                    "Revise a matriz de rigidez [k^e], incluindo termos de flexão e torção relevantes para estruturas aeroespaciais.",
                                    "Identifique as propriedades geométricas e materiais usadas em [m^e] e [k^e].",
                                    "Esboce um elemento finito simples (ex: viga de Euler-Bernoulli) e anote suas matrizes.",
                                    "Verifique dimensionalidade e simetria das matrizes."
                                  ],
                                  "verification": "Confirme que [m^e] e [k^e] estão corretamente formuladas comparando com referências padrão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de elementos finitos (ex: Bathe), papel e caneta, software MATLAB para plotar matrizes.",
                                  "tips": "Use notação consistente para graus de liberdade (translação e rotação).",
                                  "learningObjective": "Compreender as matrizes fundamentais para amortecimento proporcional.",
                                  "commonMistakes": "Confundir massas consistentes vs. agrupadas; ignorar termos de rotação inercial."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Modelo de Amortecimento Proporcional de Rayleigh",
                                  "subSteps": [
                                    "Estude a equação de movimento geral: [m]{¨u} + [c]{˙u} + [k]{u} = {f}.",
                                    "Explique o amortecimento viscoso proporcional como suposição [c] = α[m] + β[k].",
                                    "Discuta vantagens: diagonaliza no espaço modal, simplifica análise de vibrações.",
                                    "Derive a condição para amortecimento proporcional via modos normais.",
                                    "Compare com amortecimento não-proporcional."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que Rayleigh é usado em aeroespaciais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notas de dinâmica estrutural, vídeo tutorial sobre Rayleigh damping.",
                                  "tips": "Visualize com gráfico de histéresis para entender proporcionalidade.",
                                  "learningObjective": "Graspar o conceito teórico e justificativa para Rayleigh.",
                                  "commonMistakes": "Assumir α e β arbitrários sem ligação modal; confundir com amortecimento modal direto."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a Matriz de Amortecimento Elementar [c^e]",
                                  "subSteps": [
                                    "Escreva explicitamente [c^e] = α [m^e] + β [k^e] para um elemento específico.",
                                    "Calcule termos escalares e some matrizes.",
                                    "Verifique propriedades: simetria, positiva definida para α, β > 0.",
                                    "Implemente em código simples para um elemento 2D.",
                                    "Analise impacto nos autovalores do sistema."
                                  ],
                                  "verification": "Gere [c^e] numérica para exemplo e confira simetria.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB ou Python (NumPy), planilha para cálculos manuais.",
                                  "tips": "Normalise matrizes para evitar erros numéricos grandes.",
                                  "learningObjective": "Dominar a formulação algébrica de [c^e].",
                                  "commonMistakes": "Erro de sinal em β; esquecer escalarização correta."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar e Determinar Parâmetros α e β",
                                  "subSteps": [
                                    "Defina α como coeficiente de amortecimento de massa (relacionado a baixas frequências).",
                                    "Defina β como coeficiente de rigidez (altas frequências).",
                                    "Use fórmula modal: ξ_i = α/(2ω_i) + β ω_i / 2 para ξ alvo em dois modos.",
                                    "Resolva sistema 2x2 para α e β dados ξ_1, ξ_2, ω_1, ω_2.",
                                    "Aplique a uma estrutura aeroespacial simples (ex: painel flutter)."
                                  ],
                                  "verification": "Calcule α e β para frequências conhecidas e verifique ξ nos modos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora matricial, software ANSYS ou similar para modos.",
                                  "tips": "Escolha modos dominantes (1º e 2º) para precisão em faixas críticas.",
                                  "learningObjective": "Selecionar α e β para modelagem realista.",
                                  "commonMistakes": "Inverter fórmulas de ξ; escolher modos irrelevantes."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Integrar em Análise Dinâmica",
                                  "subSteps": [
                                    "Monte sistema global com múltiplos elementos incluindo [c^e].",
                                    "Resolva autovalores para frequências complexas e fatores de amortecimento.",
                                    "Compare respostas transitórias com e sem amortecimento.",
                                    "Avalie estabilidade em contexto aeroelástico.",
                                    "Documente o processo completo."
                                  ],
                                  "verification": "Plot de decaimento vibracional confirma amortecimento.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB para análise modal, relatório template.",
                                  "tips": "Use solve eig para verificar.",
                                  "learningObjective": "Aplicar [c^e] em simulação dinâmica completa.",
                                  "commonMistakes": "Assemblagem errada de matrizes globais; ignorar condições de contorno."
                                }
                              ],
                              "practicalExample": "Para uma viga cantilever aeroespacial de 1m, E=70GPa, ρ=2700kg/m³, seção 0.01x0.1m: compute [m^e] e [k^e] (2 nós, 4 GL/nó). Assuma ξ=0.02 nos modos 1 (ω1=10 rad/s) e 3 (ω3=100 rad/s), resolva α≈0.4, β≈0.0002, forme [c^e] e simule resposta a pulso unitário.",
                              "finalVerifications": [
                                "Matriz [c^e] é simétrica e positiva semi-definida.",
                                "α e β produzem ξ corretos nos modos alvo.",
                                "Resposta temporal mostra decaimento exponencial proporcional.",
                                "Autovalores complexos têm partes imaginárias próximas a ω naturais.",
                                "Integração global não altera modos sem amortecimento.",
                                "Valores físicos razoáveis (α ~ s^-1, β ~ s)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de [c^e] (sem erros algébricos).",
                                "Correta resolução do sistema para α e β.",
                                "Explicação clara de α (massa) vs. β (rigidez).",
                                "Validação numérica com plots de decaimento.",
                                "Aplicação contextual a vibrações aeroespaciais.",
                                "Documentação completa com unidades e suposições."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (autovalores modais).",
                                "Física: Dinâmica de vibrações e dissipação de energia.",
                                "Engenharia de Controle: Amortecimento em sistemas de feedback.",
                                "Computação: Programação numérica para FEM (MATLAB/Python)."
                              ],
                              "realWorldApplication": "Em análise de flutter de asas de aeronaves, o amortecimento de Rayleigh modela dissipação viscosa em painéis compostos, previnindo instabilidades dinâmicas durante voo supersônico, como no design do F-35 ou satélites com estruturas flexíveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "57.2.3.3",
                        "name": "Assembleia Global e Equações de Movimento Discretizadas",
                        "description": "Montagem das matrizes globais e obtenção da forma final das equações de movimento [M]{ü} + [C]{ú} + [K]{u} = {F(t)} para análise de vibrações.",
                        "specificSkills": [
                          {
                            "id": "57.2.3.3.1",
                            "name": "Realizar a assembleia das matrizes globais",
                            "description": "Explicar o processo de superposição de matrizes elementares para formar [M], [K] e [C] globais, considerando condições de contorno e graus de liberdade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar as matrizes elementares locais",
                                  "subSteps": [
                                    "Identificar todos os elementos finitos na malha e seus graus de liberdade (DOFs) locais.",
                                    "Calcular as matrizes elementares de massa [m_e], rigidez [k_e] e amortecimento [c_e] para cada elemento usando as fórmulas apropriadas.",
                                    "Verificar a consistência das dimensões e simetria de cada matriz elementar.",
                                    "Armazenar as matrizes em formato que permita indexação por elemento e DOF local.",
                                    "Documentar suposições como propriedades do material e geometria."
                                  ],
                                  "verification": "Comparar as matrizes calculadas com exemplos analíticos conhecidos ou software de referência para validar valores.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro-texto de Método dos Elementos Finitos (ex: Zienkiewicz)",
                                    "Software MATLAB ou Python (NumPy)",
                                    "Papel quadriculado para cálculos manuais"
                                  ],
                                  "tips": [
                                    "Sempre use unidades consistentes (SI) para evitar erros de escala.",
                                    "Comece com um elemento simples para testar fórmulas.",
                                    "Salve matrizes em variáveis nomeadas como me1, ke1 para clareza."
                                  ],
                                  "learningObjective": "Compreender e calcular corretamente as matrizes elementares locais para dinâmica estrutural.",
                                  "commonMistakes": [
                                    "Ignorar fatores de integração numérica em elementos complexos.",
                                    "Confundir DOFs translacionais e rotacionais.",
                                    "Esquecer a densidade de massa na matriz de massa."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o mapeamento de graus de liberdade locais para globais",
                                  "subSteps": [
                                    "Numerar todos os nós da malha e atribuir DOFs globais sequencialmente (ex: nó 1: DOF 1 e 2 para 2D).",
                                    "Para cada elemento, criar uma lista de conectividade que mapeie DOFs locais (1,2,...) para globais (ex: 1->3, 2->4).",
                                    "Criar uma tabela ou matriz de mapeamento (connectivity matrix) para todos os elementos.",
                                    "Verificar que não há sobreposições ou lacunas nos DOFs globais.",
                                    "Identificar DOFs restritos por condições de contorno iniciais."
                                  ],
                                  "verification": "Testar o mapeamento manualmente para 2-3 elementos, garantindo que índices locais correspondam corretamente aos globais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha Excel ou tabela em papel para conectividade",
                                    "Código Python para gerar mapeamento automático",
                                    "Diagrama da malha finita"
                                  ],
                                  "tips": [
                                    "Desenhe a malha numerada para visualização.",
                                    "Use funções de indexação zero-based em programação.",
                                    "Mantenha uma lista de DOFs livres vs. fixos."
                                  ],
                                  "learningObjective": "Dominar o processo de mapeamento de DOFs locais para o sistema global.",
                                  "commonMistakes": [
                                    "Erro de numeração sequencial nos nós.",
                                    "Duplicar DOFs em nós compartilhados.",
                                    "Esquecer DOFs rotacionais em problemas 3D."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a assembleia das matrizes globais",
                                  "subSteps": [
                                    "Inicializar matrizes globais vazias [M], [K], [C] com dimensões totais de DOFs x DOFs.",
                                    "Para cada elemento, somar as contribuições locais nas posições globais correspondentes via mapeamento.",
                                    "Usar loops ou funções de dispersão (scatter) para adicionar valores: M(i,j) += m_e(p,q) onde i=map(p), j=map(q).",
                                    "Verificar simetria e ausência de valores fora das bandas esperadas.",
                                    "Salvar as matrizes globais completas."
                                  ],
                                  "verification": "Comparar soma de todos os elementos com a global para um caso simples; checar normas ou traços.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software MATLAB (função 'assembly') ou Python (SciPy sparse)",
                                    "Exemplo numérico de malha com 4 elementos",
                                    "Calculadora matricial"
                                  ],
                                  "tips": [
                                    "Implemente em código para eficiência; evite loops aninhados desnecessários.",
                                    "Use matrizes esparsas para malhas grandes.",
                                    "Imprima submatrizes para depuração."
                                  ],
                                  "learningObjective": "Implementar o processo de superposição para formar matrizes globais coerentes.",
                                  "commonMistakes": [
                                    "Índices off-by-one no mapeamento.",
                                    "Acumular em posições erradas devido a mapeamento incorreto.",
                                    "Esquecer de zerar matrizes globais inicialmente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar condições de contorno às matrizes globais",
                                  "subSteps": [
                                    "Identificar DOFs fixos (ex: deslocamentos nulos em apoios).",
                                    "Eliminar linhas e colunas correspondentes aos DOFs restritos, reduzindo o sistema.",
                                    "Alternativamente, modificar linhas para impor valores prescritos (penalty method ou partitioning).",
                                    "Verificar que as matrizes reduzidas mantêm propriedades físicas (positiva definida).",
                                    "Documentar o sistema final pronto para solução dinâmica."
                                  ],
                                  "verification": "Resolver um modo estático simples e comparar com solução analítica.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código para remoção de DOFs (MATLAB 'condense')",
                                    "Exemplo de viga engastada",
                                    "Teoria de condições de contorno em FEM"
                                  ],
                                  "tips": [
                                    "Prefira métodos de eliminação direta para precisão.",
                                    "Mantenha backup das matrizes completas.",
                                    "Teste com uma condição simples primeiro."
                                  ],
                                  "learningObjective": "Incorporar condições de contorno corretamente no sistema global.",
                                  "commonMistakes": [
                                    "Remover DOFs errados.",
                                    "Usar método de penalidade com fator muito baixo/alto.",
                                    "Não atualizar vetor de forças junto com matrizes."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma viga axial 1D com 2 elementos e 3 nós (DOFs globais: 1,2,3). Elemento 1: DOFs locais 1->1, 2->2; m_e = [[1,0],[0,2]]. Elemento 2: DOFs locais 1->2, 2->3; m_e = [[2,0],[0,1]]. Assembleia: M_global(1,1)=1, M(2,2)=2+2=4, M(3,3)=1. Aplique contorno fixo em DOF1: remova linha/coluna 1, resultando em [4,0;0,1].",
                              "finalVerifications": [
                                "Dimensões das matrizes globais correspondem ao número total de DOFs livres.",
                                "Simetria e positiva definitude das matrizes [K] e [M] são preservadas.",
                                "Soma das normas das matrizes elementares aproxima a norma global.",
                                "Valores em posições de mapeamento coincidem com contribuições elementares.",
                                "Condições de contorno reduzem corretamente o sistema sem singularidades.",
                                "Teste de modo: autovalores positivos para vibrações livres."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos de assembleia (erro <1%).",
                                "Correção do mapeamento de DOFs sem sobreposições.",
                                "Aplicação adequada de condições de contorno.",
                                "Eficiência na implementação (tempo computacional razoável).",
                                "Documentação clara do processo e verificações.",
                                "Capacidade de depurar erros comuns em malhas maiores."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Operações de montagem e esparsidade de matrizes.",
                                "Programação Numérica: Implementação eficiente com loops e funções vetoriais.",
                                "Física da Dinâmica: Interpretação de equações de movimento discretizadas.",
                                "Engenharia Computacional: Integração com solvers de autovalores.",
                                "Matemática Aplicada: Integração numérica em elementos finitos."
                              ],
                              "realWorldApplication": "Na análise aeroelástica de asas de aeronaves, a assembleia global permite simular respostas dinâmicas a turbulências, prevendo flutter e fadiga estrutural em softwares como NASTRAN ou Abaqus."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.2.3.3.2",
                            "name": "Formular as equações de movimento discretizadas",
                            "description": "Derivar a equação padrão do segundo grau [M]{ü} + [C]{ú} + [K]{u} = {F(t)} a partir da discretização, incluindo vetores de força dinâmica como excitações harmônicas ou de base.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a equação de movimento contínua e princípios de discretização espacial e temporal",
                                  "subSteps": [
                                    "Estudar a equação diferencial de movimento contínua: ρ ü - ∇·σ = f(t), onde σ inclui efeitos dinâmicos.",
                                    "Entender a discretização espacial via elementos finitos, aproximando o deslocamento u(x,t) = N(x) u(t).",
                                    "Discutir discretização temporal (ex: Newmark, Wilson-θ) para ü e ú.",
                                    "Identificar componentes: massa inercial, amortecimento viscoso e rigidez elástica.",
                                    "Relacionar à forma padrão [M]{ü} + [C]{ú} + [K]{u} = {F(t)}."
                                  ],
                                  "verification": "Escrever corretamente a equação contínua e sua forma semi-discretizada em termos de graus de liberdade nodais.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Livro de elementos finitos (ex: Bathe 'Finite Element Procedures')",
                                    "Notas de aula sobre dinâmica estrutural",
                                    "Software simbólico como Mathematica ou SymPy"
                                  ],
                                  "tips": "Comece com o caso 1D (barra axial) para visualizar a discretização antes de generalizar.",
                                  "learningObjective": "Compreender a transição da formulação contínua para a semi-discretizada no tempo.",
                                  "commonMistakes": [
                                    "Ignorar a dependência temporal nas funções de forma",
                                    "Confundir discretização espacial com temporal",
                                    "Esquecer termos inerciais na equação fraca"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar as matrizes elementares de massa, amortecimento e rigidez",
                                  "subSteps": [
                                    "Calcular matriz de massa elementar [M_e] = ∫ ρ N^T N dV (consistente ou lumpada).",
                                    "Derivar matriz de rigidez [K_e] = ∫ B^T D B dV, adaptada para dinâmica.",
                                    "Formular matriz de amortecimento [C_e], usando Rayleigh: α[M_e] + β[K_e].",
                                    "Verificar simetria e propriedades positivas definidas das matrizes.",
                                    "Testar em um elemento simples (ex: viga Euler-Bernoulli)."
                                  ],
                                  "verification": "Montar [M_e], [C_e], [K_e] para um elemento truss e confirmar valores numéricos.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Calculadora simbólica ou MATLAB Symbolic Toolbox",
                                    "Exemplos resolvidos de MEF dinâmico",
                                    "Folha de papel para integrais"
                                  ],
                                  "tips": "Use massa lumpada para simplicidade inicial em problemas de alta frequência.",
                                  "learningObjective": "Dominar a obtenção das matrizes elementares locais para análise dinâmica.",
                                  "commonMistakes": [
                                    "Erro na transformação de coordenadas para elementos 2D/3D",
                                    "Usar integral errada para massa (volume vs área)",
                                    "Escolha inadequada de α e β no amortecimento Rayleigh"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular vetores de força nodal elementar, incluindo forças dinâmicas",
                                  "subSteps": [
                                    "Derivar vetor de força elementar {F_e(t)} = ∫ N^T {f(t)} dV + ∫ N^T {t(t)} dS.",
                                    "Definir excitações harmônicas: {F(t)} = {F_0} sin(ωt) ou cos(ωt).",
                                    "Incluir forças de base (suporte): {F_base(t)} = -[M_e]{ü_g(t)} para terremotos ou vibrações de base.",
                                    "Exemplificar com carga distribuída harmônica em uma placa.",
                                    "Verificar equilíbrio nodal para t=0."
                                  ],
                                  "verification": "Escrever {F_e(t)} para uma excitação harmônica e uma de base em um elemento específico.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Tabelas de funções de forma por elemento",
                                    "Exemplos de cargas dinâmicas em aeroespacial",
                                    "Python/MATLAB para plotar forças vs tempo"
                                  ],
                                  "tips": "Normalize as forças para facilitar comparações entre tipos de excitação.",
                                  "learningObjective": "Capacitar a modelagem precisa de cargas dinâmicas no nível elementar.",
                                  "commonMistakes": [
                                    "Esquecer o sinal negativo nas forças de base inercial",
                                    "Aplicar harmônica como estática",
                                    "Ignorar direção vetorial das forças"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Assemblar matrizes e vetores globais e formular a equação de movimento discretizada",
                                  "subSteps": [
                                    "Assemblar [M] = ∑ [T_e]^T [M_e] [T_e], similar para [C] e [K], usando conectividade.",
                                    "Montar {F(t)} global somando contribuições elementares.",
                                    "Escrever a equação global: [M]{ü} + [C]{ú} + [K]{u} = {F(t)}.",
                                    "Incluir condições de contorno (ex: fixações aeroespaciais).",
                                    "Validar com um modelo simples de 2 elementos."
                                  ],
                                  "verification": "Assemblar manualmente para um sistema de 2 barras e obter a equação final de 4 DOFs.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Planilha Excel ou MATLAB para assembly",
                                    "Diagrama de malha finita",
                                    "Código template de MEF em Python"
                                  ],
                                  "tips": "Use índices de conectividade para evitar erros de superposição de elementos.",
                                  "learningObjective": "Executar a transição de elementar para global na formulação dinâmica.",
                                  "commonMistakes": [
                                    "Erro na matriz de transformação [T_e]",
                                    "Duplicar DOFs na assembly",
                                    "Esquecer amortecimento global"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e aplicar a equação em contextos aeroespaciais específicos",
                                  "subSteps": [
                                    "Aplicar a equações para excitação harmônica (ex: motor de aeronave).",
                                    "Simular força de base (ex: lançamento de foguete).",
                                    "Discutir redução modal para grandes sistemas.",
                                    "Implementar numericamente um caso simples.",
                                    "Analisar estabilidade da formulação."
                                  ],
                                  "verification": "Resolver um problema pequeno e plotar resposta dinâmica.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/ANSYS para simulação",
                                    "Casos de estudo aeroespaciais",
                                    "Gráficos de resposta harmônica"
                                  ],
                                  "tips": "Verifique simetria das matrizes finais para detectar erros de assembly.",
                                  "learningObjective": "Aplicar a equação discretizada a cenários reais de dinâmica estrutural aeroespacial.",
                                  "commonMistakes": [
                                    "Não linearizar para pequenas amplitudes",
                                    "Ignorar acoplamento modal",
                                    "Escala errada de frequências"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma treliça simplificada de uma asa de aeronave com 3 nós e 2 elementos truss, sujeita a excitação harmônica no nó livre (F(t) = 1000 sin(2π*50 t) N) simulando vibração de motor. Derive [M], [C], [K] globais e formule [M]{ü} + [C]{ú} + [K]{u} = {F(t)}, resolvendo para deslocamentos nodais.",
                              "finalVerifications": [
                                "Equação global derivada corretamente na forma padrão de 2ª ordem.",
                                "Matrizes de massa, amortecimento e rigidez são simétricas e positivas semi-definidas.",
                                "Vetores de força harmônica e de base incorporados adequadamente.",
                                "Assembly validada em um modelo de teste com 2-3 elementos.",
                                "Condições de contorno aplicadas sem perda de DOFs essenciais.",
                                "Resposta dinâmica plausível em simulação numérica simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação de matrizes elementares (90% correto).",
                                "Correção na assembly global sem erros de indexação.",
                                "Adequada modelagem de forças dinâmicas (harmônicas e base).",
                                "Clareza na explicação da transição contínua-discreta.",
                                "Aplicação prática em exemplo aeroespacial com resultados quantitativos.",
                                "Identificação de pelo menos 3 erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Montagem e propriedades de matrizes esparsas.",
                                "Programação Numérica: Implementação de solvers em MATLAB/Python.",
                                "Física Aplicada: Princípios de dinâmica newtoniana e Lagrangeana.",
                                "Engenharia de Controle: Preparação para análise modal e controle ativo.",
                                "Matemática Computacional: Integração numérica em elementos finitos."
                              ],
                              "realWorldApplication": "Na análise de aeroelasticidade de aeronaves e foguetes, essa formulação é essencial para prever respostas a excitações harmônicas (ex: turbulência ou motores), forças de base (lançamentos) e evitar fenômenos como flutter, garantindo segurança e otimização estrutural em missões espaciais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.2.3.3.3",
                            "name": "Aplicar análise modal nas equações MEF",
                            "description": "Diagonalizar as equações usando coordenadas modais, explorando ortogonalidade para reduzir a múltiplos graus de liberdade em problemas aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar as equações de movimento globais do sistema MEF",
                                  "subSteps": [
                                    "Montar as matrizes de massa [M], amortecimento [C] e rigidez [K] globais a partir dos elementos finitos.",
                                    "Verificar a simetria e propriedades positivas definidas das matrizes.",
                                    "Escrever a equação geral de movimento: [M]{ÿ} + [C]{ý} + [K]{y} = {F(t)}.",
                                    "Assumir condições de contorno e graus de liberdade relevantes para o problema aeroespacial.",
                                    "Simplificar para o caso não amortecido se aplicável: [M]{ÿ} + [K]{y} = 0."
                                  ],
                                  "verification": "Conferir se as matrizes resultantes são simétricas e o traço da matriz de massa é conservado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Matrizes de elementos finitos de exemplo",
                                    "Software MATLAB ou Python (NumPy/SciPy)",
                                    "Folha de cálculo ou caderno para anotações"
                                  ],
                                  "tips": "Sempre normalize as matrizes de massa para unidade se possível, facilitando cálculos posteriores.",
                                  "learningObjective": "Compreender a origem e estrutura das equações discretizadas em dinâmica estrutural.",
                                  "commonMistakes": [
                                    "Ignorar acoplamentos entre graus de liberdade",
                                    "Erros na montagem global das matrizes",
                                    "Não verificar simetria das matrizes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular e resolver o problema de autovalores",
                                  "subSteps": [
                                    "Reescrever a equação para o problema generalizado: [K]{φ} = ω²[M]{φ}.",
                                    "Usar rotina de autovalores (ex: eig no MATLAB) para calcular frequências naturais ω e modos {φ}.",
                                    "Ordenar os autovalores em ordem crescente de frequência.",
                                    "Normalizar os modos de vibração usando a norma modal: {φ}_i^T [M] {φ}_j = δ_ij.",
                                    "Selecionar os primeiros N modos relevantes para o problema."
                                  ],
                                  "verification": "Verificar ortogonalidade: {φ}_i^T [M] {φ}_j = 0 para i ≠ j e {φ}_i^T [K] {φ}_j = ω_i² δ_ij.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código MATLAB/Python para solver de autovalores",
                                    "Exemplo numérico de viga ou placa aeroespacial"
                                  ],
                                  "tips": "Use solvers robustos para problemas grandes; evite inversão direta de matrizes.",
                                  "learningObjective": "Dominar a extração de modos e frequências naturais via análise modal.",
                                  "commonMistakes": [
                                    "Não normalizar modos corretamente",
                                    "Incluir modos rígidos sem tratamento",
                                    "Erros numéricos em matrizes mal-condicionadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a transformação para coordenadas modais",
                                  "subSteps": [
                                    "Definir a matriz modal [Φ] cujas colunas são os autovetores {φ_i}.",
                                    "Transformar as coordenadas físicas: {y} = [Φ]{q}, onde {q} são coordenadas modais.",
                                    "Substituir na equação original: [M*]{ÿ_q} + [C*]{ý_q} + [K*]{q} = {F_q}.",
                                    "Projetar forças: {F_q} = [Φ]^T {F}.",
                                    "Explorar ortogonalidade para diagonalizar [M*] = [Φ]^T [M] [Φ] = I (se normalizado)."
                                  ],
                                  "verification": "Confirmar que [M*] e [K*] são diagonais: diag(ω_i²).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Script de transformação modal",
                                    "Matrizes [M], [K], [Φ] do passo anterior"
                                  ],
                                  "tips": "Garanta que [Φ] seja ortonormal em relação a [M] para simplificação.",
                                  "learningObjective": "Aprender a desacoplar o sistema multi-grau de liberdade via modos.",
                                  "commonMistakes": [
                                    "Erro na transposição da matriz modal",
                                    "Não projetar forças corretamente",
                                    "Ignorar amortecimento não proporcional"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar diagonalização e interpretar resultados",
                                  "subSteps": [
                                    "Calcular matrizes modais [M*], [C*], [K*] e confirmar diagonalidade.",
                                    "Resolver equações modais desacopladas para cada modo: m_i ÿ_{q_i} + c_i ý_{q_i} + k_i q_i = F_{q_i}.",
                                    "Animar ou plotar os modos de vibração para visualização.",
                                    "Comparar com soluções analíticas ou experimentais.",
                                    "Discutir redução modal para problemas aeroespaciais (ex: truncar modos altos)."
                                  ],
                                  "verification": "Equações modais independentes e frequências coincidem com o passo 2.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Ferramentas de plotagem (MATLAB plotmode)",
                                    "Dados de validação analítica"
                                  ],
                                  "tips": "Visualize modos para entender comportamento físico intuitivamente.",
                                  "learningObjective": "Interpretar e validar a análise modal em contextos práticos.",
                                  "commonMistakes": [
                                    "Truncar modos insuficientemente",
                                    "Interpretar incorretamente modos locais",
                                    "Não validar ortogonalidade final"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma asa de aeronave modelada por MEF com 1000 DOFs, aplique análise modal para identificar os 6 primeiros modos de flexão e torção, transformando as equações para coordenadas modais e reduzindo o modelo para análise de flutter.",
                              "finalVerifications": [
                                "Matrizes modais [M*] e [K*] são diagonais com precisão >99%.",
                                "Frequências naturais dos primeiros 5 modos coincidem com benchmark analítico em <5% de erro.",
                                "Ortogonalidade confirmada: produto escalar nulo entre modos distintos.",
                                "Transformação modal preserva energia cinética e potencial do sistema.",
                                "Modos visualizados mostram deformações físicas coerentes com estrutura aeroespacial.",
                                "Equações desacopladas resolvidas independentemente para resposta transitória."
                              ],
                              "assessmentCriteria": [
                                "Correção na formulação do problema de autovalores (simetria e normalização).",
                                "Precisão numérica dos autovalores e autovetores (erro relativo <1%).",
                                "Aplicação correta da transformação modal e diagonalização.",
                                "Validação de ortogonalidade e propriedades modais.",
                                "Interpretação física dos modos em contexto aeroespacial.",
                                "Eficiência computacional na redução modal."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Problemas de autovalores generalizados e diagonalização.",
                                "Aeroelasticidade: Identificação de frequências críticas para flutter e divergency.",
                                "Controle de Sistemas: Decoplamento modal para design de controladores.",
                                "Vibrações Mecânicas: Teoria de modos normais em sistemas contínuos.",
                                "Programação Numérica: Uso de solvers em MATLAB/Python para MEF dinâmica."
                              ],
                              "realWorldApplication": "Na certificação de aeronaves pela FAA/EASA, a análise modal das equações MEF é usada para prever vibrações induzidas por turbulência, otimizando o design de asas e fuselagens contra fadiga e instabilidades aeroelásticas como flutter."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.2.3.3.4",
                            "name": "Verificar com exemplo numérico simples",
                            "description": "Resolver um exemplo de viga em vibração livre usando MEF com 2 elementos, calculando frequências naturais e comparando com solução exata.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o problema e configurar o modelo da viga",
                                  "subSteps": [
                                    "Especificar as propriedades da viga: comprimento L=1 m, módulo de elasticidade E=210 GPa, módulo de cisalhamento G=81 GPa, inércia I=1e-8 m⁴, densidade ρ=7800 kg/m³, área A=1e-4 m².",
                                    "Definir condições de contorno: viga engastada em uma extremidade (w(0)=0, w'(0)=0) e livre na outra.",
                                    "Escolher 2 elementos finitos de viga Euler-Bernoulli, com nós em x=0, 0.5, 1.0 m.",
                                    "Estabelecer funções de interpolação hermitianas para deslocamentos transversais.",
                                    "Calcular frequências naturais exatas usando fórmula analítica: ω_n = (β_n L)^2 √(EI / ρ A L^4), com β_1 L ≈ 1.875, β_2 L ≈ 4.694."
                                  ],
                                  "verification": "Verificar se propriedades, condições de contorno e divisão em elementos estão documentadas corretamente em um esboço ou tabela.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel, lápis, calculadora, tabela de valores β_n para vigas engastada-livre.",
                                  "tips": "Desenhe um diagrama da viga com nós numerados para visualizar melhor.",
                                  "learningObjective": "Compreender a configuração inicial de um problema de vibração livre em MEF.",
                                  "commonMistakes": "Esquecer unidades consistentes (SI) ou condições de contorno erradas (ex: confundir engastada com articulada)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular matrizes de rigidez e massa elementares",
                                  "subSteps": [
                                    "Derivar matriz de rigidez local [k_e] para elemento de viga: k_e = (EI / l^3) * [[12, 6l, -12, 6l], [6l, 4l², -6l, 2l²], [-12, -6l, 12, -6l], [6l, 2l², -6l, 4l²]], com l=0.5 m.",
                                    "Derivar matriz de massa consistente [m_e]: m_e = (ρ A l / 420) * [[156, 22l, 54, -13l], [22l, 4l², 13l, -3l²], [54, 13l, 156, -22l], [-13l, -3l², -22l, 4l²]].",
                                    "Calcular valores numéricos para [k_e] e [m_e] de cada elemento.",
                                    "Verificar simetria e propriedades positivas das matrizes.",
                                    "Aplicar condições de contorno removendo graus de liberdade fixos (1 e 2 no nó 1)."
                                  ],
                                  "verification": "Comparar valores numéricos de [k_e] e [m_e] com fórmulas padrão; deve resultar em matrizes simétricas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora científica ou software como MATLAB/Octave, fórmulas de MEF para vigas.",
                                  "tips": "Use l=0.5 m para simplificar cálculos; armazene matrizes em formato tabular.",
                                  "learningObjective": "Dominar a derivação de matrizes elementares para dinâmica de vigas.",
                                  "commonMistakes": "Erro no sinal das funções de forma ou esquecer fator de escala em massa consistente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Montar matrizes globais e aplicar condições de contorno",
                                  "subSteps": [
                                    "Montar [K] global somando contribuições: K(3:4,3:4) += k_e1(3:4,3:4), K(3:6,3:6) += k_e2(1:4,1:4), similar para [M].",
                                    "Resultado: sistema 4x4 livre (graus de liberdade 3,4,5,6).",
                                    "Calcular valores numéricos finais de [K] e [M] globais.",
                                    "Verificar partição correta após remoção de DOFs engastados.",
                                    "Normalizar ou escalar matrizes se necessário para precisão numérica."
                                  ],
                                  "verification": "Determinante de [K] positivo e [M] definida positiva; trace(M) ≈ ρ A L.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha Excel ou MATLAB para montagem matricial.",
                                  "tips": "Numerote DOFs claramente: nó1(θ_y=1, w=2), nó2(w=3, θ_y=4), nó3(w=5, θ_y=6).",
                                  "learningObjective": "Executar montagem global eficiente em MEF dinâmico.",
                                  "commonMistakes": "Sobreposição incorreta de elementos ou esquecer renumeração de DOFs."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver problema de autovalores e calcular frequências",
                                  "subSteps": [
                                    "Formular [K] {φ} = ω² [M] {φ} e resolver autovalores ω² usando decomposição ou função eig().",
                                    "Extrair 2 menores frequências naturais ω1, ω2 (rad/s).",
                                    "Calcular frequências em Hz: f = ω / (2π).",
                                    "Comparar com exatas: ω1_exata ≈ 3.516 √(EI/ρAL^4), ω2_exata ≈ 22.034 √(EI/ρAL^4).",
                                    "Calcular erro percentual: |ω_num - ω_ex|/ω_ex * 100%."
                                  ],
                                  "verification": "Autovalores positivos reais; erro <5% para 2 elementos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software numérico (MATLAB, Python com NumPy/SciPy).",
                                  "tips": "Use eig(K, M) para autovalores generalizados; plote modos se possível.",
                                  "learningObjective": "Aplicar análise modal em MEF para vibrações livres.",
                                  "commonMistakes": "Confundir autovalores com frequências ou escalar incorretamente."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar resultados e validar convergência",
                                  "subSteps": [
                                    "Tabular ω_num, ω_ex, erro para modos 1 e 2.",
                                    "Discutir convergência: com 2 elementos, erro ~2-5%; mais elementos melhoram.",
                                    "Visualizar modos de vibração aproximados.",
                                    "Documentar lições: MEF aproxima bem modos baixos.",
                                    "Testar sensibilidade variando propriedades."
                                  ],
                                  "verification": "Relatório com tabela de comparação e gráficos de modos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software de plotagem (MATLAB plot ou Python Matplotlib).",
                                  "tips": "Salve código/script para reprodutibilidade.",
                                  "learningObjective": "Interpretar e validar resultados de MEF contra analítico.",
                                  "commonMistakes": "Ignorar normalização de modos ou superestimar precisão."
                                }
                              ],
                              "practicalExample": "Para viga de aço L=1m, engastada-livre, com 2 elementos: ω1_num ≈ 3.52 rad/s (erro 0.1%), ω2_num ≈ 22.10 rad/s (erro 0.3%), vs. exatas 3.516 e 22.034 rad/s. Código MATLAB: K = [...]; M=[...]; [V,D]=eig(K,M);",
                              "finalVerifications": [
                                "Matrizes elementares derivadas corretamente com valores numéricos exatos.",
                                "Montagem global resulta em sistema 4x4 com DOFs livres.",
                                "Frequências numéricas calculadas com erro <5% vs. exatas.",
                                "Tabela de comparação e erros percentuais documentados.",
                                "Modos de vibração plotados e qualitativamente corretos.",
                                "Código ou cálculos manuais reproduzíveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica das frequências (erro <3%).",
                                "Correção na formulação de matrizes [k_e] e [m_e].",
                                "Eficiência na montagem e resolução de autovalores.",
                                "Análise qualitativa de convergência e erros.",
                                "Clareza na documentação e visualizações.",
                                "Identificação de potenciais melhorias (ex: mais elementos)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (autovalores generalizados).",
                                "Programação: Implementação numérica em Python/MATLAB.",
                                "Física: Teoria de vibrações e ondas em contínuos.",
                                "Engenharia Computacional: Validação de modelos numéricos."
                              ],
                              "realWorldApplication": "Verificação de frequências naturais em asas de aeronaves ou pás de turbinas para evitar ressonância com excitações aerodinâmicas, essencial em certificação FAA/EASA de estruturas aeroespaciais."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.3",
                    "name": "Matrizes de Massa, Rigidez e Amortecimento no MEF",
                    "description": "Construção e montagem das matrizes elementares de massa, rigidez e amortecimento de Rayleigh para análise dinâmica.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.3.1",
                        "name": "Matriz de Rigidez Elementar no MEF",
                        "description": "Derivação e construção da matriz de rigidez [k] para elementos finitos unidimensionais e bidimensionais, considerando deformações axiais, flexurais e de cisalhamento, essenciais para modelagem dinâmica de estruturas aeroespaciais como vigas e painéis.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.1.1",
                            "name": "Identificar graus de liberdade e funções de interpolação",
                            "description": "Determinar os graus de liberdade nodais (translações e rotações) e selecionar funções de forma adequadas (lineares ou quadráticas) para elementos barra e viga no contexto de análise dinâmica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de graus de liberdade (DOFs) em elementos finitos",
                                  "subSteps": [
                                    "Defina graus de liberdade nodais como os deslocamentos independentes (translações e rotações) em nós de elementos finitos.",
                                    "Estude a diferença entre DOFs kinemáticos e estáticos em estruturas 1D como barras e vigas.",
                                    "Revise a importância dos DOFs na formulação da matriz de rigidez elementar no MEF.",
                                    "Analise diagramas de nós para barras (axial) e vigas (transverso e rotacional).",
                                    "Compare DOFs totais por elemento: 2 para barra linear, 4 para viga planar."
                                  ],
                                  "verification": "Crie um diagrama anotado de DOFs para um elemento barra e viga, confirmando com referências padrão de MEF.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de MEF (ex: Bathe ou Zienkiewicz)",
                                    "Diagramas de elementos finitos impressos",
                                    "Software como MATLAB para visualização"
                                  ],
                                  "tips": "Use setas para representar translações (u, v) e rotações (θ) claramente nos diagramas.",
                                  "learningObjective": "Identificar e classificar DOFs nodais básicos em elementos estruturais 1D.",
                                  "commonMistakes": [
                                    "Confundir DOFs nodais com modais; ignorar rotações em vigas; assumir simetria sem justificar."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar DOFs específicos para elementos barra",
                                  "subSteps": [
                                    "Descreva DOFs para barra axial: translação axial (u) em cada nó (2 DOFs totais).",
                                    "Discuta ausência de rotações em barras puramente axiais.",
                                    "Calcule DOFs para barra com 2 nós lineares vs. quadrática (3 nós).",
                                    "Examine condições de contorno que restringem DOFs em análises dinâmicas.",
                                    "Pratique listando DOFs em um sketch de malha com múltiplas barras."
                                  ],
                                  "verification": "Liste corretamente os DOFs para uma barra com 2 e 3 nós, incluindo vetor de deslocamentos {u1, u2} ou {u1, u2, u3}.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Folhas de papel para sketches",
                                    "Tutoriais online de MEF para barras (ex: YouTube ou MIT OpenCourseWare)",
                                    "Planilha Excel para tabulação de DOFs"
                                  ],
                                  "tips": "Lembre-se: barras são uniaxial, focando apenas em alongamento; visualize deformação axial.",
                                  "learningObjective": "Determinar precisamente os DOFs nodais para elementos barra em MEF dinâmico.",
                                  "commonMistakes": [
                                    "Incluir rotações desnecessárias; confundir com elementos treliça 2D; ignorar nós intermediários em elementos quadráticos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar DOFs e funções de interpolação para elementos viga",
                                  "subSteps": [
                                    "Liste DOFs para viga Euler-Bernoulli: translação vertical (w) e rotação (θ) em cada nó (4 DOFs para 2 nós).",
                                    "Compare com viga Timoshenko, incluindo cisalhamento.",
                                    "Estude funções de forma lineares: N1 = 1 - ξ, N2 = ξ para deslocamentos; Hermite cúbicas para vigas.",
                                    "Introduza funções quadráticas para nós intermediários, aumentando precisão em curvaturas.",
                                    "Derive brevemente a interpolação de deslocamento w(ξ) = Σ Ni wi."
                                  ],
                                  "verification": "Desenhe o elemento viga com DOFs {w1, θ1, w2, θ2} e escreva funções lineares vs. quadráticas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software FEA como ANSYS Student ou FreeFEM",
                                    "Notas de aula sobre teoria de vigas",
                                    "Calculadora simbólica (ex: SymPy no Python)"
                                  ],
                                  "tips": "Use coordenada natural ξ (-1 a 1) para funções de forma; teste consistência de rotação dw/dx = θ.",
                                  "learningObjective": "Associar DOFs nodais de vigas com funções de interpolação adequadas.",
                                  "commonMistakes": [
                                    "Omitir rotações nos nós; usar lineares para flexão sem Hermite; confundir ordem polinomial com número de DOFs."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Selecionar funções de interpolação adequadas para análise dinâmica",
                                  "subSteps": [
                                    "Critérios de seleção: linear para campos suaves, quadrática para gradientes altos ou singularidades.",
                                    "Avalie convergência: quadráticas melhoram precisão em massas consistentes dinâmicas.",
                                    "Compare matrizes de rigidez para linear vs. quadrática em barra/viga.",
                                    "Aplique em contexto aeroespacial: vigas para painéis de asas com flutter.",
                                    "Simule uma malha simples e verifique DOFs totais do sistema."
                                  ],
                                  "verification": "Justifique escolha de função quadrática para viga em análise de vibração, com equação de shape function.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código MATLAB/Octave para montar Ke e Me",
                                    "Exemplos de problemas aeroelásticos",
                                    "Referência: 'Finite Element Procedures' de Bathe"
                                  ],
                                  "tips": "Verifique isoparamétrico: mesma ordem para geometria e campo; priorize consistência de massa em dinâmica.",
                                  "learningObjective": "Selecionar otimizadamente DOFs e funções de interpolação para elementos barra/viga em MEF dinâmico.",
                                  "commonMistakes": [
                                    "Escolher quadrática sem necessidade (aumenta custo computacional); ignorar locking em vigas finas; não validar com soluções analíticas."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma viga cantilever representando uma longarina de asa de aeronave. Identifique DOFs: nó raiz fixo (w1=0, θ1=0), nó livre (w2, θ2). Use funções Hermite cúbicas lineares para análise de modo fundamental de flexão; mude para quadráticas adicionando nó médio para capturar curvatura não-linear em flutter.",
                              "finalVerifications": [
                                "Lista correta de DOFs para barra (2-3) e viga (4-6).",
                                "Funções de forma lineares e quadráticas derivadas sem erros.",
                                "Justificativa contextual para escolha em dinâmica aeroespacial.",
                                "Diagrama de elemento com nós, DOFs e shape functions anotados.",
                                "Simulação simples em software mostrando convergência.",
                                "Comparação com solução analítica para freq. natural."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de DOFs nodais (translações/rotações).",
                                "Correta derivação e seleção de funções de interpolação.",
                                "Integração com matrizes de rigidez/massa no MEF dinâmico.",
                                "Aplicação prática a elementos aeroespaciais.",
                                "Ausência de erros comuns como locking ou inconsistência.",
                                "Clareza em diagramas e justificativas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Polinômios de Lagrange/Hermite e integração numérica Gauss.",
                                "Física: Equações de equilíbrio dinâmico de vigas (Euler-Bernoulli).",
                                "Programação: Implementação de MEF em Python/MATLAB para automação.",
                                "Engenharia Aeroespacial: Análise de flutter e fadiga em estruturas compostas."
                              ],
                              "realWorldApplication": "Em projetos de aeronaves, como o Boeing 787, engenheiros usam MEF com DOFs e funções quadráticas em vigas para simular respostas dinâmicas a turbulência, previnindo aeroelasticidade divergente e otimizando peso estrutural."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.2",
                            "name": "Derivar matriz de rigidez para elemento barra axial",
                            "description": "Calcular a matriz [k_e] = ∫ [B]^T [D] [B] dV para elemento barra considerando rigidez axial EA/L, incluindo transformações para elementos inclinados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configuração do elemento barra axial e definição de graus de liberdade",
                                  "subSteps": [
                                    "Desenhe o elemento barra axial com nós i e j, comprimento L, seção transversal A e módulo de elasticidade E.",
                                    "Identifique os graus de liberdade: deslocamentos axiais u_i e u_j nos nós.",
                                    "Defina o sistema de coordenadas local x ao longo do eixo da barra.",
                                    "Escreva a função de interpolação linear para o deslocamento u(x) = N_i u_i + N_j u_j, onde N_i = 1 - x/L e N_j = x/L.",
                                    "Calcule a deformação axial ε_x = du/dx a partir das funções de forma."
                                  ],
                                  "verification": "Verifique se a matriz de funções de forma [N] está correta interpolando u(x) em pontos médios e extremos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis para esboços",
                                    "Livro de MEF (ex: Bathe ou Zienkiewicz)",
                                    "Software de desenho vetorial opcional"
                                  ],
                                  "tips": "Sempre normalize as funções de forma para que N_i + N_j = 1 em todo o domínio.",
                                  "learningObjective": "Compreender a cinemática do elemento barra e suas funções de interpolação lineares.",
                                  "commonMistakes": [
                                    "Confundir coordenadas locais com globais desde o início",
                                    "Esquecer que ε = du/dx para deformação uniaxial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivação da matriz de deformação [B]",
                                  "subSteps": [
                                    "Derive a deformação ε_x = dN_i/dx * u_i + dN_j/dx * u_j.",
                                    "Calcule as derivadas: dN_i/dx = -1/L, dN_j/dx = 1/L.",
                                    "Forme a matriz [B] = [-1/L, 1/L], constante ao longo do elemento.",
                                    "Confirme que [B] relaciona {ε} = [B] {d_e}, onde {d_e} = [u_i, u_j]^T.",
                                    "Verifique a consistência dimensional de [B] (1/L)."
                                  ],
                                  "verification": "Substitua valores numéricos simples (L=1, u_i=1, u_j=0) e confirme ε_x = -1 em x=0 e 0 em x=1.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico como SymPy/MATLAB",
                                    "Folha de derivações"
                                  ],
                                  "tips": "Lembre-se: [B] é derivada das funções de forma em relação a x local.",
                                  "learningObjective": "Construir a matriz [B] que liga deformações a deslocamentos nodais.",
                                  "commonMistakes": [
                                    "Usar funções de forma em vez de suas derivadas",
                                    "Inverter os sinais em dN/dx"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definição da matriz constitutiva [D] e integração para [k_e] local",
                                  "subSteps": [
                                    "Defina [D] = E para comportamento uniaxial isotrópico.",
                                    "Escreva a fórmula geral [k_e] = ∫_0^L [B]^T [D] [B] A dx.",
                                    "Como [B], [D] constantes, simplifique para [k_e] = [B]^T E [B] A L.",
                                    "Compute explicitamente: k_11 = k_22 = EA/L, k_12 = k_21 = -EA/L.",
                                    "Forme a matriz 2x2 simétrica [k_e] = (EA/L) [[1, -1], [-1, 1]]."
                                  ],
                                  "verification": "Calcule numericamente com E=200 GPa, A=1 cm², L=1 m e confirme rigidez axial esperada.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB/Python para matrizes simbólicas",
                                    "Tabela de propriedades de materiais"
                                  ],
                                  "tips": "A integração é trivial por constância; foque na multiplicação matricial.",
                                  "learningObjective": "Derivar a matriz de rigidez elementar via formulação fraca do MEF.",
                                  "commonMistakes": [
                                    "Esquecer o fator A na integração volumétrica",
                                    "Perder a simetria da matriz [k_e]"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Transformação para coordenadas globais em elementos inclinados",
                                  "subSteps": [
                                    "Defina ângulo θ entre eixo local x e global X.",
                                    "Construa a matriz de rotação [T] = [[cosθ, sinθ], [-sinθ, cosθ]] para 2D.",
                                    "Transforme deslocamentos locais {d_e_local} = [T] {d_e_global}.",
                                    "Obtenha [k_e_global] = [T]^T [k_e_local] [T].",
                                    "Verifique para θ=0: [k_global] = [k_local]; para θ=45°: componentes corretas."
                                  ],
                                  "verification": "Implemente em código e compare com fórmula analítica para θ conhecido.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software MEF como ANSYS Student ou código Python customizado",
                                    "Exemplos numéricos de livros de MEF"
                                  ],
                                  "tips": "Sempre verifique [T]^T [T] = [I] para ortogonalidade.",
                                  "learningObjective": "Aplicar transformações de coordenadas para elementos arbitrariamente orientados.",
                                  "commonMistakes": [
                                    "Usar [T] em vez de [T]^T na transformação de rigidez",
                                    "Confundir vetores linha/coluna em {d_local}"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma barra de aço (E=200 GPa, A=1e-4 m², L=2 m) inclinada a 30° em um truss 2D: derive [k_e_local] = (1e7) [[1,-1],[-1,1]], então aplique [T] com cos30=√3/2, sin30=0.5 para obter [k_e_global] e some a uma estrutura simples de 2 barras.",
                              "finalVerifications": [
                                "Derive [k_e] corretamente para barra horizontal (θ=0).",
                                "Confirme simetria e propriedades de partição zero de [k_e].",
                                "Transforme para θ=45° e verifique rigidez equivalente.",
                                "Implemente em código e compare com solução analítica (erro <1%).",
                                "Explique verbalmente o papel de [B], [D] e ∫ dV.",
                                "Resolva um truss simples com 2 elementos e valide deslocamentos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de [B] e [D] (100% correto).",
                                "Correta simplificação da integral para forma fechada EA/L.",
                                "Matrriz de transformação [T] e [k_global] sem erros algébricos.",
                                "Exemplo prático resolvido com valores numéricos consistentes.",
                                "Identificação de erros comuns e justificativas claras.",
                                "Clareza na documentação de steps e verificações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (multiplicação matricial, autovalores para modos).",
                                "Programação: Implementação em Python/MATLAB para automação MEF.",
                                "Física: Mecânica dos sólidos, lei de Hooke uniaxial.",
                                "Engenharia Aeroespacial: Modelagem de treliças em fuselagens.",
                                "Cálculo Numérico: Integração gaussiana para elementos mais complexos."
                              ],
                              "realWorldApplication": "Em projetos aeroespaciais, como análise de treliças em suportes de motores ou estruturas de satélites, onde matrizes de rigidez elementares são assembladas para prever deformações sob cargas dinâmicas de voo, otimizando peso e segurança."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.1.3",
                            "name": "Derivar matriz de rigidez para elemento viga flexural",
                            "description": "Obter a matriz 12x12 [k_e] para viga Euler-Bernoulli com termos de flexão EI/L^3, considerando condições de contorno e acoplamento entre nós.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o modelo da viga Euler-Bernoulli e definir graus de liberdade",
                                  "subSteps": [
                                    "Revise as hipóteses da teoria Euler-Bernoulli: seções planas permanecem planas, deformação transversal desprezível, rotação igual à derivada da deflexão.",
                                    "Identifique os 6 graus de liberdade por nó: deslocamentos axiais (ux), transversais (uy, uz) e rotações (θx, θy, θz).",
                                    "Esboce o elemento viga com comprimento L, módulo de elasticidade E e momentos de inércia Iy, Iz para flexão em planos y e z.",
                                    "Defina o vetor de deslocamentos nodais {d_e} de dimensão 12x1.",
                                    "Anote as condições de contorno iniciais para nós livremente apoiados."
                                  ],
                                  "verification": "Desenhe o esquema do elemento com DOFs rotulados corretamente e liste as hipóteses em um resumo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro-texto de MEF (ex: Bathe ou Zienkiewicz)",
                                    "Papel milimetrado",
                                    "Calculadora simbólica (Mathematica ou SymPy)"
                                  ],
                                  "tips": "Comece pelo plano simples (2D) para flexão em y antes de generalizar para 3D.",
                                  "learningObjective": "Entender a cinemática do elemento viga e seus DOFs associados à flexão.",
                                  "commonMistakes": [
                                    "Confundir rotações com deslocamentos transversais",
                                    "Esquecer torção θx na matriz 12x12"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenvolver funções de interpolação hermitianas para flexão",
                                  "subSteps": [
                                    "Derive as funções de forma N1 a N4 para deflexão v(x) em flexão planar: N1 = 1 - 3ξ² + 2ξ³, etc., onde ξ = x/L.",
                                    "Estenda para rotação θ(x) = dv/dx usando funções hermitianas.",
                                    "Generalize para flexão em y (uy, θz) e z (uz, θy), mantendo desacoplamento.",
                                    "Inclua funções lineares para extensão axial ux e cúbicas para torção θx se aplicável.",
                                    "Verifique continuidade de deslocamento e derivada nos nós."
                                  ],
                                  "verification": "Escreva explicitamente as 4 funções de forma para v(x) e plote-as para ξ de 0 a 1.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de plotagem (Matlab ou Python Matplotlib)",
                                    "Tabela de funções hermitianas de referência"
                                  ],
                                  "tips": "Use ξ normalizado para simplificar derivações algébricas.",
                                  "learningObjective": "Construir funções de forma que garantem C1-continuidade necessária para vigas.",
                                  "commonMistakes": [
                                    "Usar funções lineares em vez de hermitianas",
                                    "Erros nos coeficientes polinomiais (ex: 3ξ² ao invés de 2ξ³)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a matriz operadora de deformação [B]",
                                  "subSteps": [
                                    "Calcule as derivadas das funções de forma: dv/dx = (1/L) dN/dξ.",
                                    "Para flexão em y: ε_yy = -d²uy/dx² (curvatura κ_z).",
                                    "Monte [B] como matriz 1x12 (para flexão uniaxial) com termos d²N_i/dx² multiplicados por fatores.",
                                    "Separe submatrizes para flexão y, z, extensão e torção (desacopladas na formulação padrão).",
                                    "Verifique dimensionalidade: [B] tem linhas para cada modo de deformação."
                                  ],
                                  "verification": "Escreva [B] para flexão em y e confirme que derivadas de segunda ordem aparecem apenas em DOFs de flexão.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": [
                                    "Folha de cálculo simbólica",
                                    "Referência MEF para vigas 3D"
                                  ],
                                  "tips": "Agrupe DOFs por plano para evitar matrizes esparsas confusas.",
                                  "learningObjective": "Relacionar deslocamentos nodais à curvatura via [B].",
                                  "commonMistakes": [
                                    "Confundir κ_z com d²uy/dx² (sinal negativo)",
                                    "Incluir acoplamento prematuro entre planos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar a matriz de rigidez [k_e] via integração",
                                  "subSteps": [
                                    "Escreva [k_e] = ∫_0^L [B]^T E I [B] dx para flexão (A para axial, GJ para torção).",
                                    "Para flexão: submatriz 4x4 por plano com termos EI/L^3 * coeficientes (12, 6L, etc.).",
                                    "Realize integração analítica: substitua ξ, integre polinômios de grau 6.",
                                    "Monte a matriz 12x12 completa, com blocos diagonais para modos desacoplados.",
                                    "Aplique condições de contorno reduzindo DOFs se necessário (ex: viga encastrada)."
                                  ],
                                  "verification": "Calcule entrada k_{yy,yy} = 12 EI / L^3 e confirme simetria.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": [
                                    "SymPy ou Mathematica para integração simbólica",
                                    "Matriz padrão de viga como referência"
                                  ],
                                  "tips": "Integre por partes ou use tabelas conhecidas, mas derive do zero.",
                                  "learningObjective": "Obter expressão fechada da matriz [k_e] 12x12.",
                                  "commonMistakes": [
                                    "Fator 1/L incorreto nas derivadas",
                                    "Assimetria na matriz final"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar propriedades e considerar acoplamentos nodais",
                                  "subSteps": [
                                    "Confirme simetria, semi-definidade positiva e partição nodal.",
                                    "Analise acoplamento: forças em um nó afetam o outro via off-diagonais.",
                                    "Teste com casos conhecidos: viga biapoiada livre, compare com analítico.",
                                    "Discuta extensões: cisalhamento Timoshenko ou acoplamento axial-flexural.",
                                    "Documente a matriz final com termos EI_y/L^3, EI_z/L^3."
                                  ],
                                  "verification": "Multiplique [k_e] por vetor unitário e verifique energia positiva.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software numérico (ANSYS ou código MEF simples)",
                                    "Exemplos numéricos"
                                  ],
                                  "tips": "Use propriedades de simetria para reduzir cálculos.",
                                  "learningObjective": "Validar a derivação e entender implicações físicas.",
                                  "commonMistakes": [
                                    "Ignorar fator 1/420 em alguns termos",
                                    "Confundir Iy com Iz"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma viga de L=5m, E=70 GPa, Iy=1e-4 m^4 (alumínio aeroespacial), derive a submatriz de flexão em y: [[12EI/L^3, 6EI/L^2, -12EI/L^3, 6EI/L^2], [sym], ...] resultando em k11=1.68e5 N/m, e implemente em código para montagem global.",
                              "finalVerifications": [
                                "Matriz [k_e] é 12x12, simétrica e com zeros nos acoplamentos cruzados (flexão y-z).",
                                "Termos de flexão: 12EI/L^3 na diagonal para deslocamentos transversais.",
                                "Coeficientes off-diagonal corretos: 6EI/L^2 para acoplamento deslocamento-rotação.",
                                "Soma de rigidez nodal preserva equilíbrio estático.",
                                "Energia de deformação positiva para modos físicos.",
                                "Convergência para solução exata em malha refinada."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos coeficientes numéricos/analíticos (erro <1%).",
                                "Correta identificação de DOFs e funções hermitianas.",
                                "Integração analítica sem erros algébricos.",
                                "Verificação de simetria e propriedades energéticas.",
                                "Explicação clara de acoplamentos nodais.",
                                "Aplicação correta a condições de contorno."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Integração de polinômios e álgebra matricial.",
                                "Programação: Implementação em Python (NumPy/SciPy) ou Fortran para MEF.",
                                "Física: Equilíbrio de momentos e teoria de vigas clássica.",
                                "Engenharia Mecânica: Análise modal de estruturas.",
                                "Computação Científica: Integração numérica (Gauss) para elementos complexos."
                              ],
                              "realWorldApplication": "Na análise de estruturas aeroespaciais, como asas de aeronaves, a matriz [k_e] é essencial para simulações MEF de aeroelasticidade, prevendo flutter e fadiga em projetos da Embraer ou Boeing."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.1.1",
                              "10.1.4.3.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.2",
                        "name": "Matriz de Massa Elementar no MEF",
                        "description": "Construção das matrizes de massa consistentes e diagonais (lumped) [m_e] para elementos finitos, utilizando integração numérica ou analítica, para capturar inércias translacionais e rotacionais em análises dinâmicas.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.2.1",
                            "name": "Calcular matriz de massa consistente para barra",
                            "description": "Derivar [m_e] = ρA L ∫ [N]^T [N] dx, resultando em matriz 2x2 com termos 6/30 e 1/30 para massa uniforme.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Funções de Interpolação Linear para Elemento Barra",
                                  "subSteps": [
                                    "Defina o elemento barra unidimensional com dois nós nos extremos (x=0 e x=L).",
                                    "Introduza a coordenada normalizada ξ = x/L, onde ξ varia de 0 a 1.",
                                    "Escreva as funções de forma lineares: N₁(ξ) = 1 - ξ, N₂(ξ) = ξ.",
                                    "Verifique que N₁(0)=1, N₁(1)=0, N₂(0)=0, N₂(1)=1.",
                                    "Confirme que N₁ + N₂ = 1 para interpolação contínua."
                                  ],
                                  "verification": "As funções de forma interpolam corretamente os deslocamentos nos nós e somam 1 em qualquer ponto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de MEF (ex: Bathe ou Zienkiewicz)",
                                    "Calculadora"
                                  ],
                                  "tips": "Desenhe o elemento barra com ξ marcado para visualização intuitiva.",
                                  "learningObjective": "Compreender e aplicar funções de interpolação lineares em elementos finitos 1D.",
                                  "commonMistakes": [
                                    "Confundir N₁ e N₂",
                                    "Esquecer normalização ξ = x/L",
                                    "Não verificar condições de nós"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a Expressão da Matriz de Massa Consistente",
                                  "subSteps": [
                                    "Lembre a definição geral: [m_e] = ∫_Ω ρ [N]^T [N] dV, onde Ω é o volume do elemento.",
                                    "Para barra 1D uniforme: dV = A dx, então [m_e] = ρ A ∫_0^L [N]^T [N] dx.",
                                    "Mude para ξ: dx = L dξ, integral de 0 a 1, resultando [m_e] = ρ A L ∫_0^1 [N]^T [N] dξ.",
                                    "Escreva [N] = [N₁  N₂] como vetor linha para deslocamentos nodais.",
                                    "Identifique a matriz 2x2: m_{11} = ρAL ∫ N₁² dξ, m_{12}=ρAL ∫ N₁ N₂ dξ, etc."
                                  ],
                                  "verification": "A expressão [m_e] = ρ A L ∫_0^1 [N]^T [N] dξ está corretamente escrita e simétrica.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software simbólico como Mathematica ou SymPy (opcional)"
                                  ],
                                  "tips": "Sempre fatorize ρ A L fora da integral para simplificação.",
                                  "learningObjective": "Derivar a fórmula padrão da matriz de massa consistente para elementos lineares.",
                                  "commonMistakes": [
                                    "Esquecer o jacobiano L em dx = L dξ",
                                    "Usar [N] como matriz em vez de vetor",
                                    "Ignorar simetria da matriz"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular os Elementos da Integral",
                                  "subSteps": [
                                    "Calcule ∫_0^1 N₁² dξ = ∫ (1-ξ)² dξ = ∫ (1 - 2ξ + ξ²) dξ = [ξ - ξ² + ξ³/3]_0^1 = 1/3.",
                                    "Calcule ∫_0^1 N₂² dξ = ∫ ξ² dξ = [ξ³/3]_0^1 = 1/3.",
                                    "Calcule ∫_0^1 N₁ N₂ dξ = ∫ (1-ξ)ξ dξ = ∫ (ξ - ξ²) dξ = [ξ²/2 - ξ³/3]_0^1 = 1/6.",
                                    "Note que m_{12} = m_{21} = ρ A L * (1/6), m_{11} = m_{22} = ρ A L * (1/3).",
                                    "Simplifique: m_{11} = (6/30) ρ A L, pois 1/3 = 10/30, mas padronize para 30 como denominador comum."
                                  ],
                                  "verification": "Todos os integrais são corretos: 1/3 para diagonais, 1/6 para off-diagonais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou software de integração",
                                    "Tabela de integrais indefinidas"
                                  ],
                                  "tips": "Use expansão binomial para (1-ξ)² e integre termo a termo.",
                                  "learningObjective": "Executar integrais exatas das funções de forma quadráticas.",
                                  "commonMistakes": [
                                    "Erro em limites de integração",
                                    "Confundir 1/3 com 1/2",
                                    "Não usar denominador comum 30"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar a Matriz Final e Verificar Consistência",
                                  "subSteps": [
                                    "Monte [m_e] = (ρ A L / 30) * [ 36  3 ; 3  36 ]? Não: corrija para padrão: diagonais 6/30 m? Espera, m=ρAL.",
                                    "Diagonal: (1/3)m = 10/30 m? Não: 1/3 ≈0.333, mas padrão é 6/30=0.2 e 1/30≈0.033 para consistentes? Recalcule precisamente.",
                                    "Correção padrão: ∫N₁²= ∫(1-2ξ+ξ²)=1-1+1/3=1/3? Para massa consistente linear: m11= ρAL (2/3 *1/2? Padrão é [m_e]=(m/6)[2 1;1 2] onde m=ρAL, mas 2/6=1/3, sim.",
                                    "Padronize: [m_e] = (ρ A L / 6) [ 2 1 ; 1 2 ], ou equivalentemente (m/6)[2 1;1 2].",
                                    "Verifique soma de linha: 2/6 +1/6=1/2 m por nó, total m.",
                                    "Confirme termos 6/30=1/5? Nota: 6/30 m para? Prompt diz 6/30 e 1/30, mas cálculo exato é 120/420? Para beam 2D é diferente; para barra axial é [m/6 (2 1;1 2)]. Assuma prompt erro, use padrão correto: m11=m22= m/3 =10m/30, m12= m/6=5m/30? Não combina. Recheck: prompt '6/30 e 1/30', talvez para transverse ou erro. Para consistentes bar é m/6 [2 1;1 2], 2/6m=1/3m=10/30m, 1/6m=5/30m, mas prompt diz 6/30 e 1/30. Talvez lumped é 1/2, consist é diferente. Upon standard: para 1D bar, sim [ρAL/6] [2 1;1 2], mas alguns livros usam /30 para beam com hermite. Contexto 'barra', mas aero estruturas, provavelmente truss bar. Mas prompt especifica 6/30 e 1/30, que é para Euler-Bernoulli beam massa consistente aproximada? Para beam transverse, matriz 4x4 tem termos como ρA L /420 * 156 etc, mas para simplified 2DOF bar é não. Para simple bar with linear shape, é /6 [2 1;1 2]. Mas para seguir prompt: assuma result 6/30 m diagonal? 6/30=0.2m, 1/30≈0.033m, soma linha 0.233m x2=0.466, não m. Talvez erro prompt, mas use padrão correto e note como 6/30 se for variant. Standard for consistent mass 1D bar: m11 = ρAL ∫N1^2 = ρAL /3, m12=ρAL /6. Para denominador 30: /3 =10/30, /6=5/30. Talvez prompt erro tipográfico, 6/30 para outro. Para seguir, use cálculo correto: [m/6] [2 1;1 2].",
                                    "Verificação final: trace([m_e]) = 2*(ρAL/3) = 2m/3? Não, para modais.",
                                    "Confirme simetria e positivo definido."
                                  ],
                                  "verification": "Matriz final: [m_e] = \frac{ρ A L}{6} \begin{bmatrix} 2 & 1 \\ 1 & 2 \begin{bmatrix}, soma elementos = 6/6 ρAL = m total.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Matriz escrita",
                                    "Verificador online de MEF ou MATLAB"
                                  ],
                                  "tips": "Some todos elementos: deve igualar massa total m = ρ A L.",
                                  "learningObjective": "Ensamblar e validar a matriz de massa consistente.",
                                  "commonMistakes": [
                                    "Fator errado (usar /3 ao invés /6)",
                                    "Não verificar soma = m",
                                    "Assimetria"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma barra de alumínio com L=1 m, ρ=2700 kg/m³, A=0.01 m², m=ρAL=27 kg. [m_e] = 27/6 * [2 1; 1 2] = 4.5 * [2 1;1 2] = [[9 4.5]; [4.5 9]]. Verifique soma=27 kg.",
                              "finalVerifications": [
                                "Matriz é simétrica (m12 = m21).",
                                "Elementos diagonais iguais: ρ A L / 3 cada.",
                                "Elementos off-diagonal: ρ A L / 6.",
                                "Soma de todos elementos = ρ A L (massa total).",
                                "Matriz positiva definida (autovalores positivos).",
                                "Coincide com forma padrão (m/6)[2 1; 1 2].",
                                "Unidades consistentes: kg."
                              ],
                              "assessmentCriteria": [
                                "Correção das funções de forma N1 e N2.",
                                "Integração precisa dos termos quadráticos.",
                                "Fatorização correta de ρ A L.",
                                "Montagem simétrica da matriz 2x2.",
                                "Verificação de soma igual a massa total.",
                                "Interpretação física dos termos (massa nodal distribuída)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo integral e funções polinomiais.",
                                "Física: Princípios de dinâmica e conservação de massa.",
                                "Programação: Implementação em Python/MATLAB para MEF.",
                                "Engenharia: Análise modal em estruturas aeroespaciais.",
                                "Computação Numérica: Integração gaussiana para elementos superiores."
                              ],
                              "realWorldApplication": "Usado no Método dos Elementos Finitos para simular modos de vibração e resposta dinâmica de componentes aeroespaciais como fuselagens, asas ou painéis, prevendo ressonâncias em aeronaves para evitar fadiga estrutural."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.2.2",
                            "name": "Calcular matriz de massa lumped para viga",
                            "description": "Construir matriz diagonal [m_e] distribuindo massa nodal ρAL/2 e momentos de inércia ρI/L, simplificando para integração temporal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar parâmetros e graus de liberdade do elemento viga",
                                  "subSteps": [
                                    "Defina os parâmetros do elemento: densidade ρ, área da seção transversal A, comprimento L e momento de inércia I.",
                                    "Identifique os graus de liberdade (DOF): deslocamento transversal v e rotação θ em cada nó (total de 4 DOF para 2 nós).",
                                    "Esboce o elemento viga com nós 1 e 2, rotulando os DOF como v1, θ1, v2, θ2.",
                                    "Confirme que a matriz de massa lumped será diagonal 4x4.",
                                    "Anote unidades consistentes (ex: kg para massa, m para L)."
                                  ],
                                  "verification": "Lista de parâmetros anotada com DOF corretamente identificados e esboço do elemento completo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta ou software de desenho (ex: Draw.io)",
                                    "Referência de MEF para vigas (livro ou PDF)"
                                  ],
                                  "tips": "Sempre comece visualizando o elemento para evitar confusão nos DOF.",
                                  "learningObjective": "Compreender a configuração DOF de um elemento viga no MEF.",
                                  "commonMistakes": [
                                    "Confundir DOF de viga com barra (sem rotação)",
                                    "Esquecer momento de inércia I para rotação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular massas nodais translacionais",
                                  "subSteps": [
                                    "Calcule a massa total do elemento: m_total = ρ * A * L.",
                                    "Distribua igualmente para deslocamentos transversais: m_v1 = m_v2 = ρ * A * L / 2.",
                                    "Verifique que m_v1 + m_v2 = m_total.",
                                    "Registre os valores com unidades (ex: kg).",
                                    "Compare com massa consistente para entender simplificação lumped."
                                  ],
                                  "verification": "Valores de m_v1 e m_v2 calculados corretamente e soma igual a m_total.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Calculadora ou software (ex: MATLAB, Python)",
                                    "Valores exemplo: ρ=2700 kg/m³, A=0.01 m², L=1 m"
                                  ],
                                  "tips": "Use valores numéricos reais de alumínio aeroespacial para prática.",
                                  "learningObjective": "Dominar distribuição lumped de massa translacional em vigas.",
                                  "commonMistakes": [
                                    "Dividir por número errado de nós",
                                    "Usar A em vez de I para translação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular massas nodais rotacionais",
                                  "subSteps": [
                                    "Calcule o 'momento de massa rotacional' por nó: m_θ1 = m_θ2 = ρ * I / L.",
                                    "Note que isso aproxima o efeito rotacional da distribuição de massa.",
                                    "Verifique dimensionalmente: [ρ I / L] tem unidades de kg*m² / rad² (massa rotacional).",
                                    "Some contribuições rotacionais se aplicável, mas lumped é diagonal.",
                                    "Compare com formulação consistente para validar simplificação."
                                  ],
                                  "verification": "Valores de m_θ1 e m_θ2 corretos e unidades consistentes.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Mesmos da Step 2",
                                    "Tabela de propriedades de seções (ex: I para viga em I)"
                                  ],
                                  "tips": "I é o momento de inércia polar ou segundo área para flexão transversal.",
                                  "learningObjective": "Calcular precisamente massas rotacionais lumped para vigas.",
                                  "commonMistakes": [
                                    "Usar I errado (ex: polar em vez de área)",
                                    "Esquecer divisão por L"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar e validar a matriz de massa lumped [m_e]",
                                  "subSteps": [
                                    "Crie matriz diagonal 4x4: diag(m_v1, m_θ1, m_v2, m_θ2).",
                                    "Escreva explicitamente: [m_e] = diag(ρAL/2, ρI/L, ρAL/2, ρI/L).",
                                    "Verifique propriedades: traço = m_total + 2*(ρI/L), simétrica e diagonal.",
                                    "Teste com exemplo numérico e confira soma de massas.",
                                    "Discuta vantagem para integração temporal (diagonal facilita inversão)."
                                  ],
                                  "verification": "Matriz [m_e] montada corretamente, diagonal e propriedades validadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Software de matriz (ex: MATLAB 'diag()', Python NumPy)",
                                    "Exemplo numérico completo"
                                  ],
                                  "tips": "Implemente em código para automação futura.",
                                  "learningObjective": "Construir e validar matriz de massa lumped completa.",
                                  "commonMistakes": [
                                    "Ordem errada de DOF na diagonal",
                                    "Não verificar soma de massas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma viga de alumínio aeroespacial: ρ=2700 kg/m³, A=0.01 m², L=1 m, I=8.33e-6 m⁴. Então m_v1=m_v2=13.5 kg, m_θ1=m_θ2=0.0225 kg·m². [m_e] = diag(13.5, 0.0225, 13.5, 0.0225). Use em código: import numpy as np; m_e = np.diag([13.5, 0.0225, 13.5, 0.0225]).",
                              "finalVerifications": [
                                "Matriz é diagonal 4x4 com entradas corretas ρAL/2 e ρI/L.",
                                "Soma das massas translacionais = ρ A L.",
                                "Unidades consistentes em todos termos.",
                                "Ordem DOF: v1, θ1, v2, θ2 respeitada.",
                                "Propriedades simétricas e positivas definidas confirmadas.",
                                "Comparação numérica com massa consistente mostra simplificação válida."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de massas nodais (erro <1%).",
                                "Correta identificação e ordenação de DOF.",
                                "Validação completa de propriedades da matriz.",
                                "Exemplo prático implementado e verificado.",
                                "Explicação clara da simplificação lumped vs. consistente.",
                                "Uso correto de unidades e dimensionalidade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Operações com matrizes diagonais e propriedades espectrais.",
                                "Física: Conservação de massa e momentos de inércia em dinâmica.",
                                "Programação: Implementação em NumPy/MATLAB para MEF.",
                                "Engenharia Aeroespacial: Modelagem de vibrações em asas e fuselagens.",
                                "Cálculo Numérico: Integração temporal explícita beneficiada por lumped."
                              ],
                              "realWorldApplication": "Em análise dinâmica de estruturas aeroespaciais, como simulação de flutter em asas de aeronaves via MEF, onde matrizes lumped aceleram solvers de tempo real em softwares como NASTRAN ou Abaqus, reduzindo custo computacional em otimização de design."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.1.3",
                              "10.1.4.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.2.3",
                            "name": "Comparar massas consistente vs. lumped",
                            "description": "Analisar impactos na precisão de frequências naturais e modos, com exemplos numéricos para elementos aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Massas Consistente e Lumped",
                                  "subSteps": [
                                    "Defina matriz de massa consistente: integral da função de forma transposta vezes densidade vezes função de forma sobre o volume do elemento.",
                                    "Defina matriz de massa lumped: massa total do elemento distribuída diagonalmente nos nós, tipicamente massa/ número de nós por grau de liberdade.",
                                    "Compare propriedades: consistente é não-diagonal e captura distribuição inercial exata; lumped é diagonal, simplificada para iterações rápidas.",
                                    "Discuta origens: consistente de formulação fraca do MEF; lumped de aproximações nodais.",
                                    "Revise funções de forma lineares para barra 2D como exemplo base."
                                  ],
                                  "verification": "Escreva definições precisas e compare em uma tabela as propriedades chave de ambas as matrizes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de MEF (ex: Bathe ou Zienkiewicz), notas de aula sobre formulação elementar, calculadora simbólica (SymPy ou MATLAB).",
                                  "tips": "Use analogia: consistente como 'massa distribuída ao longo de uma corda vibrante'; lumped como 'massa concentrada nos nós'.",
                                  "learningObjective": "Diferenciar conceitualmente massas consistente e lumped, identificando vantagens e limitações iniciais.",
                                  "commonMistakes": "Confundir consistente com rígida (rigidez é sempre consistente); ignorar que lumped pode superestimar frequências baixas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular Matrizes de Massa para um Elemento de Viga Flexural",
                                  "subSteps": [
                                    "Selecione elemento de viga Euler-Bernoulli 2 nós com 2 graus de liberdade por nó (translação e rotação).",
                                    "Derive matriz de massa consistente: ∫ N^T ρ A N dx, onde N são funções de forma hermitianas.",
                                    "Calcule numericamente para comprimento L=1m, ρA=1 kg/m: resulta em [m11= m/420 *156, etc.] (valores padrão).",
                                    "Formule matriz lumped: diagonal com m/2 nos nós translacionais, momentos de inércia lumped nos rotacionais.",
                                    "Implemente em código simples para automação (Python com NumPy)."
                                  ],
                                  "verification": "Gere matrizes 4x4 para ambas e confirme simetria e traço igual (massa total preservada).",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software MEF básico (ou código próprio), tabela de funções de forma para vigas, papel e lápis para derivação manual.",
                                  "tips": "Memorize traço das matrizes: sempre igual à massa total do elemento para ambas.",
                                  "learningObjective": "Derivar e computar matrizes de massa elementares, preparando para montagem global.",
                                  "commonMistakes": "Esquecer fatores de integração exatos (ex: 1/420 para viga); não normalizar funções de forma."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar Análise Modal com Ambas as Matrizes de Massa",
                                  "subSteps": [
                                    "Monte estrutura simples: viga cantilever com 4 elementos, condições de contorno fixas na raiz.",
                                    "Monte matrizes globais de massa (M) e rigidez (K) consistentes.",
                                    "Resolva problema de autovalores generalizado: K φ = ω² M φ para frequências naturais ω e modos φ.",
                                    "Repita com M lumped (diagonalizar para eficiência).",
                                    "Extraia 3 primeiras frequências e compare percentuais de diferença."
                                  ],
                                  "verification": "Calcule frequências para ambos; consistente deve dar valores ~5-20% menores que lumped para modos baixos.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "MATLAB/Python (scipy.linalg.eig), modelo MEF pré-montado, planilha para resultados.",
                                  "tips": "Use solvers eficientes para M diagonal (lumped permite inversão trivial).",
                                  "learningObjective": "Executar análise modal comparativa, observando discrepâncias quantitativas.",
                                  "commonMistakes": "Não aplicar condições de contorno corretamente (reduzir M e K); confundir frequências com períodos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Impactos na Precisão para Elementos Aeroespaciais",
                                  "subSteps": [
                                    "Aplique a uma asa simplificada: viga com seção aeroespacial (L=5m, perfis NACA).",
                                    "Compare frequências com solução analítica exata (ex: viga Euler exata).",
                                    "Quantifique erros: % diferença em ω1, ω2; observe lumped superestima modos flexurais.",
                                    "Discuta implicações: erro em flutter (ω estrutural vs aerodinâmica), fadiga vibracional.",
                                    "Recomende uso: consistente para precisão alta; lumped para análises preliminares rápidas."
                                  ],
                                  "verification": "Gere gráfico de frequências vs número de elementos; explique convergência diferencial.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Dados de perfis aeroespaciais (AirfoilTools), software ANSYS/ABAQUS para validação opcional.",
                                  "tips": "Foquem em modos dominantes (1-3); ignore altos onde ambas convergem.",
                                  "learningObjective": "Interpretar impactos práticos na engenharia aeroespacial, com exemplos numéricos.",
                                  "commonMistakes": "Ignorar efeitos de malha fina (lumped melhora com refinamento); generalizar sem contexto estrutural."
                                }
                              ],
                              "practicalExample": "Em uma asa cantilever de UAV (L=2m, m=10kg), usando 10 elementos MEF: massa consistente dá ω1=15.2 rad/s (erro 2% vs analítico); lumped dá 17.8 rad/s (erro 12%), afetando previsão de flutter em 10% na velocidade crítica.",
                              "finalVerifications": [
                                "Calcular e comparar 3 frequências naturais com <5% erro para consistente vs solução referência.",
                                "Explicar verbalmente por que lumped superestima frequências baixas em estruturas esguias.",
                                "Gerar tabela numérica de matrizes elementares e globais para viga teste.",
                                "Plotar modos de vibração e destacar diferenças nodais.",
                                "Recomendar escolha de massa baseada em critério de precisão vs tempo computacional.",
                                "Validar com exemplo aeroespacial real (ex: painel de fuselagem)."
                              ],
                              "assessmentCriteria": [
                                "Precisão das derivações matriciais (100% traço preservado, simetria).",
                                "Correção quantitativa das frequências (diferença <10% identificada corretamente).",
                                "Profundidade da análise de impactos (quantificação % e implicações aeroelásticas).",
                                "Clareza em gráficos/tabelas comparativos.",
                                "Recomendações contextualizadas para aplicações aeroespaciais.",
                                "Identificação de 3+ erros comuns e mitigação."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Solução de problemas de autovalores generalizados (K - λM).",
                                "Programação Numérica: Implementação de MEF em Python/MATLAB para automação.",
                                "Física Aplicada: Teoria de vibrações contínuas e convergência de aproximações.",
                                "Engenharia Aeroespacial: Integração com aeroelasticidade (ex: V-g method para flutter)."
                              ],
                              "realWorldApplication": "Na certificação de aeronaves (FAA/EASA), massas consistentes são mandatórias para análise modal precisa de asas e fuselagens, evitando subestimação de frequências que poderia levar a instabilidades de flutter em voo; lumped usada em otimização inicial de design para reduzir tempo de simulação em 50%."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.2.1",
                              "10.1.4.3.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.3",
                        "name": "Matriz de Amortecimento de Rayleigh Elementar",
                        "description": "Formulação do amortecimento proporcional via modelo de Rayleigh [c_e] = α [m_e] + β [k_e], calibração de parâmetros α e β para simular dissipação em estruturas aeroespaciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.3.1",
                            "name": "Formular modelo de Rayleigh para elemento",
                            "description": "Construir [c_e] combinando massas e rigidez elementares, verificando ortogonalidade modal para múltiplos modos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Matrizes Elementares de Massa e Rigidez",
                                  "subSteps": [
                                    "Identifique o tipo de elemento (ex.: viga, barra ou placa) e suas funções de interpolação.",
                                    "Derive ou recupere a matriz de massa elementar [m_e] usando integração numérica ou formas fechadas.",
                                    "Derive ou recupere a matriz de rigidez elementar [k_e] a partir do potencial de deformação.",
                                    "Verifique simetria e propriedades positivas definidas de [m_e] e [k_e].",
                                    "Extraia os primeiros modos modais do elemento resolvendo o problema de autovalores generalizado."
                                  ],
                                  "verification": "Matrizes [m_e] e [k_e] são simétricas e os autovalores modais estão corretamente ordenados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de texto sobre MEF (ex.: Bathe 'Finite Element Procedures')",
                                    "Software MATLAB ou Python com NumPy/SciPy",
                                    "Folha de cálculo para derivações manuais"
                                  ],
                                  "tips": "Use formas consistentes de massa para precisão em frequências altas; armazene modos modais em uma matriz Φ.",
                                  "learningObjective": "Compreender a construção fundamental de [m_e] e [k_e] para um elemento específico.",
                                  "commonMistakes": [
                                    "Ignorar termos de rotação em elementos de viga",
                                    "Usar massa inconsistente (lumped vs. consistent)",
                                    "Não normalizar vetores modais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Coeficientes de Amortecimento Rayleigh α e β",
                                  "subSteps": [
                                    "Escolha critérios para α e β: razões de amortecimento modal ξ_i para dois modos alvo.",
                                    "Calcule α e β resolvendo o sistema: ξ_1 = (α / (2 ω_1)) + (β ω_1 / 2), ξ_2 = (α / (2 ω_2)) + (β ω_2 / 2).",
                                    "Resolva o sistema linear 2x2 para α e β usando frequências modais ω_1 e ω_2.",
                                    "Verifique que ξ_i são razoáveis (tipicamente 0.01-0.05 para estruturas aeroespaciais).",
                                    "Teste sensibilidade variando modos alvo."
                                  ],
                                  "verification": "α e β produzem ξ_i dentro de ±5% dos valores desejados para os modos selecionados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha Excel ou MATLAB script para solver linear",
                                    "Dados modais do Step 1"
                                  ],
                                  "tips": "Selecione modos adjacentes para cobertura espectral ampla; use mínimos quadrados para mais de 2 modos.",
                                  "learningObjective": "Selecionar e calcular coeficientes Rayleigh para matching de amortecimento modal.",
                                  "commonMistakes": [
                                    "Escolher modos muito próximos em frequência",
                                    "Confundir α (damping massa-proporcional) com β",
                                    "Usar frequências erradas (rad/s vs. Hz)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir Matriz de Amortecimento Elementar [c_e]",
                                  "subSteps": [
                                    "Formule [c_e] = α [m_e] + β [k_e] usando multiplicação escalar-matriz.",
                                    "Implemente computacionalmente em software, garantindo simetria.",
                                    "Verifique dimensionalidade: [c_e] deve ter mesmo tamanho que [m_e] e [k_e].",
                                    "Calcule autovalores de [c_e] para confirmar propriedades positivas semi-definidas.",
                                    "Compare com amortecimento modal diagonalizado."
                                  ],
                                  "verification": "[c_e] é simétrica e Φ^T [c_e] Φ é diagonal com entradas 2 ξ_i ω_i.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB/Python para operações matriciais",
                                    "Matrizes do Step 1 e coeficientes do Step 2"
                                  ],
                                  "tips": "Use funções built-in como sparse() para eficiência em elementos grandes.",
                                  "learningObjective": "Montar [c_e] combinando contribuições proporcionais de massa e rigidez.",
                                  "commonMistakes": [
                                    "Erro de escala em α/β",
                                    "Não preservar simetria numérica",
                                    "Ignorar unidades consistentes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar Ortogonalidade Modal para Múltiplos Modos",
                                  "subSteps": [
                                    "Compute matrizes de ortogonalidade: Φ^T [m_e] Φ, Φ^T [k_e] Φ, Φ^T [c_e] Φ.",
                                    "Confirme diagonalidade: off-diagonais < 1e-10 (tolerância numérica).",
                                    "Teste para 3-5 modos iniciais; verifique normalização Φ^T [m_e] Φ = I.",
                                    "Analise impacto de α/β na ortogonalidade de [c_e].",
                                    "Documente desvios e ajuste modos se necessário."
                                  ],
                                  "verification": "Todas matrizes modais são diagonais dentro de tolerância numérica para modos selecionados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Script de verificação em MATLAB (eig, dot products)",
                                    "Matrizes finais do Step 3"
                                  ],
                                  "tips": "Use modos mass-normalizados; monitore condição numérica de Φ.",
                                  "learningObjective": "Validar que o modelo Rayleigh preserva ortogonalidade modal.",
                                  "commonMistakes": [
                                    "Usar modos não ortogonais iniciais",
                                    "Tolerância inadequada para off-diagonais",
                                    "Testar apenas 1 modo"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um elemento de viga Euler-Bernoulli com 2 nós e 4 gdl (2 translações, 2 rotações), usando massa consistente [m_e] 4x4 e [k_e] 4x4, defina ξ1=0.02 em 10 Hz e ξ2=0.03 em 50 Hz. Calcule α≈0.12, β≈1.2e-4, construa [c_e], e verifique ortogonalidade para os 3 primeiros modos.",
                              "finalVerifications": [
                                "[c_e] é simétrica e positiva semi-definida.",
                                "Razões de amortecimento ξ_i coincidem com alvos para modos selecionados.",
                                "Ortogonalidade mantida: off-diagonais em Φ^T [c_e] Φ < 1e-10.",
                                "Autovalores de [m_e], [k_e], [c_e] positivos.",
                                "Dimensionalmente consistente com DOFs do elemento.",
                                "Sensibilidade baixa a pequenas variações em α/β."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de [m_e] e [k_e] (erro <1%).",
                                "Correção no cálculo de α/β (ξ erro <5%).",
                                "Implementação numérica sem erros de arredondamento.",
                                "Verificação completa de ortogonalidade para ≥3 modos.",
                                "Documentação clara de passos e resultados.",
                                "Eficiência computacional demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Problemas de autovalores generalizados e decomposição modal.",
                                "Física: Princípios de amortecimento viscoso e vibrações livres.",
                                "Programação: Manipulação matricial em Python/MATLAB para MEF.",
                                "Engenharia Mecânica: Modelagem dinâmica de estruturas.",
                                "Controle de Sistemas: Análise de estabilidade em laços fechados."
                              ],
                              "realWorldApplication": "Em análises de aeroelasticidade, como previsão de flutter em asas de aeronaves, onde [c_e] Rayleigh é usado em simulações MEF para capturar dissipação energética em painéis sob cargas dinâmicas, permitindo otimização de design para evitar ressonâncias críticas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.2",
                              "10.1.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.3.2",
                            "name": "Calibrar α e β via frequências e fatores de amortecimento",
                            "description": "Resolver sistema 2x2 para ajustar α e β dado ξ1, ξ2 e ω1, ω2 de modos dominantes em vibrações aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Matriz de Amortecimento de Rayleigh e Formular o Sistema de Equações",
                                  "subSteps": [
                                    "Estude a forma da matriz de amortecimento C = α M + β K, onde M é a matriz de massa e K de rigidez.",
                                    "Lembre que para o i-ésimo modo, o fator de amortecimento ξ_i satisfaz: ξ_i = (α / (2 ω_i)) + (β ω_i / 2), com ω_i frequência natural.",
                                    "Selecione dois modos dominantes (ex: primeiro e segundo modos de flexão) para calibração.",
                                    "Escreva o sistema 2x2: [1/(2ω1)  ω1/2; 1/(2ω2)  ω2/2] [α; β] = [ξ1; ξ2].",
                                    "Verifique unidades: α em rad/s, β em s/rad."
                                  ],
                                  "verification": "Sistema de equações escrito corretamente em formato matricial ou escalar.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de dinâmica estrutural (ex: Clough & Penzien), notas de aula sobre MEF, calculadora simbólica (ex: SymPy ou MATLAB).",
                                  "tips": "Sempre normalize frequências em rad/s, não Hz.",
                                  "learningObjective": "Compreender a origem física e matemática da calibração de Rayleigh.",
                                  "commonMistakes": "Confundir ω em Hz com rad/s; inverter coeficientes α e β nas equações."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Coletar e Preparar Dados de Frequências e Fatores de Amortecimento",
                                  "subSteps": [
                                    "Identifique modos dominantes de uma estrutura aeroespacial (ex: viga cantilever simulando asa).",
                                    "Obtenha ω1, ξ1 do primeiro modo e ω2, ξ2 do segundo via análise modal ou testes experimentais.",
                                    "Exemplo hipotético: ω1 = 10 rad/s, ξ1 = 0.02; ω2 = 50 rad/s, ξ2 = 0.05.",
                                    "Garanta que modos sejam bem separados (ω2 >> ω1) para boa condicionamento da matriz.",
                                    "Crie tabela com valores e calcule coeficientes da matriz A explicitamente."
                                  ],
                                  "verification": "Tabela de dados completa com coeficientes da matriz A calculados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Resultados de análise modal (software como NASTRAN ou ANSYS), planilha Excel ou Python para tabulação.",
                                  "tips": "Use modos com contribuição modal significativa (>5% massa modal).",
                                  "learningObjective": "Selecionar dados relevantes para calibração precisa.",
                                  "commonMistakes": "Usar fatores de amortecimento em % ao invés de fração decimal; ignorar separação de frequências."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver o Sistema Linear 2x2 para α e β",
                                  "subSteps": [
                                    "Monte a matriz A = [[1/(2ω1), ω1/2], [1/(2ω2), ω2/2]] e vetor b = [ξ1, ξ2].",
                                    "Calcule determinante det(A) = (ω2/2)/(2ω1) - (ω1/2)/(2ω2) para verificar não-singularidade.",
                                    "Use fórmula inversa ou eliminação gaussiana: α = (ξ1 ω2 - ξ2 ω1)/(ω2 - ω1), β aproximado similarmente.",
                                    "Implemente numericamente e resolva x = A^{-1} b.",
                                    "Arredonde α e β com precisão adequada (ex: 4 casas decimais)."
                                  ],
                                  "verification": "Valores de α e β obtidos e matriz A x = b satisfeita com erro < 1e-6.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora matricial, MATLAB/Python (numpy.linalg.solve), papel e lápis para mão.",
                                  "tips": "Para automação, escreva script: A = np.array([[1/(2*w1), w1/2], [1/(2*w2), w2/2]]); sol = np.linalg.solve(A, xi).",
                                  "learningObjective": "Resolver sistemas lineares aplicados à engenharia.",
                                  "commonMistakes": "Erro de sinal nos coeficientes; divisão por zero se ω1 ≈ ω2."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Calibração e Interpretar Resultados",
                                  "subSteps": [
                                    "Substitua α, β de volta nas equações para ξ1 e ξ2 e compare com valores originais (erro <1%).",
                                    "Verifique se α >0, β >0 e ξ interpolados razoáveis entre ω1 e ω2.",
                                    "Analise sensibilidade: varie ξ em ±10% e observe impacto em α/β.",
                                    "Discuta limitações: Rayleigh assume amortecimento modal proporcional, inválido para regimes altos.",
                                    "Documente relatório com equações, valores e gráficos de ξ vs ω."
                                  ],
                                  "verification": "Erro de reprodução <1% e relatório com interpretação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software de plotagem (Matplotlib), template de relatório.",
                                  "tips": "Plote curvas ξ(ω) para visualizar ajuste.",
                                  "learningObjective": "Avaliar validade da calibração em contextos reais.",
                                  "commonMistakes": "Ignorar sinal negativo em α/β; não checar condicionamento da matriz."
                                }
                              ],
                              "practicalExample": "Para uma asa simplificada: modo 1 (flexão raiz): ω1=15.7 rad/s, ξ1=0.015; modo 2 (torção): ω2=62.8 rad/s, ξ2=0.035. Resolva: α ≈ 0.32 rad/s, β ≈ 0.00042 s/rad. Verifique: ξ_calc1=0.015, ξ_calc2=0.035.",
                              "finalVerifications": [
                                "Sistema 2x2 resolvido com erro residual <0.1%.",
                                "α e β positivos e fisicamente coerentes.",
                                "Curva ξ(ω) matches dados nos modos selecionados.",
                                "Sensibilidade testada com variação ±5% nos inputs.",
                                "Limitações documentadas (ex: não captura amortecimento não-proporcional)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação das equações (100% correto).",
                                "Correta resolução numérica (erro <1e-4).",
                                "Interpretação física adequada de α e β.",
                                "Validação completa com gráficos e sensibilidade.",
                                "Relatório claro e estruturado."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Resolução de sistemas e condicionamento de matrizes.",
                                "Matemática Numérica: Métodos de eliminação e estabilidade.",
                                "Engenharia Mecânica: Análise modal em vibrações.",
                                "Programação: Implementação em Python/MATLAB para MEF."
                              ],
                              "realWorldApplication": "Calibração usada em simulações de flutter em aeronaves (ex: Boeing 787), onde α e β ajustam modelo dinâmico para testes de solo/vôo, previnindo ressonâncias catastróficas em estruturas compostas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.3.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.4",
                        "name": "Montagem das Matrizes Globais no MEF",
                        "description": "Processo de superposição e aplicação de condições de contorno para obter as matrizes globais [M], [K] e [C] a partir das elementares, preparando para equação [M]{¨u} + [C]{˙u} + [K]{u} = {F}.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.4.1",
                            "name": "Executar montagem por conectividade nodal",
                            "description": "Mapear graus de liberdade locais para globais usando tabela de conectividade, somando contribuições elementares em [M_g], [K_g], [C_g].",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a tabela de conectividade e identificar graus de liberdade",
                                  "subSteps": [
                                    "Liste todos os nós da malha e seus graus de liberdade (DOFs) globais (ex: translações u_x, u_y, rotações θ_z).",
                                    "Para cada elemento, identifique os nós conectados e os DOFs locais correspondentes (ex: nó 1: DOFs 1-3, nó 2: DOFs 4-6).",
                                    "Crie uma tabela de conectividade nodal mapeando DOFs locais de cada elemento para índices globais.",
                                    "Defina o tamanho das matrizes globais baseado no total de DOFs (ex: n_DOFs x n_DOFs).",
                                    "Anote propriedades elementares: matrizes locais [m_e], [k_e], [c_e] já computadas."
                                  ],
                                  "verification": "Tabela de conectividade completa sem duplicatas ou faltas, com mapeamento unívoco de DOFs locais para globais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel quadriculado, software de MEF como MATLAB ou Python (NumPy), malha de exemplo simples (treliça 1D/2D).",
                                  "tips": "Comece com uma malha pequena (3-5 nós) para visualizar o mapeamento.",
                                  "learningObjective": "Compreender a relação entre malha nodal, conectividade e DOFs locais/globais.",
                                  "commonMistakes": "Confundir DOFs locais de elementos adjacentes; ignorar DOFs de rotação em elementos 2D."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear DOFs locais para globais e inicializar matrizes globais",
                                  "subSteps": [
                                    "Inicialize matrizes globais zeradas: [M_g] = zeros(n_DOFs), [K_g] = zeros(n_DOFs), [C_g] = zeros(n_DOFs).",
                                    "Para cada elemento e, leia sua tabela de conectividade (ex: DOF_local_1 → global_i, DOF_local_2 → global_j).",
                                    "Crie vetores de índices globais para linhas e colunas baseados no mapeamento.",
                                    "Extraia submatrizes elementares correspondentes aos DOFs mapeados.",
                                    "Prepare loop de montagem: para cada par (i_global, j_global), acumule contribuições."
                                  ],
                                  "verification": "Matrizes globais inicializadas corretamente e mapeamento testado em um elemento isolado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Planilha Excel ou script Python/MATLAB para inicialização e mapeamento.",
                                  "tips": "Use índices 1-based em MATLAB ou 0-based em Python; teste com print da tabela para um elemento.",
                                  "learningObjective": "Dominar o mapeamento explícito de índices locais para globais.",
                                  "commonMistakes": "Índices off-by-one (ex: MATLAB 1-based vs Python 0-based); não zerar matrizes adequadamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a soma das contribuições elementares nas matrizes globais",
                                  "subSteps": [
                                    "Para cada elemento e, loop sobre DOFs locais i_loc e j_loc.",
                                    "Calcule índices globais: i_g = conectividade(e, i_loc), j_g = conectividade(e, j_loc).",
                                    "Some: M_g(i_g, j_g) += m_e(i_loc, j_loc); similar para K_g e C_g.",
                                    "Garanta simetria adicionando também j_g, i_g se não simétrico por algoritmo.",
                                    "Repita para todos elementos, atualizando matrizes globais acumulativamente."
                                  ],
                                  "verification": "Matrizes globais preenchidas com valores não-nulos nos DOFs conectados; verifique soma de uma entrada específica.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código implementado em Python (NumPy) ou MATLAB; malha com 5-10 elementos.",
                                  "tips": "Implemente em loop duplo eficiente; use broadcasting em NumPy para aceleração.",
                                  "learningObjective": "Aplicar soma nodal para assemblar matrizes globais coerentes.",
                                  "commonMistakes": "Sobrescrever em vez de somar contribuições múltiplas; esquecer simetria em elementos não-simétricos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e validar as matrizes globais montadas",
                                  "subSteps": [
                                    "Confira simetria: M_g == M_g' (dentro de tolerância numérica).",
                                    "Verifique partição de energia: trace(K_g) ≈ soma trace(k_e) sobre elementos.",
                                    "Aplique condições de contorno zerando linhas/colunas de DOFs fixos.",
                                    "Compare com solução analítica para malha conhecida (ex: barra axial simples).",
                                    "Execute teste de rigidez: aplique força unitária e verifique deslocamentos esperados."
                                  ],
                                  "verification": "Matrizes simétricas, positivos-definidas (autovalores >0 para K_g), e coincidem com benchmark.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Funções de verificação em código (eig, trace, spy plot para visualização).",
                                  "tips": "Use spy() no MATLAB ou spy() em Matplotlib para visualizar esparsidade.",
                                  "learningObjective": "Garantir integridade numérica e física das matrizes globais.",
                                  "commonMistakes": "Não tratar condições de contorno; ignorar erros de acumulação numérica."
                                }
                              ],
                              "practicalExample": "Considere uma treliça 2D com 3 nós (1 fixo, 2 livres) e 2 elementos. Cada nó tem 2 DOFs (u_x, u_y). Tabela conectividade: elem1 [1,2], elem2 [2,3]. Matrizes locais: k1 = [[1,0,-1,0], ...]. Após montagem: K_g(4x4) com contribuições somadas em DOF4 (nó2_y) de ambos elementos.",
                              "finalVerifications": [
                                "Matrizes [M_g], [K_g], [C_g] são simétricas e esparsas conforme conectividade.",
                                "Soma das diagonais de [K_g] equals soma de todas k_e.",
                                "Aplicação de BCs resulta em matrizes reduzidas corretas.",
                                "Visualização spy mostra padrão de conectividade nodal.",
                                "Teste de convergência: refinar malha e comparar solução.",
                                "Autovalores de [K_g] todos positivos (semi-definida positiva)."
                              ],
                              "assessmentCriteria": [
                                "Precisão do mapeamento DOF local-global (100% correto).",
                                "Implementação correta da soma sem overflows ou erros de índice.",
                                "Verificações de simetria e propriedades físicas passadas.",
                                "Eficiência computacional (tempo <1s para 100 elementos).",
                                "Capacidade de debugar erros comuns em malha irregular.",
                                "Explicação clara do processo em relatório ou código comentado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Linear: Operações matriciais, esparsidade e solvers iterativos.",
                                "Programação: Loops eficientes, vetoresização em NumPy/MATLAB.",
                                "Física: Conservação de energia/momento na assemblagem.",
                                "Engenharia de Software: Modularidade em códigos MEF (classes para Elemento/Malha)."
                              ],
                              "realWorldApplication": "Em análise aeroelástica de asas de aeronaves, montagem nodal de [K_g] e [M_g] permite simular flutter via equações {M}ÿ + {C}ý + {K}u = {F}, previnindo falhas estruturais em voo supersônico."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.1",
                              "10.1.4.3.2",
                              "10.1.4.3.3"
                            ]
                          },
                          {
                            "id": "10.1.4.3.4.2",
                            "name": "Aplicar condições de contorno e particionamento",
                            "description": "Eliminar ou penalizar DOFs prescritos, reduzindo matrizes para análise dinâmica livre ou forçada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar DOFs prescritos e condições de contorno",
                                  "subSteps": [
                                    "Analisar o modelo estrutural e definir condições de contorno (ex: apoios fixos, deslocamentos impostos).",
                                    "Listar todos os graus de liberdade (DOFs) do modelo MEF global.",
                                    "Classificar DOFs em livres (f) e prescritos (p) com base nas condições.",
                                    "Documentar a correspondência entre nós/elementos e DOFs afetados.",
                                    "Verificar consistência com simetria ou simulações prévias."
                                  ],
                                  "verification": "Lista de DOFs prescritos completa e validada contra diagrama da estrutura.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Diagrama da estrutura, software MEF (MATLAB, ANSYS), planilha para listagem de DOFs.",
                                  "tips": "Numere DOFs sequencialmente para facilitar particionamento.",
                                  "learningObjective": "Compreender a relação entre condições físicas e DOFs matemáticos.",
                                  "commonMistakes": "Ignorar DOFs rotacionais em apoios fixos ou confundir com cargas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar eliminação de DOFs prescritos",
                                  "subSteps": [
                                    "Reorganizar matrizes globais [M], [K], [C] em blocos: ff, fp, pf, pp.",
                                    "Eliminar linhas e colunas correspondentes aos DOFs prescritos (p).",
                                    "Manter apenas submatrizes ff para DOFs livres.",
                                    "Ajustar vetor de forças {F} removendo componentes prescritas.",
                                    "Verificar propriedades: simetria, positiva definitividade."
                                  ],
                                  "verification": "Matrizes reduzidas têm dimensões n_f x n_f (onde n_f = DOFs livres) e são simétricas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Matrizes globais montadas, script MATLAB/Python para manipulação matricial.",
                                  "tips": "Use índices booleanos para seleção eficiente de linhas/colunas.",
                                  "learningObjective": "Dominar redução matricial por eliminação direta.",
                                  "commonMistakes": "Eliminar DOFs errados, quebrando simetria das matrizes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar método de penalização como alternativa",
                                  "subSteps": [
                                    "Calcular penalidade α = 10^12 * max(diag([K])) ou similar.",
                                    "Para DOFs prescritos u_p = 0, modificar [K_pp] += α[I], [M_pp] += α[I].",
                                    "Ajustar vetor de forças {F_p} = α * {u_p prescrito}.",
                                    "Resolver sistema completo sem redução física.",
                                    "Comparar resultados com eliminação para validação."
                                  ],
                                  "verification": "Soluções de deslocamentos coincidem (erro < 1e-6) entre métodos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Matrizes originais, calculadora para α, solver numérico.",
                                  "tips": "Escolha α grande mas não excessiva para evitar ill-conditioning.",
                                  "learningObjective": "Entender penalização como método iterativo/condensado.",
                                  "commonMistakes": "α muito pequena (não impõe restrição) ou muito grande (numérica instável)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Particionar matrizes reduzidas para análise dinâmica",
                                  "subSteps": [
                                    "Particionar DOFs livres em primários (estruturais) e secundários (modais).",
                                    "Formar equações reduzidas: [M_ff]{ü_f} + [C_ff]{ú_f} + [K_ff]{u_f} = {F_f}(t).",
                                    "Preparar para análise livre (autovalores) ou forçada (integração temporal).",
                                    "Implementar em código para solver dinâmico.",
                                    "Testar com excitação unitária."
                                  ],
                                  "verification": "Equações dinâmicas resolvem frequências modais corretas vs. analítico.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Código MEF pronto, solver eigensystem (eig em MATLAB).",
                                  "tips": "Use ordenação AMD para condicionamento em grandes matrizes.",
                                  "learningObjective": "Preparar matrizes para simulações dinâmicas livres/forçadas.",
                                  "commonMistakes": "Particionamento inconsistente levando a modos espúrios."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e preparar para análise dinâmica completa",
                                  "subSteps": [
                                    "Comparar massas/rigidez reduzidas com valores esperados.",
                                    "Executar análise modal livre e verificar frequências/modais.",
                                    "Simular resposta forçada e checar estabilidade.",
                                    "Documentar processo e matrizes finais.",
                                    "Analisar sensibilidade a condições de contorno."
                                  ],
                                  "verification": "Frequências modais erro < 5% vs. solução referência.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Referência analítica (ex: viga Euler-Bernoulli), plotter de modos.",
                                  "tips": "Visualize modos deformados para intuição física.",
                                  "learningObjective": "Garantir robustez da redução para aplicações dinâmicas.",
                                  "commonMistakes": "Não validar, assumindo redução correta."
                                }
                              ],
                              "practicalExample": "Em uma viga cantilever modelada com 10 elementos MEF (60 DOFs), fixe a raiz (6 DOFs prescritos u=0). Elimine/penalize esses DOFs, reduza matrizes para 54x54, particione e calcule 5 primeiros modos para análise de vibração em asa de drone.",
                              "finalVerifications": [
                                "Dimensões das matrizes reduzidas corretas (n_f x n_f).",
                                "Simetria e positiva definitividade preservadas.",
                                "Frequências modais coincidem com solução analítica (erro < 2%).",
                                "Resposta forçada converge sem oscilações numéricas.",
                                "Modos deformados fisicamente consistentes.",
                                "Comparação eliminação vs. penalização idêntica."
                              ],
                              "assessmentCriteria": [
                                "Identificação precisa de DOFs prescritos (20%).",
                                "Correta eliminação/particionamento matricial (25%).",
                                "Implementação válida de penalização (20%).",
                                "Equações dinâmicas reduzidas corretas (20%).",
                                "Validação com resultados quantitativos (15%)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Particionamento e redução de matrizes esparsas.",
                                "Programação Numérica: Manipulação matricial em Python/MATLAB.",
                                "Física Aplicada: Dinâmica de vibrações e equações de Lagrange.",
                                "Engenharia Computacional: Pré-processamento em solvers MEF.",
                                "Controle de Sistemas: Preparação para análise modal em aeroelasticidade."
                              ],
                              "realWorldApplication": "No design de asas de aeronaves, aplica condições de contorno na raiz da asa para análise de flutter e resposta a turbulência, garantindo segurança contra instabilidades dinâmicas durante certificação FAA/EASA."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.4.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.4.3",
                            "name": "Verificar simetria e propriedades das matrizes montadas",
                            "description": "Confirmar simetria positiva definida de [K_g] e [M_g], e proporcionalidade de [C_g] para decomposição modal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Verificar simetria das matrizes globais [M_g], [K_g] e [C_g]",
                                  "subSteps": [
                                    "Carregue as matrizes globais montadas no software de análise (ex: MATLAB ou Python com NumPy).",
                                    "Compute a transposta de cada matriz usando A^T = transpose(A).",
                                    "Calcule a diferença absoluta entre A e A^T elemento a elemento: diff = abs(A - A^T).",
                                    "Verifique se o máximo da diferença é menor que um tolerância numérica (ex: 1e-12).",
                                    "Registre o resultado para cada matriz em um relatório."
                                  ],
                                  "verification": "A matriz é simétrica se max(abs(A - A^T)) < 1e-12 para todos os elementos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software MATLAB/Python (NumPy/SciPy), matrizes globais [M_g], [K_g], [C_g] em formato .mat ou .csv",
                                  "tips": "Use funções built-in como issymmetric() no MATLAB para agilizar.",
                                  "learningObjective": "Entender e aplicar o conceito de simetria matricial na prática computacional.",
                                  "commonMistakes": "Ignorar erros de arredondamento numérico; sempre definir tolerância explícita."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Confirmar que [M_g] e [K_g] são positivas definidas",
                                  "subSteps": [
                                    "Compute os autovalores de [M_g] e [K_g] usando eig() ou eigh() para matrizes simétricas.",
                                    "Verifique se todos os autovalores são positivos (mínimo > 0).",
                                    "Alternativamente, tente fatoração Cholesky: se bem-sucedida sem NaN ou Inf, é positiva definida.",
                                    "Calcule o menor autovalor e condicione o número da matriz para qualidade.",
                                    "Documente os autovalores mínimos e o tempo de computação."
                                  ],
                                  "verification": "Todos autovalores > 0 e fatoração Cholesky converge sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software MATLAB/Python (SciPy para eigh), matrizes [M_g] e [K_g]",
                                  "tips": "Para matrizes grandes, use decomposição LDL para eficiência.",
                                  "learningObjective": "Aplicar testes numéricos para propriedades espectrais de matrizes.",
                                  "commonMistakes": "Confundir positiva definida com semi-definida; verificar estritamente >0."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar proporcionalidade de [C_g] via amortecimento de Rayleigh",
                                  "subSteps": [
                                    "Assuma forma C_g ≈ α M_g + β K_g e defina equações baseadas em modos dominantes.",
                                    "Selecione dois modos (ex: 1º e 10º) com frequências ω1 e ω2, e fatores de amortecimento ζ1, ζ2.",
                                    "Resolva sistema linear: α + β ω1² = 2 ζ1 ω1; α + β ω2² = 2 ζ2 ω2.",
                                    "Reconstrua C_approx = α M_g + β K_g e compute norma da diferença ||C_g - C_approx|| / ||C_g|| < tolerância.",
                                    "Plote espectro de amortecimento para validar."
                                  ],
                                  "verification": "Erro de reconstrução < 5% e ξ interpolado razoável entre modos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Software MATLAB/Python, autovalores/vetores de M_g e K_g, [C_g]",
                                  "tips": "Escolha modos com boa separação de frequências para α e β estáveis.",
                                  "learningObjective": "Modelar amortecimento proporcional para análise modal.",
                                  "commonMistakes": "Selecionar modos próximos causando singularidade no sistema."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar propriedades para decomposição modal",
                                  "subSteps": [
                                    "Execute decomposição modal generalizada: resolver (K - λ M) φ = 0.",
                                    "Confirme ortogonalidade: φ_i^T M φ_j = δ_ij, φ_i^T K φ_j = λ_j δ_ij.",
                                    "Verifique se matriz modal diagonaliza o sistema.",
                                    "Simule resposta livre breve para checar estabilidade.",
                                    "Gere relatório final com métricas de qualidade."
                                  ],
                                  "verification": "Autovalores reais positivos, autovetores ortonormais em M e K métricas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software com solver eigensystem (MATLAB eigs(), SciPy), matrizes verificadas",
                                  "tips": "Use solvers para matrizes esparsas se aplicável (ex: eigs com shift-invert).",
                                  "learningObjective": "Integrar verificações para habilitar análise modal confiável.",
                                  "commonMistakes": "Prosseguir sem simetria, levando a autovalores complexos espúrios."
                                }
                              ],
                              "practicalExample": "Para uma treliça 2D com 2 elementos e 3 nós, monte M_g (4x4), K_g (4x4), C_g = 0.1 M_g + 0.01 K_g. Verifique simetria (exata), positiva definida (autovalores M_g: [0.5,1.2,2.0,3.1]), proporcionalidade (erro 0%), e decomposição modal (4 modos reais).",
                              "finalVerifications": [
                                "Simetria confirmada para todas matrizes com tol < 1e-12.",
                                "Autovalores mínimos de M_g e K_g > 1e-6.",
                                "Erro de Rayleigh damping < 5% em norma Frobenius.",
                                "Decomposição modal produz autovalores reais positivos e ortonormalidade.",
                                "Relatório gerado com plots de autovalores e condições.",
                                "Simulação de resposta modal livre estável."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nas verificações (tol adequada).",
                                "Correta interpretação de resultados (ex: positiva definida).",
                                "Eficiência computacional (uso de solvers apropriados).",
                                "Documentação clara com evidências (prints/plots).",
                                "Identificação e discussão de potenciais issues numéricos.",
                                "Aplicação correta de Rayleigh para C_g."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Autovalores, simetria, decomposições.",
                                "Programação Numérica: Manipulação de matrizes em Python/MATLAB.",
                                "Física/Engenharia: Dinâmica de sistemas multi-graus de liberdade.",
                                "Análise Numérica: Condicionamento e estabilidade.",
                                "Otimização: Problemas de autovalores generalizados."
                              ],
                              "realWorldApplication": "Em simulações aeroelásticas de asas de aeronaves via MEF, verifica-se essas propriedades para análise modal precisa, previnindo flutter e garantindo estabilidade dinâmica em projetos da NASA/Embraer."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.4.1",
                              "10.1.4.3.4.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.4",
                    "name": "Análise Modal via Método dos Elementos Finitos",
                    "description": "Cálculo de frequências naturais, modos de vibração e solução modal em estruturas discretizadas pelo MEF.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.4.1",
                        "name": "Formulação das Equações de Movimento no MEF",
                        "description": "Derivação das equações dinâmicas discretizadas pelo Método dos Elementos Finitos para estruturas aeroespaciais, incluindo matrizes de massa [M], rigidez [K] e amortecimento [C], resultando na equação geral [M]{ü} + [C]{u} + [K]{u} = {F(t)}.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.1.1",
                            "name": "Montagem das Matrizes de Massa e Rigidez no MEF",
                            "description": "Construir as matrizes global de massa [M] e rigidez [K] a partir dos elementos finitos, considerando elementos de viga, placa ou casca típicos em estruturas aeroespaciais, e aplicar condições de contorno.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Derivação das Matrizes Elementares de Rigidez [K_e] e Massa [M_e]",
                                  "subSteps": [
                                    "Revise as funções de forma (shape functions) para o elemento escolhido (viga, placa ou casca).",
                                    "Calcule a matriz de rigidez elementar [K_e] usando a integral ∫ B^T D B dV.",
                                    "Derive a matriz de massa elementar [M_e] com ∫ N^T ρ N dV, considerando massa consistente ou concentrada.",
                                    "Verifique simetria e propriedades positivas definidas das matrizes.",
                                    "Implemente numericamente via Gauss-Legendre para elementos 2D/3D."
                                  ],
                                  "verification": "Compare as matrizes derivadas com fórmulas padrão de livros-texto ou software para o elemento específico.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Livro de MEF (ex: Bathe ou Zienkiewicz)",
                                    "MATLAB/Python para integração numérica",
                                    "Folhas de cálculo"
                                  ],
                                  "tips": "Use simetria da geometria para reduzir cálculos; priorize elementos de viga Timoshenko para aeroespaciais.",
                                  "learningObjective": "Derivar corretamente [K_e] e [M_e] para elementos típicos de estruturas aeroespaciais.",
                                  "commonMistakes": [
                                    "Esquecer o Jacobiano na integração",
                                    "Confundir massa consistente com diagonalizada",
                                    "Ignorar rotação em elementos de casca"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Transformação das Matrizes Elementares para o Sistema Global",
                                  "subSteps": [
                                    "Defina a matriz de rotação [T] baseada nos ângulos entre sistemas local e global.",
                                    "Transforme [K_e] para [K_e^g] = [T]^T [K_e] [T] e [M_e] para [M_e^g] = [T]^T [M_e] [T].",
                                    "Expanda as matrizes para incluir todos os graus de liberdade (DoFs) do nó com zeros.",
                                    "Verifique ortogonalidade de [T] (det([T])=1 e [T]^T [T]=I).",
                                    "Aplique para múltiplos elementos com orientações diferentes."
                                  ],
                                  "verification": "Confirme que [K_e^g] preserva energia (x_g^T K_g x_g = x_l^T K_l x_l).",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Software FEA como ANSYS ou Abaqus para validação",
                                    "Calculadora matricial (MATLAB)",
                                    "Diagramas de malha"
                                  ],
                                  "tips": "Para cascas, use convenções de rotação 3D; teste com elemento alinhado (T=I).",
                                  "learningObjective": "Transformar matrizes locais em globais mantendo propriedades físicas.",
                                  "commonMistakes": [
                                    "Erro no sinal da rotação",
                                    "Não expandir para DoFs completos",
                                    "Usar [T] em vez de [T]^T"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Montagem da Matriz Global de Rigidez [K] e Massa [M]",
                                  "subSteps": [
                                    "Numere os nós e atribua índices de DoFs globais à malha.",
                                    "Inicialize [K] e [M] como matrizes esparsas zeradas do tamanho total de DoFs.",
                                    "Some as contribuições elementares: [K] += [K_e^g] e [M] += [M_e^g] nos índices corretos.",
                                    "Use scatter-gather ou conectividade para automação.",
                                    "Verifique partição de energia: trace([K]) = soma trace([K_e]).",
                                    "Otimize armazenamento esparso para grandes malhas."
                                  ],
                                  "verification": "Verifique dimensões (n_DoF x n_DoF) e soma das diagonais coincide com elementares.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código Python com NumPy/SciPy",
                                    "Exemplo de malha em .inp (Abaqus)",
                                    "Planilha Excel para malha pequena"
                                  ],
                                  "tips": "Implemente em loop sobre elementos; use CSR para esparsidade em códigos reais.",
                                  "learningObjective": "Montar eficientemente matrizes globais a partir de elementares.",
                                  "commonMistakes": [
                                    "Sobreposição errada de DoFs compartilhados",
                                    "Índices off-by-one",
                                    "Ignorar esparsidade levando a matriz densa"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicação de Condições de Contorno nas Matrizes Globais",
                                  "subSteps": [
                                    "Identifique DoFs restritos (ex: apoios fixos, simetria).",
                                    "Aplique método da rigidez penalizada ou eliminação de linhas/colunas.",
                                    "Para rigidez penalizada: adicione α*I aos DoFs restritos em [K] e [M].",
                                    "Atualize vetores de carga/forças inerciais se aplicável.",
                                    "Verifique redução de tamanho ou condicionamento da matriz.",
                                    "Teste com caso conhecido (viga em cantilever)."
                                  ],
                                  "verification": "Resolva [K]u=f para caso estático simples e compare deslocamentos esperados.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Solver eigen (SciPy.linalg.eig)",
                                    "Documentação ANSYS para BCs",
                                    "Casos analíticos de vigas/placas"
                                  ],
                                  "tips": "Prefira eliminação para precisão; α=1e12 para penalização.",
                                  "learningObjective": "Incorporar condições de contorno preservando simetria e esparsidade.",
                                  "commonMistakes": [
                                    "Penalizar massa em vez de rigidez",
                                    "Não remover linhas/colunas simetricamente",
                                    "Esquecer re-numerar DoFs"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma asa simplificada como placa retangular com 4 elementos de casca. Derive [K_e] e [M_e] para um elemento (shape functions DKQ), transforme para global, monte [K] 24x24 e [M], aplique contorno em raiz (u=v=w=θx=θy=0). Verifique autovalores modais.",
                              "finalVerifications": [
                                "Matrizes [K] e [M] são simétricas e definidas positivas.",
                                "Dimensões correspondem ao total de DoFs livres.",
                                "Soma das diagonais coincide com soma elementar.",
                                "Autovalores modais crescem monotonicamente com refinamento de malha.",
                                "Convergência para solução analítica em caso benchmark (viga cantilever).",
                                "Condicionamento numérico aceitável (cond([K]) < 1e12)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de matrizes elementares (erro <1%).",
                                "Correta transformação e montagem global sem erros de indexação.",
                                "Aplicação adequada de BCs mantendo simetria.",
                                "Eficiência computacional (uso de esparsidade).",
                                "Validação com software comercial ou analítica.",
                                "Relatório claro com plots de modos."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Operações matriciais, autovalores e esparsidade.",
                                "Programação: Implementação em Python/MATLAB com SciPy/NumPy.",
                                "Física: Princípios de dinâmica e vibrações.",
                                "Engenharia de Materiais: Propriedades D e ρ para compósitos aeroespaciais.",
                                "Otimização: Refinamento de malha e solvers iterativos."
                              ],
                              "realWorldApplication": "Na análise modal de componentes aeroespaciais como asas, fuselagem ou painéis de satélites, para prever frequências naturais e modos, evitando ressonâncias com excitações de voo e fenômenos aeroelásticos como flutter."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.2",
                            "name": "Simplificação para Vibração Livre Não Amortecida",
                            "description": "Simplificar a equação dinâmica para o caso de vibração livre sem amortecimento, obtendo [M]{ü} + [K]{u} = 0, e preparar para a análise modal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a equação geral de movimento no Método dos Elementos Finitos (MEF)",
                                  "subSteps": [
                                    "Recordar a forma geral da equação dinâmica: [M]{ü} + [C]{u̇} + [K]{u} = {F}(t)",
                                    "Identificar os componentes: matriz de massa [M], amortecimento [C], rigidez [K] e forças externas {F}",
                                    "Explicar o significado físico de cada termo em vibrações estruturais",
                                    "Escrever a equação em notação matricial padrão para sistemas multi-graus de liberdade",
                                    "Discutir o contexto aeroespacial, como em estruturas de asas ou fuselagens"
                                  ],
                                  "verification": "O aluno consegue escrever e explicar corretamente a equação geral sem erros de notação",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Livro-texto de Dinâmica das Estruturas (ex: Clough & Penzien)",
                                    "Papel e caneta para anotações",
                                    "Slides ou vídeo introdutório sobre MEF dinâmico"
                                  ],
                                  "tips": "Use desenhos esquemáticos de um elemento finito para visualizar os graus de liberdade",
                                  "learningObjective": "Compreender a estrutura completa da equação dinâmica no MEF para vibrações forçadas e livres",
                                  "commonMistakes": [
                                    "Confundir aceleração {ü} com velocidade {u̇}",
                                    "Esquecer a dependência temporal em {F}(t)",
                                    "Usar notação escalar em vez de vetorial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar condições para vibração livre não amortecida",
                                  "subSteps": [
                                    "Definir vibração livre: ausência de forças externas, {F}(t) = 0",
                                    "Definir não amortecida: matriz de amortecimento [C] = 0",
                                    "Justificar fisicamente: sistemas ideais sem dissipação de energia (ex: vácuo ou testes controlados)",
                                    "Escrever a equação resultante parcial: [M]{ü} + [K]{u} = 0",
                                    "Verificar dimensionalmente os termos restantes"
                                  ],
                                  "verification": "O aluno lista corretamente as condições {F}=0 e [C]=0 e escreve a equação simplificada inicial",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Planilha ou quadro branco",
                                    "Exemplos numéricos simples de [M] e [K] de um sistema 2DOF"
                                  ],
                                  "tips": "Pense em um pêndulo simples ou mola-massa sem atrito para analogia",
                                  "learningObjective": "Reconhecer as hipóteses que levam à simplificação para vibração livre não amortecida",
                                  "commonMistakes": [
                                    "Manter [C] por engano, confundindo com caso amortecido",
                                    "Ignorar que {F}=0 é essencial para 'livre'"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar e validar a equação final [M]{ü} + [K]{u} = 0",
                                  "subSteps": [
                                    "Substituir [C]=0 e {F}=0 na equação geral",
                                    "Reescrever explicitamente: [M]{ü} + [K]{u} = {0}",
                                    "Verificar propriedades das matrizes: [M] simétrica positiva definida, [K] simétrica semi-definida positiva",
                                    "Resolver para uma forma padrão introduzindo coordenadas modais (prévia para análise modal)",
                                    "Testar com um exemplo numérico pequeno (ex: 1 DOF)"
                                  ],
                                  "verification": "O aluno deriva a equação final e valida com um exemplo 1DOF onde ω² = k/m",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software MATLAB ou Python (NumPy/SciPy)",
                                    "Exemplo de matrizes [M] e [K] pré-definidas"
                                  ],
                                  "tips": "Normalize as equações dividindo por massa para obter forma desacoplada",
                                  "learningObjective": "Dominar a simplificação matemática e suas propriedades algébricas",
                                  "commonMistakes": [
                                    "Erro de sinal nos termos",
                                    "Confundir [K]{u} com [K]{ü}",
                                    "Não verificar simetria das matrizes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Preparar para análise modal",
                                  "subSteps": [
                                    "Introduzir a solução assumida harmônica: {u} = {φ} sin(ωt + θ)",
                                    "Substituir na equação para obter problema de autovalores: ([K] - ω²[M]){φ} = 0",
                                    "Explicar o papel das frequências naturais ω e modos {φ}",
                                    "Discutir importância em aeroelasticidade (ex: evitar ressonância)",
                                    "Planejar próximos passos: solução numérica via decomposição espectral"
                                  ],
                                  "verification": "O aluno escreve o problema de autovalores e explica sua relevância para modos de vibração",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código MATLAB para autovalores (eig)",
                                    "Artigo sobre análise modal em asas"
                                  ],
                                  "tips": "Use o comando eig([K], [M]) no MATLAB para visualização rápida",
                                  "learningObjective": "Conectar a equação simplificada à análise modal subsequente",
                                  "commonMistakes": [
                                    "Assumir solução cos(ωt) em vez de sin, afetando derivadas",
                                    "Esquecer normalização dos modos"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um sistema massa-mola com dois graus de liberdade (2DOF) modelado por MEF: [M] = [[m,0],[0,m]], [K] = [[k1+k2,-k2],[-k2,k2]], [C]=0, {F}=0. Simplifique para [M]{ü} + [K]{u} = 0 e resolva para frequências naturais ω1 e ω2, obtendo modos de vibração distintos para análise de flutter em uma asa flexível.",
                              "finalVerifications": [
                                "Deriva corretamente [M]{ü} + [K]{u} = 0 a partir da equação geral",
                                "Explica fisicamente as hipóteses de vibração livre não amortecida",
                                "Formula o problema de autovalores para análise modal",
                                "Valida com exemplo numérico simples (1 ou 2 DOF)",
                                "Identifica preparação para solução modal numérica"
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação matemática (sem erros de notação ou sinal)",
                                "Compreensão conceitual das simplificações físicas",
                                "Capacidade de validar com exemplo prático",
                                "Clareza na ligação com análise modal",
                                "Profundidade nos subpassos e verificações intermediárias",
                                "Uso correto de propriedades matriciais"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (autovalores e autovetores)",
                                "Física: Mecânica clássica (equações diferenciais de segunda ordem)",
                                "Engenharia de Computação: Implementação numérica em MATLAB/Python",
                                "Engenharia Mecânica: Dinâmica de sistemas multi-DOF"
                              ],
                              "realWorldApplication": "Em aeroespacial, essa simplificação é usada para calcular frequências e modos naturais de asas ou painéis de satélites, prevendo instabilidades como flutter e garantindo segurança em voo supersônico."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.4.1.3",
                            "name": "Incorporação do Amortecimento de Rayleigh",
                            "description": "Modelar o amortecimento proporcional de Rayleigh como [C] = α[M] + β[K], e discutir sua adequação para análises modais em estruturas aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão das Matrizes Fundamentais no MEF: Massa [M] e Rigidez [K]",
                                  "subSteps": [
                                    "Relembrar a formulação das equações de movimento sem amortecimento: [M]{ü} + [K]{u} = {F}.",
                                    "Derivar ou revisar a montagem das matrizes [M] e [K] para um elemento finito simples (ex: viga de Euler-Bernoulli).",
                                    "Entender as propriedades modais: autovalores e autovetores de [M]^{-1}[K].",
                                    "Discutir a importância das frequências naturais em análises modais.",
                                    "Verificar ortogonalidade dos modos assumindo ausência de amortecimento."
                                  ],
                                  "verification": "Montar [M] e [K] para um elemento e resolver problema modal simples, confirmando frequências conhecidas.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Livro 'Finite Element Procedures' de Bathe (cap. 9)",
                                    "Software MATLAB ou Python com NumPy/SciPy",
                                    "Planilha com exemplo de viga"
                                  ],
                                  "tips": "Use elementos 2D para visualização; normalize modos para facilitar comparações.",
                                  "learningObjective": "Compreender as bases das matrizes dinâmicas no MEF para preparar incorporação de amortecimento.",
                                  "commonMistakes": [
                                    "Confundir [M] global com local",
                                    "Ignorar condições de contorno na montagem",
                                    "Não normalizar massas para modos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formulação do Amortecimento Proporcional de Rayleigh",
                                  "subSteps": [
                                    "Introduzir o modelo [C] = α[M] + β[K], onde α é coeficiente de amortecimento de massa e β de rigidez.",
                                    "Explicar origens físicas: α relacionado a amortecimento viscoso inercial, β a estrutural.",
                                    "Derivar as razões de amortecimento modal: ξ_i = α/(2ω_i) + β ω_i / 2.",
                                    "Discutir determinação de α e β via curvas de decaimento ou frequências/amortecimentos medidos.",
                                    "Comparar com amortecimento não-proporcional (não diagonalizável simultaneamente)."
                                  ],
                                  "verification": "Calcular ξ_i para modos conhecidos e plotar diagrama de raízes complexas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Artigo 'Rayleigh Damping' de Chopra (Dynamics of Structures)",
                                    "MATLAB script para eigenvalues com [C]",
                                    "Gráficos de ξ vs ω"
                                  ],
                                  "tips": "Escolha α e β para cobrir faixa de frequências de interesse (ex: 1º a 5º modo).",
                                  "learningObjective": "Modelar matematicamente o amortecimento de Rayleigh e suas implicações modais.",
                                  "commonMistakes": [
                                    "Confundir α com β nas fórmulas de ξ",
                                    "Aplicar Rayleigh a sistemas com modos próximos",
                                    "Não verificar se [C] decouple nos modos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporação nas Equações de Movimento e Resolução Modal",
                                  "subSteps": [
                                    "Formular equação completa: [M]{ü} + [C]{u̇} + [K]{u} = {F}.",
                                    "Assumir solução harmônica {u} = {φ} e^{st} e transformar para equação característica.",
                                    "Diagonalizar no espaço modal: equações desacopladas para cada modo.",
                                    "Implementar numericamente via MEF: montar [C] global e resolver autovalores de (λ²[M] + λ[C] + [K]).",
                                    "Validar com caso sem amortecimento (α=β=0)."
                                  ],
                                  "verification": "Resolver sistema com [C] e confirmar decaimento exponencial nos modos.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Software ANSYS ou Abaqus (módulo modal)",
                                    "Código MATLAB para MEF dinâmico",
                                    "Exemplo de malha finita"
                                  ],
                                  "tips": "Use pré-condicionadores para matrizes grandes; monitore convergência modal.",
                                  "learningObjective": "Integrar Rayleigh nas equações MEF e realizar análise modal amortecida.",
                                  "commonMistakes": [
                                    "Montagem incorreta de [C] global",
                                    "Esquecer pré-multiplicação por Φ^T",
                                    "Ignorar normalização modal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discussão de Adequação para Análises Modais em Estruturas Aeroespaciais",
                                  "subSteps": [
                                    "Analisar limitações: assume amortecimento modal constante, inadequado para modos altos.",
                                    "Comparar com modelos avançados (ex: amortecimento modal complexo ou viscoelástico).",
                                    "Aplicar a casos aeroespaciais: asas, fuselagens onde flutter é crítico.",
                                    "Avaliar sensibilidade: variação de α/β em frequências de flutter.",
                                    "Recomendar uso: bom para estimativas iniciais em regime subcrítico."
                                  ],
                                  "verification": "Relatório comparando resultados Rayleigh vs. experimental em benchmark aeroespacial.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "NASA Technical Report on Aeroelasticity",
                                    "Paper 'Modal Analysis in Aerospace' ",
                                    "Dados experimentais de viga flutter"
                                  ],
                                  "tips": "Foque em faixa 0-20 Hz típica de estruturas aeronáuticas; use half-power bandwidth para calibração.",
                                  "learningObjective": "Avaliar criticamente a adequação de Rayleigh em contextos aeroespaciais reais.",
                                  "commonMistakes": [
                                    "Superestimar precisão em modos não-proporcionais",
                                    "Ignorar acoplamento aeroelástico",
                                    "Não considerar não-linearidades"
                                  ]
                                }
                              ],
                              "practicalExample": "Modelar uma viga cantilever de alumínio (seção de asa) com MEF (10 elementos), aplicar Rayleigh com α=0.1, β=0.001, resolver modos amortecidos e verificar frequências complexas contra dados experimentais de vibração livre.",
                              "finalVerifications": [
                                "Derivação correta de [C] = α[M] + β[K] e ξ_i.",
                                "Resolução modal de sistema com amortecimento, plotando decaimento.",
                                "Discussão de pelo menos 3 limitações em aeroespaciais.",
                                "Implementação numérica funcional em software.",
                                "Comparação com caso sem amortecimento.",
                                "Calibração de α/β via método half-power."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na formulação (100% corretude nas derivadas).",
                                "Profundidade na discussão de adequação (cobertura de prós/contras).",
                                "Qualidade da implementação numérica (convergência <1%).",
                                "Relevância ao contexto aeroespacial (exemplos específicos).",
                                "Clareza em verificações e plots modais.",
                                "Identificação de erros comuns e mitigação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (autovalores generalizados).",
                                "Física: Teoria de vibrações e dissipação de energia.",
                                "Engenharia Aeronáutica: Aeroelasticidade e prevenção de flutter.",
                                "Computação: Programação numérica em MEF (MATLAB/Python/Fortran).",
                                "Controle: Projeto de amortecedores passivos."
                              ],
                              "realWorldApplication": "Em análises modais de asas de aeronaves (ex: Boeing 787), Rayleigh é usado para estimar amortecimento em testes de solo, auxiliando na certificação FAA/EASA contra instabilidades como flutter divergente."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.2",
                        "name": "Problema de Autovalores Generalizado",
                        "description": "Formulação do problema de valores próprios generalizado [K]{φ} = ω² [M]{φ} para cálculo de frequências naturais ω e modos de vibração {φ} em sistemas discretizados pelo MEF.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.2.1",
                            "name": "Assumir Solução Harmônica e Linearizar",
                            "description": "Assumir solução na forma {u(t)} = {φ} sin(ωt) para obter a equação de autovalores generalizada e discutir propriedades como ortogonalidade dos modos em relação a [M] e [K].",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Assumir a Forma da Solução Harmônica",
                                  "subSteps": [
                                    "Revise a equação de movimento geral para sistemas discretizados: [M]{ü} + [C]{u̇} + [K]{u} = {F(t)}.",
                                    "Para análise modal livre não amortecida, simplifique para [M]{ü} + [K]{u} = 0.",
                                    "Assuma solução harmônica u(t) = φ sin(ωt), onde φ é o vetor de modo e ω é a frequência natural.",
                                    "Derive as derivadas temporais: u̇(t) = ω φ cos(ωt), ü(t) = -ω² φ sin(ωt).",
                                    "Verifique que a solução satisfaz as condições de movimento harmônico livre."
                                  ],
                                  "verification": "Confirme que u(t), u̇(t) e ü(t) estão corretamente expressos em termos de φ e ω.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis, calculadora, notas de aula sobre dinâmica de estruturas.",
                                  "tips": "Sempre normalize o vetor φ para simplificar cálculos posteriores.",
                                  "learningObjective": "Compreender e aplicar a assunção de solução harmônica em problemas modais.",
                                  "commonMistakes": "Esquecer o sinal negativo em ü(t) ou confundir sin com cos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Substituir na Equação de Movimento e Linearizar",
                                  "subSteps": [
                                    "Substitua u(t), u̇(t) e ü(t) na equação [M]{ü} + [K]{u} = 0.",
                                    "Simplifique o termo temporal sin(ωt), resultando em [-ω² [M] φ + [K] φ] sin(ωt) = 0.",
                                    "Como sin(ωt) ≠ 0 para todo t, o vetor entre colchetes deve ser zero: [K] φ = ω² [M] φ.",
                                    "Reorganize para a forma padrão do problema de autovalores generalizado.",
                                    "Discuta a linearização: o problema não linear em tempo torna-se linear em autovalores."
                                  ],
                                  "verification": "Derive explicitamente [K] φ - ω² [M] φ = 0 e confirme independência temporal.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel e lápis, software simbólico como MATLAB Symbolic Toolbox (opcional).",
                                  "tips": "Fatore sin(ωt) para isolar o problema espacial.",
                                  "learningObjective": "Linearizar equações diferenciais em problemas de autovalores.",
                                  "commonMistakes": "Incluir termos de amortecimento desnecessariamente ou errar o rearranjo algébrico."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Obter e Interpretar a Equação de Autovalores Generalizada",
                                  "subSteps": [
                                    "Escreva a equação matricial: ([K] - ω² [M]) φ = 0.",
                                    "Explique que ω² são autovalores e φ autovetores.",
                                    "Discuta condições para soluções não triviais: det([K] - ω² [M]) = 0.",
                                    "Implemente numericamente para um sistema pequeno (ex: 2 DOF).",
                                    "Verifique simetria de [M] e [K] para propriedades espectrais."
                                  ],
                                  "verification": "Resolva para um exemplo 2x2 e obtenha ω e φ corretos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "MATLAB ou Python (NumPy/SciPy), matrizes de exemplo de [M] e [K].",
                                  "tips": "Use solvers de autovalores como eig em MATLAB para validação.",
                                  "learningObjective": "Formular e resolver problemas de autovalores generalizados.",
                                  "commonMistakes": "Confundir autovalores próprios com generalizados ou ignorar não-diagonalidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Propriedades dos Modos: Ortogonalidade",
                                  "subSteps": [
                                    "Mostre ortogonalidade em massa: φ_i^T [M] φ_j = 0 para i ≠ j.",
                                    "Mostre ortogonalidade em rigidez: φ_i^T [K] φ_j = 0 para i ≠ j.",
                                    "Derive normalização modal: φ_i^T [M] φ_i = 1, φ_i^T [K] φ_i = ω_i².",
                                    "Explique implicações para superposição modal.",
                                    "Discuta modos reais devido à simetria positiva definida."
                                  ],
                                  "verification": "Calcule φ_i^T [M] φ_j e confirme zero para i ≠ j em exemplo numérico.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "MATLAB para multiplicação matricial, exemplos de modos de uma treliça.",
                                  "tips": "Use propriedades hermitianas para generalizações complexas.",
                                  "learningObjective": "Entender e provar ortogonalidade modal.",
                                  "commonMistakes": "Esquecer transposição ou assumir ortogonalidade euclidiana simples."
                                }
                              ],
                              "practicalExample": "Para uma treliça aeroespacial de 2 graus de liberdade com [M] = [[2,0],[0,1]] kg e [K] = [[3, -1],[-1,2]] N/m, assuma u(t) = φ sin(ωt), derive [K]φ = ω²[M]φ, resolva para ω1≈0.707 rad/s, φ1=[0.85,0.53]^T e verifique φ1^T[M]φ1=1 após normalização.",
                              "finalVerifications": [
                                "Derivação correta de ü(t) = -ω² φ sin(ωt).",
                                "Equação de autovalores [K]φ = ω²[M]φ obtida sem erros algébricos.",
                                "Ortogonalidade comprovada numericamente para pelo menos dois modos.",
                                "Normalização modal aplicada corretamente.",
                                "Discussão de simetria de [M] e [K] incluída.",
                                "Exemplo numérico resolvido com autovalores/freqüências precisas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na assunção harmônica e derivação temporal (30%).",
                                "Correção na formulação do problema generalizado (25%).",
                                "Profundidade na prova de ortogonalidade (20%).",
                                "Uso correto de ferramentas numéricas (15%).",
                                "Clareza na discussão de propriedades (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Autovalores generalizados e decomposição espectral.",
                                "Física Quântica: Analogia com oscilador harmônico quântico.",
                                "Programação: Implementação em Python/MATLAB para FEM modal.",
                                "Controle de Sistemas: Modos em análise de vibrações ativas."
                              ],
                              "realWorldApplication": "Em aeroelasticidade, essa técnica identifica frequências naturais de asas de aeronaves para evitar flutter (ressonância destrutiva), como no design do Boeing 737 onde modos modais guiam reforços estruturais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.1.2"
                            ]
                          },
                          {
                            "id": "10.1.4.4.2.2",
                            "name": "Métodos de Solução Numérica para Autovalores",
                            "description": "Aplicar métodos como Lanczos ou subespaço para extrair as primeiras N frequências e modos dominantes em problemas grandes de MEF, considerando eficiência computacional.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Problema de Autovalores Generalizado em MEF",
                                  "subSteps": [
                                    "Revisar a formulação do problema modal em MEF: (K - λ M) φ = 0, onde K é rigidez, M é massa e λ são autovalores (quadrados das frequências).",
                                    "Identificar desafios em problemas grandes: matrizes esparsas de alta dimensão (milhares de DOFs).",
                                    "Explicar por que métodos diretos (ex: QZ) são ineficientes para extrair apenas os primeiros N autovalores.",
                                    "Discutir autovalores extremos (menores λ) como frequências e modos dominantes.",
                                    "Estudar propriedades de simetria positiva definida de K e M."
                                  ],
                                  "verification": "Resumir em um parágrafo os motivos para usar métodos numéricos iterativos em problemas grandes de MEF.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Notas de aula sobre MEF modal",
                                    "MATLAB ou Python com SciPy/NumPy",
                                    "Artigo introdutório sobre análise modal"
                                  ],
                                  "tips": [
                                    "Visualize matrizes K e M de um exemplo pequeno para entender esparsidade.",
                                    "Use plot de autovalores para ver distribuição."
                                  ],
                                  "learningObjective": "Entender a formulação matemática e limitações computacionais do problema de autovalores generalizado.",
                                  "commonMistakes": [
                                    "Confundir autovalores com frequências angulares.",
                                    "Ignorar normalização dos modos (ortogonalidade em M)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o Algoritmo de Lanczos para Autovalores Generalizados",
                                  "subSteps": [
                                    "Aprender tridiagonalização de Lanczos para problema padrão Ax = λx, adaptando para generalizado via shift-invert.",
                                    "Detalhar iterações: gerar sequência ortogonal q_k, construir matriz tridiagonal T_k.",
                                    "Explicar extração de Ritz values θ_j^{(k)} como aproximações de autovalores extremos.",
                                    "Implementar parada baseada em residual ||A q_j - θ_j q_j|| < tolerância.",
                                    "Discutir aceleração para menores autovalores via inversão (K^{-1} M)."
                                  ],
                                  "verification": "Desenhar fluxograma do algoritmo Lanczos e explicar 3 iterações manualmente em um toy problem 3x3.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Pseudocódigo de Lanczos do livro 'Matrix Computations' de Golub",
                                    "Jupyter Notebook com implementação básica",
                                    "Exemplo de código MATLAB fs Lanczos"
                                  ],
                                  "tips": [
                                    "Monitore reortogonalização para evitar perda de ortogonalidade em problemas il-condicionados.",
                                    "Comece com k=20 Ritz vectors para convergência rápida."
                                  ],
                                  "learningObjective": "Dominar os passos iterativos do método Lanczos e sua adaptação para problemas generalizados.",
                                  "commonMistakes": [
                                    "Esquecer reortogonalização levando a instabilidade numérica.",
                                    "Usar shift-invert sem pré-condicionador para eficiência."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Método Lanczos em Código para MEF",
                                  "subSteps": [
                                    "Gerar ou carregar malha MEF de uma viga ou placa (ex: 1000 DOFs).",
                                    "Montar matrizes K e M esparsas usando FEM library (ex: FEniCS ou SciPy sparse).",
                                    "Codificar Lanczos: inicializar q1 aleatório, iterar até convergir N=10 autovalores.",
                                    "Extrair frequências ω = sqrt(λ) e modos φ, normalizando φ^T M φ = 1.",
                                    "Plotar convergência de Ritz values vs iterações."
                                  ],
                                  "verification": "Executar código e obter as 5 primeiras frequências com erro <1% vs solução exata.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Python com SciPy.sparse.linalg, Matplotlib",
                                    "Malha MEF exemplo (viga cantilever)",
                                    "Documentação ARPACK para lobpcg"
                                  ],
                                  "tips": [
                                    "Use sparse solvers para K^{-1} em shift-invert.",
                                    "Teste com N pequeno primeiro para debug."
                                  ],
                                  "learningObjective": "Implementar funcionalmente Lanczos para extrair modos dominantes em MEF real.",
                                  "commonMistakes": [
                                    "Não tratar zeros no modo rígido (λ=0).",
                                    "Índices errados em vetores Ritz."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com Método de Subespaço e Analisar Eficiência",
                                  "subSteps": [
                                    "Implementar método de subespaço: projetar em m vetores Q_m, resolver eigenvalue pequeno Q_m^T (K - λ M) Q_m.",
                                    "Comparar tempo CPU e memória para problema grande (10k DOFs), visando primeiras 20 frequências.",
                                    "Avaliar precisão: erro relativo vs referência (ex: método direto em submalha).",
                                    "Discutir trade-offs: Lanczos para espectro extremo vs subespaço para blocos.",
                                    "Otimizar: pré-condicionamento, paralelização básica."
                                  ],
                                  "verification": "Gerar tabela comparativa: tempo Lanczos vs subespaço vs direto, com speedup >10x.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Código do Step 3 estendido",
                                    "Problema MEF grande (asa simplificada ~5k DOFs)",
                                    "Profiler como %timeit no Python"
                                  ],
                                  "tips": [
                                    "Escolha m=2N para subespaço robusto.",
                                    "Meça FLOPs aproximados para eficiência teórica."
                                  ],
                                  "learningObjective": "Avaliar e otimizar métodos numéricos considerando custo computacional em MEF.",
                                  "commonMistakes": [
                                    "Comparar sem normalizar tamanho problema.",
                                    "Ignorar custo de inversão em shift-invert."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma simulação MEF de uma asa de aeronave com 50.000 DOFs, use Lanczos para extrair as 10 primeiras frequências e modos, identificando modos de flexão crítica em 5 minutos, vs horas com método direto, permitindo análise de flutter rápida.",
                              "finalVerifications": [
                                "Código converge para N=10 autovalores com residual <1e-6.",
                                "Frequências coincidem com referência em <0.5% erro relativo.",
                                "Tempo de execução <1% do método direto para problemas >10k DOFs.",
                                "Modos normalizados corretamente (φ^T M φ =1).",
                                "Gráficos de convergência mostram estabilização em <50 iterações.",
                                "Eficiência medida: speedup quantificado em relatório."
                              ],
                              "assessmentCriteria": [
                                "Precisão das primeiras N frequências (<1% erro).",
                                "Eficiência computacional demonstrada (tempo/memória).",
                                "Implementação numéricamente estável (sem NaNs ou divergência).",
                                "Correta interpretação de modos dominantes.",
                                "Análise comparativa com outro método.",
                                "Relatório claro com plots e métricas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Numérica: Algoritmos iterativos e análise de erro.",
                                "Programação Científica: Manipulação de matrizes esparsas em Python/MATLAB.",
                                "Engenharia Aeroespacial: Análise modal para aeroelasticidade.",
                                "Otimização Computacional: Pré-condicionadores e paralelismo.",
                                "Física Computacional: Simulações dinâmicas em MEF."
                              ],
                              "realWorldApplication": "Na indústria aeroespacial, esses métodos são usados pela Boeing e NASA para análise modal de asas e fuselagens grandes, reduzindo tempo de simulação de dias para horas, essencial para certificação de aeronaves contra vibrações e flutter."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.3",
                        "name": "Solução Modal e Expansão em Coordenadas Modais",
                        "description": "Uso dos modos de vibração para expandir a solução dinâmica em coordenadas modais, permitindo desacoplamento das equações e análise de resposta modal em estruturas aeroespaciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.3.1",
                            "name": "Expansão Modal da Solução",
                            "description": "Expressar o deslocamento geral como {u(t)} = [Φ]{q(t)}, onde [Φ] contém os modos, e derivar as equações desacopladas para as coordenadas modais q_i(t).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Equação de Movimento e os Modos de Vibração",
                                  "subSteps": [
                                    "Escreva a equação de movimento undamped para o sistema: [M]{ü} + [K]{u} = {F(t)}.",
                                    "Lembre-se das propriedades dos modos normais: [Φ]^T [M] [Φ] = [I] e [Φ]^T [K] [Φ] = [Ω]^2, onde [Ω]^2 é diagonal com ω_i^2.",
                                    "Liste os passos para obter os modos [Φ] via elementos finitos: montar [M] e [K], resolver problema de autovalores.",
                                    "Verifique a normalização modal: modos mass-normalizados.",
                                    "Discuta o número de modos necessários para boa aproximação (ex: primeiros 6 modos)."
                                  ],
                                  "verification": "Escreva corretamente a EOM undamped e demonstre as propriedades ortogonais dos modos com um exemplo 2x2.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Notas de análise modal FEM",
                                    "Matriz de massa e rigidez de exemplo simples",
                                    "Software MATLAB ou Python para autovalores"
                                  ],
                                  "tips": "Sempre normalize os modos pela massa para simplificar cálculos.",
                                  "learningObjective": "Compreender a base teórica da análise modal e propriedades ortogonais essenciais para desacoplamento.",
                                  "commonMistakes": [
                                    "Esquecer a normalização modal",
                                    "Confundir modos não-normalizados com ortogonais",
                                    "Ignorar que [Φ] é coluna-ortogonal apenas após normalização"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a Expansão Modal da Solução Geral",
                                  "subSteps": [
                                    "Expresse o deslocamento geral como {u(t)} = [Φ]{q(t)}, onde [Φ] é a matriz de modos e {q(t)} são as coordenadas modais.",
                                    "Justifique a escolha: truncar [Φ] aos primeiros N modos para aproximação.",
                                    "Derive as velocidades e acelerações: {ú(t)} = [Φ]{q̇(t)}, {ü(t)} = [Φ]{q̈(t)}.",
                                    "Discuta a redução de dimensionalidade: de n DOFs para N << n coordenadas.",
                                    "Esboce graficamente para um sistema 2-DOF: modos como vetores e combinação linear."
                                  ],
                                  "verification": "Escreva a expansão {u(t)} = [Φ]{q(t)} e derive {ü(t)} corretamente, confirmando com um sketch.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Papel e lápis para derivações",
                                    "Exemplo numérico de viga com modos conhecidos",
                                    "Livro de Dinâmica das Estruturas (Clough & Penzien)"
                                  ],
                                  "tips": "Visualize [Φ] como base modal que diagonaliza o sistema.",
                                  "learningObjective": "Dominar a representação do deslocamento em termos de coordenadas modais.",
                                  "commonMistakes": [
                                    "Escrever {u} = {Φ} [q] em vez de [Φ]{q}",
                                    "Confundir expansão estática com modal",
                                    "Usar todos os modos sem truncamento"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Substituir a Expansão na Equação de Movimento",
                                  "subSteps": [
                                    "Substitua {u}, {ü} na EOM: [M][Φ]{q̈} + [K][Φ]{q} = {F(t)}.",
                                    "Pré-multiplique por [Φ]^T: [Φ]^T [M] [Φ] {q̈} + [Φ]^T [K] [Φ] {q} = [Φ]^T {F(t)}.",
                                    "Aplique ortogonalidade: [I] {q̈} + [Ω]^2 {q} = {Q(t)}, onde Q_i = φ_i^T F.",
                                    "Verifique para caso livre (F=0): equações desacopladas por modo.",
                                    "Calcule forças modais {Q(t)} para um F(t) sinusoidal."
                                  ],
                                  "verification": "Derive a equação modal desacoplada [I]{q̈} + [Ω]^2 {q} = {Q(t)} passo a passo.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Calculadora simbólica (SymPy ou MATLAB Symbolic)",
                                    "Exemplo 3-DOF com [M], [K] conhecidos",
                                    "Transparências para projeção de modos"
                                  ],
                                  "tips": "O truque chave é pré-multiplicar por [Φ]^T para projetar nos modos.",
                                  "learningObjective": "Executar a substituição e usar ortogonalidade para obter forma desacoplada.",
                                  "commonMistakes": [
                                    "Esquecer pré-multiplicação por [Φ]^T",
                                    "Não usar normalização levando a [μ] ≠ [I]",
                                    "Confundir {Q} com forças físicas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar e Interpretar as Equações Desacopladas por Modo",
                                  "subSteps": [
                                    "Para cada modo i: q̈_i + ω_i² q_i = Q_i(t), onde Q_i = φ_i^T F(t).",
                                    "Resolva para caso livre: q_i(t) = A_i cos(ω_i t) + B_i sin(ω_i t).",
                                    "Discuta excitação modal: modos independentes, excitação seletiva por φ_i^T F.",
                                    "Reconstrua u(t) somando contribuições modais.",
                                    "Avalie convergência: erro diminui com mais modos."
                                  ],
                                  "verification": "Escreva e resolva a EDO para q_i(t) undamped, reconstruindo u(t) para condições iniciais dadas.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Software para simulação modal (ANSYS ou NASTRAN tutorial)",
                                    "Condições iniciais de exemplo",
                                    "Gráficos de modos e resposta temporal"
                                  ],
                                  "tips": "Cada modo vibra independentemente em sua freq natural.",
                                  "learningObjective": "Derivar EDOs modais desacopladas e interpretar respostas.",
                                  "commonMistakes": [
                                    "Acoplar modos acidentalmente",
                                    "Ignorar truncamento em reconstrução",
                                    "Confundir q_i com deslocamentos físicos"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma viga cantilever modelada com 4 elementos finitos (8 DOFs), obtenha os 3 primeiros modos [Φ] (3x8). Expansão: u(t) = Φ q(t). Para carga F(t) = [0,...,P sin(Ωt)]^T no final, derive q̈1 + ω1² q1 = φ1^T F, etc. Simule em MATLAB e plote respostas modais independentes.",
                              "finalVerifications": [
                                "Escreve corretamente {u(t)} = [Φ]{q(t)} e propriedades modais.",
                                "Deriva [I]{q̈} + [Ω]^2 {q} = [Φ]^T {F} sem erros.",
                                "Obtém EDO desacoplada q̈_i + ω_i² q_i = Q_i(t) para cada i.",
                                "Calcula forças modais Q_i corretamente para F dado.",
                                "Reconstrói u(t) e verifica ortogonalidade numérica.",
                                "Discute truncamento de modos com exemplo quantitativo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação da expansão modal (30%)",
                                "Correção na aplicação de ortogonalidade e derivação (40%)",
                                "Interpretação física das coordenadas modais (15%)",
                                "Uso de exemplo prático com cálculos numéricos (10%)",
                                "Clareza na reconstrução e discussão de convergência (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Problemas de autovalores e diagonalização de matrizes.",
                                "Física: Princípios de vibrações livres e forçadas em sistemas contínuos.",
                                "Programação: Implementação em MATLAB/Python para solver modais (eig).",
                                "Engenharia de Controle: Redução modal para design de controladores."
                              ],
                              "realWorldApplication": "Em aeroelasticidade, usada para análise de flutter em asas de aeronaves: expansão modal reduz modelo FEM de milhares de DOFs para 10-20 modais, simulando respostas a rajadas de vento e previnindo ressonâncias destrutivas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.4.3.2",
                            "name": "Cálculo de Resposta Modal a Excitações",
                            "description": "Calcular a resposta modal para excitações harmônicas ou arbitrárias usando funções de influência modal, com ênfase em aplicações aeroespaciais como vibrações induzidas por turbulência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Obtenção das Propriedades Modais e Funções de Influência",
                                  "subSteps": [
                                    "Realize a análise modal via elementos finitos para obter frequências naturais ω_r e modos φ_r.",
                                    "Calcule as massas generalizadas M_r = φ_r^T M φ_r e rigidezes K_r = φ_r^T K φ_r.",
                                    "Derive as funções de influência modal h_r(t) para cada modo, usando a solução do oscilador amortecido unitário.",
                                    "Verifique a ortogonalidade modal: φ_r^T M φ_s = 0 e φ_r^T K φ_s = 0 para r ≠ s.",
                                    "Armazene as funções modais normalizadas para uso posterior."
                                  ],
                                  "verification": "Confirme que as frequências e modos satisfazem a equação de autovalores (K - ω²M)φ = 0 e que as funções h_r(t) seguem h_r(t) = (1/M_r ω_r) e^{-ζω t} sin(ω_d t) para t>0.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Software FEM como ANSYS ou MATLAB",
                                    "Matrizes de massa M e rigidez K do modelo",
                                    "Documentação de análise modal"
                                  ],
                                  "tips": [
                                    "Use modos dominantes (primeiros 10-20) para reduzir ordem computacional.",
                                    "Normalizar modos pela massa generalizada para simplificar cálculos."
                                  ],
                                  "learningObjective": "Compreender e extrair propriedades modais essenciais para expansão em coordenadas modais.",
                                  "commonMistakes": [
                                    "Ignorar amortecimento modal ζ_r.",
                                    "Não verificar ortogonalidade, levando a acoplamentos espúrios.",
                                    "Selecionar modos irrelevantes, degradando precisão."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formulação da Excitação e Projeção Modal",
                                  "subSteps": [
                                    "Defina a excitação f(t) como harmônica f(t) = F_0 cos(Ωt) ou arbitrária (ex: turbulência via espectro von Karman).",
                                    "Projete a força nos modos: Q_r(t) = φ_r^T f(t), usando superposição modal.",
                                    "Para harmônica, compute amplitude estática φ_r^T F_0 e fase.",
                                    "Para arbitrária, discretize f(t) ou use transformada de Fourier para frequência.",
                                    "Inclua amortecimento modal ζ_r obtido de Rayleigh ou experimental."
                                  ],
                                  "verification": "Verifique que ∑ Q_r(t) φ_r ≈ f(t) em alguns pontos para validar projeção.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": [
                                    "Dados de excitação aeroespacial (espectros de turbulência)",
                                    "Funções modais φ_r do Step 1",
                                    "MATLAB ou Python para projeção"
                                  ],
                                  "tips": [
                                    "Para turbulência, use filtros para gerar realizações estocásticas realistas.",
                                    "Mantenha pelo menos 90% da energia modal para truncagem."
                                  ],
                                  "learningObjective": "Projetar corretamente forças externas nos coordenadas modais.",
                                  "commonMistakes": [
                                    "Esquecer normalização modal em Q_r(t).",
                                    "Usar força nodal sem projeção, causando erro de escala.",
                                    "Negligenciar forças correlacionadas em turbulência."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Cálculo da Resposta Modal para Excitações Harmônicas",
                                  "subSteps": [
                                    "Resolva a equação modal ẍ_r + 2ζ_r ω_r ẋ_r + ω_r² x_r = Q_r(t)/M_r para harmônica.",
                                    "Use resposta em regime permanente: x_r(t) = H_r(Ω) Q_r(Ω) e^{iΩt}, com H_r(Ω) = 1/(ω_r² - Ω² + 2iζ_r ω_r Ω).",
                                    "Compute módulo e fase da função de transferência modal.",
                                    "Some respostas modais: u(t) ≈ ∑ φ_r x_r(t).",
                                    "Plote FRF (Função de Resposta em Frequência) para validação."
                                  ],
                                  "verification": "Compare FRF modal com picos em ω_r e atenuação em anti-ressonância.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Equações modais derivadas",
                                    "Ferramentas numéricas como MATLAB ode45 ou simbólica"
                                  ],
                                  "tips": [
                                    "Aproximação quasi-estática para Ω << ω_r.",
                                    "Evite divisão por zero em Ω = ω_r usando limites."
                                  ],
                                  "learningObjective": "Derivar e calcular respostas modais em domínio da frequência para excitações harmônicas.",
                                  "commonMistakes": [
                                    "Confundir resposta transitória com permanente.",
                                    "Erro de sinal na função de transferência H_r.",
                                    "Sobrestimar resposta perto de ressonância sem amortecimento."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Extensão para Excitações Arbitrárias e Aplicação Aeroespacial",
                                  "subSteps": [
                                    "Para arbitrária, integre convolução: x_r(t) = ∫ h_r(t-τ) Q_r(τ)/M_r dτ (integral de Duhamel).",
                                    "Use FFT para eficiência: X_r(ω) = H_r(ω) Q_r(ω), IFFT para tempo.",
                                    "Aplique a vibrações de turbulência: modele f(t) como processo estacionário com PSD.",
                                    "Sintetize deslocamentos u(t) = ∑ φ_r x_r(t) e calcule tensões/ fadiga.",
                                    "Avalie em asa: compute cargas de flutter ou fadiga por gusts."
                                  ],
                                  "verification": "Energia total conservada: ∫ u(t)^T M u(t) dt ≈ energia de f(t).",
                                  "estimatedTime": "1.5-2 horas",
                                  "materials": [
                                    "Espectros de turbulência NASA",
                                    "Modelo FEM de asa cantilever",
                                    "Códigos FFT em Python/MATLAB"
                                  ],
                                  "tips": [
                                    "Janela de Blackman para FFT reduzir vazamento espectral.",
                                    "Monitore truncagem modal com erro <5% RMS."
                                  ],
                                  "learningObjective": "Calcular respostas modais para cargas realistas em aeroespaciais.",
                                  "commonMistakes": [
                                    "Erro numérico em Duhamel sem quadratura adaptativa.",
                                    "Ignorar não-linearidades em grandes vibrações.",
                                    "Escala errada em PSD de turbulência."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validação, Síntese e Análise de Resultados",
                                  "subSteps": [
                                    "Compare resposta modal reduzida com solução full-order FEM.",
                                    "Calcule métricas: erro RMS, picos de deslocamento, acelerações.",
                                    "Analise sensibilidade a ζ_r e truncagem modal.",
                                    "Gere relatórios com plots de tempo/frequência e mapas de tensão.",
                                    "Discuta implicações para certificação aeronáutica (ex: FAR 25.305)."
                                  ],
                                  "verification": "Erro de modelo <2% em resposta dominante; convergência modal observada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Resultados full-order de solver dinâmico",
                                    "Ferramentas de pós-processamento como Paraview"
                                  ],
                                  "tips": [
                                    "Use MAC (Modal Assurance Criterion) para validar modos.",
                                    "Documente suposições para reprodutibilidade."
                                  ],
                                  "learningObjective": "Validar e interpretar resultados modais em contexto prático.",
                                  "commonMistakes": [
                                    "Comparar sem normalização de energia.",
                                    "Ignorar efeitos aerodinâmicos em aeroelasticidade.",
                                    "Concluir sem análise de incertezas."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma asa cantilever modelada por 1000 DOFs. Excitação harmônica em raiz simulando motor (Ω=50 Hz, F_0=10kN) e turbulência arbitrária (PSD von Karman). Calcule x_r(t) para 10 modos, sintetize u(tip) e verifique picos < limite de fadiga (0.5g).",
                              "finalVerifications": [
                                "Respostas modais capturam >95% da energia cinética da resposta full-order.",
                                "Funções de influência h_r(t) decaem corretamente com ζ_r.",
                                "Projeções modais Q_r(t) preservam equilíbrio de forças.",
                                "FRF mostra picos em ω_r com largura ~ζ_r.",
                                "Resposta a turbulência tem RMS condizente com espectro de entrada.",
                                "Síntese modal reconstrói deslocamentos com erro <1% em norma L2."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática das equações modais e funções H_r(Ω) (20%).",
                                "Correta implementação numérica de Duhamel/FFT sem artefatos (25%).",
                                "Validação quantitativa com métricas de erro (20%).",
                                "Interpretação física em contexto aeroespacial (15%).",
                                "Eficiência computacional (ordem reduzida viável) (10%).",
                                "Relatório claro com plots e conclusões (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformadas de Fourier e integrais de convolução.",
                                "Física: Dinâmica linear amortecida e superposição modal.",
                                "Engenharia Mecânica: Análise de vibrações e fadiga.",
                                "Ciência de Computação: Métodos numéricos e redução de modelo.",
                                "Aerodinâmica: Modelagem de cargas gust/turbulência."
                              ],
                              "realWorldApplication": "Em aeronaves, usado para prever vibrações de fuselagem por turbulência (certificação FAA), otimizar supressores de flutter em asas e estimar vida útil por fadiga em missões longas, reduzindo testes físicos caros."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.3.1",
                              "10.1.4.4.1.3"
                            ]
                          },
                          {
                            "id": "10.1.4.4.3.3",
                            "name": "Interpretação e Validação de Resultados Modais",
                            "description": "Interpretar frequências naturais, formas modais e participação modal, comparando com resultados analíticos ou experimentais em estruturas aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Extração e Visualização Inicial dos Resultados Modais",
                                  "subSteps": [
                                    "Abrir o arquivo de saída do solver MEF (ex: .rst no ANSYS ou .odb no Abaqus)",
                                    "Identificar e listar as primeiras 10-20 frequências naturais (Hz ou rad/s)",
                                    "Visualizar as formas modais animadas para os modos dominantes",
                                    "Extrair valores de participação modal (mass participation factors) por direção",
                                    "Exportar dados para planilha ou ferramenta de pós-processamento"
                                  ],
                                  "verification": "Verificar se as frequências estão ordenadas crescentemente e formas modais deformam logicamente sem anomalias numéricas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software MEF (ANSYS, Abaqus ou NASTRAN)",
                                    "Arquivo de resultados da análise modal",
                                    "Visualizador de pós-processamento"
                                  ],
                                  "tips": "Ajuste a escala de deformação para 10-100x para visualizar modos de alta frequência claramente.",
                                  "learningObjective": "Extrair e visualizar resultados modais de forma precisa e organizada.",
                                  "commonMistakes": [
                                    "Confundir modos rígidos (frequência zero) com elásticos",
                                    "Não verificar convergência do número de modos extraídos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Interpretação Física das Frequências Naturais e Formas Modais",
                                  "subSteps": [
                                    "Classificar cada modo como flexão, torção, extensão ou combinado baseado na visualização",
                                    "Relacionar frequências com rigidez e massa: f ∝ √(k/m)",
                                    "Analisar nodos e antinodos nas formas modais para prever comportamentos dinâmicos",
                                    "Identificar modos críticos (baixas frequências) suscetíveis a ressonância",
                                    "Documentar interpretações em tabela com descrições qualitativas"
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito o significado físico de pelo menos 3 modos principais.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Tabelas de resultados exportadas",
                                    "Referências teóricas de vibrações (ex: livros de Meirovitch)",
                                    "Ferramenta de plotagem (MATLAB ou Python)"
                                  ],
                                  "tips": "Compare formas modais com analogias simples como corda de violão para flexão.",
                                  "learningObjective": "Interpretar o significado físico das frequências e formas modais em contextos aeroespaciais.",
                                  "commonMistakes": [
                                    "Interpretar modos locais como globais",
                                    "Ignorar efeitos de contorno em estruturas complexas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Análise da Participação Modal",
                                  "subSteps": [
                                    "Calcular fatores de participação modal efetiva (MPF) para cada direção (X, Y, Z, Rx, Ry, Rz)",
                                    "Verificar se os primeiros modos capturam >90% da massa total",
                                    "Identificar modos com alta participação para resposta dinâmica",
                                    "Plotar espectro de participação cumulativa",
                                    "Avaliar completude da base modal para análise espectral"
                                  ],
                                  "verification": "Gráfico de participação cumulativa atinge 90% com <10 modos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha Excel ou script Python/MATLAB",
                                    "Dados de massa modal do solver"
                                  ],
                                  "tips": "Use logaritmo para escalas em plots de participação para modos altos.",
                                  "learningObjective": "Avaliar a representatividade dos modos na dinâmica estrutural.",
                                  "commonMistakes": [
                                    "Confundir participação modal com massa modal normalizada",
                                    "Não somar rotações e translações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validação Comparativa com Resultados Analíticos ou Experimentais",
                                  "subSteps": [
                                    "Obter resultados de referência: analíticos (ex: Euler-Bernoulli para vigas) ou experimentais (acelerômetros)",
                                    "Calcular erros percentuais: |f_num - f_ref| / f_ref * 100% para frequências e MAC para formas modais",
                                    "Plotar curvas de comparação (frequências vs. modo número)",
                                    "Analisar discrepâncias: atribuir a malha, condições de contorno ou amortecimento",
                                    "Gerar relatório com conclusões e recomendações de refinamento"
                                  ],
                                  "verification": "Erros médios <5% para primeiros 6 modos e MAC >0.9 para formas principais.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Dados analíticos/experimentais",
                                    "Software de cálculo (MATLAB para MAC - Modal Assurance Criterion)",
                                    "Templates de relatório"
                                  ],
                                  "tips": "Priorize validação dos modos mais baixos, pois são os mais críticos.",
                                  "learningObjective": "Validar numericamente resultados modais contra benchmarks confiáveis.",
                                  "commonMistakes": [
                                    "Usar referência inadequada (ex: viga livre vs. engastada)",
                                    "Ignorar normalização nas comparações de formas modais"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma modelagem MEF de uma asa cantilever de aeronave (viga de alumínio 2m x 0.2m x 0.1m), extraia os primeiros 6 modos: valide frequências de flexão (1º modo ~5Hz analítico) com erro <3%, interprete 2º modo como torção e confirme 95% participação com 10 modos via testes modais simulados.",
                              "finalVerifications": [
                                "Lista precisa das frequências, formas e participações para 10 modos.",
                                "Interpretação física correta de pelo menos 80% dos modos principais.",
                                "Erros de validação <5% em frequências e MAC >0.85 em formas.",
                                "Gráficos de comparação gerados e analisados.",
                                "Relatório identifica causas de discrepâncias e sugere melhorias.",
                                "Base modal captura >90% da massa em todas direções."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração e interpretação (90% correção).",
                                "Qualidade da análise de participação modal (cumulativa >90%).",
                                "Rigor na validação (erros quantificados e justificados).",
                                "Clareza visual em plots e tabelas.",
                                "Profundidade na discussão de implicações aeroespaciais.",
                                "Completude do relatório com recomendações acionáveis."
                              ],
                              "crossCurricularConnections": [
                                "Vibrações e Acústica: Teoria de frequências naturais.",
                                "Mecânica dos Materiais: Influência de propriedades em modos.",
                                "Controle e Dinâmica: Modos para síntese de controladores.",
                                "Aerodinâmica e Aeroelasticidade: Ressonância com fluxos.",
                                "Processamento de Sinais: Análise modal experimental."
                              ],
                              "realWorldApplication": "Na certificação de aeronaves (ex: Boeing 787), validar modos de asas e fuselagem contra testes modais para evitar flutter aeroelástico, otimizando peso e rigidez enquanto previne fadiga por vibrações operacionais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.5",
                "name": "Amortecimento de Rayleigh e Vibrações Aleatórias",
                "description": "Discute o modelo de amortecimento de Rayleigh e a análise de vibrações aleatórias em estruturas aeroespaciais.",
                "totalSkills": 47,
                "atomicTopics": [
                  {
                    "id": "10.1.5.1",
                    "name": "Modelo de Amortecimento de Rayleigh",
                    "description": "Formulação matemática do amortecimento proporcional baseado em matrizes de massa e rigidez para sistemas estruturais.",
                    "individualConcepts": [
                      {
                        "id": "57.1.1.1",
                        "name": "Formulação Matemática do Amortecimento de Rayleigh",
                        "description": "Definição e derivação da matriz de amortecimento proporcional C = αM + βK, onde M é a matriz de massa e K a matriz de rigidez, para sistemas estruturais multi-graus de liberdade.",
                        "specificSkills": [
                          {
                            "id": "57.1.1.1.1",
                            "name": "Identificar a forma geral do modelo de Rayleigh",
                            "description": "Reconhecer e descrever a estrutura da matriz de amortecimento proporcional como combinação linear das matrizes de massa e rigidez em equações de movimento dinâmicas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Equações de Movimento Dinâmicas Básicas",
                                  "subSteps": [
                                    "Estude a equação geral de movimento para sistemas multi-graus de liberdade: M ü + K u = F(t), onde M é matriz de massa, K rigidez, u deslocamento.",
                                    "Identifique os componentes: aceleração (ü), velocidade (não presente ainda), deslocamento (u) e forças externas.",
                                    "Esboce um sistema simples de 2 DOF (graus de liberdade) para visualizar M e K.",
                                    "Derive verbalmente o papel de cada matriz na dinâmica estrutural.",
                                    "Compare com equação escalar de um único DOF para analogia."
                                  ],
                                  "verification": "Escreva corretamente a equação sem amortecimento e rotule cada termo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de dinâmica estrutural (ex: Clough & Penzien), papel e caneta, software MATLAB para matrizes exemplo.",
                                  "tips": "Use blocos de notas para desenhar matrizes 2x2 simples para massa e rigidez.",
                                  "learningObjective": "Compreender a base das equações de movimento sem amortecimento.",
                                  "commonMistakes": "Confundir matriz de massa (M) com rigidez (K); esquecer que são simétricas positivas definidas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Amortecimento Proporcional",
                                  "subSteps": [
                                    "Expanda a equação para incluir amortecimento: M ü + C u̇ + K u = F(t), destacando C como matriz de amortecimento.",
                                    "Discuta propriedades desejáveis de C: simétrica, positiva semi-definida, facilita modos normais.",
                                    "Explique amortecimento proporcional (Rayleigh): C é combinação linear de M e K.",
                                    "Liste vantagens: diagonalização simultânea com M e K, análise modal simplificada.",
                                    "Calcule um exemplo numérico simples com α=0, β=0 para verificar C=0."
                                  ],
                                  "verification": "Formule a equação completa com amortecimento e defina C verbalmente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Aulas gravadas sobre dinâmica (YouTube/Khan Academy), calculadora matricial.",
                                  "tips": "Lembre-se: amortecimento afeta velocidade (u̇), massa aceleração, rigidez deslocamento.",
                                  "learningObjective": "Reconhecer a necessidade e forma geral do amortecimento nas equações dinâmicas.",
                                  "commonMistakes": "Esquecer o ponto sobre u̇ (velocidade); assumir C arbitrária sem proporcionalidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar a Forma Geral do Modelo de Rayleigh",
                                  "subSteps": [
                                    "Apresente a fórmula exata: C = α M + β K, onde α e β são coeficientes escalares.",
                                    "Derive intuitivamente: α controla amortecimento em modos rígidos (baixa freq.), β em modos elásticos (alta freq.).",
                                    "Escreva para um sistema 2 DOF: compute C explicitamente com M e K exemplo.",
                                    "Verifique propriedades: simetria (herdada de M e K), definitude semi-positiva.",
                                    "Compare com amortecimento não-proporcional (não ortogonaliza modos)."
                                  ],
                                  "verification": "Escreva C = α M + β K e compute para matrizes dadas (ex: M=diag(1,2), K=toeplitz).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "MATLAB ou Python (NumPy) para multiplicação matricial, planilha Excel para verificação.",
                                  "tips": "Escolha α e β pequenos para testes iniciais; plote autovalores para visualização.",
                                  "learningObjective": "Reconhecer e formular precisamente a estrutura linear do modelo de Rayleigh.",
                                  "commonMistakes": "Inverter α e β; esquecer que é combinação linear (não produto). Escrever C = M K ou similar."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Descrever e Validar a Estrutura como Combinação Linear",
                                  "subSteps": [
                                    "Descreva verbalmente: 'matriz de amortecimento proporcional Rayleigh é superposição linear ponderada das matrizes de massa e rigidez'.",
                                    "Teste linearidade: verifique se C(α1,β1) + C(α2,β2) = C(α1+α2, β1+β2).",
                                    "Analise impacto: resolva autovalores do problema (K - λ M)^{-1} C para fator de amortecimento.",
                                    "Discuta limitações: assume modos normais não alterados.",
                                    "Aplique em contexto aeroespacial: amortecimento em asas para flutter."
                                  ],
                                  "verification": "Explique em 3 frases a estrutura e valide com cálculo numérico de C.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Artigo sobre Rayleigh damping (NASA tech reports), simulador ANSYS ou similar.",
                                  "tips": "Use diagrama Venn para mostrar sobreposição M e K em C.",
                                  "learningObjective": "Descrever com precisão a combinação linear e suas implicações dinâmicas.",
                                  "commonMistakes": "Descrever como 'multiplicação' em vez de 'combinação linear'; ignorar escalares α,β."
                                }
                              ],
                              "practicalExample": "Considere uma viga cantilever de aeronave com 2 DOF (translação e rotação na ponta). M = [[m,0],[0,I]], K = [[3EI/L^3, ...]], compute C = 0.1 M + 0.01 K. Simule resposta a pulso em MATLAB: observe decaimento modal proporcional.",
                              "finalVerifications": [
                                "Pode escrever C = α M + β K sem consultar notas?",
                                "Computa corretamente C para M e K 2x2 dados?",
                                "Explica diferença entre Rayleigh e amortecimento geral?",
                                "Identifica α como relacionado a frequência baixa e β alta?",
                                "Valida simetria e positividade de C?",
                                "Aplica em equação completa: M ü + C u̇ + K u = 0?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na fórmula (100% pontuação se exata)",
                                "Compreensão conceitual (explicação linear vs. não-linear)",
                                "Habilidade computacional (cálculo matricial correto)",
                                "Descrição verbal clara e concisa",
                                "Identificação de propriedades (simetria, definitude)",
                                "Aplicação contextual em aeroelasticidade"
                              ],
                              "crossCurricularConnections": [
                                "Matemática Linear: combinação linear de matrizes, autovalores",
                                "Física: osciladores amortecidos, modos normais",
                                "Engenharia Mecânica: análise modal, vibrações estruturais",
                                "Computação: simulações numéricas em MATLAB/ANSYS"
                              ],
                              "realWorldApplication": "No design de asas de aviões, o modelo de Rayleigh simplifica simulações de flutter e resposta vibracional, permitindo prever instabilidades aeroelásticas sem amortecimento complexo, usado pela Boeing e NASA em certificação de aeronaves."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.1.1.1.2",
                            "name": "Derivar a equação C = αM + βK",
                            "description": "Derivar matematicamente a expressão do amortecimento proporcional a partir das equações de Lagrange ou Hamilton para sistemas estruturais aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar as Equações de Lagrange para Sistemas Dinâmicos com Amortecimento",
                                  "subSteps": [
                                    "Relembre a formulação Lagrangiana geral: L = T - V, onde T é energia cinética e V é potencial.",
                                    "Escreva as equações de movimento: d/dt (∂L/∂q̇) - ∂L/∂q = Q, incorporando forças não conservativas Q para amortecimento.",
                                    "Defina as matrizes de massa M e rigidez K a partir de T = (1/2) q̇^T M q̇ e V = (1/2) q^T K q.",
                                    "Introduza o termo de dissipação de Rayleigh: R = (1/2) q̇^T C q̇, onde C é a matriz de amortecimento.",
                                    "Expresse a equação geral de movimento: M q̈ + C q̇ + K q = 0."
                                  ],
                                  "verification": "Confirme que você pode escrever corretamente a equação de movimento geral com todos os termos identificados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de dinâmica estrutural (ex: Clough & Penzien), caderno de anotações, calculadora simbólica (ex: Mathematica ou papel).",
                                  "tips": "Use notação matricial consistente para evitar confusões em sistemas multi-DOF.",
                                  "learningObjective": "Compreender a base Lagrangiana para derivar equações de movimento com amortecimento.",
                                  "commonMistakes": "Esquecer o fator 1/2 nas expressões de energia ou confundir forças generalizadas Q com termos dissipativos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir a Hipótese de Amortecimento Proporcional de Rayleigh",
                                  "subSteps": [
                                    "Discuta a suposição de Rayleigh: o amortecimento é proporcional à velocidade, com potência dissipada linear em q̇.",
                                    "Defina a taxa de dissipação: ∂R/∂q̇ = C q̇, derivando da forma quadrática R.",
                                    "Apresente a forma assumida: C = α M + β K, onde α e β são escalares constantes.",
                                    "Justifique fisicamente: α captura amortecimento inercial (massa), β captura amortecimento estrutural (rigidez).",
                                    "Verifique que essa forma mantém C simétrica e positiva definida para estabilidade."
                                  ],
                                  "verification": "Escreva a expressão de C e confirme sua simetria multiplicando por vetores de teste.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Referências em aeroelasticidade (ex: Bisplinghoff & Ashley), software de álgebra simbólica.",
                                  "tips": "Pense em α como relacionado a viscosidade e β a histerese em materiais.",
                                  "learningObjective": "Explicar e justificar a hipótese de proporcionalidade no modelo de Rayleigh.",
                                  "commonMistakes": "Confundir α com coeficiente de massa (é adimensional em algumas unidades) ou assumir C diagonal sem prova."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar Formalmente a Expressão C = αM + βK",
                                  "subSteps": [
                                    "Comece com as equações de Lagrange e substitua Q_i = - ∂R/∂q̇_i para cada grau de liberdade.",
                                    "Expanda ∂R/∂q̇ = C q̇, assumindo C linear em M e K.",
                                    "Use o modo normal de vibração: assuma q = φ sin(ωt), onde φ é vetor modal e ω frequência natural.",
                                    "Substitua na equação de movimento e isole termos para encontrar α = 2 ζ ω / ||φ||_M^2 e β = 2 ζ / (ω ||φ||_K^2), generalizando para escalares.",
                                    "Conclua que para amortecimento modal uniforme, C toma a forma proporcional."
                                  ],
                                  "verification": "Derive a equação final e verifique dimensionalmente: [C] = [α][M] + [β][K].",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel quadriculado, lápis, tabela de frequências modais de um sistema conhecido.",
                                  "tips": "Use expansão modal para simplificar; resolva para um caso 1-DOF primeiro.",
                                  "learningObjective": "Executar a derivação matemática passo a passo usando análise modal.",
                                  "commonMistakes": "Ignorar normalização modal (φ^T M φ = 1) ou erros em derivadas parciais de R."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a Derivação com um Exemplo Simples e Considerações Aeroespaciais",
                                  "subSteps": [
                                    "Considere um sistema 2-DOF (ex: viga com massas puntiformes simulando painel de asa).",
                                    "Calcule M e K explicitamente para o sistema.",
                                    "Aplique C = αM + βK e resolva autovalores para verificar decaimento modal.",
                                    "Discuta limitações: válido apenas se modos não acoplados fortemente.",
                                    "Relacione a estruturas aeroespaciais: essencial para modelar amortecimento em painéis de fuselagem ou asas."
                                  ],
                                  "verification": "Simule numericamente (ex: MATLAB) e confirme que autovalores têm parte real negativa uniforme.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB ou Python (SciPy) para eigenvalues, dados de um sistema 2-DOF padrão.",
                                  "tips": "Escolha valores realistas: m=1kg, k=1000N/m para escalas aeroespaciais.",
                                  "learningObjective": "Aplicar e validar a derivação em contexto prático aeroespacial.",
                                  "commonMistakes": "Escolher α/β inconsistentes dimensionalmente ou ignorar acoplamento não proporcional."
                                }
                              ],
                              "practicalExample": "Para um sistema massa-mola-amortecedor 2-DOF representando uma seção de asa: M = diag(1,1) kg, K = [[2,-1],[-1,1]] kN/m. Escolha α=0.1 s^-1, β=0.001 s. Calcule C e resolva M q̈ + C q̇ + K q = 0 para modos com fator de amortecimento ζ≈5% uniforme, simulando vibrações forçadas por turbulência.",
                              "finalVerifications": [
                                "Equação derivada bate com literatura padrão (ex: equação 5.2 em Fung's Aeroelasticity).",
                                "Dimensionalmente consistente: [α]=1/T, [β]=T.",
                                "Autovalores complexos com partes reais negativas iguais nos modos.",
                                "C simétrica e positiva semi-definida (autovalores ≥0).",
                                "Recupera caso 1-DOF: c = αm + βk.",
                                "Aplicável a sistemas aeroespaciais sem acoplamento forte."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação Lagrangiana (sem erros em parciais).",
                                "Correta justificativa da proporcionalidade via modos normais.",
                                "Validação numérica com exemplo 2-DOF (autovalores corretos).",
                                "Identificação de limitações e contexto aeroespacial.",
                                "Clareza na explicação oral/escrita dos passos.",
                                "Uso consistente de notação matricial."
                              ],
                              "crossCurricularConnections": [
                                "Física: Princípios variacionais de Lagrange aplicados a oscilações forçadas.",
                                "Engenharia Mecânica: Análise modal em vibrações estruturais.",
                                "Controle de Sistemas: Amortecimento em laços de feedback para estabilidade.",
                                "Matemática Computacional: Autovalores e decomposição modal."
                              ],
                              "realWorldApplication": "Em projetos aeroespaciais, como análise de flutter em asas de aeronaves (ex: Boeing 787), onde C = αM + βK simplifica simulações de vibrações aleatórias induzidas por rajadas, prevendo fadiga estrutural e garantindo segurança de voo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "57.1.1.1.1"
                            ]
                          },
                          {
                            "id": "57.1.1.1.3",
                            "name": "Aplicar o modelo em equações de movimento",
                            "description": "Formular as equações diferenciais de segundo ordem Mẍ + Cẋ + Kx = F incorporando o amortecimento de Rayleigh para excitações externas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a equação de movimento sem amortecimento",
                                  "subSteps": [
                                    "Identifique os parâmetros fundamentais: massa (M), rigidez (K) e deslocamento (x).",
                                    "Escreva a equação básica para um sistema de um grau de liberdade: Mẍ + Kx = 0.",
                                    "Estenda para múltiplos graus de liberdade usando matrizes: Mẍ + Kx = 0.",
                                    "Verifique as unidades: massa em kg, rigidez em N/m, aceleração em m/s².",
                                    "Discuta modos naturais de vibração livres."
                                  ],
                                  "verification": "A equação Mẍ + Kx = 0 está corretamente formulada com unidades consistentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis, calculadora, livro de dinâmica estrutural (ex: Clough & Penzien).",
                                  "tips": "Comece com um sistema SDOF (single degree of freedom) para simplicidade antes de generalizar.",
                                  "learningObjective": "Compreender a base da dinâmica linear sem dissipação de energia.",
                                  "commonMistakes": "Confundir notação vetorial com escalar; ignorar simetria das matrizes M e K."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o modelo de amortecimento de Rayleigh",
                                  "subSteps": [
                                    "Defina os coeficientes de Rayleigh: α (proporcional à massa) e β (proporcional à rigidez).",
                                    "Formule a matriz de amortecimento: C = αM + βK.",
                                    "Incorpore o termo de amortecimento na equação: Mẍ + Cẋ + Kx = 0.",
                                    "Calcule α e β a partir de frequências e razões de amortecimento conhecidas (ex: α = 2ζ1ω1 M, β = 2ζn/ωn K).",
                                    "Verifique propriedades: C deve ser simétrica e positiva definida."
                                  ],
                                  "verification": "Matriz C = αM + βK é simétrica e gera equação Mẍ + Cẋ + Kx = 0.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de álgebra simbólica (ex: MATLAB Symbolic ou Python SymPy), exemplos numéricos de matrizes.",
                                  "tips": "Use análise modal para escolher α e β que aproximem amortecimentos desejados em certos modos.",
                                  "learningObjective": "Dominar a formulação do amortecedor de Rayleigh como aproximação para dissipação.",
                                  "commonMistakes": "Escolher α e β arbitrários sem base modal; esquecer que C depende de M e K."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar excitações externas",
                                  "subSteps": [
                                    "Defina a força externa F(t) como vetor de cargas aplicadas (ex: F(t) = F0 sin(ωt) para harmônica).",
                                    "Adicione o termo forçante à equação completa: Mẍ + Cẋ + Kx = F(t).",
                                    "Considere excitações aleatórias ou distribuídas em estruturas aeroespaciais.",
                                    "Especifique condições iniciais: x(0) e ẋ(0).",
                                    "Non-dimensionalize a equação se necessário para análise."
                                  ],
                                  "verification": "Equação final inclui F(t) corretamente e atende às condições de contorno.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Planilha ou software (ex: Excel para SDOF, ANSYS para MDOF).",
                                  "tips": "Represente F(t) em termos de modos modais para simplificação.",
                                  "learningObjective": "Aplicar o modelo completo a sistemas forçados externamente.",
                                  "commonMistakes": "Colocar F(t) no lado esquerdo; ignorar dependência temporal de F."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e analisar a equação formulada",
                                  "subSteps": [
                                    "Resolva numericamente ou analiticamente para um caso simples (ex: SDOF harmônico).",
                                    "Verifique estabilidade: raízes do polinômio característico devem ter parte real negativa.",
                                    "Compare com amortecimento viscoso clássico (C constante).",
                                    "Avalie resposta em frequência para excitações aleatórias.",
                                    "Documente a formulação em relatório curto."
                                  ],
                                  "verification": "Simulação mostra decaimento oscilatório realista e resposta coerente com F(t).",
                                  "estimatedTime": "35 minutos",
                                  "materials": "MATLAB ou Python (SciPy para ODE solvers), gráficos de resposta.",
                                  "tips": "Use método de Runge-Kutta para integração numérica de EDOs.",
                                  "learningObjective": "Validar a formulação através de análise e simulação.",
                                  "commonMistakes": "Erros de sinal em ẋ; instabilidade numérica por passos de tempo grandes."
                                }
                              ],
                              "practicalExample": "Para uma asa simplificada modelada como viga cantilever com M = diag([1, 0.5]) kg, K = [[1000, -500], [-500, 500]] N/m, α=0.05 s⁻¹, β=0.001 s, e F(t) = [100 sin(10t), 0] N. Calcule C, formule Mẍ + Cẋ + Kx = F(t) e simule a resposta em flexão.",
                              "finalVerifications": [
                                "Equação tem forma exata Mẍ + (αM + βK)ẋ + Kx = F(t).",
                                "Matrizes M, C, K são simétricas e positivas definidas.",
                                "Unidades consistentes (ex: C em Ns/m).",
                                "Resposta simulada decai sem oscilações divergentes.",
                                "Coeficientes α e β aproximam amortecimentos modais alvo.",
                                "Condições iniciais zero produzem resposta coerente com F(t)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de C = αM + βK (100%).",
                                "Correção na inclusão de F(t) e termos diferenciais.",
                                "Validação numérica ou analítica com gráficos.",
                                "Explicação clara de escolhas de α e β.",
                                "Identificação de erros potenciais e limitações do modelo.",
                                "Aplicação correta a exemplo prático."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Solução de equações diferenciais lineares e análise modal.",
                                "Programação: Implementação em Python/MATLAB para simulações dinâmicas.",
                                "Física: Princípios de energia dissipada em vibrações forçadas.",
                                "Engenharia de Controle: Integração com controladores ativos de vibração."
                              ],
                              "realWorldApplication": "Em dinâmica aeroelástica, usado para modelar amortecimento em análises de flutter de asas de aeronaves e vibrações aleatórias em painéis de satélites sob turbulência atmosférica, permitindo previsões precisas de fadiga estrutural."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "57.1.1.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "57.1.1.2",
                        "name": "Determinação dos Parâmetros α e β",
                        "description": "Cálculo dos coeficientes de amortecimento α e β com base em fatores de amortecimento modais especificados para modos de vibração natural.",
                        "specificSkills": [
                          {
                            "id": "57.1.1.2.1",
                            "name": "Calcular α e β para um modo único",
                            "description": "Resolver o sistema de equações α + βω² = 2ξω para determinar α e β dado o fator de amortecimento ξ e frequência natural ω de um modo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a equação do amortecimento de Rayleigh para um modo único",
                                  "subSteps": [
                                    "Revise a fórmula do fator de amortecimento: ξ = α / (2ω) + (β ω) / 2",
                                    "Derive a equação rearranjada: multiplique por 2ω para obter α + β ω² = 2 ξ ω",
                                    "Reconheça que o sistema é subdeterminado para um modo (uma equação, duas variáveis)",
                                    "Identifique soluções comuns: β = 0 (amortecimento proporcional à massa) ou α = 0 (proporcional à rigidez)",
                                    "Anote a equação derivada e as soluções possíveis em um caderno"
                                  ],
                                  "verification": "Capaz de recitar a equação derivada e explicar a subdeterminação com um exemplo verbal.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Livro-texto de dinâmica de estruturas aeroespaciais",
                                    "Caderno e caneta",
                                    "Acesso a notas de aula sobre Rayleigh damping"
                                  ],
                                  "tips": "Visualize com um diagrama de um sistema de 1 grau de liberdade (DOF) com matriz de amortecimento [α M + β K].",
                                  "learningObjective": "Dominar a derivação matemática e limitações do modelo para um modo único.",
                                  "commonMistakes": [
                                    "Confundir ξ com o coeficiente de amortecimento absoluto c",
                                    "Esquecer o fator 2 na multiplicação por 2ω",
                                    "Ignorar que o sistema requer uma suposição adicional"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Coletar e validar os dados de entrada ξ e ω",
                                  "subSteps": [
                                    "Identifique o fator de amortecimento ξ (ex: 0.01-0.1 para estruturas aeroespaciais)",
                                    "Obtenha a frequência natural ω em rad/s do modo específico",
                                    "Confirme unidades: ξ adimensional, ω em rad/s (não Hz)",
                                    "Calcule ω² antecipadamente para facilitar cálculos",
                                    "Registre valores com pelo menos 3 casas decimais de precisão"
                                  ],
                                  "verification": "Dados anotados corretamente com unidades, e ω² computado sem erros aritméticos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Dados do problema ou saída de análise modal (ex: FEM)",
                                    "Calculadora",
                                    "Folha de papel quadriculado"
                                  ],
                                  "tips": "Use valores realistas de modos de asas de aeronaves: ω baixa para modos de flexão (~5-20 rad/s).",
                                  "learningObjective": "Preparar entradas precisas e validadas para evitar erros de propagação.",
                                  "commonMistakes": [
                                    "Converter incorretamente Hz para rad/s (fator 2π esquecido)",
                                    "Usar ξ irrealista (>0.2, causando superamortecimento)",
                                    "Não calcular ω² de antemão"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Selecionar método e calcular α e β",
                                  "subSteps": [
                                    "Escolha o método baseado no modo: β=0 para modos baixos (α = 2 ξ ω)",
                                    "Ou α=0 para modos altos (β = 2 ξ / ω)",
                                    "Justifique a escolha (ex: dados experimentais ou literatura)",
                                    "Realize o cálculo numérico: plugue ξ e ω nos fórmulas escolhidas",
                                    "Exemplo rápido: ξ=0.05, ω=10 → α=1.0 (se β=0)"
                                  ],
                                  "verification": "Resultados numéricos corretos e método documentado com justificativa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora científica ou planilha (Excel/Python)",
                                    "Tabela de frequências modais do problema"
                                  ],
                                  "tips": "Prefira β=0 para amortecimento uniforme em baixas frequências em aeroelasticidade.",
                                  "learningObjective": "Aplicar soluções analíticas para sistemas subdeterminados com escolhas engenheirísticas.",
                                  "commonMistakes": [
                                    "Erro aritmético em 2 ξ ω (esquecer o 2)",
                                    "Inverter as fórmulas de α e β",
                                    "Não justificar a escolha do método"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e documentar os parâmetros α e β",
                                  "subSteps": [
                                    "Substitua α e β na equação: confirme α + β ω² = 2 ξ ω (tolerância 10^{-6})",
                                    "Cheque unidades: α em s^{-1}, β em s",
                                    "Valide valores: positivos, consistentes com literatura (α ~0.1-10, β ~10^{-4}-0.1)",
                                    "Documente: método usado, valores, equação verificada",
                                    "Prepare resumo para input em software de análise (ex: NASTRAN)"
                                  ],
                                  "verification": "Verificação da equação passa e documentação completa.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Software de verificação simples (opcional: Python script)"
                                  ],
                                  "tips": "Sempre faça 'back-substitution' para capturar erros numéricos.",
                                  "learningObjective": "Assegurar confiabilidade dos parâmetros para uso em simulações reais.",
                                  "commonMistakes": [
                                    "Pular a verificação numérica",
                                    "Gerar valores negativos ou irreais",
                                    "Esquecer unidades nos resultados"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado ξ = 0.02 e ω = 25 rad/s para o primeiro modo de flexão de uma asa. Escolha β = 0 (proporcional à massa): α = 2 × 0.02 × 25 = 1.0 s⁻¹, β = 0 s. Verificação: 1.0 + 0 × 625 = 1.0; 2 × 0.02 × 25 = 1.0. Perfeito para modelagem inicial em flutter analysis.",
                              "finalVerifications": [
                                "Equação α + β ω² = 2 ξ ω satisfeita numericamente",
                                "Unidades corretas: α (s⁻¹), β (s)",
                                "Valores positivos e dentro de faixas típicas aeroespaciais",
                                "Método de solução justificado e documentado",
                                "Sem erros aritméticos detectados na verificação",
                                "Preparado para extensão a múltiplos modos"
                              ],
                              "assessmentCriteria": [
                                "Derivação da equação 100% correta",
                                "Cálculos numéricos com erro < 0.1%",
                                "Justificativa lógica e engenheirística da escolha de α/β",
                                "Verificações completas e documentadas",
                                "Clareza na apresentação dos resultados",
                                "Compreensão conceitual demonstrada"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sistemas lineares subdeterminados e álgebra",
                                "Física: Dinâmica de vibrações amortecidas",
                                "Engenharia Computacional: Parâmetros em solvers FEM (ANSYS/NASTRAN)",
                                "Análise Numérica: Otimização de damping em simulações modais"
                              ],
                              "realWorldApplication": "No design de estruturas aeroespaciais, como asas de aviões, α e β calibrados para modos únicos garantem que simulações de vibrações aleatórias e aeroelasticidade (ex: prevenção de flutter) reflitam o amortecimento material real, essencial para certificação FAA/EASA."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "57.1.1.1.1"
                            ]
                          },
                          {
                            "id": "57.1.1.2.2",
                            "name": "Determinar α e β para múltiplos modos",
                            "description": "Estimar α e β minimizando o erro entre fatores de amortecimento desejados para dois ou mais modos de vibração usando equações lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Modelo de Amortecimento de Rayleigh e Equações para Múltiplos Modos",
                                  "subSteps": [
                                    "Estude a forma geral do modelo de Rayleigh: c = α M + β K, onde M é massa e K é rigidez.",
                                    "Derive a relação para o fator de amortecimento modal: ξ_i ≈ α/(2 ω_i) + β ω_i / 2, para o modo i com frequência natural ω_i.",
                                    "Entenda que para N>2 modos, α e β são estimados minimizando o erro quadrático médio entre ξ_i desejados e preditos.",
                                    "Memorize a formulação em least squares: minimizar || A x - b ||^2, onde x = [α, β]^T, A tem colunas [1/(2ω_i), ω_i/2], b = ξ_i.",
                                    "Pratique reescrevendo as equações para 2 modos como sistema linear exato."
                                  ],
                                  "verification": "Escreva corretamente as equações ξ_i em termos de α, β e ω_i para 3 modos diferentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de dinâmica estrutural, notas de aula, calculadora.",
                                  "tips": "Use unidades consistentes (rad/s para ω_i) para evitar erros dimensionais.",
                                  "learningObjective": "Compreender a base teórica do modelo de Rayleigh e sua extensão para múltiplos modos via minimização de erro.",
                                  "commonMistakes": "Confundir α (proporcional a massa) com β (proporcional a rigidez); esquecer o fator 1/2 nas equações."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Coletar e Organizar Dados dos Modos de Vibração",
                                  "subSteps": [
                                    "Identifique os modos relevantes (ex: primeiros 3 modos de flexão de uma asa).",
                                    "Liste as frequências naturais ω_i (em rad/s) obtidas de análise modal.",
                                    "Defina os fatores de amortecimento desejados ξ_i baseados em requisitos de design (ex: ξ=0.02 para flutter suppression).",
                                    "Crie uma tabela com colunas: modo i, ω_i, ξ_i desejado.",
                                    "Verifique plausibilidade: ξ_i tipicamente 0.01-0.05 para estruturas aeroespaciais."
                                  ],
                                  "verification": "Crie uma tabela completa com pelo menos 3 modos, incluindo unidades e fontes dos dados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Resultados de análise modal (FEM software como NASTRAN), planilha Excel.",
                                  "tips": "Priorize modos com maior participação modal para precisão.",
                                  "learningObjective": "Selecionar dados relevantes e organizá-los para formulação do problema.",
                                  "commonMistakes": "Usar frequências em Hz em vez de rad/s; ignorar modos com ω_i muito próximos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular e Resolver o Sistema de Equações via Least Squares",
                                  "subSteps": [
                                    "Monte a matriz A (N x 2): coluna 1 = 1/(2 ω_i), coluna 2 = ω_i / 2.",
                                    "Vetor b = [ξ_1, ξ_2, ..., ξ_N]^T.",
                                    "Calcule a solução x = (A^T A)^{-1} A^T b para α e β.",
                                    "Use software se N grande: MATLAB (pinv(A)*b) ou Python (numpy.linalg.lstsq).",
                                    "Para N=2, resolva analiticamente para validação."
                                  ],
                                  "verification": "Compute α e β numericamente e compare com solução analítica para caso N=2.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora matricial, MATLAB/Python, papel para matrizes pequenas.",
                                  "tips": "Normalizar ω_i se escalas variam muito para estabilidade numérica.",
                                  "learningObjective": "Aplicar álgebra linear para estimar parâmetros minimizando erro.",
                                  "commonMistakes": "Erro na montagem de A (inverter ordem das colunas); não transpor A corretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar a Solução e Calcular Erros Residuais",
                                  "subSteps": [
                                    "Compute ξ_i preditos: ξ_pred,i = α/(2 ω_i) + β ω_i / 2.",
                                    "Calcule erros: e_i = |ξ_i desejado - ξ_pred,i| / ξ_i desejado * 100%.",
                                    "Verifique se erro médio < 10% e máximo < 20%; ajuste pesos se necessário.",
                                    "Plote ξ_des vs ξ_pred para visualização.",
                                    "Discuta implicações: se erro alto, considere modelo modal Rayleigh inadequado."
                                  ],
                                  "verification": "Gere relatório com tabela de erros e gráfico, confirmando convergência.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Software de plotagem (MATLAB, Excel), relatório template.",
                                  "tips": "Pese modos por energia modal para melhor ajuste.",
                                  "learningObjective": "Validar a estimativa e interpretar resultados no contexto de design.",
                                  "commonMistakes": "Ignorar erros em modos críticos; superestimar precisão sem checar resíduos."
                                }
                              ],
                              "practicalExample": "Para uma asa com 3 modos: ω1=10 rad/s ξ1=0.015, ω2=25 rad/s ξ2=0.02, ω3=50 rad/s ξ3=0.025. Monte A = [[0.05, 5], [0.02, 12.5], [0.01, 25]], b=[0.015,0.02,0.025]. Solução: α≈0.15, β≈0.0008. Erros: 2%, 1.5%, 3%.",
                              "finalVerifications": [
                                "α e β têm unidades corretas (s^-1 e s, respectivamente).",
                                "ξ_preditos casam com desejados dentro de 10% para todos os modos.",
                                "Solução é única e estável (cond(A^T A) < 1000).",
                                "Para N=2, matches solução analítica exata.",
                                "Gráfico de ξ vs ω mostra boa aproximação linear.",
                                "Relatório inclui tabela de dados, matrizes e erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão da formulação das equações (100% correto).",
                                "Correta montagem e resolução da matriz least squares.",
                                "Análise de erros residuais com interpretação qualitativa.",
                                "Uso apropriado de ferramentas numéricas sem erros de programação.",
                                "Clareza na documentação e plots gerados.",
                                "Identificação de limitações do modelo Rayleigh."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Sistemas sobredeterminado e least squares.",
                                "Otimização: Minimizadores quadráticos e gradiente.",
                                "Análise Numérica: Condicionamento de matrizes e estabilidade.",
                                "Engenharia Mecânica: Análise modal em FEM.",
                                "Controle de Sistemas: Modelagem de amortecimento em vibrações ativas."
                              ],
                              "realWorldApplication": "Em design de asas de aeronaves, determinar α e β garante fatores de amortecimento adequados nos modos críticos, prevenindo flutter aeroelástico e fadiga por vibrações, como no Boeing 787 onde modelos Rayleigh calibram dampers para certificação FAA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "57.1.1.2.1",
                              "57.1.1.1.3"
                            ]
                          },
                          {
                            "id": "57.1.1.2.3",
                            "name": "Avaliar limitações da aproximação",
                            "description": "Analisar como o modelo Rayleigh aproxima o amortecimento não-proporcional e identificar casos onde a proporcionalidade modal é válida.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos do Amortecimento Não-Proporcional e Aproximação de Rayleigh",
                                  "subSteps": [
                                    "Estudar a forma geral da matriz de amortecimento C em sistemas multi-graus de liberdade (MDOF).",
                                    "Explicar como o amortecimento não-proporcional viola a ortogonalidade modal.",
                                    "Derivar a aproximação de Rayleigh: C ≈ αM + βK, onde M é massa e K é rigidez.",
                                    "Identificar que α e β são escalares obtidos por ajuste modal.",
                                    "Comparar com amortecimento proporcional clássico."
                                  ],
                                  "verification": "Escrever um resumo de 200 palavras explicando a aproximação e suas premissas iniciais.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Dinâmica de Estruturas (Clough & Penzien)",
                                    "Notas de aula sobre ST-57",
                                    "Software MATLAB para visualização de matrizes"
                                  ],
                                  "tips": "Use diagramas para ilustrar a decomposição de C em componentes proporcionais.",
                                  "learningObjective": "Compreender a base matemática da aproximação de Rayleigh para amortecimento geral.",
                                  "commonMistakes": [
                                    "Assumir que Rayleigh é exato para todo amortecimento não-proporcional.",
                                    "Confundir α com coeficiente de massa Rayleigh em fluidos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Suposições de Proporcionalidade Modal",
                                  "subSteps": [
                                    "Definir proporcionalidade modal: vetores modais ortogonais em M, K e C.",
                                    "Examinar como α e β são calculados minimizando erro em frequências modais específicas.",
                                    "Calcular coeficientes de amortecimento modal ξ_i ≈ (α + β ω_i²)/(2 ω_i).",
                                    "Verificar condições para validade: baixa não-proporcionalidade (η < 0.2).",
                                    "Simular numericamente um caso simples de 2-DOF para validar."
                                  ],
                                  "verification": "Implementar equação de ξ_i em uma planilha e plotar para 3 modos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB ou Python (NumPy/SciPy)",
                                    "Exemplos de matrizes M, K, C de literatura aeroespacial"
                                  ],
                                  "tips": "Escolha frequências modais representativas (baixas e altas) para ajuste.",
                                  "learningObjective": "Identificar premissas matemáticas que sustentam a aproximação.",
                                  "commonMistakes": [
                                    "Ignorar variação de ξ_i com frequência.",
                                    "Usar apenas um modo para determinar α e β."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Casos de Validade e Limitações",
                                  "subSteps": [
                                    "Listar cenários válidos: estruturas com amortecimento viscosa leve e modos bem separados.",
                                    "Analisar limitações: alto amortecimento não-linear, modos próximos, acoplamento forte.",
                                    "Quantificar erro: calcular norma ||C - (αM + βK)|| e comparar com energia modal.",
                                    "Estudar casos de falha: torção-bending em asas ou vibrações aleatórias intensas.",
                                    "Comparar com métodos exatos como complex eigenvalue analysis."
                                  ],
                                  "verification": "Produzir tabela comparativa de erro para 3 cenários (válido, limite, inválido).",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Artigos sobre aeroelasticidade (ex: MSC Nastran docs)",
                                    "Solver de autovalores complexos em MATLAB"
                                  ],
                                  "tips": "Use métricas como perda de ortogonalidade modal para quantificar não-proporcionalidade.",
                                  "learningObjective": "Discernir contextos onde a aproximação é precisa versus inadequada.",
                                  "commonMistakes": [
                                    "Superestimar validade em estruturas compostas aeroespaciais.",
                                    "Negligenciar efeitos de não-linearidade implícitos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar Avaliação Crítica e Recomendações",
                                  "subSteps": [
                                    "Resumir limitações principais: precisão modal limitada a 2-3 primeiros modos.",
                                    "Propor critérios de aceitabilidade: erro < 10% em ξ_i para modos relevantes.",
                                    "Discutir alternativas: amortecimento modal direto ou state-space formulation.",
                                    "Aplicar a um exemplo aeroespacial e recomendar quando usar Rayleigh.",
                                    "Documentar relatório com gráficos de sensibilidade."
                                  ],
                                  "verification": "Redigir relatório de 1 página com conclusões e thresholds quantitativos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Templates de relatório técnico",
                                    "Ferramentas de plotagem (MATLAB/Excel)"
                                  ],
                                  "tips": "Priorize modos críticos para flutter ou fadiga em análises.",
                                  "learningObjective": "Desenvolver habilidade para avaliar criticamente aproximações em engenharia.",
                                  "commonMistakes": [
                                    "Recomendar Rayleigh universalmente sem verificação numérica."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma asa de aeronave modelada como viga cantilever 2-DOF (flexão-torção), determine α e β do amortecimento real medido via testes modais. Calcule ξ_i aproximados e compare com autovalores complexos exatos; identifique que a aproximação falha se o amortecimento torsional for 3x maior que flexural, levando a erro >20% no modo coupled.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 limitações chave da aproximação Rayleigh.",
                                "Calcular e interpretar coeficientes de não-proporcionalidade η para um exemplo dado.",
                                "Identificar corretamente 2 cenários aeroespaciais onde é válida e 2 onde não.",
                                "Produzir gráfico de ξ_i vs. ω_i mostrando discrepâncias.",
                                "Propor alternativa metodológica para caso de alta não-proporcionalidade.",
                                "Resumir relatório com thresholds quantitativos de validade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de α e β (equações corretas).",
                                "Identificação correta de suposições modais (ortogonalidade).",
                                "Quantificação de erros com métricas numéricas adequadas.",
                                "Análise contextualizada em aeroelasticidade.",
                                "Clareza na distinção entre casos válidos e limitações.",
                                "Uso de exemplos práticos e verificações independentes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de autovalores complexos e normas de matrizes.",
                                "Engenharia Estrutural: Modelagem modal em vibrações.",
                                "Controle de Sistemas: Representação state-space para amortecimento não-clássico.",
                                "Física: Princípios de dissipação de energia em osciladores.",
                                "Computação: Simulações numéricas em MATLAB/Python para análise dinâmica."
                              ],
                              "realWorldApplication": "No design de aeronaves, avaliar se a aproximação Rayleigh é adequada para prever damping em análises de flutter, evitando erros em certificação FAA que poderiam subestimar instabilidades em asas com materiais compostos de amortecimento anisotrópico."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "57.1.1.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "57.1.1.3",
                        "name": "Integração com Análise Modal",
                        "description": "Uso do amortecimento de Rayleigh na decomposição modal para solução de respostas dinâmicas em estruturas aeroespaciais.",
                        "specificSkills": [
                          {
                            "id": "57.1.1.3.1",
                            "name": "Verificar ortogonalidade modal com Rayleigh",
                            "description": "Demonstrar que as matrizes M, C e K são simultaneamente diagonalizáveis nos modos naturais quando C = αM + βK.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar ortogonalidade modal das matrizes de massa (M) e rigidez (K)",
                                  "subSteps": [
                                    "Recordar que os modos naturais φ_i satisfazem o problema de autovalores generalizado K φ_i = ω_i² M φ_i.",
                                    "Verificar que os modos são ortogonais com respeito a M: φ_i^T M φ_j = δ_ij (modal mass = 1 após normalização).",
                                    "Verificar ortogonalidade com respeito a K: φ_i^T K φ_j = ω_i² δ_ij.",
                                    "Normalizar os modos para que as massas modais sejam unitárias.",
                                    "Escrever as matrizes modais Φ = [φ_1, φ_2, ..., φ_n] e confirmar Φ^T M Φ = I e Φ^T K Φ = Ω² (diagonal)."
                                  ],
                                  "verification": "Confirmar que Φ^T M Φ = I e Φ^T K Φ é diagonal com autovalores ω_i².",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e lápis, software de análise modal (ex: MATLAB ou Python com SciPy), matrizes M e K de exemplo.",
                                  "tips": "Sempre normalize os modos primeiro para simplificar cálculos.",
                                  "learningObjective": "Entender as propriedades fundamentais de ortogonalidade em análise modal não amortecida.",
                                  "commonMistakes": "Esquecer de normalizar os modos, levando a massas modais não unitárias."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o modelo de amortecimento de Rayleigh C = αM + βK",
                                  "subSteps": [
                                    "Definir explicitamente C = α M + β K, onde α e β são coeficientes escalares determinados experimentalmente.",
                                    "Explicar que isso assume amortecimento proporcional, comum em estruturas aeroespaciais.",
                                    "Verificar dimensionalmente: α tem unidades de frequência, β de 1/frequência.",
                                    "Expressar C na base modal usando as ortogonalidades conhecidas.",
                                    "Preparar para computar φ_i^T C φ_j."
                                  ],
                                  "verification": "Escrever a equação C = α M + β K e confirmar unidades dos coeficientes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis, referências teóricas sobre Rayleigh damping.",
                                  "tips": "Lembre-se que α e β são positivos para amortecimento físico realista.",
                                  "learningObjective": "Compreender a forma assumida para o amortecimento proporcional.",
                                  "commonMistakes": "Confundir α e β com outros parâmetros, como coeficientes de viscosidade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar ortogonalidade de C com respeito aos modos naturais",
                                  "subSteps": [
                                    "Calcular φ_i^T C φ_j = φ_i^T (α M + β K) φ_j = α φ_i^T M φ_j + β φ_i^T K φ_j.",
                                    "Substituir as ortogonalidades: = α δ_ij + β ω_j² δ_ij.",
                                    "Para i ≠ j, δ_ij = 0, logo φ_i^T C φ_j = 0.",
                                    "Para i = j, φ_i^T C φ_i = α + β ω_i² (amortecimento modal γ_i).",
                                    "Concluir que Φ^T C Φ é diagonal com entradas γ_i = α + β ω_i²."
                                  ],
                                  "verification": "Mostrar explicitamente que φ_i^T C φ_j = 0 para i ≠ j e diagonal para i = j.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Calculadora ou MATLAB para verificação numérica, modos φ_i normalizados.",
                                  "tips": "Use a linearidade da multiplicação matricial para fatorar α e β.",
                                  "learningObjective": "Provar matematicamente a ortogonalidade de C nos modos naturais.",
                                  "commonMistakes": "Erro de índice ao substituir ω_j² em vez de ω_i² (deve ser simétrico)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir diagonalizabilidade simultânea de M, C e K",
                                  "subSteps": [
                                    "Resumir: Φ^T M Φ = I (diagonal), Φ^T C Φ = Γ (diagonal), Φ^T K Φ = Ω² (diagonal).",
                                    "Explicar que isso implica diagonalização simultânea pelas mesmas matrizes modais Φ.",
                                    "Discutir implicações: desacoplamento modal no espaço modal.",
                                    "Verificar numericamente com um exemplo pequeno.",
                                    "Generalizar para sistemas multi-graus de liberdade em aeroelasticidade."
                                  ],
                                  "verification": "Confirmar que todas as três matrizes são diagonalizadas por Φ.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software numérico (MATLAB), exemplo 2x2.",
                                  "tips": "Teste com valores numéricos para validar a prova analítica.",
                                  "learningObjective": "Reconhecer as condições para análise modal amortecida.",
                                  "commonMistakes": "Assumir ortogonalidade sem prova explícita."
                                }
                              ],
                              "practicalExample": "Considere um sistema 2DOF com M = [[2,0],[0,1]], K = [[3, -1],[-1,2]], resolva autovalores para φ1, φ2 normalizados. Defina α=0.1, β=0.01. Compute C = αM + βK, então Φ^T C Φ deve ser diagonal com γ1 ≈ 0.13, γ2 ≈ 0.14.",
                              "finalVerifications": [
                                "Φ^T M Φ = I (identidade).",
                                "Φ^T K Φ diagonal com ω_i².",
                                "φ_i^T C φ_j = 0 para i≠j.",
                                "γ_i = α + β ω_i² > 0 para todos i.",
                                "Transformação modal desacopla as equações de movimento.",
                                "Verificação numérica coincide com analítica."
                              ],
                              "assessmentCriteria": [
                                "Prova analítica correta usando ortogonalidades.",
                                "Cálculo explícito de φ_i^T C φ_j.",
                                "Normalização adequada dos modos.",
                                "Interpretação física do amortecimento modal.",
                                "Exemplo numérico validado.",
                                "Conclusão clara sobre diagonalizabilidade simultânea."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Diagonalização simultânea e autovalores generalizados.",
                                "Física: Princípios de vibrações amortecidas e modos normais.",
                                "Engenharia Aeroespacial: Análise de flutter e aeroelasticidade.",
                                "Programação Numérica: Implementação em MATLAB/Python para análise modal."
                              ],
                              "realWorldApplication": "Em projetos de asas de aeronaves, verifica-se ortogonalidade para desacoplar equações modais, permitindo simulações eficientes de vibrações sob cargas aerodinâmicas e predizer instabilidades como flutter."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "57.1.1.1.2",
                              "57.1.1.2.1"
                            ]
                          },
                          {
                            "id": "57.1.1.3.2",
                            "name": "Implementar análise modal com amortecimento",
                            "description": "Transformar equações acopladas em coordenadas modais desacopladas e resolver para resposta transitória ou harmônica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular equações de movimento com amortecimento de Rayleigh",
                                  "subSteps": [
                                    "Derivar as equações de movimento para um sistema multi-graus de liberdade (MDOF): M ü + C ú + K u = F(t)",
                                    "Definir o modelo de amortecimento de Rayleigh: C = α M + β K, onde α e β são coeficientes proporcionais",
                                    "Determinar valores de α e β a partir de razões de amortecimento modal conhecidas ou dados experimentais",
                                    "Verificar simetria e propriedades positivas definidas das matrizes M, C e K",
                                    "Escrever as equações acopladas explicitamente para um exemplo de 2-3 DOF"
                                  ],
                                  "verification": "Equações escritas corretamente e matrizes C proporcionais a M e K confirmadas por inspeção",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Software de álgebra simbólica como MATLAB/SymPy",
                                    "Notas sobre dinâmica estrutural",
                                    "Exemplo de estrutura aeroespacial simples"
                                  ],
                                  "tips": "Comece com um sistema pequeno (2 DOF) para validar conceitos antes de generalizar",
                                  "learningObjective": "Entender e formular o modelo matemático completo incluindo amortecimento proporcional",
                                  "commonMistakes": [
                                    "Confundir α e β (α para massa, β para rigidez)",
                                    "Esquecer de normalizar modos",
                                    "Assumir amortecimento não proporcional sem verificação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar análise modal para obter propriedades modais",
                                  "subSteps": [
                                    "Resolver o problema de autovalores generalizado: (K - ω² M) φ = 0 para frequências ω e modos φ",
                                    "Normalizar os modos modais: φᵀ M φ = 1 e computar φᵀ K φ = ω²",
                                    "Verificar ortogonalidade modal: φᵢᵀ M φⱼ = 0 e φᵢᵀ K φⱼ = 0 para i ≠ j",
                                    "Calcular fatores de amortecimento modal ξᵢ = (α / (2 ωᵢ)) + (β ωᵢ / 2)",
                                    "Armazenar matrizes modais Φ e frequências em vetores para uso posterior"
                                  ],
                                  "verification": "Frequências e modos satisfazem equações de autovalores e normalização verificada numericamente",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "MATLAB ou Python com NumPy/SciPy para eigen solvers",
                                    "Planilha para verificações manuais",
                                    "Referência: Clough & Penzien 'Dynamics of Structures'"
                                  ],
                                  "tips": "Use solvers numéricos robustos para sistemas reais; valide com soluções analíticas para 2 DOF",
                                  "learningObjective": "Computar modos e frequências corretamente para sistemas com amortecimento Rayleigh",
                                  "commonMistakes": [
                                    "Não normalizar modos corretamente levando a erros em transformações",
                                    "Ignorar verificação de ortogonalidade",
                                    "Usar autovalores errados devido a problemas de condicionamento"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Transformar equações para coordenadas modais desacopladas",
                                  "subSteps": [
                                    "Definir transformação modal: u = Φ q, onde q são coordenadas modais",
                                    "Substituir na equação original: Φᵀ M Φ q̈ + Φᵀ C Φ q̇ + Φᵀ K Φ q = Φᵀ F(t)",
                                    "Explorar propriedades modais para simplificar: q̈ᵢ + 2 ξᵢ ωᵢ q̇ᵢ + ωᵢ² qᵢ = Φᵢᵀ F(t)",
                                    "Confirmar que as equações estão desacopladas (diagonalizadas)",
                                    "Implementar numericamente a transformação e verificar diagonalidade de matrizes modais"
                                  ],
                                  "verification": "Matrizes modais de massa, rigidez e amortecimento são diagonais ou identidade",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Código MATLAB/Python para multiplicação matricial",
                                    "Ferramentas de plotagem para visualizar modos",
                                    "Exercícios de álgebra linear"
                                  ],
                                  "tips": "Visualize os modos deformados para intuição física da transformação",
                                  "learningObjective": "Aplicar transformação modal para desacoplar equações dinâmicas com amortecimento",
                                  "commonMistakes": [
                                    "Erro na transposição Φᵀ vs Φ",
                                    "Não computar cargas modais Φᵀ F corretamente",
                                    "Assumir desacoplamento sem amortecimento proporcional"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver equações modais para respostas transitória ou harmônica",
                                  "subSteps": [
                                    "Para resposta harmônica: assumir F(t) = F₀ e^{iΩt}, resolver qᵢ(t) = Hᵢ(Ω) Φᵢᵀ F₀ e^{iΩt}",
                                    "Calcular função de transferência modal Hᵢ(Ω) = 1 / (ωᵢ² - Ω² + 2 i ξᵢ ωᵢ Ω)",
                                    "Para transitória: usar integração numérica (Newmark, etc.) ou Duhamel para cada modo",
                                    "Superpor respostas modais: u(t) = Σ Φᵢ qᵢ(t)",
                                    "Plotar respostas no tempo/frequência e analisar amplificações"
                                  ],
                                  "verification": "Respostas modais convergem para solução original via recíproca modal",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "MATLAB ODE solvers ou SciPy integrate",
                                    "Ferramentas de FFT para análise harmônica",
                                    "Dados de excitação real como turbulência aeroelástica"
                                  ],
                                  "tips": "Comece com excitação harmônica unitária para validar antes de casos complexos",
                                  "learningObjective": "Resolver e interpretar respostas dinâmicas desacopladas no domínio modal",
                                  "commonMistakes": [
                                    "Erro de fase em respostas harmônicas",
                                    "Não truncar número de modos levando a ruído numérico",
                                    "Ignorar contribuições de modos residuais"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma asa simplificada modelada como viga de 2 DOF (flexão e torção), com M = diag([1,1]), K apropriada e C = 0.05 M + 0.1 K, aplique carga harmônica aerodinâmica F(t) = [10 sin(ωt), 5 sin(ωt)]. Compute frequências modais ~5-15 Hz, transforme, resolva q(t) e plote deslocamentos u(t) para ω próximo a ω₁, mostrando pico de ressonância atenuado pelo amortecimento.",
                              "finalVerifications": [
                                "Equações modais estão desacopladas e diagonais",
                                "Frequências e amortecimentos modais coincidem com formulações analíticas",
                                "Resposta total u(t) = Φ q(t) satisfaz equação original dentro de 1e-6 erro",
                                "Análise de sensibilidade a α/β mostra comportamento físico esperado",
                                "Plots de resposta mostram atenuação correta por ξᵢ"
                              ],
                              "assessmentCriteria": [
                                "Precisão das propriedades modais (erro <1% vs analítico)",
                                "Correta implementação da transformação modal e diagonalização",
                                "Validade numérica das soluções transitórias/harmônicas",
                                "Interpretação física das respostas (ressonância, atenuação)",
                                "Eficiência computacional (truncamento modal justificado)",
                                "Documentação clara de passos e verificações"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Problemas de autovalores generalizados e diagonalização",
                                "Programação Numérica: Solvers de EDO e análise modal em MATLAB/Python",
                                "Controle de Sistemas: Análise de frequências e estabilidade vibracional",
                                "Física Aplicada: Princípios de vibrações forçadas e amortecimento",
                                "Engenharia Aeroespacial: Modelagem de flutter e fadiga estrutural"
                              ],
                              "realWorldApplication": "Na certificação de aeronaves, essa análise prevê respostas vibracionais a cargas gust/turbulência, otimizando amortecedores e evitando flutter catastrófico, como no design de asas do Boeing 787 ou hélices de drones."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "57.1.1.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.2",
                    "name": "Equações de Movimento com Amortecimento de Rayleigh",
                    "description": "Derivação e solução das equações diferenciais lineares com amortecimento de Rayleigh em análise modal.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.2.1",
                        "name": "Modelo de Amortecimento de Rayleigh",
                        "description": "Definição e formulação do modelo de amortecimento proporcional de Rayleigh para sistemas multi-graus de liberdade em estruturas aeroespaciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.1.1",
                            "name": "Identificar a forma da matriz de amortecimento de Rayleigh",
                            "description": "Reconhecer e formular a matriz de amortecimento [C] = α[M] + β[K], onde α e β são coeficientes de massa e rigidez, e explicar sua proporcionalidade aos modos naturais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Matrizes de Massa e Rigidez em Dinâmica Estrutural",
                                  "subSteps": [
                                    "Estude a definição da matriz de massa [M], que representa a inércia distribuída na estrutura.",
                                    "Analise a matriz de rigidez [K], que captura as propriedades elásticas da estrutura.",
                                    "Identifique como [M] e [K] são usadas nas equações de movimento livres: [M]{ü} + [K]{u} = 0.",
                                    "Pratique montando [M] e [K] para um sistema de 2 graus de liberdade (2DOF).",
                                    "Verifique a simetria e propriedades positivas definidas de [M] e [K]."
                                  ],
                                  "verification": "Construa [M] e [K] para um sistema simples e confirme que satisfazem as propriedades esperadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Dinâmica Estrutural (ex: Chopra), software MATLAB ou Python para matrizes"
                                  ],
                                  "tips": "Use diagramas de elementos finitos para visualizar a origem física de [M] e [K].",
                                  "learningObjective": "Compreender o papel fundamental de [M] e [K] nas equações de vibração estrutural.",
                                  "commonMistakes": [
                                    "Confundir massa com rigidez; ignorar a simetria das matrizes."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Conceito de Amortecimento Proporcional",
                                  "subSteps": [
                                    "Defina amortecimento como dissipação de energia em vibrações estruturais.",
                                    "Explique amortecimento modal: taxas de amortecimento independentes para cada modo natural.",
                                    "Discuta por que o amortecimento não proporcional complica a análise modal.",
                                    "Apresente o modelo de Rayleigh como uma aproximação simples para amortecimento proporcional.",
                                    "Compare com outros modelos (ex: Cauchy, viscoso geral)."
                                  ],
                                  "verification": "Explique em suas palavras por que o amortecimento proporcional permite desacoplamento modal.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Vídeos tutoriais sobre vibrações amortecidas, notas de aula de Aeroelasticidade"
                                  ],
                                  "tips": "Pense em amortecimento como 'fricção interna' que varia com velocidade.",
                                  "learningObjective": "Reconhecer a necessidade e vantagens do amortecimento proporcional em análises dinâmicas.",
                                  "commonMistakes": [
                                    "Assumir que todo amortecimento é proporcional; confundir com amortecimento de Coulomb."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar a Forma da Matriz de Amortecimento de Rayleigh",
                                  "subSteps": [
                                    "Escreva a equação geral com amortecimento: [M]{ü} + [C]{u̇} + [K]{u} = 0.",
                                    "Apresente a forma de Rayleigh: [C] = α[M] + β[K].",
                                    "Derive intuitivamente: α contribui proporcionalmente à massa (amortecimento de baixa frequência), β à rigidez (alta frequência).",
                                    "Verifique que [C] é simétrica se [M] e [K] o forem.",
                                    "Substitua em uma equação de 1DOF para validar: c = αm + βk."
                                  ],
                                  "verification": "Escreva [C] para um sistema conhecido e confirme que é linear em [M] e [K].",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Folha de papel para derivações, calculadora matricial ou SymPy em Python"
                                  ],
                                  "tips": "Lembre-se: Rayleigh assume que o amortecimento é uma combinação linear das matrizes conhecidas.",
                                  "learningObjective": "Memorizar e reconhecer precisamente a forma [C] = α[M] + β[K].",
                                  "commonMistakes": [
                                    "Escrever [C] = α[K] + β[M] invertido; esquecer a simetria."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar Coeficientes e Proporcionalidade aos Modos Naturais",
                                  "subSteps": [
                                    "Defina α como coeficiente de massa (relacionado a modos de baixa frequência).",
                                    "Defina β como coeficiente de rigidez (modos de alta frequência).",
                                    "Mostre que as taxas de amortecimento ξ_i = (α / (2ω_i)) + (β ω_i / 2), proporcional aos modos.",
                                    "Calcule ξ para os primeiros modos de um sistema 2DOF.",
                                    "Discuta limitações: bom para estruturas leves, mas não para todas as frequências."
                                  ],
                                  "verification": "Calcule ξ para dois modos e grafique vs. frequência natural.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "MATLAB para autovalores, planilha Excel para cálculos manuais"
                                  ],
                                  "tips": "A curva de ξ(ω) é hiperbólica: mínima em ω = 1/√(αβ).",
                                  "learningObjective": "Entender como α e β garantem amortecimento modal proporcional.",
                                  "commonMistakes": [
                                    "Confundir α com rigidez; ignorar dependência em ω_i."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma viga cantilever modelada com 2 elementos finitos (2DOF), compute [M] e [K], escolha α=0.05 e β=0.001, forme [C], e resolva os autovalores para verificar que os modos têm amortecimento real positivo e desacoplado.",
                              "finalVerifications": [
                                "Escreve corretamente [C] = α[M] + β[K] sem hesitação.",
                                "Explica o papel físico de α e β em termos de frequência.",
                                "Deriva ξ_i para um modo genérico.",
                                "Identifica limitações do modelo Rayleigh em um exemplo.",
                                "Aplica a forma em uma equação de movimento completa.",
                                "Distingue de outros modelos de [C]."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação de [C] (100% correto).",
                                "Compreensão conceitual de proporcionalidade modal (explicação clara).",
                                "Habilidade em calcular coeficientes e taxas de amortecimento.",
                                "Identificação correta de propriedades matriciais (simetria, definitude).",
                                "Aplicação prática em sistema simples sem erros.",
                                "Reconhecimento de limitações e contextos de uso."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Operações com matrizes e autovalores.",
                                "Física: Princípios de vibrações e dissipação de energia.",
                                "Engenharia Mecânica: Modelagem de elementos finitos.",
                                "Matemática Aplicada: Soluções de EDOs lineares com coeficientes constantes.",
                                "Controle de Sistemas: Amortecimento em estabilidade dinâmica."
                              ],
                              "realWorldApplication": "No design de asas de aeronaves, o modelo de Rayleigh é usado para prever amortecimento em análises de flutter, evitando vibrações destrutivas durante o voo, como no desenvolvimento de aviões comerciais pela Boeing."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.2",
                            "name": "Determinar coeficientes α e β",
                            "description": "Calcular os coeficientes de Rayleigh α e β a partir de frequências e razões de amortecimento modal especificadas para os primeiros modos de vibração.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o modelo de amortecimento de Rayleigh e equações modais",
                                  "subSteps": [
                                    "Estude a forma geral da matriz de amortecimento: C = α M + β K, onde M é massa e K é rigidez.",
                                    "Lembre que para o modo i, a razão de amortecimento modal é ξ_i = (α / (2 ω_i)) + (β ω_i / 2), com ω_i = 2π f_i.",
                                    "Identifique que para dois modos, isso forma um sistema linear de duas equações.",
                                    "Anote as frequências naturais f_1, f_2 e razões ξ_1, ξ_2 fornecidas.",
                                    "Converta frequências em angulares: ω_1 = 2π f_1, ω_2 = 2π f_2."
                                  ],
                                  "verification": "Confirme que você pode escrever as duas equações ξ_1 e ξ_2 em termos de α e β.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel ou caderno",
                                    "Calculadora básica",
                                    "Referência teórica do modelo de Rayleigh"
                                  ],
                                  "tips": "Desenhe um diagrama esquemático da estrutura vibrante para visualizar os modos.",
                                  "learningObjective": "Compreender a base teórica ligando parâmetros modais a α e β.",
                                  "commonMistakes": [
                                    "Confundir ω com f",
                                    "Esquecer o fator 2 nas equações de ξ"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Coletar e preparar dados de entrada dos modos de vibração",
                                  "subSteps": [
                                    "Liste os dados: f_1, ξ_1 para o primeiro modo; f_2, ξ_2 para o segundo modo.",
                                    "Calcule ω_1 = 2π f_1 e ω_2 = 2π f_2 com precisão.",
                                    "Verifique unidades consistentes (f em Hz, ξ adimensional).",
                                    "Forme os coeficientes da matriz: para eq1: 1/(2ω_1) para α, ω_1/2 para β; eq2 similar.",
                                    "Escreva o sistema em forma matricial: A [α; β] = [ξ_1; ξ_2]."
                                  ],
                                  "verification": "Tenha a matriz A (2x2) e vetor b = [ξ_1, ξ_2] prontos para resolução.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora científica",
                                    "Planilha Excel ou software como MATLAB para cálculos preliminares"
                                  ],
                                  "tips": "Use π ≈ 3.1416 e mantenha pelo menos 4 casas decimais.",
                                  "learningObjective": "Preparar dados modais de forma precisa para o sistema linear.",
                                  "commonMistakes": [
                                    "Usar f em rad/s ao invés de Hz",
                                    "Inverter ξ_1 e ξ_2"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver o sistema linear para determinar α e β",
                                  "subSteps": [
                                    "Use eliminação gaussiana ou fórmula de Cramer para resolver A [α; β] = b.",
                                    "Calcule determinante det(A) = (1/(2ω_1))(ω_2/2) - (ω_1/2)(1/(2ω_2)).",
                                    "Encontre α = (ξ_1 (ω_2/2) - ξ_2 (ω_1/2)) / det(A); similar para β.",
                                    "Alternativamente, use inversa de A ou solver numérico.",
                                    "Arredonde resultados com precisão adequada (ex: 3-4 casas decimais)."
                                  ],
                                  "verification": "Substitua α e β de volta nas equações originais e verifique se ξ_1 e ξ_2 são recuperados (erro < 1%).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou MATLAB/Python para resolução matricial",
                                    "Papel para cálculos manuais"
                                  ],
                                  "tips": "Se det(A) ≈ 0, os modos são mal condicionados; escolha outros modos.",
                                  "learningObjective": "Aplicar álgebra linear para extrair coeficientes do modelo.",
                                  "commonMistakes": [
                                    "Erro de sinal no determinante",
                                    "Dividir por zero"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e interpretar os coeficientes α e β",
                                  "subSteps": [
                                    "Confirme α > 0 e β > 0 (amortecimento físico positivo).",
                                    "Calcule ξ para um terceiro modo (se disponível) e compare com dados reais.",
                                    "Analise magnitudes: α domina baixas frequências, β altas.",
                                    "Discuta limitações do modelo de Rayleigh (aproximação para poucos modos).",
                                    "Documente valores finais com unidades (α em s⁻¹, β em s)."
                                  ],
                                  "verification": "Relatório com valores, verificação de retornos e interpretação física.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Gráfico de ξ vs ω para visualização",
                                    "Software de plotagem"
                                  ],
                                  "tips": "Plote ξ_calc vs ω para checar linearidade.",
                                  "learningObjective": "Garantir validade física e prática dos resultados.",
                                  "commonMistakes": [
                                    "Ignorar sinal negativo",
                                    "Esquecer unidades"
                                  ]
                                }
                              ],
                              "practicalExample": "Dados: Modo 1: f_1 = 10 Hz, ξ_1 = 0.02; Modo 2: f_2 = 30 Hz, ξ_2 = 0.01. ω_1 ≈ 62.83 rad/s, ω_2 ≈ 188.50 rad/s. Sistema: 0.00796 α + 31.42 β = 0.02; 0.00265 α + 94.25 β = 0.01. Solução: α ≈ 0.50 s⁻¹, β ≈ 0.00010 s. Verificação: ξ_1 calc = 0.02, ξ_2 calc = 0.01.",
                              "finalVerifications": [
                                "α e β são positivos e com unidades corretas (s⁻¹).",
                                "Substituição reversa recupera ξ_1 e ξ_2 com erro < 0.1%.",
                                "Coeficientes têm magnitudes físicas razoáveis para estruturas aeroespaciais.",
                                "Sistema é bem condicionado (det(A) ≠ 0).",
                                "Interpretação liga α a amortecimento massal e β a viscoso.",
                                "Resultados documentados em relatório claro."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nos cálculos (erro < 1%).",
                                "Correta formulação do sistema linear.",
                                "Validação física dos coeficientes.",
                                "Uso adequado de unidades e precisão decimal.",
                                "Clareza na documentação e interpretação.",
                                "Identificação de potenciais erros ou limitações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Resolução de sistemas lineares e álgebra matricial.",
                                "Física: Dinâmica de vibrações e amortecimento modal.",
                                "Engenharia: Modelagem em aeroelasticidade e controle de flutter.",
                                "Programação: Implementação em MATLAB/Python para solvers automáticos."
                              ],
                              "realWorldApplication": "Em projetos de asas de aeronaves, determinar α e β a partir de testes modais permite modelar amortecimento em simulações de flutter, previnindo falhas catastróficas como no caso histórico do Tacoma Narrows Bridge adaptado a aeroestruturas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.2.1.3",
                            "name": "Verificar ortogonalidade com modos naturais",
                            "description": "Demonstrar que o amortecimento de Rayleigh mantém a ortogonalidade das matrizes de massa e rigidez nos modos naturais, facilitando a análise modal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Ortogonalidade das Matrizes de Massa e Rigidez nos Modos Naturais",
                                  "subSteps": [
                                    "Recordar que os vetores modais φ_i e φ_j (i ≠ j) satisfazem φ_i^T M φ_j = 0 e φ_i^T K φ_j = 0.",
                                    "Verificar numericamente para um sistema simples de 2DOF, computando os produtos escalares.",
                                    "Explicar como essa ortogonalidade diagonaliza as matrizes no espaço modal.",
                                    "Derivar brevemente a equação de autovalores para o problema não amortecido."
                                  ],
                                  "verification": "Confirme que todos os produtos escalares φ_i^T M φ_j e φ_i^T K φ_j são zero para i ≠ j.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Matrizes M e K de exemplo, software MATLAB ou Python (NumPy/SciPy), calculadora matricial.",
                                  "tips": "Use vetores modais normalizados para simplificar cálculos.",
                                  "learningObjective": "Entender a base teórica da ortogonalidade no problema não amortecido.",
                                  "commonMistakes": "Confundir ortogonalidade com normalização; esquecer de normalizar os modos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Modelo de Amortecimento de Rayleigh",
                                  "subSteps": [
                                    "Definir a matriz de amortecimento C = α M + β K, onde α e β são coeficientes escalares.",
                                    "Explicar como α e β são tipicamente calibrados usando frequências e razões de amortecimento conhecidas.",
                                    "Mostrar a equação de movimento completa: M ü + C ú + K u = F.",
                                    "Discutir por que esse modelo é proporcional e modalmente diagonalizável.",
                                    "Calcular α e β para um exemplo de 2DOF usando duas frequências modais."
                                  ],
                                  "verification": "Escreva a expressão explícita de C e confirme que é uma combinação linear de M e K.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Fórmulas de Rayleigh damping, dados de frequências modais de exemplo, planilha ou código para cálculo de α/β.",
                                  "tips": "Escolha frequências modais próximas para melhor aproximação em faixas de interesse.",
                                  "learningObjective": "Compreender a forma proporcional do amortecimento de Rayleigh.",
                                  "commonMistakes": "Usar valores arbitrários para α/β sem calibração; assumir C simétrica sem verificação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar Preservação da Ortogonalidade com a Matriz C",
                                  "subSteps": [
                                    "Calcular φ_i^T C φ_j = φ_i^T (α M + β K) φ_j = α (φ_i^T M φ_j) + β (φ_i^T K φ_j).",
                                    "Substituir as ortogonalidades conhecidas: resulta em zero para i ≠ j.",
                                    "Verificar numericamente para o sistema 2DOF, computando φ_i^T C φ_j.",
                                    "Mostrar que no espaço modal, C se diagonaliza com os mesmos vetores φ.",
                                    "Comparar com amortecimento não proporcional, onde ortogonalidade é perdida."
                                  ],
                                  "verification": "Obtenha φ_i^T C φ_j = 0 numericamente e analiticamente para i ≠ j.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Vetores modais φ, matrizes M, K, C computada, software para multiplicação matricial.",
                                  "tips": "Implemente em código para automação e visualização de matrizes modais.",
                                  "learningObjective": "Provar que Rayleigh damping preserva ortogonalidade modal.",
                                  "commonMistakes": "Erros de transposição em produtos escalares; ignorar normalização dos modos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Implicações para Análise Modal",
                                  "subSteps": [
                                    "Transformar equações para coordenadas modais: cada modo desacopla.",
                                    "Derivar coeficientes de amortecimento modal ξ_n = (α / (2 ω_n)) + (β ω_n / 2).",
                                    "Discutir facilidades: solução uncoupled para respostas modais.",
                                    "Aplicar a um exemplo de vibração forçada, somando contribuições modais.",
                                    "Avaliar limitações do modelo Rayleigh em sistemas não clássicos."
                                  ],
                                  "verification": "Escreva as equações modais desacopladas e compute ξ_n para cada modo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Frequências ω_n, equações modais, simulador de resposta dinâmica (ex: MATLAB ode45).",
                                  "tips": "Plotar respostas modais para visualizar desacoplamento.",
                                  "learningObjective": "Aplicar a preservação de ortogonalidade na análise modal prática.",
                                  "commonMistakes": "Confundir amortecimento modal com global; superestimar precisão em modos altos."
                                }
                              ],
                              "practicalExample": "Considere uma viga cantilever de 2DOF com M = [[2,0],[0,1]] kg, K = [[1000, -500],[-500,500]] N/m. Modos: φ1 = [0.85, 0.53]^T, φ2 = [-0.53, 0.85]^T (normalizados). Calibre α=0.1, β=0.01 s. Verifique φ1^T C φ2 ≈ 0, facilitando análise modal de vibrações induzidas por turbulência.",
                              "finalVerifications": [
                                "Produtos escalares φ_i^T M φ_j = 0, φ_i^T K φ_j = 0 e φ_i^T C φ_j = 0 para i ≠ j.",
                                "Cálculo correto de α e β via calibração modal.",
                                "Equações modais desacopladas derivadas.",
                                "Amortecimentos modais ξ_n computados e razoáveis (ex: 1-5%).",
                                "Resposta modal simulada converge para solução total.",
                                "Discussão de uma limitação do modelo Rayleigh."
                              ],
                              "assessmentCriteria": [
                                "Precisão analítica na prova de ortogonalidade (equações corretas).",
                                "Correção numérica em exemplo 2DOF (erros < 1e-10).",
                                "Calibração adequada de α/β com justificativa.",
                                "Explicação clara das implicações para análise modal.",
                                "Identificação de erros comuns e como evitá-los.",
                                "Uso apropriado de ferramentas computacionais."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: produtos escalares, diagonalização e autovalores.",
                                "Análise Numérica: métodos modais e solução de EDOs desacopladas.",
                                "Engenharia Mecânica: modelagem de vibrações estruturais.",
                                "Física: princípios de osciladores amortecidos e modos normais."
                              ],
                              "realWorldApplication": "Na análise de aeroelasticidade de asas de aeronaves, o amortecimento de Rayleigh permite decoupling modal para prever flutter e respostas a rajadas, essencial para certificação de segurança pela FAA, reduzindo tempo computacional em simulações FEM."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.2",
                        "name": "Derivação das Equações de Movimento",
                        "description": "Obtenção das equações diferenciais lineares de movimento para sistemas estruturais com amortecimento de Rayleigh usando princípios variacionais.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.2.1",
                            "name": "Formular equações via Princípio de Lagrange",
                            "description": "Derivar as equações [M]{¨x} + [C]{˙x} + [K]{x} = {F(t)} incorporando o amortecimento de Rayleigh na função dissipativa de Rayleigh.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir as Funções Energéticas: Cinética (T), Potencial (V) e Dissipativa (R)",
                                  "subSteps": [
                                    "Expresse a energia cinética T como T = (1/2) {˙x}^T [M] {˙x}, onde [M] é a matriz de massa.",
                                    "Defina a energia potencial V como V = (1/2) {x}^T [K] {x}, assumindo forças elásticas lineares.",
                                    "Formule a função dissipativa de Rayleigh R = (1/2) {˙x}^T [C] {˙x}, onde [C] é a matriz de amortecimento.",
                                    "Identifique as coordenadas generalizadas q_i correspondentes ao vetor {x}.",
                                    "Verifique que todas as matrizes são simétricas e positivas definidas para estabilidade."
                                  ],
                                  "verification": "Funções T, V e R expressas corretamente em termos matriciais e escalares.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro de Dinâmica de Estruturas (ex: Clough & Penzien)",
                                    "Matriz de massa [M], rigidez [K] e amortecimento [C] de um exemplo simples",
                                    "Software simbólico como Mathematica ou SymPy"
                                  ],
                                  "tips": "Comece com um sistema de 2 graus de liberdade para visualizar melhor.",
                                  "learningObjective": "Compreender a representação energética do sistema com amortecimento de Rayleigh.",
                                  "commonMistakes": [
                                    "Confundir T com V",
                                    "Esquecer o fator 1/2 nas expressões quadráticas",
                                    "Usar [C] na energia potencial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Derivadas Parciais das Funções Energéticas",
                                  "subSteps": [
                                    "Compute ∂T/∂˙q_i = soma_j M_{ij} ˙q_j e ∂T/∂q_i = 0.",
                                    "Compute ∂V/∂q_i = soma_j K_{ij} q_j e ∂V/∂˙q_i = 0.",
                                    "Para R, calcule ∂R/∂˙q_i = soma_j C_{ij} ˙q_j (forças dissipativas Q_i^diss = -∂R/∂˙q_i).",
                                    "Derive d/dt (∂L/∂˙q_i) onde L = T - V, resultando em soma_j M_{ij} ¨q_j.",
                                    "Liste todas as derivadas em forma vetorial: ∂L/∂˙x = [M]{˙x}, ∂L/∂x = -[K]{x}."
                                  ],
                                  "verification": "Todas as derivadas parciais calculadas e expressas em forma matricial.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Folha de cálculo para derivadas",
                                    "Exemplo numérico com matrizes 2x2",
                                    "Calculadora simbólica"
                                  ],
                                  "tips": "Use a propriedade de simetria das matrizes para simplificar somas.",
                                  "learningObjective": "Dominar o cálculo das derivadas parciais para Lagrangiano estendido.",
                                  "commonMistakes": [
                                    "Erro no sinal das forças dissipativas (deve ser negativo)",
                                    "Confundir ˙q com q nas derivadas",
                                    "Ignorar a derivada temporal em d/dt(∂L/∂˙q)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o Princípio de Lagrange Estendido com Forças Não-Conservativas",
                                  "subSteps": [
                                    "Escreva a equação de Lagrange: d/dt(∂L/∂˙q_i) - ∂L/∂q_i = Q_i^{nc}, onde Q^{nc} inclui dissipativas e externas.",
                                    "Substitua: [M]{¨x} - (-[K]{x}) = -∂R/∂˙x + {F(t)}.",
                                    "Simplifique para [M]{¨x} + [C]{˙x} + [K]{x} = {F(t)}.",
                                    "Generalize para múltiplos graus de liberdade confirmando a forma matricial.",
                                    "Inclua forças externas {F(t)} como generalizadas."
                                  ],
                                  "verification": "Equação de Lagrange aplicada resultando na forma final desejada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Template de equação de Lagrange",
                                    "Exemplo de sistema com força externa harmônica"
                                  ],
                                  "tips": "Lembre-se: amortecimento Rayleigh é dissipativo, logo Q_diss = -∇_˙q R.",
                                  "learningObjective": "Aplicar corretamente o princípio variacional com dissipação.",
                                  "commonMistakes": [
                                    "Sinal errado no termo de amortecimento",
                                    "Esquecer d/dt na aceleração",
                                    "Confundir Q_nc com forças conservativas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Interpretar a Derivação Final",
                                  "subSteps": [
                                    "Compare a equação derivada [M]{¨x} + [C]{˙x} + [K]{x} = {F(t)} com a forma padrão.",
                                    "Teste com um sistema SDOF (1 grau de liberdade) para validar.",
                                    "Discuta propriedades: [C] proporcional a [M] + [K] no modelo Rayleigh clássico.",
                                    "Analise limites: sem amortecimento (C=0), sem massa, etc.",
                                    "Documente a derivação em um relatório curto."
                                  ],
                                  "verification": "Equação final matches exatamente e validada com caso simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplo SDOF: mÿ + cẏ + ky = F(t)",
                                    "Gráfico de resposta para verificação"
                                  ],
                                  "tips": "Use substituição numérica para checar.",
                                  "learningObjective": "Validar e interpretar a equação de movimento derivada.",
                                  "commonMistakes": [
                                    "Não testar com caso conhecido",
                                    "Ignorar proporcionalidade em Rayleigh",
                                    "Erros de transcrição matricial"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma viga aeroelástica com 2 modos modais. Use [M] = diag(1, 0.5), [K] = diag(100, 200), [C] = 0.1*[M] + 0.01*[K]. Derive as EOMs e simule resposta a uma força F(t) = sin(ωt) em um software como MATLAB.",
                              "finalVerifications": [
                                "Equação final é [M]{¨x} + [C]{˙x} + [K]{x} = {F(t)}.",
                                "Forças dissipativas derivadas corretamente como -[C]{˙x}.",
                                "Matrizes simétricas preservadas na derivação.",
                                "Validação com sistema de 1 DOF coincide com equação clássica.",
                                "Lagrangiano L = T - V correto e independe de R."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação de T, V e R (30%).",
                                "Correção nas derivadas parciais e aplicação de Lagrange (40%).",
                                "Validação e interpretação coerentes (20%).",
                                "Clareza na documentação e exemplo prático (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e métodos de Lagrange.",
                                "Física: Princípios energéticos em mecânica clássica.",
                                "Engenharia Mecânica: Análise modal e vibrações.",
                                "Controle Automático: Modelagem para sistemas com feedback."
                              ],
                              "realWorldApplication": "Na aeroelasticidade, essa derivação é essencial para modelar flutter em asas de aeronaves, onde o amortecimento de Rayleigh simula dissipação viscosa, permitindo previsão e supressão de instabilidades vibratórias em projetos da Boeing ou NASA."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.2.2.2",
                            "name": "Aplicar em sistemas multi-graus de liberdade",
                            "description": "Estender a derivação para estruturas aeroespaciais com múltiplos graus de liberdade, considerando análise pelo método dos elementos finitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Sistemas SDOF e Introduzir MDOF com Amortecimento Rayleigh",
                                  "subSteps": [
                                    "Relembrar as equações de movimento para sistemas de um grau de liberdade (SDOF) com amortecimento de Rayleigh: m ü + c ú + k u = F(t).",
                                    "Estender conceitualmente para múltiplos graus de liberdade (MDOF), definindo vetores de deslocamento {u}, velocidades {ú} e acelerações {ü}.",
                                    "Introduzir matrizes de massa [M], rigidez [K] e amortecimento Rayleigh [C] = α[M] + β[K].",
                                    "Explicar a importância do Rayleigh para estruturas aeroespaciais, onde α e β são calibrados via frequências/modais.",
                                    "Derivar a forma matricial geral: [M]{ü} + [C]{ú} + [K]{u} = {F(t)}."
                                  ],
                                  "verification": "Capacidade de escrever corretamente a equação matricial MDOF e explicar os parâmetros α e β.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Livro de Dinâmica de Estruturas (Clough & Penzien), notas de aula, MATLAB para simulações simples.",
                                  "tips": "Use analogias com molas-massa para visualizar acoplamento entre DOFs.",
                                  "learningObjective": "Compreender a extensão de SDOF para MDOF e o modelo Rayleigh proporcional.",
                                  "commonMistakes": "Confundir amortecimento Rayleigh com viscoso geral; assumir [C] diagonal sem justificação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Discretizar Estrutura Aeroespacial via Método dos Elementos Finitas (FEM)",
                                  "subSteps": [
                                    "Escolher elementos finitos adequados (ex: vigas Euler-Bernoulli para asas ou fuselagens).",
                                    "Definir nós e graus de liberdade locais (translacional e rotacional).",
                                    "Calcular matrizes elementares de massa [m_e], rigidez [k_e] e amortecimento [c_e] usando Rayleigh.",
                                    "Transformar para coordenadas globais via matriz de rotação [T].",
                                    "Montar matrizes globais [M], [K], [C] por superposição de elementos."
                                  ],
                                  "verification": "Montar manualmente matrizes para um sistema de 2 elementos com 3 DOFs.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Software ANSYS ou MATLAB com toolbox FEM, exemplos de malhas para asas.",
                                  "tips": "Comece com malhas grosseiras para validar antes de refinar.",
                                  "learningObjective": "Aplicar FEM para discretizar estruturas contínuas em MDOF.",
                                  "commonMistakes": "Erros na transformação de coordenadas locais-globais; esquecer condições de contorno."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar e Resolver Equações de Movimento para MDOF",
                                  "subSteps": [
                                    "Aplicar condições iniciais e de contorno nas matrizes montadas.",
                                    "Linearizar o sistema se necessário e formular problema de autovalores para modos normais.",
                                    "Resolver numericamente via integração temporal (ex: Newmark-β) ou decomposição modal.",
                                    "Implementar código para simular resposta livre/forçada com carga aerodinâmica simulada.",
                                    "Calcular α e β otimizados minimizando erro em frequências naturais."
                                  ],
                                  "verification": "Simulação reproduz resposta esperada para caso benchmark (ex: viga cantilever).",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "MATLAB/Octave scripts para FEM dinâmico, dados de propriedades de materiais aeroespaciais.",
                                  "tips": "Use decomposição modal para reduzir ordem em sistemas grandes.",
                                  "learningObjective": "Derivar e resolver equações dinâmicas MDOF com Rayleigh via FEM.",
                                  "commonMistakes": "Não normalizar modais; instabilidade numérica por timestep inadequado."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Resultados, Validar e Interpretar Vibrações",
                                  "subSteps": [
                                    "Plotar respostas temporais, espectros de frequência e modos de vibração.",
                                    "Comparar com soluções analíticas ou experimentais para validação.",
                                    "Avaliar efeitos do amortecimento Rayleigh em atenuação de vibrações.",
                                    "Identificar frequências críticas para aeroelasticidade (ex: risco de flutter).",
                                    "Documentar sensibilidade a parâmetros como α, β e malha."
                                  ],
                                  "verification": "Relatório com gráficos mostrando convergência FEM e atenuação correta.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Ferramentas de plotagem (MATLAB, Python Matplotlib), benchmarks de literatura.",
                                  "tips": "Verifique simetria das matrizes [M] e [K] para detecção de erros.",
                                  "learningObjective": "Interpretar análises dinâmicas em contextos aeroespaciais.",
                                  "commonMistakes": "Ignorar modos rígidos; superestimar amortecimento sem calibração."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar a Caso Prático e Otimizar",
                                  "subSteps": [
                                    "Modelar uma estrutura real (ex: asa simplificada com 10 DOFs).",
                                    "Simular vibrações sob excitação aleatória (turbulência).",
                                    "Otimizar α e β para matching com dados modais experimentais.",
                                    "Avaliar impacto em fadiga estrutural.",
                                    "Gerar relatório com recomendações de design."
                                  ],
                                  "verification": "Modelo prediz corretamente frequências/modais de um caso conhecido.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Dados experimentais de asas (NASA relatórios), software de otimização.",
                                  "tips": "Itere malha até convergência em 5% das frequências.",
                                  "learningObjective": "Integrar análise MDOF em fluxos de design aeroespacial.",
                                  "commonMistakes": "Sobremodelagem levando a tempo computacional excessivo."
                                }
                              ],
                              "practicalExample": "Modelar uma viga cantilever representando seção de asa com 4 elementos finitos (8 DOFs), aplicar amortecimento Rayleigh calibrado para frequências 1ª e 2ª modais, simular resposta a pulso aerodinâmico e verificar atenuação em 3 ciclos.",
                              "finalVerifications": [
                                "Matrizes [M], [K], [C] são simétricas e positivas definidas.",
                                "Frequências naturais convergem com refinamento de malha.",
                                "Resposta temporal mostra decaimento exponencial correto pelo Rayleigh.",
                                "Modos de vibração coincidem com soluções analíticas em 5%.",
                                "Simulação sob carga aleatória gera PSD compatível com teoria.",
                                "Parâmetros α e β produzem fator de amortecimento realista (ζ ≈ 0.02-0.05)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação matricial (sem erros algébricos).",
                                "Correta implementação FEM com convergência demonstrada.",
                                "Calibração adequada de Rayleigh via modais.",
                                "Interpretação física dos resultados (ex: implicações aeroelásticas).",
                                "Eficiência computacional (tempo de simulação razoável).",
                                "Relatório claro com gráficos e conclusões acionáveis."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (autovalores, decomposição modal).",
                                "Programação: Implementação numérica em MATLAB/Python.",
                                "Física: Mecânica clássica e ondas em contínuos.",
                                "Engenharia de Materiais: Propriedades para [M] e [K].",
                                "Controle de Sistemas: Amortecimento ativo vs. passivo Rayleigh."
                              ],
                              "realWorldApplication": "Análise de vibrações em asas de aeronaves para prevenir flutter crítico, otimização de amortecedores em satélites ou hélices de turbinas eólicas aeroespaciais, integrando com certificação FAA/NASA via simulações FEM dinâmicas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.3",
                        "name": "Solução das Equações em Análise Modal",
                        "description": "Resolução das equações de movimento desacopladas utilizando coordenadas modais para resposta dinâmica em estruturas aeroespaciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.3.1",
                            "name": "Realizar transformação modal",
                            "description": "Transformar as equações acopladas em coordenadas modais {x} = [Φ]{q}, resultando em equações desacopladas para cada modo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Obter a matriz de modos modais [Φ]",
                                  "subSteps": [
                                    "Resolver o problema de autovalores generalizado (K - ω²M)φ = 0 para obter frequências naturais ω_i e autovetores φ_i",
                                    "Extrair os autovetores correspondentes para cada modo relevante (geralmente os primeiros n modos)",
                                    "Montar a matriz [Φ] com os autovetores como colunas: [Φ] = [φ_1, φ_2, ..., φ_n]",
                                    "Verificar se os modos são suficientes para representar o movimento (número de graus de liberdade)",
                                    "Documentar as frequências modais ω_i associadas"
                                  ],
                                  "verification": "Conferir se [Φ] satisfaz [K]{φ_i} = ω_i² [M]{φ_i} para cada i",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Calculadora matricial ou software como MATLAB/Python (NumPy/SciPy)",
                                    "Matrizes de massa [M] e rigidez [K] do sistema",
                                    "Papel e lápis para sistemas pequenos"
                                  ],
                                  "tips": "Comece com sistemas de baixa dimensionalidade (2-3 DOF) para prática manual antes de software",
                                  "learningObjective": "Compreender a extração de modos modais a partir das matrizes de massa e rigidez",
                                  "commonMistakes": [
                                    "Usar autovalores em vez de autovetores",
                                    "Inverter colunas/linhas na montagem de [Φ]",
                                    "Ignorar modos rígidos (ω=0)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Normalizar a matriz de modos [Φ]",
                                  "subSteps": [
                                    "Escalonar cada autovetor φ_i para que {φ_i}^T [M] {φ_i} = 1 (normalização em massa)",
                                    "Verificar ortogonalidade modal: {φ_i}^T [M] {φ_j} = 0 para i ≠ j e {φ_i}^T [K] {φ_j} = 0 para i ≠ j",
                                    "Aplicar normalização em massa seguida de rigidez se necessário para amortecimento de Rayleigh",
                                    "Re-montar [Φ] com os autovetores normalizados",
                                    "Confirmar propriedades: [Φ]^T [M] [Φ] = [I] e [Φ]^T [K] [Φ] = [Λ] (diagonal)"
                                  ],
                                  "verification": "Calcular [Φ]^T [M] [Φ] e verificar se resulta na identidade [I]",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de álgebra linear (MATLAB eig ou equivalente)",
                                    "Matrizes [M] e [K] normalizadas"
                                  ],
                                  "tips": "Use funções built-in como 'eig' no MATLAB com opção de normalização modal",
                                  "learningObjective": "Dominar a normalização modal para garantir propriedades ortogonais",
                                  "commonMistakes": [
                                    "Normalizar em rigidez em vez de massa",
                                    "Esquecer ortogonalidade para amortecimento proporcional",
                                    "Não verificar simetria das matrizes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e aplicar a transformação de coordenadas {x} = [Φ]{q}",
                                  "subSteps": [
                                    "Escrever a transformação cinemática: deslocamentos físicos {x} em termos de coordenadas modais {q}",
                                    "Derivar velocidades e acelerações: {ẋ} = [Φ]{q̇} e {ẍ} = [Φ]{q̈}",
                                    "Substituir nas equações originais de movimento: [M]{ẍ} + [C]{ẋ} + [K]{x} = {F}",
                                    "Obter a forma transformada: [Φ]^T [M] [Φ] {q̈} + [Φ]^T [C] [Φ] {q̇} + [Φ]^T [K] [Φ] {q} = [Φ]^T {F}",
                                    "Simplificar usando ortogonalidade: [I] {q̈} + [Φ]^T [C] [Φ] {q̇} + [Λ] {q} = {Q} onde {Q} = [Φ]^T {F}"
                                  ],
                                  "verification": "Verificar se as matrizes de massa e rigidez se tornam diagonal/identidade após transformação",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Equações de movimento originais com [C] = α[M] + β[K]",
                                    "Bloco de notas ou software simbólico (SymPy)"
                                  ],
                                  "tips": "Mantenha notação consistente: use subscritos para modais",
                                  "learningObjective": "Aplicar transformação modal para converter coordenadas físicas em modais",
                                  "commonMistakes": [
                                    "Esquecer de premultiplicar por [Φ]^T",
                                    "Não derivar corretamente acelerações",
                                    "Confundir {q} com {x}"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar equações desacopladas para cada modo",
                                  "subSteps": [
                                    "Para amortecimento de Rayleigh [C] = α[M] + β[K], calcular [Φ]^T [C] [Φ] = α[I] + β[Λ] (diagonal)",
                                    "Escrever equação para o modo i: q̈_i + (α + β ω_i²) q̇_i + ω_i² q_i = Q_i",
                                    "Identificar coeficientes modais: ω_i (frequência), 2ζ_i ω_i = α + β ω_i² (amortecimento)",
                                    "Verificar desacoplamento: matriz de amortecimento modal é diagonal",
                                    "Expressar força modal Q_i = {φ_i}^T {F}"
                                  ],
                                  "verification": "Confirmar que cada equação modal é do tipo escalar SDOF desacoplada",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Fórmulas de Rayleigh para α e β",
                                    "Exemplo numérico com valores específicos"
                                  ],
                                  "tips": "Lembre-se: Rayleigh garante proporcionalidade apenas se α e β constantes",
                                  "learningObjective": "Obter equações independentes para análise modal",
                                  "commonMistakes": [
                                    "Assumir amortecimento não-proporcional",
                                    "Erro no cálculo de coeficientes modais",
                                    "Ignorar contribuições de força modal"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e interpretar as equações modais",
                                  "subSteps": [
                                    "Comparar respostas modais com solução original para excitação simples",
                                    "Calcular fatores de amplificação modal e razões de amortecimento ζ_i",
                                    "Discutir contribuições de cada modo à resposta total",
                                    "Verificar limites: resposta estática (q̇=q̈=0) e resposta livre",
                                    "Documentar processo completo em relatório"
                                  ],
                                  "verification": "Simular numericamente e comparar {x} = [Φ]{q} com solução direta",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de simulação (MATLAB ode45 ou equivalente)",
                                    "Dados de entrada do exemplo"
                                  ],
                                  "tips": "Use plots de modos para visualização intuitiva",
                                  "learningObjective": "Interpretar resultados modais e validar transformação",
                                  "commonMistakes": [
                                    "Sobrestimar modos superiores",
                                    "Não normalizar forças modais",
                                    "Ignorar acoplamento residual"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um sistema 2DOF com m1=m2=1 kg, k1=k2=1 N/m, k_c=0.5 N/m, α=0.1, β=0.01: Calcule [M], [K], resolva autovalores para obter [Φ], normalize, aplique transformação e derive q̈1 + 0.12 q̇1 + ω1² q1 = Q1 e similar para modo 2. Verifique desacoplamento.",
                              "finalVerifications": [
                                "Matriz [Φ] normalizada corretamente com [Φ]^T[M][Φ]=[I]",
                                "Equações modais desacopladas obtidas para todos os modos",
                                "Coeficientes de amortecimento modal consistentes com Rayleigh",
                                "Resposta modal reproduz a resposta física via {x}=[Φ]{q}",
                                "Forças modais Q_i calculadas corretamente",
                                "Sem acoplamento residual nas matrizes transformadas"
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de modos e normalização (90%+ correto)",
                                "Correta derivação da transformação e simplificação (passos lógicos claros)",
                                "Identificação precisa de propriedades modais (ω_i, ζ_i)",
                                "Validação numérica com exemplo prático",
                                "Explicação conceitual da desacoplamento",
                                "Uso adequado de ferramentas e documentação"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Resolução de problemas de autovalores generalizados",
                                "Física: Teoria de vibrações livres e forçadas",
                                "Programação: Implementação numérica em MATLAB/Python para análise modal",
                                "Engenharia Mecânica: Modelagem de estruturas multi-DOF",
                                "Controle de Sistemas: Decoplamento para design de controladores modais"
                              ],
                              "realWorldApplication": "Na análise de vibrações de alas de aeronaves ou fuselagens, a transformação modal permite simular respostas a turbulência ou manobras, prevendo flutter aeroelástico e otimizando design para segurança e fadiga."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.2.1",
                              "10.1.5.2.1.3"
                            ]
                          },
                          {
                            "id": "10.1.5.2.3.2",
                            "name": "Resolver equações modais independentes",
                            "description": "Solucionar as equações diferenciais escalares ¨q_r + 2ζ_r ω_r ˙q_r + ω_r² q_r = Q_r(t) para cada modo r, obtendo a resposta modal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e preparar os parâmetros modais da equação",
                                  "subSteps": [
                                    "Extraia os parâmetros do modo r: frequência natural ω_r, fator de amortecimento ζ_r e força modal Q_r(t) da análise modal prévia.",
                                    "Verifique se a equação está na forma padrão: ¨q_r + 2ζ_r ω_r ˙q_r + ω_r² q_r = Q_r(t).",
                                    "Defina condições iniciais: q_r(0) e ˙q_r(0), se fornecidas.",
                                    "Escolha o tipo de excitação Q_r(t) (ex: degrau, harmônica, aleatória) para guiar o método de solução.",
                                    "Anote unidades consistentes (ex: rad/s para ω_r)."
                                  ],
                                  "verification": "Lista completa de parâmetros anotada com valores numéricos ou expressões simbólicas corretas.",
                                  "estimatedTime": "0.5 hours",
                                  "materials": [
                                    "Papel e caneta ou software simbólico como Mathematica/MATLAB",
                                    "Dados modais do problema (modos, frequências)"
                                  ],
                                  "tips": "Sempre normalize unidades para evitar erros dimensionais; use subscritos r consistentemente.",
                                  "learningObjective": "Compreender os componentes essenciais da equação modal independente.",
                                  "commonMistakes": [
                                    "Confundir ζ_r com coeficiente de amortecimento absoluto",
                                    "Ignorar dependência temporal em Q_r(t)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Resolver a solução homogênea da equação",
                                  "subSteps": [
                                    "Escreva a equação homogênea: ¨q_r + 2ζ_r ω_r ˙q_r + ω_r² q_r = 0.",
                                    "Calcule as raízes da equação característica: s = [-ζ_r ω_r ± ω_r √(1 - ζ_r²)].",
                                    "Determine o regime: subamortecido (ζ_r < 1), crítico (ζ_r = 1) ou superamortecido (ζ_r > 1).",
                                    "Escreva a solução geral q_h(t): combinação de exponenciais ou seno/cosseno com decaimento.",
                                    "Verifique limites especiais (ex: sem amortecimento ζ_r=0)."
                                  ],
                                  "verification": "Solução homogênea q_h(t) que satisfaz a equação homogênea quando derivadas substituídas.",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Calculadora científica",
                                    "Tabelas de soluções de EDOs de 2ª ordem"
                                  ],
                                  "tips": "Use d = √(1 - ζ²) para frequência amortecida; memorize formas padrão para agilizar.",
                                  "learningObjective": "Dominar a solução transitória da equação do oscilador amortecido.",
                                  "commonMistakes": [
                                    "Erro no sinal das raízes (sempre parte real negativa)",
                                    "Confundir ω_d com ω_r"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar a solução particular para Q_r(t)",
                                  "subSteps": [
                                    "Analise a forma de Q_r(t): harmônica (Q_0 cos(Ωt)), degrau, impulso, etc.",
                                    "Aplique método apropriado: suposição estacionária para harmônica (q_p = D cos(Ωt + φ)), convolução de Duhamel para geral.",
                                    "Substitua q_p na equação e resolva para coeficientes (ex: módulo D e fase φ).",
                                    "Para Q_r(t) harmônica: D = Q_0 / √[(ω_r² - Ω²)² + (2ζ_r ω_r Ω)²].",
                                    "Valide solução particular não contendo termos homogêneos."
                                  ],
                                  "verification": "q_p(t) que, quando ¨q_p + 2ζω ˙q_p + ω² q_p = Q_r(t), equilibra exatamente.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "MATLAB ou Python (SymPy/Scipy) para soluções simbólicas/numericas",
                                    "Exemplos de forcing functions"
                                  ],
                                  "tips": "Para harmônica, use diagrama fasorial para fase; Duhamel é versátil para qualquer Q(t).",
                                  "learningObjective": "Aplicar métodos de solução particular para forçantes modais.",
                                  "commonMistakes": [
                                    "Usar ressonância sem checar Ω ≈ ω_r",
                                    "Esquecer fator de magnificação dinâmico"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Combinar soluções e aplicar condições iniciais",
                                  "subSteps": [
                                    "Escreva solução total: q_r(t) = q_h(t) + q_p(t).",
                                    "Aplique q_r(0) para encontrar constante A (ou C1).",
                                    "Derive ˙q_r(t) e aplique ˙q_r(0) para constante B (ou C2).",
                                    "Simplifique expressão final para resposta modal q_r(t).",
                                    "Plote ou tabule q_r(t) vs t para visualização."
                                  ],
                                  "verification": "q_r(0) e ˙q_r(0) atendidos; equação diferencial satisfeita em t>0.",
                                  "estimatedTime": "0.5 hours",
                                  "materials": [
                                    "Software de plotagem (MATLAB plot, Python matplotlib)"
                                  ],
                                  "tips": "Resolva sistema 2x2 para constantes simultaneamente; verifique numericamente em t=0.",
                                  "learningObjective": "Obter resposta modal completa e verificável.",
                                  "commonMistakes": [
                                    "Erros algébricos em CI levando a inconsistências",
                                    "Ignorar regime de amortecimento na q_h"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma asa de avião modelada como viga com 3 modos, ω_1=10 rad/s, ζ_1=0.02, Q_1(t)=Q_0 cos(Ωt) com Ω=9.5 rad/s (próximo ressonância). Resolva para q_1(t), encontre pico de resposta ~ Q_0 / (2ζ_1 ω_1²) e plote deformação modal.",
                              "finalVerifications": [
                                "Parâmetros modais corretamente identificados e unidades consistentes.",
                                "Solução homogênea satisfaz EDO homogênea.",
                                "Solução particular equilibra Q_r(t) exatamente.",
                                "Condições iniciais atendidas em q_r(0) e ˙q_r(0).",
                                "Resposta q_r(t) mostra decaimento transitório e regime permanente correto.",
                                "Verificação numérica: substitua q_r em EDO para t amostrados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na solução homogênea (raízes corretas, regime identificado).",
                                "Correção da solução particular (fórmula de D/φ ou Duhamel exata).",
                                "Aplicação precisa de condições iniciais (sistema resolvido sem erros).",
                                "Expressão final simplificada e interpretável.",
                                "Visualização/plots mostram comportamento físico realista (ex: ressonância).",
                                "Explicação clara de passos e justificativas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações diferenciais lineares de 2ª ordem e transformadas de Laplace.",
                                "Física: Dinâmica de osciladores amortecidos forçados.",
                                "Engenharia de Controle: Análise de estabilidade e resposta em malha aberta.",
                                "Processamento de Sinais: FFT para identificar modos em vibrações aleatórias."
                              ],
                              "realWorldApplication": "Em aeroelasticidade, resolver equações modais independentes permite prever resposta de asas a turbulência ou flutter, essencial para certificação de aeronaves (ex: análise de fadiga em Boeing 787 sob cargas gust)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.5.2.3.3",
                            "name": "Reconstruir resposta física",
                            "description": "Combinar respostas modais via {x(t)} = [Φ]{q(t)} para obter a resposta total da estrutura sob excitações arbitrárias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar análise modal e preparar matriz de modos [Φ]",
                                  "subSteps": [
                                    "Realize a análise modal da estrutura para obter frequências naturais ω_r e modos de vibração φ_r.",
                                    "Monte a matriz de modos [Φ] com as colunas sendo os vetores de modo normalizados (φ_r^T M φ_r = 1).",
                                    "Verifique a ortogonalidade dos modos: [Φ]^T [M] [Φ] = [I] e [Φ]^T [K] [Φ] = [Ω]^2.",
                                    "Identifique o número de modos relevantes para capturar pelo menos 99% da energia total.",
                                    "Armazene [Φ] para uso posterior na reconstrução."
                                  ],
                                  "verification": "Confirme que [Φ] satisfaz as propriedades de ortogonalidade calculando [Φ]^T [M] [Φ] ≈ [I].",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Matriz de massa [M]",
                                    "Matriz de rigidez [K]",
                                    "Software como MATLAB ou Python (NumPy/SciPy)"
                                  ],
                                  "tips": "Use truncamento modal para reduzir dimensões, priorizando modos de baixa frequência.",
                                  "learningObjective": "Compreender a base da decomposição modal e preparar dados para superposição.",
                                  "commonMistakes": [
                                    "Não normalizar os modos corretamente",
                                    "Incluir modos irrelevantes levando a ruído numérico",
                                    "Ignorar propriedades de ortogonalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Resolver equações modais para coordenadas generalizadas {q(t)}",
                                  "subSteps": [
                                    "Transforme a equação física [M]{ẍ} + [C]{ẋ} + [K]{x} = {F(t)} para coordenadas modais usando [Φ].",
                                    "Obtenha as equações desacopladas: φ_r^T [M] φ_r q̈_r + φ_r^T [C] φ_r q̇_r + φ_r^T [K] φ_r q_r = φ_r^T {F(t)}.",
                                    "Aplique amortecimento de Rayleigh: C_rr = α M_rr + β K_rr, simplificando para q̈_r + 2ζ_r ω_r q̇_r + ω_r² q_r = Q_r(t).",
                                    "Resolva cada equação modal independentemente usando Duhamel ou Laplace para excitações arbitrárias.",
                                    "Calcule {q(t)} como vetor com todos q_r(t)."
                                  ],
                                  "verification": "Verifique que as respostas modais q_r(t) convergem para zero sem excitação (condição inicial zero).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Equações modais desacopladas",
                                    "Função de excitação {F(t)}",
                                    "Ferramentas numéricas (MATLAB ode45 ou SciPy solve_ivp)"
                                  ],
                                  "tips": "Para vibrações aleatórias, use PSD modal; para determinísticas, integre numericamente.",
                                  "learningObjective": "Dominar a solução das equações desacopladas em coordenadas modais.",
                                  "commonMistakes": [
                                    "Erro na projeção modal φ_r^T {F(t)}",
                                    "Não considerar amortecimento modal corretamente",
                                    "Sobrestimar número de modos necessários"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar superposição modal para obter resposta física {x(t)}",
                                  "subSteps": [
                                    "Aplique a fórmula de reconstrução: {x(t)} = [Φ] {q(t)}.",
                                    "Multiplique matematicamente [Φ] (n x m) por {q(t)} (m x 1) para obter {x(t)} (n x 1).",
                                    "Implemente numericamente em loop temporal para t de 0 a T.",
                                    "Plote {x(t)} em cada grau de liberdade para visualização.",
                                    "Compare com resposta direta sem modos para validação parcial."
                                  ],
                                  "verification": "A norma da resposta {x(t)} deve coincidir com simulação full-order dentro de 1% de erro.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Matriz [Φ]",
                                    "Vetor {q(t)} temporal",
                                    "Software de plotagem (MATLAB plot ou Matplotlib)"
                                  ],
                                  "tips": "Use modos mass-normalizados para evitar escalas erradas; vetorize operações para eficiência.",
                                  "learningObjective": "Aplicar corretamente a transformação inversa modal para reconstruir deslocamentos físicos.",
                                  "commonMistakes": [
                                    "Inverter a ordem: usar {q} = [Φ]^T {x}",
                                    "Erro de indexação em implementações numéricas",
                                    "Não sincronizar tempos de {q_r(t)}"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e interpretar a resposta física reconstruída",
                                  "subSteps": [
                                    "Verifique condições de contorno: [K]{x(t)} ≈ 0 em nós fixos.",
                                    "Calcule energias cinética e potencial para confirmar conservação aproximada.",
                                    "Analise picos de resposta e compare com critérios de fadiga.",
                                    "Teste sensibilidade variando número de modos.",
                                    "Documente limitações como não-linearidades ignoradas."
                                  ],
                                  "verification": "Erro relativo entre resposta modal e full < 2%; energias balanceadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Resposta {x(t)}",
                                    "Simulação de referência full-order",
                                    "Ferramentas de análise (FFT para frequências)"
                                  ],
                                  "tips": "Use 10-20 modos para precisão; valide com casos analíticos simples.",
                                  "learningObjective": "Interpretar e validar a precisão da reconstrução modal.",
                                  "commonMistakes": [
                                    "Ignorar aliasing de alta frequência",
                                    "Não verificar equilíbrio energético",
                                    "Concluir prematuramente sem validação"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma viga cantilever com 4 elementos finitos (8 DOFs), excitação harmônica F(t) = sin(ω t) no ponto livre. Modos: ω1=3.5 rad/s, φ1 livre=1. Obtenha [Φ] 8x4, resolva 4 eqs modais, reconstrua x(t) no ponto livre e compare com solução exata.",
                              "finalVerifications": [
                                "A equação {x(t)} = [Φ]{q(t)} está corretamente implementada sem erros dimensionais.",
                                "Resposta converge com aumento de modos (erro <1%).",
                                "Condições iniciais {x(0)}=0, {ẋ(0)}=0 são satisfeitas.",
                                "Energia total varia coerentemente com excitação.",
                                "Frequências dominantes em FFT de x(t) coincidem com ω_r.",
                                "Resposta em nós fixos é zero dentro de tolerância numérica."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica da reconstrução (erro <2%).",
                                "Compreensão conceitual da superposição modal explicada verbalmente.",
                                "Implementação eficiente em código (tempo de execução razoável).",
                                "Identificação correta de limitações modais.",
                                "Validação cruzada com método direto.",
                                "Interpretação física dos resultados (picos, amortecimento)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Decomposição modal e multiplicação matricial.",
                                "Programação Numérica: Solução de EDOs e visualização em MATLAB/Python.",
                                "Controle de Sistemas: Estados modais para design de controladores.",
                                "Processamento de Sinais: Análise espectral de vibrações aleatórias.",
                                "Engenharia de Materiais: Impacto na fadiga estrutural."
                              ],
                              "realWorldApplication": "Em aeronaves, reconstrói deslocamentos em asas sob turbulência para prever flutter, otimizar peso e certificar fadiga (ex: análise de Boeing 787 sob cargas gust)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.3.2"
                            ]
                          },
                          {
                            "id": "10.1.5.2.3.4",
                            "name": "Aplicar a casos aeroespaciais",
                            "description": "Implementar a solução modal com Rayleigh em problemas de vibrações de asas ou fuselagens, considerando excitações aleatórias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar a estrutura aeroespacial como sistema multi-graus de liberdade",
                                  "subSteps": [
                                    "Identificar os modos de vibração relevantes para asas ou fuselagens usando análise modal prévia.",
                                    "Definir matrizes de massa [M] e rigidez [K] baseadas em propriedades geométricas e materiais da estrutura.",
                                    "Incorporar o amortecimento de Rayleigh proporcional: C = αM + βK, calibrando α e β com dados experimentais.",
                                    "Diagonalizar o sistema para obter coordenadas modais via autovalores e autovetores.",
                                    "Validar o modelo com frequências naturais conhecidas de benchmarks aeroespaciais."
                                  ],
                                  "verification": "Comparar frequências e modos obtidos com valores teóricos ou FEM para erro <5%.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Software FEM (ANSYS/NASTRAN), MATLAB/Python para análise modal, dados de propriedades de asas (ex: NACA 0012).",
                                  "tips": "Comece com modelo beam simplificado para asas antes de full 3D.",
                                  "learningObjective": "Construir e validar modelo dinâmico de estruturas aeroespaciais com Rayleigh damping.",
                                  "commonMistakes": "Ignorar modos superiores que afetam resposta em altas frequências; usar α/β inadequados sem calibração."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular equações de movimento desacopladas em coordenadas modais",
                                  "subSteps": [
                                    "Transformar equações físicas Mẍ + Cẋ + Kx = F(t) para modais: Φ^T M Φ η̈ + Φ^T C Φ η̇ + Φ^T K Φ η = Φ^T F(t).",
                                    "Verificar diagonalização: matrizes modais de massa e rigidez tornam-se identidade e diagonais.",
                                    "Expressar amortecimento modal como 2ζ_ω_i para cada modo i, derivado de Rayleigh.",
                                    "Definir forças modais para excitações aleatórias, como turbulência modelada por PSD (Power Spectral Density).",
                                    "Implementar em código para equações desacopladas: η̈_i + 2ζ_i ω_i η̇_i + ω_i² η_i = Q_i(t)."
                                  ],
                                  "verification": "Resolver equação modal unitária e confirmar desacoplamento (off-diagonais zero).",
                                  "estimatedTime": "1-2 horas",
                                  "materials": "MATLAB/SciPy para eigen-decomposição, templates de código para Rayleigh modal.",
                                  "tips": "Use funções built-in como eig() para precisão numérica.",
                                  "learningObjective": "Desacoplar equações dinâmicas aeroespaciais usando análise modal com Rayleigh.",
                                  "commonMistakes": "Esquecer normalização modal, levando a amplitudes erradas; confundir Rayleigh com damping viscoso não-proporcional."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar solução para excitações aleatórias em domínio frequência",
                                  "subSteps": [
                                    "Modelar excitação aleatória como processo estacionário com PSD S(ω), ex: turbulência von Karman.",
                                    "Calcular resposta modal em frequência: H_i(ω) = 1 / (-ω² + 2iζ_i ω_i ω + ω_i²).",
                                    "Obter PSD de resposta modal: S_η_i(ω) = |H_i(ω)|² S_Q_i(ω), onde S_Q_i é PSD modal.",
                                    "Integrar para variâncias: σ_η_i² = ∫ S_η_i(ω) dω usando método de integração numérica.",
                                    "Reconstruir resposta física via x(t) = Φ η(t) para análise estatística (RMS, picos)."
                                  ],
                                  "verification": "Verificar que variância aumenta com intensidade de excitação e diminui com ζ.",
                                  "estimatedTime": "2-4 horas",
                                  "materials": "MATLAB Signal Processing Toolbox ou Python (scipy.signal), PSD de turbulência aeroespacial.",
                                  "tips": "Use trapezoidal rule para integração; plotar FRF para insight visual.",
                                  "learningObjective": "Resolver vibrações aleatórias modais com Rayleigh em domínio frequência.",
                                  "commonMistakes": "Aplicar solução determinística a estocástica; ignorar cross-spectral densities entre modos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular, analisar e validar o caso aeroespacial",
                                  "subSteps": [
                                    "Executar simulação temporal via integração numérica (Newmark/Ode45) com ruído aleatório.",
                                    "Comparar resposta modal/física com critérios de fadiga (ex: fator de segurança >1.5).",
                                    "Avaliar sensibilidade a parâmetros Rayleigh (varrer α/β).",
                                    "Validar contra dados experimentais ou literatura (ex: vibrações de asa AGARD).",
                                    "Documentar resultados com gráficos de PSD, time-history e estatísticas."
                                  ],
                                  "verification": "Simulação temporal converge para mesmas estatísticas da análise em frequência.",
                                  "estimatedTime": "3-5 horas",
                                  "materials": "Simulink/MATLAB ode solvers, dados experimentais AGARD 445.6 para flutter/vibração.",
                                  "tips": "Seed aleatória fixa para reprodutibilidade; downsample para eficiência.",
                                  "learningObjective": "Aplicar e validar solução modal Rayleigh em cenários reais aeroespaciais.",
                                  "commonMistakes": "Sobrestimar damping sem calibração; não considerar acoplamento aerodinâmico."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar resultados e propor otimizações",
                                  "subSteps": [
                                    "Analisar modos dominantes em resposta a turbulência (ex: 1º flexional de asa).",
                                    "Calcular life-cycle sob fadiga usando Rainflow counting em simulações.",
                                    "Otimizar α/β para minimizar RMS de resposta crítica.",
                                    "Relatar limitações (ex: linearidade assumida) e extensões (non-Rayleigh).",
                                    "Preparar relatório com conclusões acionáveis para design aeroespacial."
                                  ],
                                  "verification": "Otimização reduz pico de resposta >20% sem comprometer estabilidade.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": "Ferramentas de pós-processamento (MATLAB plots), templates de relatório.",
                                  "tips": "Foco em modo crítico; use Pareto para trade-offs.",
                                  "learningObjective": "Interpretar e otimizar soluções modais para aplicações práticas.",
                                  "commonMistakes": "Interpretar variância como amplitude pico; ignorar não-estacionaridade."
                                }
                              ],
                              "practicalExample": "Simule vibrações de uma asa cantilever (comprimento 2m, NACA 0012) sob excitação aleatória de turbulência (PSD von Karman, velocidade 100m/s). Implemente Rayleigh (α=0.1, β=0.001), compute PSD resposta no modo 1 flexional e verifique RMS deslocamento <1cm para segurança.",
                              "finalVerifications": [
                                "Frequências modais coincidem com modelo FEM (erro <3%).",
                                "PSD resposta modal peaks nos modos amortecidos corretamente.",
                                "Variâncias espaciais via x=Φη batem com simulação temporal.",
                                "Sensibilidade a Rayleigh mostra trade-off massa/ rigidez.",
                                "Resultados reproduzíveis com diferentes seeds aleatórias.",
                                "Otimização reduz resposta crítica em pelo menos 15%."
                              ],
                              "assessmentCriteria": [
                                "Precisão da diagonalização modal (off-diagonais <1e-6).",
                                "Correta implementação de PSD para aleatórias (integração converge).",
                                "Validação quantitativa vs benchmarks (erro RMS <10%).",
                                "Análise de sensibilidade completa e insights acionáveis.",
                                "Código limpo, comentado e reprodutível.",
                                "Relatório claro com gráficos profissionais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de autovalores e integrais de Fourier para PSD.",
                                "Programação: Numéricos em MATLAB/Python para solvers ODE e signal processing.",
                                "Física: Dinâmica de estruturas e teoria de processos estocásticos.",
                                "Engenharia de Materiais: Calibração Rayleigh com testes modais experimentais.",
                                "Controle: Extensão para atenuadores ativos baseados em modais."
                              ],
                              "realWorldApplication": "Previsão e mitigação de fadiga por vibração em fuselagens de aviões comerciais sob turbulência (ex: Boeing 737), otimizando damping para estender vida útil de 50.000 ciclos para 75.000, reduzindo custos de manutenção em milhões."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.3",
                    "name": "Propriedades do Amortecimento de Rayleigh",
                    "description": "Características como ortogonalidade modal e limitações em estruturas com múltiplos graus de liberdade.",
                    "individualConcepts": [
                      {
                        "id": "57.2.1.1",
                        "name": "Formulação do Amortecimento de Rayleigh",
                        "description": "Definição e derivação da matriz de amortecimento proporcional baseada nas frequências e modos naturais de vibração.",
                        "specificSkills": [
                          {
                            "id": "57.2.1.1.1",
                            "name": "Derivar a matriz de amortecimento de Rayleigh",
                            "description": "Derivar a forma da matriz de amortecimento C = αM + βK a partir das equações de movimento de sistemas multi-grau de liberdade, relacionando α e β com frequências naturais e fator de amortecimento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar equações de movimento para sistemas MDOF amortecidos",
                                  "subSteps": [
                                    "Escreva a equação geral de movimento: M ü + C ú + K u = F(t), onde M é matriz de massa, C de amortecimento, K de rigidez.",
                                    "Explique os graus de liberdade (DOF) e a importância do acoplamento modal.",
                                    "Discuta o problema próprio não amortecido: resolver (K - ω² M) φ = 0 para frequências naturais ω_i e modos φ_i.",
                                    "Introduza a suposição de amortecimento proporcional para simplificar C.",
                                    "Verifique ortonormalidade dos modos: φ_i^T M φ_j = δ_ij, φ_i^T K φ_j = ω_i² δ_ij."
                                  ],
                                  "verification": "Confirme que a equação geral está corretamente escrita e os conceitos de modos normais são compreendidos via discussão ou quiz.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Dinâmica das Estruturas (Clough & Penzien), MATLAB para matrizes de exemplo.",
                                  "tips": "Use notação matricial consistente para evitar confusões com escalares.",
                                  "learningObjective": "Compreender a base matemática das equações de movimento MDOF com amortecimento.",
                                  "commonMistakes": "Confundir notação vetorial com matricial; ignorar a simetria das matrizes M, C, K."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Assumir a forma de amortecimento de Rayleigh: C = αM + βK",
                                  "subSteps": [
                                    "Proponha a forma C = αM + βK, onde α e β são escalares positivos.",
                                    "Justifique a proporcionalidade: garante que C compartilhe os mesmos autovetores de M e K.",
                                    "Mostre que C φ_i = (α + β ω_i²) φ_i, confirmando amortecimento modal.",
                                    "Discuta limitações: aproximação para amortecimento leve e estruturas próximas do ideal.",
                                    "Escreva a equação de movimento substiuindo C."
                                  ],
                                  "verification": "Substitua C na equação original e verifique se resulta em forma diagonal no espaço modal.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Folha de papel ou software simbólico como SymPy/MATLAB Symbolic Toolbox.",
                                  "tips": "Escolha unidades consistentes para α (1/tempo) e β (tempo).",
                                  "learningObjective": "Introduzir e justificar a forma proporcional do amortecimento de Rayleigh.",
                                  "commonMistakes": "Esquecer que α e β devem ser escolhidos para matching modal; assumir valores arbitrários."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar as equações modais e extrair coeficientes de amortecimento",
                                  "subSteps": [
                                    "Transforme coordenadas para modais: u = Φ q, onde Φ contém modos φ_i.",
                                    "Substitua na equação: obtenha ï + 2 Ξ Ω ė + Ω² q = Φ^T F, com amortecimento modal.",
                                    "Para Rayleigh, mostre que o coeficiente modal é 2 ξ_i ω_i = α + β ω_i².",
                                    "Escreva explicitamente ξ_i ≈ (α/(2 ω_i) + β ω_i / 2).",
                                    "Verifique para múltiplos modos: a forma linear permite ajuste médio."
                                  ],
                                  "verification": "Derive a equação modal e isole o termo de amortecimento para um modo específico.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "MATLAB para computar autovalores de exemplo 2x2 DOF.",
                                  "tips": "Use pré-multiplicação por Φ^T para decoupling.",
                                  "learningObjective": "Derivar a relação entre α, β e os parâmetros modais ξ_i, ω_i.",
                                  "commonMistakes": "Erro na transformação modal; confundir ξ_i com ξ médio."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar α e β a partir de dados modais e verificar propriedades",
                                  "subSteps": [
                                    "Colete ω_i e ξ_i dos primeiros modos dominantes.",
                                    "Resolva o sistema linear: α + β ω_1² = 2 ξ_1 ω_1; α + β ω_2² = 2 ξ_2 ω_2.",
                                    "Generalize para n modos, usando mínimos quadrados se overdetermined.",
                                    "Verifique propriedades: C positiva definida, fator de Rayleigh ótimo.",
                                    "Teste em exemplo numérico: compute autovalores complexos."
                                  ],
                                  "verification": "Calcule α e β para um sistema 2 DOF e confirme que ξ_i recuperados batem.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "MATLAB script para solver linear e eigenvalues.",
                                  "tips": "Priorize modos de baixa frequência para α, altas para β.",
                                  "learningObjective": "Calcular α e β e validar a aproximação Rayleigh.",
                                  "commonMistakes": "Resolver sistema incorreto; ignorar inconsistências entre modos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar e validar a matriz C em simulação",
                                  "subSteps": [
                                    "Construa M, K para sistema beam-like simples.",
                                    "Compute C = αM + βK com valores derivados.",
                                    "Simule resposta livre e compare damping ratios.",
                                    "Analise erro de aproximação para modos não usados.",
                                    "Discuta extensões para vibrações aleatórias."
                                  ],
                                  "verification": "Simulação mostra decay exponencial com taxa próxima a 2 ξ ω.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "MATLAB ode45 para integração numérica.",
                                  "tips": "Use initial conditions modais para isolar efeitos.",
                                  "learningObjective": "Validar numericamente a derivação Rayleigh.",
                                  "commonMistakes": "Má condicionamento em sistemas com ω_i próximas."
                                }
                              ],
                              "practicalExample": "Para uma viga de 2 DOF modelando uma asa de aeronave: M = diag([1, 0.5]), K = [[2, -1], [-1, 1]], ω1=1 rad/s ξ1=0.02, ω2=2 rad/s ξ2=0.05. Resolva α + β(1)=0.04, α + β(4)=0.2 → α=0.093, β=0.019. C = αM + βK resulta em damping modal aproximado.",
                              "finalVerifications": [
                                "Matriz C = αM + βK é simétrica e positiva semi-definida.",
                                "Coeficientes modais 2ξ_i ω_i ≈ α + β ω_i² para modos principais (erro <10%).",
                                "Autovalores complexos da matriz de estado têm partes imaginárias próximas a ω_i.",
                                "Simulação numérica confirma decaimento sem overshoot indesejado.",
                                "Sistema linear para α, β é resolvido corretamente sem singularidades.",
                                "Propriedades de Rayleigh (ortogonalidade modal preservada) verificadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão da derivação da equação modal (100% correto).",
                                "Correta identificação de α e β via sistema linear (erro <1%).",
                                "Validação numérica com simulação (match de damping ratios >90%).",
                                "Explicação clara de limitações e justificativas matemáticas.",
                                "Uso consistente de notação e verificações intermediárias.",
                                "Criatividade na extensão para contexto aeroespacial."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de autovalores e decomposição modal.",
                                "Física: Dinâmica vibracional e princípios de conservação de energia.",
                                "Engenharia de Controle: Modelagem de sistemas lineares invariantes no tempo.",
                                "Computação: Programação numérica em MATLAB para simulações dinâmicas."
                              ],
                              "realWorldApplication": "Em aeroelasticidade, o amortecimento de Rayleigh modela dissipadores em asas de aeronaves para suprimir flutter, permitindo simulações eficientes de vibrações induzidas por turbulência em projetos da Boeing ou Embraer, reduzindo fadiga estrutural."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.2.1.1.2",
                            "name": "Calcular coeficientes α e β",
                            "description": "Determinar os coeficientes α e β para um sistema conhecido, utilizando condições de amortecimento modal equivalente em um ou dois modos dominantes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Amortecimento Modal e Rayleigh",
                                  "subSteps": [
                                    "Defina amortecimento modal equivalente: razão de amortecimento ξ_i para cada modo i com frequência natural ω_i.",
                                    "Revise a matriz de amortecimento modal [C_modal] onde c_ii = 2 ξ_i ω_i m_i.",
                                    "Introduza o modelo de Rayleigh: [C] = α [M] + β [K], onde α é coeficiente de massa e β de rigidez.",
                                    "Explique como Rayleigh aproxima o amortecimento modal em modos dominantes.",
                                    "Identifique condições: sistema conhecido com modos e ξ_i disponíveis."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e desenhe um diagrama comparando amortecimento modal vs Rayleigh.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Dinâmica de Estruturas (ex: Clough & Penzien)",
                                    "Notas de aula sobre vibrações livres",
                                    "Calculadora ou software simbólico como SymPy"
                                  ],
                                  "tips": "Use analogias como 'Rayleigh é uma aproximação linear simples para comportamentos modais complexos'.",
                                  "learningObjective": "Explicar verbalmente como o amortecimento Rayleigh modela dissipação de energia em estruturas.",
                                  "commonMistakes": [
                                    "Confundir α com coeficiente de viscosidade em vez de massa",
                                    "Ignorar que Rayleigh é não-clássico e modo-dependente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar Fórmulas para um Modo Dominante",
                                  "subSteps": [
                                    "Para um modo i dominante: ξ_i ≈ (α / (2 ω_i)) + (β ω_i / 2).",
                                    "Simplifique assumindo contribuição igual de α e β termos, ou otimize para igualdade.",
                                    "Derive α = 2 ξ_i ω_i e β = 2 ξ_i / ω_i para minimizar erro.",
                                    "Calcule numericamente para um exemplo simples: ω_1 = 10 rad/s, ξ_1 = 0.02.",
                                    "Verifique dimensionalmente: [α] = s^-1, [β] = s."
                                  ],
                                  "verification": "Derive as equações em papel e calcule α e β para ω_i=10, ξ_i=0.02 (α≈0.4, β≈0.004).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Papel e lápis",
                                    "Planilha Excel ou MATLAB para cálculos simbólicos",
                                    "Artigo sobre Rayleigh damping"
                                  ],
                                  "tips": "Lembre que para um modo, α + β ω_i^2 ≈ 2 ξ_i ω_i.",
                                  "learningObjective": "Derivar e calcular α e β para caso de um modo dominante com precisão.",
                                  "commonMistakes": [
                                    "Usar fórmula errada: confundir com dois modos",
                                    "Esquecer fator 2 nas equações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular α e β para Dois Modos Dominantes",
                                  "subSteps": [
                                    "Monte o sistema: para modos 1 e 2: α/(2ω1) + β ω1 /2 = ξ1; α/(2ω2) + β ω2 /2 = ξ2.",
                                    "Resolva o sistema linear: [1/(2ω1), ω1/2; 1/(2ω2), ω2/2] [α; β] = [ξ1; ξ2].",
                                    "Use eliminação gaussiana ou inversa de matriz 2x2.",
                                    "Implemente em código: escreva função em Python/MATLAB.",
                                    "Teste com dados: ω1=10, ξ1=0.02; ω2=30, ξ2=0.05."
                                  ],
                                  "verification": "Resolva sistema manualmente e confirme com código; valores devem coincidir dentro de 1%.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB ou Python (NumPy)",
                                    "Matriz solver online",
                                    "Exercícios de álgebra linear"
                                  ],
                                  "tips": "Sempre normalize equações dividindo por fatores comuns para evitar erros numéricos.",
                                  "learningObjective": "Resolver sistema de equações para α e β em dois modos e implementar computacionalmente.",
                                  "commonMistakes": [
                                    "Erro na montagem da matriz (invertendo termos α/β)",
                                    "Não verificar solução plugando de volta"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Aplicar os Coeficientes em um Sistema",
                                  "subSteps": [
                                    "Calcule ξ aproximado para outros modos usando fórmula Rayleigh e compare com ξ reais.",
                                    "Simule resposta temporal de um DOF com [C] Rayleigh vs modal.",
                                    "Analise erro: % diferença em ξ para modos 1-3.",
                                    "Ajuste se necessário (ex: minimizar erro médio ponderado).",
                                    "Documente processo em relatório curto."
                                  ],
                                  "verification": "Gráfico de ξ Rayleigh vs modal para 3 modos mostra erro <10% nos dominantes.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de simulação (MATLAB ODE45)",
                                    "Dados de modos de uma viga cantilever"
                                  ],
                                  "tips": "Pondere por energia modal para melhores aproximações.",
                                  "learningObjective": "Avaliar precisão da aproximação Rayleigh e refinar cálculos.",
                                  "commonMistakes": [
                                    "Assumir Rayleigh perfeito para todos modos",
                                    "Ignorar efeitos não-lineares"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma asa de aeronave modelada como viga cantilever: modos dominantes ω1=15 rad/s (ξ1=0.015), ω2=45 rad/s (ξ2=0.04). Calcule α ≈ 0.45 s^-1, β ≈ 0.00133 s. Use em simulação de resposta a rajada para verificar atenuação.",
                              "finalVerifications": [
                                "Deriva corretamente equações para 1 e 2 modos.",
                                "Calcula α e β com erro <1% para exemplo dado.",
                                "Implementa código que resolve sistema geral.",
                                "Avalia erro em terceiro modo <15%.",
                                "Explica limitações do Rayleigh em contextos aeroelásticos.",
                                "Gera gráfico comparativo de decaimento modal."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações (90% correto).",
                                "Correção numérica em cálculos (erro <0.5%).",
                                "Clareza na explicação conceitual.",
                                "Efetividade da verificação e análise de erro.",
                                "Criatividade na aplicação prática.",
                                "Uso adequado de ferramentas computacionais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sistemas lineares e álgebra matricial.",
                                "Física: Dinâmica de vibrações e dissipação de energia.",
                                "Engenharia de Controle: Modelagem de sistemas amortecidos.",
                                "Programação: Implementação numérica em Python/MATLAB.",
                                "Análise Numérica: Condicionamento de matrizes."
                              ],
                              "realWorldApplication": "Em análise de flutter de asas de aeronaves, α e β são calculados para simular amortecimento equivalente, previnindo oscilações destrutivas durante voo turbulentos, como no design do Boeing 787."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.2.1.1.3",
                            "name": "Aplicar em equação de movimento",
                            "description": "Incorporar a matriz de Rayleigh na equação geral Mẍ + Cẋ + Kx = F e verificar proporcionalidade modal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a equação geral de movimento dinâmico",
                                  "subSteps": [
                                    "Identifique os componentes da equação Mẍ + Cẋ + Kx = F: massa (M), amortecimento (C), rigidez (K) e força externa (F).",
                                    "Explique os termos: ẍ (aceleração), ẋ (velocidade), x (deslocamento).",
                                    "Discuta o problema do amortecimento: C é geralmente desconhecido e não proporcional.",
                                    "Estabeleça notação matricial para sistemas multi-graus de liberdade (MDOF).",
                                    "Derive brevemente a equação a partir das leis de Newton para um sistema discreto."
                                  ],
                                  "verification": "Escreva a equação geral corretamente e identifique cada termo com sua unidade física (ex: kg para M).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro-texto de dinâmica estrutural (ex: Clough & Penzien), caderno de anotações, calculadora.",
                                  "tips": "Use dimensões para validar: [M] = massa, [C] = viscosidade, [K] = rigidez.",
                                  "learningObjective": "Compreender a estrutura fundamental da equação de movimento em sistemas lineares.",
                                  "commonMistakes": "Confundir ẋ com ẍ; ignorar que M, C, K são matrizes em MDOF."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e formular a matriz de amortecimento de Rayleigh",
                                  "subSteps": [
                                    "Introduza o modelo de Rayleigh: C = αM + βK, onde α e β são coeficientes escalares.",
                                    "Explique a origem: combinação linear de massa e rigidez para aproximar amortecimento viscoso.",
                                    "Calcule α e β a partir de frequências e razões de amortecimento modal conhecidas: α = 2ζω_m M, β = 2ζ/ω_M K (aproximações).",
                                    "Verifique propriedades: C é simétrica se M e K forem.",
                                    "Discuta limitações: assume amortecimento modalmente proporcional."
                                  ],
                                  "verification": "Escreva C = αM + βK e compute C para matrizes M e K dadas com α=0.1, β=0.01.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software MATLAB ou Python (NumPy), exemplos de matrizes M e K de um sistema 2DOF.",
                                  "tips": "Escolha α e β para matching em primeiros modos; use ξ_i = (α/(2ω_i)) + (β ω_i / 2).",
                                  "learningObjective": "Formular matematicamente o modelo de amortecimento de Rayleigh.",
                                  "commonMistakes": "Esquecer que α tem unidades de frequência [1/s], β de 1/frequência [s]; inverter termos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar a matriz de Rayleigh na equação geral",
                                  "subSteps": [
                                    "Substitua C por αM + βK na equação: Mẍ + (αM + βK)ẋ + Kx = F.",
                                    "Reescreva como Mẍ + αMẋ + βKẋ + Kx = F.",
                                    "Divida por M (pré-multiplicação por M^{-1}): ẍ + αẋ + β (M^{-1}K) ẋ + M^{-1}K x = M^{-1}F.",
                                    "Identifique o termo de amortecimento efetivo.",
                                    "Implemente numericamente para um sistema pequeno."
                                  ],
                                  "verification": "Derive a equação modificada e verifique se C resultante satisfaz C = αM + βK.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "MATLAB/SciPy para multiplicação matricial, planilha Excel para validação manual.",
                                  "tips": "Mantenha simetria; teste com F=0 para movimento livre.",
                                  "learningObjective": "Integrar o modelo de Rayleigh na equação dinâmica padrão.",
                                  "commonMistakes": "Não distribuir corretamente os termos αMẋ e βKẋ; assumir escalares em vez de matrizes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar proporcionalidade modal",
                                  "subSteps": [
                                    "Realize a transformada modal: assuma x = Φ q, onde Φ são vetores modais de K e M.",
                                    "Substitua na equação e pré-multiplique por Φ^T M: obtém equações desacopladas se C modal for diagonal.",
                                    "Mostre que Φ^T C Φ = α Φ^T M Φ + β Φ^T K Φ é diagonal (pois M e K modais são identidade e diagonal).",
                                    "Calcule razões de amortecimento modal: ξ_i = α/(2ω_i) + β ω_i / 2.",
                                    "Confirme numericamente com autovalores."
                                  ],
                                  "verification": "Compute Φ^T C Φ e confirme que é diagonal dentro de tolerância numérica (ex: <1e-10).",
                                  "estimatedTime": "50 minutos",
                                  "materials": "MATLAB eig() para modais, script para transformada modal.",
                                  "tips": "Normalizar Φ ortogonalmente w.r.t. M: Φ^T M Φ = I.",
                                  "learningObjective": "Demonstrar que Rayleigh assume amortecimento modalmente proporcional.",
                                  "commonMistakes": "Usar autovetores não normalizados; confundir com amortecimento geral não-proporcional."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar e validar em um exemplo prático",
                                  "subSteps": [
                                    "Escolha um sistema 2DOF (ex: viga com 2 massas).",
                                    "Monte M, K; defina α, β baseados em dados experimentais fictícios.",
                                    "Incorpore C e resolva numericamente a resposta temporal.",
                                    "Compare com amortecimento geral para validar aproximação.",
                                    "Analise decaimento modal."
                                  ],
                                  "verification": "Plote resposta e confirme decaimento proporcional aos ξ_i calculados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB ode45 para integração, dados de exemplo (M=[2 0;0 1], K=[3 -1;-1 2]).",
                                  "tips": "Use pulso inicial para excitação; zoom em modos individuais.",
                                  "learningObjective": "Aplicar o processo completo em um caso realista.",
                                  "commonMistakes": "Erros de indexação em MATLAB; escolher α/β que não matcham modos."
                                }
                              ],
                              "practicalExample": "Considere uma asa simplificada modelada como sistema 2DOF com massas m1=100kg, m2=50kg; rigidez k11=1e5 N/m, etc. Defina α=5 s^-1, β=0.02 s; incorpore C e simule resposta a uma rajada de vento F(t), verificando decaimento modal uniforme.",
                              "finalVerifications": [
                                "Equação final Mẍ + (αM + βK)ẋ + Kx = F está corretamente escrita.",
                                "Matriz modal de C (Φ^T C Φ) é diagonal dentro de 1e-12.",
                                "Razões de amortecimento ξ1 e ξ2 matcham as especificadas (±5%).",
                                "Simulação numérica mostra decaimento exponencial nos modos.",
                                "Cálculo manual para 1DOF confirma o modelo.",
                                "Discussão das limitações do Rayleigh é incluída."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação (100% correto).",
                                "Correta implementação numérica e verificação diagonalidade.",
                                "Interpretação física dos resultados (ex: implicações em aeroelasticidade).",
                                "Eficiência no uso de ferramentas computacionais.",
                                "Identificação de erros comuns e como evitá-los.",
                                "Conexão com propriedades modais reais."
                              ],
                              "crossCurricularConnections": [
                                "Análise Modal em Vibrações Mecânicas (Engenharia Mecânica).",
                                "Controle de Vibrações em Aeroelasticidade (Aeroespacial).",
                                "Simulações Numéricas em Métodos Numéricos (Computação Científica).",
                                "Modelagem em Dinâmica de Sistemas (Física Avançada)."
                              ],
                              "realWorldApplication": "Em projetos de aeronaves, o amortecimento de Rayleigh é usado para modelar dissipação em análises de flutter e fadiga vibracional de asas, permitindo previsões rápidas de estabilidade sem dados experimentais completos de C."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "57.2.1.2",
                        "name": "Ortogonalidade Modal no Amortecimento de Rayleigh",
                        "description": "Propriedade que permite desacoplamento modal quando o amortecimento é proporcional, preservando a ortogonalidade das matrizes de massa e rigidez.",
                        "specificSkills": [
                          {
                            "id": "57.2.1.2.1",
                            "name": "Verificar ortogonalidade da matriz C",
                            "description": "Demonstrar que φ_i^T C φ_j = 0 para i ≠ j, onde φ são vetores modais, usando a forma C = αM + βK e propriedades de ortogonalidade de M e K.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Ortogonalidade dos Vetores Modais com Matrizes M e K",
                                  "subSteps": [
                                    "Lembre-se que os vetores modais φ_i satisfazem o problema de autovalores: (K - ω_i² M) φ_i = 0.",
                                    "Verifique que φ_i^T M φ_j = 0 para i ≠ j (ortogonalidade em massa).",
                                    "Confirme φ_i^T K φ_j = 0 para i ≠ j (ortogonalidade em rigidez).",
                                    "Normalize os modos se necessário: φ_i^T M φ_i = 1.",
                                    "Anote as propriedades para referência futura."
                                  ],
                                  "verification": "Escreva as equações de ortogonalidade para M e K e confirme com um exemplo simples de 2 graus de liberdade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Livro de dinâmica estrutural ou notas de aula",
                                    "Calculadora"
                                  ],
                                  "tips": "Use modos normalizados para simplificar cálculos; visualize os modos como formas orthogonais.",
                                  "learningObjective": "Compreender as propriedades fundamentais de ortogonalidade modal em M e K.",
                                  "commonMistakes": [
                                    "Confundir ortogonalidade em M com K",
                                    "Esquecer normalização modal",
                                    "Assumir ortogonalidade sem prova"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a Forma do Amortecedor de Rayleigh C = αM + βK",
                                  "subSteps": [
                                    "Defina C explicitamente como combinação linear: C = α M + β K, onde α e β são coeficientes escalares.",
                                    "Discuta o significado físico: α controla amortecimento em massa, β em rigidez.",
                                    "Escreva a equação de movimento completa: M φ'' + C φ' + K φ = 0.",
                                    "Verifique dimensionalmente α (1/tempo) e β (adimensional).",
                                    "Prepare matrizes M, K e modos φ de um exemplo numérico."
                                  ],
                                  "verification": "Escreva a expressão de C e substitua em uma equação de movimento simples para um sistema 1DOF.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Notas sobre amortecimento de Rayleigh",
                                    "Exemplo de matrizes M e K de uma viga simples"
                                  ],
                                  "tips": "Escolha α e β positivos para amortecimento proporcional estável.",
                                  "learningObjective": "Dominar a definição e interpretação física da matriz C.",
                                  "commonMistakes": [
                                    "Usar coeficientes negativos sem justificativa",
                                    "Confundir α com β",
                                    "Ignorar unidades"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar o Produto φ_i^T C φ_j",
                                  "subSteps": [
                                    "Substitua C na expressão: φ_i^T C φ_j = φ_i^T (α M + β K) φ_j.",
                                    "Distribua: = α (φ_i^T M φ_j) + β (φ_i^T K φ_j).",
                                    "Aplique ortogonalidade: para i ≠ j, φ_i^T M φ_j = 0 e φ_i^T K φ_j = 0.",
                                    "Conclua: φ_i^T C φ_j = 0 para i ≠ j.",
                                    "Verifique para i = j: φ_i^T C φ_i = α + β ω_i² ≠ 0 geralmente."
                                  ],
                                  "verification": "Calcule explicitamente φ_i^T C φ_j para i ≠ j em um exemplo 2x2 e mostre zero.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou MATLAB/Octave para matrizes",
                                    "Exemplo numérico com φ1 = [1, 0]^T, φ2 = [0, 1]^T, M=I, K=diag(1,4)"
                                  ],
                                  "tips": "Faça contas matriciais passo a passo; use simetria de M, C, K.",
                                  "learningObjective": "Derivar algebricamente a ortogonalidade de C nos modos.",
                                  "commonMistakes": [
                                    "Erro na distribuição matricial",
                                    "Esquecer o caso i=j",
                                    "Não usar normalização"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Interpretar Ortogonalidade Completa de C",
                                  "subSteps": [
                                    "Confirme que C é ortogonal nos modos: matriz modal de C é diagonal.",
                                    "Discuta implicações: desacopla equações modais em coordenadas modais.",
                                    "Teste numericamente com valores α=0.1, β=0.01 em exemplo 2DOF.",
                                    "Analise estabilidade: amortecimento modal positivo.",
                                    "Resuma prova em um fluxograma ou equação chave."
                                  ],
                                  "verification": "Mostre que a matriz de amortecimento modal é diagonal e discuta benefícios.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software de cálculo matricial (MATLAB/Python)",
                                    "Gráfico de modos orthogonais"
                                  ],
                                  "tips": "Implemente em código para visualização; verifique simetria de C.",
                                  "learningObjective": "Aplicar e validar a ortogonalidade em contexto dinâmico.",
                                  "commonMistakes": [
                                    "Assumir ortogonalidade sem derivação",
                                    "Ignorar desacoplamento modal",
                                    "Erros numéricos em verificação"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma estrutura 2DOF com M = [[2,0],[0,1]], K = [[2, -1],[-1,2]], modos φ1 ≈ [0.85, 0.53]^T, φ2 ≈ [0.53, -0.85]^T normalizados. Defina α=0.05, β=0.001. Compute φ1^T C φ2 = α φ1^T M φ2 + β φ1^T K φ2 = 0 + 0 = 0, confirmando ortogonalidade.",
                              "finalVerifications": [
                                "Derive φ_i^T C φ_j = 0 para i ≠ j algebricamente.",
                                "Calcule numericamente para um sistema 2DOF e mostre resultado zero.",
                                "Explique por que C desacopla as equações modais.",
                                "Verifique φ_i^T C φ_i > 0 para estabilidade.",
                                "Discuta limitações do modelo de Rayleigh (ex: não para amortecimento não-proporcional)."
                              ],
                              "assessmentCriteria": [
                                "Precisão algébrica na derivação (sem erros de matriz).",
                                "Correta aplicação de ortogonalidade de M e K.",
                                "Exemplo numérico válido com cálculos exatos.",
                                "Interpretação física clara do desacoplamento.",
                                "Identificação de erros comuns e limitações.",
                                "Clareza na documentação e verificações."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: produtos escalares e ortogonalidade de autovetores.",
                                "Física: modos normais de vibração em sistemas acoplados.",
                                "Programação: simulação numérica em MATLAB/Python para dinâmica.",
                                "Engenharia Mecânica: análise de estabilidade em estruturas.",
                                "Matemática Aplicada: problemas de autovalores generalizados."
                              ],
                              "realWorldApplication": "Em análise de flutter e vibrações de asas de aeronaves, a ortogonalidade de C permite modelagem modal desacoplada, facilitando predição de instabilidades aeroelásticas e design de dampers em aviões como o Boeing 787."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "57.2.1.1"
                            ]
                          },
                          {
                            "id": "57.2.1.2.2",
                            "name": "Desacoplar equações modais",
                            "description": "Transformar as equações acopladas em coordenadas modais desacopladas para análise de resposta transitória ou harmônica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar as equações de movimento acopladas",
                                  "subSteps": [
                                    "Escreva as equações de movimento no formato padrão: M ü + C ú + K u = F(t), onde M, C, K são matrizes de massa, amortecimento e rigidez.",
                                    "Identifique o número de graus de liberdade (n) do sistema.",
                                    "Verifique se as matrizes são simétricas e positivas definidas.",
                                    "Anote as condições iniciais u(0) e ú(0) para análise transitória.",
                                    "Discuta o contexto de Rayleigh damping: C = αM + βK."
                                  ],
                                  "verification": "Confirme que as matrizes M, C, K estão corretamente definidas e simétricas via inspeção ou software como MATLAB.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de dinâmica estrutural (ex: Clough & Penzien), MATLAB ou Python (NumPy/SciPy).",
                                  "tips": "Sempre normalize as matrizes para unidades consistentes para evitar erros numéricos.",
                                  "learningObjective": "Compreender a forma matricial das equações acopladas e seu significado físico.",
                                  "commonMistakes": "Confundir notação vetorial com escalar; ignorar simetria das matrizes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular modos e frequências naturais",
                                  "subSteps": [
                                    "Resolva o problema de autovalores generalizado: (K - ω²M)φ = 0 para obter frequências ω_i e modos φ_i.",
                                    "Use decomposição espectral ou funções como eig() no MATLAB.",
                                    "Ordene os modos por frequência crescente.",
                                    "Normalize os modos usando massa modal: φ_i^T M φ_i = 1.",
                                    "Verifique ortogonalidade: φ_i^T M φ_j = 0 e φ_i^T K φ_j = 0 para i ≠ j."
                                  ],
                                  "verification": "Gere os autovalores e autovetores; confirme ortogonalidade com produto escalar próximo de zero.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de análise modal (MATLAB eig(), ANSYS), calculadora matricial.",
                                  "tips": "Para sistemas grandes, use métodos iterativos como Lanczos para eficiência.",
                                  "learningObjective": "Dominar o cálculo de propriedades modais essenciais para desacoplamento.",
                                  "commonMistakes": "Não normalizar modos, levando a massas modais incorretas; inverter ordem de M e K no problema de autovalores."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formar a matriz modal e transformar coordenadas",
                                  "subSteps": [
                                    "Construa a matriz modal Φ = [φ_1, φ_2, ..., φ_n].",
                                    "Defina coordenadas modais q(t) tal que u(t) = Φ q(t).",
                                    "Substitua na equação original: Φ^T M Φ q̈ + Φ^T C Φ q̇ + Φ^T K Φ q = Φ^T F(t).",
                                    "Simplifique usando ortogonalidade: massa modal diagonal M* = Φ^T M Φ = I (se normalizado).",
                                    "Similar para rigidez K* = diag(ω_i²)."
                                  ],
                                  "verification": "Verifique se M* e K* são diagonais com trace(M*) ≈ n.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "MATLAB ou Python para multiplicação matricial, papel e lápis para 2DOF.",
                                  "learningObjective": "Executar a transformação modal corretamente.",
                                  "commonMistakes": "Esquecer transposição Φ^T; usar modos não normalizados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Desacoplar o termo de amortecimento usando Rayleigh",
                                  "subSteps": [
                                    "Expresse C = αM + βK; então C* = Φ^T C Φ = α I + β diag(ω_i²).",
                                    "Mostre que ξ_i = (α/(2ω_i)) + (β ω_i / 2) para fatores de amortecimento modais.",
                                    "Confirme que as equações modais são desacopladas: q̈_i + 2ξ_i ω_i q̇_i + ω_i² q_i = Q_i(t).",
                                    "Para resposta harmônica/transitória, resolva SDOF independentes.",
                                    "Compare com amortecimento não proporcional (não diagonal)."
                                  ],
                                  "verification": "Calcule ξ_i para cada modo; verifique se C* é diagonal.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Exemplo numérico de sistema com Rayleigh damping, solver simbólico (SymPy).",
                                  "learningObjective": "Aplicar ortogonalidade no amortecimento de Rayleigh para desacoplamento completo.",
                                  "commonMistakes": "Assumir amortecimento arbitrário como proporcional; erro em fórmula de ξ_i."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e interpretar as equações desacopladas",
                                  "subSteps": [
                                    "Integre as equações modais independentes (analítica ou numérica).",
                                    "Reconstrua resposta física: u(t) = Φ q(t).",
                                    "Compare com solução acoplada para validação.",
                                    "Analise contribuição modal dominante para respostas transitórias/harmônicas.",
                                    "Discuta limitações do Rayleigh (apenas baixos modos)."
                                  ],
                                  "verification": "Erro entre soluções acoplada e modal < 1% em pontos chave.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Simulador dinâmico (MATLAB ode45), gráficos de resposta.",
                                  "tips": "Use truncamento modal para sistemas grandes (primeiros 6-10 modos).",
                                  "learningObjective": "Interpretar e validar o desacoplamento na prática.",
                                  "commonMistakes": "Ignorar forças modais Q_i; não truncar modos adequadamente."
                                }
                              ],
                              "practicalExample": "Considere um sistema 2DOF com M = diag(1,1), K = [[2,-1],[-1,2]], C = 0.1 M + 0.01 K. Compute modos (ω1≈0.707, ω2≈1.732), transforme para q̈1 + 0.085 q̇1 + 0.5 q1 = F1, q̈2 + 0.107 q̇2 + 3 q2 = F2, resolva para u(t) sob pulso unitário.",
                              "finalVerifications": [
                                "Matrizes modais M*, K*, C* são diagonais.",
                                "Fatores de amortecimento ξ_i calculados corretamente para cada modo.",
                                "Resposta modal reconstrói a resposta física com erro <0.5%.",
                                "Ortogonalidade confirmada: φ_i^T M φ_j = δ_ij.",
                                "Equações modais independentes resolvidas para caso harmônico (ω=1 rad/s).",
                                "Contribuições modais identificadas corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de modos e frequências (erro <1%).",
                                "Correta aplicação da transformação modal e desacoplamento de C Rayleigh.",
                                "Validação numérica com reconstrução de u(t).",
                                "Explicação clara da física por trás do desacoplamento.",
                                "Identificação de limitações e erros potenciais.",
                                "Eficiência computacional demonstrada (tempo de simulação reduzido)."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Decomposição espectral e autovalores.",
                                "Controle de Sistemas: Decoplamento para design de controladores modais.",
                                "Processamento de Sinais: Análise FFT para excitações harmônicas.",
                                "Engenharia Aeroespacial: Modelagem de flutter e vibrações em asas."
                              ],
                              "realWorldApplication": "Em análise de aeroelasticidade, desacoplar equações modais permite simular respostas transitórias de painéis de aeronaves a rajadas turbulentas, prevendo fadiga e otimizando amortecedores Rayleigh para evitar flutter catastrófico em aviões comerciais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "57.2.1.1"
                            ]
                          },
                          {
                            "id": "57.2.1.2.3",
                            "name": "Interpretar fatores de amortecimento modal",
                            "description": "Calcular ξ_n = (α/(2ω_n)) + (β ω_n / 2) para cada modo n e discutir implicações na resposta dinâmica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos dos Parâmetros no Amortecimento de Rayleigh",
                                  "subSteps": [
                                    "Revise o modelo de amortecimento de Rayleigh: amortecimento proporcional definido por α (amortecimento de massa) e β (amortecimento de rigidez).",
                                    "Identifique ω_n como a frequência natural do modo n, obtida da análise modal.",
                                    "Explique ξ_n como o fator de amortecimento modal, que quantifica a dissipação de energia no modo n.",
                                    "Discuta a ortogonalidade modal: como o amortecimento de Rayleigh preserva a ortogonalidade das funções modais.",
                                    "Compare com amortecimento não proporcional, destacando a simplicidade do Rayleigh."
                                  ],
                                  "verification": "Resuma em um parágrafo os papéis de α, β, ω_n e ξ_n, confirmando com referências do textbook.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notas de aula sobre dinâmica estrutural, textbook de vibrações (ex: Chopra), calculadora.",
                                  "tips": "Use diagramas de modos para visualizar como α domina modos baixos e β modos altos.",
                                  "learningObjective": "Explicar com precisão os parâmetros envolvidos na fórmula de amortecimento modal.",
                                  "commonMistakes": "Confundir α com amortecimento viscoso geral ou ignorar dependência de ω_n."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar e Memorizar a Fórmula do Fator de Amortecimento Modal",
                                  "subSteps": [
                                    "Derive a fórmula ξ_n = (α / (2 ω_n)) + (β ω_n / 2) a partir da matriz de amortecimento C = α M + β K.",
                                    "Verifique a dimensionalidade: confirme que ambos os termos têm unidades de fator adimensional.",
                                    "Esboce gráficos qualitativos: ξ_n vs. ω_n, mostrando mínimo em ω_n = sqrt(α/β).",
                                    "Pratique reescrevendo a fórmula para diferentes modos n=1,2,3.",
                                    "Resolva para α e β dados ω_n e ξ_n desejados (inverso)."
                                  ],
                                  "verification": "Derive a fórmula do zero e resolva um exercício simples de inversão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e lápis para derivação, software simbólico como MATLAB Symbolic ou Wolfram Alpha.",
                                  "tips": "Lembre-se: o primeiro termo diminui com ω_n, o segundo aumenta, criando trade-off.",
                                  "learningObjective": "Derivar e aplicar corretamente a fórmula ξ_n para qualquer modo n.",
                                  "commonMistakes": "Esquecer o fator 1/2 ou inverter os termos de α e β."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Fatores de Amortecimento para Múltiplos Modos",
                                  "subSteps": [
                                    "Selecione um sistema exemplo com α, β e frequências modais ω_1 a ω_4.",
                                    "Calcule ξ_n para cada modo usando a fórmula.",
                                    "Tabule os resultados e plote ξ_n vs. modo ou frequência.",
                                    "Analise tendências: identifique modos subamortecidos (ξ_n < 0.05) ou sobre-amortecidos.",
                                    "Valide cálculos com software numérico."
                                  ],
                                  "verification": "Produza uma tabela com cálculos corretos para 4 modos, sem erros aritméticos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora científica, MATLAB ou Python (NumPy) para plotagem, dados de exemplo de estrutura aeroespacial.",
                                  "tips": "Use planilhas para automatizar cálculos em múltiplos modos e evitar erros manuais.",
                                  "learningObjective": "Executar cálculos precisos de ξ_n para sistemas multimodais.",
                                  "commonMistakes": "Usar unidades inconsistentes (rad/s vs. Hz) ou arredondar prematuramente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Implicações na Resposta Dinâmica",
                                  "subSteps": [
                                    "Explique como ξ_n afeta o decaimento exponencial na resposta livre: y(t) ~ e^(-ξ_n ω_n t).",
                                    "Discuta ressonância: modos com ξ_n baixo amplificam respostas sob excitação harmônica.",
                                    "Analise estabilidade: ξ_n > 0 garante estabilidade, mas valores baixos levam a flutter em aeroelasticidade.",
                                    "Compare respostas para diferentes ξ_n via simulações ou curvas de decaimento.",
                                    "Relacione com vibrações aleatórias: impacto no espectro de resposta."
                                  ],
                                  "verification": "Escreva um relatório curto discutindo implicações para um caso com ξ_1=0.02 e ξ_2=0.1.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de simulação (MATLAB Vibration Toolbox), gráficos de resposta dinâmica.",
                                  "tips": "Visualize com animações de modos para conectar matemática à física.",
                                  "learningObjective": "Discutir qualitativa e quantitativamente as implicações dinâmicas de ξ_n.",
                                  "commonMistakes": "Ignorar que ξ_n variável por modo altera a resposta total não-linearmente."
                                }
                              ],
                              "practicalExample": "Para uma asa de aeronave modelada com α=0.2 s^-1, β=0.0005 s, ω_1=15 rad/s (flexão), ω_2=50 rad/s (torção): Calcule ξ_1 ≈ 0.0067 (subamortecido, risco de flutter) e ξ_2 ≈ 0.0125 (moderado). Discuta: modo 1 requer reforço de amortecimento para evitar oscilações persistentes em rajadas.",
                              "finalVerifications": [
                                "Calcula corretamente ξ_n para 3 modos dados α, β, ω_n.",
                                "Identifica corretamente o modo com menor ξ_n e explica risco.",
                                "Descreve gráfico qualitativo de ξ_n vs. ω_n.",
                                "Simula resposta livre e verifica decaimento consistente com ξ_n.",
                                "Discute implicações aeroelásticas com exemplos reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos (erro <1%).",
                                "Profundidade na interpretação de implicações dinâmicas.",
                                "Uso correto de terminologia (ex: ortogonalidade modal).",
                                "Qualidade de visualizações (gráficos, tabelas).",
                                "Conexão clara com contexto aeroespacial.",
                                "Ausência de erros conceituais em derivação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (análise modal), análise assintótica.",
                                "Física: Dinâmica de vibrações, teoria de controle.",
                                "Engenharia: Simulações numéricas em CFD/FEM (ANSYS, NASTRAN).",
                                "Computação: Programação para automação (Python/MATLAB).",
                                "Projeto: Otimização em design aeroelástico."
                              ],
                              "realWorldApplication": "Em projetos de aeronaves, calcular ξ_n garante que modos críticos de asas ou fuselagens tenham amortecimento adequado (>0.02), prevenindo flutter catastrófico, como no redesign da asa do Harrier Jump Jet para estabilidade em manobras."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "57.2.1.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "57.2.1.3",
                        "name": "Limitações em Estruturas com Múltiplos Graus de Liberdade",
                        "description": "Restrições do modelo de Rayleigh em sistemas MDOF, como inadequação para modos com amplificações de amortecimento díspares.",
                        "specificSkills": [
                          {
                            "id": "57.2.1.3.1",
                            "name": "Identificar condições de não-proporcionalidade",
                            "description": "Avaliar quando C não comuta com M e K, resultando em modos complexos e acoplamento não-clássico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Amortecimento Proporcional em Sistemas MDOF",
                                  "subSteps": [
                                    "Relembrar a equação de movimento geral para sistemas MDOF: Mẍ + Cẋ + Kx = 0.",
                                    "Definir amortecimento proporcional clássico (Rayleigh): C = αM + βK.",
                                    "Explicar por que, nesse caso, C comuta com M e K (propriedade [C,M]=0 e [C,K]=0).",
                                    "Discutir implicações: modos reais e desacoplados.",
                                    "Resolver um exemplo simples de 2DOF com amortecimento proporcional."
                                  ],
                                  "verification": "Resolver manualmente um sistema 2DOF proporcional e confirmar autovalores reais.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Livro de Dinâmica de Estruturas (ex: Clough & Penzien), MATLAB ou Python (NumPy/SciPy).",
                                  "tips": "Use matrizes diagonalizáveis para visualizar comutação.",
                                  "learningObjective": "Compreender as bases do amortecimento proporcional e sua comutatividade.",
                                  "commonMistakes": "Confundir comutação com simetria; sempre verificar [A,B]=AB-BA=0."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aprender Conceitos de Comutação de Matrizes",
                                  "subSteps": [
                                    "Definir comutador de matrizes: [A,B] = AB - BA.",
                                    "Demonstrar propriedades: se A e B são simétricas e C=αA+βB, então [C,A]=[C,B]=0.",
                                    "Calcular comutadores para matrizes de massa M, rigidez K e amortecimento C genérica.",
                                    "Identificar quando C não comuta: introduzir termo não-proporcional em C.",
                                    "Verificar numericamente comutadores próximos de zero (tolerância 1e-10)."
                                  ],
                                  "verification": "Implementar função em MATLAB para calcular [C,M] e [C,K]; confirmar norma < 1e-12 para proporcional.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "MATLAB ou Octave, tutoriais de álgebra linear (Khan Academy).",
                                  "tips": "Use comando comm(A,B) no Symbolic Toolbox para prova analítica.",
                                  "learningObjective": "Dominar cálculo e interpretação de comutadores em contexto dinâmico.",
                                  "commonMistakes": "Ignorar normalização; sempre use normas de Frobenius para magnitude."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Condições de Não-Proporcionalidade",
                                  "subSteps": [
                                    "Construir matriz C não-proporcional: adicionar termo off-diagonal assimétrico.",
                                    "Testar condição: calcular [C,M] e [C,K]; se ||[C,M]|| > ε ou ||[C,K]|| > ε, não-proporcional.",
                                    "Analisar espectro de autovalores do problema generalizado (λ²M + λC + K).",
                                    "Comparar com caso proporcional: observar autovalores complexos conjugados.",
                                    "Variar parâmetros em C para threshold de proporcionalidade (ex: fator γ em C = αM + βK + γN)."
                                  ],
                                  "verification": "Gerar plot de norma do comutador vs. γ; identificar região não-proporcional.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Software Eigensolver (MATLAB eig), planilha Excel para casos simples.",
                                  "tips": "Comece com 2DOF para intuição; escale para 3DOF.",
                                  "learningObjective": "Aplicar testes numéricos e analíticos para detectar não-proporcionalidade.",
                                  "commonMistakes": "Assumir simetria implica comutação; teste sempre explicitamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Consequências: Modos Complexos e Acoplamento Não-Clássico",
                                  "subSteps": [
                                    "Resolver autovalores/vetores para C não-proporcional: notar partes reais/imaginárias nos modos.",
                                    "Explicar acoplamento não-clássico: modos perdem ortogonalidade em M e K.",
                                    "Simular resposta temporal: observar beating ou respostas assimétricas entre DOFs.",
                                    "Comparar damping ratios modais: discrepância entre proporcional e não.",
                                    "Documentar thresholds práticos para engenharia aeroespacial (ex: γ < 0.1)."
                                  ],
                                  "verification": "Simulação time-domain mostra oscilações complexas não vistas no caso proporcional.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "MATLAB Simulink ou ODE solvers, artigos sobre aeroelasticidade.",
                                  "tips": "Use modal assurance criterion (MAC) para quantificar acoplamento.",
                                  "learningObjective": "Ligar não-proporcionalidade a fenômenos físicos observáveis.",
                                  "commonMistakes": "Interpretar autovalores complexos como instabilidade; são normais em não-proporcional."
                                }
                              ],
                              "practicalExample": "Considere uma viga 2DOF (translação e rotação) com M = diag(1,1), K = [[2,-1],[-1,1]], C_proporcional = 0.1M + 0.05K. Adicione γN onde N=[[0,1],[0,0]] e γ=0.2. Calcule [C,M] e [C,K]; normas >1e-6 confirmam não-proporcionalidade. Autovalores: de reais para complexos (ex: -0.05 ± 0.3i).",
                              "finalVerifications": [
                                "Calcular corretamente comutadores para 3 exemplos dados.",
                                "Identificar não-proporcionalidade em sistema desconhecido com acurácia >95%.",
                                "Explicar verbalmente modos complexos vs. reais.",
                                "Simular e plotar resposta temporal distinguindo casos.",
                                "Listar 3 consequências em estruturas aeroespaciais.",
                                "Aplicar critério de threshold γ<0.1 corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de comutadores (erro <1e-10).",
                                "Correta interpretação de autovalores complexos.",
                                "Qualidade de simulações e plots (legendas, escalas).",
                                "Profundidade na análise de acoplamento modal.",
                                "Clareza na ligação com limitações do Rayleigh damping.",
                                "Criatividade em exemplos personalizados."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Teoria espectral e comutadores.",
                                "Física: Dinâmica vibracional e dissipação de energia.",
                                "Controle de Sistemas: Modos não-ortogonais em controle ativo.",
                                "Programação Numérica: Solvers de autovalores em engenharia computacional."
                              ],
                              "realWorldApplication": "Em asas de aeronaves, amortecimento não-proporcional (devido a fluid-estrutura) leva a acoplamento modal em flutter analysis; identificar permite usar métodos state-space em vez de modal decoupling, essencial para certificação FAA em projetos como Boeing 787."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "57.2.1.2"
                            ]
                          },
                          {
                            "id": "57.2.1.3.2",
                            "name": "Analisar discrepâncias em fatores de amortecimento",
                            "description": "Comparar ξ_n calculados para modos baixos e altos, identificando limitações em estruturas aeroespaciais com modos próximos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o modelo de amortecimento de Rayleigh e a fórmula para ξ_n",
                                  "subSteps": [
                                    "Estudar a equação geral do modelo de Rayleigh: c = a m + b k, onde a é coeficiente massal e b rígido.",
                                    "Derivar a expressão para o fator de amortecimento modal: ξ_n = (a / (2 ω_n)) + (b ω_n / 2).",
                                    "Identificar os termos dominantes: massal para modos baixos (baixas ω_n) e rígido para modos altos.",
                                    "Analisar premissas do modelo: amortecimento proporcional e modos bem separados.",
                                    "Resolver exercícios simples de cálculo de ξ_n para um único modo."
                                  ],
                                  "verification": "Capacidade de derivar corretamente ξ_n a partir da equação de Rayleigh e explicar os termos dominantes verbalmente ou por escrito.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de dinâmica estrutural (ex: Clough & Penzien), software MATLAB ou Python para simulações básicas, calculadora.",
                                  "tips": "Sempre normalize as frequências modais em rad/s para evitar erros unitários.",
                                  "learningObjective": "Compreender matematicamente como o modelo de Rayleigh distribui o amortecimento nos modos.",
                                  "commonMistakes": "Confundir unidades de frequência (Hz vs rad/s); ignorar que a e b são constantes globais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Obter frequências modais de uma estrutura aeroespacial",
                                  "subSteps": [
                                    "Selecionar uma estrutura modelo, como uma viga cantilever representando uma asa.",
                                    "Calcular ou extrair frequências modais ω_n usando análise modal (FEM ou analítica).",
                                    "Identificar modos baixos (n=1,2) e altos (n=5,6+), listando ω_1 < ω_2 << ω_5.",
                                    "Verificar separação modal: calcular razão ω_{n+1}/ω_n > 1.5 para modos bem separados.",
                                    "Documentar os primeiros 6-8 modos em uma tabela."
                                  ],
                                  "verification": "Tabela completa de ω_n com pelo menos 6 modos e razões de separação calculadas corretamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software ANSYS/NASTRAN para FEM, ou código Python com NumPy/SciPy para análise modal analítica.",
                                  "tips": "Use elementos finitos com malha convergida para precisão nas frequências altas.",
                                  "learningObjective": "Extrair dados modais realistas de estruturas aeroespaciais.",
                                  "commonMistakes": "Subestimar modos altos por malha grosseira; não normalizar massas/inércias."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular ξ_n para modos baixos e altos",
                                  "subSteps": [
                                    "Ajustar a e b do modelo Rayleigh para coincidir com ξ médio experimental (ex: ξ=0.02).",
                                    "Computar ξ_n baixo: dominado por a/(2ω_n) para n=1,2.",
                                    "Computar ξ_n alto: dominado por b ω_n /2 para n=5,6.",
                                    "Plotar ξ_n vs ω_n e observar o 'V' característico (mínimo no meio).",
                                    "Calcular erro médio: |ξ_n - ξ_target| / ξ_target para todos os modos."
                                  ],
                                  "verification": "Gráfico de ξ_n vs ω_n com cálculos tabulados e erro <20% para modos selecionados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB/Python para plotagem (Matplotlib), planilha Excel para tabelas.",
                                  "tips": "Escolha a e b minimizando erro quadrático para melhor ajuste.",
                                  "learningObjective": "Aplicar numericamente o modelo Rayleigh em múltiplos modos.",
                                  "commonMistakes": "Usar ξ_target inconsistente; plotar em escala log sem linearizar."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar discrepâncias e identificar limitações com modos próximos",
                                  "subSteps": [
                                    "Comparar ξ_n calculados vs ξ desejado, destacando subestimação em baixos e superestimação em altos.",
                                    "Simular modos próximos alterando geometria (ex: encurtar viga para ω_3 ≈ ω_2).",
                                    "Quantificar discrepância: Δξ = max(|ξ_n baixo - ξ_target|, |ξ_n alto - ξ_target|).",
                                    "Explicar limitações: Rayleigh assume modos ortogonais independentes; falha em acoplamento.",
                                    "Propor alternativas: modelo de Rayleigh-Ritz ou amortecimento não-proporcional."
                                  ],
                                  "verification": "Relatório com gráficos de discrepância, Δξ >0.01 e discussão de causas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software FEM avançado, relatório em LaTeX/Word.",
                                  "tips": "Teste sensibilidade variando separação modal em 10% increments.",
                                  "learningObjective": "Diagnosticar falhas do modelo Rayleigh em cenários realistas aeroespaciais.",
                                  "commonMistakes": "Atribuir discrepâncias só a a/b errados, ignorando proximidade modal."
                                }
                              ],
                              "practicalExample": "Em uma asa de UAV modelada como viga cantilever (L=2m, EI=1e6 Nm², m=10 kg/m): ω1=5 rad/s, ω2=15, ω3=35, ω4=70. Ajuste Rayleigh para ξ=0.015. ξ1=0.025 (alta), ξ4=0.03 (alta), mas se ω3=16 (próximo a ω2), Δξ>0.02, indicando limitação.",
                              "finalVerifications": [
                                "Gráfico ξ_n vs ω_n mostra 'V' com discrepâncias quantificadas.",
                                "Identificação correta de modos próximos (razão <1.2).",
                                "Cálculo de Δξ >5% para modos extremos.",
                                "Explicação verbal das limitações do Rayleigh.",
                                "Sugestão de modelo alternativo viável.",
                                "Relatório com todos os cálculos reproduzíveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de ξ_n (<5% erro numérico).",
                                "Análise qualitativa das discrepâncias (causas físicas corretas).",
                                "Quantificação de limitações (Δξ e razões modais).",
                                "Uso adequado de ferramentas (plots, FEM).",
                                "Clareza no relatório e exemplos práticos.",
                                "Criatividade em simulações de modos próximos."
                              ],
                              "crossCurricularConnections": [
                                "Análise Modal em Vibrações Mecânicas (engenharia mecânica).",
                                "Controle Ativo de Flutter (aeroelasticidade).",
                                "Otimização de Parâmetros (otimização numérica).",
                                "Processamento de Sinais (identificação modal experimental)."
                              ],
                              "realWorldApplication": "No design de asas de aeronaves comerciais (ex: Boeing 787), análise de discrepâncias em ξ_n previne flutter induzido por amortecimento inadequado em modos próximos da cauda ou hélices de turbinas, garantindo certificação FAA com margens de estabilidade."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "57.2.1.2.3"
                            ]
                          },
                          {
                            "id": "57.2.1.3.3",
                            "name": "Discutir alternativas ao modelo de Rayleigh",
                            "description": "Comparar com amortecimento modal geral ou métodos não-proporcionais, citando referências como Meirovitch ou Rao.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Modelo de Rayleigh e Identificar suas Limitações",
                                  "subSteps": [
                                    "Relembrar a formulação do modelo de Rayleigh: c = αM + βK, onde M é massa e K rigidez.",
                                    "Analisar suposições: amortecimento proporcional (modos desacoplados).",
                                    "Identificar limitações para MDOF: modos não-ortogonais em amortecimento, imprecisão em frequências próximas.",
                                    "Estudar exemplos onde falha: estruturas assimétricas ou com amortecedores localizados.",
                                    "Documentar 3-5 limitações específicas em contextos aeroespaciais."
                                  ],
                                  "verification": "Lista de limitações documentada com equações e exemplos, revisada por auto-perguntas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Meirovitch (Cap. 9), notas de aula, software MATLAB para simulação simples.",
                                  "tips": "Use diagramas modais para visualizar desacoplamento falho.",
                                  "learningObjective": "Compreender por que Rayleigh é inadequado para sistemas MDOF complexos.",
                                  "commonMistakes": "Confundir Rayleigh com Rayleigh-Ritz (aproximação espacial)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Amortecimento Modal Geral",
                                  "subSteps": [
                                    "Definir matriz de amortecimento geral [C] não-proporcional.",
                                    "Explicar diagonalização modal via decomposição espectral ou iterativa.",
                                    "Derivar equações modais generalizadas: resolver problema de autovalores complexos.",
                                    "Comparar com Rayleigh: necessidade de matrizes de massa/ rigidez generalizadas.",
                                    "Implementar numéricamente em código para um sistema 2-DOF."
                                  ],
                                  "verification": "Código executado mostrando modos complexos e frequências/amortecimentos modais.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Rao 'Vibration of Continuous Systems' (Seção 4.5), MATLAB ou Python (NumPy/SciPy).",
                                  "tips": "Comece com sistema 2x2 para validar eigenvectors complexos.",
                                  "learningObjective": "Dominar formulação modal para amortecimento arbitrário.",
                                  "commonMistakes": "Ignorar partes imaginárias nos autovalores (frequências e amortecimento)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Métodos Não-Proporcionais",
                                  "subSteps": [
                                    "Descrever métodos state-space: reformular como sistema de primeira ordem.",
                                    "Estudar abordagens de redução modal (ex: modo dominante).",
                                    "Discutir métodos híbridos: Rayleigh + correções locais.",
                                    "Analisar complexidade computacional vs. precisão.",
                                    "Citar aplicações: painéis aeroelásticos com amortecimento viscoso."
                                  ],
                                  "verification": "Resumo escrito de 3 métodos com prós/contras e pseudocódigo.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Meirovitch 'Principles and Techniques of Vibrations' (Cap. 10), artigos IEEE sobre aeroelasticidade.",
                                  "tips": "Compare tempo de CPU via simulações simples.",
                                  "learningObjective": "Identificar ferramentas para amortecimento não-clássico em engenharia.",
                                  "commonMistakes": "Assumir ortogonalidade modal sem verificar não-proporcionalidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Alternativas e Citar Referências",
                                  "subSteps": [
                                    "Criar tabela comparativa: Rayleigh vs. Modal Geral vs. Não-Proporcionais (precisão, custo, casos de uso).",
                                    "Discutir critérios de escolha: DOF, simetria, dados experimentais.",
                                    "Citar Meirovitch (p. 456-460) e Rao (exemplos numéricos).",
                                    "Avaliar em contexto aeroespacial: vibrações de fuselagem.",
                                    "Preparar argumentos para discussão em grupo."
                                  ],
                                  "verification": "Tabela e ensaio de 300 palavras submetidos para revisão.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Referências citadas, LaTeX ou Word para tabela.",
                                  "tips": "Use métricas quantitativas como erro percentual em simulações.",
                                  "learningObjective": "Sintetizar comparações críticas com suporte bibliográfico.",
                                  "commonMistakes": "Citar fontes sem page numbers ou contexto específico."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar em Exemplo Prático e Sintetizar Discussão",
                                  "subSteps": [
                                    "Simular viga cantilever 3-DOF com [C] não-proporcional.",
                                    "Aplicar Rayleigh, modal geral e state-space; plotar respostas transitórias.",
                                    "Quantificar discrepâncias em picos de deslocamento.",
                                    "Concluir recomendações para design aeroespacial.",
                                    "Gravar vídeo de 2min explicando insights."
                                  ],
                                  "verification": "Plots e vídeo mostrando diferenças >10% em Rayleigh.",
                                  "estimatedTime": "70 minutos",
                                  "materials": "MATLAB Simulink ou ANSYS para simulação avançada.",
                                  "tips": "Normalize respostas para comparação clara.",
                                  "learningObjective": "Demonstrar superioridade de alternativas via evidência numérica.",
                                  "commonMistakes": "Escolher sistema trivial onde Rayleigh funciona bem."
                                }
                              ],
                              "practicalExample": "Em uma asa de aeronave com amortecedores piezelétricos localizados (não-proporcional), simule vibrações forçadas a 10Hz: Rayleigh subestima damping no modo 2 em 25%, enquanto modal geral captura acoplamento modal corretamente, evitando predição errônea de flutter.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 limitações de Rayleigh em MDOF.",
                                "Derivar equações modais para [C] geral em quadro branco.",
                                "Apresentar tabela comparativa com citações precisas.",
                                "Executar simulação mostrando falha de Rayleigh.",
                                "Defender escolha de método para caso aeroespacial real.",
                                "Identificar quando usar cada alternativa."
                              ],
                              "assessmentCriteria": [
                                "Precisão técnica na descrição de métodos (90% correção).",
                                "Profundidade da comparação quantitativa (métricas incluídas).",
                                "Citações relevantes e contextualizadas (mín. 3 refs).",
                                "Clareza na comunicação (diagramas/tabelas eficazes).",
                                "Criatividade em exemplo prático aeroespacial.",
                                "Identificação correta de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (autovalores complexos, decomposição).",
                                "Física: Dinâmica linear e não-linear de sistemas contínuos.",
                                "Engenharia de Controle: Estabilização via feedback modal.",
                                "Computação: Programação numérica para análise modal (MATLAB/Python)."
                              ],
                              "realWorldApplication": "Na certificação de aeronaves (FAA/EASA), análise precisa de amortecimento não-proporcional previne flutter catastrófico, como no caso do F-111, onde modelos Rayleigh falharam, exigindo métodos modais gerais para wing pivot designs."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "57.2.1.1",
                              "57.2.1.2"
                            ]
                          },
                          {
                            "id": "57.2.1.3.4",
                            "name": "Aplicar em exemplo aeroespacial",
                            "description": "Simular limitações em uma viga ou placa aeroespacial usando MEF, avaliando erro em frequências amortecidas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar a estrutura aeroespacial usando Método dos Elementos Finitos (MEF)",
                                  "subSteps": [
                                    "Selecionar o tipo de estrutura: viga ou placa aeroespacial (ex: viga de suporte de asa).",
                                    "Definir geometria, material (ex: alumínio aeroespacial) e condições de contorno (ex: articulada em uma extremidade).",
                                    "Discretizar a estrutura em elementos finitos (malha com 20-50 elementos).",
                                    "Calcular matrizes de massa [M] e rigidez [K] para múltiplos graus de liberdade.",
                                    "Exportar ou visualizar o modelo inicial no software."
                                  ],
                                  "verification": "Verificar se as matrizes [M] e [K] são simétricas e positivas definidas; comparar deslocamentos estáticos com solução analítica.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Software MEF (ANSYS, Abaqus ou MATLAB com toolbox PDE); propriedades de materiais aeroespaciais.",
                                  "tips": "Comece com malha grosseira para testes rápidos, refine depois.",
                                  "learningObjective": "Construir um modelo MEF preciso para estruturas aeroespaciais com múltiplos DOFs.",
                                  "commonMistakes": "Ignorar condições de contorno reais, levando a modos rígidos; usar malha muito fina no início."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Incorporar o modelo de amortecimento de Rayleigh",
                                  "subSteps": [
                                    "Definir parâmetros de Rayleigh: α (amortecimento mássico) e β (amortecimento rígido) baseados em frequências alvo.",
                                    "Montar matriz de amortecimento [C] = α[M] + β[K].",
                                    "Verificar proporção modal de amortecimento para os primeiros modos (ex: 1-5%).",
                                    "Integrar [C] no sistema dinâmico completo [M]{ẍ} + [C]{ẋ} + [K]{x} = {0}.",
                                    "Testar com eigenvalue problem para modos não amortecidos."
                                  ],
                                  "verification": "Calcular fatores de amortecimento modais; devem estar próximos aos valores especificados (erro <5%).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Mesmo software MEF; tabelas de propriedades de Rayleigh para aeroespaciais.",
                                  "tips": "Use α e β para cobrir faixa de frequências de interesse (ex: primeiras 3 modos).",
                                  "learningObjective": "Implementar corretamente amortecimento de Rayleigh em modelos MEF multi-DOF.",
                                  "commonMistakes": "Escolha errada de α/β causando super ou sub-amortecimento em modos altos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular frequências amortecidas e analisar respostas",
                                  "subSteps": [
                                    "Resolver problema de autovalores complexos para frequências amortecidas ω_d e fatores ζ.",
                                    "Executar análise modal com amortecimento (ex: 10 primeiros modos).",
                                    "Simular resposta transitória a excitação inicial ou harmônica.",
                                    "Plotar curvas de frequência amortecida vs. não amortecida.",
                                    "Exportar resultados numéricos para análise posterior."
                                  ],
                                  "verification": "Frequências amortecidas devem ser ω_d = ω √(1 - ζ²); comparar com teoria para ζ<10%.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Software MEF com solver modal; scripts MATLAB para pós-processamento.",
                                  "tips": "Use solvers iterativos para modelos grandes; monitore convergência.",
                                  "learningObjective": "Executar simulações dinâmicas amortecidas e interpretar frequências resultantes.",
                                  "commonMistakes": "Não linearizar corretamente para autovalores complexos; ignorar normalização modal."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar erros e limitações do modelo Rayleigh em estruturas aeroespaciais",
                                  "subSteps": [
                                    "Comparar frequências simuladas com soluções analíticas ou experimentais (ex: erro percentual).",
                                    "Analisar sensibilidade de α/β em diferentes modos (ex: erro >10% em modos altos).",
                                    "Identificar limitações: Rayleigh assume amortecimento proporcional, falha em não-proporcional.",
                                    "Quantificar erro em frequências amortecidas para viga/placa (ex: tabela de erros modais).",
                                    "Propor melhorias (ex: amortecimento modal geral)."
                                  ],
                                  "verification": "Relatório com erros <5% nos primeiros 3 modos e discussão de limitações.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Dados experimentais de vigas aeroespaciais; Excel/MATLAB para análise de erro.",
                                  "tips": "Foquem em modos dominantes para aplicações práticas.",
                                  "learningObjective": "Criticar limitações do Rayleigh e quantificar erros em contextos reais.",
                                  "commonMistakes": "Subestimar erros em modos superiores; não contextualizar aeroespacialmente."
                                }
                              ],
                              "practicalExample": "Simule uma viga de alumínio de 2m (suporte de asa) com malha de 30 elementos beam, α=0.1, β=0.001. Calcule frequências amortecidas dos primeiros 5 modos e avalie erro vs. solução exata: modo 1 ω_d=45 Hz (erro 2%), modo 5 ω_d=250 Hz (erro 12%).",
                              "finalVerifications": [
                                "Modelo MEF gera matrizes [M], [K], [C] corretas e simétricas.",
                                "Frequências amortecidas calculadas com erro <5% nos modos baixos.",
                                "Relatório identifica limitações do Rayleigh (ex: não captura amortecimento não-proporcional).",
                                "Gráficos de modos e respostas transitórias são claros e rotulados.",
                                "Análise de sensibilidade mostra impacto de α/β.",
                                "Conclusões ligam resultados a design aeroespacial."
                              ],
                              "assessmentCriteria": [
                                "Precisão do modelo MEF (malha convergida, condições corretas: 30%).",
                                "Implementação correta de Rayleigh e simulação modal (25%).",
                                "Quantificação de erros em frequências amortecidas (20%).",
                                "Análise crítica de limitações (15%).",
                                "Clareza de relatórios, gráficos e documentação (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Solução de problemas de autovalores complexos.",
                                "Física: Dinâmica vibracional e teoria de amortecimento.",
                                "Programação: Scripts em MATLAB/Python para automação MEF.",
                                "Engenharia de Materiais: Propriedades viscoelásticas aeroespaciais."
                              ],
                              "realWorldApplication": "Em design de asas de aeronaves, simulações Rayleigh-MEF avaliam flutter e fadiga vibracional, otimizando peso e segurança (ex: Boeing usa para certificação FAA)."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "57.2.1.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.4",
                    "name": "Conceitos Básicos de Vibrações Aleatórias",
                    "description": "Processos estocásticos estacionários, densidade espectral de potência e estatísticas de resposta em estruturas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.4.1",
                        "name": "Processos Estocásticos Estacionários",
                        "description": "Conceitos fundamentais de processos estocásticos estacionários, incluindo definição, propriedades estatísticas como média constante e função de autocorrelação dependente apenas do tempo de defasagem, e sua relevância em modelar excitações aleatórias em estruturas aeroespaciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.1.1",
                            "name": "Definir processo estocástico estacionário",
                            "description": "Explicar a definição de um processo estocástico estacionário de primeira e segunda ordem, diferenciando de processos não estacionários, com exemplos de turbulência atmosférica em aeronaves.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Básicos de Processos Estocásticos",
                                  "subSteps": [
                                    "Defina um processo estocástico como uma coleção de variáveis aleatórias indexadas por tempo ou espaço.",
                                    "Discuta exemplos simples, como o movimento browniano ou ruído branco.",
                                    "Explique a importância de modelar fenômenos imprevisíveis como turbulência atmosférica.",
                                    "Identifique propriedades estatísticas fundamentais: média, variância e covariância.",
                                    "Revise a notação probabilística básica: X(t) ~ distribuição com parâmetros dependentes de t."
                                  ],
                                  "verification": "Resuma em uma frase o que é um processo estocástico e dê um exemplo relacionado à aeronáutica.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Probabilidade e Processos Estocásticos (ex: Papoulis)",
                                    "Notas de aula sobre Mecânica do Voo"
                                  ],
                                  "tips": "Comece com analogias cotidianas, como o clima, para fixar o conceito.",
                                  "learningObjective": "Compreender a definição fundamental de processos estocásticos como base para estacionariedade.",
                                  "commonMistakes": [
                                    "Confundir com processos determinísticos",
                                    "Ignorar o indexamento temporal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Estacionariedade de Primeira Ordem",
                                  "subSteps": [
                                    "Defina estacionariedade de primeira ordem: a distribuição marginal de X(t) é invariante no tempo, i.e., E[X(t)] = μ constante.",
                                    "Derive matematicamente que a média não depende de t.",
                                    "Calcule a média de um exemplo simples, como ruído gaussiano estacionário.",
                                    "Compare com processos onde a média varia, como tendência linear.",
                                    "Aplique ao contexto de turbulência: em janelas curtas de voo, a velocidade média é aproximadamente constante."
                                  ],
                                  "verification": "Prove que para um processo estacionário de 1ª ordem, E[X(t+τ)] = E[X(t)] para qualquer τ.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou software como MATLAB para simulações",
                                    "Folha de fórmulas probabilísticas"
                                  ],
                                  "tips": "Use gráficos de funções de média vs. tempo para visualizar a constância.",
                                  "learningObjective": "Dominar a definição e implicações matemáticas da estacionariedade de primeira ordem.",
                                  "commonMistakes": [
                                    "Confundir com variância constante",
                                    "Esquecer que apenas a 1ª ordem requer média constante"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Estacionariedade de Segunda Ordem",
                                  "subSteps": [
                                    "Estenda para 2ª ordem: média constante e função de autocovariância R(τ) = Cov(X(t), X(t+τ)) depende apenas de τ.",
                                    "Escreva a fórmula: R_X(t1, t2) = R_X(|t1 - t2|).",
                                    "Calcule autocovariância para um processo gaussiano estacionário.",
                                    "Discuta propriedades: R(0) = variância, simetria R(τ) = R(-τ).",
                                    "Relacione com turbulência atmosférica: espectro de potência estacionário em voos estáveis."
                                  ],
                                  "verification": "Dê um exemplo numérico onde Cov(X(0), X(1)) = Cov(X(5), X(6)) mas não para não estacionário.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "MATLAB ou Python (biblioteca NumPy/SciPy)",
                                    "Exemplos de código para autocovariância"
                                  ],
                                  "tips": "Plote a função de autocorrelação para intuir dependência temporal.",
                                  "learningObjective": "Compreender e calcular propriedades de 2ª ordem para processos estacionários.",
                                  "commonMistakes": [
                                    "Assumir estacionariedade ampla sem verificar momentos",
                                    "Confundir covariância com correlação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar de Processos Não Estacionários e Aplicar Exemplos",
                                  "subSteps": [
                                    "Defina não estacionário: média ou covariância dependem explicitamente de t.",
                                    "Exemplos: processo com deriva (não est. 1ª ordem), ruído com variância crescente.",
                                    "Compare estatísticas em turbulência atmosférica: estacionária em escalas curtas vs. não em tempestades longas.",
                                    "Discuta impactos em aeronaves: fadiga estrutural por vibrações aleatórias estacionárias.",
                                    "Simule um exemplo simples em software para visualizar diferenças."
                                  ],
                                  "verification": "Classifique um gráfico de sinal como estacionário ou não, justificando com média e covariância.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de simulação (MATLAB/Python)",
                                    "Dados reais de turbulência (NASA datasets)"
                                  ],
                                  "tips": "Use testes estatísticos como Augmented Dickey-Fuller para prática avançada.",
                                  "learningObjective": "Diferenciar conceitual e praticamente processos estacionários de não estacionários no contexto aeroespacial.",
                                  "commonMistakes": [
                                    "Assumir toda turbulência é estacionária",
                                    "Ignorar contexto temporal específico"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um voo de aeronave, modele as flutuações de velocidade vertical devido à turbulência como um processo gaussiano estacionário de 2ª ordem. Simule 1000 amostras com μ=0, σ²=1, R(τ)=exp(-|τ|/10), plote a realização, verifique média constante e autocovariância dependente apenas de τ, contrastando com uma simulação não estacionária onde variância cresce com tempo.",
                              "finalVerifications": [
                                "Explique verbalmente as diferenças entre estacionariedade de 1ª e 2ª ordem.",
                                "Calcule corretamente a autocovariância para τ=5 em um exemplo dado.",
                                "Identifique se um processo com média constante mas covariância dependente de t é estacionário.",
                                "Aplique o conceito a um dado de turbulência atmosférica real.",
                                "Diferencie com precisão um processo estacionário de não estacionário em um gráfico.",
                                "Liste 3 propriedades matemáticas de processos estacionários de 2ª ordem."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição matemática de estacionariedade (1ª e 2ª ordem).",
                                "Capacidade de diferenciar com exemplos corretos de não estacionários.",
                                "Uso apropriado de fórmulas e cálculos numéricos.",
                                "Relevância ao contexto de turbulência atmosférica em aeronaves.",
                                "Clareza na explicação de propriedades estatísticas.",
                                "Demonstração prática via simulação ou gráfico."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Funções de distribuição e momentos.",
                                "Física: Modelagem de ruído e vibrações em sistemas dinâmicos.",
                                "Engenharia Aeroespacial: Análise de aeroelasticidade e fadiga estrutural.",
                                "Processamento de Sinais: Espectros de potência e filtros.",
                                "Matemática Aplicada: Equações diferenciais estocásticas."
                              ],
                              "realWorldApplication": "Na dinâmica de estruturas aeroespaciais, processos estocásticos estacionários modelam vibrações aleatórias por turbulência atmosférica, permitindo calcular amortecimento de Rayleigh, prever fadiga em asas de aeronaves e otimizar designs para segurança em voos comerciais sob condições turbulentas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.2",
                            "name": "Identificar propriedades de estacionariedade",
                            "description": "Listar e descrever propriedades como invariância estatística no tempo, função de autocorrelação e densidade espectral, aplicando a vibrações induzidas por vento em estruturas aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito fundamental de processos estacionários",
                                  "subSteps": [
                                    "Defina processo estocástico estacionário como um processo cujas propriedades estatísticas não mudam com o tempo.",
                                    "Diferencie entre estacionariedade fraca (primeiros e segundos momentos constantes) e estacionariedade estrita (todas as distribuições invariantes).",
                                    "Revise definições de momentos estatísticos: média, variância e covariância.",
                                    "Estude exemplos simples como ruído branco gaussiano.",
                                    "Discuta implicações em vibrações aleatórias induzidas por vento."
                                  ],
                                  "verification": "Escreva uma definição precisa e liste 3 exemplos de processos estacionários vs. não estacionários.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de texto sobre processos estocásticos (ex: Papoulis), notas de aula, calculadora.",
                                  "tips": "Use analogias como 'clima constante' para intuitivamente captar invariância no tempo.",
                                  "learningObjective": "Explicar o que significa estacionariedade em termos estatísticos e temporais.",
                                  "commonMistakes": "Confundir estacionariedade com periodicidade; assumir que média zero implica estacionariedade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar propriedades de invariância estatística no tempo",
                                  "subSteps": [
                                    "Liste propriedades chave: média constante E[X(t)] = μ, variância constante Var[X(t)] = σ².",
                                    "Descreva autocovariância R(τ) = E[(X(t)-μ)(X(t+τ)-μ)] dependendo apenas de τ.",
                                    "Calcule média e variância de uma amostra simulada de vibrações de vento.",
                                    "Verifique invariância plotando médias móveis ao longo do tempo.",
                                    "Analise dados reais de aceleração em uma estrutura aeroespacial exposta a vento."
                                  ],
                                  "verification": "Gere gráficos mostrando média e variância constantes em uma série temporal simulada.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software MATLAB ou Python (com NumPy/SciPy), dados de séries temporais de vento.",
                                  "tips": "Use janelas deslizantes para testar invariância em dados reais.",
                                  "learningObjective": "Listar e verificar propriedades básicas de invariância estatística.",
                                  "commonMistakes": "Ignorar tendências lineares que mascaram não-estacionariedade; usar amostras muito curtas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a função de autocorrelação",
                                  "subSteps": [
                                    "Defina função de autocorrelação ρ(τ) = R(τ)/R(0) normalizada.",
                                    "Estime ρ(τ) a partir de dados usando fft ou métodos diretos.",
                                    "Interprete propriedades: ρ(0)=1, simétrica ρ(-τ)=ρ(τ), decresce para processos de memória curta.",
                                    "Aplique a vibrações de vento: identifique correlações em rajadas turbulentas.",
                                    "Compare com processos não estacionários como rampas."
                                  ],
                                  "verification": "Plote e interprete a função de autocorrelação de dados de vento em uma asa, confirmando dependência só de τ.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "MATLAB/Python para estimação de ACF, conjunto de dados de turbulência atmosférica (ex: NASA datasets).",
                                  "tips": "Verifique estacionariedade primeiro antes de estimar ACF para evitar viés.",
                                  "learningObjective": "Descrever e calcular a função de autocorrelação como indicador de estacionariedade.",
                                  "commonMistakes": "Não normalizar a ACF; confundir com PSD sem Fourier."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar a densidade espectral e aplicação aeroespacial",
                                  "subSteps": [
                                    "Relacione densidade espectral S(f) via Transformada de Fourier da ACF (Teorema de Wiener-Khinchin).",
                                    "Estime PSD usando Welch's method em dados de vibrações induzidas por vento.",
                                    "Descreva propriedades: S(f) ≥ 0, integral igual a variância.",
                                    "Aplique a estruturas aeroespaciais: identifique picos de ressonância em espectros de vento.",
                                    "Simule impacto em fadiga de asas ou fuselagens."
                                  ],
                                  "verification": "Gere PSD de dados de vento e liste 3 propriedades estacionárias observadas.",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Software de análise espectral (MATLAB Signal Processing Toolbox), dados de vibrações aeroespaciais.",
                                  "tips": "Use médias sobre segmentos para reduzir variância na estimação de PSD.",
                                  "learningObjective": "Conectar densidade espectral a propriedades estacionárias em contextos de engenharia aeroespacial.",
                                  "commonMistakes": "Esquecer de remover tendências antes da FFT; interpretar picos como não-estacionariedade."
                                }
                              ],
                              "practicalExample": "Analise dados de aceleração de uma asa de aeronave exposta a vento turbulento (disponível em repositórios como NASA): verifique média constante (~0g), variância estável, ACF decaindo exponencialmente e PSD com espectro de von Karman típico de turbulência estacionária.",
                              "finalVerifications": [
                                "Lista completa de 5 propriedades de estacionariedade com definições precisas.",
                                "Gráficos de média móvel, variância e ACF confirmando invariância.",
                                "Cálculo correto de PSD e interpretação no contexto de vibrações de vento.",
                                "Exemplo aplicado: análise de dados reais de estrutura aeroespacial.",
                                "Resumo escrito conectando propriedades a amortecimento de Rayleigh.",
                                "Teste: diferenciar dados estacionários vs. não estacionários corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e listagem de propriedades (invariância, ACF, PSD).",
                                "Qualidade de análises computacionais (gráficos corretos e interpretações).",
                                "Aplicação contextual a vibrações induzidas por vento em aeroespacial.",
                                "Profundidade dos substeps executados e verificações pessoais.",
                                "Capacidade de identificar erros comuns em exemplos práticos.",
                                "Conexão clara com conceitos maiores como aeroelasticidade."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: momentos e funções de correlação.",
                                "Física: dinâmica de fluidos turbulentos e espectros de energia.",
                                "Engenharia Mecânica: análise modal e fadiga estrutural.",
                                "Processamento de Sinais: FFT e estimação espectral."
                              ],
                              "realWorldApplication": "Em projetos aeroespaciais, identificar estacionariedade em cargas de vento permite modelar vibrações aleatórias para prever fadiga em asas de aviões ou painéis solares orbitais, otimizando designs contra flutter e ressonâncias destrutivas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.3",
                            "name": "Aplicar em modelagem de excitações aleatórias",
                            "description": "Modelar excitações de base em sistemas estruturais aeroespaciais como processos estacionários, utilizando equações diferenciais estocásticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Processos Estacionários em Vibrações Aleatórias",
                                  "subSteps": [
                                    "Defina processos estacionários e suas propriedades chave (média constante, autocorrelação dependente apenas de lag).",
                                    "Estude funções de densidade de probabilidade e espectros de potência para sinais estacionários.",
                                    "Revise exemplos de excitações aleatórias em aeroespacial, como turbulência atmosférica.",
                                    "Calcule estatísticas básicas (média, variância) para um processo gaussiano estacionário.",
                                    "Compare processos estacionários com não-estacionários em contextos estruturais."
                                  ],
                                  "verification": "Resuma as propriedades de um processo estacionário em um diagrama e calcule corretamente a autocorrelação para um exemplo dado.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro 'Random Vibrations' de Newland; software MATLAB para plots de autocorrelação.",
                                  "tips": "Use simulações simples em MATLAB para visualizar estacionariedade antes de prosseguir.",
                                  "learningObjective": "Identificar e caracterizar processos estacionários aplicáveis a excitações estruturais.",
                                  "commonMistakes": "Confundir estacionariedade com ergodicidade; assumir gaussianidade sem justificativa."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Caracterizar Excitações de Base em Sistemas Aeroespaciais",
                                  "subSteps": [
                                    "Identifique fontes de excitações de base: turbulência, jato de motor, movimento de base em pouso.",
                                    "Meça ou modele o espectro de potência da excitação (ex: von Kármán para turbulência).",
                                    "Determine parâmetros como intensidade RMS e frequência de corte.",
                                    "Ajuste o modelo ao contexto aeroespacial (ex: aceleração de base em fuselagem).",
                                    "Valide com dados experimentais de testes de vibração."
                                  ],
                                  "verification": "Crie um espectro de potência para uma excitação de base típica e compare com curvas padrão.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Dados de turbulência NASA; software como ANSYS ou MATLAB Signal Processing Toolbox.",
                                  "tips": "Comece com espectros Dryden ou von Kármán para simplicidade em simulações.",
                                  "learningObjective": "Modelar realisticamente excitações aleatórias específicas de estruturas aeroespaciais.",
                                  "commonMistakes": "Ignorar escalas de comprimento relevantes para aeronaves; usar espectros inadequados para regime subsônico/supersônico."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular Equações Diferenciais Estocásticas (EDEs)",
                                  "subSteps": [
                                    "Escreva a EDO determinística base para o sistema estrutural (ex: equação do oscilador com Rayleigh damping).",
                                    "Incorpore a excitação estacionária como termo estocástico w(t).",
                                    "Expresse como EDE no formato du = A u dt + B dw, usando integral de Wiener.",
                                    "Inclua amortecimento de Rayleigh e modos múltiplos se aplicável.",
                                    "Derive a equação de covariância para solução estatística."
                                  ],
                                  "verification": "Derive corretamente a EDE para um sistema SDOF com excitação de base estacionária.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Livro 'Stochastic Differential Equations' de Øksendal; papel e lápis para derivações.",
                                  "tips": "Use a representação de estado-espaco para facilitar simulações numéricas.",
                                  "learningObjective": "Traduzir problemas físicos em EDEs estacionárias precisas.",
                                  "commonMistakes": "Esquecer o termo de acoplamento na excitação de base; confundir dW com dt."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver e Simular o Modelo Estocástico",
                                  "subSteps": [
                                    "Implemente simulação Monte Carlo usando Euler-Maruyama para EDEs.",
                                    "Calcule respostas estatísticas: desvios padrão de deslocamento, espectro de resposta.",
                                    "Compare soluções analíticas (ex: fórmula de resposta em frequência) com numéricas.",
                                    "Analise sensibilidade a parâmetros do processo estacionário.",
                                    "Otimize passos de tempo para convergência estatística."
                                  ],
                                  "verification": "Gere 100 realizações e confirme que a variância simulada converge para o valor teórico.",
                                  "estimatedTime": "5 horas",
                                  "materials": "MATLAB ou Python (com NumPy/SciPy); código template para SDE solvers.",
                                  "tips": "Use 10^4-10^5 passos por realização para precisão em frequências altas.",
                                  "learningObjective": "Aplicar métodos numéricos para obter respostas estacionárias confiáveis.",
                                  "commonMistakes": "Passos de tempo grandes causando instabilidade; amostras insuficientes para estatísticas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Analisar o Modelo",
                                  "subSteps": [
                                    "Compare com dados experimentais ou benchmarks aeroespaciais.",
                                    "Avalie fadiga cumulativa usando resposta de pico ou espectral.",
                                    "Teste robustez variando parâmetros do processo.",
                                    "Documente limitações (ex: linearidade assumida).",
                                    "Proponha melhorias como modelo não-linear."
                                  ],
                                  "verification": "Produza relatório com gráficos de espectro de resposta matching dados reais ±10%.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Dados de testes de vibração (ex: FAA/NASA databases); ferramentas de plotagem.",
                                  "tips": "Use critérios de Welch para estimar espectros de simulações.",
                                  "learningObjective": "Garantir validade prática do modelo em cenários aeroespaciais.",
                                  "commonMistakes": "Sobreajuste ao ruído; ignorar efeitos multimodais."
                                }
                              ],
                              "practicalExample": "Modelar a excitação de base devido a turbulência atmosférica em uma asa de aeronave comercial (ex: Boeing 737), usando espectro von Kármán para simular deslocamentos na raiz da asa e prever fadiga estrutural em voo de cruzeiro.",
                              "finalVerifications": [
                                "O modelo reproduz corretamente o espectro de resposta estacionário.",
                                "Estatísticas simuladas (média, RMS) convergem com <5% de erro após 50 realizações.",
                                "A EDE é estável numericamente para dt < 0.01s.",
                                "Análise de sensibilidade identifica parâmetros críticos.",
                                "Comparação com benchmarks experimentais mostra boa concordância.",
                                "Documentação inclui código fonte e resultados reproduzíveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação da EDE (100% corretude derivacional).",
                                "Qualidade da simulação (convergência estatística demonstrada).",
                                "Relevância do modelo ao contexto aeroespacial (uso de espectros reais).",
                                "Análise de resultados (gráficos claros, interpretações físicas).",
                                "Identificação de erros comuns e limitações.",
                                "Clareza na documentação e verificações."
                              ],
                              "crossCurricularConnections": [
                                "Probabilidade e Estatística: Cálculo de momentos e espectros.",
                                "Controle de Sistemas: Análise em domínio de frequência para atenuação.",
                                "Física Computacional: Métodos numéricos para SDEs.",
                                "Engenharia de Materiais: Previsão de fadiga sob carregamento aleatório."
                              ],
                              "realWorldApplication": "No design de aeronaves, esse modelo é usado para certificar estruturas contra vibrações aleatórias de turbulência, otimizando peso e segurança em conformidade com normas FAA/EASA, prevenindo falhas como flutter ou fadiga em missões longas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.2",
                        "name": "Densidade Espectral de Potência (PSD)",
                        "description": "Representação em frequência da potência de um sinal aleatório estacionário, sua relação com a função de autocorrelação via Teorema de Wiener-Khintchine, e uso em análise de vibrações estruturais.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.2.1",
                            "name": "Definir densidade espectral de potência",
                            "description": "Descrever a PSD como a transformada de Fourier da função de autocorrelação, interpretando sua unidade (potência por Hz) em contextos aeroespaciais como ruído de motor.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Função de Autocorrelação",
                                  "subSteps": [
                                    "Definir a função de autocorrelação para processos estacionários: R(τ) = E[X(t)X(t+τ)]",
                                    "Explicar propriedades principais: simetria R(τ) = R(-τ), valor máximo em τ=0 e R(0) = potência média",
                                    "Discutir o significado físico: medida de similaridade do sinal consigo mesmo em diferentes defasagens (lags)",
                                    "Exemplificar com sinal periódico e ruído branco",
                                    "Derivar a relação com a variância para τ=0"
                                  ],
                                  "verification": "Explicar verbalmente a autocorrelação e calcular R(0) para um sinal simples",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Processamento de Sinais (ex: Oppenheim)",
                                    "Calculadora ou software MATLAB/Python",
                                    "Notas sobre processos estocásticos"
                                  ],
                                  "tips": [
                                    "Visualize a autocorrelação como um 'eco' do sinal em diferentes tempos.",
                                    "Comece com sinais determinísticos antes de aleatórios."
                                  ],
                                  "learningObjective": "Entender a autocorrelação como base para análise espectral de sinais aleatórios.",
                                  "commonMistakes": [
                                    "Confundir com correlação cruzada.",
                                    "Ignorar a hipótese de estacionariedade.",
                                    "Esquecer que é uma expectativa estatística."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar a Transformada de Fourier",
                                  "subSteps": [
                                    "Recordar a Transformada de Fourier (FT) para funções: S(f) = ∫ R(τ) e^{-j2πfτ} dτ",
                                    "Explicar o Teorema de Wiener-Khinchin: PSD é a FT da autocorrelação",
                                    "Discutir convergência para funções positivas definidas",
                                    "Verificar propriedades: PSD é real e par, integra a potência total",
                                    "Diferenciar FT contínua de discreta (DFT/FFT para prática)"
                                  ],
                                  "verification": "Derivar qualitativamente a relação FT-autocorrelação e citar o teorema",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela de transformadas de Fourier",
                                    "Software Python (numpy.fft)",
                                    "Vídeo tutorial sobre Wiener-Khinchin"
                                  ],
                                  "tips": [
                                    "Lembre-se: autocorrelação no tempo → espectro no domínio da frequência.",
                                    "Use simetria para simplificar cálculos."
                                  ],
                                  "learningObjective": "Conectar transformada de Fourier com análise de sinais aleatórios.",
                                  "commonMistakes": [
                                    "Confundir FT direta do sinal com FT da autocorrelação.",
                                    "Esquecer o sinal negativo na exponencial.",
                                    "Aplicar FT sem verificar positividade."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Formalmente a Densidade Espectral de Potência (PSD)",
                                  "subSteps": [
                                    "Definir PSD: S(f) = FT{R(τ)}, com unidade potência por Hertz (W/Hz)",
                                    "Verificar propriedades: ∫ S(f) df = R(0) = potência total",
                                    "Explicar bilateral vs unilateral: S(f) para f de -∞ a ∞",
                                    "Discutir estimativas práticas: método de Welch ou Blackman-Tukey",
                                    "Calcular PSD para ruído branco: S(f) = constante (N0/2)"
                                  ],
                                  "verification": "Escrever a definição matemática de PSD e calcular potência total a partir dela",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Folha de derivações matemáticas",
                                    "MATLAB ou Python (scipy.signal.welch)",
                                    "Exemplos de PSD de ruído"
                                  ],
                                  "tips": [
                                    "Sempre normalize pela largura de banda para obter potência.",
                                    "Plote logarítmico para visualizar melhor."
                                  ],
                                  "learningObjective": "Definir PSD matematicamente e entender suas propriedades fundamentais.",
                                  "commonMistakes": [
                                    "Confundir PSD com espectro de potência de sinais determinísticos.",
                                    "Errar a unidade (potência vs amplitude).",
                                    "Ignorar fator de escala na FT discreta."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar PSD em Contextos Aeroespaciais",
                                  "subSteps": [
                                    "Aplicar a ruído de motor: picos em harmônicos de rotação",
                                    "Interpretar: densidade de potência em faixas de frequência críticas para fadiga",
                                    "Discutir filtros passa-banda para vibrações estruturais",
                                    "Analisar largura de banda: ruído estreito vs largo",
                                    "Relacionar com normas aeroespaciais (ex: MIL-STD para vibrações)"
                                  ],
                                  "verification": "Descrever como PSD do ruído de motor afeta estruturas aeroespaciais",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Dados reais de PSD de motores (NASA datasets)",
                                    "Artigo sobre vibrações aleatórias em aeronaves",
                                    "Software de plotagem (Matplotlib)"
                                  ],
                                  "tips": [
                                    "Pense em Hz como 'frequência de ressonância' da estrutura.",
                                    "Compare com medições experimentais."
                                  ],
                                  "learningObjective": "Aplicar conceito de PSD a problemas reais de engenharia aeroespacial.",
                                  "commonMistakes": [
                                    "Interpretar amplitude como potência total sem integrar.",
                                    "Ignorar efeitos não-lineares em altas amplitudes.",
                                    "Generalizar ruído de motor como branco."
                                  ]
                                }
                              ],
                              "practicalExample": "Simule um sinal de ruído de motor em Python: gere um sinal estacionário com autocorrelação exponencial decaindo, compute sua FT para obter PSD, plote e identifique picos em 100-500 Hz representando harmônicos de rotação, integrando para verificar potência total de 10 W.",
                              "finalVerifications": [
                                "Definir PSD como FT da autocorrelação com precisão matemática.",
                                "Explicar unidade W/Hz e relação com potência total.",
                                "Interpretar PSD de ruído de motor aeroespacial corretamente.",
                                "Citar Teorema de Wiener-Khinchin.",
                                "Identificar propriedades como realidade e simetria.",
                                "Calcular potência a partir de PSD integrada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição matemática (80% correto).",
                                "Correta interpretação da unidade e propriedades (exemplos contextualizados).",
                                "Capacidade de ligar a autocorrelação e FT.",
                                "Aplicação aeroespacial relevante (ruído/vibrações).",
                                "Uso correto de terminologia técnica.",
                                "Demonstração prática via cálculo ou simulação."
                              ],
                              "crossCurricularConnections": [
                                "Processamento de Sinais Digitais (estimação prática de PSD).",
                                "Estatística e Probabilidade (processos estocásticos estacionários).",
                                "Dinâmica de Estruturas (análise de vibrações forçadas).",
                                "Acústica e Ruído (análise espectral de som).",
                                "Controle Automático (espectros em sistemas lineares)."
                              ],
                              "realWorldApplication": "Na engenharia aeroespacial, a PSD é usada para analisar vibrações aleatórias induzidas por ruído de motores em aeronaves, prevendo fadiga estrutural, otimizando amortecedores e garantindo conformidade com normas de certificação como FAA ou EASA, evitando falhas catastróficas em voo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.2",
                            "name": "Calcular PSD a partir de autocorrelação",
                            "description": "Aplicar o Teorema de Wiener-Khintchine para obter a PSD de funções de autocorrelação conhecidas, com exemplos numéricos para cargas aleatórias em asas de aeronaves.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Teorema de Wiener-Khintchine",
                                  "subSteps": [
                                    "Estude a definição formal do teorema: a PSD é a Transformada de Fourier da função de autocorrelação para processos estacionários.",
                                    "Revise os conceitos de processo estocástico estacionário e função de autocorrelação R(τ).",
                                    "Analise a relação matemática: S(ω) = ∫_{-∞}^{∞} R(τ) e^{-jωτ} dτ.",
                                    "Discuta simetria e propriedades de positividade da PSD.",
                                    "Resolva um exemplo simples analítico, como R(τ) = σ² e^{-α|τ|}."
                                  ],
                                  "verification": "Derive a fórmula do teorema e calcule PSD para uma autocorrelação exponencial básica, conferindo com tabela conhecida.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Probabilidade e Processos Estocásticos' (Papoulis)",
                                    "Notas de aula sobre vibrações aleatórias",
                                    "Calculadora simbólica como Wolfram Alpha"
                                  ],
                                  "tips": "Lembre-se que o teorema vale para processos de largura de banda estreita e estacionários; visualize graficamente R(τ) e S(ω).",
                                  "learningObjective": "Dominar a relação teórica entre autocorrelação e PSD via Teorema de Wiener-Khintchine.",
                                  "commonMistakes": [
                                    "Confundir PSD com espectro de potência bilateral vs. unilateral",
                                    "Esquecer o fator de normalização na transformada",
                                    "Aplicar a sinais não estacionários"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Propriedades da Autocorrelação e PSD",
                                  "subSteps": [
                                    "Liste propriedades da autocorrelação: R(0) = potência média, simetria par, decresce para τ grande.",
                                    "Estude propriedades da PSD: não-negativa, integral igual a R(0), simétrica para sinais reais.",
                                    "Verifique o teorema inverso: autocorrelação é inversa Fourier da PSD.",
                                    "Analise impacto de filtros lineares na PSD via convolução.",
                                    "Pratique com funções conhecidas: white noise (PSD constante), banda limitada."
                                  ],
                                  "verification": "Prove que ∫ S(ω) dω / 2π = R(0) e liste 3 propriedades compartilhadas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Artigo 'Wiener-Khintchine Theorem' (Wikipedia ou IEEE)",
                                    "Software MATLAB para plotar R(τ) e S(ω)",
                                    "Folha de exercícios de propriedades estocásticas"
                                  ],
                                  "tips": "Use simulações para visualizar: gere sinal gaussiano e compute R(τ) empiricamente.",
                                  "learningObjective": "Identificar e aplicar propriedades fundamentais para validação de cálculos.",
                                  "commonMistakes": [
                                    "Ignorar normalização de frequência (rad/s vs. Hz)",
                                    "Confundir variância com potência total",
                                    "Não considerar periodicidade em sinais discretos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar Cálculos Analíticos e Numéricos",
                                  "subSteps": [
                                    "Escolha uma R(τ) conhecida, como triangular ou exponencial dupla.",
                                    "Compute analiticamente a Fourier: integre por partes ou use tabelas de transformadas.",
                                    "Implemente numericamente via FFT em software: discretize τ e aplique fft(R).",
                                    "Compare analítico vs. numérico, analisando janelamento e aliasing.",
                                    "Ajuste para PSD unilateral: dobre a parte positiva e normalize."
                                  ],
                                  "verification": "Calcule PSD para R(τ) = cos(ω₀ τ) e valide com Dirac em ω=ω₀.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB ou Python (SciPy.signal)",
                                    "Tabelas de Transformadas de Fourier",
                                    "Exercícios numéricos de vibrações aleatórias"
                                  ],
                                  "tips": "Para numérico, use zero-padding para reduzir leakage espectral; sempre plote para inspeção visual.",
                                  "learningObjective": "Executar cálculos precisos tanto analíticos quanto computacionais.",
                                  "commonMistakes": [
                                    "Erro na discretização de τ (passo inadequado)",
                                    "Esquecer fator 1/N na FFT",
                                    "Não lidar com simetria em sinais reais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Cargas Aleatórias em Asas de Aeronaves",
                                  "subSteps": [
                                    "Modele cargas gust como processo gaussiano estacionário com R(τ) medida.",
                                    "Calcule PSD das cargas na raiz da asa usando Wiener-Khintchine.",
                                    "Integre PSD com funções de resposta frequência para resposta estrutural.",
                                    "Gere exemplo numérico: R(τ) de turbulência von Karman, compute PSD.",
                                    "Analise picos de fadiga: encontre RMS e ciclos equivalentes."
                                  ],
                                  "verification": "Simule PSD de carga gust, compute resposta em modo de flexão da asa e verifique energia total.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Software NASTRAN ou MATLAB Aerospace Toolbox",
                                    "Dados de espectros de turbulência (MIL-HDBK-1797)",
                                    "Relatórios de aeroelasticidade (NASA)"
                                  ],
                                  "tips": "Use espectros padrão como Dryden para validação; foque em frequências críticas de flutter.",
                                  "learningObjective": "Aplicar o cálculo em contexto aeroespacial realista.",
                                  "commonMistakes": [
                                    "Não converter unidades (g vs. N/m)",
                                    "Ignorar direção espacial das cargas",
                                    "Subestimar largura de banda da turbulência"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere cargas aleatórias na raiz de uma asa com R(τ) = 10 * exp(-20 |τ|) (unidades N² s). Calcule PSD: S(ω) = (20/400 + ω²). Plote em MATLAB: gere τ de -1 a 1s, fft e normalize. Resultado: PSD Lorentziana com pico em ω=0, decay 1/ω², usada para estimar fadiga em 10^6 ciclos.",
                              "finalVerifications": [
                                "Calcule corretamente PSD analítica para R(τ) exponencial e numérica via FFT com erro <1%.",
                                "Identifique propriedades: S(ω) ≥ 0, ∫ S(ω) dω = R(0).",
                                "Aplique a exemplo de asa: PSD de gust von Karman com picos em 1-5 Hz.",
                                "Prove teorema inverso para uma PSD simples.",
                                "Simule resposta estrutural e verifique conservação de energia.",
                                "Discuta limitações para não-estacionário."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática no cálculo da transformada (erro <5%).",
                                "Correta interpretação física da PSD no contexto aeroespacial.",
                                "Qualidade da implementação numérica (plots limpos, normalização).",
                                "Aplicação contextualizada a cargas em asas (relevância e realismo).",
                                "Identificação de erros comuns e autocorreção.",
                                "Clareza na documentação de passos e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Processamento de Sinais Digitais (FFT e janelamento).",
                                "Estatística e Probabilidade (processos estocásticos).",
                                "Engenharia Mecânica (análise de vibrações e fadiga).",
                                "Programação Computacional (MATLAB/Python para simulações).",
                                "Física (mecânica quântica análoga em espectroscopia)."
                              ],
                              "realWorldApplication": "Na certificação de aeronaves (FAA/EASA), PSD calculada de autocorrelações de cargas gust dimensiona asas contra fadiga, prevendo vida útil sob turbulência real, como em Boeing 787 onde espectros von Karman guiam testes de endurance."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.3",
                            "name": "Interpretar PSD em vibrações estruturais",
                            "description": "Analisar gráficos de PSD para identificar picos de ressonância e largura de banda em respostas de estruturas aeroespaciais a excitações aleatórias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Densidade Espectral de Potência (PSD)",
                                  "subSteps": [
                                    "Estude a definição de PSD como a distribuição de potência de um sinal aleatório em função da frequência.",
                                    "Revise as propriedades matemáticas da PSD, incluindo integral igual à variância do sinal e simetria para sinais reais.",
                                    "Aprenda a relação entre PSD e funções de autocorrelação via Teorema de Wiener-Khinchin.",
                                    "Explore unidades típicas: (aceleração)^2/Hz para vibrações estruturais.",
                                    "Pratique convertendo séries temporais em PSD conceitualmente."
                                  ],
                                  "verification": "Explique em suas palavras o que é PSD e calcule a potência total de um exemplo simples.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de texto sobre vibrações aleatórias (ex: Newland 'Random Vibrations')",
                                    "Vídeos tutoriais sobre PSD no YouTube ou Khan Academy",
                                    "Folha de anotações"
                                  ],
                                  "tips": "Visualize PSD como um 'gráfico de energia por frequência' para intuitivamente entender picos.",
                                  "learningObjective": "Dominar a definição e propriedades básicas da PSD em contextos de vibrações.",
                                  "commonMistakes": [
                                    "Confundir PSD com FFT (PSD é potência média)",
                                    "Ignorar normalização por Hz",
                                    "Esquecer que PSD é para processos estacionários"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Ler e Interpretar Gráficos de PSD",
                                  "subSteps": [
                                    "Identifique os eixos: frequência (Hz) no x, densidade de potência (g²/Hz) no y.",
                                    "Reconheça características: linha de base (ruído), platôs (regiões de potência constante), decaimentos em alta frequência.",
                                    "Pratique plotando PSDs simulados de sinais aleatórios brancos e filtrados.",
                                    "Diferencie PSD de resposta em frequência (FRF) e aceleração RMS.",
                                    "Analise escalas logarítmicas comuns em gráficos de PSD aeroespaciais."
                                  ],
                                  "verification": "Desenhe e rotule um gráfico PSD genérico de vibração estrutural, identificando 3 características chave.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software MATLAB/Python com funções pwelch() ou scipy.signal.welch",
                                    "Gráficos PSD de exemplo de estruturas aeroespaciais (NASA relatórios)",
                                    "Planilha Excel para plotagem manual"
                                  ],
                                  "tips": "Use escala log-log para visualizar melhor faixas dinâmicas amplas em vibrações aeroespaciais.",
                                  "learningObjective": "Habilidade para ler e descrever qualquer gráfico de PSD corretamente.",
                                  "commonMistakes": [
                                    "Ler eixo y como amplitude em vez de potência",
                                    "Confundir frequência com período",
                                    "Ignorar resolução de frequência no gráfico"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Picos de Ressonância em PSD",
                                  "subSteps": [
                                    "Defina ressonância como picos locais onde PSD excede níveis de ruído em pelo menos 10 dB.",
                                    "Meça altura do pico (nível de potência) e localização (frequência natural).",
                                    "Diferencie modos múltiplos: picos adjacentes indicam frequências modais próximas.",
                                    "Considere efeitos de amortecimento: picos mais afiados para baixo amortecimento.",
                                    "Pratique em PSDs reais de testes de vibração random de painéis aeroespaciais."
                                  ],
                                  "verification": "Em um gráfico PSD fornecido, marque e liste 2-3 picos de ressonância com frequências e razões.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Dados PSD de testes shaker (disponíveis em repositórios NASA/ESA)",
                                    "Ferramentas como Octave ou GNUplot para análise",
                                    "Templates de relatório de análise"
                                  ],
                                  "tips": "Compare com modelo modal teórico para validar picos reais vs. artefatos.",
                                  "learningObjective": "Detectar e quantificar picos de ressonância com precisão em PSDs estruturais.",
                                  "commonMistakes": [
                                    "Confundir picos de ruído com ressonância",
                                    "Não considerar vazamento espectral",
                                    "Ignorar direção da excitação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar Largura de Banda e Interpretar Respostas Globais",
                                  "subSteps": [
                                    "Defina largura de banda como largura em meia-potência (-3dB) ao redor do pico.",
                                    "Calcule Q-factor: Q = f_res / Δf, onde Δf é largura de banda.",
                                    "Interprete: Alta Q indica baixa amortecimento; aplique fórmula de Rayleigh.",
                                    "Avalie resposta global: integre PSD para RMS, compare com limites de fadiga.",
                                    "Sintetize: Relacione achados a falhas potenciais em estruturas aeroespaciais."
                                  ],
                                  "verification": "Calcule largura de banda e Q para um pico dado, interpretando implicações de amortecimento.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código Python para cálculo automático de largura de banda",
                                    "Exemplos de normas MIL-STD-810 para vibrações aeroespaciais",
                                    "Calculadora gráfica"
                                  ],
                                  "tips": "Use interpolação linear em escala log para precisão em largura de banda.",
                                  "learningObjective": "Analisar largura de banda e integrar interpretações para diagnósticos estruturais.",
                                  "commonMistakes": [
                                    "Usar largura total em vez de -3dB",
                                    "Confundir largura com skew do pico",
                                    "Não relacionar a amortecimento"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um teste de vibração random de uma asa de UAV sob excitação de turbulência simulada (PSD de entrada MIL-STD-810G), identifique picos em 45 Hz (primeiro modo de flexão, Q=25) e 120 Hz (torção, Q=15), determinando larguras de banda de 1.8 Hz e 8 Hz, respectivamente, para validar modelo de elementos finitos e ajustar amortecedores.",
                              "finalVerifications": [
                                "Identifica corretamente todos os picos de ressonância em um PSD desconhecido.",
                                "Calcula largura de banda com erro <5%.",
                                "Interpreta implicações de Q-factor para amortecimento estrutural.",
                                "Integra PSD para obter resposta RMS precisa.",
                                "Relaciona achados a riscos aeroespaciais como fadiga.",
                                "Compara PSD experimental com teórico."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de picos (localização e altura: 90%+).",
                                "Correção no cálculo de largura de banda e Q-factor.",
                                "Profundidade da interpretação física (amortecimento, modos).",
                                "Clareza na comunicação de resultados via relatório ou gráfico anotado.",
                                "Aplicação contextual a cenários aeroespaciais reais.",
                                "Eficiência: análise completa em <30 min por gráfico."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformada de Fourier e processamento de sinais.",
                                "Física: Dinâmica de sistemas amortecidos e teoria de vibrações.",
                                "Engenharia Mecânica: Análise modal e elementos finitos.",
                                "Estatística: Processos estocásticos e análise espectral.",
                                "Ciência de Dados: Machine learning para detecção automática de picos."
                              ],
                              "realWorldApplication": "Em certificação de aeronaves, interpretação de PSD de testes de vibração random garante que estruturas suportem cargas de turbulência sem ressonância perigosa, prevenindo falhas como flutter ou fadiga em missões espaciais (ex: painéis de satélites sob vibrações de lançamento)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.3",
                        "name": "Estatísticas de Resposta em Estruturas",
                        "description": "Cálculo de estatísticas como valor médio, variância, valor RMS e probabilidade de excedência para respostas de sistemas estruturais lineares a excitações aleatórias estacionárias.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.3.1",
                            "name": "Calcular estatísticas básicas de resposta",
                            "description": "Determinar média, variância e desvio padrão da resposta de um sistema de um grau de liberdade a excitação branca estacionária, usando integrais espectrais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o modelo do sistema SDOF e a excitação branca estacionária",
                                  "subSteps": [
                                    "Descreva a equação diferencial do sistema de um grau de liberdade (SDOF): mÿ + cẏ + ky = x(t).",
                                    "Explique que excitação branca estacionária x(t) tem valor médio zero e densidade espectral de potência (PSD) constante S_xx(ω) = S_0.",
                                    "Confirme que a resposta estacionária y(t) é também estacionária com média zero devido à linearidade e propriedades da excitação.",
                                    "Identifique os parâmetros: massa m, amortecimento c, rigidez k e frequência natural ω_n = √(k/m)."
                                  ],
                                  "verification": "Escreva a equação do sistema e confirme que E[y(t)] = 0 para t → ∞.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Referência teórica sobre vibrações aleatórias"
                                  ],
                                  "tips": "Lembre-se: excitação branca implica independência temporal e PSD flat.",
                                  "learningObjective": "Compreender os fundamentos do SDOF sob excitação aleatória estacionária.",
                                  "commonMistakes": "Confundir resposta transitória com estacionária; ignorar que média é zero."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a função de transferência H(ω) do sistema",
                                  "subSteps": [
                                    "Transforme a equação diferencial para o domínio da frequência usando Fourier: H(ω) = Y(ω)/X(ω).",
                                    "Calcule H(ω) = 1 / (m(ω_n² - ω² + i 2 ζ ω_n ω)), onde ζ = c/(2√(km)) é o fator de amortecimento.",
                                    "Determine |H(ω)|² = 1 / [(m(ω_n² - ω²))² + (2 ζ ω_n ω m)²].",
                                    "Verifique a forma simplificada para excitação branca: S_yy(ω) = |H(ω)|² S_0."
                                  ],
                                  "verification": "Plote ou esboce |H(ω)|² e confirme pico em ω ≈ ω_n.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora simbólica ou MATLAB/SymPy",
                                    "Gráfica de |H(ω)|²"
                                  ],
                                  "tips": "Use ζ baixo para ressonância clara; normalize frequências por ω_n.",
                                  "learningObjective": "Derivar e interpretar a função de transferência em frequência.",
                                  "commonMistakes": "Erro no sinal da derivada ou confusão entre H(iω) e H(ω); fator i mal colocado."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a média da resposta estacionária",
                                  "subSteps": [
                                    "Estabeleça que E[y(t)] = ∫_{-∞}^∞ H(ω) S_xx(ω) dω / (2π), mas para branca zero-mean, resulta em zero.",
                                    "Confirme analiticamente: como H(ω) é ímpar em fase e S_xx par, integral é zero.",
                                    "Discuta implicações: sem bias na excitação, resposta oscila simetricamente ao redor de zero.",
                                    "Calcule numericamente para validar: simule ou integre trivialmente."
                                  ],
                                  "verification": "Mostre E[y] = 0 com justificativa matemática.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para prova",
                                    "Software de simulação opcional"
                                  ],
                                  "tips": "É trivial, mas essencial para prosseguir; não pule!",
                                  "learningObjective": "Reconhecer que média da resposta é zero em sistemas lineares sem bias.",
                                  "commonMistakes": "Assumir média não-zero por confusão com processos não estacionários."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular a variância usando integrais espectrais",
                                  "subSteps": [
                                    "Escreva σ_y² = E[y²] = ∫_{-∞}^∞ S_yy(ω) dω / (2π) = (S_0 / (2π)) ∫_{-∞}^∞ |H(ω)|² dω.",
                                    "Simplifique para integral positiva: σ_y² = (S_0 / π) ∫_0^∞ |H(ω)|² dω.",
                                    "Use fórmula fechada para SDOF: σ_y² = (π S_0) / (4 ζ m ω_n³) para excitação em velocidade ou ajuste conforme.",
                                    "Avalie numericamente a integral se fórmula não disponível, usando quadratura."
                                  ],
                                  "verification": "Compute σ_y² e confirme unidade de (comprimento)².",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "MATLAB/Python para integral numérica",
                                    "Tabelas de integrais espectrais"
                                  ],
                                  "tips": "Para excitação de deslocamento branco, use a fórmula padrão; verifique convenções de PSD.",
                                  "learningObjective": "Aplicar teorema espectral para variância de resposta estacionária.",
                                  "commonMistakes": "Fator 2π errado; limites de integral de 0 a ∞ sem dobrar; confundir PSD unilateral/bilateral."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Determinar o desvio padrão e validar os resultados",
                                  "subSteps": [
                                    "Calcule desvio padrão σ_y = √σ_y².",
                                    "Compare com simulação Monte Carlo de x(t) e y(t) para validação.",
                                    "Analise sensibilidade: como σ_y varia com ζ, ω_n, S_0.",
                                    "Interprete: RMS da resposta y_rms = σ_y.",
                                    "Documente todos os passos em relatório."
                                  ],
                                  "verification": "σ_y de integral ≈ σ_y de simulação (erro <5%).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de simulação (MATLAB/Simulink)",
                                    "Gráficos de histograma de y(t)"
                                  ],
                                  "tips": "Simule com dt pequeno para precisão espectral.",
                                  "learningObjective": "Validar cálculos analíticos com simulações e interpretar estatísticas.",
                                  "commonMistakes": "Esquecer raiz quadrada para desvio; unidades inconsistentes em simulação."
                                }
                              ],
                              "practicalExample": "Para um sistema SDOF com m=1 kg, k=100 N/m (ω_n=10 rad/s), c=0.2 Ns/m (ζ=0.01), e PSD de excitação branca S_0=0.1 m²/s³ (unilateral). Calcule: E[y]=0, σ_y² ≈ (π S_0)/(4 ζ k ω_n) = 0.0785 m², σ_y ≈ 0.280 m. Valide simulando 10.000s de x(t) gaussiano branco.",
                              "finalVerifications": [
                                "Média calculada é exatamente zero.",
                                "Variância positiva e finita (não diverge).",
                                "Desvio padrão com unidades corretas (ex: metros).",
                                "Integral numérica converge ao valor analítico.",
                                "Simulação Monte Carlo confirma resultados (erro <10%).",
                                "Sensibilidade a ζ mostra aumento com amortecimento baixo."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações (sem erros algébricos).",
                                "Correta aplicação de teoremas espectrais e convenções PSD.",
                                "Validação cruzada entre analítico, numérico e simulação.",
                                "Interpretação física dos resultados (ex: risco de fadiga).",
                                "Clareza na documentação de passos e fórmulas.",
                                "Tratamento correto de limites e simetrias."
                              ],
                              "crossCurricularConnections": [
                                "Estatística e Probabilidade: Conceitos de processos estacionários e momentos.",
                                "Processamento de Sinais: Transformadas de Fourier e PSD.",
                                "Controle de Sistemas: Funções de transferência em frequência.",
                                "Física Computacional: Simulações numéricas de EDOs estocásticas."
                              ],
                              "realWorldApplication": "Em aeroelasticidade, calcular desvio padrão da resposta de uma asa de aeronave a turbulência (modelada como excitação branca) para prever fadiga estrutural e dimensionar amortecedores, evitando flutter ou falhas em voo sob condições atmosféricas aleatórias."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.3.2",
                            "name": "Determinar resposta RMS",
                            "description": "Calcular o valor raiz quadrada média (RMS) da resposta usando a integral da PSD da entrada multiplicada pela função de transferência ao quadrado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de PSD, Função de Transferência e RMS",
                                  "subSteps": [
                                    "Defina PSD (Power Spectral Density) como a distribuição de potência de um sinal aleatório em função da frequência.",
                                    "Explique a função de transferência H(ω) como a razão entre a resposta Y(ω) e a excitação X(ω) no domínio da frequência.",
                                    "Descreva a variância da resposta σ_y² = ∫_{-∞}^{∞} PSD_x(ω) |H(ω)|² dω e RMS = √σ_y².",
                                    "Discuta a simetria da PSD para sinais reais, permitindo integração de 0 a ∞ com fator 2.",
                                    "Revise unidades: PSD em (unidade²/Hz), |H|² adimensional ou com unidades adequadas, integral resulta em unidade²."
                                  ],
                                  "verification": "Resuma os conceitos em um diagrama de blocos mostrando entrada PSD_x → |H|² → produto → integral → variância → RMS.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro-texto de vibrações aleatórias (ex: Newland), notas de aula, calculadora.",
                                  "tips": "Use analogias como 'PSD é o histograma de energia por frequência' para fixar o conceito.",
                                  "learningObjective": "Entender a base teórica da fórmula de RMS para respostas aleatórias em sistemas lineares.",
                                  "commonMistakes": "Confundir PSD com DFT/FFT; esquecer que |H(ω)|² é o quadrado do módulo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Obter ou Calcular a PSD da Entrada e a Função de Transferência",
                                  "subSteps": [
                                    "Identifique a PSD_x(ω) da excitação (ex: turbulência, ruído branco: constante S_0).",
                                    "Calcule ou obtenha H(ω) do modelo estrutural (analítico para SDOF/MDOF ou via FEM/modal).",
                                    "Compute |H(ω)|² = |H(ω)| * conj(H(ω)) para casos complexos.",
                                    "Verifique discretização em frequências ω_i se numérico.",
                                    "Garanta consistência de unidades entre PSD_x e H."
                                  ],
                                  "verification": "Plote PSD_x(ω) e |H(ω)|² em gráfico de frequência para inspeção visual.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software MATLAB/Python (numpy, scipy.signal), dados de exemplo de PSD de turbulência.",
                                  "tips": "Para SDOF, use H(ω) = 1 / (k - mω² + i c ω) e isole o módulo.",
                                  "learningObjective": "Preparar os dados de entrada corretamente para o cálculo do produto espectral.",
                                  "commonMistakes": "Usar H(t) em vez de H(ω); ignorar fator de simetria 2 para PSD de um lado."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Produto Espectral G_yy(ω) = PSD_x(ω) * |H(ω)|²",
                                  "subSteps": [
                                    "Multiplique ponto a ponto PSD_x(ω_i) * |H(ω_i)|² para cada frequência discreta.",
                                    "Para analítico, derive a expressão fechada se possível (ex: ruído branco em SDOF).",
                                    "Plote G_yy(ω) para validar picos em ressonâncias.",
                                    "Ajuste limites de integração (ex: 0 a ω_max relevante).",
                                    "Salve o array de G_yy para integração."
                                  ],
                                  "verification": "Confirme que G_yy tem unidades de PSD da resposta e picos alinhados com modos naturais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "MATLAB (plot, element-wise multiply .*), Python (matplotlib, numpy arrays).",
                                  "tips": "Use log-scale no plot para visualizar melhor faixas dinâmicas amplas.",
                                  "learningObjective": "Dominar a multiplicação espectral que captura a amplificação do sistema.",
                                  "commonMistakes": "Multiplicar H(ω) em vez de |H|²; escalas erradas em plots."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Realizar a Integração Numérica ou Analítica para Obter a Variância",
                                  "subSteps": [
                                    "Aplique integração trapezoidal ou Simpson: σ_y² ≈ ∑ G_yy(ω_i) Δω (com Δω = 2π/N ou similar).",
                                    "Para analítico, integre ∫ G_yy(ω) dω usando tabelas ou software simbólico.",
                                    "Inclua fator 2 se integrando apenas positivo.",
                                    "Verifique convergência variando limites de frequência.",
                                    "Calcule RMS = sqrt(σ_y²)."
                                  ],
                                  "verification": "Compare com valor analítico conhecido para caso simples (erro <1%).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB (trapz, integral), Python (scipy.integrate.trapz), exemplos analíticos.",
                                  "tips": "Sempre normalize Δω corretamente; teste com PSD delta para validação.",
                                  "learningObjective": "Executar a integração precisa para variância e extrair RMS.",
                                  "commonMistakes": "Esquecer Δω na soma discreta; integrar sem fator 2 para PSD simétrica."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Interpretar o Resultado RMS",
                                  "subSteps": [
                                    "Confira unidades: RMS deve ter unidades da resposta (ex: m/s para deslocamento).",
                                    "Compare com simulações no tempo (std de resposta simulada).",
                                    "Analise sensibilidade a parâmetros (ex: damping).",
                                    "Documente suposições e limitações (linearidade, estacionariedade).",
                                    "Prepare relatório com plots e valor final."
                                  ],
                                  "verification": "RMS calculado bate com referência teórica dentro de 5%.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Simulador temporal (odeint em Python), relatório template.",
                                  "tips": "Use Monte Carlo no tempo para cross-check numérico.",
                                  "learningObjective": "Garantir confiabilidade e interpretação prática do RMS.",
                                  "commonMistakes": "Ignorar não-linearidades; superestimar por limites de freq errados."
                                }
                              ],
                              "practicalExample": "Para uma viga cantilever aeroespacial com freq natural 10 Hz, damping 2%, sob turbulência com PSD_x(ω) = S_0 (constante 0.01 m²/s²/Hz). H(ω) de modelo modal. Calcule |H|², integre de 0-50 Hz com fator 2, obtenha σ_y² ≈ 0.05 m², RMS ≈ 0.22 m. Plote G_yy mostrando pico em 10 Hz.",
                              "finalVerifications": [
                                "Fórmula aplicada corretamente: RMS = sqrt(∫ PSD_x |H|² dω).",
                                "Plots de PSD_x, |H|², G_yy e valor numérico documentados.",
                                "Unidades consistentes e convergência da integral confirmada.",
                                "Validação cross-check com simulação temporal (erro <5%).",
                                "Interpretação física: RMS indica amplitude típica de vibração.",
                                "Relatório completo com suposições listadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão do cálculo RMS (erro <2% vs analítico).",
                                "Correção conceitual de PSD e |H|².",
                                "Qualidade dos plots e visualizações.",
                                "Tratamento adequado de integração numérica/analítica.",
                                "Identificação de erros comuns evitados.",
                                "Clareza na documentação e interpretação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de Fourier, integração numérica (trapz, Simpson).",
                                "Física: Teoria de vibrações aleatórias, teorema de Wiener-Khinchin.",
                                "Engenharia de Controle: Funções de transferência em sistemas dinâmicos.",
                                "Estatística: Momentos de sinais aleatórios, variância espectral."
                              ],
                              "realWorldApplication": "Em projetos de aeronaves, calcular RMS de resposta estrutural a turbulência atmosférica para prever fadiga em asas, dimensionar amortecedores ou certificar conformidade com normas FAA (ex: análise de flutter e vibrações aleatórias em Boeing 787)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.3.3",
                            "name": "Analisar distribuições de picos",
                            "description": "Estimar estatísticas de picos e taxa de cruzamento de nível para respostas gaussianas estacionárias em estruturas aeroespaciais, relacionando com fadiga.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Processos Gaussianos Estacionários",
                                  "subSteps": [
                                    "Revise a definição de um processo estocástico gaussiano estacionário, focando em média zero e autocorrelação.",
                                    "Estude propriedades espectrais: densidade espectral de potência (PSD) e momentos espectrais (λ0, λ2, λ4).",
                                    "Calcule largura de banda espectral ε = sqrt(1 - λ2² / (λ0 λ4)).",
                                    "Identifique condições para respostas estacionárias em estruturas aeroespaciais sob excitação aleatória.",
                                    "Pratique com exemplos simples de PSD para vibrações estruturais."
                                  ],
                                  "verification": "Resuma as propriedades chave em um diagrama e calcule ε para um PSD dado com precisão >95%.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro de texto sobre vibrações aleatórias (ex: Clough & Penzien), software MATLAB ou Python (scipy.signal).",
                                  "tips": "Visualize PSDs para intuir largura de banda; use plots para comparar estreito vs. largo.",
                                  "learningObjective": "Dominar fundamentos de processos gaussianos estacionários e seus parâmetros espectrais.",
                                  "commonMistakes": "Confundir estacionariedade com ergodicidade; ignorar normalização da PSD."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Distribuição de Picos",
                                  "subSteps": [
                                    "Derive a PDF de picos para processos gaussianos: Rayleigh para banda estreita, próximo a gaussiana para banda larga.",
                                    "Calcule estatísticas de picos: número médio de picos Np = (1/(2π)) * sqrt(λ4/λ2), altura média Ep = sqrt(2π λ0) * (1-ε²)/ε * exp(-ρ), onde ρ = sqrt(λ2²/(λ0 λ4)).",
                                    "Estime variância de picos e desvios padrão.",
                                    "Compare distribuições para diferentes larguras de banda usando simulações.",
                                    "Aplique a respostas de estruturas aeroespaciais simuladas."
                                  ],
                                  "verification": "Calcule Np e Ep para dois PSDs diferentes e valide contra simulação numérica (erro <5%).",
                                  "estimatedTime": "3 horas",
                                  "materials": "Fórmulas de Rice (referência: Newland 'Random Vibrations'), simulador Python (numpy.random, matplotlib).",
                                  "tips": "Use ε como heurística: ε<0.5 indica Rayleigh dominante.",
                                  "learningObjective": "Calcular e interpretar estatísticas de picos em respostas gaussianas.",
                                  "commonMistakes": "Usar fórmulas erradas para banda larga; esquecer fator de correlação ρ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Taxa de Cruzamento de Nível",
                                  "subSteps": [
                                    "Estude fórmula de Rice para taxa de up-crossing: ν(η) = ∫[0,∞] ḣ φ(η,ḣ) dḣ, simplificando para gaussiano: ν(η) = (sqrt(λ2/(2π)) / σ) exp(-(η/σ)²/2), σ=sqrt(λ0).",
                                    "Calcule para múltiplos níveis η e plote curva de cruzamento.",
                                    "Relacione com contagem de ciclos de fadiga (Rainflow ou similar).",
                                    "Simule tempo série gaussiano e conte cruzamentos para validar.",
                                    "Ajuste para estruturas: considere fator de qualidade Q."
                                  ],
                                  "verification": "Gere simulação, conte cruzamentos e compare com fórmula analítica (erro <10%).",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "MATLAB Signal Processing Toolbox ou Python (statsmodels.tsa), paper de Rice (1944/5).",
                                  "tips": "Normalize níveis η/σ para universalidade; log-plot para visualização.",
                                  "learningObjective": "Dominar cálculo e interpretação de taxas de cruzamento de nível.",
                                  "commonMistakes": "Confundir up-crossing com zero-crossing; ignorar derivada ḣ."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar com Análise de Fadiga",
                                  "subSteps": [
                                    "Conecte picos e cruzamentos a ciclos de carga: esperados vs. observados.",
                                    "Estime dano cumulativo usando regra de Miner com S-N curve.",
                                    "Calcule taxa de dano D = ν(η) * n(η), onde n(η) de PDF de picos.",
                                    "Aplique a exemplo aeroespacial: asa sob turbulência.",
                                    "Avalie sensibilidade a parâmetros espectrais."
                                  ],
                                  "verification": "Compute vida útil estimada para caso teste e compare com método numérico.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Dados de fadiga aeroespacial (NASA reports), Excel ou Python para integração.",
                                  "tips": "Comece com banda estreita para simplificação; itere para realismo.",
                                  "learningObjective": "Integrar estatísticas de picos/cruzamentos à previsão de fadiga estrutural.",
                                  "commonMistakes": "Subestimar influência de ε na contagem de picos; linearizar dano incorretamente."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Prática Integrada e Simulação",
                                  "subSteps": [
                                    "Gere PSD realista para estrutura aeroespacial (ex: flapwise bending).",
                                    "Simule resposta via integração temporal ou Welch.",
                                    "Extraia picos e cruzamentos dos dados simulados.",
                                    "Compare analítico vs. simulado; analise discrepâncias.",
                                    "Documente relatório com plots e conclusões."
                                  ],
                                  "verification": "Relatório completo com validação quantitativa (R² >0.9 para fits).",
                                  "estimatedTime": "3 horas",
                                  "materials": "Software ANSYS ou NASTRAN para PSDs reais, Python full pipeline.",
                                  "tips": "Use FFT para eficiência; seed random para reprodutibilidade.",
                                  "learningObjective": "Aplicar workflow completo em cenário realista.",
                                  "commonMistakes": "Aliasing em simulações; sampling inadequado."
                                }
                              ],
                              "practicalExample": "Em uma asa de aeronave sob turbulência, dada PSD de aceleração com λ0=1 m²/s⁴, λ2=10, λ4=100, calcule Np=15 picos/s, Ep=2.5σ, ν(2σ)=0.1/s, estimando 10^6 ciclos em 10h de voo para prever fadiga.",
                              "finalVerifications": [
                                "Calcular corretamente estatísticas de picos para PSD dado (erro <5%).",
                                "Plotar e interpretar PDF de picos vs. Rayleigh/gaussiana.",
                                "Validar taxa de cruzamento via simulação (concordância >90%).",
                                "Estimar dano de fadiga com base em cruzamentos (unidade consistente).",
                                "Identificar impacto de largura de banda em predições.",
                                "Documentar workflow com código reproduzível."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática em fórmulas de Rice/Davenport (>95%).",
                                "Qualidade de simulações e validações numéricas.",
                                "Interpretação física correta (relação com fadiga).",
                                "Uso apropriado de ferramentas computacionais.",
                                "Clareza em relatórios e visualizações.",
                                "Capacidade de sensibilidade e troubleshooting."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Distribuições probabilísticas e momentos.",
                                "Mecânica dos Sólidos: Resposta dinâmica estrutural.",
                                "Processamento de Sinais: Análise espectral e FFT.",
                                "Engenharia de Confiabilidade: Análise de fadiga e vida útil.",
                                "Física: Processos estocásticos em dinâmica."
                              ],
                              "realWorldApplication": "Previsão de vida útil de componentes aeroespaciais como asas ou fuselagens sob cargas aleatórias de turbulência, otimizando inspeções e manutenção para segurança em aviação comercial e militar."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.3.4",
                            "name": "Aplicar em análise modal",
                            "description": "Estender estatísticas de resposta para sistemas multi-graus de liberdade usando coordenadas modais e ortogonalidade, com foco em estruturas aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Análise Modal para Sistemas Multi-DOF",
                                  "subSteps": [
                                    "Identificar as equações de movimento para um sistema multi-graus de liberdade (MDOF).",
                                    "Explicar o processo de diagonalização da matriz de massa e rigidez usando autovalores e autovetores.",
                                    "Derivar as propriedades modais: frequências naturais e modos de vibração.",
                                    "Discutir a decomposição modal da resposta em coordenadas modais.",
                                    "Verificar ortogonalidade dos modos em relação às matrizes de massa e rigidez."
                                  ],
                                  "verification": "Capacidade de formular as equações modais uncoupled para um sistema MDOF de 2-3 DOF.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Livro de Dinâmica de Estruturas (ex: Clough & Penzien)",
                                    "Software MATLAB ou Python (NumPy/SciPy)",
                                    "Folhas de cálculo para matrizes de exemplo"
                                  ],
                                  "tips": "Comece com sistemas de 2 DOF para visualizar modos; use plot de modos para intuição.",
                                  "learningObjective": "Compreender a base teórica da análise modal e sua redução de acoplamento.",
                                  "commonMistakes": "Confundir frequências com deslocamentos modais; ignorar normalização dos modos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Coordenadas Modais e Propriedades de Ortogonalidade",
                                  "subSteps": [
                                    "Definir transformação modal: q = Φ^T u, onde Φ são os modos.",
                                    "Provar ortogonalidade: Φ^T M Φ = I e Φ^T K Φ = Ω² (diagonal).",
                                    "Aplicar a equações de movimento uncoupled: ÿ_n + 2ζ_n ω_n ẏ_n + ω_n² y_n = Φ_n^T f(t).",
                                    "Normalizar modos para massa unitária.",
                                    "Resolver numericamente para um exemplo simples com excitação harmônica."
                                  ],
                                  "verification": "Derivação correta das equações modais uncoupled e verificação numérica da ortogonalidade.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB script para eigenvalores",
                                    "Exemplos de problemas de vibrações livres",
                                    "Calculadora matricial online"
                                  ],
                                  "tips": "Use eig() no MATLAB para validar modos analíticos em problemas pequenos.",
                                  "learningObjective": "Dominar a transformação modal e suas propriedades ortogonais.",
                                  "commonMistakes": "Esquecer a transposição Φ^T na projeção de forças; normalização incorreta."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estender Estatísticas de Resposta para Excitações Aleatórias em Coordenadas Modais",
                                  "subSteps": [
                                    "Introduzir funções de densidade espectral de potência (PSD) para cargas aleatórias estacionárias.",
                                    "Derivar PSD modal: S_{y_n}(ω) = |H_n(ω)|^2 S_f(ω) |Φ_n|^2, onde H_n é a função de transferência modal.",
                                    "Calcular estatísticas: variância σ_{y_n}^2 = ∫ S_{y_n}(ω) dω; RMS modal.",
                                    "Recuperar resposta física: covariância u = Φ diag(σ_y^2) Φ^T.",
                                    "Computar estatísticas globais como RMS total e correlações modais."
                                  ],
                                  "verification": "Cálculo correto de PSD e variâncias modais para PSD de entrada branca.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Software como MATLAB Vibration Toolbox ou Python (control library)",
                                    "Tabelas de PSD para turbulência aeroespacial",
                                    "Exemplos de Chiles & Young"
                                  ],
                                  "tips": "Integre numericamente PSDs usando trapz() para evitar fórmulas fechadas complexas.",
                                  "learningObjective": "Estender análise estocástica para respostas modais uncoupled.",
                                  "commonMistakes": "Ignorar fator |Φ_n|^2 na projeção; confundir PSD de força com aceleração."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Análise Modal a Estruturas Aeroespaciais",
                                  "subSteps": [
                                    "Modelar uma estrutura aeroespacial simples (ex: viga cantilever representando asa).",
                                    "Obter modos via FEM (Finite Element Method) ou analíticos.",
                                    "Aplicar PSD de turbulência ou ruído como entrada (ex: von Karman spectrum).",
                                    "Calcular respostas RMS em nós críticos (raiz da asa, ponta).",
                                    "Analisar contribuição modal dominante para fadiga ou flutter."
                                  ],
                                  "verification": "Simulação completa com plots de PSD modal e resposta física RMS.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Software NASTRAN ou ANSYS para FEM aeroespacial",
                                    "Dados de PSD de turbulência (NASA)",
                                    "Python/MATLAB para pós-processamento modal"
                                  ],
                                  "tips": "Use modos truncados (primeiros 5-10) para eficiência computacional.",
                                  "learningObjective": "Aplicar conceitos a contextos reais de engenharia aeroespacial.",
                                  "commonMistakes": "Sobrestimar modos altos sem truncamento; ignorar acoplamento não-linear."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Validar a Análise",
                                  "subSteps": [
                                    "Comparar com solução direta no domínio do tempo (simulação Monte Carlo).",
                                    "Verificar conservação de energia: soma de variâncias modais igual à física.",
                                    "Analisar sensibilidade a truncamento modal.",
                                    "Documentar relatório com gráficos de modo shapes, PSDs e RMS.",
                                    "Discutir limitações (ex: não-linearidades, damping não-clássico)."
                                  ],
                                  "verification": "Concordância entre análise modal e simulação temporal dentro de 5% de erro.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Scripts de simulação temporal",
                                    "Ferramentas de plot (Matplotlib)"
                                  ],
                                  "tips": "Sempre plote contribuições modais para identificar dominantes.",
                                  "learningObjective": "Garantir robustez e precisão da análise modal estocástica.",
                                  "commonMistakes": "Não validar contra benchmark; truncamento excessivo."
                                }
                              ],
                              "practicalExample": "Para uma viga cantilever de asa de aeronave com 10 elementos FEM, aplicar PSD de turbulência von Karman na raiz, calcular modos, PSDs modais e RMS de tensão na ponta da asa, identificando o modo de flexão primeiro como dominante.",
                              "finalVerifications": [
                                "Derivação correta das equações modais uncoupled com ortogonalidade comprovada.",
                                "Cálculo preciso de variâncias modais a partir de PSD de entrada.",
                                "Recuperação correta da resposta física via soma modal.",
                                "Análise de um modelo aeroespacial com resultados realistas (ex: RMS < 1% deformação).",
                                "Validação cruzada com simulação temporal.",
                                "Identificação de modos dominantes e limitações."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações (ortogonalidade, PSD modal).",
                                "Correção numérica em simulações (erro <5%).",
                                "Relevância ao contexto aeroespacial (escolha de PSD e estrutura).",
                                "Clareza em documentação e visualizações.",
                                "Profundidade na discussão de aplicações e erros.",
                                "Eficiência computacional (truncamento modal justificado)."
                              ],
                              "crossCurricularConnections": [
                                "Dinâmica de voo: Integração com aeroelasticidade e flutter.",
                                "Processamento de sinais: Análise espectral e FFT para PSDs.",
                                "Materiais e estruturas: Avaliação de fadiga sob cargas aleatórias.",
                                "Controle de sistemas: Síntese de controladores modais.",
                                "Estatística e probabilidade: Teoria de processos estocários."
                              ],
                              "realWorldApplication": "No design de asas de aviões e satélites, essa análise prevê respostas a turbulência atmosférica ou vibrações de lançamento, otimizando massa e evitando fadiga prematura, como no Boeing 787 onde análises modais guiam certificação FAA."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.5",
                    "name": "Análise de Resposta a Vibrações Aleatórias",
                    "description": "Métodos de cálculo da resposta estatística (RMS, picos) de estruturas aeroespaciais a excitações aleatórias.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.5.1",
                        "name": "Processos Estocásticos e Espectros de Potência",
                        "description": "Fundamentos dos processos aleatórios estacionários e sua representação espectral para modelar excitações em estruturas aeroespaciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.1.1",
                            "name": "Definir processos estocásticos estacionários",
                            "description": "Explicar as propriedades de ergodicidade, estacionariedade e autocorrelação em vibrações aleatórias aplicadas a estruturas aeroespaciais, com exemplos de turbulência atmosférica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Processos Estocásticos",
                                  "subSteps": [
                                    "Revise a definição de um processo estocástico como uma coleção de variáveis aleatórias indexadas por tempo.",
                                    "Estude exemplos básicos como o movimento browniano e ruído branco gaussiano.",
                                    "Identifique diferenças entre processos determinísticos e estocásticos em contextos de vibrações.",
                                    "Explore representações matemáticas: X(t) onde t é contínuo ou discreto.",
                                    "Discuta espectros de potência como ferramentas para análise de processos estocásticos."
                                  ],
                                  "verification": "Resuma em 3 frases os conceitos chave e dê um exemplo simples de processo estocástico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Probabilidade e Processos Estocásticos' (Papoulis), vídeo introdutório no Khan Academy, caderno para anotações.",
                                  "tips": "Use analogias como 'previsão do tempo' para visualizar aleatoriedade temporal.",
                                  "learningObjective": "Dominar a definição e exemplos iniciais de processos estocásticos.",
                                  "commonMistakes": "Confundir processos estocásticos com funções aleatórias estáticas; lembre-se do índice temporal."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Explicar Estacionariedade",
                                  "subSteps": [
                                    "Defina estacionariedade fraca: média constante, variância constante e autocovariância dependente apenas de lag.",
                                    "Diferencie estacionariedade estrita (todas as distribuições invariantes no tempo).",
                                    "Calcule estatísticas de primeira e segunda ordem para um sinal estacionário.",
                                    "Verifique estacionariedade em dados simulados plotando média móvel e variância.",
                                    "Relacione com vibrações aleatórias: por que assumimos estacionariedade em análises aeroespaciais?"
                                  ],
                                  "verification": "Gere um sinal estacionário simples no MATLAB/Python e confirme estatísticas constantes.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software MATLAB ou Python (com NumPy/SciPy), tutorial 'Stationary Processes' online.",
                                  "tips": "Teste estacionariedade removendo tendências lineares nos dados.",
                                  "learningObjective": "Explicar propriedades matemáticas da estacionariedade em processos.",
                                  "commonMistakes": "Ignorar que estacionariedade fraca é suficiente para muitos análises espectrais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Ergodicidade em Processos Estocásticos",
                                  "subSteps": [
                                    "Defina ergodicidade: ensemble averages iguais a time averages.",
                                    "Discuta implicações: uma realização longa representa o processo inteiro.",
                                    "Estude testes de ergodicidade via decomposição espectral.",
                                    "Aplique a vibrações: em turbulência, amostras longas são ergodicas.",
                                    "Compare processos ergodicos vs. não-ergodicos com exemplos gráficos."
                                  ],
                                  "verification": "Simule duas realizações ergodicas e compare médias temporais e ensemble.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Simulador online de processos estocásticos, paper 'Ergodicity in Random Vibrations'.",
                                  "tips": "Visualize com plots de trajetórias múltiplas sobrepostas.",
                                  "learningObjective": "Compreender e verificar ergodicidade em contextos práticos.",
                                  "commonMistakes": "Assumir todos os processos estacionários são ergodicos; verifique condições adicionais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Autocorrelação e suas Propriedades",
                                  "subSteps": [
                                    "Defina função de autocorrelação R(τ) = E[X(t)X(t+τ)].",
                                    "Estude propriedades: simetria, máximo em τ=0, decaimento para estacionários.",
                                    "Calcule autocorrelação para ruído branco (delta em τ=0).",
                                    "Relacione com espectro de potência via Teorema de Wiener-Khinchin.",
                                    "Aplique a vibrações aleatórias: autocorrelação modela persistência em turbulência."
                                  ],
                                  "verification": "Plote e calcule R(τ) para um sinal de turbulência simulada.",
                                  "estimatedTime": "55 minutos",
                                  "materials": "MATLAB toolbox Signal Processing, dataset de turbulência atmosférica (NASA).",
                                  "tips": "Use FFT para estimar espectro a partir de autocorrelação.",
                                  "learningObjective": "Dominar cálculo e interpretação da autocorrelação.",
                                  "commonMistakes": "Confundir autocorrelação com autocovariância; normalize adequadamente."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Aplicar Conceitos a Vibrações Aleatórias em Aeroespacial",
                                  "subSteps": [
                                    "Integre conceitos: processos estacionários ergodicos modelam turbulência atmosférica.",
                                    "Exemplo: espectro de von Karman para turbulência em estruturas de aeronaves.",
                                    "Simule resposta de uma viga aeroespacial a excitação estocástica estacionária.",
                                    "Discuta impactos em fadiga e aeroelasticidade.",
                                    "Valide com dados reais de voo (ex: medições de acelerômetros em asas)."
                                  ],
                                  "verification": "Crie um relatório curto com simulação e interpretação das propriedades.",
                                  "estimatedTime": "70 minutos",
                                  "materials": "Software ANSYS ou Python (para simulação modal), dados de turbulência (Dryden model).",
                                  "tips": "Comece com modelo 1DOF para simplicidade antes de multi-DOF.",
                                  "learningObjective": "Aplicar propriedades a cenários reais de engenharia aeroespacial.",
                                  "commonMistakes": "Negligenciar efeitos não-lineares em vibrações intensas de turbulência."
                                }
                              ],
                              "practicalExample": "Simule turbulência atmosférica usando o modelo de Dryden (estacionário e ergodico) para excitar uma asa de aeronave finita elemento. Calcule autocorrelação da carga e verifique se médias temporais igualam ensemble para prever fadiga estrutural.",
                              "finalVerifications": [
                                "Explique verbalmente as diferenças entre estacionariedade fraca e estrita.",
                                "Gere e valide um sinal estacionário com autocorrelação decaindo.",
                                "Demonstre ergodicidade comparando 10 realizações.",
                                "Aplique a um exemplo de turbulência e interprete espectro de potência.",
                                "Resolva um problema: dado R(τ), encontre variância e confirme estacionariedade.",
                                "Discuta limitações em cenários aeroespaciais reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições matemáticas de estacionariedade, ergodicidade e autocorrelação (30%).",
                                "Qualidade das simulações e plots gerados (25%).",
                                "Correta aplicação a vibrações aleatórias aeroespaciais (20%).",
                                "Interpretação clara de propriedades e exemplos (15%).",
                                "Identificação de erros comuns e tips práticos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Inferência e testes de hipótese para estacionariedade.",
                                "Física: Mecânica estatística e flutuações em fluidos turbulentos.",
                                "Engenharia de Controle: Filtros para sinais estocásticos estacionários.",
                                "Processamento de Sinais: Transformadas de Fourier e espectros."
                              ],
                              "realWorldApplication": "No design de aeronaves, modela turbulência atmosférica como processo estocástico estacionário ergodico para prever respostas vibratórias de asas e fuselagens, otimizando amortecimento e evitando falhas por fadiga em voos comerciais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.2",
                            "name": "Calcular densidade espectral de potência (PSD)",
                            "description": "Derivar e calcular a função de densidade espectral de potência (PSD) a partir de funções de autocorrelação para excitações aleatórias como ruído de motores ou fluxo turbulento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Função de Autocorrelação",
                                  "subSteps": [
                                    "Defina a função de autocorrelação R(τ) para um processo estocástico estacionário.",
                                    "Calcule a autocorrelação para processos simples como ruído branco e ruído colorido.",
                                    "Interprete as propriedades da autocorrelação: simetria, valor máximo em τ=0 e decaimento.",
                                    "Relacione a autocorrelação com a variância e potência média do sinal.",
                                    "Pratique com gráficos de autocorrelação de excitações aleatórias como fluxo turbulento."
                                  ],
                                  "verification": "Produza gráficos corretos de R(τ) para ruído branco e compare com definições teóricas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Processos Estocásticos (ex: Papoulis)",
                                    "Software MATLAB ou Python (NumPy/SciPy)",
                                    "Folha de papel para derivações"
                                  ],
                                  "tips": "Sempre normalize a autocorrelação para facilitar comparações.",
                                  "learningObjective": "Entender o conceito e cálculo da função de autocorrelação em processos estacionários.",
                                  "commonMistakes": [
                                    "Confundir autocorrelação com correlação cruzada",
                                    "Ignorar a estacionaridade do processo",
                                    "Erro em unidades de tempo τ"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Teorema de Wiener-Khinchin",
                                  "subSteps": [
                                    "Enuncie o teorema: PSD S(ω) é a Transformada de Fourier da autocorrelação R(τ).",
                                    "Derive a relação matemática: S(ω) = ∫ R(τ) e^{-jωτ} dτ.",
                                    "Discuta bilateral vs. unilateral PSD e normalizações comuns.",
                                    "Verifique a relação inversa: R(τ) = (1/2π) ∫ S(ω) e^{jωτ} dω.",
                                    "Aplique a propriedades de Parseval para conservação de energia."
                                  ],
                                  "verification": "Derive corretamente a fórmula do teorema e comprove com um exemplo simples.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Notas de Dinâmica de Estruturas Aeroespaciais",
                                    "MATLAB para simular Fourier",
                                    "Calculadora simbólica como SymPy"
                                  ],
                                  "tips": "Use a simetria de R(τ) para simplificar a integral da Fourier.",
                                  "learningObjective": "Dominar a relação fundamental entre autocorrelação e PSD via Wiener-Khinchin.",
                                  "commonMistakes": [
                                    "Esquecer o fator 2π na transformada inversa",
                                    "Confundir frequência angular ω com f",
                                    "Não considerar processos reais vs. complexos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar e Calcular a PSD Analiticamente",
                                  "subSteps": [
                                    "Escolha uma R(τ) exemplo: exponencial para ruído de motor R(τ) = σ² e^{-α|τ|}.",
                                    "Calcule a Transformada de Fourier passo a passo.",
                                    "Obtenha S(ω) = 2σ² α / (α² + ω²) e interprete picos e largura de banda.",
                                    "Generalize para outros modelos: ruído branco (S(ω)=constante), turbulento (S(ω)~1/ω^n).",
                                    "Valide com simulação numérica da autocorrelação."
                                  ],
                                  "verification": "Derive S(ω) para dois modelos diferentes e plote corretamente.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Papel e lápis para integrais",
                                    "MATLAB/Simulink para validação",
                                    "Tabelas de Transformadas de Fourier"
                                  ],
                                  "tips": "Use tabelas de Fourier para aceleração em formas comuns.",
                                  "learningObjective": "Capacitar derivação analítica de PSD a partir de R(τ).",
                                  "commonMistakes": [
                                    "Erro no sinal da exponencial na Fourier",
                                    "Não usar valor absoluto em |τ|",
                                    "Ignorar fator de escala na PSD"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Cálculo de PSD em Excitações Aleatórias Reais",
                                  "subSteps": [
                                    "Modele ruído de motor como processo gaussiano com R(τ) dada.",
                                    "Calcule PSD numericamente usando FFT em dados simulados.",
                                    "Compare analítico vs. numérico e analise discrepâncias.",
                                    "Aplique a fluxo turbulento: use espectro de von Kármán.",
                                    "Integre PSD em análise de resposta estrutural (ex: integral de potência)."
                                  ],
                                  "verification": "Gere PSD para ruído de motor e verifique integral igual à variância.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Dados simulados de ruído (MATLAB toolbox Signal Processing)",
                                    "Software Python (SciPy.signal.welch)",
                                    "Referências aeroespaciais ST-57"
                                  ],
                                  "tips": "Use windowing (Hanning) para reduzir leakage em cálculos numéricos.",
                                  "learningObjective": "Aplicar cálculo de PSD a cenários práticos de vibrações aleatórias.",
                                  "commonMistakes": [
                                    "Amostragem inadequada levando a aliasing",
                                    "Escala errada em plots de PSD",
                                    "Confundir PSD unilateral com bilateral"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado R(τ) = 100 e^{-10|τ|} para ruído de motor de aeronave, derive S(ω) = 2000 / (100 + ω²), plote e calcule potência em banda 0-100 rad/s usando integração numérica.",
                              "finalVerifications": [
                                "Derivar corretamente S(ω) a partir de R(τ) para ruído branco e colorido.",
                                "Verificar que ∫ S(ω) dω / 2π = R(0) (potência total).",
                                "Produzir plots de PSD consistentes com simulações numéricas.",
                                "Aplicar a um modelo de fluxo turbulento e interpretar largura de banda.",
                                "Explicar uso em análise de fadiga estrutural.",
                                "Comparar PSD analítica vs. estimada via Welch em dados sintéticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação matemática (fórmulas corretas e passos lógicos).",
                                "Correção numérica: erro <5% entre analítico e simulação.",
                                "Interpretação física: ligação clara com excitações reais.",
                                "Qualidade de plots e verificações (rótulos, escalas adequadas).",
                                "Criatividade em extensão a novos modelos de ruído.",
                                "Clareza na documentação do processo."
                              ],
                              "crossCurricularConnections": [
                                "Processamento de Sinais Digitais: Estimativa de PSD via periodograma.",
                                "Estatística e Probabilidade: Propriedades de processos estacionários.",
                                "Engenharia Mecânica: Análise de vibrações em estruturas.",
                                "Física: Teoria de ondas e espectroscopia.",
                                "Computação: Programação numérica em MATLAB/Python."
                              ],
                              "realWorldApplication": "Na engenharia aeroespacial, calcular PSD de ruído de motores ou fluxo turbulento permite prever respostas de vibração em asas e fuselagens, otimizando design contra fadiga e aeroelasticidade em aeronaves como o Boeing 787."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.5.1.3",
                            "name": "Interpretar espectros de resposta",
                            "description": "Analisar espectros de potência de resposta de sistemas estruturais lineares a partir da convolução do PSD de excitação com a função de transferência modal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de PSD de Excitação e Função de Transferência Modal",
                                  "subSteps": [
                                    "Defina Power Spectral Density (PSD) como a distribuição de potência de um sinal aleatório em função da frequência.",
                                    "Explique a função de transferência modal H(ω) como a razão entre resposta e excitação no domínio da frequência para cada modo.",
                                    "Revise a representação modal de sistemas estruturais lineares, incluindo massas, rigidezes e amortecimentos modais.",
                                    "Identifique como o PSD de excitação S_xx(ω) representa a entrada estocástica.",
                                    "Discuta unidades típicas: PSD em (unidade da resposta)^2 / Hz."
                                  ],
                                  "verification": "Escreva um resumo de 200 palavras explicando PSD e H(ω), com um diagrama esquemático.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notas de aula sobre processos estocásticos, livro de dinâmica estrutural (ex: Clough & Penzien), calculadora.",
                                  "tips": "Visualize PSD como um histograma de energia por frequência para sinais estacionários.",
                                  "learningObjective": "Dominar os conceitos de entrada (PSD de excitação) e o filtro modal (função de transferência).",
                                  "commonMistakes": "Confundir PSD (potência) com espectro de Fourier (amplitude); ignorar normalização por Hz."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a Convolução no Domínio da Frequência para Espectros de Resposta",
                                  "subSteps": [
                                    "Lembre que no domínio da frequência, convolução temporal vira multiplicação: S_yy(ω) = |H(ω)|^2 * S_xx(ω).",
                                    "Derive a fórmula para sistemas lineares invariantes no tempo (LTI).",
                                    "Discuta o papel do fator |H(ω)|^2 como amplificador/amortecedor seletivo por frequência.",
                                    "Analise o efeito do amortecimento: picos mais estreitos com maior damping.",
                                    "Considere contribuições multimodais: soma sobre modos S_yy(ω) = Σ |H_r(ω)|^2 S_xx(ω)."
                                  ],
                                  "verification": "Derive a equação S_yy(ω) = |H(ω)|^2 S_xx(ω) a partir das propriedades de Wiener-Khinchin.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Papel e lápis para derivações, software como MATLAB para plotar |H(ω)|^2 simples.",
                                  "tips": "Pense na função de transferência como um filtro passa-faixa centrado nas frequências naturais.",
                                  "learningObjective": "Compreender matematicamente como o espectro de resposta é obtido via multiplicação espectral.",
                                  "commonMistakes": "Usar H(ω) em vez de |H(ω)|^2; esquecer soma modal para sistemas multi-DOF."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Numericamente o Espectro de Potência de Resposta",
                                  "subSteps": [
                                    "Obtenha dados: PSD de excitação S_xx(ω) e parâmetros modais (ω_n, ζ_n).",
                                    "Compute H_r(ω) = 1 / (ω_n^2 - ω^2 + 2iζ_n ω_n ω) para cada modo r.",
                                    "Calcule |H_r(ω)|^2 e multiplique por S_xx(ω), somando modos.",
                                    "Integre numericamente se necessário, usando grade de frequências (ex: 0-1000 Hz, Δf=0.1 Hz).",
                                    "Plote S_yy(ω) vs. ω."
                                  ],
                                  "verification": "Implemente cálculo em spreadsheet ou código simples e gere gráfico de S_yy(ω).",
                                  "estimatedTime": "90 minutos",
                                  "materials": "Excel/MATLAB/Python (biblioteca numpy/scipy), dados de exemplo de PSD turbulência.",
                                  "tips": "Use resolução fina em torno de ω_n para capturar picos precisamente.",
                                  "learningObjective": "Executar o cálculo prático da convolução espectral.",
                                  "commonMistakes": "Escala errada de frequência; overflow numérico perto de ω_n sem damping."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Características do Espectro de Resposta",
                                  "subSteps": [
                                    "Identifique picos principais: localização em ω_n, amplitude proporcional a 1/(4ζ_n).",
                                    "Avalie largura de banda: Δω ≈ 2ζ_n ω_n indica nível de amortecimento.",
                                    "Analise assimetrias ou efeitos multimodais (interferência construtiva/destrutiva).",
                                    "Calcule variância total: σ_y^2 = ∫ S_yy(ω) dω, RMS = sqrt(σ_y^2).",
                                    "Compare com PSD de entrada: amplificação modal seletiva."
                                  ],
                                  "verification": "Anote 5 observações chave do gráfico gerado no Step 3, ligando a parâmetros físicos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Gráficos gerados, régua/log-log plot para análise.",
                                  "tips": "Use escala log-log para visualizar largas faixas dinâmicas de PSD.",
                                  "learningObjective": "Extrair informações físicas (modos, damping) do espectro de resposta.",
                                  "commonMistakes": "Atribuir picos espúrios a modos reais; ignorar contribuições off-peak."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar Interpretação com Análise de Sensibilidade",
                                  "subSteps": [
                                    "Varie ζ_n e observe mudanças em picos/largura.",
                                    "Altere S_xx(ω) (ex: white noise vs. banda-larga) e compare.",
                                    "Verifique limites: ζ→0 (picos infinitos), excitação narrowband.",
                                    "Use software para simulação temporal e FFT para validar PSD.",
                                    "Documente insights em relatório curto."
                                  ],
                                  "verification": "Gere 3 gráficos de sensibilidade e explique impactos físicos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software de simulação (MATLAB Simulink ou Python), exemplos de dados reais.",
                                  "tips": "Comece com sistema SDOF para intuição antes de MDOF.",
                                  "learningObjective": "Confirmar robustez da interpretação via variações paramétricas.",
                                  "commonMistakes": "Não normalizar PSD corretamente; confundir resposta modal com total."
                                }
                              ],
                              "practicalExample": "Para uma viga cantilever representando uma asa de aeronave (ω_n=50 Hz, ζ=0.02), sob PSD de turbulência atmosférica S_xx(ω) flat até 100 Hz. Calcule S_yy(ω), identifique pico em 50 Hz com amplitude elevada, largura ~2 Hz indicando baixo damping, e RMS de deslocamento para prever fadiga.",
                              "finalVerifications": [
                                "Identifica corretamente picos modais no S_yy(ω) alinhados com ω_n.",
                                "Calcula variância total σ_y^2 via integração numérica com erro <5%.",
                                "Interpreta largura de pico como medida de ζ_n.",
                                "Explica efeito de S_xx(ω) na forma de S_yy(ω).",
                                "Valida com simulação temporal-FFT.",
                                "Discute limitações (linearidade, estacionariedade)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na fórmula S_yy(ω) = Σ |H_r(ω)|^2 S_xx(ω) (100%).",
                                "Qualidade de plots: resolução, escalas adequadas, legendas.",
                                "Profundidade de interpretação: ligação física a parâmetros (ω_n, ζ).",
                                "Correção numérica: erro em picos/RMS <10%.",
                                "Análise de sensibilidade: insights qualitativos/quantitativos.",
                                "Clareza no relatório: estrutura, linguagem técnica."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Propriedades de processos estocásticos estacionários e teorema de Wiener-Khinchin.",
                                "Programação/Computação: Implementação numérica com FFT, NumPy/MATLAB para análise espectral.",
                                "Física: Dinâmica linear, ressonância e amortecimento em vibrações.",
                                "Engenharia Mecânica: Análise modal e resposta em frequência.",
                                "Processamento de Sinais: Convolução, filtros LTI e PSD estimation."
                              ],
                              "realWorldApplication": "Na certificação de aeronaves (ex: FAA/EASA), espectros de resposta são usados para estimar cargas vibratórias aleatórias de turbulência ou jato, prevendo vida útil por fadiga em asas e fuselagem via métodos como Rainflow counting."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.2",
                        "name": "Resposta RMS em Sistemas com Amortecimento de Rayleigh",
                        "description": "Cálculo do valor eficaz (RMS) da resposta para sistemas de um ou múltiplos graus de liberdade sob excitações aleatórias, incorporando amortecimento proporcional de Rayleigh.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.2.1",
                            "name": "Derivar fórmula de RMS para SDOF",
                            "description": "Obter a expressão analítica para o RMS da deslocamento, velocidade e aceleração em sistemas de um grau de liberdade (SDOF) com amortecimento de Rayleigh sob excitação de base aleatória.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Estabelecer a equação de movimento para SDOF com excitação de base e amortecimento de Rayleigh",
                                  "subSteps": [
                                    "Escrever a equação absoluta para o deslocamento u_abs = u + u_g, onde u é relativo à base.",
                                    "Derivar a equação relativa: m ü + c ú + k u = -m ü_g(t), com ü_g(t) como aceleração aleatória da base.",
                                    "Introduzir amortecimento de Rayleigh: c = α m + β k.",
                                    "Substituir c na equação: m ü + (α m + β k) ú + k u = -m ü_g(t).",
                                    "Dividir por m para forma padrão: ü + (α + β ω_n²) ú + ω_n² u = -ü_g(t), com ω_n² = k/m."
                                  ],
                                  "verification": "Equação escrita corretamente, com termos de Rayleigh identificados e sinal negativo em -m ü_g.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Papel ou editor LaTeX",
                                    "Livro 'Dynamics of Structures' (Clough & Penzien, Capítulo 9)",
                                    "Notas de aula sobre SDOF"
                                  ],
                                  "tips": "Mantenha notação consistente: u relativo, ü_g aceleração da base.",
                                  "learningObjective": "Modelar matematicamente o sistema SDOF sob excitação de base com amortecimento proporcional Rayleigh.",
                                  "commonMistakes": "Confundir deslocamentos absolutos e relativos; omitir o fator -m na força de excitação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir parâmetros modais e fator de amortecimento para Rayleigh",
                                  "subSteps": [
                                    "Calcular frequência natural: ω_n = √(k/m).",
                                    "Expressar coeficiente de amortecimento: 2 ξ ω_n = α + β ω_n², logo ξ = (α / (2 ω_n)) + (β ω_n / 2).",
                                    "Escrever a equação normalizada: ü + 2 ξ ω_n ú + ω_n² u = -ü_g(t).",
                                    "Discutir dependência de ξ com a frequência (modal para Rayleigh).",
                                    "Verificar limites: α domina em baixas frequências, β em altas."
                                  ],
                                  "verification": "Expressão de ξ derivada corretamente e equação normalizada completa.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Calculadora ou software simbólico como SymPy/Mathematica",
                                    "Tabela de propriedades modais"
                                  ],
                                  "tips": "Use ξ(ω) = α/(2ω) + β ω /2 para generalidade em modo específico.",
                                  "learningObjective": "Compreender como o amortecimento Rayleigh introduz dependência frequência no fator de amortecimento.",
                                  "commonMistakes": "Erro no cálculo de ξ: inverter α e β; assumir ξ constante como em viscoso."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Representar a excitação e resposta no domínio da frequência",
                                  "subSteps": [
                                    "Assumir ü_g(t) como processo estacionário gaussiano com densidade espectral de potência (PSD) S_üg(ω), simétrica.",
                                    "Aplicar transformada de Fourier: U(ω) = H_u(ω) (-Ü_g(ω)), onde H_u(ω) é a função de transferência.",
                                    "Definir PSD da resposta: S_u(ω) = |H_u(ω)|² S_üg(ω).",
                                    "Estender para velocidade v = ú: S_v(ω) = ω² |H_u(ω)|² S_üg(ω).",
                                    "Para aceleração a = ü: S_a(ω) = ω⁴ |H_u(ω)|² S_üg(ω)."
                                  ],
                                  "verification": "PSDs expressas corretamente em termos de H_u(ω) e suas derivadas.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": [
                                    "Referência: 'Random Vibrations' (Lutes & Sarkani)",
                                    "Software MATLAB para plotar PSDs exemplares"
                                  ],
                                  "tips": "Lembre-se: PSD é unilateral para integrais práticas (fator 2 para ω>0).",
                                  "learningObjective": "Aplicar teoria espectral para ligar excitação aleatória à resposta em frequência.",
                                  "commonMistakes": "Esquecer o sinal negativo em H_u; confundir PSD bilateral com unilateral."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar explicitamente as funções de transferência H(ω)",
                                  "subSteps": [
                                    "Escrever H_u(ω) = 1 / (ω_n² - ω² + i 2 ξ ω_n ω)  [nota: ajustado pelo -ü_g].",
                                    "Confirmar: H_u(iω) = -1 / (-ω² + i 2 ξ ω_n ω + ω_n²).",
                                    "Derivar H_v(ω) = i ω H_u(ω) para velocidade.",
                                    "Derivar H_a(ω) = -ω² H_u(ω) para aceleração relativa.",
                                    "Calcular |H_u(ω)|² = 1 / [(ω_n² - ω²)² + (2 ξ ω_n ω)²]."
                                  ],
                                  "verification": "|H(ω)|² calculado corretamente para u, v e a.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "SymPy ou Wolfram Alpha para simplificação simbólica",
                                    "Folha para manipulações algébricas"
                                  ],
                                  "tips": "Use convenção e^{iωt} para consistência nas derivadas iω.",
                                  "learningObjective": "Obter expressões analíticas das funções de transferência para respostas RMS.",
                                  "commonMistakes": "Erro no denominador de H_u; esquecer fatores ω² ou iω nas derivadas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Calcular as expressões analíticas para RMS via integração das PSDs",
                                  "subSteps": [
                                    "Variância σ_u² = ∫_{-∞}^∞ S_u(ω) dω / 2π = ∫_0^∞ |H_u(ω)|² S_üg(ω) dω / π.",
                                    "Similar para σ_v² = ∫_0^∞ ω² |H_u(ω)|² S_üg(ω) dω / π.",
                                    "σ_a² = ∫_0^∞ ω⁴ |H_u(ω)|² S_üg(ω) dω / π.",
                                    "Discutir casos especiais: ruído branco S_üg constante, levando a fórmulas fechadas.",
                                    "Escrever RMS: σ_u = √σ_u², etc., como expressões finais."
                                  ],
                                  "verification": "Fórmulas de RMS derivadas para deslocamento, velocidade e aceleração.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": [
                                    "Referência: Newland 'An Introduction to Random Vibrations'",
                                    "MATLAB para validar integral numérica"
                                  ],
                                  "tips": "Para PSD branca: σ_u² ≈ (π S_üg(0) ) / (4 ξ ω_n³) no narrow-band approx.",
                                  "learningObjective": "Derivar as fórmulas finais de RMS para análise de vibrações aleatórias.",
                                  "commonMistakes": "Erro no fator de normalização da integral (2π vs π); limites de integração errados."
                                }
                              ],
                              "practicalExample": "Em uma asa de aeronave modelada como SDOF na raiz (m=100 kg, k=10^5 N/m, α=0.1, β=0.001), sob turbulência com PSD von Kármán S_üg(ω)= φ ω_g / |ω + i b|^2 (φ=0.01, b=1), derive σ_a para prever fadiga: compute H_a(ω), integre numericamente σ_a² ≈ 0.15 g RMS.",
                              "finalVerifications": [
                                "Fórmulas de σ_u, σ_v, σ_a coincidem com literatura (ex: Craig 'Structural Dynamics').",
                                "Limite ξ→0 reproduz resposta não amortecida.",
                                "Para PSD branca constante, RMS_u = √(π S_0 /(4 ξ k)) verifica dimensionalmente.",
                                "Derivação simétrica para PSD bilateral.",
                                "Teste numérico em software confirma analítico dentro de 1%.",
                                "Inclui dependência Rayleigh em ξ(ω_n)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática em todas as derivações (sem erros algébricos).",
                                "Completude: fórmulas para deslocamento, velocidade e aceleração.",
                                "Correta incorporação de amortecimento Rayleigh (ξ frequência-dependente).",
                                "Uso apropriado de teoria espectral e convenções PSD.",
                                "Clareza na apresentação com passos lógicos e unidades consistentes.",
                                "Validação com limites especiais ou exemplos numéricos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformadas de Fourier, integrais impróprias e análise complexa.",
                                "Física: Processos estocásticos e teoria de vibrações aleatórias.",
                                "Engenharia Mecânica: Análise modal e dinâmica não linear.",
                                "Computação: Simulações Monte Carlo ou FFT para validação numérica.",
                                "Estatística: Conceitos de variância e gaussianidade."
                              ],
                              "realWorldApplication": "Na certificação FAA/EASA de aeronaves, derivação de RMS prevê cargas de fadiga em painéis e suportes sob vibrações de turbulência atmosférica, otimizando design para vida útil >10^5 ciclos sem falhas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.5.2.2",
                            "name": "Aplicar análise modal para MDOF",
                            "description": "Usar coordenadas modais e ortogonalidade para calcular o RMS da resposta em sistemas multi-graus de liberdade (MDOF), assumindo modos desacoplados com amortecimento Rayleigh.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Análise Modal em Sistemas MDOF",
                                  "subSteps": [
                                    "Defina um sistema MDOF e escreva as equações de movimento acopladas: [M]{ẍ} + [C]{ẋ} + [K]{x} = {F(t)}.",
                                    "Explique a decomposição em modos normais usando autovetores Φ da equação de autovalores.",
                                    "Transforme as coordenadas físicas em coordenadas modais: {x} = [Φ]{q}, onde q são as coordenadas generalizadas.",
                                    "Verifique a ortonormalização: ΦᵀMΦ = I e ΦᵀKΦ = Λ (diagonal).",
                                    "Discuta a importância do desacoplamento modal para simplificar o problema."
                                  ],
                                  "verification": "Escreva as equações desacopladas para um sistema 2-DOF e confirme que as matrizes de massa e rigidez são diagonais.",
                                  "estimatedTime": "1-2 hours",
                                  "materials": [
                                    "Livro de Dinâmica Estrutural (Clough & Penzien)",
                                    "MATLAB ou Python com NumPy/SciPy",
                                    "Notas de aula sobre análise modal"
                                  ],
                                  "tips": "Comece com um sistema simples de 2 DOF para visualizar os modos.",
                                  "learningObjective": "Compreender a transformação modal e suas propriedades básicas em sistemas MDOF.",
                                  "commonMistakes": [
                                    "Confundir coordenadas físicas com modais",
                                    "Esquecer de normalizar os modos",
                                    "Ignorar a simetria das matrizes M e K"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Propriedades de Ortogonalidade das Funções Modais",
                                  "subSteps": [
                                    "Demonstre ΦᵀMΦ = I e ΦᵀKΦ = diag(ω_i²) para modos ortonormais.",
                                    "Estenda para amortecimento: assuma Rayleigh damping [C] = α[M] + β[K], resultando em ΦᵀCΦ ≈ diag(2ζ_i ω_i).",
                                    "Calcule forças modais: {Q(t)} = Φᵀ{F(t)}, usando ortogonalidade para excitações aleatórias.",
                                    "Derive a equação modal desacoplada: q̈_i + 2ζ_i ω_i q̇_i + ω_i² q_i = Q_i(t)/m_i.",
                                    "Aplique a uma PSD de entrada S_F(ω) para obter PSD modal S_{Q_i}(ω)."
                                  ],
                                  "verification": "Para um sistema dado, compute ΦᵀCΦ e confirme que é aproximadamente diagonal (erro <5%).",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Software de autovalores (MATLAB eig)",
                                    "Exemplos numéricos de sistemas MDOF",
                                    "Tabela de propriedades ortogonais"
                                  ],
                                  "tips": "Use modplots para visualizar modos e confirmar ortogonalidade visualmente.",
                                  "learningObjective": "Dominar as propriedades ortogonais que permitem o desacoplamento modal.",
                                  "commonMistakes": [
                                    "Assumir ortogonalidade sem normalização",
                                    "Erro na projeção de forças: esquecer Φᵀ",
                                    "Confundir ζ_i com amortecimento físico"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Amortecimento Rayleigh e Desacoplamento para Vibrações Aleatórias",
                                  "subSteps": [
                                    "Determine α e β do Rayleigh damping ajustando ζ_i para modos dominantes: ζ_i = α/(2ω_i) + β ω_i /2.",
                                    "Escreva a função de transferência modal H_i(ω) = 1 / [(ω_i² - ω²) + i 2ζ_i ω_i ω].",
                                    "Calcule PSD da resposta modal: S_{q_i}(ω) = |H_i(ω)|² S_{Q_i}(ω).",
                                    "Integre para variância modal: σ_{q_i}² = ∫ S_{q_i}(ω) dω.",
                                    "Use Parseval: σ_{q_i}² = (π / (2 m_i² ω_i³)) S_F(ω_i) para PSD branca aproximada."
                                  ],
                                  "verification": "Ajuste α, β para um sistema com ζ1=0.02, ζ3=0.05 e verifique desacoplamento.",
                                  "estimatedTime": "2-3 hours",
                                  "materials": [
                                    "Código Python/MATLAB para Rayleigh damping",
                                    "PSD de excitação aleatória (ex: turbulência)",
                                    "Gráficos de |H_i(ω)|"
                                  ],
                                  "tips": "Escolha α e β minimizando erro nos primeiros modos; ignore modos altos.",
                                  "learningObjective": "Aplicar Rayleigh damping para obter equações modais desacopladas sob excitação aleatória.",
                                  "commonMistakes": [
                                    "Escolha errada de α/β levando a ζ_i não reais",
                                    "Esquecer fator 1/m_i nas forças modais",
                                    "Integral numérica imprecisa"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular RMS da Resposta Física Usando Ortogonalidade Modal",
                                  "subSteps": [
                                    "Calcule RMS modal: RMS_{q_i} = sqrt(σ_{q_i}²).",
                                    "Reconstrua resposta física: {x_rms} = [Φ] {RMS_q}, mas use ortogonalidade para variância: σ_x² = Φ diag(σ_{q_i}²) Φᵀ.",
                                    "Para RMS vetorial: RMS_x,j = sqrt( ∑_i Φ_{j i}² σ_{q_i}² ) assumindo modos uncorrelacionados.",
                                    "Implemente numericamente para um sistema MDOF com PSD de entrada.",
                                    "Interprete: identifique contribuições modais dominantes ao RMS."
                                  ],
                                  "verification": "Compare RMS calculado analiticamente vs. simulação temporal (erro <10%).",
                                  "estimatedTime": "2-3 hours",
                                  "materials": [
                                    "Script MATLAB/Python para PSD e RMS modal",
                                    "Dados de sistema aeroespacial (massas, rigidez)",
                                    "Ferramenta de plotagem (Matplotlib)"
                                  ],
                                  "tips": "Assuma PSD constante para simplificar; valide com Monte Carlo simulation.",
                                  "learningObjective": "Calcular com precisão o RMS da resposta em coordenadas físicas via soma modal.",
                                  "commonMistakes": [
                                    "Confundir variância modal com física",
                                    "Esquecer ortogonalidade em σ_x² = Φ diag Φᵀ",
                                    "Incluir modos irrelevantes"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma viga aeroespacial 3-DOF modelada com M = diag(1,1,1) kg, K diagonal com ω1=10, ω2=30, ω3=50 rad/s, Rayleigh com ζ1=0.02, ζ2=0.03, ζ3=0.05. PSD de força S_F=0.1 (m/s²)²/Hz constante. Calcule Φ, α/β, RMS_q_i e RMS_x no DOF 2.",
                              "finalVerifications": [
                                "Derivar corretamente as equações modais desacopladas para MDOF com Rayleigh.",
                                "Calcular α e β dados ζ_i para 3 modos.",
                                "Computar RMS_q_i para PSD branca e somar para RMS físico.",
                                "Validar numericamente com simulação temporal (correlação >95%).",
                                "Identificar modo dominante contribuindo >70% do RMS.",
                                "Explicar impacto da ortogonalidade no cálculo eficiente."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações (sem erros algébricos).",
                                "Correta implementação numérica (erro RMS <5%).",
                                "Interpretação física dos resultados modais.",
                                "Eficiência computacional usando desacoplamento.",
                                "Tratamento adequado de aproximações Rayleigh.",
                                "Clareza na documentação do processo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (autovalores, diagonalização).",
                                "Engenharia Estrutural: Análise de vibrações forçadas.",
                                "Processamento de Sinais: Espectros de potência e funções de transferência.",
                                "Programação: NumPy/SciPy para simulações dinâmicas.",
                                "Física: Princípios de osciladores harmônicos desacoplados."
                              ],
                              "realWorldApplication": "Em aeronáutica, calcular RMS de vibrações em asas sob turbulência atmosférica para prever fadiga estrutural e otimizar design de amortecedores, evitando falhas como flutter em aviões comerciais."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.1.2"
                            ]
                          },
                          {
                            "id": "10.1.5.5.2.3",
                            "name": "Implementar Rayleigh em simulações",
                            "description": "Modelar matrizes de amortecimento de Rayleigh em equações modais e computar RMS via integração numérica de PSD para estruturas aeroespaciais como asas ou fuselagens.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e formular equações modais com amortecimento de Rayleigh",
                                  "subSteps": [
                                    "Derive as equações de movimento em coordenadas modais para um sistema multi-graus de liberdade (MDOF).",
                                    "Defina os coeficientes de amortecimento de Rayleigh α e β usando frequências modais naturais.",
                                    "Formule a matriz de amortecimento modal C_modal = α M_modal + β K_modal.",
                                    "Verifique a proporcionalidade do amortecimento Rayleigh assumindo modos ortogonais.",
                                    "Documente as equações para um sistema de 3 modos como exemplo inicial."
                                  ],
                                  "verification": "Equações modais escritas corretamente e matriz C Rayleigh derivada com valores de α e β calculados para frequências dadas.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Livro de dinâmica estrutural (Clough & Penzien)",
                                    "Folha de cálculo ou MATLAB para derivação simbólica",
                                    "Notas de aula sobre modos normais"
                                  ],
                                  "tips": "Use frequências dos dois primeiros modos para estimar α e β minimizando erro de amortecimento alvo.",
                                  "learningObjective": "Compreender a representação modal do amortecimento Rayleigh proporcional.",
                                  "commonMistakes": "Confundir amortecimento Rayleigh com amortecimento modal direto; ignorar ortogonalidade das matrizes modais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar modelo estrutural modal e PSD de entrada",
                                  "subSteps": [
                                    "Obtenha massas modais M_modal, frequências ω_n e vetores modais Φ de uma estrutura aeroespacial (ex: asa cantilever).",
                                    "Defina o espectro de densidade de potência (PSD) de excitação aleatória, como turbulência atmosférica.",
                                    "Escolha método de integração numérica (ex: Simpson ou Trapezoidal) para o domínio de frequência.",
                                    "Discretize o PSD em pontos de frequência relevantes (0 a 2x frequência máxima modal).",
                                    "Implemente função para ler ou gerar PSD em código (Python/MATLAB)."
                                  ],
                                  "verification": "Modelo modal com Φ, M_modal, ω_n exportado e PSD plotado corretamente com unidades consistentes.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Software FEM como ANSYS ou NASTRAN para extração modal",
                                    "Biblioteca NumPy/SciPy para PSD",
                                    "Dados de PSD padrão MIL-STD-810"
                                  ],
                                  "tips": "Garanta que PSD tenha unidades de (aceleração)^2/Hz para compatibilidade.",
                                  "learningObjective": "Configurar dados de entrada para análise de vibrações aleatórias.",
                                  "commonMistakes": "Usar frequências erradas para extração modal; escalar PSD incorretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar equação de resposta RMS em coordenadas modais",
                                  "subSteps": [
                                    "Escreva a fórmula para resposta RMS modal: σ_q_i = sqrt( ∫ G_q_i(ω) dω ), onde G_q_i é PSD de resposta modal.",
                                    "Derive G_q_i(ω) = |H_i(ω)|^2 S_x(ω), com H_i o filtro de transferência modal incluindo Rayleigh.",
                                    "Implemente H_i(ω) = 1 / (-ω^2 M_i + i 2 ζ_i ω M_i ω_n_i + K_i), ajustado para Rayleigh.",
                                    "Code a função de integração numérica para cada modo.",
                                    "Vetorize para todos os modos e some contribuições para resposta física RMS."
                                  ],
                                  "verification": "Função de código retorna RMS modal para PSD unitário conhecido, comparando com solução analítica.",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "MATLAB/Python com SciPy.integrate",
                                    "Exemplo analítico de SDOF para validação",
                                    "Documentação de Rayleigh damping"
                                  ],
                                  "tips": "Use fator de qualidade Q ou ζ efetivo de Rayleigh para cada modo.",
                                  "learningObjective": "Calcular resposta RMS via PSD modal com amortecimento Rayleigh.",
                                  "commonMistakes": "Esquecer fator |Φ|^2 na transformação física; erro de fase no H(ω) complexo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar simulação, validar e analisar resultados",
                                  "subSteps": [
                                    "Aplique modelo a estrutura exemplo (fuselagem simplificada com 5 modos).",
                                    "Execute simulação para PSD de turbulência e plote respostas RMS modais e físicas.",
                                    "Valide comparando com solução sem amortecimento ou benchmarks analíticos.",
                                    "Analise sensibilidade a α/β e refine se necessário.",
                                    "Gere relatório com plots de PSD resposta e tabela de RMS."
                                  ],
                                  "verification": "Simulação roda sem erros, RMS converge e plots mostram pico em ressonância atenuado por Rayleigh.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Código completo da simulação",
                                    "Ferramentas de plotagem (Matplotlib)",
                                    "Dados de benchmark de asa NACA"
                                  ],
                                  "tips": "Teste com PSD estreita para verificar picos modais isolados.",
                                  "learningObjective": "Aplicar e validar implementação em contexto aeroespacial.",
                                  "commonMistakes": "Sobrestimar número de pontos de integração levando a tempo excessivo; ignorar limites de frequência."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Otimizar e documentar a simulação",
                                  "subSteps": [
                                    "Otimize código para eficiência (vetorização, paralelização).",
                                    "Adicione interface para variar α, β, PSD.",
                                    "Documente código com comentários e README.",
                                    "Teste com diferentes estruturas (asa vs fuselagem).",
                                    "Prepare visualizações para apresentação."
                                  ],
                                  "verification": "Código otimizado roda em <1 min para 10 modos, documentação completa.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Git para versionamento",
                                    "Jupyter Notebook para documentação"
                                  ],
                                  "tips": "Use funções modulares para reutilização em análises futuras.",
                                  "learningObjective": "Produzir simulação robusta e documentada.",
                                  "commonMistakes": "Não versionar código; hardcoded parâmetros."
                                }
                              ],
                              "practicalExample": "Simule uma asa cantilever de alumínio (comprimento 2m, 5 modos) sob PSD de turbulância (S_x(ω) = 0.01 / ω^2 g^2/Hz). Compute RMS de deslocamento na ponta da asa usando Rayleigh com ζ=2% nos modos 1-2, plotando resposta vs frequência.",
                              "finalVerifications": [
                                "Matriz de amortecimento Rayleigh corretamente proporcional e modal.",
                                "PSD de resposta modal mostra atenuação em ressonância.",
                                "RMS físico computado soma contribuições modais corretamente.",
                                "Simulação converge com malha de frequência fina.",
                                "Resultados validados contra caso sem amortecimento.",
                                "Código executável e reproduzível."
                              ],
                              "assessmentCriteria": [
                                "Precisão da derivação de H_i(ω) com Rayleigh (erro <1%).",
                                "Eficiência numérica da integração (tempo <5s para 1000 pontos).",
                                "Correção da transformação modal-física.",
                                "Análise de sensibilidade a parâmetros demonstrada.",
                                "Qualidade de plots e documentação.",
                                "Aplicação realista a estrutura aeroespacial."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Integração numérica e funções complexas.",
                                "Programação: Implementação em Python/MATLAB com vetores.",
                                "Física: Dinâmica de vibrações e aeroelasticidade.",
                                "Engenharia: Análise FEM modal.",
                                "Estatística: Processos estocásticos e PSD."
                              ],
                              "realWorldApplication": "Certificação de aeronaves pela FAA/EASA, prevendo fadiga e vibrações em asas/fuselagens sob turbulência, otimizando design para reduzir RMS e estender vida útil."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.5.3",
                        "name": "Predição de Picos de Resposta Estatística",
                        "description": "Métodos para estimar níveis de pico (peak) da resposta aleatória, incluindo fatores de pico e distribuições estatísticas para fadiga e dimensionamento em aeroespaciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.5.3.1",
                            "name": "Calcular fator de pico RMS",
                            "description": "Aplicar o fator de pico médio (como √(2 ln νT) para processos gaussianos) para predizer picos a partir do RMS em vibrações aleatórias de estruturas aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de RMS e Vibrações Aleatórias",
                                  "subSteps": [
                                    "Defina RMS (Root Mean Square) como a magnitude efetiva de uma vibração aleatória.",
                                    "Explique o que são picos em processos gaussianos estacionários.",
                                    "Discuta a importância de predizer picos a partir de RMS em estruturas aeroespaciais.",
                                    "Revise distribuições gaussianas e propriedades estatísticas de vibrações.",
                                    "Identifique parâmetros chave: ν (taxa de zero-crossings) e T (duração do teste)."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos e liste definições corretas sem erros.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de texto sobre dinâmica de estruturas (ex: Clough & Penzien), calculadora científica.",
                                  "tips": "Use diagramas de espectro de potência para visualizar vibrações aleatórias.",
                                  "learningObjective": "Dominar terminologia e base teórica para fator de pico RMS.",
                                  "commonMistakes": "Confundir RMS com amplitude máxima; ignorar estacionariedade do processo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar a Fórmula do Fator de Pico Médio",
                                  "subSteps": [
                                    "Apresente a fórmula aproximada: F_p = √(2 ln(ν T)) para processos gaussianos estreitos de banda.",
                                    "Derive intuitivamente a partir da teoria de extremos de Davenport.",
                                    "Discuta correções para banda larga: fator de irregularidade γ.",
                                    "Calcule ν como frequência média de zero-crossings: ν = (1/π) √(m2/m0), onde mi são momentos espectrais.",
                                    "Exemplifique com valores típicos em aeroespacial (ν ≈ 10-100 Hz)."
                                  ],
                                  "verification": "Escreva a fórmula correta e derive ν para um espectro simples.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Artigo de Davenport (1964), software MATLAB para momentos espectrais.",
                                  "tips": "Memorize √(2 ln(ν T)) como base; pratique com ln natural.",
                                  "learningObjective": "Reproduzir e explicar a fórmula do fator de pico.",
                                  "commonMistakes": "Usar log10 em vez de ln; esquecer unidades de ν e T."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar Cálculos Passo a Passo do Fator de Pico",
                                  "subSteps": [
                                    "Colete dados: RMS (σ), ν e T de um teste de vibração.",
                                    "Calcule o argumento: ν T.",
                                    "Compute ln(ν T) e multiplique por 2.",
                                    "Tire raiz quadrada para obter F_p.",
                                    "Calcule pico esperado: Pico_RMS = F_p * σ."
                                  ],
                                  "verification": "Resolva um problema numérico e confira com valor tabelado (±5% erro).",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Planilha Excel ou Python script para cálculos, dados de exemplo de vibração.",
                                  "tips": "Use calculadora com funções ln e sqrt; verifique overflow para T grande.",
                                  "learningObjective": "Executar cálculo preciso do fator de pico RMS.",
                                  "commonMistakes": "Erro aritmético em ln; não converter unidades de tempo/frequência."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Contexto Aeroespacial e Validar",
                                  "subSteps": [
                                    "Selecione caso: vibração randômica em painel de fuselagem (σ=0.1g, ν=20Hz, T=600s).",
                                    "Calcule F_p e Pico_RMS.",
                                    "Compare com simulações FEM ou dados experimentais.",
                                    "Avalie sensibilidade a variações em ν e T.",
                                    "Documente relatório com gráfico de distribuição de picos."
                                  ],
                                  "verification": "Gere relatório com cálculo, gráfico e discussão de precisão.",
                                  "estimatedTime": "1 hora 15 minutos",
                                  "materials": "Software ANSYS/NASTRAN para validação, dados de teste MIL-STD-810.",
                                  "tips": "Sempre inclua margens de segurança (ex: fator 1.1-1.2 para conservadorismo).",
                                  "learningObjective": "Integrar cálculo em análise estrutural aeroespacial.",
                                  "commonMistakes": "Ignorar efeitos não-gaussianos; superestimar para banda larga."
                                }
                              ],
                              "practicalExample": "Em um teste de qualificação de uma asa de UAV sob vibração randômica (σ_RMS = 5 m/s², ν = 15 Hz, T = 1800 s), calcule F_p ≈ √(2 ln(15*1800)) ≈ 3.72, logo Pico_RMS ≈ 18.6 m/s². Use para verificar tensão máxima na pele de alumínio.",
                              "finalVerifications": [
                                "Cálculo de F_p coincide com fórmula padrão para νT > 100.",
                                "Pico predito é 3-5 vezes σ_RMS para testes típicos.",
                                "ν calculado corretamente de momentos espectrais.",
                                "Relatório inclui limitações (ex: não-gaussiano).",
                                "Gráfico de PDF de picos vs. gaussiano.",
                                "Margem de segurança aplicada corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica: erro < 2% na fórmula.",
                                "Compreensão conceitual: explica Davenport corretamente.",
                                "Aplicação contextual: liga a fadiga estrutural.",
                                "Análise de sensibilidade: varia ν/T e discute impacto.",
                                "Documentação: relatório claro com unidades.",
                                "Validação: compara com dados reais ou simulação."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: distribuições extremas e momentos espectrais.",
                                "Engenharia Mecânica: análise modal e resposta dinâmica.",
                                "Física: processos estocásticos e teoria de Rayleigh.",
                                "Programação: scripts Python/MATLAB para automação."
                              ],
                              "realWorldApplication": "Predizer picos de tensão em componentes de aeronaves durante voo turbulento ou lançamento de foguetes, garantindo conformidade com MIL-STD-810 e prevenindo falhas por fadiga em missões espaciais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.2.2"
                            ]
                          },
                          {
                            "id": "10.1.5.5.3.2",
                            "name": "Analisar distribuições de extremos",
                            "description": "Usar teoria de valores extremos (Gumbel ou Weibull) para estimar probabilidades de ultrapassagem de picos em respostas de asas ou painéis sob turbulência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos da Teoria de Valores Extremos",
                                  "subSteps": [
                                    "Estude os teoremas de Fisher-Tippett-Gnedenko sobre convergência de máximos para distribuições Gumbel, Fréchet e Weibull.",
                                    "Entenda as formas assintóticas das distribuições de extremos tipo I (Gumbel), II e III (Weibull para mínimos).",
                                    "Aprenda os parâmetros: localização (μ), escala (β) e forma (ξ) para cada distribuição.",
                                    "Revise o conceito de bloco de máximos (block maxima) e picos sobre limiares (POT).",
                                    "Identifique quando usar Gumbel (caudas exponenciais) vs. Weibull (caudas limitadas) em respostas estruturais."
                                  ],
                                  "verification": "Resuma em um diagrama as três distribuições de extremos e suas aplicações em aeroelasticidade.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro 'Extreme Value Theory' de Stuart Coles; slides de ST-57; software MATLAB ou Python (scipy.stats).",
                                  "tips": "Use gráficos QQ para visualizar convergência assintótica rapidamente.",
                                  "learningObjective": "Compreender as bases teóricas para seleção de distribuições de extremos em vibrações aleatórias.",
                                  "commonMistakes": "Confundir Gumbel (ilimitado) com Weibull (limitado superior); ignorar normalização dos dados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e Extrair Dados de Picos de Resposta",
                                  "subSteps": [
                                    "Simule ou obtenha séries temporais de resposta de asas/painéis sob turbulência (ex: modelo de von Karman).",
                                    "Aplique filtro de Rainflow ou extraia picos locais usando detecção de zero-crossings.",
                                    "Forme blocos de máximos (ex: máximos por ciclo de turbulência) ou excedências sobre limiar u.",
                                    "Normalize os picos: Z = (X - μ)/β, verificando independência e estacionariedade.",
                                    "Plote histogramas e caudas empíricas para inspeção visual."
                                  ],
                                  "verification": "Gere um conjunto de pelo menos 100 picos independentes e plote o EDF (Empirical Distribution Function).",
                                  "estimatedTime": "3 horas",
                                  "materials": "Software NASTRAN ou MATLAB Aeroelasticity Toolbox; dados de turbulência Dryden ou von Karman.",
                                  "tips": "Escolha limiar u como 90% percentil para POT, evitando poucos eventos.",
                                  "learningObjective": "Preparar dados de picos adequados para modelagem de extremos em estruturas aeroespaciais.",
                                  "commonMistakes": "Incluir picos dependentes sem declustering; não verificar estacionariedade da turbulência."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ajustar Distribuições Gumbel ou Weibull aos Dados",
                                  "subSteps": [
                                    "Estime parâmetros iniciais via momentos (média e variância dos log-picos para Gumbel).",
                                    "Use máxima verossimilhança (MLE) com scipy.stats.gumbel_r ou weibull_min.",
                                    "Teste goodness-of-fit: Kolmogorov-Smirnov, Anderson-Darling ou QQ-plots.",
                                    "Selecione melhor modelo via AIC/BIC ou teste de Hill para forma ξ.",
                                    "Valide com bootstrap para intervalos de confiança nos parâmetros."
                                  ],
                                  "verification": "Obtenha parâmetros ajustados com p-value > 0.05 no teste KS e plote QQ-plot linear.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Python (scipy, statsmodels); R (extRemes package); dados preparados do Step 2.",
                                  "tips": "Para respostas de asas, Gumbel é comum; Weibull se houver bound físico (ex: yield stress).",
                                  "learningObjective": "Ajustar e validar distribuições de extremos aos dados de picos estruturais.",
                                  "commonMistakes": "Sobreajuste com poucos dados; ignorar viés de MLE em amostras pequenas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estimar Probabilidades de Ultrapassagem e Interpretar",
                                  "subSteps": [
                                    "Calcule probabilidade de ultrapassagem: P(X > x) = 1 - F(x; μ, β, ξ) para horizonte T.",
                                    "Estime picos esperados: η = μ + β * (γ + log(T)) para Gumbel (γ Euler-Mascheroni).",
                                    "Compute retornos levels para períodos raros (ex: 10^-3 probabilidade).",
                                    "Avalie risco de fadiga cumulativa integrando sobre a cauda.",
                                    "Compare com critérios de design (ex: 3σ picos em FAR-25)."
                                  ],
                                  "verification": "Gere tabela de probabilidades para x = 2σ, 3σ e plote curva de risco vs. amplitude.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Código Python do Step 3; normas FAR/JAR aeroespaciais.",
                                  "tips": "Use aproximações assintóticas para T grande, evitando simulações caras.",
                                  "learningObjective": "Quantificar riscos de picos extremos em respostas de asas/painéis sob turbulência.",
                                  "commonMistakes": "Esquecer fator de tempo T na extrapolação; usar normal em vez de EV para caudas pesadas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Aplicar a Casos de Estudo",
                                  "subSteps": [
                                    "Simule Monte Carlo para validar predições de EV.",
                                    "Aplique a modelo de asa (ex: AGARD 445.6) ou painel retangular.",
                                    "Compare predições com dados experimentais de wind tunnel.",
                                    "Documente sensibilidade a parâmetros de turbulência.",
                                    "Gere relatório com plots e recomendações de design."
                                  ],
                                  "verification": "Erro relativo < 10% entre predição EV e Monte Carlo para probabilidade 10^-3.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Modelos benchmark AGARD; software SIMPACK ou ZAERO.",
                                  "tips": "Teste robustez variando intensidade de turbulência.",
                                  "learningObjective": "Aplicar análise de extremos a problemas reais de aeroelasticidade.",
                                  "commonMistakes": "Não validar com dados independentes; subestimar dispersão em ξ."
                                }
                              ],
                              "practicalExample": "Em uma simulação de asa flexível sob turbulência moderada (IAS=150 kt), extraia 500 picos de flexão na raiz. Ajuste Gumbel aos block maxima, estime P/pico > 2.5σ) ≈ 10^-4 para 1000h de voo, garantindo margem de fadiga.",
                              "finalVerifications": [
                                "Plot QQ linear entre dados empíricos e Gumbel/Weibull ajustada.",
                                "Probabilidades de ultrapassagem coincidem com Monte Carlo (±5%).",
                                "Intervalos de confiança nos retornos levels são razoáveis (<20% CV).",
                                "Seleção de modelo justificada por AIC e testes de fit.",
                                "Relatório inclui interpretação para design estrutural.",
                                "Sensibilidade a limiar u ou tamanho de bloco analisada."
                              ],
                              "assessmentCriteria": [
                                "Precisão no ajuste de parâmetros (erro KS < 0.1).",
                                "Correta extrapolação para eventos raros (T>10^3).",
                                "Interpretação física das probabilidades em contexto aeroespacial.",
                                "Qualidade de visualizações (QQ, PP, caudas).",
                                "Tratamento de dependências e estacionariedade nos dados.",
                                "Aplicação correta a asas/painéis com validação."
                              ],
                              "crossCurricularConnections": [
                                "Estatística Avançada: Modelos de caudas pesadas e MLE.",
                                "Dinâmica de Estruturas: Resposta a cargas aleatórias e fadiga.",
                                "Probabilidade e Risco: Análise de eventos extremos em engenharia.",
                                "Simulação Numérica: Monte Carlo e métodos de bootstrapping.",
                                "Normas Aeronáuticas: FAR-25 gust loads e certificação."
                              ],
                              "realWorldApplication": "Na certificação de aeronaves (ex: Boeing 787), prediz picos de resposta em asas sob rajadas severas, dimensionando reforços para evitar falha por fadiga em 10^5 ciclos, otimizando peso e segurança."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.2.3"
                            ]
                          },
                          {
                            "id": "10.1.5.5.3.3",
                            "name": "Avaliar contagens de ciclo de fadiga",
                            "description": "Calcular espectros de contagem de ciclo (rainflow) a partir de respostas aleatórias para previsão de vida útil em componentes aeroespaciais sujeitos a vibrações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Processar Dados de Resposta Aleatória",
                                  "subSteps": [
                                    "Obtenha o espectro de densidade de potência (PSD) da resposta estrutural de vibrações aleatórias.",
                                    "Converta o PSD em uma série temporal realista usando método de simulação (ex: método de Shinozuka ou filtro digital).",
                                    "Filtre ruídos e normalize os dados para representar deslocamentos ou tensões reais.",
                                    "Calcule estatísticas iniciais: RMS, picos médios e desvios padrão.",
                                    "Valide a série temporal comparando com o PSD original via FFT."
                                  ],
                                  "verification": "Verifique se a FFT inversa da série temporal reconstrói o PSD original com erro <5%.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Software MATLAB/Python (SciPy, NumPy), dados PSD de simulação ou teste experimental.",
                                  "tips": "Use sementes fixas para reprodutibilidade em simulações.",
                                  "learningObjective": "Compreender a geração de sinais aleatórios estacionários a partir de PSDs para análise de fadiga.",
                                  "commonMistakes": "Ignorar não-estacionaridade ou usar amostragem inadequada levando a aliasing."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o Algoritmo Rainflow para Extração de Ciclos",
                                  "subSteps": [
                                    "Aplique o algoritmo Rainflow à série temporal: identifique picos e vales sequencialmente.",
                                    "Forme 'chuvas' (rainflows) conectando picos/vales de amplitudes similares.",
                                    "Extraia ciclos completos (fechados) e residuais (abertos) conforme ASTM E1049.",
                                    "Registre amplitude, médio e contagem para cada ciclo extraído.",
                                    "Visualize a sequência de ciclos com plot de histograma de reversões."
                                  ],
                                  "verification": "Compare contagens manuais em uma série sintética simples com o algoritmo automatizado.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": "Bibliotecas Rainflow (ex: pyRainflow em Python, ou função fatcount em MATLAB), série temporal gerada.",
                                  "tips": "Implemente em código para eficiência; teste com onda senoidal conhecida.",
                                  "learningObjective": "Dominar o counting de ciclos Rainflow para histories irregulares de carregamento.",
                                  "commonMistakes": "Confundir ciclos residuais com completos ou ignorar histérese."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o Espectro de Contagem de Ciclos (Matriz de Histograma)",
                                  "subSteps": [
                                    "Binne amplitudes e níveis médios em uma grade (ex: 20x20 bins).",
                                    "Some contagens de ciclos em cada bin da matriz de contagem.",
                                    "Ajuste para correção de ciclo (ex: fator 0.5 para alguns métodos).",
                                    "Gere curvas S-N (Wöhler) para o material do componente aeroespacial.",
                                    "Calcule dano por bin usando regra de Miner: D_i = n_i / N_i."
                                  ],
                                  "verification": "Some danos totais D_total <1 para vida finita; valide com software comercial como nCode.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Dados de curva S-N (ex: alumínio 2024-T3), planilhas ou scripts Python/MATLAB.",
                                  "tips": "Use log-escala para bins de amplitude para melhor resolução em baixos ciclos.",
                                  "learningObjective": "Criar histogramas de fadiga para previsão quantitativa de vida útil.",
                                  "commonMistakes": "Escolha errada de bins levando a sub/sobre-estimação de dano."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Prever Vida Útil e Validar Previsão",
                                  "subSteps": [
                                    "Some danos cumulativos: D_total = Σ D_i sobre todos bins.",
                                    "Estime ciclos até falha: N_f = 1 / D_total (por unidade de tempo).",
                                    "Converta para vida útil em horas de voo considerando taxa de ocorrência.",
                                    "Realize análise de sensibilidade variando PSD ou S-N.",
                                    "Compare com métodos alternativos (ex: Dirlik para PSD direto)."
                                  ],
                                  "verification": "Erro de previsão <20% em benchmark de fadiga aleatória conhecido.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Curvas S-N experimentais, relatórios de certificação FAA.",
                                  "tips": "Inclua fator de segurança 2-4 para aplicações aeroespaciais.",
                                  "learningObjective": "Integrar contagens Rainflow com mecânica de fadiga para predição de vida em vibrações aleatórias.",
                                  "commonMistakes": "Não linearizar danos ou ignorar efeitos de sequência."
                                }
                              ],
                              "practicalExample": "Em uma asa de aeronave sujeita a turbulência, gere série temporal de flexão raiz a partir de PSD de teste de shaker. Aplique Rainflow para obter 10^5 ciclos, matriz mostra dano dominante em R=0.1, prevendo 20.000 horas de voo até crack de 0.5mm.",
                              "finalVerifications": [
                                "Matriz de contagem de ciclos reproduz distribuição de amplitudes esperada do PSD.",
                                "Dano total converge para valor físico realista (<1 para vida design).",
                                "Visualizações (histograma, rainflow plot) sem anomalias numéricas.",
                                "Código/scripts executam sem erros e são reprodutíveis.",
                                "Previsão de vida útil sensível corretamente a variações de PSD.",
                                "Comparação com método Dirlik mostra concordância >90%."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração de ciclos Rainflow (erro <2% em testes sintéticos).",
                                "Correta construção e interpretação da matriz de histograma.",
                                "Aplicação precisa da regra de Palmgren-Miner para dano cumulativo.",
                                "Validação estatística das séries temporais (kurtosis, skewness).",
                                "Relatório claro com plots e justificativas de premissas.",
                                "Eficiência computacional para séries longas (>10^6 pontos)."
                              ],
                              "crossCurricularConnections": [
                                "Estatística e Probabilidade: Análise de processos estocásticos e PSD.",
                                "Programação Computacional: Implementação numérica em Python/MATLAB.",
                                "Mecânica dos Materiais: Curvas S-N e propagação de trincas (Paris' law).",
                                "Engenharia Aeroespacial: Certificação FAR/JAR para fadiga flutter.",
                                "Análise de Dados: Processamento de sinais e FFT."
                              ],
                              "realWorldApplication": "Predição de vida útil de painéis de fuselagem em jatos comerciais durante voos turbulentos, essencial para agendamento de inspeções na manutenção preditiva da Boeing/Airbus, evitando falhas catastróficas como no Aloha Airlines 243."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.3.1"
                            ]
                          },
                          {
                            "id": "10.1.5.5.3.4",
                            "name": "Validar com ensaios experimentais",
                            "description": "Comparar predições teóricas de picos e RMS com dados de ensaios de vibração em mesa vibratória para estruturas aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar e Finalizar Predições Teóricas",
                                  "subSteps": [
                                    "Reveja o modelo teórico de Rayleigh para amortecimento e resposta a vibrações aleatórias.",
                                    "Calcule predições de picos estatísticos e RMS usando equações de resposta espectral.",
                                    "Documente todas as premissas, parâmetros (ex.: espectro de potência de entrada) e resultados esperados.",
                                    "Valide numericamente o modelo com simulações preliminares em software como MATLAB ou NASTRAN.",
                                    "Gere gráficos de resposta teórica para comparação futura."
                                  ],
                                  "verification": "Predições documentadas em relatório com gráficos e valores numéricos de picos e RMS.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Software de análise (MATLAB, Python com SciPy), modelo FEM da estrutura, espectro de vibração padrão (ex.: MIL-STD-810).",
                                  "tips": "Use unidades consistentes (gRMS para aceleração) e considere fatores de segurança iniciais.",
                                  "learningObjective": "Dominar cálculo preciso de respostas teóricas para vibrações aleatórias em estruturas aeroespaciais.",
                                  "commonMistakes": "Ignorar efeitos não-lineares ou usar espectro incorreto; sempre cross-check com literatura."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Planejar e Configurar Ensaio Experimental",
                                  "subSteps": [
                                    "Defina objetivos do teste alinhados às predições (níveis de vibração, direções, durações).",
                                    "Selecione e instrumente a estrutura com acelerômetros (pelo menos 10 canais para pontos críticos).",
                                    "Calibre mesa vibratória e sensores conforme normas (ex.: ISO 5344).",
                                    "Configure sistema de aquisição de dados (DAQ) com taxa de amostragem > 2x frequência máxima.",
                                    "Realize testes de shaker e verifique uniformidade do campo vibracional."
                                  ],
                                  "verification": "Checklist de configuração assinado e dados de calibração registrados.",
                                  "estimatedTime": "6-8 horas",
                                  "materials": "Mesa vibratória eletrodinâmica, acelerômetros piezoelétricos, DAQ (ex.: NI LabVIEW), estrutura de teste (mock-up de painel aeroespacial).",
                                  "tips": "Posicione sensores em nós modais críticos identificados no modelo.",
                                  "learningObjective": "Aprender planejamento experimental rigoroso para reprodutibilidade em testes de vibração.",
                                  "commonMistakes": "Subestimação de fixações; use grampos e adesivos aeroespaciais testados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Ensaio e Coletar Dados",
                                  "subSteps": [
                                    "Inicie vibração random com espectro matching ao teórico (controle closed-loop).",
                                    "Monitore em tempo real níveis RMS e evite sobrecargas (abortar se >120% target).",
                                    "Colete dados por pelo menos 60 segundos por nível, com múltiplas repetições (3x).",
                                    "Registre condições ambientais (temperatura, umidade) e logs do shaker.",
                                    "Pare o teste e inspecione estrutura por danos visíveis."
                                  ],
                                  "verification": "Arquivos de dados brutos salvos com metadados completos e sem interrupções.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Mesa vibratória, software de controle (ex.: Vibration Research), cabos e fixações.",
                                  "tips": "Use random fatigue spectrum para simular vida real; monitore fadiga acumulada.",
                                  "learningObjective": "Executar testes de vibração controlados com segurança e precisão.",
                                  "commonMistakes": "Excitação insuficiente; verifique PSD em tempo real."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Processar Dados Experimentais",
                                  "subSteps": [
                                    "Filtre dados brutos (anti-aliasing, remoção de DC) usando FFT.",
                                    "Calcule PSD experimental e extraia picos (99% statistical) e RMS por canal.",
                                    "Aplique correções por calibração e compute médias/ desvios de repetições.",
                                    "Gere gráficos de PSD e time history para pontos chave.",
                                    "Compare estatisticamente com predições (t-test ou correlação)."
                                  ],
                                  "verification": "Relatório de processamento com valores de picos/RMS e gráficos overlay.",
                                  "estimatedTime": "5-7 horas",
                                  "materials": "Software de pós-processamento (MATLAB Signal Processing Toolbox, Artemis).",
                                  "tips": "Use windowing (Hanning) para reduzir leakage em PSD.",
                                  "learningObjective": "Mestre análise estatística de dados vibracionais experimentais.",
                                  "commonMistakes": "Não normalizar por massa; sempre reporte em gRMS."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar, Validar e Relatar",
                                  "subSteps": [
                                    "Sobreponha curvas teóricas e experimentais (picos, RMS vs. frequência).",
                                    "Calcule métricas de discrepância (ex.: <15% para validação).",
                                    "Identifique discrepâncias e proponha ajustes no modelo (ex.: damping real).",
                                    "Documente conclusões, limitações e recomendações para testes futuros.",
                                    "Prepare apresentação com visuals claros."
                                  ],
                                  "verification": "Relatório final com tabelas de comparação e declaração de validação.",
                                  "estimatedTime": "3-5 horas",
                                  "materials": "Ferramentas de plotting (Excel, MATLAB), template de relatório.",
                                  "tips": "Use scatter plots para correlação; quantifique confiança com intervals.",
                                  "learningObjective": "Interpretar validação teórico-experimental e iterar modelos.",
                                  "commonMistakes": "Ignorar incertezas experimentais; inclua error bars."
                                }
                              ],
                              "practicalExample": "Em um mock-up de painel de fuselagem de satélite, prediga RMS de 5g em 100-2000Hz via Rayleigh; teste em mesa LDS V9 com 10 acelerômetros, compare picos medidos (4.8g) vs. preditos (5.1g), ajustando damping em 8%.",
                              "finalVerifications": [
                                "Discrepância média de picos/RMS < 15% entre teoria e experimento.",
                                "PSD experimental matching teórico em bandas críticas (>80% correlação).",
                                "Todos dados processados sem artefatos (SNR >20dB).",
                                "Relatório completo com raw data, processamento e comparações.",
                                "Modelo atualizado incorpora lições experimentais.",
                                "Sem danos na estrutura pós-teste."
                              ],
                              "assessmentCriteria": [
                                "Precisão das predições teóricas (erro <10% em simulações preliminares).",
                                "Qualidade da configuração experimental (calibração verificada).",
                                "Integridade dos dados coletados (repetições consistentes, CV<5%).",
                                "Análise estatística robusta (uso correto de picos 99%, RMS).",
                                "Interpretação clara de discrepâncias e propostas de melhoria.",
                                "Relatório profissional com visuals e referências normativas.",
                                "Segurança e conformidade com normas aeroespaciais."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Análise de PSD, testes de hipótese para validação.",
                                "Engenharia Experimental: Calibração de sensores e DAQ.",
                                "Materiais: Efeitos de damping em compósitos aeroespaciais.",
                                "Controle de Sistemas: Closed-loop shaker control.",
                                "Qualidade e Certificação: MIL-STD-810G para vibração random."
                              ],
                              "realWorldApplication": "Validação de painéis de asas ou fuselagens em programas como Boeing 787 ou SpaceX Falcon, garantindo certificação FAA/EASA contra falhas vibracionais em voo turbulentos ou lançamento."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.5.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.6",
                "name": "Ensaios Experimentais de Vibração e Aeroelasticidade",
                "description": "Cobre ensaios de vibração estrutural experimental, aeroelasticidade de placas e cascas, problemas de estabilidade e resposta aeroelástica, modelos aeroelásticos na base modal e ensaios em túnel de vento.",
                "totalSkills": 60,
                "atomicTopics": [
                  {
                    "id": "10.1.6.1",
                    "name": "Ensaios de Vibração Estrutural Experimental",
                    "description": "Técnicas e procedimentos para realização de ensaios experimentais de vibrações em estruturas aeroespaciais.",
                    "individualConcepts": [
                      {
                        "id": "57.3.1.1",
                        "name": "Instrumentação para Ensaios de Vibração",
                        "description": "Seleção, instalação e calibração de sensores e equipamentos necessários para medir vibrações em estruturas aeroespaciais.",
                        "specificSkills": [
                          {
                            "id": "57.3.1.1.1",
                            "name": "Selecionar sensores adequados",
                            "description": "Identificar e escolher acelerômetros, velocímetros e strain gauges apropriados para capturar respostas dinâmicas em estruturas aeroespaciais, considerando faixa de frequência, sensibilidade e ambiente de teste.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir Requisitos da Medição",
                                  "subSteps": [
                                    "Analise o tipo de estrutura aeroespacial e as respostas dinâmicas esperadas (ex.: vibrações modais, acelerações).",
                                    "Determine a faixa de frequência de interesse (ex.: 0-1000 Hz para modos fundamentais).",
                                    "Identifique condições ambientais (temperatura, umidade, vibrações extremas, campo magnético).",
                                    "Especifique níveis de sensibilidade requeridos (ex.: resolução de 0.01 g para acelerações).",
                                    "Defina precisão, resolução e taxa de amostragem necessárias."
                                  ],
                                  "verification": "Documente um relatório de requisitos com tabela resumindo faixa de freq, sensibilidade e ambiente.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Especificações do teste, manuais de estruturas aeroespaciais, software de análise modal (ex.: MATLAB).",
                                  "tips": "Use diagramas de corpo livre para mapear pontos de medição críticos.",
                                  "learningObjective": "Compreender como requisitos do teste ditam escolhas de sensores.",
                                  "commonMistakes": "Ignorar efeitos ambientais como temperatura, levando a sensores inadequados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Tipos de Sensores Adequados",
                                  "subSteps": [
                                    "Revise características de acelerômetros (piezoelétricos, MEMS, capacitivos).",
                                    "Compare velocímetros (ex.: LDV - Laser Doppler Velocimetry) para medições não-contato.",
                                    "Estude strain gauges (foil, semiconductor) para deformações locais.",
                                    "Classifique sensores por aplicação: aceleração linear, angular, strain.",
                                    "Consulte catálogos de fabricantes (ex.: PCB Piezotronics, Brüel & Kjær)."
                                  ],
                                  "verification": "Crie uma matriz comparativa de 3-5 sensores por tipo com prós e contras.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Catálogos online de sensores, datasheets PDF, banco de dados de sensores aeroespaciais.",
                                  "tips": "Priorize sensores com certificação aeroespacial (ex.: MIL-STD).",
                                  "learningObjective": "Diferenciar sensores por princípio de operação e adequação a vibrações.",
                                  "commonMistakes": "Confundir velocímetros com acelerômetros sem considerar integração temporal."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar Especificações Técnicas",
                                  "subSteps": [
                                    "Verifique faixa de frequência vs. ressonância do sensor (deve cobrir 1.5x a freq máxima).",
                                    "Avalie sensibilidade e faixa dinâmica (ex.: 100 mV/g, ±50g).",
                                    "Teste compatibilidade ambiental (IP rating, temperatura operacional).",
                                    "Calcule ruído e resolução efetiva para o sinal esperado.",
                                    "Simule resposta em software (ex.: resposta em freq com FFT)."
                                  ],
                                  "verification": "Gere gráficos de resposta em frequência e tabela de specs vs. requisitos.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Software de simulação (ANSYS, LabVIEW), calculadora, datasheets detalhados.",
                                  "tips": "Use fator de segurança 1.5 na faixa de freq para margens de erro.",
                                  "learningObjective": "Aplicar critérios quantitativos para matching de specs.",
                                  "commonMistakes": "Selecionar sensor com faixa de freq estreita, perdendo modos altos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Selecionar e Justificar Escolha Final",
                                  "subSteps": [
                                    "Pontue sensores com base em requisitos (peso 40% freq, 30% sensibilidade, 30% ambiente).",
                                    "Selecione o sensor ótimo por ponto de medição (ex.: strain gauge em root da asa).",
                                    "Planeje montagem e calibração (adesivos, condicionadores de sinal).",
                                    "Estime custo e disponibilidade.",
                                    "Documente justificativa com trade-offs."
                                  ],
                                  "verification": "Apresente relatório final com seleção, justificativa e plano de implementação.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Planilha de decisão multicritério (Excel), relatórios anteriores.",
                                  "tips": "Considere custo-benefício; sensores baratos podem falhar em testes caros.",
                                  "learningObjective": "Tomar decisões baseadas em evidências e trade-offs.",
                                  "commonMistakes": "Escolher sensor único para todos pontos, ignorando variações locais."
                                }
                              ],
                              "practicalExample": "Para teste de vibração em asa de UAV: selecione acelerômetro MEMS (ex.: ADXL345) para ponta da asa (alta freq, baixa massa) e strain gauge foil para raiz (alta strain, ambiente controlado).",
                              "finalVerifications": [
                                "Relatório lista sensores com specs matching 100% dos requisitos.",
                                "Matriz comparativa mostra pelo menos 3 opções por tipo avaliadas.",
                                "Gráficos de resposta em freq confirmam cobertura da faixa necessária.",
                                "Justificativa aborda trade-offs ambientais e de custo.",
                                "Plano de montagem inclui calibração e condicionamento de sinal.",
                                "Simulação preliminar valida sinal/ruído > 20 dB."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de requisitos (90% alinhamento).",
                                "Profundidade da comparação de sensores (cobertura de 3+ tipos).",
                                "Análise quantitativa de specs (cálculos corretos).",
                                "Justificativa lógica e baseada em evidências.",
                                "Integração de fatores ambientais e práticos.",
                                "Clareza e completude do relatório final."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Condicionadores de sinal e DAQ systems.",
                                "Materiais: Compatibilidade de strain gauges com compósitos aeroespaciais.",
                                "Análise Numérica: Simulações modais em FEM.",
                                "Segurança: Certificações MIL-STD para ambientes hostis."
                              ],
                              "realWorldApplication": "Em testes de qualificação de asas de aviões na Embraer ou Boeing, selecionar sensores corretos evita falhas catastróficas em flutter, economizando milhões em redesign."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.3.1.1.2",
                            "name": "Instalar e calibrar instrumentação",
                            "description": "Realizar a montagem física dos sensores na estrutura de teste, incluindo fixação adequada e calibração estática/dinâmica para garantir precisão nas medições de vibração.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e preparar sensores e estrutura de teste",
                                  "subSteps": [
                                    "Identificar os tipos de sensores necessários (ex: acelerômetros piezoelétricos para vibração)",
                                    "Verificar especificações dos sensores (faixa de frequência, sensibilidade, faixa dinâmica)",
                                    "Limpar a estrutura de teste e superfícies de montagem com álcool isopropílico",
                                    "Preparar cabos e conectores, testando continuidade elétrica",
                                    "Planejar posições de montagem baseadas no modo de vibração esperado"
                                  ],
                                  "verification": "Checklist assinado confirmando preparação e testes elétricos iniciais sem falhas",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Acelerômetros, strain gauges",
                                    "Álcool isopropílico, panos sem fiapos",
                                    "Multímetro",
                                    "Diagrama de montagem"
                                  ],
                                  "tips": "Sempre use luvas para evitar contaminação por óleos da pele nos sensores",
                                  "learningObjective": "Compreender seleção de sensores adequados para medições precisas de vibração",
                                  "commonMistakes": "Selecionar sensores com faixa de frequência inadequada; ignorar limpeza da superfície"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Realizar montagem física e fixação dos sensores",
                                  "subSteps": [
                                    "Aplicar adesivo cianoacrilato ou fita dupla-face de alta resistência em superfícies planas",
                                    "Fixar sensores nas posições planejadas, garantindo alinhamento perpendicular à direção de medição",
                                    "Segurar firmemente por 1-2 minutos para cura inicial do adesivo",
                                    "Conectar cabos aos sensores e roteá-los evitando tensão ou interferência",
                                    "Proteger conexões com fita isolante ou capas contra vibração excessiva"
                                  ],
                                  "verification": "Inspeção visual e teste de tração leve (sem descolamento) em cada sensor",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Adesivo cianoacrilato (superglue aeroespacial)",
                                    "Fita dupla-face 3M",
                                    "Cabos coaxiais",
                                    "Fita isolante"
                                  ],
                                  "tips": "Aplique adesivo em pouca quantidade para evitar bolhas de ar que afetam a transmissão de vibração",
                                  "learningObjective": "Dominar técnicas de fixação que minimizam ruído e garantem acoplamento rígido",
                                  "commonMistakes": "Excesso de adesivo criando massa extra; desalinhamento angular dos sensores"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar calibração estática",
                                  "subSteps": [
                                    "Conectar sistema de aquisição de dados (DAQ) e software de calibração",
                                    "Aplicar cargas conhecidas estáticas (pesos) em direções conhecidas",
                                    "Registrar respostas dos sensores e calcular fator de calibração (sensibilidade)",
                                    "Ajustar offsets de zero para eliminar deriva",
                                    "Repetir medições em múltiplos pontos para validar linearidade"
                                  ],
                                  "verification": "Fator de calibração dentro de ±5% do valor nominal do fabricante",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Sistema DAQ (ex: NI USB-DAQ)",
                                    "Pesos de calibração padronizados",
                                    "Software LabVIEW ou similar"
                                  ],
                                  "tips": "Mantenha temperatura ambiente constante para evitar variações térmicas",
                                  "learningObjective": "Calcular e aplicar fatores de calibração estática para precisão em medições DC",
                                  "commonMistakes": "Não zerar offsets corretamente; ignorar histerese em cargas cíclicas"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar calibração dinâmica e verificação final",
                                  "subSteps": [
                                    "Aplicar excitação dinâmica controlada (shaker ou martelo de impacto)",
                                    "Medir resposta em frequência usando FFT e comparar com referência conhecida",
                                    "Ajustar ganho e fase para minimizar discrepâncias",
                                    "Testar conjunto completo com excitação em múltiplas direções",
                                    "Documentar relatório de calibração com gráficos de resposta em frequência"
                                  ],
                                  "verification": "Resposta em frequência coincide com referência em ±10% até a frequência de interesse",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Shaker eletrodinâmico ou martelo de impacto",
                                    "Referência acelerômetro calibrado",
                                    "Software de análise modal (ex: LMS Test.Lab)"
                                  ],
                                  "tips": "Use excitação senoidal varrida lentamente para capturar ressonâncias sem sobrecarga",
                                  "learningObjective": "Validar precisão dinâmica garantindo fidelidade em medições de vibração transitória",
                                  "commonMistakes": "Excitação excessiva danificando sensores; não considerar crosstalk entre eixos"
                                }
                              ],
                              "practicalExample": "Em uma viga cantilever simulando ala de aeronave, instale 3 acelerômetros ao longo do span: um na raiz, um no meio e um na ponta. Fixe com superglue, calibre estaticamente com pesos de 100g, e dinamicamente com shaker a 100-1000 Hz, verificando picos modais em 50 Hz e 200 Hz.",
                              "finalVerifications": [
                                "Todos sensores fixados sem folgas ou desalinhamentos visíveis",
                                "Sinais elétricos estáveis sem ruído excessivo (>60 dB SNR)",
                                "Calibração estática com erro <5%; dinâmica com coerência >0.95",
                                "Resposta em frequência matches referência em banda de interesse",
                                "Documentação completa com fotos, fatores de calibração e gráficos",
                                "Teste de durabilidade: 10 ciclos de vibração sem perda de sinal"
                              ],
                              "assessmentCriteria": [
                                "Precisão da fixação: ausência de ruído de montagem em sinais",
                                "Fatores de calibração dentro de tolerâncias especificadas",
                                "Linearidade e repetibilidade em testes estáticos/dinâmicos",
                                "Qualidade da documentação e relatórios gerados",
                                "Segurança: uso correto de EPIs e procedimentos",
                                "Eficiência temporal: conclusão dentro do tempo estimado"
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Conexões e sinal conditioning para DAQ",
                                "Programação: Scripts para automação de calibração em Python/MATLAB",
                                "Segurança no Trabalho: Manuseio de equipamentos de alta vibração",
                                "Matemática: Análise de FFT e cálculo de sensibilidade"
                              ],
                              "realWorldApplication": "Em testes de qualificação de estruturas aeroespaciais, como painéis de fuselagem da Embraer, onde instrumentação precisa garante detecção precoce de flutter ou fadiga, evitando falhas catastróficas em voo."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.3.1.1.3",
                            "name": "Configurar sistemas de aquisição de dados",
                            "description": "Configurar data loggers ou sistemas DAQ para amostragem adequada, considerando taxa de Nyquist e filtros anti-aliasing para vibrações estruturais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Determinar Requisitos de Amostragem Baseados na Análise de Frequência",
                                  "subSteps": [
                                    "Identifique as frequências de vibração esperadas na estrutura (f_max) através de análise modal ou dados preliminares.",
                                    "Calcule a taxa de Nyquist: fs >= 2 * f_max, adicionando margem de 20-50% para segurança.",
                                    "Defina a resolução temporal necessária e o número de canais de dados.",
                                    "Documente os requisitos em uma planilha ou relatório.",
                                    "Considere ruído ambiente e aliasing potencial."
                                  ],
                                  "verification": "Verifique se fs calculada é pelo menos 2.5x f_max e documentada corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de análise modal (ex: MATLAB, ANSYS)",
                                    "Dados de frequência da estrutura",
                                    "Planilha Excel"
                                  ],
                                  "tips": "Sempre superestime f_max para evitar subamostragem.",
                                  "learningObjective": "Compreender e aplicar o teorema de Nyquist para dimensionar sistemas de aquisição.",
                                  "commonMistakes": "Subestimar f_max levando a aliasing invisível nos dados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e Configurar Hardware de Aquisição de Dados",
                                  "subSteps": [
                                    "Escolha data logger ou sistema DAQ com taxa de amostragem >= fs calculada e canais suficientes.",
                                    "Conecte sensores de vibração (acelerômetros) aos canais de entrada.",
                                    "Configure ganho, faixa dinâmica e excitação se necessário.",
                                    "Instale drivers e verifique conexões físicas.",
                                    "Teste alimentação e grounding para minimizar ruído."
                                  ],
                                  "verification": "Execute um teste de continuidade e verifique sinal de referência em todos os canais.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Data logger/DAQ (ex: NI DAQmx, Arduino com shield)",
                                    "Acelerômetros",
                                    "Cabos BNC/shielded",
                                    "Multímetro"
                                  ],
                                  "tips": "Use cabos blindados para reduzir interferência eletromagnética.",
                                  "learningObjective": "Selecionar hardware compatível com requisitos de vibração estrutural.",
                                  "commonMistakes": "Ignorar compatibilidade de impedância entre sensores e DAQ."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Software com Filtros Anti-Aliasing",
                                  "subSteps": [
                                    "Instale e abra o software de aquisição (ex: LabVIEW, DAQami).",
                                    "Defina taxa de amostragem fs, trigger e duração da aquisição.",
                                    "Ative filtros anti-aliasing (low-pass com fc = fs/2).",
                                    "Configure decimação ou downsampling se necessário.",
                                    "Salve configuração como template para reutilização."
                                  ],
                                  "verification": "Simule sinal acima de fs/2 e confirme atenuação pelo filtro.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software DAQ (LabVIEW, Python com PyDAQmx)",
                                    "Computador com interface USB/PCIe"
                                  ],
                                  "tips": "Teste filtros com sinal senoidal conhecido antes da aplicação real.",
                                  "learningObjective": "Implementar filtros para prevenir aliasing em dados de vibração.",
                                  "commonMistakes": "Esquecer de ativar anti-aliasing, causando distorção espectral."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Validar o Sistema Completo",
                                  "subSteps": [
                                    "Aplique excitação conhecida (ex: martelo de impacto) à estrutura.",
                                    "Adquira dados e analise espectro de frequência (FFT).",
                                    "Verifique ausência de aliasing e fidelidade do sinal.",
                                    "Calibre sensores comparando com referência.",
                                    "Ajuste parâmetros e reteste até aprovação."
                                  ],
                                  "verification": "Espectro FFT mostra picos corretos sem componentes espúrios acima de f_max.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Martelo de impacto",
                                    "Software FFT (MATLAB, Python SciPy)",
                                    "Estrutura de teste"
                                  ],
                                  "tips": "Registre todas as aquisições para auditoria posterior.",
                                  "learningObjective": "Validar configuração através de testes empíricos.",
                                  "commonMistakes": "Não calibrar, levando a erros de amplitude."
                                }
                              ],
                              "practicalExample": "Configure um NI DAQ-9234 para testar vibrações em uma viga cantilever com f_max=500Hz: defina fs=2500Hz, aplique filtro anti-aliasing fc=1250Hz, conecte acelerômetros, excitação com shaker, e valide espectro FFT sem aliasing.",
                              "finalVerifications": [
                                "Taxa de amostragem fs >= 2.5 * f_max confirmada.",
                                "Filtros anti-aliasing ativos e testados.",
                                "Sinais adquiridos sem clipping ou ruído excessivo.",
                                "Espectro FFT reproduz modos esperados.",
                                "Sistema estável por 10 minutos contínuos.",
                                "Calibração verificada com sinal referência."
                              ],
                              "assessmentCriteria": [
                                "Cálculo preciso de Nyquist com margem de segurança.",
                                "Seleção adequada de hardware para especificações.",
                                "Configuração correta de filtros no software.",
                                "Validação empírica com análise espectral.",
                                "Documentação completa de passos e resultados.",
                                "Identificação e correção de erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Processamento de Sinais Digitais (teorema de Nyquist, FFT).",
                                "Eletrônica e Instrumentação (seleção de sensores/DAQ).",
                                "Análise Estrutural (modos de vibração).",
                                "Programação (scripts Python/LabVIEW para automação).",
                                "Estatística (análise de ruído e incertezas)."
                              ],
                              "realWorldApplication": "Em ensaios de qualificação de asas de aeronaves na Embraer, configurações DAQ garantem detecção precisa de flutter aeroelástico, evitando falhas catastróficas em voo."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "57.3.1.2",
                        "name": "Técnicas de Excitação Estrutural",
                        "description": "Métodos para aplicar forças de excitação controladas em estruturas aeroespaciais durante ensaios experimentais.",
                        "specificSkills": [
                          {
                            "id": "57.3.1.2.1",
                            "name": "Aplicar excitação por impacto (martelo)",
                            "description": "Executar testes de impacto com martelo instrumentado para excitar modos de vibração em estruturas, garantindo repetibilidade e cobertura de frequências naturais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a estrutura de teste e instrumentação",
                                  "subSteps": [
                                    "Fixar a estrutura de teste em um suporte rígido e estável para minimizar vibrações espúrias.",
                                    "Instalar acelerômetros em pontos estratégicos da estrutura, garantindo alinhamento correto e fixação segura.",
                                    "Conectar todos os sensores a um sistema de aquisição de dados (DAQ) e verificar conexões elétricas.",
                                    "Configurar o software de aquisição para registrar sinais com taxa de amostragem adequada (ex: >2x frequência máxima esperada).",
                                    "Realizar testes de ruído de fundo para baseline."
                                  ],
                                  "verification": "Verificar se todos os canais do DAQ mostram sinal de ruído baixo (<1% da amplitude esperada) e sem desconexões.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": "Estrutura de teste (ex: viga cantilever), acelerômetros, DAQ, cabos, suporte de fixação, computador com software (ex: LabVIEW ou MATLAB).",
                                  "tips": "Use fita adesiva de alta resistência ou clamps para fixar sensores; evite superfícies irregulares.",
                                  "learningObjective": "Entender a importância da preparação adequada para dados limpos e confiáveis.",
                                  "commonMistakes": "Fixação solta de sensores levando a ruído; taxa de amostragem insuficiente causando aliasing."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calibrar o martelo instrumentado",
                                  "subSteps": [
                                    "Verificar a integridade do martelo: ponta de impacto adequada (ex: borracha para baixas frequências) e força integrada.",
                                    "Realizar calibração em superfície rígida para validar resposta em frequência do martelo.",
                                    "Ajustar ganho e offset no DAQ para o canal do martelo.",
                                    "Executar impactos de referência em bloco rígido e comparar com curva de calibração do fabricante.",
                                    "Registrar calibração e salvar perfil no software."
                                  ],
                                  "verification": "Curva de resposta em frequência do martelo coincide com especificações (±5% de erro).",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": "Martelo instrumentado (ex: PCB ou Dytran), bloco rígido de calibração, DAQ.",
                                  "tips": "Use luvas antiestáticas para manusear o martelo; limpe a ponta antes de cada uso.",
                                  "learningObjective": "Dominar calibração para garantir medições precisas de força de excitação.",
                                  "commonMistakes": "Ponta errada causando excesso de altas frequências; offset não zerado distorcendo integrals de força."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar testes de impacto controlados",
                                  "subSteps": [
                                    "Definir grid de pontos de impacto baseado em modos esperados (ex: NODAL lines).",
                                    "Executar 5-10 impactos repetidos em cada ponto, com ângulo perpendicular e força consistente.",
                                    "Monitorar FRFs (Funções de Resposta em Frequência) em tempo real para cobertura de modos.",
                                    "Variar pontos de impacto até cobrir todas as frequências naturais alvo.",
                                    "Registrar condições ambientais (temperatura, umidade)."
                                  ],
                                  "verification": "FRFs mostram picos claros nos modos esperados com coerência >0.95 em bandas de interesse.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": "Martelo calibrado, estrutura preparada, DAQ em operação.",
                                  "tips": "Pratique swing consistente como golfe; marque pontos com fita para repetibilidade.",
                                  "learningObjective": "Executar excitação com repetibilidade para identificação modal confiável.",
                                  "commonMistakes": "Impactos oblíquos reduzindo energia transferida; número insuficiente de médias causando variabilidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar dados e validar repetibilidade",
                                  "subSteps": [
                                    "Processar FRFs: windowing (Hanning), média de impactos, remoção de leakage.",
                                    "Identificar modos: picos de frequência, damping e mode shapes via peak-picking ou circle-fit.",
                                    "Verificar repetibilidade: comparar FRFs de impactos múltiplos (desvio <5%).",
                                    "Avaliar cobertura: modos observados vs. esperados de simulação FEM.",
                                    "Gerar relatório com gráficos e métricas."
                                  ],
                                  "verification": "Repetibilidade confirmada (CV <5% em frequências naturais) e cobertura >90% dos modos alvo.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": "Software de análise (MATLAB Vibration Toolbox ou LMS Test.Lab).",
                                  "tips": "Use zoom em FRFs para precisão; exporte dados em CSV para backup.",
                                  "learningObjective": "Interpretar dados para validar qualidade do teste experimental.",
                                  "commonMistakes": "Windowing inadequado causando leakage; ignorar baixa coerência em validação."
                                }
                              ],
                              "practicalExample": "Em um laboratório aeroespacial, fixe uma viga de alumínio representando uma longarina de asa. Use martelo com ponta de borracha para excitar os primeiros 5 modos de flexão. Bata em 10 pontos ao longo da viga, adquira dados com 4 acelerômetros e confirme frequências naturais em 50, 150, 300 Hz etc., validando contra modelo FEM.",
                              "finalVerifications": [
                                "FRFs exibem coerência >0.95 nos modos de interesse.",
                                "Repetibilidade de frequências naturais <2% de variação entre impactos.",
                                "Cobertura de pelo menos 80% dos modos naturais previstos.",
                                "Energia de impacto consistente (integral de força similar).",
                                "Ausência de vibrações espúrias ou ruído excessivo.",
                                "Relatório gerado com mode shapes identificados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de frequências naturais (±5% vs. referência).",
                                "Repetibilidade dos testes (desvio padrão <3%).",
                                "Segurança na manipulação do equipamento.",
                                "Eficiência temporal (dentro do estimado).",
                                "Qualidade dos dados (coerência e SNR altos).",
                                "Documentação completa e análise correta."
                              ],
                              "crossCurricularConnections": [
                                "Física: Teoria de vibrações modais e equações de movimento.",
                                "Engenharia Mecânica: Análise modal experimental e simulações FEM.",
                                "Processamento de Sinais: FFT, windowing e análise de FRF.",
                                "Segurança e Normas: ABNT NBR ISO 5344 para testes de vibração."
                              ],
                              "realWorldApplication": "Em indústrias aeroespaciais como Embraer ou Boeing, testes de impacto com martelo validam modelos dinâmicos de asas e fuselagens durante certificação (ex: FAR 25), identificando flutter risks e otimizando designs para fadiga e vibração."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.3.1.2.2",
                            "name": "Utilizar excitadores eletrodinâmicos (shakers)",
                            "description": "Configurar e operar shakers para excitação harmônica ou aleatória, ajustando amplitude e frequência para simular cargas dinâmicas aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparação e inspeção do equipamento",
                                  "subSteps": [
                                    "Inspecione visualmente o shaker eletrodinâmico quanto a danos, cabos soltos ou desgaste.",
                                    "Verifique a estrutura de teste (ex.: viga ou modelo aeroespacial) para fixações seguras e ausência de folgas.",
                                    "Calcule a massa do shaker e selecione o modelo adequado para a carga dinâmica simulada.",
                                    "Prepare o ambiente de teste: isole vibrações externas e garanta ventilação para o shaker.",
                                    "Registre dados iniciais: peso da estrutura, dimensões e condições ambientais."
                                  ],
                                  "verification": "Checklist de inspeção assinado confirmando ausência de anomalias.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Shaker eletrodinâmico",
                                    "Estrutura de teste",
                                    "Ferramentas de inspeção (paquímetro, torquímetro)",
                                    "Checklist impresso"
                                  ],
                                  "tips": "Sempre use EPI (óculos, luvas) e priorize segurança ao manusear equipamentos pesados.",
                                  "learningObjective": "Identificar e preparar componentes para operação segura do shaker.",
                                  "commonMistakes": [
                                    "Ignorar desgaste em cabos, levando a falhas elétricas",
                                    "Subestimar massa do shaker, causando imprecisões",
                                    "Não registrar condições iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Montagem e fixação do shaker na estrutura",
                                  "subSteps": [
                                    "Posicione o shaker no ponto de excitação desejado na estrutura.",
                                    "Fixe o shaker usando parafusos de alta resistência com torque especificado pelo fabricante.",
                                    "Instale o transdutor de força (load cell) entre shaker e estrutura para medição precisa.",
                                    "Conecte o acelerômetro na estrutura para monitoramento de resposta.",
                                    "Teste preliminar de fixação com vibração manual para verificar estabilidade."
                                  ],
                                  "verification": "Teste de vibração baixa confirma fixação sem deslizamentos ou ruídos anormais.",
                                  "estimatedTime": "1,5 horas",
                                  "materials": [
                                    "Parafusos de fixação",
                                    "Load cell",
                                    "Acelerômetro",
                                    "Torquímetro",
                                    "Chave de torque"
                                  ],
                                  "tips": "Aplique torque em padrão cruzado para distribuição uniforme de forças.",
                                  "learningObjective": "Montar shaker de forma segura e precisa para transmissão eficiente de vibrações.",
                                  "commonMistakes": [
                                    "Torque inadequado causando folgas",
                                    "Posição errada do shaker alterando modos vibratórios",
                                    "Omissão do load cell"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configuração do sistema de controle e amplificador",
                                  "subSteps": [
                                    "Conecte o shaker ao amplificador de potência e ao controlador (software como LMS ou LabVIEW).",
                                    "Calibre o sistema: zero o load cell e verifique sensibilidade do acelerômetro.",
                                    "Defina parâmetros iniciais: faixa de frequência (ex.: 5-2000 Hz), limite de amplitude e força máxima.",
                                    "Configure aquisição de dados: taxa de amostragem > 2x frequência máxima.",
                                    "Realize auto-teste do sistema para sincronização shaker-sensor."
                                  ],
                                  "verification": "Gráfico de resposta em malha aberta mostra sinal limpo sem distorções.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Amplificador de potência",
                                    "Controlador/software",
                                    "Cabos BNC e power",
                                    "Computador com DAQ"
                                  ],
                                  "tips": "Use filtros passa-baixa para evitar sobrecarga em altas frequências.",
                                  "learningObjective": "Configurar eletrônica e software para controle preciso de excitação.",
                                  "commonMistakes": [
                                    "Calibração incorreta levando a medições erradas",
                                    "Taxa de amostragem baixa causando aliasing",
                                    "Conexões soltas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Execução de excitação harmônica e ajustes",
                                  "subSteps": [
                                    "Inicie excitação harmônica em frequência fixa baixa (ex.: 10 Hz) e aumente amplitude gradualmente.",
                                    "Varra frequências (sweep) de 5-500 Hz para identificar ressonâncias.",
                                    "Ajuste amplitude e frequência para simular cargas dinâmicas aeroespaciais (ex.: flutter).",
                                    "Monitore resposta em tempo real: aceleração vs. força.",
                                    "Registre FRF (Função de Resposta em Frequência) para análise."
                                  ],
                                  "verification": "FRF gerada com picos de ressonância claros e sem clipping.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de controle",
                                    "Óculos de proteção para vibrações intensas"
                                  ],
                                  "tips": "Pare imediatamente se detectar sobrecarga térmica no shaker.",
                                  "learningObjective": "Operar shaker em modo harmônico com controle de parâmetros dinâmicos.",
                                  "commonMistakes": [
                                    "Aumento rápido de amplitude causando danos",
                                    "Sweep muito rápido perdendo ressonâncias",
                                    "Ignorar limites de força"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Execução de excitação aleatória e finalização",
                                  "subSteps": [
                                    "Gere espectro de potência aleatório baseado em perfis aeroespaciais (ex.: PSD de turbulência).",
                                    "Aplique excitação aleatória, ajustando RMS de aceleração para níveis de qualificação.",
                                    "Monitore fadiga e integridade da estrutura durante 30-60 minutos.",
                                    "Desligue sistema gradualmente e colete dados finais.",
                                    "Desmonte e inspecione pós-teste para danos."
                                  ],
                                  "verification": "PSD de resposta coincide com espectro de entrada dentro de 10% de tolerância.",
                                  "estimatedTime": "2,5 horas",
                                  "materials": [
                                    "Perfis PSD padrão aeroespacial",
                                    "Ferramentas de desmontagem"
                                  ],
                                  "tips": "Use controle de feedback para manter níveis consistentes.",
                                  "learningObjective": "Aplicar excitação aleatória realista e analisar resultados.",
                                  "commonMistakes": [
                                    "Espectro inadequado não simulando condições reais",
                                    "Tempo de teste insuficiente",
                                    "Desmontagem sem inspeção"
                                  ]
                                }
                              ],
                              "practicalExample": "Configurar um shaker para excitar uma viga cantilever representando uma asa de drone, varrendo frequências harmônicas até 100 Hz para identificar o primeiro modo de flexão, e depois aplicar excitação aleatória com PSD simulando rajadas de vento, medindo resposta com acelerômetros.",
                              "finalVerifications": [
                                "FRF harmônica mostra ressonâncias precisas com damping correto.",
                                "PSD aleatória mantém níveis RMS estáveis sem sobrecarga.",
                                "Nenhum dano visível na estrutura ou shaker pós-teste.",
                                "Dados adquiridos são limpos e analisáveis.",
                                "Relatório inclui parâmetros usados e observações.",
                                "Segurança mantida: sem incidentes ou alertas do sistema."
                              ],
                              "assessmentCriteria": [
                                "Precisão na configuração: erros <5% em calibração.",
                                "Segurança: adesão total a protocolos sem violações.",
                                "Eficiência: conclusão dentro do tempo estimado.",
                                "Qualidade de dados: sinal-ruído >20 dB.",
                                "Análise: identificação correta de pelo menos 3 modos vibratórios.",
                                "Documentação: relatório completo com gráficos e conclusões."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica de potência (amplificadores e drivers)",
                                "Controle automático (loops de feedback)",
                                "Processamento de sinais (FFT e PSD)",
                                "Mecânica dos sólidos (modos vibratórios)",
                                "Segurança industrial (normas NR-10 e NR-12)"
                              ],
                              "realWorldApplication": "Em indústrias aeroespaciais como Embraer ou Boeing, shakers eletrodinâmicos qualificam componentes de aeronaves (asas, fuselagem) sob vibrações de motores e turbulência, garantindo conformidade com normas FAA/EASA para certificação de voo seguro."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.3.1.2.3",
                            "name": "Realizar excitação por base",
                            "description": "Implementar excitação na base da estrutura para simular vibrações ambientais, como as de lançamento de foguetes ou turbulência atmosférica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a estrutura de teste e a base de excitação",
                                  "subSteps": [
                                    "Selecionar e inspecionar a estrutura modelo (ex.: painel ou viga aeroespacial).",
                                    "Fixar rigidamente a estrutura na mesa de testes ou base shaker usando grampos e parafusos com torque especificado.",
                                    "Verificar alinhamento e ausência de folgas na fixação.",
                                    "Limpar superfícies de contato para evitar deslizamentos.",
                                    "Documentar configuração inicial com fotos ou diagramas."
                                  ],
                                  "verification": "Estrutura fixada sem movimento ao aplicar força manual; torque dos parafusos medido e registrado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Estrutura modelo",
                                    "Mesa shaker ou base de testes",
                                    "Grampos e parafusos",
                                    "Torquímetro",
                                    "Nível de bolha"
                                  ],
                                  "tips": [
                                    "Aplique torque em padrão cruzado para uniformidade.",
                                    "Use fita adesiva de alta resistência se necessário para protótipos."
                                  ],
                                  "learningObjective": "Compreender a importância de uma fixação rígida para transmitir excitação fiel da base à estrutura.",
                                  "commonMistakes": [
                                    "Fixação solta causando modos espúrios",
                                    "Alinhamento desalinhado gerando assimetrias",
                                    "Superfícies sujas promovendo deslizamento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Instalar e fixar o excitador (shaker) na base",
                                  "subSteps": [
                                    "Posicionar o shaker eletrodinâmico na base sob a estrutura.",
                                    "Fixar o shaker à base usando flanges e parafusos de alta resistência.",
                                    "Conectar o stinger ou haste de transmissão à base da estrutura.",
                                    "Verificar curso livre do shaker e ausência de interferências mecânicas.",
                                    "Testar acionamento em baixa amplitude para checar ruídos."
                                  ],
                                  "verification": "Shaker fixado sem vibrações parasitas; teste de baixa amplitude confirma transmissão suave.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Shaker eletrodinâmico",
                                    "Stinger ou haste de transmissão",
                                    "Flanges e parafusos",
                                    "Chaves de torque"
                                  ],
                                  "tips": [
                                    "Alinhe o eixo do shaker perpendicular à base para excitação pura.",
                                    "Lubrifique conexões móveis se aplicável."
                                  ],
                                  "learningObjective": "Dominar a montagem mecânica do excitador para excitação base-efetiva.",
                                  "commonMistakes": [
                                    "Fixação inadequada do shaker causando perda de energia",
                                    "Stinger muito rígido ou flexível alterando resposta",
                                    "Interferência com estrutura durante curso máximo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Instrumentar com sensores e configurar aquisição de dados",
                                  "subSteps": [
                                    "Colar acelerômetros na base, estrutura e pontos críticos.",
                                    "Conectar sensores ao sistema de aquisição de dados (DAQ).",
                                    "Calibrar sensores e verificar sinais em tempo real.",
                                    "Configurar canais de entrada para força (load cell no shaker) e aceleração.",
                                    "Testar integridade do cabeamento com sinal de referência."
                                  ],
                                  "verification": "Sinais dos sensores limpos e calibrados; resposta a pulso de martelo coincide com calibração.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Acelerômetros",
                                    "Load cell",
                                    "Sistema DAQ",
                                    "Adesivo epóxi para sensores",
                                    "Cabeamento blindado"
                                  ],
                                  "tips": [
                                    "Posicione acelerômetros em nós e antinós esperados.",
                                    "Use massa compensadora em sensores para minimizar carregamento."
                                  ],
                                  "learningObjective": "Aprender instrumentação precisa para medição de respostas vibracionais.",
                                  "commonMistakes": [
                                    "Colagem inadequada de sensores caindo durante teste",
                                    "Cabeamento solto introduzindo ruído",
                                    "Falta de calibração levando a escalas erradas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Configurar controle de excitação e espectro de vibração",
                                  "subSteps": [
                                    "Definir espectro de excitação baseado em padrões ambientais (ex.: lançamento de foguete).",
                                    "Configurar controlador do shaker para modo base-excitation (aceleração ou deslocamento).",
                                    "Ajustar limites de amplitude, força e frequência (tipicamente 5-2000 Hz).",
                                    "Executar sweep sinusoidal para identificar ressonâncias preliminares.",
                                    "Salvar configuração e realizar teste de segurança em baixa amplitude."
                                  ],
                                  "verification": "Espectro aplicado reproduz fielmente o perfil alvo; sem sobrecarga no shaker.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software de controle vibracional (ex.: LMS Test.Lab)",
                                    "Computador com interface DAQ",
                                    "Especificações de vibração ambiental"
                                  ],
                                  "tips": [
                                    "Comece com 10% da amplitude alvo e incremente gradualmente.",
                                    "Monitore temperatura do shaker durante sweeps."
                                  ],
                                  "learningObjective": "Configurar excitação realista simulando condições ambientais aeroespaciais.",
                                  "commonMistakes": [
                                    "Espectro inadequado não representando cenários reais",
                                    "Limites mal definidos causando falha no shaker",
                                    "Ignorar não-linearidades em altas amplitudes"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Executar teste, monitorar e coletar dados",
                                  "subSteps": [
                                    "Iniciar excitação controlada pelo espectro definido.",
                                    "Monitorar respostas em tempo real via software.",
                                    "Registrar múltiplas corridas para repetibilidade.",
                                    "Parar teste se detectar anomalias (ex.: clipping ou aquecimento).",
                                    "Desligar shaker e salvar todos os dados brutos."
                                  ],
                                  "verification": "Dados coletados mostram resposta estável e repetível; FRF (Função de Resposta em Frequência) coerente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software de monitoramento",
                                    "Óculos de segurança",
                                    "Luvas anti-vibração"
                                  ],
                                  "tips": [
                                    "Mantenha ambiente controlado (sem tráfego próximo).",
                                    "Registre condições ambientais (temperatura, umidade)."
                                  ],
                                  "learningObjective": "Executar ensaio com segurança e coletar dados de qualidade para análise posterior.",
                                  "commonMistakes": [
                                    "Teste prolongado causando fadiga prematura",
                                    "Não pausar para resfriamento do shaker",
                                    "Dados corrompidos por interrupções abruptas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um laboratório aeroespacial, fixe um modelo de painel de satélite em uma mesa shaker. Configure excitação base com espectro de lançamento de foguete (20-2000 Hz, 5g RMS). Meça acelerações na base e na ponta do painel para validar modos de flexão torsional simulando turbulência de lançamento.",
                              "finalVerifications": [
                                "Excitação transmitida uniformemente da base à estrutura sem perdas significativas (>95% eficiência).",
                                "Respostas vibracionais coincidem com simulações analíticas (erro <10% em frequências modais).",
                                "Dados sem ruído excessivo (SNR > 20 dB).",
                                "Nenhuma falha mecânica ou dano à estrutura.",
                                "Repetibilidade entre corridas <5% variação RMS.",
                                "FRF base-estrutura captura todos os modos relevantes."
                              ],
                              "assessmentCriteria": [
                                "Precisão e rigidez da montagem (ausência de folgas ou desalinhamentos).",
                                "Qualidade da instrumentação (sinais limpos e calibrados).",
                                "Fidelidade do espectro de excitação ao perfil ambiental alvo.",
                                "Segurança no procedimento (monitoramento de limites e EPI).",
                                "Eficiência temporal (dentro do tempo estimado total).",
                                "Documentação completa de configuração e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Física: Dinâmica de vibrações e ondas mecânicas.",
                                "Engenharia de Controle: Sistemas de feedback para controle de shaker.",
                                "Matemática: Transformada de Fourier para análise espectral.",
                                "Engenharia Mecânica: Projeto de fixações e fadiga de materiais.",
                                "Informática: Processamento de sinais digitais em DAQ."
                              ],
                              "realWorldApplication": "Nos testes de qualificação de foguetes e satélites (ex.: NASA SLS ou SpaceX Falcon), excitação por base simula vibrações acústicas e dinâmicas de lançamento, garantindo que estruturas resistam a cargas ambientais sem falha catastrófica."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "57.3.1.3",
                        "name": "Análise e Identificação Modal Experimental",
                        "description": "Processamento de dados e extração de parâmetros modais a partir de ensaios de vibração em estruturas aeroespaciais.",
                        "specificSkills": [
                          {
                            "id": "57.3.1.3.1",
                            "name": "Processar sinais de vibração",
                            "description": "Aplicar transformadas de Fourier (FFT) e análise espectral para identificar picos de frequência e formas modais a partir de dados adquiridos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Aquisição e Pré-processamento de Sinais de Vibração",
                                  "subSteps": [
                                    "Importar dados de vibração adquiridos de sensores acelerométricos ou deslocamento.",
                                    "Aplicar filtros passa-baixa ou anti-aliasing para remover ruído de alta frequência.",
                                    "Remover tendência linear e normalizar o sinal para média zero.",
                                    "Dividir o sinal em janelas sobrepostas usando função de janela (ex: Hanning).",
                                    "Verificar a taxa de amostragem e duração do sinal para adequação à análise espectral."
                                  ],
                                  "verification": "Sinais pré-processados exibem ausência de tendência e ruído excessivo em plot visual e estatísticas descritivas.",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": "Software MATLAB/Python (SciPy/NumPy), dados de vibração em CSV, documentação de sensores.",
                                  "tips": "Use janelas de 50% sobreposição para reduzir vazamento espectral.",
                                  "learningObjective": "Preparar sinais de vibração limpos e prontos para análise espectral.",
                                  "commonMistakes": "Ignorar remoção de tendência, levando a picos espúrios em baixa frequência."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar Transformada de Fourier Rápida (FFT)",
                                  "subSteps": [
                                    "Calcular a FFT de cada janela do sinal usando funções built-in (fft() no MATLAB ou np.fft.fft() no Python).",
                                    "Obter o espectro de amplitude e fase convertendo para domínio de frequência.",
                                    "Calcular densidade espectral de potência (PSD) via Welch's method para média de espectros.",
                                    "Definir eixos de frequência usando taxa de amostragem (f = fs * np.arange(N)/N).",
                                    "Plotar espectro de frequência para visualização inicial."
                                  ],
                                  "verification": "Espectro de frequência mostra picos coerentes sem artefatos de processamento.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": "Bibliotecas NumPy/SciPy/MATLAB Signal Processing Toolbox, scripts de FFT.",
                                  "tips": "Escolha N (tamanho FFT) como potência de 2 para eficiência computacional.",
                                  "learningObjective": "Gerar espectros de frequência precisos a partir de sinais temporais.",
                                  "commonMistakes": "Não aplicar janela, causando vazamento espectral e distorção de picos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Picos de Frequência no Espectro",
                                  "subSteps": [
                                    "Aplicar detecção de picos usando findpeaks() ou peakutils no espectro de amplitude.",
                                    "Definir thresholds de amplitude e curvatura para filtrar picos falsos.",
                                    "Listar frequências modais principais (f1, f2, etc.) e amplitudes associadas.",
                                    "Comparar com frequências esperadas de modelo analítico ou FEM.",
                                    "Anotar largura de banda e fator de qualidade (Q) para cada pico."
                                  ],
                                  "verification": "Lista de picos com frequências precisas (±1% erro) e sem falsos positivos.",
                                  "estimatedTime": "25-40 minutos",
                                  "materials": "Funções de detecção de picos (SciPy signal.find_peaks), espectros gerados.",
                                  "tips": "Use threshold adaptativo baseado em ruído de fundo para robustez.",
                                  "learningObjective": "Extrair frequências naturais dominantes do espectro.",
                                  "commonMistakes": "Threshold baixo, detectando ruído como picos modais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Análise de Formas Modais a partir de Dados Multiplos",
                                  "subSteps": [
                                    "Coletar espectros de múltiplos pontos de medição na estrutura.",
                                    "Aplicar método de função de transferência (FRF) ou phase resonance para modos.",
                                    "Estimar formas modais via polyreference least-squares (pLSFD) ou peak-picking.",
                                    "Animar formas modais usando software para visualização.",
                                    "Calcular MAC (Modal Assurance Criterion) para validar ortogonalidade."
                                  ],
                                  "verification": "Formas modais animadas mostram deflexões coerentes com física esperada.",
                                  "estimatedTime": "40-60 minutos",
                                  "materials": "Dados multi-canais, toolbox modal (MATLAB Vibrationdata ou Python modalsim).",
                                  "tips": "Use pelo menos 10 DOFs para formas modais precisas.",
                                  "learningObjective": "Identificar e visualizar modos de vibração da estrutura.",
                                  "commonMistakes": "Ignorar fase, levando a formas modais invertidas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validação e Relatório de Resultados",
                                  "subSteps": [
                                    "Comparar frequências e formas com simulações FEM ou teoria.",
                                    "Calcular erros percentuais e MAC > 0.9 para modos correlacionados.",
                                    "Documentar limitações como ruído ou excitação inadequada.",
                                    "Gerar relatório com plots, tabelas de frequências e animações.",
                                    "Sugerir melhorias para testes futuros."
                                  ],
                                  "verification": "Relatório completo com validação quantitativa (erros <5%).",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": "Templates de relatório, software de plot (Matplotlib/Plotly).",
                                  "tips": "Sempre inclua uncertainty quantification nos picos.",
                                  "learningObjective": "Validar e comunicar resultados de análise modal.",
                                  "commonMistakes": "Não validar com múltiplas excitações, superestimando confiança."
                                }
                              ],
                              "practicalExample": "Em um ensaio de vibração de uma asa de modelo reduzido de aeronave, adquira dados de 8 acelerômetros durante excitação com martelo. Pré-processe, aplique FFT, identifique picos em 15Hz (torção) e 25Hz (flexão), e extraia formas modais mostrando deflexão assimétrica na torção.",
                              "finalVerifications": [
                                "Picos de frequência identificados com precisão <2% vs. referência.",
                                "Formas modais visualizadas e validadas por MAC >0.9.",
                                "Espectros limpos sem artefatos de pré-processamento.",
                                "Relatório inclui plots, tabelas e interpretações físicas.",
                                "Resultados reproduzíveis em reexecução do código.",
                                "Limitações documentadas (ex: ruído ambiente)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de pelo menos 3 picos modais principais.",
                                "Qualidade do pré-processamento (ausência de vazamento espectral).",
                                "Correção na extração e visualização de formas modais.",
                                "Uso adequado de thresholds e validações quantitativas.",
                                "Clareza e completude do relatório final.",
                                "Eficiência computacional e código comentado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de transformadas de Fourier e análise harmônica.",
                                "Programação: Implementação numérica em Python/MATLAB para processamento de sinais.",
                                "Física: Dinâmica de vibrações e princípios de ressonância modal.",
                                "Engenharia Computacional: Modelagem FEM para validação.",
                                "Estatística: Análise de incerteza em detecção de picos."
                              ],
                              "realWorldApplication": "Em indústrias aeroespaciais, como na certificação de aeronaves pela FAA/EASA, processar sinais de vibração identifica modos críticos de flutter, prevenindo falhas catastróficas em voo, como no caso do Lockheed Electra."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.3.1.3.2",
                            "name": "Identificar frequências e amortecimentos naturais",
                            "description": "Extrair frequências naturais, razões de amortecimento e formas modais usando métodos como circle fit ou least-squares em funções de FRF (Frequency Response Functions).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparação e Pré-processamento dos Dados de FRF",
                                  "subSteps": [
                                    "Coletar dados de FRF de ensaios de vibração experimental, incluindo magnitude e fase em função da frequência.",
                                    "Aplicar filtros para remover ruído e outliers dos dados.",
                                    "Identificar picos ressonantes nos gráficos de FRF para regiões de interesse.",
                                    "Normalizar os dados e plotar magnitude e Nyquist para visualização.",
                                    "Segmentar os dados em janelas ao redor de cada modo esperado."
                                  ],
                                  "verification": "Gráficos limpos de FRF com picos claros identificados e sem artefatos visíveis.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Software MATLAB ou Python (SciPy, NumPy), dados FRF reais ou simulados.",
                                  "tips": "Use janelas Hanning para reduzir vazamento espectral durante o pré-processamento.",
                                  "learningObjective": "Compreender a importância da qualidade dos dados para identificação modal precisa.",
                                  "commonMistakes": "Ignorar ruído alto, levando a picos falsos; não segmentar corretamente as regiões modais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicação do Método Circle Fit",
                                  "subSteps": [
                                    "Plotar o diagrama de Nyquist (real vs. imaginário) para a região do modo alvo.",
                                    "Ajustar um círculo aos pontos de Nyquist próximos à ressonância usando regressão circular.",
                                    "Calcular o centro do círculo (frequência natural ω_n) e o raio relacionado ao amortecimento.",
                                    "Extrair a razão de amortecimento ζ como ζ = r / |centro|.",
                                    "Validar o ajuste pelo coeficiente de correlação R² > 0.95."
                                  ],
                                  "verification": "Círculo ajustado sobreposto ao Nyquist com bom encaixe visual e R² alto.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": "Script MATLAB/Python com função circle_fit, dados Nyquist.",
                                  "tips": "Selecione pontos simétricos acima e abaixo da frequência ressonante para melhor precisão.",
                                  "learningObjective": "Dominar o método geométrico Circle Fit para extração rápida de parâmetros modais.",
                                  "commonMistakes": "Incluir pontos fora da região ressonante, distorcendo o centro do círculo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicação do Método Least-Squares",
                                  "subSteps": [
                                    "Modelar a FRF como soma de termos modais: H(ω) = Σ [A_r / (ω_n² - ω² + i 2 ζ ω_n ω)].",
                                    "Linearizar o modelo para forma adequada ao least-squares.",
                                    "Definir matriz de design com colunas para cada parâmetro modal e resolver sistema Ax = b.",
                                    "Otimizar parâmetros iniciais com Circle Fit e refinar iterativamente.",
                                    "Calcular resíduos e verificar convergência (resíduos < 5% da amplitude)."
                                  ],
                                  "verification": "Parâmetros extraídos com resíduos baixos e convergência do algoritmo.",
                                  "estimatedTime": "4-5 horas",
                                  "materials": "Biblioteca lsqnonlin (MATLAB) ou curve_fit (SciPy), modelo modal implementado.",
                                  "tips": "Use gradientes numéricos para otimização não linear se analíticos forem complexos.",
                                  "learningObjective": "Implementar otimização least-squares para identificação modal multi-modo.",
                                  "commonMistakes": "Maus valores iniciais causando convergência para mínimo local; superparametrização."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Extração de Formas Modais e Validação",
                                  "subSteps": [
                                    "Calcular resíduos de Driving Point e usar para estimar formas modais φ via MAC (Modal Assurance Criterion).",
                                    "Comparar frequências e amortecimentos de Circle Fit vs. Least-Squares.",
                                    "Plotar síntese da FRF com parâmetros extraídos e sobrepor aos dados reais.",
                                    "Verificar estabilidade modal e ausência de modos espúrios.",
                                    "Documentar discrepâncias e ajustar se necessário."
                                  ],
                                  "verification": "Síntese da FRF coincide com dados originais (erro < 10%) e MAC > 0.9 entre métodos.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Funções MAC e síntese FRF em MATLAB/Python.",
                                  "tips": "Normalize formas modais pela massa para consistência entre pontos de medição.",
                                  "learningObjective": "Integrar extração de formas modais e validar resultados multi-método.",
                                  "commonMistakes": "Não normalizar formas modais, levando a incoerências; ignorar modos próximos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Relatório e Análise Final",
                                  "subSteps": [
                                    "Compilar tabela com ω_n, ζ e φ para cada modo identificado.",
                                    "Discutir incertezas e sensibilidade a ruído.",
                                    "Comparar com resultados teóricos ou FEM.",
                                    "Preparar relatório com gráficos e conclusões.",
                                    "Sugestir melhorias para ensaios futuros."
                                  ],
                                  "verification": "Relatório completo com tabelas, gráficos e análise quantitativa.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": "Ferramentas de edição (Word, LaTeX), software de plotagem.",
                                  "tips": "Use tabelas padronizadas para facilitar comparação entre métodos.",
                                  "learningObjective": "Sintetizar resultados modais em relatório profissional.",
                                  "commonMistakes": "Omitir quantificação de erros; conclusões sem base em verificações."
                                }
                              ],
                              "practicalExample": "Em um ensaio de vibração de uma asa de UAV, use FRF medida em 10 acelerômetros para identificar o primeiro modo de flexão torcional: extraia ω_n ≈ 15 Hz e ζ ≈ 0.02 via Circle Fit no ponto raiz da asa, valide com Least-Squares em múltiplos pontos e confirme forma modal com MAC > 0.95.",
                              "finalVerifications": [
                                "Frequências naturais extraídas coincidem entre Circle Fit e Least-Squares (diferença < 1%).",
                                "Razões de amortecimento consistentes (variação < 5%) e realistas para estruturas aeroespaciais.",
                                "Formas modais com MAC > 0.9 entre pontos de medição.",
                                "Síntese FRF reproduz dados reais com erro médio < 5%.",
                                "Ausência de modos espúrios ou resíduos altos.",
                                "Documentação completa com gráficos Nyquist e resíduos."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos parâmetros modais extraídos (erro < 2% vs. referência).",
                                "Qualidade da implementação dos métodos Circle Fit e Least-Squares.",
                                "Validação adequada com MAC, resíduos e síntese FRF.",
                                "Identificação correta de erros comuns e mitigação.",
                                "Relatório claro, com análise quantitativa e visualizações.",
                                "Tempo de execução eficiente e código reutilizável."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Ajuste de curvas não lineares e otimização least-squares.",
                                "Programação: Implementação numérica em Python/MATLAB para análise de sinais.",
                                "Física: Teoria de vibrações e dinâmica linear de sistemas multi-graus de liberdade.",
                                "Engenharia Aeroespacial: Integração com simulações FEM para certificação estrutural."
                              ],
                              "realWorldApplication": "Em certificação de aeronaves, identifica modos críticos para prevenção de flutter aeroelástico, otimizando design de asas e hélices em empresas como Embraer ou Boeing, reduzindo riscos de falha vibracional em voo."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.3.1.3.3",
                            "name": "Validar modelo experimental com analítico",
                            "description": "Comparar resultados experimentais de ensaios com previsões de modelos finitos ou modais, calculando MAC (Modal Assurance Criterion) para correlação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os Dados Experimentais e Analíticos",
                                  "subSteps": [
                                    "Coletar dados experimentais de frequências naturais, formas modais e amortecimentos de ensaios de vibração.",
                                    "Obter previsões analíticas do modelo finito de elementos (FEM) ou análise modal, incluindo frequências e vetores de modo.",
                                    "Normalizar todos os vetores de modo (experimental e analítico) para amplitude unitária máxima.",
                                    "Verificar consistência de unidades, malha de medição e condições de contorno entre dados.",
                                    "Exportar dados para formato comum (ex: MATLAB .mat ou CSV)."
                                  ],
                                  "verification": "Dados normalizados e pareados salvos em arquivo único, com resumo de estatísticas básicas (média, desvio padrão de frequências).",
                                  "estimatedTime": "2 horas",
                                  "materials": "Dados de ensaios experimentais, software FEM (ANSYS, Abaqus ou NASTRAN), MATLAB/Python com bibliotecas NumPy/SciPy.",
                                  "tips": "Use normalização MAC-específica (deslocamento máximo = 1) para evitar viéses de escala.",
                                  "learningObjective": "Compreender a preparação crítica de dados para garantir comparações válidas entre experimento e análise.",
                                  "commonMistakes": "Esquecer normalização levando a MAC artificialmente baixo; ignorar diferenças em malha de nós."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Parear Modos Correspondentes",
                                  "subSteps": [
                                    "Listar frequências experimentais e analíticas em ordem crescente.",
                                    "Parear modos com frequências próximas (critério: diferença < 5-10% ou frequência mais próxima).",
                                    "Visualizar formas modais lado a lado para confirmação qualitativa (plots de deformação).",
                                    "Criar tabela de pareamento com IDs de modos, frequências e razões de frequência.",
                                    "Excluir modos não correlacionados ou ruidosos preliminarmente."
                                  ],
                                  "verification": "Tabela de pareamento completa com pelo menos 80% dos modos principais pareados e visualizações salvas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Software de plotagem (MATLAB, Python Matplotlib), dados preparados do Step 1.",
                                  "tips": "Comece com modos de baixa frequência, que são mais confiáveis experimentalmente.",
                                  "learningObjective": "Desenvolver habilidade em reconhecimento visual e quantitativo de modos correlacionados.",
                                  "commonMistakes": "Parear incorretamente modos anti-simétricos com simétricos; ignorar modos locais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o Critério de Garantia Modal (MAC)",
                                  "subSteps": [
                                    "Implementar fórmula MAC: MAC_{ij} = |φ_exp_i^T φ_an_j|^2 / (‖φ_exp_i‖^2 ‖φ_an_j‖^2), onde φ são vetores de modo.",
                                    "Computar MAC para todos os pares de modos (matriz completa NxN).",
                                    "Gerar plot da matriz MAC (heatmap) destacando diagonal principal.",
                                    "Calcular MAC médio e máximo para modos pareados.",
                                    "Validar implementação com caso teste conhecido (MAC=1 para modos idênticos)."
                                  ],
                                  "verification": "Matriz MAC gerada, plotada e salva, com valores diagonais principais > 0.8.",
                                  "estimatedTime": "2 horas",
                                  "materials": "MATLAB/Python (bibliotecas NumPy, SciPy para produto escalar e normas), dados pareados.",
                                  "tips": "Use vetores complexos se houver fase; evite loops ineficientes com operações matriciais.",
                                  "learningObjective": "Dominar o cálculo numérico do MAC e sua interpretação como métrica de correlação modal.",
                                  "commonMistakes": "Erro na fórmula (esquecer quadrado ou normalização); usar normas L1 em vez de L2."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Resultados, Interpretar e Documentar",
                                  "subSteps": [
                                    "Avaliar MAC: excelente (>0.95), bom (0.9-0.95), aceitável (0.8-0.9), ruim (<0.8).",
                                    "Comparar quantitativamente frequências (erro %) e amortecimentos.",
                                    "Identificar discrepâncias: atribuir a incertezas experimentais, malha FEM grosseira ou condições de contorno.",
                                    "Gerar relatório com tabelas, plots MAC, gráficos de Campbell e recomendações.",
                                    "Sugerir iterações no modelo analítico se correlação insuficiente."
                                  ],
                                  "verification": "Relatório finalizado com conclusões claras, métricas resumidas e arquivos de suporte anexados.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Software de relatório (Word, LaTeX, Jupyter Notebook), todos os outputs anteriores.",
                                  "tips": "Inclua autoMAC (MAC de modos experimentais consigo mesmos) como benchmark (>0.98).",
                                  "learningObjective": "Integrar análise quantitativa e qualitativa para validar modelos e propor melhorias.",
                                  "commonMistakes": "Superestimar correlação ignorando off-diagonais altos; não quantificar erros de frequência."
                                }
                              ],
                              "practicalExample": "Em um ensaio de vibração modal de uma viga cantilever simulando uma longarina de asa, compare os primeiros 6 modos experimentais (obtidos via acelerômetros) com o modelo FEM no ANSTRAN. Calcule MAC resultando em valores diagonais >0.92, confirmando erro de frequência <5% e validando o modelo para análise aeroelástica subsequente.",
                              "finalVerifications": [
                                "MAC médio dos modos principais > 0.90.",
                                "Erro relativo de frequências < 10% para todos os modos pareados.",
                                "Matriz MAC com off-diagonais < 0.1, indicando pareamento único.",
                                "Formas modais visualmente correlacionadas em pelo menos 90% dos DOFs.",
                                "Relatório com todas as métricas documentadas e plots legíveis.",
                                "Identificação de pelo menos uma causa potencial para qualquer discrepância."
                              ],
                              "assessmentCriteria": [
                                "Precisão e correção no cálculo da matriz MAC (verificação com casos teste).",
                                "Qualidade do pareamento de modos (visual e quantitativo).",
                                "Profundidade da análise de discrepâncias e interpretações.",
                                "Clareza e completude do relatório final com visualizações.",
                                "Eficiência no uso de tempo e recursos computacionais.",
                                "Incorporação de verificações adicionais como autoMAC."
                              ],
                              "crossCurricularConnections": [
                                "Estatística e Probabilidade: Métricas de correlação e análise de matrizes.",
                                "Programação Computacional: Implementação numérica em MATLAB/Python.",
                                "Mecânica dos Materiais: Fundamentos de modelagem FEM e propriedades dinâmicas.",
                                "Engenharia de Controle: Validação para sistemas de controle ativo.",
                                "Gestão de Projetos: Documentação e iteração em validações experimentais."
                              ],
                              "realWorldApplication": "Na certificação de aeronaves pela ANAC/FAA, essa validação correlaciona modelos FEM com testes modais em bancada para prever flutter aeroelástico, reduzindo riscos em protótipos e otimizando designs de asas e fuselagens em empresas como Embraer ou Boeing."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "57.3.1.3.4",
                            "name": "Avaliar incertezas e repetibilidade",
                            "description": "Realizar testes repetidos para quantificar variabilidade, erros de medição e confiabilidade dos resultados modais em contextos aeroespaciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Planejamento dos Testes Repetidos",
                                  "subSteps": [
                                    "Definir os parâmetros modais de interesse (ex.: frequências, modos de amortecimento).",
                                    "Determinar o número de repetições (mínimo 10-20 para estatística robusta).",
                                    "Especificar condições de teste idênticas (excitação, suporte, ambiente).",
                                    "Planejar aquisição de dados e critérios de aceitação de testes válidos.",
                                    "Documentar o protocolo experimental em um plano escrito."
                                  ],
                                  "verification": "Protocolo escrito aprovado com todos os parâmetros definidos e justificados.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Folha de cálculo ou software de planejamento (Excel), estrutura de teste aeroespacial.",
                                  "tips": "Use o método de Monte Carlo para simular o número ótimo de repetições antecipadamente.",
                                  "learningObjective": "Compreender como planejar experimentos para minimizar vieses e maximizar repetibilidade.",
                                  "commonMistakes": "Subestimar o número de repetições, levando a estatísticas não confiáveis; ignorar variações ambientais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Execução dos Testes Repetidos",
                                  "subSteps": [
                                    "Configurar o sistema de medição (acelerômetros, excitador, DAQ).",
                                    "Realizar excitações idênticas (ex.: martelo instrumentado ou shaker) múltiplas vezes.",
                                    "Registrar dados brutos para cada repetição, incluindo metadados (temperatura, umidade).",
                                    "Verificar integridade dos sinais em tempo real (sem clipping ou ruído excessivo).",
                                    "Pausar entre repetições para resetar o sistema e evitar fadiga."
                                  ],
                                  "verification": "Registro de pelo menos 10 repetições válidas com sinais limpos confirmados via visualização rápida.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": "Acelerômetros, excitador de vibração, sistema DAQ (ex.: NI LabVIEW), estrutura de teste (viga ou asa modelo).",
                                  "tips": "Padronize a posição exata do impacto para consistência; grave vídeo para auditoria.",
                                  "learningObjective": "Executar medições precisas e repetíveis em contextos experimentais aeroespaciais.",
                                  "commonMistakes": "Variações na força ou localização da excitação; não registrar condições ambientais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Coleta e Pré-processamento de Dados",
                                  "subSteps": [
                                    "Importar dados brutos para software de análise (MATLAB, Python com SciPy).",
                                    "Aplicar filtros (anti-aliasing, remoção de trend) e janelamento (Hanning).",
                                    "Extrair parâmetros modais via FFT ou métodos de identificação (ex.: Peak Picking).",
                                    "Organizar dados em tabela: repetição vs. frequência/amortecimento estimado.",
                                    "Identificar e descartar outliers iniciais com critério estatístico (ex.: 3σ)."
                                  ],
                                  "verification": "Tabela de dados pré-processados com parâmetros modais extraídos para todas repetições.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": "Software de análise (MATLAB, Python), computador com capacidade de processamento.",
                                  "tips": "Automatize o pré-processamento com scripts para evitar erros manuais.",
                                  "learningObjective": "Preparar dados experimentais para análise estatística confiável.",
                                  "commonMistakes": "Filtros inadequados que distorcem modais; não tratar outliers corretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Cálculo de Estatísticas de Incerteza e Repetibilidade",
                                  "subSteps": [
                                    "Calcular estatísticas descritivas: média, desvio padrão (σ), coeficiente de variação (CV = σ/μ * 100%).",
                                    "Determinar intervalos de confiança (ex.: 95% via t-Student).",
                                    "Quantificar erros de medição (bias, precisão) e propagação de incertezas.",
                                    "Gerar gráficos: histogramas, boxplots, dispersão temporal.",
                                    "Comparar repetibilidade entre modos (ex.: CV < 5% para boa repetibilidade)."
                                  ],
                                  "verification": "Relatório com tabelas e gráficos de estatísticas, incluindo CV e intervalos de confiança.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Software estatístico (Python com NumPy/Pandas/Matplotlib, MATLAB Statistics Toolbox).",
                                  "tips": "Use bootstrapping para estimativas robustas de incerteza em amostras pequenas.",
                                  "learningObjective": "Aplicar ferramentas estatísticas para quantificar variabilidade em resultados modais.",
                                  "commonMistakes": "Confundir desvio padrão com erro padrão; ignorar normalidade dos dados."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretação e Relatório dos Resultados",
                                  "subSteps": [
                                    "Avaliar confiabilidade: classificar repetibilidade (boa/excelente se CV < 2-5%).",
                                    "Discutir fontes de variabilidade (ruído, não-linearidades, setup).",
                                    "Recomendar melhorias experimentais baseadas nos achados.",
                                    "Redigir relatório com conclusões, gráficos e sugestões para uso em modelos.",
                                    "Validar contra normas aeroespaciais (ex.: AIAA, NASA standards)."
                                  ],
                                  "verification": "Relatório final com interpretação clara e recomendações acionáveis.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Editor de texto/LaTeX para relatório, normas técnicas (PDFs).",
                                  "tips": "Relacione incertezas a impactos em análises de flutter ou fadiga.",
                                  "learningObjective": "Interpretar resultados estatísticos no contexto de engenharia aeroespacial.",
                                  "commonMistakes": "Superestimar confiabilidade sem considerar fontes sistemáticas de erro."
                                }
                              ],
                              "practicalExample": "Em um ensaio de vibração modal em uma viga cantilever simulando uma asa de UAV, realize 15 excitações com martelo instrumentado no mesmo ponto. Extraia as 3 primeiras frequências modais de cada teste, calcule CV médio de 1.2% para o 1º modo, identificando variabilidade devido a ruído de sensor, e conclua alta repetibilidade para uso em simulações CFD.",
                              "finalVerifications": [
                                "Coeficiente de variação (CV) calculado corretamente para todos parâmetros modais.",
                                "Intervalos de confiança de 95% reportados com justificativa do método.",
                                "Gráficos de repetibilidade (boxplot/histograma) gerados e interpretados.",
                                "Fontes de incerteza identificadas e quantificadas.",
                                "Conclusão sobre confiabilidade dos resultados modais alinhada com normas.",
                                "Relatório com todas estatísticas e recomendações."
                              ],
                              "assessmentCriteria": [
                                "Precisão e correção nos cálculos estatísticos (média, σ, CV, IC).",
                                "Qualidade do pré-processamento e tratamento de dados (sem artefatos evidentes).",
                                "Profundidade na identificação de fontes de variabilidade e erros.",
                                "Clareza e completude do relatório com visualizações eficazes.",
                                "Aplicação contextualizada a cenários aeroespaciais reais.",
                                "Uso adequado de software e normas técnicas."
                              ],
                              "crossCurricularConnections": [
                                "Estatística e Probabilidade: Cálculo de variância e testes de hipótese.",
                                "Análise de Dados e Programação: Uso de Python/MATLAB para automação.",
                                "Física e Mecânica: Entendimento de vibrações e propagação de erros.",
                                "Gestão da Qualidade: Normas ISO para metrologia experimental.",
                                "Engenharia de Software: Validação numérica de resultados experimentais."
                              ],
                              "realWorldApplication": "Na indústria aeroespacial, essa habilidade é essencial para certificar estruturas contra flutter (ex.: testes em túneis de vento na Boeing ou Embraer), quantificando incertezas em modelos modais para previsões confiáveis de fadiga e vida útil, evitando falhas catastróficas como no caso do Aloha Airlines 243."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.2",
                    "name": "Aeroelasticidade de Placas e Cascas",
                    "description": "Análise dos fenômenos aeroelásticos em placas e cascas de estruturas aeroespaciais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.2.1",
                        "name": "Modelagem Dinâmica de Placas e Cascas",
                        "description": "Desenvolvimento de modelos matemáticos para descrever o comportamento dinâmico de placas e cascas sob carregamentos aeroelásticos, utilizando equações de Lagrange, Princípio de Hamilton e métodos de elementos finitos.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.1.1",
                            "name": "Derivação de Equações de Movimento para Placas",
                            "description": "Aplicar princípios variacionais para derivar as equações diferenciais de movimento de placas retangulares e circulares sujeitas a forças aerodinâmicas, considerando teoria de Kirchhoff e Reissner-Mindlin.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão dos Princípios Variacionais e Formulação Energética Básica",
                                  "subSteps": [
                                    "Estudar o Princípio de Hamilton e o princípio dos trabalhos virtuais para sistemas contínuos.",
                                    "Revisar a expressão geral da energia cinética T e potencial U para placas.",
                                    "Identificar a ação funcional S = ∫ (T - U) dt para derivação variacional.",
                                    "Exercitar derivação da equação de Euler-Lagrange para campos escalares e vetoriais.",
                                    "Aplicar variações δw para deslocamentos transversais em placas."
                                  ],
                                  "verification": "Derivar corretamente a equação de Euler-Lagrange para uma corda vibrante como teste preliminar.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Livro 'Theory of Plates' de Timoshenko",
                                    "Notas de cálculo variacional",
                                    "Software SymPy ou Mathematica"
                                  ],
                                  "tips": "Comece com sistemas discretos (massa-mola) para intuitar a transição para contínuos.",
                                  "learningObjective": "Dominar os princípios variacionais aplicados a sistemas deformáveis contínuos.",
                                  "commonMistakes": [
                                    "Confundir variações δq com velocidades ∂q/∂t",
                                    "Esquecer termos de inércia rotacional"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelagem Cinemática e Geométrica de Placas Retangulares e Circulares",
                                  "subSteps": [
                                    "Definir coordenadas locais (x,y,z) e variáveis de deformação: w(x,y,t) para Kirchhoff (thin plates).",
                                    "Introduzir rotações θx, θy para teoria Reissner-Mindlin (shear deformável).",
                                    "Estabelecer condições de contorno para placas retangulares (simplesmente apoiada, engastada).",
                                    "Adaptar para geometria circular usando coordenadas polares (r,θ).",
                                    "Calcular tensões e deformações via relações constitutivas isotrópicas."
                                  ],
                                  "verification": "Esboçar os campos de deslocamento e plotar deformações para uma placa unitária.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Artigos sobre teoria de placas Kirchhoff e Mindlin",
                                    "MATLAB para visualização de malhas"
                                  ],
                                  "tips": "Use diagramas esquemáticos para visualizar cisalhamento em placas espessas.",
                                  "learningObjective": "Modelar precisamente a cinemática de placas considerando espessura e geometria.",
                                  "commonMistakes": [
                                    "Negligenciar rotações independentes em Reissner-Mindlin",
                                    "Erro em transformação polar para circulares"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formulação das Energias Cinética, Potencial e Trabalho Externo",
                                  "subSteps": [
                                    "Expressar energia cinética T ∫ ρ h (ẇ² + rotações) dA para ambas as teorias.",
                                    "Derivar energia de deformação U com momentos fletivos M e forças cisalhantes Q.",
                                    "Incluir trabalho virtual de forças aerodinâmicas p(x,y,t) como δW = ∫ p δw dA.",
                                    "Linearizar para pequenas deformações e obter funcional total.",
                                    "Verificar dimensionalidade e unidades em todas as expressões."
                                  ],
                                  "verification": "Calcular numericamente T e U para uma placa deformada conhecida e comparar com analítico.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Tabelas de propriedades de materiais aeroespaciais",
                                    "Python com NumPy para integrais"
                                  ],
                                  "tips": "Integre por partes para simplificar expressões de energia de borda.",
                                  "learningObjective": "Construir o funcional variacional completo incluindo aerodinâmica.",
                                  "commonMistakes": [
                                    "Omitir termos de inércia rotacional em Mindlin",
                                    "Erro de sinal no trabalho externo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivação das Equações Diferenciais de Movimento",
                                  "subSteps": [
                                    "Aplicar δS = 0 levando a equações de Kirchhoff: D ∇⁴w + ρ h ẅ = p.",
                                    "Estender para Reissner-Mindlin: equações acopladas para w, θx, θy.",
                                    "Derivar condições de borda naturais via termos de superfície.",
                                    "Comparar equações para placas retangulares vs. circulares (operador de Laplace polar).",
                                    "Validar com casos limite (estática, sem cisalhamento)."
                                  ],
                                  "verification": "Resolver numericamente uma equação derivada e comparar com solução exata conhecida.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Referências como 'Vibration of Plates' de Leissa",
                                    "Software FEM como ANSYS para validação"
                                  ],
                                  "tips": "Use simetria para reduzir ordem em placas circulares.",
                                  "learningObjective": "Derivar e interpretar as EDOs governantes para dinâmica aeroelástica.",
                                  "commonMistakes": [
                                    "Erro em operadores diferenciais de quarta ordem",
                                    "Confusão entre condições essenciais e naturais"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validação e Análise de Sensibilidade às Forças Aerodinâmicas",
                                  "subSteps": [
                                    "Incorporar modelos de pressão aerodinâmica (piston theory ou quasi-steady).",
                                    "Analisar estabilidade via linearização e autovalores.",
                                    "Testar convergência Kirchhoff vs. Mindlin para diferentes espessuras.",
                                    "Simular resposta transitória a pulso aerodinâmico.",
                                    "Documentar derivações em relatório com equações finais."
                                  ],
                                  "verification": "Gráficos de modos de vibração coincidem com literatura (e.g., frequências fundamentais).",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Códigos de exemplo em MATLAB para aeroelasticidade",
                                    "Dados experimentais de túneis de vento"
                                  ],
                                  "tips": "Comece com cargas uniformes antes de distribuídas.",
                                  "learningObjective": "Validar modelo dinâmico em contexto aeroelástico real.",
                                  "commonMistakes": [
                                    "Subestimar efeitos de cisalhamento em placas espessas",
                                    "Ignorar acoplamento fluido-estrutura"
                                  ]
                                }
                              ],
                              "practicalExample": "Derive as equações de movimento para uma placa retangular de alumínio (a=1m, b=0.5m, h=0.01m) engastada em três bordas, sujeita a pressão aerodinâmica sinusoidal p(x,y,t)=p0 sin(πx/a) cos(πy/b) sin(ωt), usando Reissner-Mindlin, e compute as frequências naturais dos primeiros três modos.",
                              "finalVerifications": [
                                "Equações de Kirchhoff reduzem corretamente para o caso thin-plate clássico.",
                                "Termos de cisalhamento aparecem explicitamente em Mindlin.",
                                "Condições de borda derivadas coincidem com fórmulas padrão.",
                                "Frequências calculadas para placa livre batem com tabelas de Leissa (±5%).",
                                "Resposta a carga aerodinâmica mostra amortecimento fluido-estrutura.",
                                "Derivação em coordenadas polares é consistente para disco circular."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática na derivação variacional (sem erros algébricos).",
                                "Correta inclusão de todos os termos cinéticos e potenciais.",
                                "Interpretação física das equações resultantes.",
                                "Validação quantitativa com casos analíticos conhecidos.",
                                "Clareza na documentação de passos e suposições.",
                                "Análise de limitações (e.g., linearidade, isotropia)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo variacional e PDEs elípticas.",
                                "Física: Mecânica dos contínuos e dinâmica de fluidos (aerodinâmica).",
                                "Computação: Programação simbólica (SymPy) e simulações numéricas (FEM).",
                                "Engenharia: Análise estrutural e controle de vibrações.",
                                "Química dos Materiais: Propriedades anisotrópicas de compósitos aeroespaciais."
                              ],
                              "realWorldApplication": "Modelagem de painéis de fuselagem ou asas de aeronaves para prever flutter aeroelástico em voo supersônico, essencial para certificação de segurança em projetos da Embraer ou Boeing, evitando falhas catastróficas como no caso histórico do Tacoma Narrows."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.2",
                            "name": "Modelagem de Cascas Cilíndricas",
                            "description": "Formular modelos dinâmicos para cascas cilíndricas em estruturas aeroespaciais, incorporando efeitos de curvatura e carregamento pistônico e tangencial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisão de Fundamentos de Cascas Cilíndricas",
                                  "subSteps": [
                                    "Estude a geometria básica de cascas cilíndricas: raio R, espessura h, comprimento L.",
                                    "Revise teoria de placas e cascas de Kirchhoff-Love, focando em deformações de curvatura.",
                                    "Identifique coordenadas curvilíneas (axial x, circunferencial θ, radial z).",
                                    "Analise tensões e deformações iniciais em cascas sem carregamento.",
                                    "Compile propriedades materiais relevantes (E, ν, ρ) para aeroespaciais."
                                  ],
                                  "verification": "Resuma em um diagrama esquemático da casca com coordenadas e equações de deformação anotadas.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Livro 'Theory of Shells' de Niordson; software de desenho como Draw.io; calculadora simbólica (SymPy).",
                                  "tips": "Use analogias com tubos para visualizar curvatura.",
                                  "learningObjective": "Compreender geometria e teoria básica para modelagem dinâmica.",
                                  "commonMistakes": "Ignorar relação h/R <<1 para cascas finas; confundir coordenadas cartesianas com curvilíneas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formulação das Equações de Movimento com Efeitos de Curvatura",
                                  "subSteps": [
                                    "Derive o princípio de Hamilton para energia potencial e cinética da casca.",
                                    "Incorpore termos de curvatura nos strain-displacement relations (e.g., κ_θ = ∂²w/∂θ² / R²).",
                                    "Escreva equações diferenciais parciais (EDPs) para deslocamentos u, v, w.",
                                    "Aplique condições de contorno típicas (e.g., simply supported).",
                                    "Linearize para pequenas deformações."
                                  ],
                                  "verification": "Verifique dimensionalidade das EDPs e compare com equações de Donnell-Mushtari para validação.",
                                  "estimatedTime": "6 horas",
                                  "materials": "MATLAB ou Python (SymPy para derivação simbólica); paper 'Vibration of Cylindrical Shells'.",
                                  "tips": "Mantenha simetria axial para simplificar.",
                                  "learningObjective": "Derivar EDPs dinâmicas incorporando curvatura.",
                                  "commonMistakes": "Esquecer termos de acoplamento u-w devido à curvatura; erros em operadores diferenciais circunferenciais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporação de Carregamentos Pistônicos e Tangenciais",
                                  "subSteps": [
                                    "Defina carregamento pistônico como força axial N_x(t) variando no tempo.",
                                    "Modele carregamento tangencial como cisalhamento Q_θ ou momento M_θ.",
                                    "Adicione termos de forçamento nas EDPs: f_x para pistônico, f_θ para tangencial.",
                                    "Considere efeitos dinâmicos como ressonância sob carregamento harmônico.",
                                    "Implemente superposição para múltiplos carregamentos."
                                  ],
                                  "verification": "Simule resposta estática simples e compare com solução analítica conhecida.",
                                  "estimatedTime": "5 horas",
                                  "materials": "Software FEA como ANSYS ou Abaqus trial; equações de referência de Timoshenko.",
                                  "tips": "Use Fourier series para expansão circunferencial de carregamentos.",
                                  "learningObjective": "Integrar carregamentos reais nas equações dinâmicas.",
                                  "commonMistakes": "Confundir pistônico (axial) com tangencial (hoop); negligenciar inércia em carregamentos rápidos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discretização, Solução Numérica e Validação",
                                  "subSteps": [
                                    "Aplique método de elementos finitos (shell elements) ou expansão modal (Rayleigh-Ritz).",
                                    "Monte matrizes de massa [M], rigidez [K] e amortecimento [C].",
                                    "Resolva sistema dinâmico [M]{¨u} + [C]{˙u} + [K]{u} = {F(t)} numericamente.",
                                    "Execute simulações para modos de vibração e resposta transitória.",
                                    "Valide contra dados experimentais ou benchmarks."
                                  ],
                                  "verification": "Compare frequências naturais com fórmulas analíticas (e.g., f = (1/2π)√(k/m)).",
                                  "estimatedTime": "8 horas",
                                  "materials": "MATLAB PDE Toolbox ou NASTRAN; dados de benchmark de NASA reports.",
                                  "tips": "Use malha convergente: refine até erro <5%.",
                                  "learningObjective": "Implementar e validar modelo numérico completo.",
                                  "commonMistakes": "Malha grosseira causando modos espúrios; instabilidade numérica sem amortecimento."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Análise de Sensibilidade e Aeroelasticidade",
                                  "subSteps": [
                                    "Varie parâmetros (R/h, L/R) e analise impacto em frequências/modais.",
                                    "Incorpore acoplamento fluido-estrutura básico para aeroelasticidade.",
                                    "Avalie estabilidade sob carregamento pistônico (buckling dinâmico).",
                                    "Gere gráficos de modos e respostas.",
                                    "Documente limitações do modelo."
                                  ],
                                  "verification": "Produza relatório com plots e conclusões quantitativas.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Python (Matplotlib, SciPy); relatórios AIAA sobre cascas.",
                                  "tips": "Foco em modos breathing e beam-like.",
                                  "learningObjective": "Analisar comportamento aeroespacial real.",
                                  "commonMistakes": "Ignorar efeitos não-lineares em grandes amplitudes; superestimar rigidez."
                                }
                              ],
                              "practicalExample": "Modele uma casca cilíndrica representando a fuselagem de um míssil cruise: R=0.5m, h=0.005m, L=3m, sob carregamento pistônico harmônico de 10kN a 100Hz e tangencial de cisalhamento devido a manobras, simulando frequências de vibração e risco de flutter.",
                              "finalVerifications": [
                                "Equações derivadas coincidem com literatura padrão (erro <1%).",
                                "Frequências naturais convergem com refinamento de malha.",
                                "Resposta sob carregamento pistônico mostra amplificação ressonante esperada.",
                                "Modos de deformação visualmente corretos (circunferencial vs. axial).",
                                "Validação contra benchmark experimental: erro médio <10%.",
                                "Análise de sensibilidade identifica parâmetros críticos."
                              ],
                              "assessmentCriteria": [
                                "Completude das EDPs com todos termos de curvatura (obrigatório).",
                                "Precisão numérica: convergência demonstrada.",
                                "Inclusão correta de carregamentos dinâmicos.",
                                "Qualidade de visualizações e interpretação física.",
                                "Documentação clara com referências.",
                                "Criatividade em análise de sensibilidade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações diferenciais parciais e séries de Fourier.",
                                "Programação: Implementação numérica em MATLAB/Python.",
                                "Materiais: Seleção de compostos aeroespaciais (compósitos vs. alumínio).",
                                "Física: Dinâmica de vibrações e acoplamento fluido-estrutura.",
                                "Engenharia de Controle: Amortecimento ativo para supressão de vibrações."
                              ],
                              "realWorldApplication": "Em projetos de foguetes (e.g., tanques de propelente na SpaceX Falcon), modela vibrações induzidas por thrust pistônico para evitar falhas estruturais; em aeronaves, previne flutter em fuselagens sob cargas tangenciais de manobras."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.3",
                            "name": "Integração com Método de Elementos Finitos",
                            "description": "Discretizar placas e cascas usando elementos finitos para análise dinâmica aeroelástica, incluindo amortecimento de Rayleigh e coordenação modal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparação da Geometria e Escolha de Elementos Finitos",
                                  "subSteps": [
                                    "Defina a geometria da placa ou casca (dimensões, espessura, material).",
                                    "Selecione o tipo de elemento finito adequado (ex: Q4 para placas, shell elements para cascas).",
                                    "Gere a malha de discretização considerando refinamento para regiões críticas.",
                                    "Defina condições de contorno e cargas iniciais.",
                                    "Valide a malha quanto a qualidade e convergência."
                                  ],
                                  "verification": "Visualize a malha no software FEM e confirme ausência de elementos distorcidos.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Software FEM (ANSYS, Abaqus ou código Python com FEniCS), propriedades do material.",
                                  "tips": "Use malhas adaptativas para otimizar precisão sem excesso computacional.",
                                  "learningObjective": "Compreender como discretizar geometrias complexas para análise dinâmica.",
                                  "commonMistakes": "Malhas muito grosseiras levando a erros de convergência ou elementos invertidos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Montagem das Matrizes de Massa e Rigidez",
                                  "subSteps": [
                                    "Calcule as matrizes elementares de rigidez [K_e] usando funções de forma e integrais de Gauss.",
                                    "Calcule as matrizes elementares de massa [M_e] (consistente ou lobada).",
                                    "Monte as matrizes globais [K] e [M] via superposição.",
                                    "Aplique condições de contorno reduzindo as matrizes.",
                                    "Verifique simetria e positivos definitos das matrizes."
                                  ],
                                  "verification": "Execute eigenvalue solver para frequências naturais e compare com soluções analíticas.",
                                  "estimatedTime": "5-7 horas",
                                  "materials": "Código MATLAB/Python para montagem matricial, solver de autovalores.",
                                  "tips": "Use integração numérica de alta ordem para precisão em elementos curvos.",
                                  "learningObjective": "Dominar a formulação FEM para dinâmica estrutural de placas/cascas.",
                                  "commonMistakes": "Erros na transformação de coordenadas locais-globais para cascas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporação de Amortecimento Rayleigh e Coordenação Modal",
                                  "subSteps": [
                                    "Defina os coeficientes α e β para amortecimento Rayleigh: [C] = α[M] + β[K].",
                                    "Realize análise modal para obter modos e frequências naturais.",
                                    "Projete respostas dinâmicas nos modos principais via coordenação modal.",
                                    "Incorpore forças aeroelásticas nos modos coordenados.",
                                    "Ajuste número de modos para capturar pelo menos 99% da energia modal."
                                  ],
                                  "verification": "Confirme fatores de amortecimento modais entre 0.5-2% e compare curvas de resposta.",
                                  "estimatedTime": "6-8 horas",
                                  "materials": "Ferramentas de análise modal (MATLAB Vibration Toolbox), dados experimentais de amortecimento.",
                                  "tips": "Escolha α e β minimizando erro em frequências alvo de testes experimentais.",
                                  "learningObjective": "Integrar dissipação e redução modal em análises aeroelásticas.",
                                  "commonMistakes": "Sobrestimar modos levando a truncamento inadequado ou Rayleigh mal calibrado."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Análise Dinâmica Aeroelástica e Validação",
                                  "subSteps": [
                                    "Formule o problema dinâmico: [M]{¨q} + [C]{˙q} + [K]{q} = {F_aero}.",
                                    "Integre no tempo usando Newmark ou Wilson-theta para respostas transitórias.",
                                    "Inclua acoplamento fluido-estrutura via forças aerodinâmicas (ex: teoria de pistão).",
                                    "Analise estabilidade (flutter) via varredura de velocidade ou root locus.",
                                    "Valide com dados experimentais de vibração ou aeroelasticidade."
                                  ],
                                  "verification": "Gere gráficos de deslocamento temporal e diagramas de flutter, comparando com benchmarks.",
                                  "estimatedTime": "7-10 horas",
                                  "materials": "Solvers de integração temporal (ODE45 em MATLAB), dados aeroelásticos.",
                                  "tips": "Use passos de tempo adaptativos para capturar transientes aeroelásticos.",
                                  "learningObjective": "Realizar simulações completas de aeroelasticidade via FEM.",
                                  "commonMistakes": "Ignorar não-linearidades geométricas em grandes deslocamentos."
                                }
                              ],
                              "practicalExample": "Modelar uma placa retangular representando a pele de uma asa de aeronave: discretize com 100 elementos shell, aplique Rayleigh com α=0.1, β=0.001, realize análise modal até 20 modos, e simule resposta a rajada aerodinâmica, identificando velocidades críticas de flutter.",
                              "finalVerifications": [
                                "Matrizes [K], [M], [C] são simétricas e positivas definidas.",
                                "Frequências modais convergem com refinamento de malha (erro <5%).",
                                "Fator de amortecimento Rayleigh reproduz valores experimentais.",
                                "Coordenação modal captura >95% da resposta dinâmica.",
                                "Velocidade de flutter predita está dentro de 10% de dados reais.",
                                "Respostas transitórias estabilizam sem oscilações numéricas."
                              ],
                              "assessmentCriteria": [
                                "Precisão da discretização (convergência demonstrada).",
                                "Correta implementação de Rayleigh e modos coordenados.",
                                "Validação quantitativa com analítico/experimental.",
                                "Eficiência computacional (tempo de simulação razoável).",
                                "Interpretação física dos resultados aeroelásticos.",
                                "Relatório com gráficos e conclusões claras."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (autovalores), integração numérica.",
                                "Programação: Implementação numérica em Python/MATLAB.",
                                "Física: Teoria de vibrações e dinâmica não-linear.",
                                "Engenharia Aeroespacial: Aerodinâmica e testes de túnel de vento.",
                                "Computação Científica: Paralelização para malhas grandes."
                              ],
                              "realWorldApplication": "Análise de flutter em asas de aviões comerciais (ex: Boeing 787) ou painéis de satélites, prevendo instabilidades dinâmicas para certificação FAA/EASA e otimização de design estrutural."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.2",
                        "name": "Fenômenos Aeroelásticos em Placas e Cascas",
                        "description": "Análise dos principais fenômenos de instabilidade e resposta dinâmica induzidos por interação fluido-estrutura em placas e cascas aeroespaciais.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.2.1",
                            "name": "Análise de Divergência em Placas",
                            "description": "Calcular velocidades críticas de divergência estática em placas sob fluxo incompressível, utilizando teoria linearizada aerodinâmica de Theodorsen ou pistônica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Divergência Estática em Placas",
                                  "subSteps": [
                                    "Estudar definição de divergência estática como instabilidade aeroelástica onde deformação aumenta monotonicamente sob carga aerodinâmica.",
                                    "Revisar condições de equilíbrio estático e perda de rigidez efetiva.",
                                    "Analisar exemplos históricos de falhas por divergência em estruturas aeronáuticas.",
                                    "Identificar parâmetros chave: velocidade do fluxo, rigidez flexural, módulo de Young.",
                                    "Diferenciar divergência de flutter dinâmico."
                                  ],
                                  "verification": "Resumir em diagrama conceitual os mecanismos de divergência e listar 3 exemplos reais.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Aeroelasticidade (Bisplinghoff), notas de aula sobre estabilidade estrutural, software de desenho (ex: Draw.io)"
                                  ],
                                  "tips": "Visualize a placa como um sistema mola-massa com forças aerodinâmicas desestabilizadoras.",
                                  "learningObjective": "Entender conceitualmente a divergência estática e seus parâmetros governantes.",
                                  "commonMistakes": [
                                    "Confundir com instabilidades dinâmicas como flutter",
                                    "Ignorar dependência quadrática da velocidade do fluxo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar Teoria Clássica de Placas",
                                  "subSteps": [
                                    "Derivar equação de equilíbrio para placa retangular fina usando teoria de Kirchhoff.",
                                    "Calcular frequências naturais e modos de vibração para placa simplesmente apoiada.",
                                    "Implementar condições de contorno: bordas livres, engastadas ou apoiadas.",
                                    "Resolver equação diferencial ∂⁴w/∂x⁴ + 2∂⁴w/∂x²∂y² + ∂⁴w/∂y⁴ = p/D.",
                                    "Usar séries de Fourier para aproximação modal."
                                  ],
                                  "verification": "Derivar manualmente a equação de placa e calcular 1º modo para placa 1x1m.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro de Timoshenko 'Theory of Plates and Shells', MATLAB ou Python (SymPy para simbólico)",
                                    "Papel e calculadora"
                                  ],
                                  "tips": "Comece com placa retangular isotrópica para simplificar.",
                                  "learningObjective": "Dominar modelagem estrutural de placas para acoplamento aeroelástico.",
                                  "commonMistakes": [
                                    "Esquecer termos de cisalhamento em placas espessas",
                                    "Erros em condições de contorno"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar Teoria Aerodinâmica Linearizada (Theodorsen ou Pistônica)",
                                  "subSteps": [
                                    "Explicar teoria pistônica: forças aerodinâmicas proporcionais à derivada temporal da deformação.",
                                    "Derivar função de Theodorsen C(k) para fluxo incompressível 2D.",
                                    "Calcular coeficientes de sustentação L = q * S * C_L(α), com α efetiva.",
                                    "Adaptar para placas 3D usando teoria de painel de vórtices ou VLM.",
                                    "Comparar aproximações pistônica vs. Theodorsen em baixa frequência reduzida."
                                  ],
                                  "verification": "Plotar função de Theodorsen para k=0.1-1.0 usando código simples.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Artigo de Theodorsen (1935), Python/MATLAB com scipy para Hankel",
                                    "Tabelas de valores de C(k)"
                                  ],
                                  "tips": "Use aproximação de Kussner para simplificar inicialmente.",
                                  "learningObjective": "Aplicar lift aerodinâmico linearizado em superfícies oscilantes.",
                                  "commonMistakes": [
                                    "Usar teoria quasi-steady em regime não-estacionário",
                                    "Ignorar fase de C(k)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular Equação de Divergência para Placas",
                                  "subSteps": [
                                    "Acoplar equação estrutural com forças aerodinâmicas: [K - q A] {q} = 0.",
                                    "Derivar matriz aerodinâmica A para modos de placa usando Theodorsen.",
                                    "Definir velocidade crítica V_cr como autovalor onde det(K - ρ V² A) = 0.",
                                    "Linearizar para 1 modo dominante: V_cr = sqrt(K / (ρ A_{11})).",
                                    "Implementar em código para placa multimodal."
                                  ],
                                  "verification": "Derivar equação própria e resolver para placa unimodal.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Software NumPy/SciPy ou MATLAB, exemplos de código aeroelástico"
                                  ],
                                  "tips": "Normalizar modos para simplificar matriz A.",
                                  "learningObjective": "Formular e resolver problema de autovalores para V_cr.",
                                  "commonMistakes": [
                                    "Confundir ρ∞ com densidade estrutural",
                                    "Erros de sinal em forças desestabilizadoras"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Realizar Cálculos Numéricos e Análise de Sensibilidade",
                                  "subSteps": [
                                    "Configurar modelo numérico para placa real: dimensões, material (alumínio).",
                                    "Calcular V_cr para fluxo incompressível Mach=0.3.",
                                    "Variar parâmetros: razão aspecto, rigidez, Mach number.",
                                    "Validar contra soluções analíticas ou dados experimentais.",
                                    "Interpretar resultados: mapas de V_cr vs. parâmetros."
                                  ],
                                  "verification": "Gerar gráfico de V_cr vs. razão de aspecto e comparar com referência.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código Python completo, dados de referência de artigos",
                                    "GNUPlot ou Matplotlib"
                                  ],
                                  "tips": "Use truncamento modal (5-10 modos) para convergência.",
                                  "learningObjective": "Executar análise paramétrica e validar modelo.",
                                  "commonMistakes": [
                                    "Poucos modos levando a não-convergência",
                                    "Unidades inconsistentes (m/s vs. ft/s)"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma placa retangular de alumínio (1m x 0.5m, espessura 2mm, bordas livres) em fluxo axial de ar a ρ=1.225 kg/m³, calcular V_cr usando teoria de Theodorsen com 3 modos, obtendo V_cr ≈ 150 m/s, e plotar deformação no modo crítico.",
                              "finalVerifications": [
                                "Equação de divergência derivada corretamente com termos aerodinâmicos.",
                                "Cálculo de V_cr para exemplo prático coincide com valor analítico (±5%).",
                                "Análise de sensibilidade mostra dependência esperada em rigidez e AR.",
                                "Diagrama de deformação no modo crítico desenhado.",
                                "Código numérico roda sem erros e converge.",
                                "Comparação com teoria pistônica destaca diferenças."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação teórica (80% dos passos corretos).",
                                "Correção numérica de V_cr (erro <10%).",
                                "Qualidade da análise paramétrica (pelo menos 3 variáveis).",
                                "Clareza na interpretação física dos resultados.",
                                "Uso adequado de aproximações (Theodorsen vs. pistônica).",
                                "Documentação completa do código e gráficos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações diferenciais parciais e autovalores.",
                                "Física: Dinâmica de fluidos incompressíveis e teoria de vórtices.",
                                "Engenharia Mecânica: Análise de elementos finitos para placas.",
                                "Computação: Programação numérica em Python/MATLAB.",
                                "Engenharia Aeronáutica: Otimização de asas contra instabilidades."
                              ],
                              "realWorldApplication": "Projeto de painéis de asas e fuselagem em aeronaves comerciais (ex: Boeing 787) para evitar divergência em manobras de alta velocidade, ou hélices de turbinas eólicas offshore sob ventos fortes."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.2.2",
                            "name": "Flutter em Cascas",
                            "description": "Determinar condições de flutter oscilatório em cascas cilíndricas, resolvendo autovalores do sistema acoplado aeroelástico com base modal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Flutter e Aeroelasticidade em Cascas",
                                  "subSteps": [
                                    "Estude definições de flutter oscilatório e instabilidade aeroelástica em cascas cilíndricas.",
                                    "Revise teoria de cascas cilíndricas: equações de Donnell ou Love para deformações.",
                                    "Analise acoplamento fluido-estrutura em regimes supersônicos/subsonicos.",
                                    "Identifique modos modais relevantes (torção, flexão) para flutter.",
                                    "Compare flutter em placas vs. cascas cilíndricas."
                                  ],
                                  "verification": "Resuma em um diagrama os mecanismos de flutter em cascas e liste 3 diferenças chave com placas.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Livro 'Aeroelasticity' de Bisplinghoff",
                                    "Artigos sobre teoria de cascas (Donnell)",
                                    "Software MATLAB para visualização de modos"
                                  ],
                                  "tips": "Use animações de modos modais para visualizar acoplamentos.",
                                  "learningObjective": "Dominar conceitos básicos de flutter em cascas cilíndricas.",
                                  "commonMistakes": [
                                    "Confundir flutter com divergência",
                                    "Ignorar efeitos não-lineares iniciais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar Estrutura e Aerodinâmica de Cascas Cilíndricas",
                                  "subSteps": [
                                    "Derive equações de movimento estrutural baseadas em teoria de cascas finas.",
                                    "Implemente modelo aerodinâmico: teoria de pistão ou v2-g para forças fluidas.",
                                    "Defina parâmetros geométricos: raio R, espessura h, comprimento L da casca.",
                                    "Calcule frequências e modos modais naturais da casca livre.",
                                    "Incorpore condições de contorno (simplesmente apoiada ou engastada)."
                                  ],
                                  "verification": "Gere matriz de massas e rigidez para uma casca cilíndrica simples e plote 3 primeiros modos.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "MATLAB ou Python (NumPy/SciPy)",
                                    "Referência: 'Vibration of Shells' de Leissa",
                                    "Planilhas para parâmetros geométricos"
                                  ],
                                  "tips": "Comece com cascas curtas para simplificar cálculos modais.",
                                  "learningObjective": "Construir modelos matemáticos precisos para cascas.",
                                  "commonMistakes": [
                                    "Erro em coordenadas curvilíneas",
                                    "Negligenciar termos de curvatura"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular Sistema Acoplado Aeroelástico Modal",
                                  "subSteps": [
                                    "Expresse deslocamentos em base modal: u = Φ q, onde Φ são vetores modais.",
                                    "Derive equações acopladas: M ÿ + K y + Q_aero(λ) y = 0, com λ velocidade reduzida.",
                                    "Inclua matriz aerodinâmica dependente de Mach e ângulo de ataque.",
                                    "Linearize para análise harmônica: assuma y = y0 e^{iωt}.",
                                    "Monte matriz complexa do sistema para autovalores."
                                  ],
                                  "verification": "Escreva as equações acopladas para 2 modos e verifique dimensionalidade.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Código MATLAB para montagem de matrizes",
                                    "Papel 'Flutter of Cylindrical Shells' de Bolotin",
                                    "Calculadora simbólica (SymPy)"
                                  ],
                                  "tips": "Use expansão modal truncada (4-6 modos) para eficiência.",
                                  "learningObjective": "Formular corretamente o sistema aeroelástico acoplado.",
                                  "commonMistakes": [
                                    "Falta de acoplamento cruzado nos termos aerodinâmicos",
                                    "Erro na dependência de velocidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver Autovalores e Determinar Condições de Flutter",
                                  "subSteps": [
                                    "Implemente rotina numérica para autovalores complexos em função de V (velocidade).",
                                    "Identifique flutter pela coalescência de frequências reais e crescimento de parte imaginária.",
                                    "Calcule velocidade crítica de flutter V_f onde ω_r1 = ω_r2 e Im(ω) > 0.",
                                    "Varie parâmetros (Mach, h/R) e plote curvas V-g-ω.",
                                    "Valide com dados experimentais ou benchmarks literários."
                                  ],
                                  "verification": "Obtenha V_f para casca com R=0.5m, h=0.005m, L=2m e compare com valor teórico ~300m/s.",
                                  "estimatedTime": "7 horas",
                                  "materials": [
                                    "MATLAB eig() ou Python eigs()",
                                    "Dados experimentais de NASA/CR papers",
                                    "Gráficos V-g-flutter"
                                  ],
                                  "tips": "Use método de varredura (sweep) em velocidade para eficiência.",
                                  "learningObjective": "Determinar precisamente condições de flutter via autovalores.",
                                  "commonMistakes": [
                                    "Interpretação errada de autovalores coalescentes",
                                    "Escala numérica inadequada"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma casca cilíndrica de foguete (R=1m, h=3mm, L=5m) em fluxo Mach 2: monte modelo modal com 5 modos, resolva autovalores e encontre V_flutter = 450 m/s, plotando curvas de frequência vs. velocidade para prever instabilidade em reentrada atmosférica.",
                              "finalVerifications": [
                                "Curvas V-ω mostram coalescência de dois modos com Im(ω)>0.",
                                "Velocidade crítica coincide com benchmarks (±10%).",
                                "Matriz aerodinâmica varia corretamente com Mach.",
                                "Modos modais ploteados exibem deformações realistas de casca.",
                                "Análise paramétrica identifica sensibilidade a h/R."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação das equações acopladas (sem erros dimensionais).",
                                "Correta implementação e interpretação de autovalores complexos.",
                                "Qualidade dos gráficos V-g-ω-flutter.",
                                "Validação com literatura ou experimentos.",
                                "Capacidade de variar parâmetros e discutir impactos.",
                                "Clareza na documentação do código e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de autovalores e equações diferenciais parciais.",
                                "Física: Mecânica dos fluidos compressíveis e vibrações estruturais.",
                                "Engenharia Computacional: Programação numérica em MATLAB/Python.",
                                "Engenharia Aeroespacial: Design de painéis de aeronaves/foguetes."
                              ],
                              "realWorldApplication": "Previsão de flutter em fuselagens de aviões ou cascos de mísseis para evitar falhas catastróficas durante voo supersônico, como no design do Concorde ou boosters de foguetes SpaceX."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.2.3",
                            "name": "Resposta Dinâmica a Excitações Aeroelásticas",
                            "description": "Avaliar respostas transitórias e estacionárias de placas e cascas a excitações harmônicas e aleatórias de origem aeroelástica, incluindo isolamento de vibrações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Fundamentos Teóricos de Respostas Dinâmicas em Placas e Cascas",
                                  "subSteps": [
                                    "Revisar equações de movimento para placas e cascas sob carregamentos dinâmicos.",
                                    "Estudar diferenças entre respostas transitórias (não-estacionárias) e estacionárias.",
                                    "Analisar modos de vibração naturais e frequências ressonantes.",
                                    "Explorar efeitos aeroelásticos como acoplamento fluido-estrutura.",
                                    "Derivar equações modais para simplificação de análise."
                                  ],
                                  "verification": "Resumir em um diagrama as diferenças entre respostas transitória e estacionária, com exemplos de equações.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Livro de Dinâmica de Estruturas (ex: Clough & Penzien)",
                                    "Software MATLAB ou ANSYS para visualização de modos",
                                    "Notas de aula sobre teoria de placas (Kirchhoff e Mindlin)"
                                  ],
                                  "tips": "Use analogias com massas-molas para visualizar modos de vibração.",
                                  "learningObjective": "Compreender os princípios físicos das respostas dinâmicas em estruturas aeroespaciais.",
                                  "commonMistakes": [
                                    "Confundir amortecimento estrutural com aerodinâmico",
                                    "Ignorar efeitos não-lineares em grandes amplitudes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelagem de Excitações Aeroelásticas Harmônicas e Aleatórias",
                                  "subSteps": [
                                    "Definir excitações harmônicas como forças sinusoidais com frequência variável.",
                                    "Modelar excitações aleatórias usando espectros de potência (ex: PSD de turbulência).",
                                    "Incorporar origens aeroelásticas como lift oscilante e momento de arfagem.",
                                    "Calcular coeficientes aerodinâmicos unsteady (teoria de Theodorsen ou similares).",
                                    "Simular excitações em software para placas e cascas cilíndricas."
                                  ],
                                  "verification": "Gerar gráficos de excitação harmônica e PSD aleatória para uma placa específica.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Ferramentas de simulação: MATLAB Simulink",
                                    "Dados experimentais de túneis de vento",
                                    "Referências: Bissplinghoff 'Aeroelasticity'"
                                  ],
                                  "tips": "Comece com casos 1D antes de 2D para validar modelos.",
                                  "learningObjective": "Modelar com precisão forças aeroelásticas atuantes em estruturas.",
                                  "commonMistakes": [
                                    "Subestimar largura de banda em excitações aleatórias",
                                    "Usar aerodinâmica quasi-estacionária para frequências altas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Análise de Respostas Transitórias e Estacionárias",
                                  "subSteps": [
                                    "Resolver numericamente respostas transitórias via integração temporal (Newmark ou modal).",
                                    "Calcular respostas estacionárias usando funções de transferência e diagramas de Bode.",
                                    "Comparar picos de ressonância para harmônicas vs. aleatórias.",
                                    "Avaliar amplificações devido a acoplamento aeroelástico.",
                                    "Plotar curvas de resposta em domínio tempo e frequência."
                                  ],
                                  "verification": "Produzir gráficos de resposta transitória e estacionária para uma excitação dada, com valores de pico corretos.",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Software: NASTRAN ou ABAQUS",
                                    "Scripts MATLAB para integração numérica",
                                    "Exemplos de problemas resolvidos"
                                  ],
                                  "tips": "Verifique convergência alterando passos de tempo.",
                                  "learningObjective": "Avaliar quantitativamente respostas dinâmicas sob excitações aeroelásticas.",
                                  "commonMistakes": [
                                    "Esquecer termos de Coriolis em cascas rotativas",
                                    "Não normalizar funções modais"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Técnicas de Isolamento de Vibrações e Avaliação Final",
                                  "subSteps": [
                                    "Estudar isoladores passivos (borracha, molas) e ativos (atores piezelétricos).",
                                    "Otimizar parâmetros de isolamento para minimizar transmissão de vibrações.",
                                    "Simular sistemas isolados e comparar com não-isolados.",
                                    "Realizar análise de sensibilidade a parâmetros aeroelásticos.",
                                    "Documentar métricas de desempenho como fator de isolamento."
                                  ],
                                  "verification": "Demonstrar redução de 50% na amplitude de vibração em simulação com isolamento.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Modelos experimentais de placas com isoladores",
                                    "Software de otimização: fmincon no MATLAB",
                                    "Artigos sobre controle ativo de aeroelasticidade"
                                  ],
                                  "tips": "Teste múltiplas configurações iterativamente.",
                                  "learningObjective": "Aplicar e avaliar métodos de isolamento para mitigar respostas aeroelásticas.",
                                  "commonMistakes": [
                                    "Ignorar rigidez parasitária em isoladores",
                                    "Sobreestimar desempenho em baixas frequências"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule a resposta de uma placa de asa de UAV sujeita a excitação harmônica de flutter em túnel de vento: calcule deslocamentos transitórios durante aceleração, resposta estacionária em regime constante, e aplique isoladores para reduzir vibrações em 40%, validando com dados experimentais.",
                              "finalVerifications": [
                                "Capacidade de derivar equação de resposta modal para placa sob excitação harmônica.",
                                "Geração correta de espectros de resposta para excitação aleatória.",
                                "Cálculo preciso de fator de isolamento para um sistema dado.",
                                "Identificação de ressonâncias críticas em análise de Bode.",
                                "Comparação qualitativa e quantitativa entre simulação e teoria.",
                                "Explicação de efeitos transitórios em cenários reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão numérica nas respostas calculadas (erro <5%).",
                                "Compreensão conceitual demonstrada em relatórios.",
                                "Uso adequado de ferramentas de simulação e validação.",
                                "Identificação correta de erros comuns e mitigação.",
                                "Criatividade em conexões com aplicações reais.",
                                "Clareza na documentação de passos e resultados."
                              ],
                              "crossCurricularConnections": [
                                "Aerodinâmica: Modelos unsteady para lift oscilante.",
                                "Controle de Sistemas: Isolamento ativo via feedback.",
                                "Materiais Compósitos: Efeitos em rigidez e amortecimento.",
                                "Processamento de Sinais: Análise espectral de respostas.",
                                "Engenharia Experimental: Ensaios em shaker tables."
                              ],
                              "realWorldApplication": "No design de asas de aeronaves comerciais, avalia-se a resposta dinâmica a rajadas turbulentas para prevenir fadiga estrutural e flutter catastrófico, aplicando isoladores em painéis para estender vida útil e reduzir ruído de cabine."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.3",
                        "name": "Modelos Modais e Ensaios Experimentais",
                        "description": "Uso de expansões modais para simplificação de modelos aeroelásticos e validação por meio de ensaios em túnel de vento para placas e cascas.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.3.1",
                            "name": "Redução Modal de Modelos Aeroelásticos",
                            "description": "Projetar modelos aeroelásticos reduzidos na base modal, calculando frequências naturais, ortogonalidade de modos e coordenadas modais para placas e cascas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelagem da estrutura e cálculo de frequências naturais e formas modais",
                                  "subSteps": [
                                    "Defina a geometria e propriedades materiais da placa ou casca (ex.: alumínio, espessura, dimensões).",
                                    "Monte as equações de movimento usando método dos elementos finitos (MEF) ou analítico.",
                                    "Resolva o problema de autovalores para obter frequências naturais ω_i e formas modais φ_i.",
                                    "Normalizar as formas modais (ex.: massa unitária).",
                                    "Visualize e plote as primeiras 10-20 formas modais."
                                  ],
                                  "verification": "Verificar se as frequências estão ordenadas crescentemente e formas modais são ortogonais (produto escalar ≈0 para i≠j).",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Software MEF (ANSYS, NASTRAN ou MATLAB), dados de materiais, computador com 8GB RAM"
                                  ],
                                  "tips": "Comece com malha fina para precisão, mas otimize para convergência.",
                                  "learningObjective": "Compreender como obter o espectro modal completo de estruturas aeroelásticas.",
                                  "commonMistakes": [
                                    "Malha insuficiente levando a frequências imprecisas",
                                    "Esquecimento da normalização das formas modais",
                                    "Ignorar condições de contorno reais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificação da ortogonalidade e propriedades modais",
                                  "subSteps": [
                                    "Calcule a matriz de massa M e rigidez K no espaço modal: verificar M_modal = I (identidade).",
                                    "Confirme ortogonalidade: φ_i^T M φ_j = 0 e φ_i^T K φ_j = 0 para i≠j.",
                                    "Calcule massas modais m_i = φ_i^T M φ_i e frequências reduzidas.",
                                    "Analise acoplamento modal inicial entre modos.",
                                    "Gere relatório com tabelas de propriedades modais."
                                  ],
                                  "verification": "Matrizes modais diagonalizadas com off-diagonais <1e-6.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código MATLAB/Python para pós-processamento modal, resultados do Step 1"
                                  ],
                                  "tips": "Use tolerâncias numéricas adequadas para evitar falsos erros de ortogonalidade.",
                                  "learningObjective": "Garantir propriedades ortogonais fundamentais para redução modal válida.",
                                  "commonMistakes": [
                                    "Não verificar normalização de massa",
                                    "Confundir ortogonalidade em massa vs. rigidez",
                                    "Ignorar modos rígidos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Seleção de modos dominantes e formulação da redução modal",
                                  "subSteps": [
                                    "Identifique modos dominantes baseados em energia modal ou contribuição em frequências baixas (< cutoff).",
                                    "Selecione N_r modos (ex.: 10-20% dos totais) para o modelo reduzido.",
                                    "Formule a matriz de redução Φ_r = [φ_1, φ_2, ..., φ_{N_r}].",
                                    "Projete equações reduzidas: M_r = Φ_r^T M Φ_r, K_r = Φ_r^T K Φ_r.",
                                    "Compare espectro reduzido com o completo."
                                  ],
                                  "verification": "Erro de redução em frequências <5% para modos selecionados.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Script de seleção modal (MATLAB), critérios de cutoff (ex.: 90% energia cumulativa)"
                                  ],
                                  "tips": "Priorize modos com alta deformação em regiões críticas (ex.: borda livre de placa).",
                                  "learningObjective": "Dominar critérios para truncar o espaço modal sem perda significativa.",
                                  "commonMistakes": [
                                    "Selecionar poucos modos levando a subestimação de dinâmica",
                                    "Não considerar acoplamento aeroelástico",
                                    "Erro na transposição da matriz Φ_r"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Cálculo de coordenadas modais e validação do modelo reduzido",
                                  "subSteps": [
                                    "Transforme carregamentos/forçantes para espaço modal: q_r = Φ_r^T f.",
                                    "Simule resposta dinâmica no modelo reduzido (ex.: vibração livre/forçada).",
                                    "Calcule coordenadas modais q_i(t) via projeção: q = Φ_r^{-T} u (u deslocamentos físicos).",
                                    "Compare respostas reduzida vs. completa (erros em deslocamentos e frequências).",
                                    "Ajuste N_r se erro > tolerância e itere."
                                  ],
                                  "verification": "Erro relativo médio <3% em respostas dinâmicas para excitações típicas.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Solver dinâmico (MATLAB ode45 ou similar), dados de excitação aeroelástica"
                                  ],
                                  "tips": "Use excitações senoidais nas frequências naturais para teste sensível.",
                                  "learningObjective": "Aplicar redução modal em simulações dinâmicas aeroelásticas.",
                                  "commonMistakes": [
                                    "Inversão incorreta de Φ_r",
                                    "Não validar com múltiplas excitações",
                                    "Ignorar amortecimento no modelo reduzido"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma placa retangular representando uma aleta de cauda de aeronave (1m x 0.5m, alumínio), calcule 50 modos completos, reduza para 12 modos dominantes, e valide simulando flutter sob fluxo subsonico, obtendo resposta com erro <2%.",
                              "finalVerifications": [
                                "Frequências reduzidas coincidem com completas para modos selecionados (erro <1%).",
                                "Ortogonalidade preservada no modelo reduzido.",
                                "Respostas dinâmicas em simulações livres/forçadas com erro <5%.",
                                "Energia modal cumulativa dos modos selecionados >95%.",
                                "Coordenadas modais projetadas reconstróem deslocamentos físicos com precisão.",
                                "Estabilidade numérica do modelo reduzido confirmada."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos modais (ortogonalidade e frequências).",
                                "Adequação da seleção de modos (critérios quantitativos).",
                                "Validação comparativa reduzido vs. completo.",
                                "Relatório claro com plots, tabelas e erros quantificados.",
                                "Eficiência computacional demonstrada (tempo de simulação reduzido).",
                                "Tratamento de aspectos aeroelásticos (acoplamento)."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: autovalores, ortogonalidade e projeções matriciais.",
                                "Programação Numérica: MEF e solvers em MATLAB/Python.",
                                "Dinâmica de Estruturas: vibrações e métodos modais.",
                                "Aerodinâmica: integração com equações de fluxo para aeroelasticidade.",
                                "Otimização: seleção de modos via algoritmos genéticos."
                              ],
                              "realWorldApplication": "Em projetos de aeronaves, como o Boeing 787, redução modal permite simulações aeroelásticas eficientes de asas e fuselagens, reduzindo tempo computacional de dias para horas e evitando flutter catastrófico em voo."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.3.2",
                            "name": "Planejamento de Ensaios em Túnel de Vento",
                            "description": "Desenhar e interpretar ensaios experimentais de aeroelasticidade para placas e cascas, medindo respostas vibratórias e identificando instabilidades como flutter.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definição de Objetivos e Parâmetros Críticos do Ensaio",
                                  "subSteps": [
                                    "Identificar o problema aeroelástico específico (ex.: flutter em placas ou cascas)",
                                    "Definir parâmetros de similitude (Reynolds, Mach, reduced frequency) para escalonamento",
                                    "Estabelecer faixas de velocidade de fluxo, ângulos de ataque e condições de suporte",
                                    "Determinar respostas a medir (deslocamentos, acelerações, pressões)",
                                    "Especificar critérios de sucesso para detecção de instabilidades"
                                  ],
                                  "verification": "Documentar um plano escrito com objetivos claros, parâmetros numéricos e justificativas técnicas",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Literatura técnica sobre aeroelasticidade",
                                    "Software de cálculo (MATLAB ou Python para similitude)",
                                    "Templates de planejamento de ensaios"
                                  ],
                                  "tips": "Priorize parâmetros de flutter (frequência reduzida) para eficiência",
                                  "learningObjective": "Compreender e aplicar princípios de similitude dinâmica em ensaios aeroelásticos",
                                  "commonMistakes": [
                                    "Ignorar efeitos de escala não-lineares",
                                    "Subestimar faixas de velocidade crítica",
                                    "Não alinhar com dados numéricos prévios"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Design e Construção do Modelo Experimental",
                                  "subSteps": [
                                    "Selecionar materiais com propriedades modais semelhantes ao protótipo (ex.: alumínio ou compósitos para rigidez)",
                                    "Desenhar geometria da placa ou casca usando CAD, considerando modos vibratórios alvo",
                                    "Calcular massas, rigidezes e frequências naturais via análise modal finita",
                                    "Incorporar suportes elásticos para simular condições reais de montagem",
                                    "Validar design com simulações preliminares de elementos finitos"
                                  ],
                                  "verification": "Produzir desenhos CAD e relatórios de análise modal com frequências coincidentes (±5%)",
                                  "estimatedTime": "8 horas",
                                  "materials": [
                                    "Software CAD (SolidWorks ou ANSYS)",
                                    "Materiais de prototipagem (impressora 3D, metais leves)",
                                    "Ferramentas de medição (paquímetro, balança)"
                                  ],
                                  "tips": "Use amortecimento mínimo para acentuar instabilidades",
                                  "learningObjective": "Projetar modelos escalados que reproduzam comportamentos aeroelásticos reais",
                                  "commonMistakes": [
                                    "Escolha errada de material alterando modos",
                                    "Geometria imprecisa afetando frequências",
                                    "Suportes rígidos demais simulando mal"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configuração de Instrumentação e Setup do Túnel de Vento",
                                  "subSteps": [
                                    "Selecionar sensores: acelerômetros, strain gauges, LDV para vibrações e velocímetros para fluxo",
                                    "Planejar aquisição de dados (frequência de amostragem > 2x frequência máxima esperada)",
                                    "Configurar sistema de controle de fluxo (grades, difusores para uniformidade)",
                                    "Instalar modelo com alinhamento preciso e calibração de sensores",
                                    "Testar setup em baixa velocidade para baseline"
                                  ],
                                  "verification": "Realizar testes de calibração com dados limpos e ruído <5%",
                                  "estimatedTime": "6 horas",
                                  "materials": [
                                    "Sensores (acelerômetros piezoelétricos, anemômetros)",
                                    "Sistema DAQ (NI LabVIEW ou similar)",
                                    "Ferramentas de montagem no túnel"
                                  ],
                                  "tips": "Sincronize dados de múltiplos sensores para análise modal",
                                  "learningObjective": "Montar setups experimentais precisos para medição de respostas vibratórias",
                                  "commonMistakes": [
                                    "Calibração inadequada levando a ruído",
                                    "Frequência de amostragem baixa perdendo modos altos",
                                    "Alinhamento pobre induzindo vibrações espúrias"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Planejamento da Sequência de Testes e Condições Operacionais",
                                  "subSteps": [
                                    "Definir matriz de testes: incrementos de velocidade (ex.: 5 m/s passos até V_crit)",
                                    "Incluir varreduras de frequência forçada e testes livres para identificação modal",
                                    "Estabelecer protocolos de rampa de velocidade para capturar onset de flutter",
                                    "Planejar repetições para estatística e testes de histerese",
                                    "Definir critérios de parada (amplitude limite para segurança)"
                                  ],
                                  "verification": "Criar matriz de testes em tabela com >20 condições cobertas",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Planilhas Excel ou Python para matriz",
                                    "Dados de simulações prévias para previsão V_flutter"
                                  ],
                                  "tips": "Inicie com velocidades baixas para validar linearidade",
                                  "learningObjective": "Estruturar sequências de ensaios que capturem transições para instabilidade",
                                  "commonMistakes": [
                                    "Passos de velocidade grandes pulando bifurcações",
                                    "Falta de repetições ignorando variabilidade",
                                    "Ignorar histerese em flutter"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Protocolos de Análise, Interpretação e Relatório",
                                  "subSteps": [
                                    "Definir métodos de processamento: FFT para espectros, PRONY para modos",
                                    "Estabelecer critérios de identificação de flutter (coalescência de modos, crescimento exponencial)",
                                    "Planejar visualizações (bode plots, root locus experimental)",
                                    "Preparar relatório com validação contra teoria (ex.: Theodorsen)",
                                    "Recomendar iterações baseadas em resultados"
                                  ],
                                  "verification": "Simular análise com dados sintéticos mostrando detecção correta de flutter",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Software de análise (MATLAB Signal Processing Toolbox)",
                                    "Templates de relatórios aeroelásticos"
                                  ],
                                  "tips": "Use damping ratios para quantificar estabilidade",
                                  "learningObjective": "Interpretar dados experimentais para caracterizar instabilidades aeroelásticas",
                                  "commonMistakes": [
                                    "Má interpretação de ruído como flutter",
                                    "Não normalizar dados por similitude",
                                    "Falta de comparação com predições teóricas"
                                  ]
                                }
                              ],
                              "practicalExample": "Planejar um ensaio para uma placa retangular representando uma asa delta em túnel de vento subsonico: modelo de 0.3m span em alumínio, testado de 10-50 m/s, medindo acelerações em 6 pontos para detectar flutter torsional em ~35 m/s, validado contra modelo finito elemento.",
                              "finalVerifications": [
                                "Plano cobre similitude completa com erros <10%",
                                "Matriz de testes inclui >15 condições com incrementos finos perto de V_crit",
                                "Instrumentação cobre todos os modos relevantes (1o-3o)",
                                "Critérios de segurança definidos (amplitude max 5mm)",
                                "Análise prevê detecção de flutter via coalescência modal",
                                "Relatório template pronto com métricas quantitativas"
                              ],
                              "assessmentCriteria": [
                                "Precisão dos parâmetros de similitude (nota 1-10)",
                                "Completude da matriz de testes (cobertura de regime crítico)",
                                "Adequação da instrumentação para medições vibratórias",
                                "Robustez dos protocolos de análise (métodos validados)",
                                "Integração de segurança e eficiência temporal",
                                "Clareza e detalhe do documento final"
                              ],
                              "crossCurricularConnections": [
                                "Análise de Elementos Finitos (modelagem modal)",
                                "Dinâmica de Fluidos Computacional (validação CFD)",
                                "Controle de Sistemas (supressão ativa de flutter)",
                                "Materiais Avançados (compósitos aeroespaciais)",
                                "Estatística Experimental (análise de variância em dados)"
                              ],
                              "realWorldApplication": "Esse planejamento é essencial no design de asas de aeronaves e turbinas eólicas, como no caso do Boeing 737 MAX onde testes em túnel de vento identificaram flutter potencial, evitando falhas catastróficas e otimizando performance estrutural."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.3.3",
                            "name": "Correlação entre Modelos e Ensaios",
                            "description": "Comparar resultados numéricos de modelos modais com dados experimentais de vibração e aeroelasticidade, ajustando parâmetros como amortecimento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparação dos Dados de Modelos Modais e Ensaios Experimentais",
                                  "subSteps": [
                                    "Coletar dados numéricos do modelo modal, incluindo frequências naturais, modos de vibração e respostas em frequência.",
                                    "Obter dados experimentais de vibração e aeroelasticidade de ensaios, como acelerometria em túneis de vento ou mesas vibratórias.",
                                    "Padronizar unidades e formatos de dados (ex.: Hz para frequências, m/s² para acelerações).",
                                    "Identificar parâmetros iniciais do modelo, como rigidez, massa e amortecimento.",
                                    "Criar tabelas comparativas iniciais para frequências e modos."
                                  ],
                                  "verification": "Verificar se todos os dados estão em formato unificado e tabelas comparativas completas sem discrepâncias óbvias.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de análise modal (ex.: ANSYS, MATLAB), dados experimentais em CSV/Excel, documentação de ensaios"
                                  ],
                                  "tips": "Use scripts automatizados em Python/MATLAB para importação de dados para evitar erros manuais.",
                                  "learningObjective": "Entender e preparar dados consistentes para comparação entre simulações e experimentos.",
                                  "commonMistakes": [
                                    "Ignorar diferenças de escala ou unidades, omitir ruído experimental nos dados."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Comparação Inicial de Resultados Numéricos e Experimentais",
                                  "subSteps": [
                                    "Plotar gráficos de frequências naturais e modos de vibração lado a lado (modelo vs. experimental).",
                                    "Calcular métricas iniciais de erro, como diferença percentual em frequências (MAC - Modal Assurance Criterion).",
                                    "Analisar respostas em frequência (FRF) e espectros de potência para vibrações e aeroelasticidade.",
                                    "Identificar discrepâncias principais, como picos de frequência deslocados ou modos não correlacionados.",
                                    "Documentar observações qualitativas e quantitativas em relatório preliminar."
                                  ],
                                  "verification": "Gráficos mostram sobreposição visual e MAC > 0.8 para modos correlacionados.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "MATLAB ou Python com bibliotecas SciPy/NumPy, planilhas Excel para cálculos"
                                  ],
                                  "tips": "Aplique filtros passa-baixa nos dados experimentais para reduzir ruído antes da comparação.",
                                  "learningObjective": "Desenvolver habilidades para quantificar e visualizar discrepâncias iniciais.",
                                  "commonMistakes": [
                                    "Não usar MAC para modos, focar apenas em frequências sem considerar formas modais."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ajuste Iterativo de Parâmetros do Modelo",
                                  "subSteps": [
                                    "Selecionar parâmetros sensíveis como amortecimento modal, rigidez e condições de contorno.",
                                    "Executar simulações iterativas variando um parâmetro por vez (ex.: aumentar amortecimento em 10%).",
                                    "Recalcular MAC e erros percentuais após cada iteração.",
                                    "Usar otimização (ex.: minimização de quadrados mínimos) para ajustes automáticos.",
                                    "Monitorar convergência até erros <5% em frequências principais."
                                  ],
                                  "verification": "Erros percentuais reduzidos para <5% e MAC > 0.9 na maioria dos modos.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Software de otimização (MATLAB Optimization Toolbox, Python SciPy.optimize), modelos FEM atualizados"
                                  ],
                                  "tips": "Comece ajustando amortecimento, pois é o parâmetro mais impactante em aeroelasticidade.",
                                  "learningObjective": "Aprender técnicas de calibração de modelos baseadas em dados experimentais.",
                                  "commonMistakes": [
                                    "Ajustar múltiplos parâmetros simultaneamente sem análise de sensibilidade, ignorar não-linearidades."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validação Final e Análise de Sensibilidade",
                                  "subSteps": [
                                    "Comparar respostas aeroelásticas completas (ex.: flutter speeds) entre modelo ajustado e experimental.",
                                    "Realizar análise de sensibilidade variando parâmetros em ±20%.",
                                    "Gerar relatório com gráficos finais, tabelas de correlação e recomendações.",
                                    "Testar robustez com subconjuntos de dados experimentais.",
                                    "Discutir limitações, como efeitos não-modelados (aerodinâmica não-linear)."
                                  ],
                                  "verification": "Relatório completo com todas as métricas finais aceitáveis e análise de sensibilidade documentada.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Ferramentas de plotagem avançada (Matplotlib, Origin), templates de relatório"
                                  ],
                                  "tips": "Inclua intervalos de confiança nos dados experimentais para validação estatística.",
                                  "learningObjective": "Garantir que o modelo correlacionado seja robusto e aplicável.",
                                  "commonMistakes": [
                                    "Não testar sensibilidade, superestimar correlação sem validação cruzada."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um ensaio de vibração de uma placa representando uma asa de aeronave em túnel de vento, correlacione o modelo modal FEM (frequências: 50Hz, 120Hz) com dados experimentais (48Hz, 118Hz), ajustando amortecimento de 1% para 1.5% até MAC > 0.95 e erro <3%.",
                              "finalVerifications": [
                                "MAC > 0.9 para pelo menos 80% dos modos principais.",
                                "Erro médio em frequências <5%.",
                                "Sobreposição visual perfeita em FRFs ajustadas.",
                                "Velocidade crítica de flutter predita coincide com experimental em ±10%.",
                                "Análise de sensibilidade mostra estabilidade em variações de parâmetros.",
                                "Relatório documenta todas as iterações e justificativas."
                              ],
                              "assessmentCriteria": [
                                "Precisão das métricas de correlação (MAC, erros percentuais).",
                                "Qualidade dos gráficos e visualizações comparativas.",
                                "Eficiência no ajuste iterativo (número de iterações <10).",
                                "Profundidade da análise de sensibilidade e limitações.",
                                "Clareza e completude do relatório final.",
                                "Aplicação correta de conceitos de aeroelasticidade."
                              ],
                              "crossCurricularConnections": [
                                "Estatística: Cálculo de MAC e análise de erros.",
                                "Programação: Scripts em MATLAB/Python para automação.",
                                "Física: Princípios de vibração modal e amortecimento.",
                                "Engenharia Mecânica: Modelagem FEM e otimização.",
                                "Análise de Dados: Processamento de sinais experimentais."
                              ],
                              "realWorldApplication": "Na certificação de aeronaves, como no Boeing 787, correlacionar modelos modais com ensaios em túnel de vento garante prevenção de flutter, otimizando design e segurança estrutural."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.3",
                    "name": "Problemas de Estabilidade Aeroelástica",
                    "description": "Estudo dos problemas de estabilidade em sistemas aeroelásticos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.3.1",
                        "name": "Divergência Aeroelástica",
                        "description": "Instabilidade estática em que a estrutura aeroelástica perde rigidez devido à interação com forças aerodinâmicas, levando a deformações crescentes até o colapso.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.1.1",
                            "name": "Derivar equações de equilíbrio para divergência",
                            "description": "Formular as equações de equilíbrio estático de um sistema aeroelástico simples, como uma asa rígida ou flexível, incorporando forças aerodinâmicas de sustentação e torção usando teoria aerodinâmica quasi-estacionária.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o modelo cinemático e propriedades estruturais da asa",
                                  "subSteps": [
                                    "Escolha um modelo simples, como uma asa rígida em pitching (1 grau de liberdade torsional) ou flexível com torção.",
                                    "Defina as coordenadas: ângulo de torção θ, rigidez torsional Kθ, inércia Iθ (embora para estático não precise).",
                                    "Especifique geometria: corda c, envergadura b (para 2D, unitária), ponto elástico e aerodinâmico.",
                                    "Estabeleça o ângulo de ataque efetivo α = α0 + θ (para quasi-steady).",
                                    "Anote massas, mas foque em equilíbrio estático (acelerações zero)."
                                  ],
                                  "verification": "Modelo esquematizado com DOFs, propriedades e relações cinemáticas documentadas corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis ou software como MATLAB/SymPy",
                                    "Referências: livros de aeroelasticidade como Bisplinghoff ou Fung"
                                  ],
                                  "tips": "Comece com modelo 2D pitching-plunge para simplicidade; desenhe diagrama free-body.",
                                  "learningObjective": "Compreender a representação matemática simplificada de um sistema aeroelástico.",
                                  "commonMistakes": [
                                    "Ignorar o offset entre eixo elástico e aerodinâmico",
                                    "Confundir pitching com plunge"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular forças e momentos aerodinâmicos usando teoria quasi-estacionária",
                                  "subSteps": [
                                    "Lembre coeficientes: CL(α) ≈ CLα * α, Cm(α) ≈ Cm0 + Cmα * α (linearização).",
                                    "Calcule sustentação L = (1/2) ρ V² S CL(α), com α = α0 + θ + efeitos (para estático, V constante).",
                                    "Momento aerodinâmico Maero em torno do eixo elástico: Maero = (1/2) ρ V² S ĉ (Cmα α + offset terms).",
                                    "Inclua posição do centro aerodinâmico (x_ac) relativo ao eixo elástico para momento de L.",
                                    "Expresse tudo em função de θ: Maero(θ) = Maero0 + K_aero * θ."
                                  ],
                                  "verification": "Expressões de L e Maero corretas em termos de θ, com coeficientes dimensionados.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Tabelas de perfis aerodinâmicos (NACA)",
                                    "Calculadora ou SymPy para simbólico"
                                  ],
                                  "tips": "Use S = b*c, ĉ = c/4; verifique unidades (N e Nm).",
                                  "learningObjective": "Aplicar teoria aerodinâmica quasi-estacionária a movimentos estruturais.",
                                  "commonMistakes": [
                                    "Esquecer fator dinâmico q = 1/2 ρ V²",
                                    "Não linearizar Cm e CL"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer as equações de equilíbrio estático",
                                  "subSteps": [
                                    "Para equilíbrio: soma forças = 0 (plunge: Fy = -L + K_h h = 0, mas foque torção).",
                                    "Torção: M_elástico + M_aero = 0 → Kθ θ + Maero(θ) = 0.",
                                    "Substitua Maero: Kθ θ + Maero0 + (∂Maero/∂θ) θ = 0.",
                                    "Resolva para θ_eq: θ_eq = -Maero0 / (Kθ + ∂Maero/∂θ).",
                                    "Generalize para múltiplas DOFs se flexível (matriz de rigidez)."
                                  ],
                                  "verification": "Equações balanceadas com θ_eq explícito ou matricial.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Folha de cálculo simbólica",
                                    "Exemplos de livros texto"
                                  ],
                                  "tips": "Mantenha simbólico; isole termos constantes e dependentes de θ.",
                                  "learningObjective": "Derivar condições de equilíbrio estático aeroelástico.",
                                  "commonMistakes": [
                                    "Confundir sinal de momentos",
                                    "Omitir termo estático Maero0"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar a condição de divergência a partir das equações",
                                  "subSteps": [
                                    "Divergência ocorre quando denominador zero: Kθ + ∂Maero/∂θ = 0.",
                                    "Calcule ∂Maero/∂θ = ∂/∂θ [(1/2)ρV² S ĉ Cmα (α0 + θ)] + termo de L * offset.",
                                    "Expresse V_div = sqrt( |Kθ / (∂CL/∂α * offset terms)| ) ou similar.",
                                    "Para asa flexível, det(K_estrut + K_aero) = 0.",
                                    "Verifique dimensionalidade e unidades."
                                  ],
                                  "verification": "Condição de divergência explícita (V_div ou equação característica).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software para resolver determinantes se multi-DOF",
                                    "Gráficos V-g para validar"
                                  ],
                                  "tips": "∂Maero/∂θ é tipicamente positivo para divergência (destabilizador).",
                                  "learningObjective": "Identificar instabilidade estática via rigidez efetiva zero.",
                                  "commonMistakes": [
                                    "Sinal errado no termo aerodinâmico",
                                    "Confundir com flutter dinâmico"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma seção NACA0012 rígida pitching em torno de 1/3c, com x_ac=1/4c, CLα=5.7/rad, Cmα=-0.5, offset e= -0.1c: derive Maero ≈ q c² (Cmα (α0+θ) + CLα (α0+θ) e/c), equilibre Kθ θ + Maero=0, encontre V_div tal que ∂Maero/∂θ = -Kθ.",
                              "finalVerifications": [
                                "Equações de L e Maero corretas e linearizadas.",
                                "Equilíbrio θ_eq derivado sem erros algébricos.",
                                "Condição de divergência matches literatura (ex: V_div² = Kθ / (q ∂Cm/∂α)).",
                                "Diagrama free-body completo.",
                                "Cálculo numérico para exemplo com valores realistas converge.",
                                "Análise de sensibilidade a parâmetros (ρ, V)."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações (100% simbólico correto).",
                                "Compreensão conceitual de quasi-steady vs unsteady.",
                                "Capacidade de generalizar para 2+ DOFs.",
                                "Uso correto de convenções de sinal e referências.",
                                "Clareza na documentação e diagramas.",
                                "Validação com exemplo numérico (erro <5%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (matrizes de rigidez), cálculo diferencial (linearização).",
                                "Física: Mecânica estática, aerodinâmica básica.",
                                "Engenharia: Análise estrutural (elementos finitos intro), otimização de design.",
                                "Computação: Simulação simbólica (SymPy/MATLAB), plotagem de curvas V-g."
                              ],
                              "realWorldApplication": "No design de asas de aeronaves (ex: Piper Cub histórico divergiu em 100 mph), hélices e turbinas eólicas, garante V_div > V_operacional via twist washout ou materiais compostos, evitando colapso estático catastrófico."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.2",
                            "name": "Calcular velocidade crítica de divergência",
                            "description": "Determinar a velocidade crítica de divergência resolvendo o determinante da matriz de rigidez efetiva aerelástica para sistemas com 1 ou 2 graus de liberdade, utilizando equações de Lagrange.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Divergência Aeroelástica",
                                  "subSteps": [
                                    "Defina divergência aeroelástica como instabilidade estática causada pela interação entre forças aerodinâmicas e deformações elásticas.",
                                    "Explique a velocidade crítica de divergência (V_cr) como a velocidade na qual a rigidez efetiva se anula (det(K_eff) = 0).",
                                    "Discuta sistemas com 1 DOF (ex: torção) e 2 DOF (ex: flexão-torção).",
                                    "Revise equações de Lagrange para sistemas discretos: L = T - V, onde T é energia cinética e V é potencial.",
                                    "Identifique termos aerodinâmicos que reduzem a rigidez elástica."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que acontece na V_cr e dê um exemplo físico simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Livro 'Aeroelasticity' de Raymond L. Bisplinghoff",
                                    "Notas de aula sobre mecânica do voo",
                                    "Calculadora ou software simbólico como SymPy"
                                  ],
                                  "tips": "Visualize com diagramas de asa deformando sob carga aerodinâmica crescente.",
                                  "learningObjective": "Entender conceitualmente a divergência e seu critério de instabilidade.",
                                  "commonMistakes": [
                                    "Confundir divergência (estática) com flutter (dinâmico).",
                                    "Ignorar que V_cr é independente de massa/inércia."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar o Sistema com 1 ou 2 Graus de Liberdade",
                                  "subSteps": [
                                    "Para 1 DOF (torção): defina coordenada generalizada θ (ângulo de torção).",
                                    "Para 2 DOF (flexão-torção): defina h (deslocamento vertical) e θ.",
                                    "Esboce o modelo: asa como viga cantilever com centro elástico (CE) e aerodinâmico (CA).",
                                    "Defina parâmetros: rigidez torsional GJ, inércia I, densidade ar ρ, corda c, excentricidade e.",
                                    "Escreva energia potencial elástica V_el = (1/2) K θ² para 1 DOF."
                                  ],
                                  "verification": "Desenhe e rotule o diagrama do sistema com todas as variáveis definidas corretamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis para esboços",
                                    "Tabela de propriedades de perfis aerodinâmicos (NACA)",
                                    "Software de desenho como Draw.io"
                                  ],
                                  "tips": "Use convenções padrão: CA à frente do CE para estabilidade.",
                                  "learningObjective": "Configurar precisamente o modelo físico e suas coordenadas generalizadas.",
                                  "commonMistakes": [
                                    "Erro na localização relativa de CE e CA.",
                                    "Usar DOF incorretos para o problema."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar Equações de Movimento Usando Lagrange",
                                  "subSteps": [
                                    "Calcule energia cinética T = (1/2) I ᵗ² para 1 DOF.",
                                    "Inclua energia potencial aerolástica V_aero = - (1/2) ρ V² c² e Cl_α θ² (termo de redução de rigidez).",
                                    "Aplique Lagrange: d/dt (∂L/∂ᵗ) - ∂L/∂θ = 0, resultando em K_eff θ = 0.",
                                    "Para 2 DOF, expresse T e V em matrizes de massa e rigidez.",
                                    "Linearize para pequenas deformações."
                                  ],
                                  "verification": "Derive e verifique que as equações de movimento estáticas são [K_el - λ K_aero] {q} = 0, onde λ ~ V².",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB ou Python com SymPy para derivação simbólica",
                                    "Folha de equações de aeroelasticidade padrão"
                                  ],
                                  "tips": "Mantenha símbolos consistentes; verifique unidades (V em m/s, rigidez em N.m/rad).",
                                  "learningObjective": "Dominar a formulação lagrangiana para sistemas aeroelásticos.",
                                  "commonMistakes": [
                                    "Sinal errado no termo aerodinâmico (deve reduzir rigidez).",
                                    "Esquecer fator 1/2 na energia."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular a Velocidade Crítica Resolvendo o Determinante",
                                  "subSteps": [
                                    "Formule matriz de rigidez efetiva K_eff = K_el - (ρ V² / 2) Q_aero, onde Q_aero é matriz aerodinâmica.",
                                    "Para 1 DOF: resolva det(K_eff) = K - (ρ V_cr² / 2) q_θθ = 0 → V_cr = sqrt(2K / (ρ q_θθ)).",
                                    "Para 2 DOF: compute det(K_eff) = 0, resolvendo equação quadrática em V².",
                                    "Implemente numericamente com valores reais (ex: ρ=1.225 kg/m³, c=2m).",
                                    "Valide com fórmula clássica de Theodorsen para torção."
                                  ],
                                  "verification": "Obtenha V_cr numérica e compare com valor teórico conhecido (±5% erro).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB para cálculo matricial",
                                    "Valores típicos: GJ=10^6 N.m², I=100 kg.m², e=0.25c, Cl_α=2π"
                                  ],
                                  "tips": "Use eigenvalores para sistemas multi-DOF se disponível.",
                                  "learningObjective": "Resolver analítica e numericamente para V_cr em 1-2 DOF.",
                                  "commonMistakes": [
                                    "Determinante incorreto para 2x2 matriz.",
                                    "Unidades inconsistentes em V_cr."
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma seção de asa NACA 0012 com 1 DOF torsional: GJ=5e6 N.m², I=50 kg.m², c=2m, e=0.4m, Cl_α=5.7, ρ=1.225 kg/m³. Derive K_eff = GJ/L - (ρ V² c² e Cl_α / 8), resolva det=0 → V_cr ≈ 120 m/s. Repita para 2 DOF adicionando h com EI=1e8 N.m².",
                              "finalVerifications": [
                                "det(K_eff(V_cr)) = 0 numericamente.",
                                "V_cr > 1.5 * V_operacional típica.",
                                "Modo de deformação puro na V_cr (sem oscilação).",
                                "Resultado coincide com fórmula fechada para 1 DOF.",
                                "Para 2 DOF, menor V_cr governante é selecionada.",
                                "Sensibilidade a parâmetros (∂V_cr/∂GJ >0)."
                              ],
                              "assessmentCriteria": [
                                "Correção na derivação lagrangiana (100% simbólica).",
                                "Precisão numérica do determinante (<1% erro).",
                                "Identificação correta de termos aerodinâmicos.",
                                "Explicação física da instabilidade.",
                                "Manipulação matricial para 2 DOF.",
                                "Validação com exemplo prático."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (determinantes, autovalores).",
                                "Física: Mecânica lagrangiana e estática.",
                                "Engenharia Estrutural: Análise de rigidez de vigas.",
                                "Aerodinâmica: Teoria de perfis (Cl_α, momento de torção).",
                                "Programação: Simulação numérica em MATLAB/Python."
                              ],
                              "realWorldApplication": "No design de asas de aviões comerciais (ex: Boeing 787), calcular V_cr garante margem de segurança contra divergência em manobras de alta velocidade, evitando deformações catastróficas como no acidente do X-29 experimental."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.3",
                            "name": "Analisar efeitos de parâmetros geométricos",
                            "description": "Investigar o impacto de parâmetros como posição do eixo elástico, rigidez flexural e torsional na velocidade crítica de divergência em perfis alares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos Teóricos da Divergência Aeroelástica",
                                  "subSteps": [
                                    "Estudar o conceito de divergência como instabilidade estática em perfis alares sob carga aerodinâmica.",
                                    "Identificar parâmetros geométricos chave: posição do eixo elástico (h), rigidez flexural (EI) e torsional (GJ).",
                                    "Derivar ou revisar equações de equilíbrio estático, como V_cr = sqrt( (GJ * (1 - h * c/2)) / (rho * c^2 * Cl_alpha / 2) ).",
                                    "Analisar qualitativamente impactos: eixo frontal aumenta V_cr, maior GJ estabiliza.",
                                    "Comparar com casos reais de falhas aeroelásticas históricas."
                                  ],
                                  "verification": "Escrever um resumo de 200 palavras explicando o impacto qualitativo de cada parâmetro na V_cr.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Principles of Aeroelasticity' de Bisplinghoff",
                                    "Notas de aula sobre aeroelasticidade",
                                    "Software de visualização de equações como Mathcad"
                                  ],
                                  "tips": "Comece com diagramas esquemáticos do perfil alar para visualizar a posição do eixo elástico.",
                                  "learningObjective": "Compreender as relações teóricas entre parâmetros geométricos e velocidade crítica de divergência.",
                                  "commonMistakes": [
                                    "Confundir rigidez flexural (EI, bending) com torsional (GJ, twisting)",
                                    "Ignorar o termo de acoplamento geométrico h",
                                    "Subestimar o papel da densidade do ar (rho)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Modelo Numérico ou Analítico",
                                  "subSteps": [
                                    "Selecionar ou criar modelo simplificado de perfil alar (ex: placa rígida com torção e flexão).",
                                    "Implementar equações em software (MATLAB, Python ou ANSYS).",
                                    "Definir valores nominais: c=1m, EI=1e4 Nm², GJ=1e3 Nm², h=0.25c, Cl_alpha=2π.",
                                    "Validar modelo com casos conhecidos da literatura (ex: Theodorsen).",
                                    "Preparar matriz paramétrica: variar h (0.1c a 0.5c), EI (0.5x a 2x nominal), GJ (0.5x a 2x)."
                                  ],
                                  "verification": "Executar simulação nominal e confirmar V_cr coincide com valor teórico dentro de 5%.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB ou Python com NumPy/SciPy",
                                    "Tutoriais de aeroelasticidade em GitHub",
                                    "Perfil NACA 0012 dados aerodinâmicos"
                                  ],
                                  "tips": "Use funções parametrizadas para facilitar sweeps (ex: linspace em MATLAB).",
                                  "learningObjective": "Construir um modelo confiável para análise paramétrica de divergência.",
                                  "commonMistakes": [
                                    "Erros de unidade (Nm² vs N/m)",
                                    "Não linearizar corretamente as forças aerodinâmicas",
                                    "Definir faixas paramétricas muito estreitas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Análises Paramétricas",
                                  "subSteps": [
                                    "Realizar sweep paramétrico para cada variável isoladamente (fixar outras).",
                                    "Coletar dados: V_cr vs h, V_cr vs EI, V_cr vs GJ (pelo menos 10 pontos cada).",
                                    "Registrar curvas de resposta e identificar tendências (ex: V_cr ∝ 1/sqrt(h)).",
                                    "Testar interações: variar dois parâmetros simultaneamente (ex: h e GJ).",
                                    "Exportar dados para análise (CSV ou plots preliminares)."
                                  ],
                                  "verification": "Gerar 3 gráficos de V_cr vs parâmetro com R² > 0.95 em curvas ajustadas.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Software de simulação (MATLAB/Python/ANSYS)",
                                    "Planilhas Excel para pós-processamento",
                                    "Biblioteca Matplotlib/Plotly"
                                  ],
                                  "tips": "Automatize loops para evitar erros manuais; monitore tempo de computação.",
                                  "learningObjective": "Gerar dados quantitativos sobre impactos paramétricos na estabilidade.",
                                  "commonMistakes": [
                                    "Não fixar parâmetros adequadamente em sweeps isolados",
                                    "Escala errada nos eixos dos gráficos",
                                    "Sobrecarregar modelo com malha fina desnecessária"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Interpretar Resultados",
                                  "subSteps": [
                                    "Plotar e ajustar curvas: identificar sensibilidades (dV_cr/dh, etc.).",
                                    "Quantificar efeitos: % mudança em V_cr por 10% variação em parâmetro.",
                                    "Discutir trade-offs: ex: aumentar GJ melhora V_cr mas adiciona peso.",
                                    "Comparar com teoria e literatura; propor otimizações geométricas.",
                                    "Documentar relatório com conclusões acionáveis."
                                  ],
                                  "verification": "Produzir relatório de 1 página com gráficos, tabelas e recomendações.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de plotagem (MATLAB/Origin)",
                                    "Templates de relatório LaTeX/Word",
                                    "Referências bibliográficas"
                                  ],
                                  "tips": "Use log-escalas para spans amplos; destaque pontos críticos como h=0.",
                                  "learningObjective": "Interpretar dados paramétricos para insights em design aeroelástico.",
                                  "commonMistakes": [
                                    "Interpretação causal errada (correlação ≠ causalidade)",
                                    "Ignorar limites físicos (ex: h negativo)",
                                    "Generalizações sem suporte quantitativo"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um perfil alar NACA 0012 com c=1m, varie a posição do eixo elástico h de 0.1c a 0.4c usando modelo de torção rígida no MATLAB. Fixe EI=1e4 Nm², GJ=5e3 Nm²; observe V_cr aumentar de 50 m/s para 120 m/s ao mover h para frente, simulando sweep em 20 pontos e plotando curva hiperbólica.",
                              "finalVerifications": [
                                "Explicar corretamente que avançar o eixo elástico (menor h) aumenta V_cr em 50-100%.",
                                "Quantificar: dobrar GJ eleva V_cr em √2 vezes.",
                                "Identificar que rigidez flexural EI tem impacto mínimo em perfis típicos.",
                                "Plotar curvas paramétricas com tendências corretas.",
                                "Propor ajuste geométrico para elevar V_cr em 20% sem peso extra.",
                                "Comparar resultados com fórmula analítica dentro de 10%."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos modelos e simulações (erro <5% vs teoria).",
                                "Completude das análises paramétricas (mínimo 3 parâmetros, 10+ pontos cada).",
                                "Qualidade dos gráficos e visualizações (legendas, escalas adequadas).",
                                "Profundidade da interpretação (quantitativa + qualitativa).",
                                "Clareza do relatório e recomendações práticas.",
                                "Identificação correta de trade-offs e otimizações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise paramétrica, equações diferenciais e ajuste de curvas.",
                                "Física: Mecânica dos sólidos, aerodinâmica quasi-estática.",
                                "Engenharia Computacional: Programação numérica e simulações FEM.",
                                "Design de Produto: Otimização multidisciplinar em aeroespacial.",
                                "Estatística: Análise de sensibilidade e regressão."
                              ],
                              "realWorldApplication": "No projeto de asas de UAVs ou aeronaves leves como o Piper Super Cub, otimizar a posição do eixo elástico e rigidezes para elevar V_cr acima da velocidade de cruzeiro, prevenindo falhas como a divergência observada em testes de túnel de vento da NACA nos anos 1940."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.2",
                        "name": "Flutter Aeroelástico",
                        "description": "Instabilidade dinâmica oscilatória autoexcitada resultante da acoplagem entre modos estruturais e forças aerodinâmicas não estacionárias.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.2.1",
                            "name": "Modelar equações de movimento para flutter",
                            "description": "Estabelecer as equações diferenciais de movimento acopladas para flutter em sistemas com dois graus de liberdade (flexão e torção), incluindo termos aerodinâmicos de Theodorsen ou equivalentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o modelo físico e graus de liberdade",
                                  "subSteps": [
                                    "Identifique a seção típica de asa como um sistema de dois graus de liberdade: h (flexão vertical) e α (torção).",
                                    "Desenhe o diagrama esquemático mostrando massas concentradas, rigidez flexural k_h e torsional k_α, e amortecimento c_h e c_α.",
                                    "Defina as coordenadas generalizadas h(t) e α(t) e posicione o centro elástico (CE), aerodinâmico (CA) e de gravidade (CG).",
                                    "Estabeleça suposições: movimento harmônico pequeno, fluido incompressível, ângulo de ataque pequeno.",
                                    "Calcule momentos de inércia e massas efetivas para o modelo."
                                  ],
                                  "verification": "Verifique se o diagrama inclui todos os pontos chave (CE, CA, CG) e equações de posição estão corretas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e lápis para esboços",
                                    "Livro 'Principles of Aeroelasticity' de Bisplinghoff",
                                    "Software de desenho como Draw.io"
                                  ],
                                  "tips": "Comece com um esboço simples e rotule todas as distâncias (x_α, x_h) para evitar confusões posteriores.",
                                  "learningObjective": "Compreender a configuração física do modelo de flutter com dois DOF.",
                                  "commonMistakes": [
                                    "Confundir CE com CG",
                                    "Ignorar deslocamentos relativos entre pontos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar as equações de movimento estruturais usando o princípio de Lagrange",
                                  "subSteps": [
                                    "Escreva a energia cinética T = (1/2) m ṫ² + (1/2) I_α ṡ², considerando velocidades em h e α.",
                                    "Escreva a energia potencial V = (1/2) k_h h² + (1/2) k_α α².",
                                    "Calcule as forças generalizadas não conservativas Q_h e Q_α (aerodinâmicas, a serem adicionadas depois).",
                                    "Aplique Lagrange: d/dt (∂L/∂ṫ) - ∂L/∂h = Q_h e similar para α, resultando em [M]{¨q} + [C]{˙q} + [K]{q} = {Q_aero}.",
                                    "Verifique linearidade e acoplamento inercial devido a deslocamentos de CG."
                                  ],
                                  "verification": "Resolva manualmente para um caso sem aero e confirme que reduz a equações desacopladas quando x_α=0.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Caderno de equações",
                                    "MATLAB ou Python para simbólico (SymPy)",
                                    "Referência: 'Aeroelasticity' de Fung"
                                  ],
                                  "tips": "Use notação matricial desde o início para facilitar acoplamento posterior.",
                                  "learningObjective": "Dominar derivação Lagrangiana para sistemas acoplados em aeroelasticidade.",
                                  "commonMistakes": [
                                    "Esquecer termos cruzados na energia cinética",
                                    "Não incluir amortecimento viscoso"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelar forças aerodinâmicas usando a teoria de Theodorsen",
                                  "subSteps": [
                                    "Revise lift L = π ρ b² (¨h + U b/2 ṡ - b²/8 ¨α) + 2π ρ U b C(k) (˙h/U + b/2 ṡ - α), onde C(k) é função de Theodorsen.",
                                    "Derive momento aerodinâmico M = π ρ b³/4 (¨h + U b/2 ṡ - b²/8 ¨α) + (π ρ U b²/2) C(k) (˙h/U + b/2 ṡ - α).",
                                    "Expresse forças em termos de {q}: Q_aero = [A] {¨q} + [B] {˙q} + [C] {q}.",
                                    "Implemente aproximação de Theodorsen como racional (ex: Jones) para simulação.",
                                    "Confirme unidades e coeficientes não-dimensionais (ex: μ, k reduzido)."
                                  ],
                                  "verification": "Compare com equações padrão de Theodorsen para seção 2D e valide coeficientes.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Tabelas de Theodorsen",
                                    "MATLAB Aero Toolbox",
                                    "Artigo original de Theodorsen (1935)"
                                  ],
                                  "tips": "Use k = ω b / U para número reduzido em todas as expressões aerodinâmicas.",
                                  "learningObjective": "Incorporar aerodinâmica não estacionária unsteady em equações de flutter.",
                                  "commonMistakes": [
                                    "Usar lift estacionário em vez de unsteady",
                                    "Erros nos sinais de termos de aceleração"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Acoplar equações e preparar para análise de estabilidade",
                                  "subSteps": [
                                    "Monte a matriz completa: ([M] + [A]) {¨q} + ([C] + [B]) {˙q} + [K + C] {q} = 0.",
                                    "Assuma solução harmônica q = q0 e^{iωt} e derive equação característica.",
                                    "Non-dimensionalize usando parâmetros: frequência reduzida k, massa μ, etc.",
                                    "Implemente em código para plotar V-g-f (velocidade-ganho-frequência).",
                                    "Teste com valores típicos (ex: NACA 0012) para prever velocidade de flutter."
                                  ],
                                  "verification": "Simule e confirme que flutter ocorre quando parte real de ω muda de negativo para positivo.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/Simulink",
                                    "Python com NumPy/SciPy",
                                    "Exemplos numéricos de Bisplinghoff"
                                  ],
                                  "tips": "Sempre normalize para evitar erros numéricos em simulações.",
                                  "learningObjective": "Finalizar modelo acoplado pronto para análise de flutter.",
                                  "commonMistakes": [
                                    "Matrizes erradas no acoplamento aero-estrutural",
                                    "Ignorar dependência em k para C(k)"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e refinar o modelo",
                                  "subSteps": [
                                    "Compare com dados experimentais de túneis de vento (ex: Goland wing).",
                                    "Sensitividade: varie parâmetros como x_α e observe mudança em V_flutter.",
                                    "Estenda para amortecimento aerodinâmico se necessário.",
                                    "Documente equações finais em LaTeX.",
                                    "Planeje simulação numérica para solução de autovalores."
                                  ],
                                  "verification": "Velocidade de flutter predita deve estar dentro de 10% de dados conhecidos.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Dados experimentais online (NASA)",
                                    "Overleaf para LaTeX"
                                  ],
                                  "tips": "Use autovalores complexos para detectar instabilidade.",
                                  "learningObjective": "Garantir robustez e validade prática do modelo.",
                                  "commonMistakes": [
                                    "Não validar numericamente",
                                    "Overfitting a um caso específico"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma seção de asa NACA 0012 com b=0.15m, U=30m/s, m=0.5kg, I_α=0.01kgm², k_h=2844N/m, k_α=3610Nm/rad, x_α=0.2b, derive as equações e encontre V_flutter ≈ 25m/s usando MATLAB, confirmando acoplamento flexão-torção.",
                              "finalVerifications": [
                                "Equações acopladas incluem termos inerciais cruzados e aerodinâmicos unsteady.",
                                "Função C(k) de Theodorsen está corretamente implementada.",
                                "Simulação reproduz curva V-g com flutter detectado.",
                                "Modelo prediz mudança de sinal em damping para modo crítico.",
                                "Documentação inclui todas as matrizes [M_aero], [C_aero], [K_aero].",
                                "Validação contra benchmark (ex: Theodorsen seção) com erro <5%."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação Lagrangiana (20%)",
                                "Correta inclusão de termos Theodorsen (30%)",
                                "Acoplamento matricial sem erros algébricos (20%)",
                                "Implementação numérica funcional (15%)",
                                "Validação e análise de sensibilidade (10%)",
                                "Clareza na documentação e diagramas (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Solução de EDOs lineares com coeficientes complexos e autovalores.",
                                "Programação: Uso de SymPy/MATLAB para manipulação simbólica e numérica.",
                                "Física: Princípios de energia em sistemas vibratórios acoplados.",
                                "Engenharia de Controle: Análise de estabilidade via root locus.",
                                "Computação Científica: Integração numérica para simulações transientes."
                              ],
                              "realWorldApplication": "Esse modelo é usado no design de asas de aeronaves (ex: Boeing 787) para prever e evitar flutter, garantindo segurança em regimes transônicos via testes em túnel de vento e certificação FAA."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.2.2",
                            "name": "Aplicar método V-g para previsão de flutter",
                            "description": "Utilizar o método V-g para determinar a velocidade de flutter, resolvendo numericamente as equações lineares em função do número de V e fatores de amortecimento estrutural.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar os parâmetros do modelo estrutural e aerodinâmico",
                                  "subSteps": [
                                    "Definir os graus de liberdade (ex: mergulho h e torção α)",
                                    "Coletar propriedades modais: frequências naturais, massas generalizadas e modos",
                                    "Obter coeficientes aerodinâmicos (ex: função de Theodorsen C(k)) para o número reduzido k",
                                    "Especificar fatores de amortecimento estrutural (μ_h, μ_α)",
                                    "Calcular o número de V inicial (V*) e definir tolerâncias numéricas"
                                  ],
                                  "verification": "Verificar se todos os parâmetros estão dimensionados corretamente e unidades consistentes (ex: V em m/s, k adimensional)",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Planilha ou software como MATLAB/Excel para organização de dados",
                                    "Referências: Scanlan & Rosenbaum ou Fung 'An Introduction to Aeroelasticity'"
                                  ],
                                  "tips": "Comece com um modelo simples de 2 DOF para validação antes de modelos complexos",
                                  "learningObjective": "Entender os insumos necessários para o método V-g e sua interdependência",
                                  "commonMistakes": [
                                    "Unidades inconsistentes entre sistemas imperial e métrico",
                                    "Esquecimento de normalizar massas e rigidezes",
                                    "Valores iniciais de V muito distantes da solução"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular as equações de movimento lineares acopladas",
                                  "subSteps": [
                                    "Montar as matrizes de massa [M], amortecimento [G] e rigidez [K] estruturais",
                                    "Incorporar forças aerodinâmicas lineares nas matrizes [M_a], [G_a], [K_a]",
                                    "Combinar em equações desacopladas: [M_r]{q''} + [G_r(V,g)]{q'} + [K_r(V)]{q} = 0",
                                    "Expressar em termos de velocidades complexas λ = g + iω",
                                    "Verificar simetria e propriedades das matrizes"
                                  ],
                                  "verification": "Resolver para V fixo e g=0 deve dar frequências reais próximas às modais não acopladas",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software simbólico como MATLAB Symbolic Toolbox ou Python SymPy",
                                    "Templates de matrizes de exemplos padrão"
                                  ],
                                  "tips": "Use notação matricial consistente para evitar erros de transposição",
                                  "learningObjective": "Dominar a formulação matemática das equações aeroelásticas lineares",
                                  "commonMistakes": [
                                    "Inversão errada da matriz de massa",
                                    "Sinal incorreto nos termos aerodinâmicos de amortecimento",
                                    "Não considerar acoplamento cruzado h-α"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a solução numérica iterativa V-g",
                                  "subSteps": [
                                    "Inicializar V = V* e g = 0",
                                    "Para cada iteração: resolver autovalores complexos da matriz de estado",
                                    "Extrair partes real (g) e imaginária (ω) dos autovalores",
                                    "Atualizar V novo baseado na média dos autovalores com maior damping negativo",
                                    "Iterar até convergência (|ΔV| < tolerância e max|g| < ε)"
                                  ],
                                  "verification": "O loop converge em menos de 20 iterações e g estabiliza próximo de zero",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Código MATLAB ou Python (NumPy/SciPy para eig)",
                                    "Função de Theodorsen implementada"
                                  ],
                                  "tips": "Use solver eig robusto e monitore resíduos de convergência em gráfico",
                                  "learningObjective": "Aplicar algoritmos numéricos para extração de autovalores em problemas não lineares paramétricos",
                                  "commonMistakes": [
                                    "Loop infinito por tolerância muito baixa",
                                    "Seleção errada do autovalor dominante",
                                    "Não reescalar frequências reduzidas k = ω b / V"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar resultados, plotar curvas V-g e validar",
                                  "subSteps": [
                                    "Plotar curvas V vs g para todos os modos",
                                    "Identificar V_flutter como interseção com eixo g=0",
                                    "Comparar com soluções analíticas ou experimentais conhecidas",
                                    "Analisar sensibilidade a variações de amortecimento estrutural",
                                    "Documentar limitações do método (ex: linearidade, subsonico)"
                                  ],
                                  "verification": "Gráfico V-g mostra coalescência de frequências e V_f > V_operacional",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "MATLAB plot ou Matplotlib Python",
                                    "Dados de benchmark como ala típica NACA 0012"
                                  ],
                                  "tips": "Salve múltiplas rodadas para estudo paramétrico",
                                  "learningObjective": "Interpretar curvas V-g e extrair insights de estabilidade",
                                  "commonMistakes": [
                                    "Interpretação errada da interseção (deve ser g=0 exato)",
                                    "Ignorar modos espúrios numéricos",
                                    "Não normalizar plots para comparação"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma seção de asa típica com rα²=0.5, xα=-0.2, ωh/ωα=0.5, μg=100, μθ=50. Use Theodorsen C(k) aproximado. Inicial V*=10, espessura b=1m, ρ=1.225 kg/m³. O método converge para V_flutter ≈ 12.5 m/s com coalescência de modos h e α.",
                              "finalVerifications": [
                                "Curvas V-g exibem pelo menos um ponto de interseção com g=0",
                                "Velocidade de flutter calculada converge independentemente do V inicial",
                                "Frequências em V_flutter mostram coalescência de dois modos",
                                "Resultados sensíveis a ±10% em amortecimento alteram V_f em <5%",
                                "Validação contra exemplo padrão (ex: Fung cap. 6) com erro <2%",
                                "Código executável reproduz resultados em máquina padrão"
                              ],
                              "assessmentCriteria": [
                                "Precisão da formulação matricial (verificação manual de 3 termos chave)",
                                "Convergência numérica robusta (sucesso em 3 V* iniciais diferentes)",
                                "Interpretação correta de V_flutter e modos coalescentes",
                                "Análise de sensibilidade documentada",
                                "Código limpo, comentado e reutilizável",
                                "Relatório com plots claros e conclusões quantitativas"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de autovalores e decomposição matricial",
                                "Programação: Algoritmos iterativos e solvers numéricos (eig)",
                                "Física: Dinâmica linear e vibrações forçadas",
                                "Engenharia Mecânica: Análise modal e estabilidade estrutural",
                                "Computação Científica: Modelagem multiphysics"
                              ],
                              "realWorldApplication": "No projeto de aeronaves como o F-16 ou drones, o método V-g é usado para prever V_flutter durante a fase conceitual, garantindo margem de segurança de 15-20% acima da velocidade máxima de operação e evitando falhas catastróficas como o Tacoma Narrows em pontes ou flutter em caudas de aviões."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.2.3",
                            "name": "Interpretar diagrama de raízes para estabilidade",
                            "description": "Analisar o locus das raízes das equações características em função da velocidade dinâmica para identificar o ponto de coalescência de modos e onset de flutter.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar equações características do sistema aeroelástico",
                                  "subSteps": [
                                    "Obtenha as equações de movimento acopladas do sistema (ex.: equações de Flutter com graus de liberdade estruturais e aerodinâmicos).",
                                    "Derive a equação característica determinantal: det([M]λ² + [C + C_a]λ + [K + K_a]) = 0, onde λ são as raízes complexas.",
                                    "Identifique parâmetros dependentes da velocidade dinâmica V (ex.: coeficientes aerodinâmicos via teoria de Theodorsen ou pistão).",
                                    "Liste os modos iniciais (flexão, torção) e suas frequências naturais em V=0.",
                                    "Verifique linearidade e hipóteses de small perturbations."
                                  ],
                                  "verification": "Confirme que a equação característica está corretamente formulada e dependente de V, com todos os termos acoplados identificados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notas de aula sobre aeroelasticidade, software MATLAB/Simulink para derivação simbólica, calculadora científica.",
                                  "tips": "Comece com um modelo de 2-DOF (heaving + pitching) para simplicidade antes de sistemas complexos.",
                                  "learningObjective": "Compreender como as raízes λ governam a estabilidade dinâmica em função de V.",
                                  "commonMistakes": "Ignorar acoplamento aerodinâmico ou confundir velocidade dinâmica (V/qS) com velocidade verdadeira."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o diagrama de raízes (root locus) versus velocidade dinâmica",
                                  "subSteps": [
                                    "Defina o parâmetro de varredura: velocidade dinâmica k = V / (b ω_α √(μ)), onde b é semi-corda, ω_α frequência torcional, μ massa reduzida.",
                                    "Use método numérico (ex.: scan de V de 0 a 2V_crítico) para calcular raízes λ(k) resolvendo o polinômio característico.",
                                    "Plote Re(λ) vs. Im(λ) para cada modo, traçando o locus à medida que k aumenta.",
                                    "Marque pontos chave: V=0 (raízes reais negativas), evolução dos modos.",
                                    "Valide com software: rlocus() no MATLAB adaptado para sistemas não-lineares em parâmetro."
                                  ],
                                  "verification": "O diagrama mostra loci suaves sem saltos, com raízes corretas em V=0 comparadas a valores analíticos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "MATLAB ou Python (SciPy para raízes polinomiais), planilha Excel para varredura manual, exemplos de root locus de livros como Bisplinghoff.",
                                  "tips": "Use resolução fina em k para capturar curvas precisas perto da instabilidade.",
                                  "learningObjective": "Gerar visualmente o comportamento das raízes complexas com variação de V.",
                                  "commonMistakes": "Escala errada no eixo (usar freq. reduzida ω*b/V), ou plotar vs. V absoluta em vez de dinâmica."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar coalescência de modos e onset de flutter",
                                  "subSteps": [
                                    "Examine os loci: procure aproximação de dois modos (ex.: flexão e torção) com frequências similares.",
                                    "Localize o ponto de coalescência: onde dois loci se encontram em λ complexo com Re(λ)<0.",
                                    "Continue o scan: identifique V_flutter onde loci cruzam o eixo imaginário (Re(λ)=0, ω_flutter ≠0).",
                                    "Calcule V_flutter interpolando entre pontos próximos ao cruzamento.",
                                    "Confirme histerese ou bifurcação se aplicável."
                                  ],
                                  "verification": "Ponto de coalescência e V_flutter marcados com valores numéricos precisos (±1% erro).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Diagrama plotado do Step 2, régua digital ou zoom no software para interpolação.",
                                  "tips": "Procure coalescência em ~0.7-0.9 V_flutter; use zoom para precisão no cruzamento.",
                                  "learningObjective": "Reconhecer padrões gráficos indicativos de perda de estabilidade flutter.",
                                  "commonMistakes": "Confundir coalescência (Re<0) com flutter (Re=0), ou ignorar modos espúrios."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar estabilidade geral e implicações",
                                  "subSteps": [
                                    "Classifique regiões: estável (todos Re(λ)<0), instável pós-flutter.",
                                    "Calcule margens: V_crítico = V_flutter * fator de segurança (ex.: 1.15).",
                                    "Avalie sensibilidade: varie massa, rigidez ou aerodinâmica e re-plote.",
                                    "Documente frequências de flutter e modos dominantes.",
                                    "Compare com critérios alternativos (ex.: k-method)."
                                  ],
                                  "verification": "Relatório resume V_flutter, modos coalescentes e margens com justificativa gráfica.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Software para análise de sensibilidade, template de relatório.",
                                  "tips": "Sempre inclua fator de segurança conforme FAR/JAR regulamentos.",
                                  "learningObjective": "Interpretar o diagrama para decisões de design aeroelástico.",
                                  "commonMistakes": "Declarar estabilidade sem verificar todos os modos, ou superestimar V_flutter por resolução grosseira."
                                }
                              ],
                              "practicalExample": "Em um modelo de asa típica (NACA 0012, 2-DOF), com μ=100, x_α=-0.2, r_α²=0.25, plotar root locus vs. k mostra coalescência dos modos de flexão (ω_h) e torção (ω_α) em k≈0.12, com flutter em k_flutter=0.15 (V_flutter≈120 m/s), evitando design acima dessa velocidade.",
                              "finalVerifications": [
                                "Diagrama de root locus corretamente plotado com todos os modos visíveis.",
                                "Ponto de coalescência identificado com coordenadas λ exatas.",
                                "V_flutter calculado com erro <5% comparado a solução analítica.",
                                "Regiões de estabilidade claramente delimitadas.",
                                "Análise de sensibilidade realizada para pelo menos um parâmetro.",
                                "Relatório explica física do flutter (energia aerodinâmica)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação e plotagem do root locus (40%).",
                                "Correta identificação de coalescência e V_flutter (30%).",
                                "Profundidade da análise de estabilidade e sensibilidade (15%).",
                                "Clareza visual e documentação do diagrama (10%).",
                                "Conexão com conceitos físicos de aeroelasticidade (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de valores e vetores próprios, loci de raízes em sistemas paramétricos.",
                                "Física: Dinâmica linear, oscilações forçadas e amortecimento.",
                                "Engenharia de Controle: Estabilidade de sistemas de malha fechada.",
                                "Computação: Programação numérica para resolução de polinômios e visualização."
                              ],
                              "realWorldApplication": "Na certificação de aeronaves (ex.: Boeing 787), engenheiros usam root locus para prever e mitigar flutter em asas, garantindo operação segura até V_dive +15%, evitando acidentes como o do Tacoma Narrows Bridge adaptado à aeroelasticidade."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.2.4",
                            "name": "Incorporar amortecimento de Rayleigh",
                            "description": "Incluir modelo de amortecimento proporcional de Rayleigh nas equações de flutter e avaliar seu efeito na previsão da velocidade crítica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos do Amortecimento de Rayleigh",
                                  "subSteps": [
                                    "Estude a definição de amortecimento proporcional de Rayleigh: C = αM + βK, onde α e β são coeficientes de massa e rigidez.",
                                    "Revise as equações de movimento livres: M ü + C ú + K u = 0.",
                                    "Analise as propriedades modais: assuma modos uncoupled para decouple as equações.",
                                    "Calcule os fatores de amortecimento modal: ζ_i = (α / (2 ω_i)) + (β ω_i / 2).",
                                    "Pratique com um sistema de 2 graus de liberdade (2DOF) simples para visualizar o efeito."
                                  ],
                                  "verification": "Resolva um exemplo 2DOF e confirme que os fatores de amortecimento modais são positivos e razoáveis (ζ_i entre 0.01-0.05).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Dinâmica das Estruturas (Clough & Penzien)",
                                    "MATLAB ou Python (NumPy/SciPy)",
                                    "Notas de aula sobre modais"
                                  ],
                                  "tips": "Escolha α e β para simular amortecimento leve, típico de estruturas aeroespaciais (ex: α=0.1, β=0.001).",
                                  "learningObjective": "Compreender a formulação matemática e propriedades do amortecimento de Rayleigh em sistemas multi-DOF.",
                                  "commonMistakes": [
                                    "Confundir α com β (massa vs rigidez)",
                                    "Ignorar o acoplamento modal inicial",
                                    "Usar valores de α/β que levam a amortecimento excessivo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Incorporar Amortecimento de Rayleigh nas Equações de Flutter",
                                  "subSteps": [
                                    "Comece com as equações aeroelásticas padrão sem amortecimento: M ü + K u = Q(ρ, V, k) ü + Q(ρ, V, k) ú + Q(ρ, V, k) u.",
                                    "Adicione o termo de amortecimento: M ü + C ú + K u = Q_aero.",
                                    "Defina C = αM + βK e substitua nas equações completas.",
                                    "Expresse em coordenadas modais: Φ^T M Φ = I, Φ^T K Φ = Ω^2, e adapte para C_modal.",
                                    "Verifique a dimensionalidade: garanta que Q_aero inclua forças aerodinâmicas em função da velocidade V e frequência reduzida k."
                                  ],
                                  "verification": "Escreva as equações modais completas com C incluído e confirme que o sistema é do tipo [ -ω^2 M + iω C + K - Q ] {q} = 0.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de análise aeroelástica (ex: NASTRAN ou código próprio em MATLAB)",
                                    "Tabelas de coeficientes aerodinâmicos (teoria de Theodorsen)",
                                    "Artigo sobre flutter com damping"
                                  ],
                                  "tips": "Use modos reais da estrutura para simplificar; assuma ortonormalidade Φ^T M Φ = I.",
                                  "learningObjective": "Formular corretamente as equações de flutter acopladas com amortecimento proporcional.",
                                  "commonMistakes": [
                                    "Esquecer de transformar Q_aero para coordenadas modais",
                                    "Aplicar Rayleigh apenas em massa, ignorando rigidez",
                                    "Não normalizar os modos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver o Problema de Autovalores para Análise de Flutter",
                                  "subSteps": [
                                    "Monte a matriz complexa de autovalores: A(ω, V) = -ω^2 M + iω C + (K - Q(ρV^2, k)) = 0.",
                                    "Use o método V-g (ou equivalente) para varrer V e encontrar V_crítica onde damping real cruza zero.",
                                    "Implemente numericamente em loop: incremente V, resolva autovalores, extraia partes real/imaginária das frequências.",
                                    "Inclua iterações para k = ω b / V (frequência reduzida).",
                                    "Compare soluções com e sem amortecimento para o mesmo modelo."
                                  ],
                                  "verification": "Gere gráfico de damping vs V; identifique V_flutter sem damping e com Rayleigh.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "MATLAB com eig() ou Python (scipy.linalg.eig)",
                                    "Modelo de flutter típico (ex: ala cantilever 2DOF)",
                                    "Códigos de exemplo de flutter analysis"
                                  ],
                                  "tips": "Use V-g method para eficiência: reformule como problema linear em g (damping param).",
                                  "learningObjective": "Implementar e resolver numericamente a análise de flutter com amortecimento.",
                                  "commonMistakes": [
                                    "Não atualizar k dentro do loop",
                                    "Ignorar ρ na Q_aero",
                                    "Confundir parte real (damping) com imaginária (frequência)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar o Efeito na Velocidade Crítica de Flutter",
                                  "subSteps": [
                                    "Compare V_cr sem damping (V0) vs com Rayleigh (V_Ray): calcule ΔV = (V_Ray - V0)/V0 * 100%.",
                                    "Analise sensibilidade: varie α e β, plote ΔV vs ζ_modal médio.",
                                    "Discuta limitações: Rayleigh assume amortecimento modal constante, valide com dados experimentais.",
                                    "Gere relatório com gráficos: root locus de autovalores, V-g plots.",
                                    "Conclua sobre conservadorismo: tipicamente, Rayleigh aumenta V_cr em 10-20%."
                                  ],
                                  "verification": "Demonstre que V_cr aumenta com amortecimento e quantifique o efeito para α=0.05, β=0.0005.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Gráficos em MATLAB/Origin",
                                    "Dados experimentais de flutter (ex: de túnel de vento)"
                                  ],
                                  "tips": "Para validação, use modelo benchmark como o de Theodorsen-Garrick.",
                                  "learningObjective": "Quantificar e interpretar o impacto do amortecimento de Rayleigh na previsão de flutter.",
                                  "commonMistakes": [
                                    "Superestimar o efeito sem calibração de α/β",
                                    "Não considerar efeitos não-lineares",
                                    "Ignorar acoplamento flutter-torsional"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma asa reta cantilever típica (2DOF: bending-torsion) com propriedades: L=2m, EI=1e6 Nm², GJ=1e5 Nm², massa uniforme. Use teoria de Theodorsen para Q_aero, aplique Rayleigh com α=0.1 s^-1, β=0.001 s, e mostre que V_cr aumenta de 25 m/s para 28 m/s.",
                              "finalVerifications": [
                                "Equações incluem corretamente C = αM + βK.",
                                "Gráficos V-g mostram coalescência de modos com damping positivo até V_cr.",
                                "ΔV_cr > 0 com Rayleigh, quantificado numericamente.",
                                "Análise de sensibilidade para faixa de α/β.",
                                "Validação contra caso sem damping converge.",
                                "Relatório discute limitações do modelo."
                              ],
                              "assessmentCriteria": [
                                "Precisão das equações derivadas (100% match com referências).",
                                "Correção numérica: erro em V_cr < 1%.",
                                "Qualidade dos gráficos e análise sensível.",
                                "Interpretação física do efeito do damping.",
                                "Documentação clara de código e passos.",
                                "Identificação de pelo menos 3 limitações do Rayleigh em flutter."
                              ],
                              "crossCurricularConnections": [
                                "Análise Numérica: Solução de autovalores complexos (Engenharia Computacional).",
                                "Controle de Sistemas: Estabilidade via root locus e damping ratios.",
                                "Mecânica dos Fluidos: Modelos aerodinâmicos unsteady (Theodorsen).",
                                "Otimização: Calibração de α/β via minimização de erro experimental.",
                                "Programação: Implementação em MATLAB/Python para simulações dinâmicas."
                              ],
                              "realWorldApplication": "Em projetos de aeronaves (ex: Boeing 787), o amortecimento de Rayleigh é usado em NASTRAN para prever margens de flutter, permitindo designs mais leves e eficientes ao quantificar o aumento na velocidade crítica de divergência dinâmica, evitando testes caros em túnel de vento."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.3",
                        "name": "Análise de Estabilidade em Modelos Modais",
                        "description": "Abordagem baseada em modos normais para análise de estabilidade aeroelástica em estruturas com múltiplos graus de liberdade.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.3.1",
                            "name": "Formular modelo aeroelástico modal",
                            "description": "Desenvolver o modelo dinâmico aeroelástico utilizando coordenadas modais, ortogonalidade de modos e redução modal para estruturas discretizadas por elementos finitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Realizar discretização estrutural por Elementos Finitos",
                                  "subSteps": [
                                    "Definir geometria da estrutura (ex.: asa cantilever) e propriedades materiais (módulo de elasticidade, densidade).",
                                    "Escolher tipo de elemento finito (beam, shell) e dividir em malha com n elementos.",
                                    "Montar matriz global de rigidez [K] e massa [M] usando funções de forma e integração numérica.",
                                    "Aplicar condições de contorno (ex.: fixação na raiz da asa).",
                                    "Verificar simetria e propriedades das matrizes."
                                  ],
                                  "verification": "Matrizes [K] e [M] são simétricas positivas definidas; plotar modos iniciais.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Software EF (ANSYS, NASTRAN ou MATLAB com código EF)",
                                    "Propriedades materiais de compósitos aeroespaciais"
                                  ],
                                  "tips": "Comece com malha grosseira para testes rápidos e refine iterativamente.",
                                  "learningObjective": "Construir modelo discreto estrutural preciso para dinâmica.",
                                  "commonMistakes": [
                                    "Malha inadequada levando a frequências erradas",
                                    "Esquecimento de condições de contorno",
                                    "Inconsistência de unidades (SI)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Obter propriedades modais via análise modal",
                                  "subSteps": [
                                    "Resolver problema de autovalores: ([K] - ω²[M]){φ} = 0 para obter frequências ω_i e modos {φ_i}.",
                                    "Verificar ortogonalidade: {φ_i}^T [M] {φ_j} = δ_ij e {φ_i}^T [K] {φ_j} = ω_i² δ_ij.",
                                    "Normalizar modos (mass-normalized).",
                                    "Selecionar primeiros m modos relevantes (baseado em energia modal).",
                                    "Plotar formas modais para inspeção visual."
                                  ],
                                  "verification": "Ortogonalidade confirmada numericamente (erro < 1e-10); m modos capturam >95% energia.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Solver de autovalores (MATLAB eig() ou similar)",
                                    "Ferramentas de visualização (ParaView)"
                                  ],
                                  "tips": "Use decomposição QR para grandes matrizes; selecione modos até convergência.",
                                  "learningObjective": "Entender análise modal e propriedades ortogonais para redução.",
                                  "commonMistakes": [
                                    "Seleção insuficiente de modos",
                                    "Normalização incorreta",
                                    "Ignorar modos rígidos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular equações aeroelásticas em coordenadas modais",
                                  "subSteps": [
                                    "Expressar deslocamentos {u} = [Φ]{q}, onde [Φ] = [{φ_1}, ..., {φ_m}] e {q} vetor modal.",
                                    "Substituir nas equações de movimento acopladas: [M]{ü} + [K]{u} + [Q(ρ,U)]{u} = 0.",
                                    "Usar ortogonalidade para decoplar: ï + 2ζ_i ω_i q̇_i + ω_i² q_i + termos aero = 0.",
                                    "Calcular matrizes de acoplamento aerodinâmico [A_ij] = {φ_i}^T [Q]{φ_j}.",
                                    "Incluir aerodinâmica (ex.: teoria de painel ou VLM para forças)."
                                  ],
                                  "verification": "Equações modais desacopladas ou fracamente acopladas; plotar matriz [A].",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Códigos de aerodinâmica (Tornado, XFLR5)",
                                    "MATLAB/SciPy para manipulação matricial"
                                  ],
                                  "tips": "Implemente em código para automação; teste com velocidades baixas.",
                                  "learningObjective": "Transformar modelo físico em coordenadas modais reduzidas.",
                                  "commonMistakes": [
                                    "Erro na projeção modal",
                                    "Negligenciar dependência de velocidade Mach",
                                    "Assumir acoplamento zero prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar redução modal e validar o modelo",
                                  "subSteps": [
                                    "Definir critérios de truncamento modal (ex.: Guyan ou Craig-Bampton para híbrido).",
                                    "Formar modelo reduzido com m << N graus de liberdade.",
                                    "Comparar frequências reduzidas vs. full-order.",
                                    "Simular resposta dinâmica (ex.: varredura V-g para flutter).",
                                    "Documentar modelo final e sensibilidade a parâmetros."
                                  ],
                                  "verification": "Erro de redução <5% em frequências; convergência com mais modos.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Ferramentas de simulação dinâmica (SIMULINK, Python ODE)",
                                    "Gráficos V-g"
                                  ],
                                  "tips": "Use truncamento estático para modos estáticos; valide com dados experimentais.",
                                  "learningObjective": "Criar modelo eficiente para análise de estabilidade aeroelástica.",
                                  "commonMistakes": [
                                    "Redução excessiva perdendo física",
                                    "Não validar contra full model",
                                    "Ignorar não-linearidades"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma asa cantilever de perfil NACA 0012 discretizada com 20 elementos beam EF, obtenha 6 modos flexurais, projete forças aerodinâmicas via doublet-lattice, formule equações modais e detecte velocidade de flutter em Mach 0.8.",
                              "finalVerifications": [
                                "Matrizes modais desacopladas com ortogonalidade verificada.",
                                "Frequências modais reduzidas coincidem com full-order (erro <3%).",
                                "Modelo prediz velocidade crítica de flutter corretamente.",
                                "Formas modais visualizadas e energia modal >98%.",
                                "Equações finais em forma padrão para solver de autovalores.",
                                "Sensibilidade a número de modos documentada."
                              ],
                              "assessmentCriteria": [
                                "Precisão das matrizes [K] e [M] (erro numérico <1e-12).",
                                "Correta aplicação de ortogonalidade e normalização modal.",
                                "Integração precisa de forças aerodinâmicas dependentes de fluxo.",
                                "Eficiência da redução (tempo computacional reduzido >90%).",
                                "Validação quantitativa vs. benchmarks conhecidos.",
                                "Clareza na documentação do modelo derivado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (autovalores, decomposições modais).",
                                "Física: Dinâmica de vibrações e teoria de flutter.",
                                "Informática: Programação numérica (MATLAB/Python para EF e solvers).",
                                "Engenharia Mecânica: Análise de estruturas aeroespaciais.",
                                "Aerodinâmica: Modelos de pressão unsteady (teoria de painel)."
                              ],
                              "realWorldApplication": "Previsão de instabilidades aeroelásticas como flutter em projetos de aeronaves (ex.: Boeing 787), hélices e turbinas eólicas, garantindo segurança certificada pela FAA/EASA via simulações modais reduzidas."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.3.2",
                            "name": "Avaliar estabilidade via análise modal",
                            "description": "Realizar análise de estabilidade determinando frequências e amortecimentos modais efetivos sob carregamento aerodinâmico, identificando modos críticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar o modelo modal da estrutura",
                                  "subSteps": [
                                    "Coletar dados modais da estrutura: frequências naturais, formas modais e matriz de massas/amortecimentos.",
                                    "Construir o modelo matemático usando equações de movimento: [M]{¨q} + [C]{˙q} + [K]{q} = {F}.",
                                    "Normalizar as formas modais para garantir ortogonalidade.",
                                    "Validar o modelo com dados experimentais de vibração livre.",
                                    "Documentar propriedades modais iniciais em uma tabela."
                                  ],
                                  "verification": "Verificar se as frequências naturais coincidem com testes experimentais dentro de 5% de erro.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software de análise modal (ex: NASTRAN, MATLAB), dados experimentais de vibração, planilha para tabelas"
                                  ],
                                  "tips": "Use modos dominantes (primeiros 10-20) para reduzir complexidade computacional.",
                                  "learningObjective": "Compreender e preparar o modelo modal uncoupled para análise aeroelástica.",
                                  "commonMistakes": [
                                    "Ignorar modos de torção ou flexão acoplados",
                                    "Não normalizar formas modais",
                                    "Usar dados experimentais inconsistentes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar o carregamento aerodinâmico",
                                  "subSteps": [
                                    "Definir parâmetros de fluxo: velocidade do ar (V), densidade (ρ), ângulo de ataque (α).",
                                    "Calcular forças aerodinâmicas usando teoria de Theodorsen ou método de matriz aerodinâmica [A(V)].",
                                    "Incorporar o carregamento na equação modal: [M]{¨q} + [C]{˙q} + ([K] - [A(V)]){q} = 0.",
                                    "Gerar matriz aerodinâmica para frequências complexas usando V-g ou k-ω methods.",
                                    "Plotar coeficientes aerodinâmicos vs. frequência reduzida."
                                  ],
                                  "verification": "Confirmar que a matriz aerodinâmica é simétrica e dependente da velocidade do fluxo.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Ferramentas de aeroelasticidade (ex: ZAERO, MATLAB Aero Toolbox), tabelas de coeficientes aerodinâmicos"
                                  ],
                                  "tips": "Comece com perfis 2D simplificados antes de modelos 3D.",
                                  "learningObjective": "Integrar forças aerodinâmicas no modelo modal para capturar efeitos uncoupled.",
                                  "commonMistakes": [
                                    "Negligenciar dependência em frequência da aerodinâmica",
                                    "Usar coeficientes estáticos em vez de dinâmicos",
                                    "Erro na definição da frequência reduzida k = ω b / V"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular frequências e amortecimentos modais efetivos",
                                  "subSteps": [
                                    "Resolver o problema de autovalores complexo: det([K] - ω²[M] + iω[C] - [A(ω)]) = 0.",
                                    "Extrair frequências reais (ω_r) e amortecimentos efetivos (ζ_eff = -Im(ω)/|ω|).",
                                    "Iterar sobre velocidades de fluxo (V) para gerar curvas V-ω-ζ.",
                                    "Plotar curvas de amortecimento vs. velocidade para todos os modos.",
                                    "Identificar regiões de amortecimento negativo."
                                  ],
                                  "verification": "Verificar convergência numérica com malha fina de frequências; erro <1%.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Software numérico (ex: eigenvalue solvers em Python/Scipy, MATLAB eig), scripts de automação"
                                  ],
                                  "tips": "Use métodos p-k para iteração estável em problemas não-lineares em ω.",
                                  "learningObjective": "Determinar respostas modais sob carregamento aerodinâmico acoplado.",
                                  "commonMistakes": [
                                    "Não iterar corretamente para ω complexa",
                                    "Confundir amortecimento estrutural com efetivo",
                                    "Escala errada nas curvas V-g"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar modos críticos e avaliar estabilidade",
                                  "subSteps": [
                                    "Analisar curvas V-ζ: identificar velocidades de flutter (V_f) onde ζ=0.",
                                    "Classificar modos críticos por menor margem de amortecimento ou acoplamento.",
                                    "Calcular fatores de segurança: V_div / V_f > 1.15 (regulatório).",
                                    "Simular resposta transitória para validar modos críticos.",
                                    "Gerar relatório com recomendações de reforço estrutural."
                                  ],
                                  "verification": "Modo crítico mostra cruzamento de curvas ou ζ<0; confirmado por simulação.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Gráficos de V-g, V-ω; software de simulação dinâmica (ex: SIMULINK)"
                                  ],
                                  "tips": "Priorize modos com alta forma modal na asa ou empenagem.",
                                  "learningObjective": "Interpretar resultados para decisões de design aeroelástico.",
                                  "commonMistakes": [
                                    "Focar apenas no modo fundamental",
                                    "Ignorar efeitos não-lineares em alto V",
                                    "Não considerar margens de segurança"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma asa de aeronave em modelo reduzido (escala 1:10), configure o modelo modal com 6 modos flexurais/torcionais. Aplique carregamento aerodinâmico a 80 m/s usando Theodorsen. Calcule ζ_eff para modo 2-1 (flexão-torção), identifique flutter em 95 m/s e recomende aumento de rigidez torcional.",
                              "finalVerifications": [
                                "Curvas V-ω-ζ geradas para todos os modos relevantes.",
                                "Velocidade de flutter (V_f) determinada com precisão <5%.",
                                "Modos críticos identificados com formas modais associadas.",
                                "Margens de estabilidade atendem critérios regulatórios (ex: FAR 25).",
                                "Relatório inclui plots e recomendações acionáveis.",
                                "Validação cruzada com dados experimentais de túnel de vento."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos cálculos modais (erro <3% em frequências).",
                                "Correta modelagem aerodinâmica (coerência com literatura).",
                                "Identificação precisa de modos críticos e V_f.",
                                "Qualidade dos plots e interpretação física.",
                                "Relatório completo e bem estruturado.",
                                "Eficiência computacional (tempo de execução razoável)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Solução de problemas de autovalores complexos e análise matricial.",
                                "Física: Dinâmica de vibrações amortecidas e teoria de flutter.",
                                "Engenharia de Controle: Análise de estabilidade em laços fechados.",
                                "Computação: Programação numérica e visualização de dados.",
                                "Design Aeronáutico: Integração com CFD e testes em túnel."
                              ],
                              "realWorldApplication": "Na certificação de aeronaves como o Boeing 787, análise modal avalia estabilidade aeroelástica para prevenir flutter em asas compostas, garantindo operação segura até velocidades de cruzeiro Mach 0.85."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.3.3",
                            "name": "Relacionar com ensaios experimentais",
                            "description": "Comparar previsões teóricas de estabilidade com resultados de ensaios em túnel de vento, discutindo discrepâncias devido a efeitos não lineares ou aerodinâmica não estacionária.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar previsões teóricas de estabilidade aeroelástica",
                                  "subSteps": [
                                    "Revisar o modelo modal teórico da estrutura (modos, frequências naturais, formas modais).",
                                    "Calcular previsões de estabilidade usando critérios como V-g ou k-method, considerando parâmetros aerodinâmicos lineares.",
                                    "Documentar premissas teóricas, como fluxo estacionário e linearidade.",
                                    "Gerar gráficos de margens de estabilidade (ex: velocidade de flutter vs. densidade).",
                                    "Validar o modelo teórico com dados conhecidos de literatura."
                                  ],
                                  "verification": "Verificar se as curvas de estabilidade teóricas foram plotadas e coincidem com referências padrão.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Software de análise modal (NASTRAN, MATLAB), equações de Theodorsen, artigos de referência sobre flutter.",
                                  "tips": "Use unidades consistentes (ex: Mach, Reynolds) para evitar erros de escala.",
                                  "learningObjective": "Dominar a geração de previsões teóricas baseadas em análise modal linear.",
                                  "commonMistakes": "Ignorar acoplamento fluido-estrutura ou assumir rigidez infinita."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Coletar e processar dados experimentais de túnel de vento",
                                  "subSteps": [
                                    "Selecionar dados de ensaios relevantes (ex: modelo em escala de asa com sensores de pressão e acelerômetros).",
                                    "Processar sinais experimentais: filtrar ruído, calcular amplitudes de vibração e frequências.",
                                    "Identificar condições de teste (velocidades, ângulos de ataque, Re number).",
                                    "Plotar respostas experimentais (ex: diagrama de oscilação harmônica vs. velocidade dinâmica).",
                                    "Determinar velocidades críticas experimentais de instabilidade."
                                  ],
                                  "verification": "Confirmar que dados processados mostram picos claros de amplitude indicando onset de flutter.",
                                  "estimatedTime": "5-7 horas",
                                  "materials": "Dados de túnel de vento (NASA, ONERA), software de processamento de sinal (LabVIEW, Python com SciPy).",
                                  "tips": "Normalizar dados por velocidade dinâmica para comparação direta.",
                                  "learningObjective": "Aprender a extrair métricas chave de ensaios experimentais aeroelásticos.",
                                  "commonMistakes": "Não corrigir por escalas de modelo (efeito de Reynolds) ou ruído não filtrado."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar previsões teóricas com resultados experimentais",
                                  "subSteps": [
                                    "Sobrepor gráficos teóricos e experimentais (ex: V-f vs. V-g diagrams).",
                                    "Calcular discrepâncias quantitativas (ex: % erro em V_flutter).",
                                    "Analisar qualitativamente padrões de divergência (ex: frequência de flutter).",
                                    "Realizar testes estatísticos (ex: correlação Pearson entre curvas).",
                                    "Documentar tabela de comparação com condições de teste."
                                  ],
                                  "verification": "Tabela e gráficos mostram sobreposição com métricas de erro calculadas.",
                                  "estimatedTime": "3-5 horas",
                                  "materials": "Ferramentas de plotagem (MATLAB, Python Matplotlib), planilhas (Excel).",
                                  "tips": "Use log-escala para amplitudes para destacar pequenas discrepâncias.",
                                  "learningObjective": "Desenvolver habilidades de comparação quantitativa entre teoria e experimento.",
                                  "commonMistakes": "Comparar em condições não equivalentes (ex: Ma vs. Re mismatch)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir discrepâncias atribuídas a efeitos não lineares e não estacionários",
                                  "subSteps": [
                                    "Identificar fontes de discrepância: não-linearidades estruturais (gap/lag), aerodinâmica não estacionária (vórtices).",
                                    "Explicar impactos: ex: efeitos de stall flutter ou transônicos.",
                                    "Referenciar literatura (ex: modelos de Leishman para não-estacionário).",
                                    "Propor ajustes teóricos (ex: incluir termos não-lineares via CFD).",
                                    "Escrever relatório com hipóteses testáveis para futuros ensaios."
                                  ],
                                  "verification": "Relatório discute pelo menos 3 causas específicas com evidências dos dados.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Artigos científicos (Scanlan, Fung), software CFD básico (XFOIL para 2D).",
                                  "tips": "Use PIV data se disponível para visualizar efeitos não estacionários.",
                                  "learningObjective": "Entender limitações de modelos lineares e raciocinar sobre física subjacente.",
                                  "commonMistakes": "Atribuir discrepâncias a 'erros experimentais' sem evidência."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar achados e propor melhorias",
                                  "subSteps": [
                                    "Resumir concordâncias e principais discrepâncias em um dashboard visual.",
                                    "Recomendar refinamentos teóricos (ex: acoplamento não-linear).",
                                    "Sugerir melhorias experimentais (ex: testes em regime transônico).",
                                    "Discutir implicações para design aeroespacial.",
                                    "Preparar apresentação com Q&A simulado."
                                  ],
                                  "verification": "Dashboard e relatório final com recomendações acionáveis.",
                                  "estimatedTime": "2-4 horas",
                                  "materials": "Ferramentas de visualização (Tableau, PowerPoint), template de relatório.",
                                  "tips": "Priorize discrepâncias >10% para foco.",
                                  "learningObjective": "Integrar análise para insights práticos em engenharia.",
                                  "commonMistakes": "Concluir sem quantificar incertezas."
                                }
                              ],
                              "practicalExample": "Em um modelo de asa em túnel de vento (ex: modelo NLR com rigidez torsional variável), a teoria prevê flutter a 45 m/s, mas experimento mostra 42 m/s; discrepância de 7% atribuída a aerodinâmica não estacionária observada via acelerômetros, discutida com wake unsteadiness.",
                              "finalVerifications": [
                                "Gráficos teóricos e experimentais sobrepostos com erros <15%.",
                                "Relatório discute ≥3 causas de discrepância com referências.",
                                "Tabela de comparação inclui condições de teste padronizadas.",
                                "Recomendações incluem testes adicionais específicos.",
                                "Apresentação resume achados em 5 slides claros.",
                                "Análise considera efeitos de escala (Re, Ma)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na preparação de previsões teóricas (80% match com benchmarks).",
                                "Qualidade de processamento de dados experimentais (ruído <5%).",
                                "Profundidade da comparação quantitativa (erros calculados e plotados).",
                                "Raciocínio físico nas discussões de discrepâncias (≥3 mecanismos).",
                                "Clareza e estrutura do relatório final.",
                                "Criatividade em recomendações para refinamento."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise modal e métodos eigenvalue.",
                                "Física: Dinâmica de fluidos não estacionários.",
                                "Engenharia Mecânica: Testes em túnel de vento.",
                                "Programação: Processamento de dados com Python/MATLAB.",
                                "Estatística: Análise de incertezas e correlações."
                              ],
                              "realWorldApplication": "No design de asas de aeronaves comerciais (ex: Boeing 787), essa análise previne flutter em voo, otimizando peso e segurança via iterações teoria-experimento, reduzindo custos de certificação FAA."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.4",
                    "name": "Resposta Aeroelástica",
                    "description": "Análise da resposta dinâmica de estruturas sob acoplamento aerodinâmico-elástico.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.4.1",
                        "name": "Acoplamento Aerodinâmico-Elástico",
                        "description": "Compreensão do fenômeno de interação entre forças aerodinâmicas e deformações elásticas em estruturas aeroespaciais, resultando em respostas dinâmicas acopladas.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.1.1",
                            "name": "Definir acoplamento aeroelástico",
                            "description": "Explicar o acoplamento aerodinâmico-elástico como a transferência de energia entre modos estruturais e fluxo aerodinâmico, utilizando equações de Lagrange com termos aerodinâmicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Modos Estruturais e Fluxo Aerodinâmico",
                                  "subSteps": [
                                    "Defina modos estruturais como padrões de vibração natural de uma estrutura aeroespacial, como flexão e torção em uma asa.",
                                    "Explique o fluxo aerodinâmico como o movimento do ar ao redor de uma estrutura em movimento, gerando forças como sustentação e arrasto.",
                                    "Identifique como esses modos interagem com o fluxo, levando a forças dependentes da deformação.",
                                    "Revise equações básicas de vibração livre: mẍ + cẋ + kx = 0.",
                                    "Discuta exemplos iniciais, como uma viga cantilever vibrando em fluxo uniforme."
                                  ],
                                  "verification": "Resuma em um parágrafo os modos estruturais e fluxo aerodinâmico, citando uma equação básica.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Aeroelasticity' de Bisplinghoff, vídeo introdutório sobre vibrações modais no YouTube, papel e caneta para esboços.",
                                  "tips": "Use analogias como um diapasão vibrando no vento para visualizar a interação.",
                                  "learningObjective": "Dominar definições e interações básicas entre estrutura e aerodinâmica.",
                                  "commonMistakes": "Confundir modos estruturais com modos aerodinâmicos; ignorar dependência do fluxo na velocidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar Equações de Lagrange para Sistemas Conservativos",
                                  "subSteps": [
                                    "Lembre a formulação Lagrangiana: L = T - V, onde T é energia cinética e V é potencial.",
                                    "Derive equações de movimento para um sistema estrutural simples: d/dt(∂L/∂q̇) - ∂L/∂q = 0.",
                                    "Aplique a uma asa modelada como um sistema de 2 graus de liberdade (flexão h e torção θ).",
                                    "Escreva expressões para T (cinética estrutural) e V (elástica).",
                                    "Verifique linearidade assumindo pequenas deformações."
                                  ],
                                  "verification": "Derive e escreva as equações de Lagrange para um sistema 2-DOF sem aerodinâmica.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software SymPy ou Mathematica para derivação simbólica, notas de dinâmica clássica, calculadora.",
                                  "tips": "Comece com coordenadas generalizadas simples para evitar erros de cálculo.",
                                  "learningObjective": "Aplicar Lagrange para modelar vibrações estruturais puras.",
                                  "commonMistakes": "Erros no cálculo de ∂L/∂q̇ (esquecer termos cruzados em T); assumir não-conservativo cedo demais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar Termos Aerodinâmicos nas Equações de Lagrange",
                                  "subSteps": [
                                    "Introduza forças aerodinâmicas não-conservativas via forças generalizadas Q_aero na equação de Lagrange.",
                                    "Modele Q_aero usando teoria de vórtices (teorema de Kutta-Joukowski) ou coeficientes aerodinâmicos dependentes de ângulo de ataque dinâmico.",
                                    "Expresse Q_aero em termos de velocidades modais: Q_h e Q_θ para flexão e torção.",
                                    "Linearize para pequenas amplitudes: inclua termos de acoplamento como L_{hθ} * θ̇.",
                                    "Discuta dependência da velocidade do fluxo V e densidade ρ."
                                  ],
                                  "verification": "Escreva as equações completas com Q_aero para o sistema 2-DOF.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Artigo clássico de Theodorsen sobre funções aerodinâmicas, planilha Excel para simulação numérica simples.",
                                  "tips": "Use matrizes de acoplamento aerodinâmico para organizar termos cruzados.",
                                  "learningObjective": "Integrar aerodinâmica no framework Lagrangiano.",
                                  "commonMistakes": "Ignorar retardo aerodinâmico (efeitos não-instantâneos); tratar Q_aero como conservativo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Transferência de Energia e Definição de Acoplamento Aeroelástico",
                                  "subSteps": [
                                    "Defina acoplamento aeroelástico como transferência de energia entre modos estruturais e fluxo via termos cruzados nas equações.",
                                    "Analise estabilidade: substitua soluções harmônicas e encontre velocidades críticas de flutter.",
                                    "Calcule trabalho aerodinâmico por ciclo: ∫ Q_aero * dq.",
                                    "Interprete: energia extraída do fluxo alimenta vibrações se V > V_flutter.",
                                    "Sintetize definição: 'Transferência de energia entre modos estruturais e fluxo aerodinâmico via equações de Lagrange acopladas'."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a transferência de energia com um diagrama de fluxo de energia.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Gráficos de resposta em frequência de MATLAB/Simulink, exemplos de casos reais como Tacoma Narrows.",
                                  "tips": "Visualize com plot de raízes do polinômio característico vs. V.",
                                  "learningObjective": "Definir e demonstrar acoplamento via análise energética.",
                                  "commonMistakes": "Confundir acoplamento com instabilidade; negligenciar termos não-lineares em análises iniciais."
                                }
                              ],
                              "practicalExample": "Considere uma asa cantilever de aeronave em túnel de vento: derive equações de Lagrange com termos aerodinâmicos de Theodorsen, simule em MATLAB para mostrar como torção induzida por flexão leva a flutter em V=150 m/s, transferindo energia do fluxo para amplificar vibrações.",
                              "finalVerifications": [
                                "Derivar corretamente equações de Lagrange acopladas com Q_aero.",
                                "Explicar transferência de energia com cálculo de trabalho aerodinâmico.",
                                "Identificar velocidade de flutter em um exemplo numérico simples.",
                                "Definir acoplamento aeroelástico em termos precisos e concisos.",
                                "Discutir implicações para estabilidade estrutural.",
                                "Resolver um problema de verificação envolvendo 2-DOF."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas de modos e acoplamento (30%).",
                                "Domínio matemático: derivação de equações sem erros (25%).",
                                "Análise qualitativa: explicação clara de transferência de energia (20%).",
                                "Exemplo prático: aplicação coerente a um caso real (15%).",
                                "Clareza e organização: estrutura lógica na explicação (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações diferenciais ordinárias e métodos de Lagrange.",
                                "Física: Dinâmica de fluidos e mecânica clássica.",
                                "Engenharia Mecânica: Análise modal e vibrações.",
                                "Computação: Simulação numérica em MATLAB ou Python.",
                                "Engenharia Aeronáutica: Projeto de asas e testes em túnel de vento."
                              ],
                              "realWorldApplication": "Em projetos de aeronaves como o Boeing 737, engenheiros usam modelos aeroelásticos baseados em Lagrange para prever e evitar flutter, garantindo segurança em velocidades de cruzeiro ao otimizar rigidez torsional e massa distribuída."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.2",
                            "name": "Derivar equações de movimento acopladas",
                            "description": "Derivar equações diferenciais de Lagrange para sistemas com um grau de liberdade sob excitação aerodinâmica, incluindo forças de sustentação e momento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o sistema e coordenadas generalizadas",
                                  "subSteps": [
                                    "Identifique o sistema com um grau de liberdade (DOF), como uma seção de asa com flap rotacional.",
                                    "Escolha a coordenada generalizada q(t), por exemplo, o ângulo de rotação θ do flap.",
                                    "Desenhe o diagrama esquemático mostrando geometria, massas inerciais e posição de referência aerodinâmica.",
                                    "Defina parâmetros: rigidez elástica k, massa m, momento de inércia I, velocidade do fluxo V∞, densidade ρ.",
                                    "Especifique o eixo de rotação e centro de gravidade."
                                  ],
                                  "verification": "Confirme que o DOF é único e que q(t) captura todo o movimento relevante; verifique diagrama contra referências padrão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel quadriculado, lápis, livro de aeroelasticidade (ex: Bisplinghoff), software de desenho (opcional).",
                                  "tips": "Use convenções padrão de sinal para ângulos (sentido horário positivo).",
                                  "learningObjective": "Entender como modelar sistemas acoplados com DOF mínimo para análise aeroelástica.",
                                  "commonMistakes": "Confundir DOF com múltiplos modos; ignorar posição do eixo de rotação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular energia cinética (T) e potencial (V)",
                                  "subSteps": [
                                    "Expresse a velocidade linear e angular em termos de q̇ (derivada temporal de q).",
                                    "Formule T = (1/2) I q̇² + termos de massa translacional se aplicável.",
                                    "Defina V = (1/2) k q² para mola torsional ou elástica.",
                                    "Verifique dimensionalidade: T em Joules, V em Joules.",
                                    "Simplifique para o caso de rotação pura em torno de um eixo fixo."
                                  ],
                                  "verification": "Diferencie T e V em relação ao tempo; confirme que ∂T/∂q̇ = momento conjugado correto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora simbólica (Mathematica/SymPy), notas de mecânica lagrangiana.",
                                  "tips": "Mantenha expressões simbólicas para generalidade; use matriz de inércia se expandir.",
                                  "learningObjective": "Dominar formulação lagrangiana para sistemas elásticos rotacionais.",
                                  "commonMistakes": "Esquecer termos cruzados em T para sistemas acoplados; usar V incorreta para torção."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelar forças aerodinâmicas (sustentação e momento)",
                                  "subSteps": [
                                    "Recupere coeficientes aerodinâmicos: CL(θ, α) para lift, CM(θ) para momento pitching.",
                                    "Expresse forças: Lift L = (1/2) ρ V∞² S CL, Momento M = (1/2) ρ V∞² S c CM.",
                                    "Projeite forças no espaço generalizado: Q_aero = ∂(L·r + M)/∂q, onde r é vetor posição.",
                                    "Inclua dependência dinâmica (efeitos de movimento: dCL/dt, Theodorsen function para não-estacionário se avançado).",
                                    "Linearize para pequenas amplitudes: CL ≈ CLα · θ."
                                  ],
                                  "verification": "Confirme que Q_aero tem unidades de torque (N·m) e depende de q e q̇.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Tabelas de coeficientes aerodinâmicos, software CFD básico (XFOIL), referências como Fung 'Aeroelasticity'.",
                                  "tips": "Comece com aerodinâmica quasi-estacionária para simplicidade.",
                                  "learningObjective": "Integrar aerodinâmica em formulações dinâmicas não-conservativas.",
                                  "commonMistakes": "Ignorar forças de movimento (q̇); usar coeficientes errados para perfis aerodinâmicos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar equações de movimento usando Lagrange",
                                  "subSteps": [
                                    "Forme Lagrangiano L = T - V.",
                                    "Aplique equação de Lagrange: d/dt (∂L/∂q̇) - ∂L/∂q = Q_aero.",
                                    "Expanda: I q̈ + k q = Q_aero(θ, θ̇, V∞).",
                                    "Identifique acoplamento: termos lineares em q e q̇ de origem aeroelástica.",
                                    "Escreva na forma padrão: M q̈ + C q̇ + K q = 0, destacando matrizes acopladas."
                                  ],
                                  "verification": "Substitua valores numéricos simples e resolva numericamente; confira estabilidade estática.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "SymPy ou MATLAB para derivação simbólica, solver numérico.",
                                  "tips": "Use notação matricial para clareza em acoplamentos.",
                                  "learningObjective": "Obter EDOs acopladas aeroelásticas completas.",
                                  "commonMistakes": "Erro no sinal de Q_non-conservative; esquecer d/dt em ∂L/∂q̇."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e validar as equações derivadas",
                                  "subSteps": [
                                    "Cheque consistência dimensional e limites (V∞=0 → equação elástica pura).",
                                    "Compare com literatura (ex: equações de Theodorsen para flutter).",
                                    "Simule resposta harmônica e verifique picos de ressonância.",
                                    "Analise estabilidade via Routh-Hurwitz ou eigenvalues.",
                                    "Documente suposições e extensões possíveis (múltiplos DOFs)."
                                  ],
                                  "verification": "Equação reduz corretamente para casos conhecidos; simulação converge.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "MATLAB/Python para eigenvalues, gráficos de Bode.",
                                  "tips": "Teste com V∞ baixo primeiro para depuração.",
                                  "learningObjective": "Garantir robustez e aplicabilidade das equações.",
                                  "commonMistakes": "Não linearizar adequadamente; ignorar efeitos de massa adicionada."
                                }
                              ],
                              "practicalExample": "Para uma seção de asa NACA 0012 com flap de 20% chord, pivô em 50% chord: derive ¨θ + 0.1 ˙θ + 5θ = (ρ V∞² / I) (CLα θ + C_L˙α ˙θ), onde CLα=5.7/rad, mostrando acoplamento veloz-velocidade.",
                              "finalVerifications": [
                                "Equações têm forma ¨q + acoplamentos(q, ˙q) = 0 com termos aeroelásticos explícitos.",
                                "Dimensões corretas: coeficientes em 1/s², 1/s.",
                                "Limite V∞→0 recupera oscilador harmônico elástico.",
                                "Forças de lift e momento contribuem corretamente para Q_generalizada.",
                                "Linearização válida para |θ| < 5°.",
                                "Preparado para análise de flutter (V_flutter estimado)."
                              ],
                              "assessmentCriteria": [
                                "Completude: Todos termos T, V, Q_aero presentes (30%).",
                                "Precisão matemática: Derivações corretas sem erros algébricos (25%).",
                                "Realismo aerodinâmico: Coeficientes e projeções adequados (20%).",
                                "Clareza: Notação consistente, diagrama incluído (15%).",
                                "Validação: Checks dimensionais e limites passados (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Solução de EDOs lineares com coeficientes variáveis.",
                                "Programação: Implementação em Python/MATLAB para simulação dinâmica.",
                                "Física: Princípios variacionais e conservação de energia.",
                                "Engenharia de Controle: Análise de estabilidade para sistemas acoplados."
                              ],
                              "realWorldApplication": "Previsão de flutter em asas de aeronaves (ex: incidente do Lockheed Electra), otimização de flaps para UAVs sob rajadas, design de estruturas aeroespaciais resistentes a vibrações acopladas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.3",
                            "name": "Analisar resposta a condições iniciais",
                            "description": "Calcular a resposta transitória de um sistema aeroelástico a condições iniciais, considerando amortecimento de Rayleigh e acoplamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar o sistema aeroelástico com condições iniciais",
                                  "subSteps": [
                                    "Identifique os graus de liberdade do sistema (ex.: flexão, torção).",
                                    "Defina as condições iniciais: deslocamentos e velocidades iniciais.",
                                    "Inclua matriz de amortecimento de Rayleigh: proporção com massas e rigidezes.",
                                    "Descreva o acoplamento aerodinâmico-elástico via forças aerodinâmicas.",
                                    "Esboce o diagrama esquemático do sistema."
                                  ],
                                  "verification": "Verifique se o modelo matemático está completo e as condições iniciais são explicitamente definidas em uma equação escrita.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Aeroelasticidade (ex.: Bisplinghoff), software MATLAB ou Python (NumPy/SciPy), papel e lápis para esboços"
                                  ],
                                  "tips": "Comece com um sistema de 2 DOF (flexão-torção) para simplicidade antes de generalizar.",
                                  "learningObjective": "Compreender e formular o modelo dinâmico de um sistema aeroelástico considerando acoplamento e Rayleigh damping.",
                                  "commonMistakes": [
                                    "Esquecer de normalizar as condições iniciais",
                                    "Ignorar o acoplamento aerodinâmico nas matrizes",
                                    "Confundir amortecimento de Rayleigh com viscoso"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular as equações diferenciais de movimento",
                                  "subSteps": [
                                    "Escreva a equação geral: [M]{ÿ} + [C_R]{ẏ} + [K]{y} = {F_aero}(t).",
                                    "Calcule a matriz de amortecimento de Rayleigh: [C_R] = α[M] + β[K].",
                                    "Incorpore o acoplamento aerodinâmico via modelo quasi-steady ou Theodorsen.",
                                    "Transforme para forma de estado-espaco se necessário para resolução numérica.",
                                    "Valide dimensionalmente as equações."
                                  ],
                                  "verification": "Resolva manualmente para um caso simples e confira com literatura padrão.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Referências: Wright & Cooper (Dynamic Aeroelasticity), MATLAB para simulação inicial"
                                  ],
                                  "tips": "Use coeficientes modais para reduzir o modelo se o sistema for multi-DOF.",
                                  "learningObjective": "Derivar as equações de movimento transitória incluindo Rayleigh damping e acoplamento aeroelástico.",
                                  "commonMistakes": [
                                    "Erro nos coeficientes α e β do Rayleigh",
                                    "Não linearizar forças aerodinâmicas adequadamente",
                                    "Confundir coordenadas generalizadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver numericamente a resposta transitória",
                                  "subSteps": [
                                    "Implemente o método de integração numérica (ex.: ode45 no MATLAB ou solve_ivp no Python).",
                                    "Aplique condições iniciais: y(0) e ẏ(0).",
                                    "Simule para diferentes valores de velocidade de voo e parâmetros de acoplamento.",
                                    "Plote deslocamentos, velocidades e acelerações vs. tempo.",
                                    "Analise decaimento transitório e modos dominantes."
                                  ],
                                  "verification": "Compare curvas de resposta com solução analítica para caso sem acoplamento.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "MATLAB/SciPy com solvers ODE, dados de benchmark de flutter (ex.: AGARD 445.6)"
                                  ],
                                  "tips": "Monitore estabilidade numérica ajustando tolerâncias do solver.",
                                  "learningObjective": "Calcular e visualizar a resposta transitória usando ferramentas computacionais.",
                                  "commonMistakes": [
                                    "Condições iniciais incorretas no solver",
                                    "Escolha inadequada de step-size levando a instabilidade",
                                    "Ignorar efeitos de massa adicionada aerodinâmica"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e interpretar os resultados",
                                  "subSteps": [
                                    "Identifique frequências naturais e razões de decaimento via FFT ou logarithmic decrement.",
                                    "Avalie influência do acoplamento no acoplamento de modos.",
                                    "Compare respostas com e sem Rayleigh damping.",
                                    "Discuta implicações para estabilidade flutter.",
                                    "Gere relatório com gráficos e conclusões quantitativas."
                                  ],
                                  "verification": "Os resultados mostram decaimento esperado e sensibilidade ao acoplamento?",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de análise espectral (MATLAB Signal Processing Toolbox), templates de relatório"
                                  ],
                                  "tips": "Use envelopes de decaimento para quantificar amortecimento efetivo.",
                                  "learningObjective": "Interpretar respostas transitórias em termos de dinâmica aeroelástica.",
                                  "commonMistakes": [
                                    "Atribuir erroneamente decaimento a amortecimento aerodinâmico",
                                    "Não normalizar respostas para comparação",
                                    "Ignorar regimes transônicos"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule a resposta transitória de uma seção típica de asa (NACA 0012) a uma deformação torsional inicial de 5 graus em Mach 0.6, com Rayleigh damping α=0.01, β=0.001, e acoplamento via função de Theodorsen. Plote h(t) e α(t) por 10 segundos e verifique ausência de divergência.",
                              "finalVerifications": [
                                "O aluno deriva corretamente as equações com Rayleigh e acoplamento.",
                                "Simulações numéricas reproduzem decaimento transitório realista.",
                                "Identifica corretamente modos acoplados na análise espectral.",
                                "Interpreta impactos no envelope de voo.",
                                "Relatório inclui gráficos validados e conclusões quantitativas.",
                                "Compara com benchmark AGARD 445.6."
                              ],
                              "assessmentCriteria": [
                                "Precisão das equações derivadas (30%)",
                                "Correção da implementação numérica (25%)",
                                "Qualidade da análise e interpretação (20%)",
                                "Uso adequado de ferramentas e validação (15%)",
                                "Clareza do relatório e visualizações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Solução de EDOs lineares e modais.",
                                "Física: Dinâmica de vibrações amortecidas.",
                                "Engenharia Mecânica: Análise modal de estruturas.",
                                "Computação: Programação numérica e visualização de dados.",
                                "Aerodinâmica: Modelos quasi-steady e unsteady."
                              ],
                              "realWorldApplication": "Em projetos de aeronaves, essa análise prevê respostas transitórias durante manobras ou rajadas, ajudando a evitar flutter catastrófico, otimizar amortecedores e certificar estruturas conforme FAA/EASA."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.2",
                        "name": "Modelagem na Base Modal",
                        "description": "Representação da resposta aeroelástica utilizando modos de vibração natural para simplificar análises de estruturas com múltiplos graus de liberdade.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.2.1",
                            "name": "Calcular frequências e modos naturais",
                            "description": "Determinar frequências naturais e vetores modais de estruturas aeroespaciais com dois ou mais graus de liberdade, aplicando ortogonalidade dos modos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o modelo estrutural e formular matrizes de massa e rigidez",
                                  "subSteps": [
                                    "Identifique os graus de liberdade (DOF) da estrutura aeroespacial, como deslocamentos transversais em pontos nodais de uma viga ou asa.",
                                    "Monte a matriz de massa [M] considerando massas concentradas ou distribuídas nos DOF selecionados.",
                                    "Monte a matriz de rigidez [K] baseada nas propriedades elásticas, como rigidez flexural ou torsional.",
                                    "Verifique simetria e propriedades positivas definidas das matrizes.",
                                    "Documente as unidades consistentes (ex: kg, N/m)."
                                  ],
                                  "verification": "Matrizes [M] e [K] são simétricas, positivas definidas e com dimensões n x n, onde n ≥ 2 DOF.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e lápis, software de álgebra simbólica (MATLAB/SymPy), dados da estrutura (massas, rigidezes).",
                                  "tips": "Comece com um sistema simples de 2 DOF para validar o processo antes de sistemas maiores.",
                                  "learningObjective": "Compreender como discretizar estruturas contínuas em modelos finitos com múltiplos DOF.",
                                  "commonMistakes": "Esquecer termos de acoplamento entre DOF ou usar unidades inconsistentes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular o problema de autovalores para frequências naturais",
                                  "subSteps": [
                                    "Escreva a equação de movimento livre: [M]{¨x} + [K]{x} = 0.",
                                    "Assuma solução harmônica {x} = {φ} sin(ωt), levando a ([K] - ω²[M]){φ} = 0.",
                                    "Reformule como problema generalizado de autovalores: [K]{φ} = ω² [M]{φ}.",
                                    "Use método de autovalores generalizados em software ou resolva analiticamente para 2 DOF.",
                                    "Extraia os autovalores ω²_i e autovetores {φ_i} para i=1 a n."
                                  ],
                                  "verification": "Equação ([K] - ω²[M]){φ} = 0 é satisfeita numericamente com erro < 1e-6.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Software numérico (MATLAB eig, Python scipy.linalg.eig), calculadora matricial.",
                                  "tips": "Normalizar [M] para identidade se possível, facilitando computação.",
                                  "learningObjective": "Dominar a formulação matemática do problema modal generalizado.",
                                  "commonMistakes": "Confundir autovalores ω² com frequências angulares ω ou confundir com problema padrão."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Extrair e interpretar frequências e vetores modais",
                                  "subSteps": [
                                    "Calcule frequências naturais f_i = ω_i / (2π) em Hz a partir de ω_i = sqrt(λ_i).",
                                    "Ordene modos por frequência crescente: ω_1 < ω_2 < ...",
                                    "Interprete vetores modais {φ_i} como formas modais deformadas.",
                                    "Normalize os modos (ex: φ_max = 1 ou ortonormal w.r.t [M]).",
                                    "Plote ou visualize as formas modais para compreensão física."
                                  ],
                                  "verification": "Frequências ordenadas crescentemente e modos normalizados corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de plotagem (MATLAB plot, Python matplotlib), dados numéricos dos passos anteriores.",
                                  "tips": "Visualize modos para associar a movimentos físicos como flexão ou torção.",
                                  "learningObjective": "Interpretar resultados modais em contexto aeroespacial.",
                                  "commonMistakes": "Não ordenar modos ou normalizar incorretamente, levando a interpretações erradas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar ortogonalidade dos modos e validar o modelo",
                                  "subSteps": [
                                    "Verifique ortogonalidade de massa: {φ_i}^T [M] {φ_j} = 0 para i ≠ j.",
                                    "Verifique ortogonalidade de rigidez: {φ_i}^T [K] {φ_j} = 0 para i ≠ j.",
                                    "Calcule fatores de participação modal se aplicável.",
                                    "Compare com resultados analíticos ou FEM para sistemas conhecidos.",
                                    "Documente resíduos e convergência."
                                  ],
                                  "verification": "Ortogonalidade com tolerância < 1e-8 e comparação com benchmarks < 5% erro.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de multiplicação matricial, benchmarks de literatura aeroespacial.",
                                  "tips": "Use tolerâncias numéricas adequadas devido a erros de arredondamento.",
                                  "learningObjective": "Aplicar propriedades ortogonais para redução modal.",
                                  "commonMistakes": "Ignorar não-ortogonalidade devido a amortecimento ou não-linearidades não modeladas."
                                }
                              ],
                              "practicalExample": "Para uma asa simplificada com 2 DOF (flexão e torção em seções discretas): M = diag([m1, m2]), K com termos de acoplamento. Resolver para ω1=15 Hz (flexão), ω2=25 Hz (torção), modos {φ1=[1,0]}, {φ2=[0.1,1]}, verificando ortogonalidade.",
                              "finalVerifications": [
                                "Matrizes [M] e [K] corretamente formuladas e simétricas.",
                                "Autovalores e autovetores resolvidos com erro numérico mínimo.",
                                "Frequências em Hz e modos normalizados/ordenados.",
                                "Ortogonalidade de massa e rigidez confirmada para todos os pares de modos.",
                                "Interpretação física das formas modais alinhada com estrutura aeroespacial.",
                                "Validação contra caso analítico ou software FEM."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação das matrizes (erro <1%).",
                                "Correção na resolução de autovalores generalizados.",
                                "Qualidade da interpretação e visualização dos modos.",
                                "Aplicação rigorosa de verificações de ortogonalidade.",
                                "Capacidade de identificar e corrigir erros comuns.",
                                "Documentação clara com unidades e justificativas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (autovalores generalizados, ortogonalidade).",
                                "Física: Dinâmica de vibrações livres e equações diferenciais.",
                                "Engenharia Mecânica: Análise de elementos finitos (FEM) básica.",
                                "Computação: Programação numérica em MATLAB/Python para solvers matriciais."
                              ],
                              "realWorldApplication": "Em projetos de asas de aeronaves, calcular modos naturais previne ressonâncias com excitações aerodinâmicas, evitando flutter catastrófico, como no design de aeronaves comerciais onde frequências modais guiam otimização estrutural."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.2.2",
                            "name": "Aplicar coordenadas modais",
                            "description": "Transformar equações de movimento para coordenadas naturais e resolver por análise modal em presença de acoplamento aerodinâmico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar equações de movimento e calcular modos naturais",
                                  "subSteps": [
                                    "Derivar ou obter as equações de movimento na forma M Ñ + C ñ + K q = F_aero",
                                    "Resolver o problema de autovalores generalizado para obter frequências naturais ω_i e modos Φ_i",
                                    "Normalizar os modos modais (ortogonalização em relação a M e K)",
                                    "Verificar ortogonalidade: Φ^T M Φ = I e Φ^T K Φ = Λ",
                                    "Armazenar a matriz de modos Φ"
                                  ],
                                  "verification": "Confirme que as matrizes de massa modal e rigidez modal são diagonalizadas",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Software de análise modal (MATLAB/ANSYS), equações do modelo estrutural",
                                  "tips": "Use decomposição em autovalores para eficiência computacional",
                                  "learningObjective": "Compreender os fundamentos da análise modal livre",
                                  "commonMistakes": "Esquecer de normalizar os modos, levando a inconsistências nas equações modais"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Transformar equações para coordenadas modais",
                                  "subSteps": [
                                    "Expressar deslocamentos como q = Φ η, onde η são coordenadas modais",
                                    "Substituir na equação original: M Φ Ñ̇̇ + C Φ ñ̇ + K Φ η = F_aero",
                                    "Premultiplicar por Φ^T para obter: Ñ̇̇ + 2ξω ñ̇ + ω^2 η = Φ^T F_aero",
                                    "Simplificar amortecimento para forma diagonal se não acoplado",
                                    "Validar a redução dimensional"
                                  ],
                                  "verification": "Verifique se as equações modais desacopladas são obtidas corretamente",
                                  "estimatedTime": "2 horas",
                                  "materials": "MATLAB ou Python (NumPy/SciPy), matriz de modos Φ calculada",
                                  "tips": "Mantenha os primeiros N modos dominantes para aproximação",
                                  "learningObjective": "Dominar a transformação modal das equações de movimento",
                                  "commonMistakes": "Erro na premultiplicação por Φ^T, resultando em termos acoplados residuais"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar acoplamento aerodinâmico nas coordenadas modais",
                                  "subSteps": [
                                    "Modelar forças aerodinâmicas F_aero = Q(ρ, V, k) q, usando derivadas aerodinâmicas",
                                    "Projetar F_aero nas coordenadas modais: F_modal = Φ^T Q Φ η",
                                    "Identificar matriz de acoplamento aerodinâmico A = Φ^T Q Φ",
                                    "Atualizar equações: Ñ̇̇ + (2ξω + A_v) ñ̇ + (ω^2 + A_a) η = 0",
                                    "Analisar acoplamento entre modos (ex: bending-torsion)"
                                  ],
                                  "verification": "Confirme que a matriz A apresenta acoplamento off-diagonal significativo",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Dados aerodinâmicos (painel de vórtices ou CFD), software de aeroelasticidade",
                                  "tips": "Use frequência reduzida k = ω b / V para linearização",
                                  "learningObjective": "Integrar efeitos aerodinâmicos na base modal",
                                  "commonMistakes": "Ignorar dependência da velocidade V no acoplamento"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver e analisar o sistema modal acoplado",
                                  "subSteps": [
                                    "Formular o sistema completo em estado-estado ou diretamente",
                                    "Resolver numericamente para respostas em frequência ou tempo (ex: V-g method)",
                                    "Identificar condições de flutter (raiz com parte real positiva)",
                                    "Plotar curvas de amortecimento vs. velocidade",
                                    "Interpretar contribuições modais dominantes"
                                  ],
                                  "verification": "Obtenha velocidades críticas de flutter consistentes com referências",
                                  "estimatedTime": "2 horas",
                                  "materials": "MATLAB (funções ode45 ou p-eig), scripts de aeroelasticidade",
                                  "tips": "Itere sobre velocidades V para sweep de estabilidade",
                                  "learningObjective": "Resolver problemas aeroelásticos modais e interpretar resultados",
                                  "commonMistakes": "Confundir modos simétricos e antissimétricos no acoplamento"
                                }
                              ],
                              "practicalExample": "Para uma asa tábua com 2 graus de liberdade (hélice e torção), use M = diag([m, I]), K de rigidez, Q de painel de vórtices a V=100 m/s. Transforme com Φ dos 2 primeiros modos, compute A, e encontre V_flutter ≈ 120 m/s.",
                              "finalVerifications": [
                                "Transformação modal correta sem acoplamento estrutural residual",
                                "Incorporacao precisa do acoplamento aerodinâmico off-diagonal",
                                "Cálculo de frequências e amortecimentos modais alterados",
                                "Identificação correta de velocidades críticas de instabilidade",
                                "Validação numérica contra soluções full-order",
                                "Interpretação física dos modos acoplados"
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação das equações modais (erro <1%)",
                                "Correta modelagem do acoplamento aerodinâmico",
                                "Eficiência na redução modal (N<<DOF total)",
                                "Análise qualitativa e quantitativa de estabilidade",
                                "Clareza na apresentação de gráficos e resultados",
                                "Capacidade de generalizar para sistemas multi-modais"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de autovalores e transformações lineares",
                                "Física: Teoria de vibrações e ondas",
                                "Engenharia Mecânica: Dinâmica de estruturas",
                                "Computação: Simulações numéricas e MATLAB",
                                "Aerodinâmica: Teoria de superfícies de controle"
                              ],
                              "realWorldApplication": "Análise de flutter em projetos de aeronaves (ex: Boeing 737 MAX ou drones), prevenindo falhas catastróficas por instabilidades aeroelásticas durante o ciclo de certificação FAA/EASA."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.2.3",
                            "name": "Incorporar amortecimento Rayleigh",
                            "description": "Modelar o amortecimento de Rayleigh em modelos modais aeroelásticos e analisar seu impacto na resposta dinâmica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Análise Modal e Amortecimento",
                                  "subSteps": [
                                    "Estude a equação de movimento geral para sistemas multi-graus de liberdade: M ü + C ú + K u = F.",
                                    "Revise a decomposição modal: assumir formas modais Φ e coordenadas generalizadas q.",
                                    "Entenda amortecimento proporcional: condições para C diagonalizável pelas mesmas modais de M e K.",
                                    "Pesquise a definição de amortecimento Rayleigh: C = α M + β K.",
                                    "Calcule taxas de amortecimento modais: ζ_i = (α / (2 ω_i)) + (β ω_i / 2)."
                                  ],
                                  "verification": "Resuma em um diagrama as equações modais desacopladas com Rayleigh damping.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Dinâmica das Estruturas (Clough & Penzien)",
                                    "Notas de aula sobre análise modal",
                                    "Software MATLAB ou Python (NumPy/SciPy)"
                                  ],
                                  "tips": "Use exemplos simples de 1-DOF para intuitivamente entender α e β.",
                                  "learningObjective": "Compreender como o amortecimento Rayleigh simplifica a análise modal.",
                                  "commonMistakes": [
                                    "Confundir α com coeficiente de massa vs. rigidez",
                                    "Ignorar dependência frequência das taxas de amortecimento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular o Modelo de Amortecimento Rayleigh para Aeroelasticidade",
                                  "subSteps": [
                                    "Defina matrizes de massa M e rigidez K do modelo estrutural aeroelástico.",
                                    "Selecione valores de α e β baseados em taxas de amortecimento alvo para modos dominantes (ex: ζ_1 = 0.02, ζ_3 = 0.05).",
                                    "Monte a matriz de amortecimento C = α M + β K.",
                                    "Verifique ortogonalidade: confirme Φ^T C Φ é diagonal.",
                                    "Incorpore forças aerodinâmicas no modelo modal uncoupled.",
                                    "verification: "
                                  ],
                                  "verification": "Derive analiticamente as equações modais uncoupled com C Rayleigh.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Documentação NASTRAN ou similar para modos aeroelásticos",
                                    "Planilha Excel para cálculo de α/β",
                                    "Código MATLAB template para modais"
                                  ],
                                  "tips": "Escolha α e β para matching em dois modos; use otimização se necessário.",
                                  "learningObjective": "Formular C Rayleigh compatível com base modal aeroelástica.",
                                  "commonMistakes": [
                                    "Escolher α/β sem considerar faixa de frequências relevantes",
                                    "Não verificar se C é positiva definida"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Modelo no Ambiente de Simulação",
                                  "subSteps": [
                                    "Configure o solver numérico em MATLAB/Simulink ou Python para equações modais: ïq + 2 Ζ Ω óq + Ω² q = Q_aero.",
                                    "Inclua termos de amortecimento modal: 2 ζ_i ω_i para cada modo.",
                                    "Implemente acoplamento aerodinâmico se necessário (ex: V-g método).",
                                    "Defina condições iniciais e excitação (ex: gust ou manobra).",
                                    "Execute simulação em regime transitório e/ou harmônico."
                                  ],
                                  "verification": "Execute simulação sem amortecimento e confirme instabilidades esperadas.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "MATLAB Aerospace Toolbox",
                                    "Python com SciPy odeint/solve_ivp",
                                    "Exemplo de código de flutter modal"
                                  ],
                                  "tips": "Use modos truncados (primeiros 6-10) para eficiência computacional.",
                                  "learningObjective": "Implementar numericamente o modelo com Rayleigh damping.",
                                  "commonMistakes": [
                                    "Erro de unidades em frequências (rad/s vs Hz)",
                                    "Não normalizar modais corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Impacto na Resposta Dinâmica",
                                  "subSteps": [
                                    "Gere gráficos de deslocamentos modais, velocidades e acelerações vs tempo.",
                                    "Calcule métricas: overshoot, tempo de assentamento, fator de amplificação.",
                                    "Compare respostas com/sem Rayleigh e com amortecimento não-proporcional.",
                                    "Avalie estabilidade: verifique raízes complexas do polinômio característico.",
                                    "Interprete efeitos: como α/β afetam modos baixos vs altos."
                                  ],
                                  "verification": "Produza relatório com gráficos comparativos e conclusões quantitativas.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "MATLAB plotting functions",
                                    "Python Matplotlib/Seaborn",
                                    "Ferramentas de FFT para análise espectral"
                                  ],
                                  "tips": "Use log-decay para estimar ζ efetivo dos plots.",
                                  "learningObjective": "Quantificar o impacto do Rayleigh damping na dinâmica aeroelástica.",
                                  "commonMistakes": [
                                    "Interpretar erroneamente modos espúrios",
                                    "Ignorar contribuições de modos higher-order"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Refinar o Modelo",
                                  "subSteps": [
                                    "Compare com dados experimentais de ensaios de vibração (ex: ground vibration test).",
                                    "Ajuste α/β via least-squares para match de decay rates observados.",
                                    "Teste sensibilidade: varie α/β ±20% e avalie robustez.",
                                    "Documente limitações do Rayleigh (ex: não captura histerese).",
                                    "Sugira alternativas como amortecimento modal direto se necessário."
                                  ],
                                  "verification": "Obtenha erro <10% em ζ estimados vs medidos para 3 modos.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Dados de ensaios experimentais (dataset público)",
                                    "Otimização em MATLAB fminsearch"
                                  ],
                                  "tips": "Priorize modos aeroelasticamente críticos (1º flexão, torsion).",
                                  "learningObjective": "Validar criticamente o modelo Rayleigh em contexto real.",
                                  "commonMistakes": [
                                    "Overfitting α/β a poucos modos",
                                    "Não considerar não-linearidades aerodinâmicas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um modelo modal de uma asa flexível de UAV, incorpore Rayleigh damping com α=0.1, β=0.0002 para capturar dissipação observada em testes de flutter em túnel de vento a V=80 m/s. Simule resposta a um step gust e observe redução de 40% no pico de deformação torsional.",
                              "finalVerifications": [
                                "Matriz C = αM + βK resulta em taxas modais ζ_i consistentes com dados experimentais.",
                                "Simulações mostram estabilização da resposta dinâmica sem oscilações divergentes.",
                                "Gráficos comparativos destacam impacto quantitativo do damping (ex: tempo de decay <5s).",
                                "Raízes do sistema têm partes reais negativas para todos modos relevantes.",
                                "Modelo prediz corretamente envelope de flutter dentro de 5% do experimental.",
                                "Documentação inclui derivação, código e validação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação de C Rayleigh e desacoplamento modal (80%+ correto).",
                                "Implementação numérica sem erros de codificação e convergência estável.",
                                "Análise quantitativa profunda com métricas e visualizações claras.",
                                "Validação contra referências experimentais ou literatura.",
                                "Interpretação física correta dos efeitos no comportamento aeroelástico.",
                                "Relatório estruturado e acionável para engenharia."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Solução de autovalores e diagonalização espectral.",
                                "Programação: Implementação de solvers ODE e análise numérica.",
                                "Engenharia Mecânica: Modelagem de vibrações estruturais.",
                                "Física: Princípios de dissipação de energia em osciladores.",
                                "Controle de Sistemas: Análise de estabilidade com damping."
                              ],
                              "realWorldApplication": "No design de aeronaves comerciais como o Boeing 787, o amortecimento Rayleigh é incorporado em modelos modais para prever e mitigar flutter durante certificação FAA, evitando falhas catastróficas como o incidente do DH Comet, economizando milhões em testes físicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.2.4",
                            "name": "Usar Método de Elementos Finitos",
                            "description": "Aplicar o Método de Elementos Finitos para análise dinâmica de estruturas contínuas sob carregamento aeroelástico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos do FEM para Análise Dinâmica",
                                  "subSteps": [
                                    "Estudar os princípios básicos do Método de Elementos Finitos (FEM) aplicados a problemas dinâmicos, incluindo equações de movimento governadas pela matriz de massa, amortecimento e rigidez.",
                                    "Revisar conceitos de aeroelasticidade, como carregamentos flutter e divergência, e sua integração no FEM.",
                                    "Identificar tipos de elementos finitos adequados para estruturas contínuas aeroespaciais (e.g., vigas, placas, cascas).",
                                    "Explorar formulações modais para redução de ordem no modelo dinâmico.",
                                    "Analisar diferenças entre análises estática e dinâmica no contexto aeroelástico."
                                  ],
                                  "verification": "Resumir em um diagrama as equações principais do FEM dinâmico e listar 3 exemplos de elementos para estruturas aeroespaciais.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Livro 'Finite Element Procedures' de Bathe; tutoriais ANSYS/ABAQUS online; notas de aula sobre aeroelasticidade.",
                                  "tips": "Comece com equações simples de um grau de liberdade para intuitivamente entender o acoplamento aeroelástico.",
                                  "learningObjective": "Dominar as bases teóricas do FEM dinâmico para preparar modelagem aeroelástica.",
                                  "commonMistakes": "Confundir massas consistentes com lumpadas; ignorar efeitos giroscópicos em rotações."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar Geometria e Gerar Malha",
                                  "subSteps": [
                                    "Importar ou criar geometria da estrutura contínua (e.g., asa ou painel aeroespacial) em software FEM.",
                                    "Definir dimensões precisas baseadas em especificações aeroespaciais reais.",
                                    "Gerar malha finita com elementos adequados, refinando em regiões críticas de alta deformação aeroelástica.",
                                    "Verificar qualidade da malha (aspect ratio, skewness, Jacobiano).",
                                    "Exportar malha para solver dinâmico."
                                  ],
                                  "verification": "Gerar relatório de qualidade da malha mostrando métricas acima de 0.7 em todos os elementos.",
                                  "estimatedTime": "6 horas",
                                  "materials": "Software FEM (ANSYS, NASTRAN, Abaqus); CAD de asa NACA 0012; guidelines de meshing aeroespacial.",
                                  "tips": "Use malhas adaptativas para capturar gradientes de tensão perto de bordas livres.",
                                  "learningObjective": "Criar uma malha precisa e eficiente para análise dinâmica aeroelástica.",
                                  "commonMistakes": "Malha muito grosseira levando a erros de convergência; distorção de elementos em curvas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Propriedades, Condições de Contorno e Carregamentos Aeroelásticos",
                                  "subSteps": [
                                    "Atribuir propriedades materiais isotrópicas/anisotrópicas (módulo de Young, Poisson, densidade) para compósitos aeroespaciais.",
                                    "Aplicar condições de contorno (engastamentos, apoios elásticos simulando fuselagem).",
                                    "Modelar carregamentos aeroelásticos dinâmicos (pressões unsteady de Theodorsen ou MSC).",
                                    "Incluir matriz de amortecimento aerodinâmico e forças follow-the-leader.",
                                    "Configurar análise modal para extração de modos relevantes."
                                  ],
                                  "verification": "Executar análise modal estática e confirmar frequências naturais dentro de 5% de valores analíticos conhecidos.",
                                  "estimatedTime": "5 horas",
                                  "materials": "Dados materiais de compósitos (e.g., CFRP); funções aerodinâmicas de software como ZAERO.",
                                  "tips": "Use elementos shell para eficiência em placas finas; valide com teoria de viga de Euler-Bernoulli.",
                                  "learningObjective": "Integrar corretamente física aeroelástica no modelo FEM.",
                                  "commonMistakes": "Negligenciar acoplamento fluido-estrutura; condições de contorno muito rígidas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar Simulação Dinâmica e Pós-Processar Resultados",
                                  "subSteps": [
                                    "Configurar solver dinâmico (direct integration ou modal superposition) para resposta transitória ou harmônica.",
                                    "Executar simulação com carregamento ramp-up para evitar instabilidades iniciais.",
                                    "Extrair respostas (deslocamentos, tensões, acelerações) em função do tempo ou frequência.",
                                    "Analisar modos de flutter via root locus ou V-g diagram.",
                                    "Validar contra dados experimentais ou analíticos."
                                  ],
                                  "verification": "Plotar curvas de resposta dinâmica e confirmar ausência de divergência não-física.",
                                  "estimatedTime": "7 horas",
                                  "materials": "Solver FEM licenciado; scripts Python/MATLAB para pós-processamento; dados de benchmark flutter.",
                                  "tips": "Monitore resíduos de equilíbrio durante iterações; use damping ratios realistas.",
                                  "learningObjective": "Realizar análise completa e interpretar resultados aeroelásticos.",
                                  "commonMistakes": "Time step muito grande causando oscilações numéricas; interpretação errada de modos espúrios."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Otimizar e Validar o Modelo",
                                  "subSteps": [
                                    "Refinar malha ou parâmetros baseados em análise de sensibilidade.",
                                    "Comparar com ensaios experimentais de vibração (shake table ou wind tunnel).",
                                    "Realizar estudo de convergência h/p-refinement.",
                                    "Documentar limitações do modelo (e.g., linearidade assumida).",
                                    "Gerar relatório com recomendações para design."
                                  ],
                                  "verification": "Demonstrar convergência com erro <2% em frequências e amplitudes críticas.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Dados experimentais de AGARD 445.6 wing; ferramentas de otimização FEM.",
                                  "tips": "Automatize com APDL ou scripts para eficiência.",
                                  "learningObjective": "Garantir robustez e confiabilidade da análise FEM aeroelástica.",
                                  "commonMistakes": "Sobreajuste ao ignorar incertezas; validação apenas qualitativa."
                                }
                              ],
                              "practicalExample": "Modelar uma asa flexível AGARD 445.6 usando FEM no ANSYS: discretizar com shells, aplicar carregamento unsteady de Theodorsen a Mach 0.3, extrair V-g diagram confirmando velocidade de flutter em ~350 m/s.",
                              "finalVerifications": [
                                "Frequências modais coincidem com teoria em <5% de erro.",
                                "Curvas de resposta dinâmica mostram amortecimento aeroelástico correto.",
                                "Root locus do sistema aeroelástico indica flutter realista.",
                                "Tensões máximas abaixo de limites de fadiga do material.",
                                "Convergência numérica confirmada com h-refinement.",
                                "Validação contra dados experimentais de wind tunnel."
                              ],
                              "assessmentCriteria": [
                                "Precisão da modelagem geométrica e malha (qualidade >0.8).",
                                "Correta implementação de carregamentos aeroelásticos dinâmicos.",
                                "Interpretação qualitativa e quantitativa de resultados modais.",
                                "Eficiência computacional (tempo de simulação <24h para modelo médio).",
                                "Relatório completo com gráficos, validações e conclusões.",
                                "Identificação de pelo menos 2 otimizações potenciais."
                              ],
                              "crossCurricularConnections": [
                                "Mecânica dos Fluidos: Integração com CFD para acoplamento fluido-estrutura.",
                                "Controle Automático: Uso de modos para síntese de laws de controle ativo de flutter.",
                                "Matemática Computacional: Solução de autovalores para extração modal.",
                                "Engenharia de Materiais: Propriedades anisotrópicas de compósitos.",
                                "Física Experimental: Correlação com ensaios de vibração modal."
                              ],
                              "realWorldApplication": "Análise de flutter em asas de aeronaves comerciais (e.g., Boeing 787) para certificação FAA/EASA, prevendo instabilidades em regime transônico e otimizando layout estrutural para reduzir peso em 10-15% sem comprometer segurança."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.3",
                        "name": "Análise de Estabilidade e Ensaios",
                        "description": "Estudo de problemas de estabilidade dinâmica e validação experimental da resposta aeroelástica em estruturas como placas e cascas.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.3.1",
                            "name": "Analisar estabilidade aeroelástica",
                            "description": "Identificar condições de flutter e divergência na resposta aeroelástica utilizando critérios de estabilidade em base modal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Aeroelasticidade e Análise Modal",
                                  "subSteps": [
                                    "Estude definições de flutter (instabilidade dinâmica) e divergência (instabilidade estática).",
                                    "Revise equações de movimento acopladas fluido-estrutura em aeroelasticidade.",
                                    "Aprenda bases modais: modos naturais, frequências e formas modais de vibração.",
                                    "Entenda critérios de estabilidade como V-g e método k para base modal.",
                                    "Identifique parâmetros chave: velocidade do fluxo, rigidez e amortecimento."
                                  ],
                                  "verification": "Resuma em um diagrama os tipos de instabilidades e critérios associados.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livros de aeroelasticidade (ex: Bisplinghoff), vídeos tutoriais sobre análise modal.",
                                  "tips": "Use analogias como corda esticada para divergência e pêndulo forçado para flutter.",
                                  "learningObjective": "Compreender conceitos fundamentais para análise subsequente.",
                                  "commonMistakes": "Confundir flutter (oscilar) com divergência (deformação estática)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar a Estrutura em Base Modal",
                                  "subSteps": [
                                    "Obtenha matrizes de massa [M], rigidez [K] e amortecimento [C] da estrutura.",
                                    "Realize análise modal: resolva autovalores para obter modos e frequências.",
                                    "Projete forças aerodinâmicas nos modos modais usando funções generalizadas.",
                                    "Defina coordenadas modais q_i(t) para representar deslocamentos.",
                                    "Valide o modelo comparando frequências modais com dados experimentais."
                                  ],
                                  "verification": "Gere plot de formas modais e frequências para uma viga cantilever.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Software como NASTRAN, MATLAB ou Python (SciPy para autovalores).",
                                  "tips": "Normalizar modos para massa modal unitária facilita cálculos.",
                                  "learningObjective": "Construir representação modal precisa da estrutura.",
                                  "commonMistakes": "Ignorar modos superiores que contribuem para flutter."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular Equações de Movimento Aeroelásticas em Base Modal",
                                  "subSteps": [
                                    "Escreva equações desacopladas: ï¿½ï¿½q + 2ï¿½ï¿½ï¿½q + ï¿½ï¿½Â²q = Q_aero.",
                                    "Inclua forças aerodinâmicas modais do teorema de trabalho virtual.",
                                    "Aplique teoria aerodinâmica (ex: teoria de pistão ou dupla grade de lattes).",
                                    "Introduza parâmetros não-dimensionais: ï¿½ (frequência reduzida), ï¿½ (parâmetro de massa).",
                                    "Linearize para pequenas perturbações em torno do equilíbrio."
                                  ],
                                  "verification": "Derive equação para um modo simples e verifique dimensionalidade.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Folhas de cálculo, MATLAB para simbolismo (SymPy).",
                                  "tips": "Use matrizes de aerodâmica [A] dependentes de velocidade V.",
                                  "learningObjective": "Obter sistema dinâmico modal acoplado.",
                                  "commonMistakes": "Esquecer acoplamento aerodinâmico entre modos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Critérios de Estabilidade e Identificar Condições Críticas",
                                  "subSteps": [
                                    "Implemente método V-g: varra velocidade V, compute damping g_i(V).",
                                    "Detecte flutter quando g_i = 0 para algum modo (cruzamento de frequências).",
                                    "Para divergência, resolva det([K_aero(V) + K_estr]) = 0.",
                                    "Plote diagramas V-f (velocidade vs frequência) e V-g.",
                                    "Compare com critérios alternativos como p-k ou método de autovalores complexos."
                                  ],
                                  "verification": "Identifique V_flutter em um exemplo padrão (ex: asa típica).",
                                  "estimatedTime": "5 horas",
                                  "materials": "Códigos MATLAB/Python para sweep V-g, exemplos de casos benchmark.",
                                  "tips": "Comece com 2DOF (heaving + pitching) para validação.",
                                  "learningObjective": "Aplicar métodos numéricos para prever instabilidades.",
                                  "commonMistakes": "Não considerar efeitos compressíveis em altas velocidades."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar Resultados e Realizar Sensibilidade",
                                  "subSteps": [
                                    "Analise bifurcações: identifique velocidades críticas e modos dominantes.",
                                    "Teste sensibilidade a variações em massa, rigidez ou aerodinâmica.",
                                    "Compare simulações com dados de ensaios em túnel de vento.",
                                    "Documente margens de segurança (V_flutter > 1.15 V_cruise).",
                                    "Recomende mitigações como massa balanço ou dampers."
                                  ],
                                  "verification": "Gere relatório com plots e conclusões sobre estabilidade.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Ferramentas de plot (Matplotlib), templates de relatório.",
                                  "tips": "Use margens ASABE para design aeroespacial.",
                                  "learningObjective": "Interpretar análise para decisões de engenharia.",
                                  "commonMistakes": "Superestimar estabilidade ignorando não-linearidades."
                                }
                              ],
                              "practicalExample": "Analise a estabilidade aeroelástica de uma asa reta típica de aeronave de transporte, usando modelo 2DOF (flexão e torção). Compute V_flutter = 250 m/s com método V-g em MATLAB, identificando flutter binodal entre modo 1 e 2.",
                              "finalVerifications": [
                                "Diagramas V-f e V-g mostram cruzamento claro de modos sem ambiguidades.",
                                "Velocidade de flutter calculada coincide com benchmarks (±5%).",
                                "Condições de divergência identificadas corretamente para rigidez torsional.",
                                "Análise de sensibilidade cobre variações de ±20% em parâmetros chave.",
                                "Relatório inclui plots, equações e recomendações de design.",
                                "Validação cruzada com método p-k confirma resultados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na modelagem modal (frequências <5% erro).",
                                "Correta implementação de critérios de estabilidade (V-g, divergência).",
                                "Qualidade dos plots e interpretação de resultados críticos.",
                                "Cobertura de sensibilidade e validação com dados reais.",
                                "Clareza no relatório: objetivos, métodos, conclusões.",
                                "Identificação correta de flutter vs divergência."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de autovalores complexos e estabilidade de sistemas lineares.",
                                "Física: Dinâmica de vibrações e interação fluido-estrutura.",
                                "Computação: Programação numérica para simulações (MATLAB/Python).",
                                "Engenharia Mecânica: Ensaios de vibração modal experimentais.",
                                "Aerodinâmica: Modelos de forças (teoria de vórtices, painéis)."
                              ],
                              "realWorldApplication": "Em projetos de aeronaves como o Boeing 787, análise de estabilidade aeroelástica previne flutter catastrófico durante voo, garantindo segurança via certificação FAA/EASA; aplicada também em turbinas eólicas e hélices de drones."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.3.2",
                            "name": "Avaliar resposta a excitações aleatórias",
                            "description": "Analisar vibrações aleatórias em estruturas aeroespaciais sob fluxo turbulento, usando métodos estatísticos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos de Excitações Aleatórias e Fluxo Turbulento",
                                  "subSteps": [
                                    "Estude definições de processos estocásticos e excitações aleatórias em estruturas aeroespaciais.",
                                    "Revise características do fluxo turbulento, incluindo escalas de Kolmogorov e espectros de energia.",
                                    "Identifique equações diferenciais estocásticas relevantes para vibrações estruturais.",
                                    "Analise exemplos de respostas aeroelásticas sob turbulência, como buffeting em asas.",
                                    "Compile glossário de termos chave: PSD (Power Spectral Density), coerência, funções de correlação."
                                  ],
                                  "verification": "Resuma os conceitos em um mapa mental ou tabela comparativa e explique para um colega.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Livros de texto (ex: 'Random Vibrations' de Newland), artigos sobre aeroelasticidade, software de mind mapping (MindMeister).",
                                  "tips": "Use analogias como 'turbulência como ruído branco' para fixar conceitos.",
                                  "learningObjective": "Dominar terminologia e teoria base para análise estatística de vibrações aleatórias.",
                                  "commonMistakes": "Confundir fluxo turbulento com laminar; ignorar não-estacionaridade dos sinais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Modelo Experimental ou Simulação",
                                  "subSteps": [
                                    "Selecione ou construa modelo estrutural (ex: viga cantilever representando asa).",
                                    "Configure gerador de turbulência (tela no túnel de vento ou simulador CFD como ANSYS Fluent).",
                                    "Instale sensores: acelerômetros, strain gauges para medir vibrações.",
                                    "Defina condições de contorno: velocidade de fluxo, ângulo de ataque.",
                                    "Calibre instrumentos e valide setup com testes determinísticos iniciais."
                                  ],
                                  "verification": "Execute teste piloto e confirme sinais de vibração com espectro esperado de turbulência.",
                                  "estimatedTime": "8-12 horas",
                                  "materials": "Modelo físico ou software (MATLAB/Simulink, ANSYS), sensores (acelerômetros), túnel de vento ou simulador.",
                                  "tips": "Registre todas as configurações em um log detalhado para reprodutibilidade.",
                                  "learningObjective": "Preparar ambiente controlado para captura precisa de respostas aleatórias.",
                                  "commonMistakes": "Subestimar ruído de fundo nos sensores; desalinhamento do modelo no fluxo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Coletar e Pré-processar Dados de Vibração",
                                  "subSteps": [
                                    "Adquira dados por pelo menos 10-20 minutos em múltiplas runs para estatística robusta.",
                                    "Aplique filtros anti-aliasing e remoção de trend/DC offset.",
                                    "Segmente sinais em janelas sobrepostas (ex: Hanning window, 50% overlap).",
                                    "Calcule estatísticas básicas: média, RMS, desvios padrão.",
                                    "Verifique estacionaridade via teste de Dickey-Fuller ou gráficos de autocorrelação."
                                  ],
                                  "verification": "Gere plots de time-series e histograma confirmando distribuição gaussiana aproximada.",
                                  "estimatedTime": "6-10 horas",
                                  "materials": "Software de aquisição (LabVIEW, DAQ systems), MATLAB/Python (SciPy para processamento).",
                                  "tips": "Colete dados em taxas de amostragem 10x a frequência máxima esperada.",
                                  "learningObjective": "Obter dados limpos e representativos de excitações aleatórias.",
                                  "commonMistakes": "Janelas muito curtas levando a variância alta; ignorar vazamento espectral."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Métodos Estatísticos para Análise",
                                  "subSteps": [
                                    "Compute Power Spectral Density (PSD) via Welch's method ou FFT.",
                                    "Estime funções de transferência e coerência entre excitação e resposta.",
                                    "Aplique análise de resposta em frequência (FRF) e identifique picos de ressonância.",
                                    "Use métodos como Proper Orthogonal Decomposition (POD) para modos dominantes.",
                                    "Calcule fatiga via Rainflow counting ou espectros de contagem de ciclos."
                                  ],
                                  "verification": "Compare PSDs com modelos teóricos (ex: espectro de von Karman para turbulência).",
                                  "estimatedTime": "10-15 horas",
                                  "materials": "MATLAB Signal Processing Toolbox, Python (NumPy, SciPy, Matplotlib), referências teóricas.",
                                  "tips": "Automatize scripts para múltiplas condições de fluxo.",
                                  "learningObjective": "Extrair métricas quantitativas de estabilidade estrutural sob aleatoriedade.",
                                  "commonMistakes": "Má normalização de PSD; confundir coerência baixa com causalidade fraca."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Interpretar Resultados e Avaliar Estabilidade",
                                  "subSteps": [
                                    "Identifique bandas críticas de frequência e níveis de resposta RMS.",
                                    "Avalie margens de estabilidade via critérios como peak coherence ou damping ratios.",
                                    "Simule cenários de pior caso com Monte Carlo.",
                                    "Gere relatório com gráficos, tabelas e recomendações de design.",
                                    "Valide com literatura ou dados experimentais conhecidos."
                                  ],
                                  "verification": "Conclua se estrutura atende critérios de flutter/buffeting (ex: aceleração < 2g).",
                                  "estimatedTime": "5-8 horas",
                                  "materials": "Software de relatórios (LaTeX, Jupyter), benchmarks de literatura aeroespacial.",
                                  "tips": "Use visualizações 3D de modos para insights intuitivos.",
                                  "learningObjective": "Avaliar riscos aeroelásticos e propor mitigações.",
                                  "commonMistakes": "Sobre-generalizar de uma run; ignorar não-linearidades em altas amplitudes."
                                }
                              ],
                              "practicalExample": "Em um túnel de vento, teste uma asa em escala de UAV sob turbulência gerada por grades. Meça vibrações com acelerômetros, compute PSD mostrando pico em 15 Hz (modo de flexão), e confirme estabilidade com damping > 5%.",
                              "finalVerifications": [
                                "PSDs calculados corretamente com convergência em runs repetidas.",
                                "Coerência > 0.8 nas bandas de interesse.",
                                "Resposta RMS abaixo de thresholds de fadiga.",
                                "Identificação precisa de modos estruturais.",
                                "Relatório inclui gráficos de FRF e espectros de turbulência.",
                                "Validação cruzada com simulações numéricas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de frequências ressonantes (±5%).",
                                "Uso correto de métodos estatísticos (Welch, POD).",
                                "Interpretação física dos resultados (ligação a aeroelasticidade).",
                                "Qualidade dos dados pré-processados (SNR > 20 dB).",
                                "Relatório claro com conclusões acionáveis.",
                                "Consideração de incertezas e sensibilidade."
                              ],
                              "crossCurricularConnections": [
                                "Estatística e Probabilidade: PSD, funções de correlação.",
                                "Mecânica dos Fluidos: Modelagem de turbulência.",
                                "Programação Computacional: Scripts em MATLAB/Python para análise.",
                                "Engenharia de Materiais: Efeitos de fadiga em compostos.",
                                "Controle de Sistemas: Identificação para controladores ativos."
                              ],
                              "realWorldApplication": "Na certificação de aeronaves como Boeing 787, analisa buffeting em turbulência atmosférica para prevenir fadiga estrutural e garantir segurança em voo, otimizando designs de asas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.3.3",
                            "name": "Planejar ensaios em túnel de vento",
                            "description": "Desenhar e interpretar ensaios experimentais de aeroelasticidade em túnel de vento para validar modelos de resposta dinâmica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir Objetivos e Escopo do Ensaio",
                                  "subSteps": [
                                    "Identificar o problema aeroelástico específico (ex.: flutter, buffeting) a ser validado.",
                                    "Estabelecer hipóteses baseadas em modelos analíticos ou numéricos existentes.",
                                    "Determinar parâmetros críticos: números de Reynolds, Mach, frequências naturais.",
                                    "Definir critérios de sucesso para validação do modelo dinâmico.",
                                    "Consultar normas como AGARD ou AIAA para ensaios em túnel de vento."
                                  ],
                                  "verification": "Documentar objetivos em um relatório inicial com matriz de requisitos preenchida.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Normas AGARD/AIAA, software de modelagem (ex.: MATLAB), literatura sobre aeroelasticidade.",
                                  "tips": "Priorize objetivos SMART (Específicos, Mensuráveis, Alcançáveis, Relevantes, Temporais).",
                                  "learningObjective": "Compreender como alinhar objetivos experimentais com modelos teóricos de resposta dinâmica.",
                                  "commonMistakes": "Definir escopo amplo demais, ignorando limitações do túnel de vento disponível."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar o Modelo de Teste",
                                  "subSteps": [
                                    "Escalonar o modelo físico considerando rigidez, massa e dimensões para matching dinâmico.",
                                    "Selecionar materiais (ex.: alumínio, compósitos) que reproduzam propriedades modais reais.",
                                    "Realizar simulações preliminares de modos vibratórios via FEM (Finite Element Method).",
                                    "Verificar similaridade dinâmica: matching de frequências e modos entre modelo e full-scale.",
                                    "Desenhar CAD do modelo incluindo pontos de fixação e instrumentação."
                                  ],
                                  "verification": "Gerar desenhos CAD validados por simulação modal que coincida com dados teóricos em 95%.",
                                  "estimatedTime": "8 horas",
                                  "materials": "Software CAD (SolidWorks/ANSYS), calculadora de escalonamento dinâmico, dados do protótipo full-scale.",
                                  "tips": "Use critérios de matching de Etkin para aeroelasticidade em túneis de baixa velocidade.",
                                  "learningObjective": "Dominar princípios de escalonamento para modelos aeroelásticos representativos.",
                                  "commonMistakes": "Negligenciar efeitos de rigidez torsional, levando a discrepâncias em flutter."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Planejar Instrumentação e Medições",
                                  "subSteps": [
                                    "Selecionar sensores: acelerômetros, strain gauges, pressure taps para capturar resposta dinâmica.",
                                    "Definir layout de instrumentação para modos específicos (flexão, torção).",
                                    "Configurar sistema de aquisição de dados (DAQ) com taxa de amostragem > 10x frequência máxima.",
                                    "Planejar calibração de sensores e testes de baseline (zero-flow).",
                                    "Integrar telemetria se necessário para modelos rotativos."
                                  ],
                                  "verification": "Diagrama de instrumentação completo com especificações técnicas e plano de calibração aprovado.",
                                  "estimatedTime": "6 horas",
                                  "materials": "Catálogos de sensores (PCB Piezotronics), software DAQ (LabVIEW), especificações do túnel.",
                                  "tips": "Priorize sensores com alta resolução para capturar onset de instabilidades.",
                                  "learningObjective": "Selecionar e configurar instrumentação adequada para medições aeroelásticas precisas.",
                                  "commonMistakes": "Subestimar ruído ambiental, resultando em dados inválidos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estabelecer Condições de Teste e Procedimentos",
                                  "subSteps": [
                                    "Definir matriz de testes: varredura de velocidades dinâmicas (V/F matching), ângulos de ataque.",
                                    "Estabelecer protocolos de rampa de velocidade para capturar transição para instabilidade.",
                                    "Incluir testes de excitação forçada (shakers) para identificação modal.",
                                    "Planejar procedimentos de segurança: limites de amplitude, shutdown automático.",
                                    "Documentar sequência de testes com tempos de estabilização."
                                  ],
                                  "verification": "Matriz de testes em planilha com 100% cobertura de condições críticas e riscos avaliados.",
                                  "estimatedTime": "5 horas",
                                  "materials": "Planilhas Excel/Google Sheets, manuais de operação do túnel de vento, análise FMEA.",
                                  "tips": "Inclua histerese na varredura para capturar bifurcações não-lineares.",
                                  "learningObjective": "Estruturar procedimentos experimentais seguros e abrangentes para análise de estabilidade.",
                                  "commonMistakes": "Omitir testes de baixa velocidade, perdendo baseline estável."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Planejar Análise de Dados e Validação",
                                  "subSteps": [
                                    "Definir métodos de processamento: FFT para frequências, coherence para qualidade de dados.",
                                    "Estabelecer critérios de correlação com modelos (ex.: <10% erro em velocidades de flutter).",
                                    "Preparar scripts para automação (Python/MATLAB).",
                                    "Planejar relatórios com gráficos de resposta (NYA plots, damping vs. velocidade).",
                                    "Incluir plano de iterações baseadas em resultados iniciais."
                                  ],
                                  "verification": "Script de análise funcional testado com dados simulados e relatório template pronto.",
                                  "estimatedTime": "4 horas",
                                  "materials": "Python/MATLAB com bibliotecas (SciPy, Signal Processing Toolbox), exemplos de dados históricos.",
                                  "tips": "Use modal assurance criterion (MAC) para validar modos experimentais vs. teóricos.",
                                  "learningObjective": "Integrar planejamento experimental com análise quantitativa para validação de modelos.",
                                  "commonMistakes": "Não planejar para dados ruidosos, levando a interpretações errôneas."
                                }
                              ],
                              "practicalExample": "Planejar um ensaio para validar o modelo de flutter de uma asa de UAV em túnel de vento de 2m x 2m: escalonar modelo em 1:10 com matching de frequência de torção em 20Hz, instrumentar com 8 acelerômetros, varrer velocidade de 10-50m/s, analisando damping via NYA plot para confirmar V_flutter previsto em 35m/s.",
                              "finalVerifications": [
                                "Plano completo documentado com todos os anexos (desenhos, matrizes, scripts).",
                                "Simulações preliminares confirmam matching dinâmico >90%.",
                                "Riscos de segurança identificados e mitigados com procedimentos claros.",
                                "Matriz de testes cobre todas as condições críticas de instabilidade.",
                                "Critérios de validação quantitativos definidos (ex.: erro <5% em frequências).",
                                "Aprovação preliminar de revisores técnicos obtida."
                              ],
                              "assessmentCriteria": [
                                "Completude do plano (todos os elementos presentes: 30%)",
                                "Precisão técnica no escalonamento e instrumentação (25%)",
                                "Abrangência da matriz de testes e análise de riscos (20%)",
                                "Alinhamento com normas e melhores práticas (15%)",
                                "Clareza e profissionalismo da documentação (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações diferenciais e análise modal (autovalores).",
                                "Física: Dinâmica de fluidos e vibrações (princípios de aeroelasticidade).",
                                "Engenharia Mecânica: Projeto FEM e materiais compósitos.",
                                "Computação: Programação para DAQ e processamento de sinais (Python/MATLAB).",
                                "Gestão de Projetos: Análise FMEA e planejamento de experimentos."
                              ],
                              "realWorldApplication": "Em empresas como Embraer ou NASA, esse planejamento é essencial para certificar aeronaves, previnindo falhas catastróficas como o flutter que derrubou o Tacoma Narrows Bridge ou aeronaves modernas, otimizando designs antes de testes full-scale caros."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.3.4",
                            "name": "Interpretar ensaios de vibração",
                            "description": "Processar dados de ensaios experimentais de vibração estrutural para extrair respostas aeroelásticas reais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparação e Inspeção Inicial dos Dados de Ensaio",
                                  "subSteps": [
                                    "Importar os dados brutos do ensaio de vibração de fontes como acelerômetros ou strain gauges.",
                                    "Verificar a integridade dos dados: identificar ruídos, missing values ou offsets.",
                                    "Aplicar pré-processamento básico: remoção de offsets e filtros passa-baixa para eliminar artefatos.",
                                    "Plotar séries temporais para visualização inicial das respostas estruturais.",
                                    "Documentar metadados do ensaio: configuração da estrutura, excitação aplicada e condições ambientais."
                                  ],
                                  "verification": "Gráficos de séries temporais limpas e livres de anomalias visíveis; relatório de integridade dos dados gerado.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Software de análise (MATLAB, Python com SciPy ou LabVIEW)",
                                    "Arquivos de dados brutos (.csv, .mat)",
                                    "Documentação do ensaio experimental"
                                  ],
                                  "tips": "Sempre backup os dados originais antes de qualquer processamento para evitar perda irreversível.",
                                  "learningObjective": "Compreender e preparar dados experimentais para análise confiável de vibrações.",
                                  "commonMistakes": [
                                    "Ignorar offsets DC nos sinais, levando a erros em amplitudes.",
                                    "Não calibrar sensores adequadamente antes da importação."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Análise no Domínio do Tempo",
                                  "subSteps": [
                                    "Identificar picos de resposta transitória e estacionária nos sinais de vibração.",
                                    "Calcular estatísticas descritivas: amplitude máxima, RMS e desvios padrão.",
                                    "Aplicar métodos de detecção de modos: zero-crossings ou peak-picking para estimar frequências iniciais.",
                                    "Comparar respostas com excitação conhecida (e.g., hammer test ou shaker).",
                                    "Gerar envelopes de decaimento para estimativa preliminar de damping."
                                  ],
                                  "verification": "Relatório com estatísticas temporais e identificação preliminar de frequências; plots de envelopes de decaimento coincidem com decays observados.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Scripts MATLAB/Python para análise temporal",
                                    "Ferramentas de plotting (Matplotlib, GNU Octave)"
                                  ],
                                  "tips": "Use janelas de Hann para suavizar picos e melhorar precisão em zero-crossings.",
                                  "learningObjective": "Extrair características dinâmicas básicas das respostas no tempo.",
                                  "commonMistakes": [
                                    "Confundir ruído com resposta real em sinais de baixa amplitude.",
                                    "Não considerar não-linearidades em respostas de grande amplitude."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Transformada para Domínio da Frequência e Identificação de Modos",
                                  "subSteps": [
                                    "Aplicar FFT (Fast Fourier Transform) ou Welch's method para espectros de potência.",
                                    "Identificar picos modais: frequências naturais, amplitudes e larguras de banda.",
                                    "Estimar ratios de damping via half-power bandwidth method.",
                                    "Realizar análise modal: curve-fitting com círculos de Nyquist ou métodos least-squares.",
                                    "Separar modos aeroelásticos de modos estruturais puros comparando com dados sem fluxo."
                                  ],
                                  "verification": "Espectros de frequência com picos modais claramente identificados; valores de damping dentro de 10% de referências conhecidas.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Bibliotecas de sinal (SciPy FFT, MATLAB Signal Processing Toolbox)",
                                    "Dados de referência sem aeroelasticidade"
                                  ],
                                  "tips": "Escolha comprimento de janela apropriado (e.g., 2^12 pontos) para resolução de frequência fina.",
                                  "learningObjective": "Converter dados temporais em informações modais no domínio da frequência.",
                                  "commonMistakes": [
                                    "Leakage espectral devido a janelamento inadequado.",
                                    "Atribuir picos de ruído como modos estruturais."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretação de Respostas Aeroelásticas e Validação",
                                  "subSteps": [
                                    "Comparar frequências e dampings com modelos teóricos (FEM ou teoria de flutter).",
                                    "Identificar efeitos aeroelásticos: acoplamento fluido-estrutura, redução de damping.",
                                    "Avaliar estabilidade: calcular margens de flutter via V-g ou k-methods.",
                                    "Validar com critérios experimentais: coerência de transfer functions > 0.8.",
                                    "Gerar relatório final com plots, tabelas e conclusões sobre respostas reais."
                                  ],
                                  "verification": "Relatório completo com validações quantitativas; discrepâncias < 5% com benchmarks.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Modelos FEM (ANSYS, NASTRAN)",
                                    "Ferramentas de estabilidade aeroelástica (ZAERO, custom scripts)"
                                  ],
                                  "tips": "Priorize modos críticos de baixa frequência, comuns em instabilidades aeroelásticas.",
                                  "learningObjective": "Interpretar dados para extrair respostas aeroelásticas reais e avaliar estabilidade.",
                                  "commonMistakes": [
                                    "Subestimar efeitos de fluxo em damping modal.",
                                    "Não validar com múltiplas repetições de ensaio."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um ensaio de túnel de vento em escala de uma asa de aeronave, dados de acelerômetros na borda de fuga mostram vibrações sob fluxo. Após FFT, identifica-se um modo de flexão com frequência reduzida de 15 Hz (ar) para 12 Hz (com fluxo) e damping negativo, indicando onset de flutter a Mach 0.7.",
                              "finalVerifications": [
                                "Frequências modais extraídas coincidem com picos espectrais proeminentes.",
                                "Dampings calculados via bandwidth method são consistentes em repetições.",
                                "Respostas aeroelásticas mostram acoplamento claro com parâmetros de fluxo.",
                                "Margens de estabilidade computadas alinham-se com limites operacionais conhecidos.",
                                "Relatório inclui todos os plots e métricas quantitativas.",
                                "Validações com modelos teóricos apresentam erros < 5%."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de modos (erro < 2% em frequências).",
                                "Correção na estimação de damping (consistência > 90% em métodos).",
                                "Qualidade da interpretação aeroelástica (identificação de efeitos fluido-estrutura).",
                                "Completude do relatório com visualizações claras e conclusões acionáveis.",
                                "Eficiência no processamento (tempo dentro do estimado).",
                                "Tratamento adequado de erros e incertezas nos dados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformadas de Fourier e análise espectral.",
                                "Programação: Scripts em MATLAB/Python para automação de FFT e curve-fitting.",
                                "Física: Dinâmica de fluidos computacional para validação aeroelástica.",
                                "Engenharia Mecânica: Modelagem FEM de estruturas vibrantes.",
                                "Estatística: Análise de incertezas e validação de dados experimentais."
                              ],
                              "realWorldApplication": "Durante certificação de aeronaves na FAA/EASA, interpretação de ensaios de vibração em wind tunnels detecta riscos de flutter, evitando falhas catastróficas como no caso do Northrop YF-23, onde análises modais guiaram redesenho estrutural."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.5",
                    "name": "Modelos Aeroelásticos na Base Modal",
                    "description": "Formulação de modelos aeroelásticos utilizando coordenadas modais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.5.1",
                        "name": "Coordenadas Modais e Ortogonalidade",
                        "description": "Compreensão das coordenadas modais como base para a representação de movimentos em sistemas multi-graus de liberdade, incluindo propriedades de ortogonalidade dos modos de vibração.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.1.1",
                            "name": "Identificar modos de vibração natural",
                            "description": "Determinar os modos de vibração natural de uma estrutura aeroespacial a partir da solução do problema de autovalores das equações de movimento livres.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formular as equações de movimento livres da estrutura",
                                  "subSteps": [
                                    "Derive ou obtenha as matrizes de massa (M) e rigidez (K) da estrutura aeroespacial usando métodos de elementos finitos ou analíticos.",
                                    "Escreva a equação diferencial de movimento livre: M ü + K u = 0, onde u é o vetor de deslocamentos.",
                                    "Verifique as propriedades das matrizes: M simétrica positiva definida, K simétrica semi-definida positiva.",
                                    "Defina as condições de contorno apropriadas para a estrutura (ex: apoio fixo na raiz de uma asa).",
                                    "Discretize o modelo se necessário, garantindo pelo menos 10 graus de liberdade para capturar modos relevantes."
                                  ],
                                  "verification": "Confirme que M e K são simétricas e que a equação MDD está na forma padrão sem forças externas.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Software de elementos finitos (ANSYS, NASTRAN), MATLAB ou Python (NumPy/SciPy), notas de aula sobre dinâmica estrutural.",
                                  "tips": "Comece com um modelo simples (ex: viga cantilever) para validar antes de estruturas complexas.",
                                  "learningObjective": "Compreender a origem física das equações de vibração livre em estruturas aeroespaciais.",
                                  "commonMistakes": "Ignorar acoplamento entre graus de liberdade ou usar unidades inconsistentes em M e K."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Assumir a forma de solução harmônica e derivar o problema de autovalores",
                                  "subSteps": [
                                    "Assuma solução u(t) = φ sin(ωt + θ), onde φ é o vetor modal e ω a frequência natural.",
                                    "Substitua na equação MDD para obter: (-ω² M + K) φ = 0 ou (K - ω² M) φ = 0.",
                                    "Reescreva como problema generalizado de autovalores: K φ = λ M φ, com λ = ω².",
                                    "Discuta ortogonalidade: φ_i^T M φ_j = 0 e φ_i^T K φ_j = 0 para i ≠ j.",
                                    "Identifique que det(K - λ M) = 0 define os autovalores."
                                  ],
                                  "verification": "Derive manualmente a equação de autovalores para um sistema 2x2 e verifique algebraicamente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Lápis, papel quadriculado, MATLAB para simulação simbólica (Symbolic Math Toolbox).",
                                  "tips": "Visualize φ como 'formas de onda espacial' que oscilam em ω.",
                                  "learningObjective": "Transformar equações diferenciais em problema algébrico de autovalores.",
                                  "commonMistakes": "Confundir ω com ω² ou esquecer o sinal negativo na derivação."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver o problema de autovalores numericamente",
                                  "subSteps": [
                                    "Monte as matrizes M e K no software (ex: função eig em MATLAB: [V, D] = eig(K, M)).",
                                    "Extraia autovalores λ_i (ω_i = sqrt(λ_i)) e autovetores φ_i (modos).",
                                    "Ordene por frequência crescente: ω_1 < ω_2 < ...",
                                    "Normalize os modos (ex: φ_i^T M φ_i = 1).",
                                    "Calcule pelo menos os primeiros 6 modos para estruturas aeroespaciais."
                                  ],
                                  "verification": "Verifique que K φ_i = ω_i² M φ_i para cada modo i (erro < 1e-6).",
                                  "estimatedTime": "2 horas",
                                  "materials": "MATLAB/Python (scipy.linalg.eig), modelo FEM da estrutura.",
                                  "tips": "Use solvers robustos para problemas generalizados; evite eig(K) sem M.",
                                  "learningObjective": "Aplicar métodos numéricos para extrair frequências e modos naturais.",
                                  "commonMistakes": "Não normalizar modos ou interpretar autovetores complexos como reais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar e visualizar os modos de vibração natural",
                                  "subSteps": [
                                    "Plote os autovetores φ_i como deformadas modais (ex: mesh deformed no ANSYS).",
                                    "Classifique modos: flexão, torção, acoplados (ex: modo 1: flexão raiz-costa).",
                                    "Calcule períodos T_i = 2π/ω_i e compare com dados experimentais se disponíveis.",
                                    "Analise sensibilidade: como mudanças em M/K afetam modos.",
                                    "Documente frequências em Hz e associe a riscos aeroelásticos (ex: flutter)."
                                  ],
                                  "verification": "Gere animações modais e confirme ortogonalidade numérica entre φ_i e φ_j.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Software de visualização (MATLAB plot, ParaView), planilhas para tabela de modos.",
                                  "tips": "Animações ajudam a 'sentir' o movimento; foque nos primeiros 4 modos dominantes.",
                                  "learningObjective": "Associar resultados matemáticos a comportamentos físicos estruturais.",
                                  "commonMistakes": "Interpretar modos altos como irrelevantes sem contexto aeroespacial."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e refinar a identificação dos modos",
                                  "subSteps": [
                                    "Compare com resultados analíticos para sistemas simples (ex: viga Euler-Bernoulli).",
                                    "Realize análise de convergência variando malha FEM.",
                                    "Incorpore amortecimento modal se necessário (generalização).",
                                    "Identifique modos críticos para aeroelasticidade (ex: modos de torção baixa frequência).",
                                    "Prepare relatório com tabela: modo #, f (Hz), forma modal."
                                  ],
                                  "verification": "Erro de frequência < 5% vs. referência; MAC (Modal Assurance Criterion) > 0.9.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Referências analíticas, software MAC (MATLAB toolbox).",
                                  "tips": "Use MAC para comparar modos computados vs. experimentais.",
                                  "learningObjective": "Garantir confiabilidade dos modos identificados em contextos reais.",
                                  "commonMistakes": "Sobrepor malha insuficiente levando a modos espúrios."
                                }
                              ],
                              "practicalExample": "Para uma asa cantilever de alumínio modelada com 20 elementos beam, resolva eig(K,M) para obter ω1=15 Hz (flexão primeira), φ1 com máximo deslocamento na ponta; visualize animação mostrando curvatura sinusoidal.",
                              "finalVerifications": [
                                "Autovalores λ_i > 0 para todos os modos físicos.",
                                "Autovetores normalizados satisfazem ortogonalidade em M e K.",
                                "Frequências ordenadas crescentemente sem cruzamentos espúrios.",
                                "Visualizações modais mostram deformadas físicas realistas (sem nodos errados).",
                                "Erro de verificação matricial < 1e-8 para cada modo.",
                                "Primeiros modos coincidem com intuição física (flexão antes de torção alta)."
                              ],
                              "assessmentCriteria": [
                                "Precisão das frequências naturais (erro < 3% vs. analítico).",
                                "Correta derivação e implementação do problema de autovalores.",
                                "Qualidade das visualizações e classificações modais.",
                                "Demonstração de ortogonalidade e normalização.",
                                "Análise de convergência e validação.",
                                "Relatório claro ligando resultados a aeroelasticidade."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Problemas de autovalores generalizados e diagonalização.",
                                "Física Clássica: Osciladores harmônicos acoplados e ondas estacionárias.",
                                "Engenharia Computacional: Elementos finitos e solvers numéricos.",
                                "Controle de Sistemas: Decoplamento modal para análise dinâmica."
                              ],
                              "realWorldApplication": "Em projetos de aeronaves como o Boeing 787, identificar modos naturais previne flutter aeroelástico, garantindo estabilidade em voo supersônico; usado em testes de solo com shakers para validar modelos e certificar conformidade FAA."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.2",
                            "name": "Aplicar ortogonalidade modal",
                            "description": "Utilizar a ortogonalidade dos modos de vibração para decoplar as equações de movimento em coordenadas modais generalizadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os modos de vibração e propriedades de ortogonalidade",
                                  "subSteps": [
                                    "Revise o problema de autovalores para vibrações livres: [M]{ÿ} + [K]{y} = 0",
                                    "Identifique os modos normais φ_i como autovetores ortogonais",
                                    "Verifique ortogonalidade: φ_i^T [M] φ_j = 0 e φ_i^T [K] φ_j = 0 para i ≠ j",
                                    "Normalize os modos: φ_i^T [M] φ_i = 1",
                                    "Discuta implicações para desacoplamento"
                                  ],
                                  "verification": "Resuma as propriedades de ortogonalidade em um quadro e teste com uma matriz 2x2 simples",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro de Dinâmica de Estruturas (ex: Clough & Penzien), calculadora ou MATLAB",
                                  "tips": "Sempre normalize os modos para simplificar cálculos futuros",
                                  "learningObjective": "Entender as bases matemáticas da ortogonalidade modal",
                                  "commonMistakes": "Confundir ortogonalidade com [M] e [K] vs. produto escalar padrão"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular as equações de movimento acopladas",
                                  "subSteps": [
                                    "Escreva as EDOs gerais: [M]{ÿ} + [C]{ẏ} + [K]{y} = {F(t)}",
                                    "Considere amortecimento proporcional para [C] = α[M] + β[K]",
                                    "Expresse em termos de coordenadas físicas {y}",
                                    "Calcule matrizes generalizadas de massa e rigidez para um exemplo 2-DOF",
                                    "Identifique o acoplamento nos termos fora da diagonal"
                                  ],
                                  "verification": "Confirme que as matrizes [M] e [K] são simétricas positivas definidas",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta, software simbólico como SymPy ou MATLAB Symbolic",
                                  "tips": "Use simetria das matrizes para reduzir erros de digitação",
                                  "learningObjective": "Reconhecer o acoplamento nas equações originais",
                                  "commonMistakes": "Ignorar amortecimento ou assumir [C] não proporcional prematuramente"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar a transformação para coordenadas modais",
                                  "subSteps": [
                                    "Defina {y} = [Φ]{q}, onde [Φ] é a matriz de modos",
                                    "Substitua nas EDOs: [Φ]^T [M] [Φ] {q̈} + [Φ]^T [C] [Φ] {q̇} + [Φ]^T [K] [Φ] {q} = [Φ]^T {F}",
                                    "Aplique ortogonalidade: [Φ]^T [M] [Φ] = [I], [Φ]^T [K] [Φ] = [Ω²]",
                                    "Para amortecimento proporcional: [Φ]^T [C] [Φ] = diagonal",
                                    "Obtenha EDOs desacopladas: q̈_i + 2ζ_i ω_i q̇_i + ω_i² q_i = Q_i(t)"
                                  ],
                                  "verification": "Verifique se as matrizes transformadas são diagonais",
                                  "estimatedTime": "60 minutos",
                                  "materials": "MATLAB ou Python (NumPy/SciPy) para computação numérica",
                                  "tips": "Mantenha [Φ] ortonormalizada desde o início para evitar renormalização",
                                  "learningObjective": "Executar a transformação modal corretamente",
                                  "commonMistakes": "Esquecer a transposição [Φ]^T ou não normalizar modos"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar desacoplamento e aplicar a um caso prático",
                                  "subSteps": [
                                    "Resolva as EDOs modais independentemente",
                                    "Reconstrua a resposta física: {y(t)} = [Φ]{q(t)}",
                                    "Compare respostas acoplada vs. modal para validar",
                                    "Analise contribuição de cada modo",
                                    "Discuta limitações (ex: amortecimento não proporcional)"
                                  ],
                                  "verification": "Plote respostas e confirme ausência de acoplamento modal",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de simulação (MATLAB ODE45 ou similar)",
                                  "tips": "Use excitação modal específica para isolar modos",
                                  "learningObjective": "Aplicar e validar o método de ortogonalidade",
                                  "commonMistakes": "Erro na reconstrução modal ou interpretação de modos"
                                }
                              ],
                              "practicalExample": "Para uma asa simplificada modelada como viga cantilever com 2 DOF (flexão e torção), compute modos de vibração, transforme equações sob carga aerodinâmica harmônica e verifique desacoplamento, prevendo amplitudes modais para análise de flutter.",
                              "finalVerifications": [
                                "Matrizes modais de massa, rigidez e amortecimento são diagonais",
                                "Respostas modais independentes reproduzem solução física exata",
                                "Normalização correta: φ_i^T M φ_i = 1 para todos i",
                                "Frequências modais ω_i coincidem com autovalores",
                                "Forças generalizadas Q_i calculadas corretamente",
                                "Limitações do método identificadas (ex: não-proporcionalidade)"
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação das propriedades ortogonais (90% correto)",
                                "Correta transformação e obtenção de EDOs desacopladas",
                                "Validação numérica com erro < 1% na resposta física",
                                "Interpretação física das respostas modais",
                                "Identificação de erros comuns e limitações",
                                "Clareza na documentação do processo"
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: Problema de autovalores e diagonalização",
                                "Física Clássica: Osciladores harmônicos desacoplados",
                                "Engenharia de Controle: Decoplamento para análise de estabilidade",
                                "Programação Numérica: Implementação em MATLAB/Python"
                              ],
                              "realWorldApplication": "Na indústria aeroespacial, aplica-se para reduzir modelos finitos de asas ou fuselagens em análises de vibração e aeroelasticidade, acelerando simulações de flutter e fadiga em aeronaves como o Boeing 787."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.3",
                            "name": "Realizar transformação modal",
                            "description": "Executar a transformação de coordenadas físicas para coordenadas modais utilizando a matriz de modos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Coordenadas Modais",
                                  "subSteps": [
                                    "Defina coordenadas físicas como deslocamentos reais nos graus de liberdade do sistema.",
                                    "Explique coordenadas modais como amplitudes dos modos de vibração normalizados.",
                                    "Descreva a matriz de modos Φ como colunas contendo os vetores modais φ_i.",
                                    "Revise propriedades de ortogonalidade: Φ^T M Φ = I e Φ^T K Φ = Ω².",
                                    "Identifique a relação q = Φ^T u, onde u são coordenadas físicas e q modais."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos chave e desenhe um diagrama simples de transformação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de dinâmica estrutural (ex: Clough & Penzien)",
                                    "Folha de papel e caneta",
                                    "Software de notas como Notion"
                                  ],
                                  "tips": "Use analogias como 'modos são como cordas de um violão vibrando independentemente'.",
                                  "learningObjective": "Compreender a base teórica da transformação modal e suas propriedades ortogonais.",
                                  "commonMistakes": [
                                    "Confundir coordenadas físicas com modais",
                                    "Ignorar normalização dos modos",
                                    "Esquecer propriedades de ortogonalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar a Matriz de Modos e Dados do Sistema",
                                  "subSteps": [
                                    "Obtenha a matriz de massa M e rigidez K do modelo finito elemento.",
                                    "Resolva o problema de autovalores para obter frequências ω_i e vetores modais φ_i (primeiros N modos).",
                                    "Normalize os modos: φ_i^T M φ_i = 1 para cada i.",
                                    "Construa a matriz de modos Φ = [φ_1, φ_2, ..., φ_N].",
                                    "Verifique dimensões: Φ tem tamanho (n_dof x N), onde n_dof são graus de liberdade."
                                  ],
                                  "verification": "Confirme que Φ^T M Φ = I (matriz identidade) com cálculo matricial.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software MATLAB ou Python (NumPy/SciPy)",
                                    "Exemplo de M e K de uma estrutura aeroelástica",
                                    "Calculadora matricial online"
                                  ],
                                  "tips": "Comece com poucos modos (ex: 3-5) para simplificar; use funções prontas como eig() no MATLAB.",
                                  "learningObjective": "Preparar corretamente a matriz de modos normalizada para transformação.",
                                  "commonMistakes": [
                                    "Não normalizar modos",
                                    "Incluir modos rígidos sem cuidado",
                                    "Erros de indexação em Φ"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a Transformação de Coordenadas Físicas para Modais",
                                  "subSteps": [
                                    "Obtenha o vetor de deslocamentos físicos u (de simulação ou ensaio).",
                                    "Calcule as coordenadas modais q = Φ^T u.",
                                    "Interprete q_i como amplitude do i-ésimo modo.",
                                    "Reconstrua u aproximado: u ≈ Φ q (para verificação).",
                                    "Compare ||u - Φ q|| para avaliar precisão da redução modal."
                                  ],
                                  "verification": "O erro de reconstrução deve ser < 1% para os modos selecionados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código MATLAB/Python com u exemplo",
                                    "Dados de ensaio experimental de vibração",
                                    "Planilha Excel para vetores pequenos"
                                  ],
                                  "tips": "Use operações matriciais vetoriais para eficiência; plote u vs Φ q.",
                                  "learningObjective": "Aplicar a fórmula de transformação modal com precisão numérica.",
                                  "commonMistakes": [
                                    "Usar Φ em vez de Φ^T",
                                    "Inverter ordem da multiplicação",
                                    "Ignorar truncamento de modos altos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Interpretar Resultados da Transformação",
                                  "subSteps": [
                                    "Verifique ortogonalidade modal nos resultados: q deve excitar modos independentes.",
                                    "Analise contribuição modal: identifique modos dominantes em u.",
                                    "Compare com resposta física: energia modal ∑ q_i² ≈ u^T M u.",
                                    "Discuta limitações: truncamento modal causa erro em altas frequências.",
                                    "Documente o processo em relatório com gráficos de modos e q."
                                  ],
                                  "verification": "Relatório mostra verificações numéricas e interpretação coerente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de plotagem (MATLAB plot, Python Matplotlib)",
                                    "Template de relatório",
                                    "Dados de validação experimental"
                                  ],
                                  "tips": "Gráficos de modo shapes ajudam a visualizar; foque em modos de baixa frequência.",
                                  "learningObjective": "Validar transformação e interpretar seu significado físico.",
                                  "commonMistakes": [
                                    "Não verificar reconstrução",
                                    "Interpretar q como deslocamentos físicos",
                                    "Ignorar efeitos não-lineares"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um modelo de asa aeroelástica com 10 DOF, dada M e K, compute Φ dos 4 primeiros modos. Para u = [0.1, 0.05, ..., 0.02]^T m (deslocamentos medidos em túnel de vento), calcule q = Φ^T u, obtendo q ≈ [0.8, 0.3, -0.1, 0.05]^T, mostrando domínio do 1º modo de flexão.",
                              "finalVerifications": [
                                "Matriz Φ satisfaz Φ^T M Φ = I.",
                                "Reconstrução u ≈ Φ q com erro < 5%.",
                                "Coordenadas q capturam >90% da energia cinética.",
                                "Modos dominantes coincidem com frequências observadas.",
                                "Cálculos numéricos sem NaN ou inf.",
                                "Documentação inclui código e plots."
                              ],
                              "assessmentCriteria": [
                                "Precisão da matriz de modos (ortogonalidade verificada).",
                                "Correção da transformação q = Φ^T u.",
                                "Qualidade da validação e interpretação.",
                                "Eficiência computacional e clareza do código.",
                                "Compreensão demonstrada em relatório.",
                                "Tratamento de erros numéricos."
                              ],
                              "crossCurricularConnections": [
                                "Álgebra Linear: operações matriciais e autovalores.",
                                "Física: teoria de vibrações e modos normais.",
                                "Engenharia Computacional: análise de elementos finitos.",
                                "Matemática Numérica: normalização e truncamento.",
                                "Engenharia Aeroespacial: modelagem de estruturas flexíveis."
                              ],
                              "realWorldApplication": "Na indústria aeroespacial, usada para reduzir modelos de elementos finitos em análises de flutter e vibrações de aeronaves, como no software NASTRAN para otimizar asas de aviões comerciais, permitindo simulações eficientes de respostas dinâmicas em ensaios de túnel de vento."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.2",
                        "name": "Formulação de Equações de Movimento na Base Modal",
                        "description": "Derivação das equações de movimento dinâmicas utilizando princípios variacionais (Lagrange ou Hamilton) expressas em coordenadas modais.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.2.1",
                            "name": "Derivar equações de Lagrange modais",
                            "description": "Formular as equações de Lagrange para sistemas estruturais aeroespaciais e expressá-las em termos de coordenadas modais generalizadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar princípios Lagrangianos e análise modal básica",
                                  "subSteps": [
                                    "Estude a formulação Lagrangiana clássica: L = T - V, onde T é energia cinética e V é potencial.",
                                    "Revise a equação de Euler-Lagrange: d/dt (∂L/∂q̇) - ∂L/∂q = Q para coordenadas generalizadas q.",
                                    "Realize análise modal: resolva o problema de autovalores [K - ω²M]φ = 0 para modos φ e frequências ω.",
                                    "Ortogonalize modos: verifique ∫ φ_i^T M φ_j dV = δ_ij e ∫ φ_i^T K φ_j dV = ω_j² δ_ij.",
                                    "Discuta sistemas aeroespaciais como vigas ou placas vibrantes."
                                  ],
                                  "verification": "Resuma em um diagrama as relações entre T, V, modos e coordenadas modais; confira com referência padrão.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro 'Vibration of Mechanical Systems' de Rao",
                                    "MATLAB para análise modal",
                                    "Notas de aula sobre Lagrange"
                                  ],
                                  "tips": "Comece com sistemas discretos (MDOF) antes de contínuos para intuitividade.",
                                  "learningObjective": "Compreender a base teórica para transitar de coordenadas físicas para modais.",
                                  "commonMistakes": [
                                    "Confundir massas generalizadas com massas físicas",
                                    "Ignorar normalização modal",
                                    "Esquecer forças não-conservativas Q"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir coordenadas modais generalizadas",
                                  "subSteps": [
                                    "Expresse deslocamento u(x,t) = ∑ φ_r(x) q_r(t), onde φ_r são modos e q_r coordenadas modais.",
                                    "Defina vetor modal q(t) = [q1(t), q2(t), ..., qN(t)]^T.",
                                    "Calcule massas modais m_r = ∫ φ_r^T ρ φ_r dV e frequências ω_r.",
                                    "Verifique ortogonalidade: massas e rigidezes modais são diagonais.",
                                    "Aplique a sistemas aeroespaciais: ex., modos de flexão de asa."
                                  ],
                                  "verification": "Escreva a expansão modal para um exemplo simples e compute m_r numericamente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software ANSYS ou MATLAB Modal Analysis Toolbox",
                                    "Exemplos de modos de viga Euler-Bernoulli"
                                  ],
                                  "tips": "Use truncamento modal (N<<DOF) para praticidade computacional.",
                                  "learningObjective": "Dominar a transformação de coordenadas físicas para modais uncoupled.",
                                  "commonMistakes": [
                                    "Usar modos não-normalizados levando a coeficientes errados",
                                    "Confundir q_r com amplitudes físicas",
                                    "Ignorar modos rígidos em estruturas livres"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular energia cinética T em base modal",
                                  "subSteps": [
                                    "Escreva T = (1/2) ∫ ρ u̇^T u̇ dV = (1/2) ∑∑ m_rs q̇_r q̇_s, onde m_rs = ∫ ρ φ_r^T φ_s dV.",
                                    "Aproveite ortogonalidade: T = (1/2) ∑ m_r q̇_r².",
                                    "Inclua rotações se necessário: u̇ inclui velocidades angulares para aeroelasticidade.",
                                    "Numere para viga cantilever: compute m_r explicitamente.",
                                    "Valide com energia total física."
                                  ],
                                  "verification": "Derive T para 2 modos e confirme diagonalidade da matriz modal.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Cálculo simbólico via SymPy ou Mathematica",
                                    "Referência: 'Aeroelasticity' de Bisplinghoff"
                                  ],
                                  "tips": "Visualize com animação de modos no MATLAB para entender q̇_r.",
                                  "learningObjective": "Expressar T de forma diagonal nas coordenadas modais.",
                                  "commonMistakes": [
                                    "Não integrar sobre o volume corretamente",
                                    "Esquecer densidade ρ variável",
                                    "Confundir T com potência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular energia potencial V e derivar equações de Lagrange",
                                  "subSteps": [
                                    "Escreva V = (1/2) ∫ ε^T σ dV = (1/2) ∑∑ k_rs q_r q_s, com k_rs = ∫ φ_r^T K φ_s dV = ω_s² m_rs δ_rs.",
                                    "Assim V = (1/2) ∑ k_r q_r² = (1/2) ∑ m_r ω_r² q_r².",
                                    "Aplique Lagrange: para cada r, m_r q̈_r + m_r ω_r² q_r = Q_r, onde Q_r = ∫ φ_r^T f dV.",
                                    "Inclua aerodinâmica: Q_r com forças de pressão.",
                                    "Simplifique para forma padrão: q̈_r + ω_r² q_r = Q_r / m_r."
                                  ],
                                  "verification": "Derive EOMs completas e compare com forma canônica modal.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Papel e lápis para derivação simbólica",
                                    "MATLAB para verificação numérica",
                                    "Artigos sobre flutter modal"
                                  ],
                                  "tips": "Mantenha notação consistente: subscrito r para modo r.",
                                  "learningObjective": "Obter equações desacopladas de movimento modal.",
                                  "commonMistakes": [
                                    "Erro no sinal de V em Lagrange",
                                    "Confundir Q_r com forças físicas",
                                    "Não dividir por m_r na força generalizada"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e aplicar em contexto aeroespacial",
                                  "subSteps": [
                                    "Teste com sistema 2-DOF: derive manualmente e resolva numericamente.",
                                    "Incorpore termo aerodinâmico: Q_r ≈ ∫ φ_r p_aero dS.",
                                    "Simule resposta em frequência para verificar.",
                                    "Discuta limitações: não-linearidades, acoplamentos.",
                                    "Documente derivação completa."
                                  ],
                                  "verification": "Simulação mostra resposta modal uncoupled.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/Simulink para simulação dinâmica",
                                    "Dados de asa típica (NACA)"
                                  ],
                                  "tips": "Use plot de modos para validar intuição física.",
                                  "learningObjective": "Aplicar derivação a problemas reais aeroespaciais.",
                                  "commonMistakes": [
                                    "Ignorar acoplamento aerodinâmico residual",
                                    "Sobrestimar truncamento modal",
                                    "Erros numéricos em integração"
                                  ]
                                }
                              ],
                              "practicalExample": "Para uma viga cantilever representando uma asa simplificada: derive modos φ_r via Euler-Bernoulli, compute m_r e k_r, obtenha q̈_r + (22.37)^2 q1 = Q1/m1 para primeiro modo de flexão, simulando resposta a excitação harmônica.",
                              "finalVerifications": [
                                "Equações modais desacopladas: m_r q̈_r + k_r q_r = Q_r.",
                                "Ortogonalidade confirmada numericamente para 3 primeiros modos.",
                                "Energias T e V diagonais em q.",
                                "Simulação numérica reproduz resposta modal esperada.",
                                "Forças generalizadas Q_r corretas para carga aerodinâmica unitária.",
                                "Frequências modais coincidem com análise eigenvalue."
                              ],
                              "assessmentCriteria": [
                                "Precisão na expansão modal u = Φ q.",
                                "Correta diagonalização de T e V.",
                                "Aplicação correta de Euler-Lagrange por modo.",
                                "Inclusão e cálculo de Q_r.",
                                "Validação numérica/simulada sem discrepâncias >5%.",
                                "Clareza na documentação da derivação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Problemas de autovalores e funções ortogonais.",
                                "Programação: Implementação em MATLAB/Python para análise modal.",
                                "Física: Princípios variacionais e mecânica clássica.",
                                "Engenharia de Controle: Decoplamento para controlabilidade.",
                                "Computação Científica: Integração numérica em elementos finitos."
                              ],
                              "realWorldApplication": "Na análise de flutter de asas de aeronaves, as equações modais permitem simular instabilidades aeroelásticas eficientemente, prevendo velocidades críticas de divergência ou flutter em projetos como o Boeing 787, reduzindo testes caros em túnel de vento."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.1"
                            ]
                          },
                          {
                            "id": "10.1.6.5.2.2",
                            "name": "Incorporar amortecimento de Rayleigh",
                            "description": "Incluir o modelo de amortecimento de Rayleigh nas equações modais para representar dissipação de energia em estruturas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Equações de Movimento na Base Modal sem Amortecimento",
                                  "subSteps": [
                                    "Relembrar a transformação modal: {q} = Φ^{-1} {u}, onde {u} são deslocamentos físicos e {q} coordenadas modais.",
                                    "Escrever as equações desacopladas: M̈q + Kq = Φ^T F, com M e K diagonais.",
                                    "Verificar propriedades ortogonais dos modos: Φ^T M Φ = M_modal (diagonal), Φ^T K Φ = K_modal (diagonal).",
                                    "Discutir limitações sem amortecimento: vibrações não dissipam energia.",
                                    "Derivar frequências naturais ω_n = sqrt(k_n / m_n)."
                                  ],
                                  "verification": "Capacidade de escrever e derivar as equações modais desacopladas corretamente a partir das equações físicas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Dinâmica de Estruturas (ex: Clough & Penzien)",
                                    "Software MATLAB ou Python (NumPy/SciPy)",
                                    "Notas de aula sobre modais"
                                  ],
                                  "tips": "Use matrizes de massa e rigidez conhecidas de um exemplo simples como uma viga para praticar.",
                                  "learningObjective": "Compreender a base modal pura para preparar inclusão de dissipação.",
                                  "commonMistakes": [
                                    "Confundir coordenadas modais com físicas",
                                    "Esquecer normalização modal",
                                    "Ignorar ortogonalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Modelo de Amortecimento de Rayleigh",
                                  "subSteps": [
                                    "Definir matriz de amortecimento Rayleigh: C = α M + β K, onde α e β são coeficientes escalares.",
                                    "Explicar origens física: α representa amortecimento viscoso de massa, β de rigidez.",
                                    "Discutir vantagens: proporcionalidade mantém ortogonalidade modal aproximada.",
                                    "Calcular fatores modais: ξ_n = (α / (2 ω_n)) + (β ω_n / 2) para cada modo n.",
                                    "Escolher α e β: via ξ alvo em dois modos (ex: ξ_1 = 2%, ξ_5 = 5%)."
                                  ],
                                  "verification": "Derivar corretamente ξ_n a partir de α e β para modos dados.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Artigo clássico de Rayleigh (1877)",
                                    "Planilhas Excel para cálculo de α/β",
                                    "Código Python para plotar curvas de ξ(ω)"
                                  ],
                                  "tips": "Sempre plote ξ vs ω para visualizar o comportamento não constante.",
                                  "learningObjective": "Dominar a definição e parametrização do modelo Rayleigh.",
                                  "commonMistakes": [
                                    "Confundir α com β",
                                    "Aplicar ξ constante em vez de modal",
                                    "Não resolver sistema para α/β"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar Amortecimento Rayleigh nas Equações Modais",
                                  "subSteps": [
                                    "Transformar C para base modal: C_modal = Φ^T C Φ = α M_modal + β K_modal (diagonal aproximada).",
                                    "Escrever equações completas: M̈q + C_modal ̇q + Kq = Φ^T F.",
                                    "Para modo único: m_n q̈_n + c_n q̇_n + k_n q_n = Q_n(t).",
                                    "Resolver analiticamente para excitação harmônica: assumir q_n = A e^{iωt}.",
                                    "Implementar numericamente via Newmark ou modo superposition."
                                  ],
                                  "verification": "Implementar e simular equações com C Rayleigh em software, comparando com sem amortecimento.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "MATLAB/Octave script template para integração temporal",
                                    "Exemplo de estrutura: viga cantilever",
                                    "Biblioteca SciPy para ODE solvers"
                                  ],
                                  "tips": "Teste com α=0 (apenas β) e β=0 (apenas α) para isolar efeitos.",
                                  "learningObjective": "Integrar Rayleigh damping na formulação modal completa.",
                                  "commonMistakes": [
                                    "Não transformar C para modal",
                                    "Assumir C diagonal exata sem verificação",
                                    "Erros em unidades de α (1/s) e β (s)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Validar o Efeito do Amortecimento",
                                  "subSteps": [
                                    "Simular resposta livre: decaimento exponencial q_n(t) = A e^{-ξ_n ω_n t} cos(ω_d t).",
                                    "Comparar respostas com/ sem amortecimento em termos de amplitude e frequência.",
                                    "Ajustar α/β para matching experimental (ex: log-dec em primeiros modos).",
                                    "Avaliar limitações: Rayleigh não captura dissipação histerética.",
                                    "Documentar resultados em gráfico de decaimento modal."
                                  ],
                                  "verification": "Gráficos mostram decaimento correto e matching de ξ alvo.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Dados experimentais de vibração modal",
                                    "Software para FFT (para extrair ξ)",
                                    "Templates de plotagem (Matplotlib)"
                                  ],
                                  "tips": "Use half-power bandwidth para validar ξ de simulações.",
                                  "learningObjective": "Verificar numericamente a dissipação introduzida.",
                                  "commonMistakes": [
                                    "Sobreestimar ξ em modos altos",
                                    "Ignorar acoplamento modal residual",
                                    "Não normalizar modos"
                                  ]
                                }
                              ],
                              "practicalExample": "Modelar uma asa simplificada como viga Euler-Bernoulli com excitação aerodinâmica. Calcule α e β para ξ=1% no modo 1 (flexão) e ξ=3% no modo 3 (torção), simule resposta a pulso e observe supressão de flutter.",
                              "finalVerifications": [
                                "Equações modais incluem C_modal = α M_modal + β K_modal corretamente.",
                                "Fatores de amortecimento ξ_n calculados e plotados vs ω_n.",
                                "Simulação numérica converge com decaimento observável.",
                                "Comparação com caso sem amortecimento mostra dissipação de energia.",
                                "α e β ajustados via dois modos alvo sem inconsistências.",
                                "Limitações do modelo Rayleigh discutidas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de C Rayleigh e transformação modal (80%).",
                                "Correção no cálculo de α/β e ξ_n (90%).",
                                "Qualidade da simulação e análise de resultados (85%).",
                                "Identificação de erros comuns e limitações (70%).",
                                "Clareza na documentação e gráficos (75%).",
                                "Aplicação coerente ao contexto aeroespacial (80%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (autovalores, diagonalização).",
                                "Programação: Solução de EDOs numéricas (Runge-Kutta, Newmark).",
                                "Física: Dissipação de energia em osciladores amortecidos.",
                                "Engenharia Mecânica: Análise modal experimental.",
                                "Controle: Projeto de amortecedores passivos."
                              ],
                              "realWorldApplication": "Em projetos de aeronaves, Rayleigh damping modela dissipação em análises de flutter e vibrações, permitindo prever estabilidade estrutural durante o design de asas e fuselagens, como no Boeing 787 onde testes modais calibram α/β para simulações FEM."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.1"
                            ]
                          },
                          {
                            "id": "10.1.6.5.2.3",
                            "name": "Decoplar equações modais",
                            "description": "Decoplar as equações de movimento acopladas em um conjunto de equações independentes para cada modo de vibração.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Formulação das Equações de Movimento Acopladas na Base Modal",
                                  "subSteps": [
                                    "Obtenha as equações de movimento no domínio físico: [M]{ẍ} + [C]{ẋ} + [K]{x} = {F}.",
                                    "Aplique a transformação modal {x} = [Φ]{q}, onde [Φ] é a matriz de modos.",
                                    "Substitua na equação para obter as equações modais acopladas: [Φ^T M Φ]{q̈} + [Φ^T C Φ]{q̇} + [Φ^T K Φ]{q} = [Φ^T]{F}.",
                                    "Identifique as matrizes modais de massa [M_m], amortecimento [C_m] e rigidez [K_m], notando termos fora da diagonal que indicam acoplamento.",
                                    "Verifique as propriedades ortogonais dos modos para sistemas clássicos."
                                  ],
                                  "verification": "Confirme que as matrizes modais [M_m], [C_m] e [K_m] foram corretamente formadas e exibem termos acoplados (off-diagonal ≠ 0).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Matriz de massa/rigidez do sistema físico",
                                    "Matriz de modos [Φ]",
                                    "Software como MATLAB ou Python (NumPy/SciPy)"
                                  ],
                                  "tips": "Use simetria das matrizes para simplificar cálculos; visualize as matrizes com heatmaps para identificar acoplamentos.",
                                  "learningObjective": "Compreender a origem do acoplamento nas equações modais a partir da transformação modal.",
                                  "commonMistakes": [
                                    "Esquecer de premultiplicar por [Φ^T]",
                                    "Assumir ortogonalidade sem verificar normalização",
                                    "Ignorar contribuições do amortecimento no acoplamento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diagnosticar e Quantificar o Acoplamento Modal",
                                  "subSteps": [
                                    "Calcule os elementos fora da diagonal das matrizes [M_m], [C_m] e [K_m].",
                                    "Avalie o grau de acoplamento usando métricas como o índice de acoplamento modal (off-diagonal / diagonal).",
                                    "Para sistemas não-clássicos, identifique fontes de acoplamento (ex.: amortecimento não proporcional).",
                                    "Selecione modos relevantes (primeiros N modos) para reduzir dimensionalidade.",
                                    "Documente os valores de frequências modais naturais ω_n = sqrt(k_mm / m_mm)."
                                  ],
                                  "verification": "Gere um relatório ou tabela mostrando elementos off-diagonal > 5% da diagonal média, confirmando acoplamento.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Equações modais acopladas do Step 1",
                                    "Planilha ou script para análise de matrizes"
                                  ],
                                  "tips": "Priorize modos com maior contribuição de energia; use decomposição em valores singulares (SVD) para quantificar acoplamento.",
                                  "learningObjective": "Identificar e medir precisamente o nível de acoplamento entre modos de vibração.",
                                  "commonMistakes": [
                                    "Incluir modos irrelevantes levando a acoplamento artificial",
                                    "Normalizar incorretamente os modos",
                                    "Negligenciar acoplamento no amortecimento"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Transformação para Diagonalização e Decoplamento",
                                  "subSteps": [
                                    "Para [M_m] e [K_m] simétricas, diagonalize simultaneamente usando vetores generalizados de autovalores.",
                                    "Resolva o problema de autovalores generalizado [K_m - λ M_m] {ψ} = 0 para obter matriz modal uncoupled [Ψ].",
                                    "Aplique nova transformação {q} = [Ψ]{η}, onde [Ψ] diagonaliza as matrizes.",
                                    "Verifique que as novas matrizes [M_η] = diag(m_ηi), [K_η] = diag(k_ηi) são diagonais.",
                                    "Trate [C_η] ≈ diag se amortecimento fraco, ou use aproximações para casos não-clássicos."
                                  ],
                                  "verification": "Confirme que todas as matrizes transformadas têm off-diagonais < 1e-6 (tolerância numérica).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Matrizes modais acopladas",
                                    "Solver de autovalores (eig em MATLAB, scipy.linalg.eigh)"
                                  ],
                                  "tips": "Use solvers robustos para autovalores generalizados; normalize para m_ηi = 1.",
                                  "learningObjective": "Executar a diagonalização modal para obter equações independentes por modo.",
                                  "commonMistakes": [
                                    "Usar autovalores padrão em vez de generalizados",
                                    "Invertar ordem das transformações",
                                    "Ignorar sensibilidade numérica em modos próximos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formular e Validar as Equações Decopladas",
                                  "subSteps": [
                                    "Escreva as equações decopladas: m_ηi η̈_i + c_ηi η̇_i + k_ηi η_i = F_ηi para i=1 a N.",
                                    "Calcule forças modais F_ηi = [Ψ^T Φ^T] {F}.",
                                    "Simule resposta temporal ou frequência para um modo isolado vs. acoplado.",
                                    "Compare respostas para validar decoplamento (erro < 1%).",
                                    "Documente frequências e formas modais decopladas."
                                  ],
                                  "verification": "Simulação mostra respostas modais idênticas antes/depois do decoplamento dentro de tolerância.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Equações transformadas",
                                    "Ferramenta de simulação (ODE solvers em MATLAB/Python)"
                                  ],
                                  "tips": "Teste com excitação modal pura para isolar verificação; salve scripts para reprodutibilidade.",
                                  "learningObjective": "Derivar e confirmar equações de movimento independentes para análise modal eficiente.",
                                  "commonMistakes": [
                                    "Erro na projeção de forças modais",
                                    "Assumir decoplamento perfeito sem validação numérica",
                                    "Perder rastreabilidade das transformações"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere uma viga aeroelástica de 2 modos (flexão e torção). As equações acopladas mostram off-diagonal em [C_m] devido a amortecimento não proporcional. Após diagonalização, obtenha η̈1 + 0.1 η̇1 + (10)^2 η1 = F1 e η̈2 + 0.05 η̇2 + (20)^2 η2 = F2, permitindo análise de flutter independente por modo.",
                              "finalVerifications": [
                                "Matrizes modais transformadas são diagonais (off-diagonais < 1e-6).",
                                "Frequências modais decopladas coincidem com autovalores generalizados.",
                                "Respostas simuladas de um modo isolado vs. sistema acoplado têm erro < 1%.",
                                "Forças modais projetadas corretamente para excitação física.",
                                "Conservação de energia modal verificada.",
                                "Documentação completa com scripts reproduzíveis."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de acoplamento (métricas quantitativas corretas).",
                                "Correta aplicação de autovalores generalizados (sem erros numéricos).",
                                "Validação rigorosa via simulação (gráficos comparativos).",
                                "Clareza na derivação das equações decopladas.",
                                "Eficiência computacional demonstrada (redução dimensional).",
                                "Tratamento adequado de casos não-clássicos."
                              ],
                              "crossCurricularConnections": [
                                "Análise de autovalores em Álgebra Linear Avançada.",
                                "Simulações dinâmicas em Controle de Sistemas.",
                                "Modelagem numérica em Programação Científica (MATLAB/Python).",
                                "Análise de estabilidade em Aeroelasticidade e Flutter.",
                                "Otimização modal em Design de Estruturas."
                              ],
                              "realWorldApplication": "Em projetos de asas de aeronaves, decoplar equações modais permite análise eficiente de vibrações e flutter, reduzindo tempo de simulação de horas para minutos e previnendo falhas catastróficas como no caso do X-29 ou tail flutter em jatos comerciais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.3",
                        "name": "Modelos Aeroelásticos na Base Modal",
                        "description": "Integração das forças aerodinâmicas nos modelos modais para análise de estabilidade e resposta aeroelástica.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.3.1",
                            "name": "Incorporar forças aerodinâmicas modais",
                            "description": "Projetar forças aerodinâmicas (como as de Theodorsen ou teoria de vórtices) sobre a base modal para obter coeficientes aerodinâmicos generalizados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Base Modal e Forças Aerodinâmicas",
                                  "subSteps": [
                                    "Estude a decomposição modal de estruturas aeroespaciais usando funções modais.",
                                    "Revise equações de movimento na forma modal generalizada.",
                                    "Identifique forças aerodinâmicas básicas como lift e momento em perfis oscilantes.",
                                    "Analise a importância da acoplagem fluido-estrutura em aeroelasticidade.",
                                    "Compile referências chave como livros de Bisplinghoff ou Fung."
                                  ],
                                  "verification": "Resuma em um diagrama as componentes modais e forças aerodinâmicas, confirmando com equações padrão.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Livro 'Aeroelasticity' de Bisplinghoff",
                                    "Notas de aula sobre análise modal",
                                    "Software MATLAB para visualização modal"
                                  ],
                                  "tips": "Comece com modos fundamentais (flexão e torção) para simplificar.",
                                  "learningObjective": "Compreender a representação modal de estruturas e forças aerodinâmicas como pré-requisito para incorporação.",
                                  "commonMistakes": [
                                    "Confundir modos estruturais com modos aerodinâmicos",
                                    "Ignorar dependência de frequência nas forças"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar Teorias Aerodinâmicas: Theodorsen e Teoria de Vórtices",
                                  "subSteps": [
                                    "Derive a função de circulação de Theodorsen para perfis oscilantes em fluxo incompressível.",
                                    "Implemente a função de Theodorsen C(k) numericamente para diferentes números reduzidos k.",
                                    "Explore a teoria de vórtices de vórtice liberado e bound vortex.",
                                    "Calcule coeficientes de lift e momento para movimento harmônico simples.",
                                    "Compare resultados teóricos com dados experimentais de perfis NACA."
                                  ],
                                  "verification": "Plote |C(k)| e fase para k de 0.05 a 0.5, validando contra curvas padrão de Theodorsen.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Artigo original de Theodorsen (1935)",
                                    "MATLAB ou Python com NumPy/SciPy",
                                    "Tabelas de funções de Theodorsen"
                                  ],
                                  "tips": "Use aproximações de series de Bessel para C(k) inicialmente para evitar computação complexa.",
                                  "learningObjective": "Dominar as expressões analíticas de forças aerodinâmicas unsteady para perfis 2D.",
                                  "commonMistakes": [
                                    "Erro na definição de k = ωb/U (número reduzido)",
                                    "Negligenciar termo de wake na função C(k)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incorporar Forças Aerodinâmicas na Base Modal",
                                  "subSteps": [
                                    "Expresse forças aerodinâmicas locais em termos das funções modais estruturais.",
                                    "Projete forças sobre os modos usando produtos internos modais.",
                                    "Formule a matriz de acoplagem aerodinâmica generalizada Q(k).",
                                    "Inclua dependência de frequência e efeitos de compressibilidade se aplicável.",
                                    "Derive equações de aeroelasticidade modal acoplada."
                                  ],
                                  "verification": "Construa uma matriz Q(k) 2x2 para modos de flexão e torção, verificando simetria e propriedades.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Software de elementos finitos como NASTRAN (simulado)",
                                    "Código customizado em Python/MATLAB",
                                    "Referência 'Principles of Aeroelasticity' de Fung"
                                  ],
                                  "tips": "Use modais ortonormais para simplificar projeções.",
                                  "learningObjective": "Aplicar projeção modal para generalizar forças aerodinâmicas em múltiplos graus de liberdade.",
                                  "commonMistakes": [
                                    "Projeção incorreta sem normalização modal",
                                    "Ignorar acoplagem modal-aerodinâmica off-diagonal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Obter e Validar Coeficientes Aerodinâmicos Generalizados",
                                  "subSteps": [
                                    "Calcule coeficientes generalizados q_ij(k) a partir da matriz projetada.",
                                    "Implemente rotina numérica para varredura de k.",
                                    "Valide contra soluções analíticas para viga cantilever simples.",
                                    "Analise estabilidade aeroelástica usando equações modais.",
                                    "Documente resultados em gráficos de coeficientes vs. k."
                                  ],
                                  "verification": "Compare coeficientes com benchmarks de literatura para erro <5%.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Código fonte de exemplo em GitHub para aeroelasticidade modal",
                                    "Ferramentas de plotagem (Matplotlib)"
                                  ],
                                  "tips": "Teste com perfis simétricos primeiro para isolar efeitos.",
                                  "learningObjective": "Gerar e interpretar coeficientes aerodinâmicos generalizados para análise aeroelástica.",
                                  "commonMistakes": [
                                    "Escala errada nos coeficientes (esquecer fatores dinâmicos)",
                                    "Não considerar efeitos 3D em aproximações 2D"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule uma asa reta típica (AR=6) em fluxo subsonico, incorporando forças de Theodorsen nos primeiros 3 modos (flexão, torção, chordwise), calculando Q(k) e identificando velocidades de flutter.",
                              "finalVerifications": [
                                "Matriz Q(k) corretamente projetada e simétrica para modos acoplados.",
                                "Função C(k) implementada com precisão em faixa de k relevante (0.05-0.5).",
                                "Coeficientes generalizados coincidem com benchmarks analíticos em 95%.",
                                "Equações modais aeroelásticas derivadas sem erros dimensionais.",
                                "Análise de estabilidade mostra velocidades de flutter realistas (>Mach 0.3)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação teórica (80%+ correto).",
                                "Implementação numérica sem bugs (testes unitários passados).",
                                "Interpretação física dos coeficientes (explicação qualitativa).",
                                "Eficiência computacional (tempo <1min para varredura k).",
                                "Documentação clara com plots e equações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de valores singulares e funções complexas (Bessel).",
                                "Física: Dinâmica de fluidos incompressíveis e teoria de potencial.",
                                "Engenharia Mecânica: Vibrações modais e controle ativo.",
                                "Computação: Programação numérica e simulação CFD acoplada."
                              ],
                              "realWorldApplication": "Análise de flutter em projetos de asas de aeronaves comerciais (ex: Boeing 787), otimizando rigidez modal para evitar instabilidades em cruzeiro, economizando milhões em testes de túnel de vento."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.2"
                            ]
                          },
                          {
                            "id": "10.1.6.5.3.2",
                            "name": "Analisar estabilidade aeroelástica modal",
                            "description": "Avaliar a estabilidade de flutter ou divergência resolvendo o problema de autovalores das equações aeroelásticas modais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e formular as equações aeroelásticas modais",
                                  "subSteps": [
                                    "Estudar a teoria de aeroelasticidade modal, incluindo modos de vibração estrutural e forças aerodinâmicas.",
                                    "Derivar as equações de movimento acopladas: [M]{¨q} + [C(V)]{˙q} + [K(V)]{q} = 0, onde V é a velocidade do fluxo.",
                                    "Identificar os termos dependentes da velocidade: matriz de amortecimento [C(V)] e rigidez aerodinâmica [K(V)].",
                                    "Definir os autovalores como raízes do problema generalizado.",
                                    "Documentar as premissas do modelo (ex.: base modal truncada)."
                                  ],
                                  "verification": "Verificar se as equações foram derivadas corretamente comparando com referências padrão como Bisplinghoff.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Livro 'Aeroelasticity' de Bisplinghoff, notas de aula, calculadora simbólica (ex.: SymPy).",
                                  "tips": "Comece com um sistema de 2 graus de liberdade (ex.: bending-torsion) para simplificar.",
                                  "learningObjective": "Formular corretamente as equações diferenciais aeroelásticas na forma modal.",
                                  "commonMistakes": "Ignorar a dependência em V nas matrizes ou confundir coordenadas modais com físicas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Montar o problema de autovalores",
                                  "subSteps": [
                                    "Linearizar as equações assumindo soluções harmônicas {q} = {φ} e^{λt}.",
                                    "Transformar em problema de autovalores: ([K(V)] - λ²[M] + λ[C(V)]){φ} = 0.",
                                    "Reescrever na forma padrão: [A(V) - λI]{φ} = 0, onde [A] é a matriz companheira 2n x 2n.",
                                    "Selecionar número de modos (ex.: 4-6 primeiros modos) e calcular matrizes massas, rigidez e aerodinâmicas.",
                                    "Verificar simetria e propriedades das matrizes."
                                  ],
                                  "verification": "Construir a matriz [A(V)] para uma velocidade específica e confirmar dimensões e valores esperados.",
                                  "estimatedTime": "3 horas",
                                  "materials": "Software MATLAB ou Python (NumPy/SciPy), dados de modos modais de uma viga ou asa.",
                                  "tips": "Use funções prontas para matriz companheira para evitar erros de implementação.",
                                  "learningObjective": "Construir a matriz de autovalores dependente da velocidade corretamente.",
                                  "commonMistakes": "Erro na ordem das matrizes na forma companheira ou truncagem inadequada de modos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver numericamente o problema de autovalores",
                                  "subSteps": [
                                    "Implementar um loop sobre velocidades V críticas (ex.: de 0 a 2V_flutter).",
                                    "Para cada V, calcular autovalores e autovetores usando eig() no MATLAB ou scipy.linalg.eig().",
                                    "Plotar partes reais e imaginárias dos autovalores vs. V.",
                                    "Identificar coalescência de frequências (flutter) ou autovalor real positivo (divergência).",
                                    "Validar com método V-g ou k."
                                  ],
                                  "verification": "Gerar gráfico de root locus aeroelástico com coalescência visível em V_f.",
                                  "estimatedTime": "4 horas",
                                  "materials": "MATLAB/Python com SciPy/MATLAB Aerospace Toolbox, script de exemplo para asa típica.",
                                  "tips": "Use tolerâncias numéricas pequenas e normalize autovetores para estabilidade.",
                                  "learningObjective": "Resolver e visualizar o espectro de autovalores para diferentes velocidades.",
                                  "commonMistakes": "Escolha inadequada de passos de V levando a perda da transição crítica."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e interpretar a estabilidade",
                                  "subSteps": [
                                    "Examinar partes reais dos autovalores: positivas indicam instabilidade.",
                                    "Detectar flutter (coalescência de modos com parte real cruzando zero) e divergência (autovalor real positivo).",
                                    "Determinar velocidade crítica V_cr e modo dominante de instabilidade.",
                                    "Realizar análise de sensibilidade a parâmetros (ex.: massa, rigidez).",
                                    "Redigir relatório com conclusões e recomendações."
                                  ],
                                  "verification": "Identificar V_flutter com precisão <5% comparado a valores analíticos conhecidos.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Gráficos gerados, template de relatório.",
                                  "tips": "Foque em modos de baixa frequência, pois são mais propensos a flutter.",
                                  "learningObjective": "Interpretar resultados para avaliar estabilidade e identificar riscos.",
                                  "commonMistakes": "Confundir flutter com divergência ou ignorar modos higher-order."
                                }
                              ],
                              "practicalExample": "Analisar a estabilidade de uma asa reta típica (NACA 0012, corda 1m, envergadura 5m) com modos bending e torsion, usando dados modais de uma viga Euler-Bernoulli. Calcular V_flutter ≈ 150 m/s e confirmar com dados experimentais.",
                              "finalVerifications": [
                                "Gráfico de root locus mostra coalescência clara em V_cr.",
                                "Velocidade crítica calculada coincide com benchmark em <10%.",
                                "Identificação correta de tipo de instabilidade (flutter/divergência).",
                                "Análise de sensibilidade destaca parâmetros críticos.",
                                "Relatório resume achados com plots e conclusões.",
                                "Código reproduzível gera resultados consistentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação das equações aeroelásticas (20%).",
                                "Correta implementação numérica do solver de autovalores (30%).",
                                "Qualidade da visualização e interpretação dos resultados (25%).",
                                "Identificação precisa de V_cr e modo instável (15%).",
                                "Relatório claro e completo com análise de sensibilidade (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra linear (problemas de autovalores generalizados).",
                                "Programação: NumPy/SciPy para computação científica.",
                                "Física: Dinâmica de vibrações e teoria de controle.",
                                "Engenharia Mecânica: Análise modal de estruturas."
                              ],
                              "realWorldApplication": "No design de aeronaves, como no desenvolvimento do Boeing 737, análise de flutter modal garante que a velocidade de cruzeiro esteja abaixo de V_flutter, evitando catastróficas oscilações destrutivas em voo."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.2.3"
                            ]
                          },
                          {
                            "id": "10.1.6.5.3.3",
                            "name": "Simular resposta aeroelástica",
                            "description": "Resolver numericamente as equações modais acopladas com aerodinâmica para obter respostas transitórias ou em regime permanente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o modelo modal da estrutura",
                                  "subSteps": [
                                    "Identificar os modos de vibração relevantes da estrutura usando análise modal (primeiros 4-6 modos).",
                                    "Extrair frequências naturais (ω_n), formas modais (φ_i) e massas generalizadas (μ_i) do modelo finito elemento ou analítico.",
                                    "Normalizar as formas modais para garantir ortogonalidade (φ^T M φ = I).",
                                    "Definir coordenadas generalizadas q(t) para representar o deslocamento u(t) = Φ q(t).",
                                    "Verificar a redução modal comparando resposta estática livre com modelo completo."
                                  ],
                                  "verification": "Comparar frequências e formas modais com resultados analíticos ou FEM conhecidos; erro < 5%.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Software FEM (ANSYS/NASTRAN)",
                                    "MATLAB/Python com bibliotecas modais (SciPy modal)",
                                    "Dados de estrutura de teste (ex: ala cantilever)"
                                  ],
                                  "tips": "Comece com poucos modos para validar; aumente gradualmente para precisão.",
                                  "learningObjective": "Dominar a redução modal para simplificar equações dinâmicas de estruturas.",
                                  "commonMistakes": [
                                    "Ignorar modos antisimétricos em estruturas simétricas",
                                    "Não normalizar formas modais levando a acoplamentos espúrios",
                                    "Selecionar modos insuficientes causando perda de energia"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o modelo aerodinâmico",
                                  "subSteps": [
                                    "Escolher teoria aerodinâmica (ex: teoria de vórtices shed, painel, ou unsteady aerodynamics como Theodorsen).",
                                    "Expressar forças aerodinâmicas como função das coordenadas modais q(t), velocidades ḣ, α, e parâmetros de voo (V, Mach).",
                                    "Implementar matriz de aerodinâmica [A(q, ḣ, V)] ou funções não-lineares para acoplamento.",
                                    "Incluir efeitos de regime permanente (steady) e transitórios (unsteady wake).",
                                    "Validar forças aerodinâmicas estáticas com dados experimentais ou CFD."
                                  ],
                                  "verification": "Forças aerodinâmicas estáticas coincidem com lift/drag curves conhecidas (erro < 3%).",
                                  "estimatedTime": "2-4 horas",
                                  "materials": [
                                    "Funções Theodorsen/Matthews em MATLAB/Python",
                                    "Dados experimentais de túneis de vento",
                                    "Biblioteca AeroPy ou similar"
                                  ],
                                  "tips": "Use aproximações lineares iniciais (p-k method) antes de não-lineares.",
                                  "learningObjective": "Entender como forças aerodinâmicas dependem de movimento estrutural em aeroelasticidade.",
                                  "commonMistakes": [
                                    "Negligenciar lag no wake levando a instabilidades artificiais",
                                    "Usar coeficientes quasi-steady para altas frequências",
                                    "Erro de unidades em velocidades reduzidas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular equações modais acopladas",
                                  "subSteps": [
                                    "Escrever equações de movimento modais: μ_i ÿ_i + 2ζ_i ω_i μ_i ý_i + ω_i² μ_i q_i = Q_aero_i (q, ḣ, V).",
                                    "Acoplar todos os modos: formar vetor Q = [M] ÿ + [C] ý + [K] y = Q_aero(y, ý, V).",
                                    "Linearizar para análise de flutter (p-k ou g-methods) ou manter não-linear para transitório.",
                                    "Incluir não-linearidades se necessário (ex: grandes deslocamentos).",
                                    "Verificar equilíbrio estático: ÿ=ý=0, Q_aero = [K] y."
                                  ],
                                  "verification": "Equilíbrio estático satisfeito e matrizes simétricas onde aplicável.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Folha de equações padrão de aeroelasticidade (Bisplinghoff)",
                                    "Python/MATLAB para simbólico (SymPy)"
                                  ],
                                  "tips": "Use notação matricial para clareza; teste com caso 2DOF conhecido.",
                                  "learningObjective": "Formular corretamente EDOs acopladas estrutura-aerodinâmica.",
                                  "commonMistakes": [
                                    "Confundir massas generalizadas com massas físicas",
                                    "Esquecer amortecimento aerodinâmico",
                                    "Acoplamento incorreto de modos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar solver numérico",
                                  "subSteps": [
                                    "Escolher método: Runge-Kutta4 para transitório ou eigenvalues para regime permanente.",
                                    "Configurar condições iniciais (ex: impulso ou rampa em α).",
                                    "Implementar loop temporal: integrar ÿ = M^{-1} (Q_aero - C ý - K y).",
                                    "Aplicar filtros para ruído numérico em altas frequências.",
                                    "Executar para varredura de parâmetros (V, ρ) buscando flutter."
                                  ],
                                  "verification": "Energia conservada em ausência de dissipação; estabilidade numérica (passo dt < 1/(10 f_max)).",
                                  "estimatedTime": "3-5 horas",
                                  "materials": [
                                    "SciPy.integrate.odeint/solve_ivp",
                                    "MATLAB ode45",
                                    "Gráficos com Matplotlib"
                                  ],
                                  "tips": "Monitore resíduos de equilíbrio; use dt adaptativo.",
                                  "learningObjective": "Resolver numericamente sistemas acoplados não-lineares.",
                                  "commonMistakes": [
                                    "Passo de tempo grande causando divergência",
                                    "Índices errados em vetores modais",
                                    "Não inicializar wake corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar e validar resultados",
                                  "subSteps": [
                                    "Plotar respostas transitórias q(t), amplitudes vs V.",
                                    "Identificar flutter speed (V_f) via damping vs V ou Nyquist.",
                                    "Comparar com benchmarks analíticos/experimentais.",
                                    "Calcular envelopes de resposta e margens de segurança.",
                                    "Documentar sensibilidade a parâmetros (ζ, modos)."
                                  ],
                                  "verification": "V_f coincide com literatura (erro < 10%); curvas de damping qualitativamente corretas.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Ferramentas de FFT (SciPy.signal)",
                                    "Benchmarks de Goland Wing ou AGCARD"
                                  ],
                                  "tips": "Use logscales para amplitudes; valide múltiplos métodos.",
                                  "learningObjective": "Interpretar respostas aeroelásticas e validar simulações.",
                                  "commonMistakes": [
                                    "Interpretar oscilações numéricas como flutter",
                                    "Ignorar efeitos de massa adicionada",
                                    "Comparação com modelo errado"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule a resposta aeroelástica de uma asa cantilever típica (Goland Wing) submetida a uma rampa de ângulo de ataque em V=100 m/s, usando 4 modos, teoria de Theodorsen, identificando se ocorre flutter transitório e calculando deslocamentos máximos em q1 (bending) e q2 (torsion).",
                              "finalVerifications": [
                                "Simulação converge sem divergência numérica para V < V_f.",
                                "Resposta transitória mostra damping positivo abaixo V_f e negativo acima.",
                                "Flutter speed calculado bate com benchmark (±10%).",
                                "Envelopes de tensão estrutural dentro de limites de fadiga.",
                                "Sensibilidade a ±20% em ζ altera V_f corretamente.",
                                "Validação cruzada com método p-k linear."
                              ],
                              "assessmentCriteria": [
                                "Precisão da formulação das EDOs acopladas (100% match com teoria).",
                                "Estabilidade e precisão numérica da integração (erro < 1e-6).",
                                "Identificação correta de V_f e modos dominantes.",
                                "Análise qualitativa/quantitativa de respostas (gráficos claros).",
                                "Validação com benchmarks e discussão de limitações.",
                                "Eficiência computacional (tempo < 5 min para 10s simulação)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Solução de EDOs não-lineares e análise de estabilidade (eigenvalues).",
                                "Programação: Implementação numérica em Python/MATLAB com ODE solvers.",
                                "Física: Dinâmica de fluidos não-estacionário e vibrações acopladas.",
                                "Engenharia Mecânica: Análise modal FEM e fadiga estrutural.",
                                "Computação Científica: Otimização de solvers e paralelização."
                              ],
                              "realWorldApplication": "Previsão de flutter em projetos de aeronaves (ex: Boeing 787 certification), simulando respostas a gusts ou manobras para certificar margens de segurança FAA/EASA, evitando acidentes como o de Tacoma Narrows em pontes aeroelásticas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.3.1"
                            ]
                          },
                          {
                            "id": "10.1.6.5.3.4",
                            "name": "Aplicar redução modal",
                            "description": "Selecionar e truncar modos relevantes para reduzir a ordem do modelo aeroelástico mantendo precisão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o modelo aeroelástico completo na base modal",
                                  "subSteps": [
                                    "Obtenha o modelo estrutural finito (FEM) e realize análise modal para extrair autovalores e autovetores.",
                                    "Incorpore os efeitos aerodinâmicos (ex.: teoria de Theodorsen ou matriz aerodinâmica racional) no modelo.",
                                    "Monte a matriz de massas, rigidez e amortecimento na base modal completa.",
                                    "Verifique a estabilidade do modelo full via análise de autovalores.",
                                    "Salve os dados modais (frequências, modos, resíduos de modais)."
                                  ],
                                  "verification": "Confirme que todas as frequências modais estão corretas comparando com análise prévia ou dados experimentais.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Software de elementos finitos (NASTRAN/ANSYS), MATLAB/Python para análise modal, dados de propriedades estruturais e aerodinâmicas.",
                                  "tips": "Padronize unidades (SI) e normalize modos para facilitar comparações.",
                                  "learningObjective": "Compreender a representação modal completa de um modelo aeroelástico.",
                                  "commonMistakes": "Ignorar modos com baixa frequência mas alta contribuição aerodinâmica; não verificar ortogonalidade dos modos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e selecionar modos relevantes",
                                  "subSteps": [
                                    "Calcule contribuições modais usando energia modal, resíduos de modais ou MAC (Modal Assurance Criterion).",
                                    "Avalie frequências, amortecimento e acoplamento aeroelástico para priorizar modos.",
                                    "Defina critérios de corte: ex., modos com frequência < 3x frequência de flutter ou contribuição > 1%.",
                                    "Crie uma lista ranqueada de modos por relevância.",
                                    "Visualize modos com animações para inspeção qualitativa."
                                  ],
                                  "verification": "Lista de modos selecionados cobre >95% da energia cinética total em resposta dinâmica.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Scripts MATLAB para análise de MAC e resíduos modais, ferramentas de visualização (Patran ou MATLAB plots).",
                                  "tips": "Inclua modos anti-simétricos se o modelo for assimétrico.",
                                  "learningObjective": "Selecionar modos que capturam a dinâmica dominante sem perda significativa de precisão.",
                                  "commonMistakes": "Excluir modos locais de alta frequência que afetam picos de resposta; superestimar modos irrelevantes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar a truncagem modal para redução de ordem",
                                  "subSteps": [
                                    "Trunque as matrizes modais retendo apenas os modos selecionados (ex.: primeiros 10 de 50).",
                                    "Reconstrua o modelo reduzido: M_red, K_red, C_red na base truncada.",
                                    "Incorpore acoplamentos aerodinâmicos residuais via correções (ex.: Guyan reduction para modos descartados).",
                                    "Atualize condições de contorno e forças de excitação no modelo reduzido.",
                                    "Execute uma simulação inicial para checar estabilidade."
                                  ],
                                  "verification": "Dimensão do modelo reduzido é significativamente menor (ex.: ordem 20 vs 100) e estável.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Código customizado em MATLAB ou Python (bibliotecas como SciPy para autovalores), modelo full salvo.",
                                  "tips": "Use truncagem estática dinâmica para modos descartados se precisão for crítica.",
                                  "learningObjective": "Construir um modelo aeroelástico de ordem reduzida mantendo estrutura modal.",
                                  "commonMistakes": "Não ajustar resíduos aerodinâmicos, levando a erros em flutter; truncar demais sem validação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar precisão do modelo reduzido",
                                  "subSteps": [
                                    "Compare frequências e amortecimentos de flutter entre full e reduzido.",
                                    "Simule respostas em frequência e tempo (ex.: V-g flutter) para ambos modelos.",
                                    "Calcule métricas de erro: RMSE em respostas, shift em velocidade crítica de flutter.",
                                    "Ajuste número de modos se erro > 2-5%.",
                                    "Documente gráficos comparativos."
                                  ],
                                  "verification": "Erro médio em respostas dinâmicas < 3% e velocidade de flutter < 1% de diferença.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Ferramentas de simulação (ZAERO ou MATLAB com ode solvers), plotters para comparações.",
                                  "tips": "Teste em múltiplas velocidades de fluxo para robustez.",
                                  "learningObjective": "Avaliar e quantificar a precisão da redução modal.",
                                  "commonMistakes": "Validar apenas em regime linear, ignorando não-linearidades; usar métricas inadequadas."
                                }
                              ],
                              "practicalExample": "Para uma asa cantilever de aeronave comercial com modelo FEM de 100 DOFs, extraia 20 modos estruturais. Selecione os 6 modos com maior contribuição para flutter (frequências 5-50 Hz). Trunque para ordem 12 (6 estruturais + 6 aerodinâmicos). Valide simulando curva V-g: modelo reduzido prevê velocidade de flutter de 250 m/s vs 252 m/s full (erro 0.8%), reduzindo tempo de simulação de 10 min para 30s.",
                              "finalVerifications": [
                                "Frequências modais retidas coincidem com full em <2%.",
                                "Velocidade e frequência de flutter divergem <1%.",
                                "Respostas em frequência (FRF) sobrepostas com RMSE <3%.",
                                "Tempo de computação reduzido por fator >5x.",
                                "Estabilidade preservada em análise de autovalores.",
                                "Energia modal capturada >98%."
                              ],
                              "assessmentCriteria": [
                                "Precisão quantitativa: erro em indicadores críticos <2%.",
                                "Eficiência computacional: redução de ordem >70%.",
                                "Justificativa da seleção de modos com critérios claros.",
                                "Validação abrangente com múltiplas métricas.",
                                "Documentação completa com comparações visuais.",
                                "Robustez a variações paramétricas (ex.: Mach number)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise espectral e truncagem de séries de Fourier/modais.",
                                "Engenharia Computacional: Model order reduction (MOR) e Krylov subspaces.",
                                "Controle de Sistemas: Representação em espaço de estados reduzido.",
                                "Física: Princípios de vibrações modais e acoplamento fluido-estrutura."
                              ],
                              "realWorldApplication": "Na certificação de aeronaves (ex.: Boeing 787), redução modal acelera simulações de aeroelasticidade em túnel de vento virtual, permitindo otimizar designs de asas contra flutter divergente em horas ao invés de dias, reduzindo custos e tempo de desenvolvimento."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.1.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.6",
                    "name": "Ensaios de Aeroelasticidade em Túnel de Vento",
                    "description": "Procedimentos experimentais para testes aeroelásticos em túneis de vento.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.6.1",
                        "name": "Preparação e Modelagem de Modelos Aeroelásticos",
                        "description": "Processos para criar e escalar modelos físicos que representem fielmente a dinâmica aeroelástica de estruturas aeroespaciais, considerando similaridade dinâmica e aerodinâmica.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.6.1.1",
                            "name": "Determinar critérios de escalonamento para modelos aeroelásticos",
                            "description": "Aplicar princípios de similaridade (Reynolds, Froude, Cauchy) para escalonar massas, rigidezes, frequências e propriedades aerodinâmicas em modelos reduzidos para túneis de vento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Princípios de Similaridade Dinâmica",
                                  "subSteps": [
                                    "Estude os números adimensionais chave: Reynolds (Re = ρVL/μ), Froude (Fr = V/√(gL)) e Cauchy (Ca = ρV²/E).",
                                    "Analise a aplicabilidade de cada um em problemas aeroelásticos: Re para escoamentos viscosos, Fr para efeitos gravitacionais, Ca para inércia vs. elasticidade.",
                                    "Revise teorema de Buckingham π para derivar grupos π relevantes em aeroelasticidade.",
                                    "Compile uma tabela comparativa dos princípios com exemplos de escalonamento em modelos reduzidos.",
                                    "Discuta limitações em túneis de vento, como regime de Mach e compressibilidade."
                                  ],
                                  "verification": "Criar um resumo escrito ou tabela com definições e aplicações corretas dos três princípios, sem erros conceituais.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Livro de Mecânica dos Fluidos (ex: White)",
                                    "Notas de aula sobre similaridade dinâmica",
                                    "Calculadora científica"
                                  ],
                                  "tips": "Comece com exemplos simples de navios (Froude) para fixar conceitos antes de aeroelasticidade.",
                                  "learningObjective": "Compreender e diferenciar os princípios de similaridade aplicáveis a modelos aeroelásticos.",
                                  "commonMistakes": [
                                    "Confundir Re com Mach (Re é viscoso, Mach é compressível)",
                                    "Ignorar densidade do ar no modelo vs. full-scale"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Parâmetros Relevantes em Aeroelasticidade",
                                  "subSteps": [
                                    "Liste parâmetros geométricos (L), cinemáticos (V, ω), dinâmicos (m, k, ρ_aero) e aeroelásticos (μ massa, λ rigidez).",
                                    "Defina parâmetros não-dimensionais chave: número de massa μ = m/(ρ L²), número de Cauchy λ = m ω² L³ / (ρ V⁴), frequência reduzida k = ω L / V.",
                                    "Analise dependências: como rigidez k escala com E (módulo elástico) e geometria.",
                                    "Crie um diagrama de dependências mostrando como parâmetros aeroelásticos interagem.",
                                    "Priorize parâmetros críticos para flutter e vibrações em túneis de vento."
                                  ],
                                  "verification": "Produzir uma lista completa e diagramada de 8-10 parâmetros com seus grupos π associados, validada por fórmulas padrão.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Artigos sobre escalonamento aeroelástico (ex: NASA reports)",
                                    "Software de diagramação (Draw.io)",
                                    "Folha de cálculo Excel para grupos π"
                                  ],
                                  "tips": "Use matriz de parâmetros vs. dimensões para aplicar Buckingham π sistematicamente.",
                                  "learningObjective": "Identificar e categorizar parâmetros dimensionais e adimensionais em problemas aeroelásticos.",
                                  "commonMistakes": [
                                    "Esquecer propriedades aerodinâmicas como densidade ρ_aero",
                                    "Não considerar frequências naturais ω"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar Critérios de Escalonamento",
                                  "subSteps": [
                                    "Escolha escalas primárias: λ_L (comprimento), λ_V (velocidade), λ_ρ (densidade).",
                                    "Derive escalas derivadas: massa λ_m = λ_ρ λ_L³, rigidez λ_k = λ_ρ λ_V² λ_L, frequência λ_ω = λ_V / λ_L.",
                                    "Aplique princípios: iguale Re → λ_V = λ_μ / (λ_ρ λ_L), Fr se aplicável, Ca para elasticidade.",
                                    "Calcule escalas específicas para aeroelasticidade: μ modelo = μ full-scale, λ = constante, k = constante.",
                                    "Resolva sistema de equações para consistência, ajustando λ_ρ frequentemente."
                                  ],
                                  "verification": "Calcular e tabular escalas para um caso dado (ex: λ_L=1/10), mostrando igualdade de pelo menos 4 grupos π.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Planilha Excel ou MATLAB para cálculos simbólicos",
                                    "Referências: Scanlan & Rosen (túneis de vento)",
                                    "Papel e lápis para derivações"
                                  ],
                                  "tips": "Fixe λ_L e Re primeiro, então resolva para λ_V e λ_ρ iterativamente.",
                                  "learningObjective": "Derivar escalas de escalonamento consistentes com princípios de similaridade.",
                                  "commonMistakes": [
                                    "Inconsistência em unidades SI vs. imperial",
                                    "Não igualar múltiplos números adimensionais simultaneamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Documentar Critérios de Escalonamento",
                                  "subSteps": [
                                    "Simule numericamente os critérios usando dados hipotéticos de uma asa full-scale.",
                                    "Verifique sensibilidade: varie λ_L e observe desvios em μ, λ, k.",
                                    "Compare com casos reais de literatura (ex: modelos de ponte Tacoma Narrows).",
                                    "Documente trade-offs, como aumentar λ_ρ para rigidez prática.",
                                    "Prepare relatório com equações finais e recomendações para fabricação do modelo."
                                  ],
                                  "verification": "Gerar relatório de 1-2 páginas com cálculos validados e gráfico de sensibilidade, sem discrepâncias >5%.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "MATLAB/Python para simulação",
                                    "Literatura técnica (ex: AIAA papers)",
                                    "Template de relatório LaTeX/Word"
                                  ],
                                  "tips": "Use gráficos para visualizar igualdade de grupos π entre modelo e protótipo.",
                                  "learningObjective": "Validar critérios de escalonamento e documentar para aplicação prática.",
                                  "commonMistakes": [
                                    "Ignorar viabilidade prática (ex: materiais com E muito alta)",
                                    "Não testar gama de escalas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um modelo de asa de aeronave em escala 1:10 para túnel de vento (Re=10^6 full-scale), derive λ_ρ ≈ 100, λ_m = 10, λ_k = 1000, garantindo μ, λ e k iguais, simulando testes de flutter.",
                              "finalVerifications": [
                                "Todos os grupos π chave (Re, Ca, μ, λ, k) são iguais entre modelo e full-scale.",
                                "Escalas derivadas são dimensionalmente consistentes (ex: [k] = força/comprimento).",
                                "Cálculos numéricos para um caso de exemplo estão corretos dentro de 1% de erro.",
                                "Documentação inclui trade-offs e limitações identificadas.",
                                "Validação por simulação mostra desvios <5% em frequências reduzidas.",
                                "Relatório cobre aplicação em túnel de vento específico (velocidade, tamanho)."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual nos princípios de similaridade (90% correto).",
                                "Completude na identificação de parâmetros (todos os 8+ listados).",
                                "Correção matemática nas derivações de escalas (sem erros algébricos).",
                                "Profundidade na validação e análise de sensibilidade.",
                                "Clareza e profissionalismo na documentação (gráficos, tabelas).",
                                "Criatividade em trade-offs práticos para fabricação."
                              ],
                              "crossCurricularConnections": [
                                "Mecânica dos Fluidos: Números adimensionais Re e Fr.",
                                "Dinâmica das Estruturas: Escalonamento de massas e rigidezes.",
                                "Matemática Aplicada: Teorema de Buckingham π e álgebra dimensional.",
                                "Engenharia Mecânica: Modelagem reduzida em túneis de vento.",
                                "Física: Princípios de similaridade dinâmica."
                              ],
                              "realWorldApplication": "Em indústrias aeroespaciais (ex: Embraer, Boeing), esses critérios são usados para projetar modelos de asas e fuselagens em túneis de vento, prevendo flutter e instabilidades aeroelásticas em aeronaves reais, economizando milhões em protótipos full-scale."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.6.1.2",
                            "name": "Construir modelos dinamicamente equivalentes",
                            "description": "Utilizar técnicas de modelagem modal para ajustar massas distribuídas, rigidez flexural e torsional em modelos de asas ou fuselagens, baseados em análise de elementos finitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Realizar Análise de Elementos Finitos (FEA) no Modelo Full-Scale",
                                  "subSteps": [
                                    "Obter geometria detalhada, propriedades de materiais e condições de contorno do modelo full-scale (asa ou fuselagem).",
                                    "Criar malha finita adequada, refinando áreas críticas de alta deformação.",
                                    "Executar análise modal para extrair frequências naturais, modos de vibração, massas distribuídas e rigidezes efetivas (flexural e torsional).",
                                    "Calcular massas inerciais distribuídas e matrizes de rigidez equivalente.",
                                    "Exportar dados modais para uso em scaling."
                                  ],
                                  "verification": "Verificar convergência da malha e comparar frequências com dados experimentais conhecidos; erro < 2%.",
                                  "estimatedTime": "6-8 horas",
                                  "materials": [
                                    "Software FEA (ex: ANSYS, NASTRAN)",
                                    "Computador de alta performance",
                                    "Dados CAD do modelo full-scale"
                                  ],
                                  "tips": "Use elementos beam ou shell para eficiência; valide com análise hand-calculation para modos fundamentais.",
                                  "learningObjective": "Dominar extração de propriedades dinâmicas via FEA para modelagem aeroelástica.",
                                  "commonMistakes": "Malha grosseira levando a frequências imprecisas; ignorar efeitos de cisalhamento em vigas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar Parâmetros de Escala Dinâmica para o Modelo",
                                  "subSteps": [
                                    "Aplicar leis de similitude aeroelástica (ex: scaling de Froude para massa, Cauchy para rigidez).",
                                    "Calcular fatores de escala para comprimento, massa distribuída, rigidez flexural (EI) e torsional (GJ).",
                                    "Ajustar para os primeiros 3-5 modos modais prioritários (flexão, torção).",
                                    "Verificar matching de parâmetros dinâmicos não-dimensionais (ex: razão massa/rigidez).",
                                    "Gerar especificações alvo para o modelo físico."
                                  ],
                                  "verification": "Tabela de comparação entre propriedades full-scale e scaled; matching > 95% nos parâmetros chave.",
                                  "estimatedTime": "3-4 horas",
                                  "materials": [
                                    "Planilhas ou software MATLAB/Python para cálculos",
                                    "Referências de similitude aeroelástica"
                                  ],
                                  "tips": "Priorize modos de baixa frequência; use scaling dinâmico similar para flutter.",
                                  "learningObjective": "Aplicar princípios de similitude para equivalência dinâmica em modelos reduzidos.",
                                  "commonMistakes": "Erro em fatores de escala esquecendo densidade do fluido; não considerar modos acoplados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar e Construir o Modelo Físico Equivalente",
                                  "subSteps": [
                                    "Selecionar materiais leves e rígidos (ex: balsa, espuma, aço para spar) para matching de rigidez.",
                                    "Fabricar spar e skin com perfis ajustados para EI e GJ escalados.",
                                    "Distribuir massas (ex: contrapesos, inserts) para replicar distribuição inercial.",
                                    "Montar estrutura com juntas rígidas ou flexíveis conforme design.",
                                    "Instrumentar com acelerômetros e strain gauges para testes iniciais."
                                  ],
                                  "verification": "Medir rigidez estática (deflexão sob carga) e comparar com targets; erro < 5%.",
                                  "estimatedTime": "10-15 horas",
                                  "materials": [
                                    "Materiais: balsa, alumínio, contrapesos de chumbo",
                                    "Ferramentas: serra, lixa, balança de precisão",
                                    "Instrumentos: strain gauges"
                                  ],
                                  "tips": "Use otimização iterativa no design; teste subcomponentes individualmente.",
                                  "learningObjective": "Construir hardware que replica propriedades dinâmicas com precisão.",
                                  "commonMistakes": "Sobrecarga de massa local causando modos espúrios; juntas frouxas alterando rigidez."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Ajustar Propriedades Dinâmicas Experimentalmente",
                                  "subSteps": [
                                    "Realizar ensaios de vibração livre ou forçada no modelo (hammer test ou shaker).",
                                    "Extrair frequências e modos experimentais via FFT.",
                                    "Comparar com predições FEA scaled; calcular erros percentuais.",
                                    "Ajustar massas ou rigidez (ex: adicionar/remove material) iterativamente.",
                                    "Documentar curvas de modo e validar equivalência dinâmica final."
                                  ],
                                  "verification": "Matching de frequências modais < 5% de erro para 4 primeiros modos; modos shapes similares.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": [
                                    "Martelo de impacto ou shaker",
                                    "Acelerômetros",
                                    "Software de aquisição de dados (ex: LabVIEW)"
                                  ],
                                  "tips": "Fixe bem o modelo durante testes; use excitação broadband para múltiplos modos.",
                                  "learningObjective": "Validar modelos dinâmicos via testes modais e realizar tuning fino.",
                                  "commonMistakes": "Excitação insuficiente; ruído ambiental mascarando modos; não calibrar sensores."
                                }
                              ],
                              "practicalExample": "Construir um modelo em escala 1:8 de uma asa de caça para testes de flutter em túnel de vento subsonico. Usar FEA para extrair modos de uma asa full-scale, escalar EI flexural em 1/4096 e massa linear em 1/512, fabricar spar de balsa com inserts de aço, e validar frequências de flexão/torção em bancada modal antes do teste.",
                              "finalVerifications": [
                                "Frequências dos primeiros 4 modos modais coincidem com predições em < 5% de erro.",
                                "Distribuição de massa medida por slicing/balanço matches targets em < 3%.",
                                "Rigidez flexural e torsional via testes estáticos dentro de 4% dos valores escalados.",
                                "Modos de vibração (shapes) visualmente similares aos FEA.",
                                "Nenhum modo espúrio introduzido pela construção.",
                                "Documentação completa com curvas modais e tabelas de comparação."
                              ],
                              "assessmentCriteria": [
                                "Precisão da análise FEA inicial (convergência e validação).",
                                "Correção dos cálculos de scaling dinâmico.",
                                "Qualidade de fabricação e matching de propriedades físicas.",
                                "Eficiência dos ajustes iterativos nos testes modais.",
                                "Relatório técnico com evidências quantitativas.",
                                "Segurança e reproducibilidade do processo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de autovalores e vetores para modos modais.",
                                "Física: Dinâmica de vibrações e princípios de similitude.",
                                "Engenharia de Materiais: Seleção para matching de rigidez/massa.",
                                "Programação: Scripts para automação FEA e processamento modal.",
                                "Mecânica dos Fluidos: Contexto aeroelástico em túneis de vento."
                              ],
                              "realWorldApplication": "Na certificação de aeronaves (ex: Boeing 787), modelos dinamicamente equivalentes são usados em túneis de vento para prever e mitigar flutter, reduzindo riscos e custos de protótipos full-scale em bilhões de dólares."
                            },
                            "estimatedTime": "5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.6.1.3",
                            "name": "Verificar propriedades dinâmicas do modelo",
                            "description": "Realizar testes de vibração livre e forçada no modelo para validar frequências naturais, modos de vibração e amortecimento Rayleigh antes da entrada no túnel de vento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o modelo e o setup experimental para testes de vibração",
                                  "subSteps": [
                                    "Fixar o modelo aeroelástico em suportes que permitam vibrações livres sem restrições indesejadas",
                                    "Instalar sensores de aceleração (acelerômetros) em pontos críticos como raiz da asa, ponta e fuselagem",
                                    "Conectar o sistema de aquisição de dados (DAQ) e calibrar os sensores para precisão",
                                    "Configurar excitadores para vibração forçada, como shaker ou martelo de impacto",
                                    "Verificar alinhamento e ausência de pré-estresse no modelo"
                                  ],
                                  "verification": "Inspecionar visualmente o setup e realizar teste de sinal com pulso conhecido para confirmar resposta dos sensores",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Modelo aeroelástico, acelerômetros, DAQ (ex: NI LabVIEW), suportes ajustáveis, martelo de impacto, cabos e computador com software de análise",
                                  "tips": "Use fita adesiva refletiva em pontos de medição para facilitar identificação visual durante testes",
                                  "learningObjective": "Entender a importância da instrumentação precisa para capturar respostas dinâmicas confiáveis",
                                  "commonMistakes": "Fixação excessiva que restringe modos de vibração; calibração inadequada dos sensores levando a ruído excessivo"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar testes de vibração livre e coletar dados iniciais",
                                  "subSteps": [
                                    "Aplicar excitação inicial suave (ex: liberação de deformação ou golpe leve) para induzir vibração livre",
                                    "Gravar sinais de aceleração em múltiplos pontos por pelo menos 3 ciclos de oscilação por modo esperado",
                                    "Repetir testes em diferentes configurações (ex: rigidez variável) para capturar múltiplos modos",
                                    "Salvar dados brutos em formato compatível (ex: .mat ou .csv) com metadados de setup",
                                    "Monitorar em tempo real para detectar anomalias como colisões ou ruído"
                                  ],
                                  "verification": "Visualizar time-series dos sinais e confirmar decaimento exponencial típico de vibração livre amortecida",
                                  "estimatedTime": "2 horas",
                                  "materials": "Martelo de impacto ou sistema de liberação, software de aquisição (LabVIEW ou MATLAB), acelerômetros instalados",
                                  "tips": "Realize testes em ambiente com baixa vibração ambiente para minimizar contaminação de sinal",
                                  "learningObjective": "Capturar respostas transitórias para identificar frequências naturais e modos de vibração",
                                  "commonMistakes": "Excitação insuficiente resultando em sinal fraco; não registrar condições ambientais como temperatura"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar dados de vibração livre para frequências naturais e modos",
                                  "subSteps": [
                                    "Aplicar transformada de Fourier rápida (FFT) nos sinais para extrair picos de frequência",
                                    "Identificar modos de vibração comparando animações modais com formas teóricas (ex: flexão, torção)",
                                    "Calcular frequências naturais e formas modais usando análise modal (ex: peak-picking ou circle-fit)",
                                    "Validar consistência entre repetições e sensores",
                                    "Gerar relatórios gráficos de espectros e animações modais"
                                  ],
                                  "verification": "Frequências identificadas coincidem com pelo menos 95% de precisão em testes repetidos",
                                  "estimatedTime": "2.5 horas",
                                  "materials": "Software de análise (MATLAB com Signal Processing Toolbox ou Python com SciPy), dados coletados",
                                  "tips": "Filtre sinais com bandpass ao redor de frequências esperadas para melhorar resolução",
                                  "learningObjective": "Dominar técnicas de análise modal para validar propriedades dinâmicas",
                                  "commonMistakes": "Confundir harmônicos com modos fundamentais; ignorar efeitos de aliasing na amostragem"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Realizar testes de vibração forçada e validar amortecimento Rayleigh",
                                  "subSteps": [
                                    "Aplicar excitação harmônica com shaker em frequências próximas às naturais",
                                    "Medir curvas de resposta em frequência (FRF) e identificar picos de ressonância",
                                    "Estimar coeficientes de amortecimento Rayleigh ajustando modelo teórico aos dados",
                                    "Comparar amortecimento modal com valores projetados e ajustar se necessário",
                                    "Documentar discrepâncias e correções aplicadas ao modelo"
                                  ],
                                  "verification": "Coeficientes Rayleigh reproduzem decaimento observado com erro <10%; FRFs mostram picos consistentes",
                                  "estimatedTime": "2 horas",
                                  "materials": "Shaker eletrodinâmico, amplificador de potência, software de controle (ex: LMS Test.Lab)",
                                  "tips": "Varra frequências lentamente (sweep rate <0.1 Hz/s) perto de ressonâncias para capturar respostas precisas",
                                  "learningObjective": "Aplicar modelagem de amortecimento proporcional para simular dissipação real",
                                  "commonMistakes": "Excitação em amplitude excessiva causando não-linearidades; suposição errada de amortecimento Rayleigh uniforme"
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar resultados totais e preparar para testes em túnel de vento",
                                  "subSteps": [
                                    "Comparar todas as propriedades (frequências, modos, amortecimento) com simulações FEM",
                                    "Ajustar rigidez ou massa do modelo se discrepâncias >5%",
                                    "Gerar relatório final com gráficos, tabelas e recomendações",
                                    "Desmontar setup com cuidado para reutilização",
                                    "Arquivar dados para referência futura"
                                  ],
                                  "verification": "Relatório assinado confirma que propriedades dinâmicas atendem critérios de entrada no túnel (ex: match >95%)",
                                  "estimatedTime": "1 hora",
                                  "materials": "Software FEM (ex: NASTRAN), relatório template",
                                  "tips": "Use métricas quantitativas como MAC (Modal Assurance Criterion) para validação de modos",
                                  "learningObjective": "Integrar testes experimentais com simulações para certificação do modelo",
                                  "commonMistakes": "Ignorar discrepâncias pequenas que acumulam em aeroelasticidade; relatório incompleto"
                                }
                              ],
                              "practicalExample": "Em um modelo de asa de UAV em escala 1:10, realize testes de vibração livre golpeando a ponta da asa: identifique frequência de flexão em 15 Hz e torção em 25 Hz, ajuste amortecimento Rayleigh para combinar com decaimento observado de 2% crítico, validando contra modelo FEM antes de testes de flutter no túnel.",
                              "finalVerifications": [
                                "Frequências naturais medidas coincidem com teóricas dentro de 5%",
                                "Modos de vibração identificados correspondem visualmente às formas esperadas",
                                "Coeficientes de amortecimento Rayleigh reproduzem curvas de decaimento com erro <10%",
                                "Respostas em FRF mostram picos de ressonância sem não-linearidades evidentes",
                                "Modelo ajustado atende critérios de similaridade dinâmica para túnel de vento",
                                "Relatório inclui todos os dados brutos e análises reproduzíveis"
                              ],
                              "assessmentCriteria": [
                                "Precisão na instrumentação e coleta de dados (sem ruído excessivo)",
                                "Correta aplicação de FFT e análise modal (identificação de pelo menos 3 modos)",
                                "Validação quantitativa de amortecimento com ajuste de Rayleigh",
                                "Comparação rigorosa com simulações e ajustes propostos",
                                "Relatório claro, com gráficos e conclusões acionáveis",
                                "Segurança e limpeza no setup experimental"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Transformadas de Fourier e análise de autovalores em dinâmica linear",
                                "Física: Princípios de osciladores amortecidos e ressonância",
                                "Programação: Processamento de sinais em MATLAB/Python (SciPy, NumPy)",
                                "Engenharia Mecânica: Modelagem FEM para previsão de modos",
                                "Controle de Sistemas: Identificação de parâmetros dinâmicos"
                              ],
                              "realWorldApplication": "Na certificação de aeronaves como o Boeing 787, testes dinâmicos em modelos aeroelásticos validam propriedades para prevenir flutter catastrófico em túnel de vento, garantindo segurança estrutural em velocidades de cruzeiro supersônicas."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.6.2",
                        "name": "Instrumentação e Aquisição de Dados",
                        "description": "Seleção e configuração de sensores e sistemas para medir deformações, forças aerodinâmicas, pressões e respostas dinâmicas durante os ensaios.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.6.2.1",
                            "name": "Instalar acelerômetros e strain gauges em modelos",
                            "description": "Posicionar e calibrar sensores para capturar modos de flexão, torção e acoplamento flutter, garantindo resolução temporal adequada para frequências aeroelásticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparação do Modelo e Seleção de Sensores",
                                  "subSteps": [
                                    "Inspecione o modelo estrutural para identificar pontos de medição ótimos baseados em modos de flexão, torção e acoplamento flutter.",
                                    "Selecione acelerômetros com faixa de frequência adequada (ex: >100 Hz para aeroelasticidade) e strain gauges resistivos compatíveis com o material do modelo.",
                                    "Limpe as superfícies do modelo com álcool isopropílico para remover contaminantes.",
                                    "Planeje o layout de sensores usando software de simulação ou diagramas, considerando simetria e resolução espacial.",
                                    "Verifique calibração prévia dos sensores com certificados do fabricante."
                                  ],
                                  "verification": "Layout de sensores documentado e superfícies limpas confirmadas visualmente e por inspeção tátil.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Álcool isopropílico",
                                    "Pano sem fiapos",
                                    "Acelerômetros (ex: PCB Piezotronics)",
                                    "Strain gauges (ex: Vishay)",
                                    "Software de simulação (ex: NASTRAN ou MATLAB)",
                                    "Diagrama de layout"
                                  ],
                                  "tips": "Priorize pontos nodais conhecidos dos modos para maximizar sinal/ruído; use simetria para reduzir número de sensores.",
                                  "learningObjective": "Entender como selecionar e preparar sensores para capturar dinâmicas aeroelásticas específicas.",
                                  "commonMistakes": [
                                    "Selecionar sensores com faixa de frequência inadequada",
                                    "Ignorar contaminação de superfícies",
                                    "Não planejar layout simétrico"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Posicionamento e Fixação dos Acelerômetros",
                                  "subSteps": [
                                    "Marque posições precisas no modelo usando gabaritos ou coordenadas medidas com paquímetro.",
                                    "Aplique adesivo cianoacrilato ou epóxi de cura rápida na base do acelerômetro.",
                                    "Pressione firmemente o sensor no local marcado por 1-2 minutos, garantindo alinhamento perpendicular à superfície.",
                                    "Adicione massa de equilíbrio se necessário para minimizar influência inercial do sensor.",
                                    "Registre coordenadas GPS-like (x,y,z) de cada sensor em um log."
                                  ],
                                  "verification": "Sensores firmes ao toque e sem movimento ao aplicar força manual moderada.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Adesivo cianoacrilato ou epóxi",
                                    "Pausímetro digital",
                                    "Gabaritos de posicionamento",
                                    "Massa de equilíbrio (cera ou chumbo)",
                                    "Log de posições"
                                  ],
                                  "tips": "Use fita Kapton para proteção durante colagem; evite bolhas de ar pressionando uniformemente.",
                                  "learningObjective": "Posicionar acelerômetros para capturar acelerações em modos de flexão e torção com precisão.",
                                  "commonMistakes": [
                                    "Alinhamento incorreto causando crosstalk",
                                    "Fixação fraca levando a ruído",
                                    "Não registrar posições exatas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Instalação dos Strain Gauges",
                                  "subSteps": [
                                    "Prepare a superfície com lixa fina (400 grit) e limpador para strain gauge.",
                                    "Aplique adesivo de montagem (ex: M-Bond 43B) em camada fina no gauge e superfície.",
                                    "Posicione o strain gauge alinhado com a direção de deformação esperada (ex: longitudinal para flexão).",
                                    "Cure o adesivo sob vácuo ou com calor controlado (80°C por 1 hora).",
                                    "Proteja com revestimento siliconado ou poliuretano contra umidade."
                                  ],
                                  "verification": "Gauge elétrico com resistência nominal (±0.1%) e sem delaminação visual.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Strain gauges",
                                    "Adesivo M-Bond",
                                    "Lixa 400 grit",
                                    "Limpador especial",
                                    "Forno de cura ou câmara vácuo",
                                    "Revestimento protetor"
                                  ],
                                  "tips": "Mantenha ambiente livre de poeira (classe 1000); alinhe gauge com linhas de tensão via FEA.",
                                  "learningObjective": "Instalar strain gauges para medir deformações em torção e flutter coupling.",
                                  "commonMistakes": [
                                    "Superfície mal preparada causando falha adesiva",
                                    "Alinhamento errado da direção de strain",
                                    "Cura inadequada levando a creep"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Conexões Elétricas e Roteamento de Cabos",
                                  "subSteps": [
                                    "Solde fios de alta condutividade aos terminais dos sensores usando flux e solda sem chumbo.",
                                    "Configure circuitos Wheatstone para strain gauges e condicionadores de sinal para acelerômetros.",
                                    "Roteie cabos com strain relief e fixação com fita ou clipes, evitando loops que causem ruído EMI.",
                                    "Conecte ao sistema de aquisição de dados (DAQ) com canais dedicados.",
                                    "Teste continuidade e isolamento com multímetro."
                                  ],
                                  "verification": "Continuidade elétrica confirmada e resistência de isolamento >10 MΩ.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Fios AWG 28-30",
                                    "Solda e flux",
                                    "Multímetro",
                                    "DAQ (ex: NI cDAQ)",
                                    "Fita Kapton",
                                    "Clipes de cabo"
                                  ],
                                  "tips": "Use blindagem Faraday para cabos; roteie paralelos para minimizar crosstalk.",
                                  "learningObjective": "Estabelecer conexões elétricas robustas para transmissão de sinais de alta frequência.",
                                  "commonMistakes": [
                                    "Soldas frias causando intermitência",
                                    "Cabos soltos gerando ruído triboelétrico",
                                    "Falta de blindagem"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Calibração e Verificação Inicial",
                                  "subSteps": [
                                    "Configure DAQ com taxa de amostragem >10x frequência máxima esperada (Nyquist).",
                                    "Aplique excitação conhecida (martelo ou shaker) e compare respostas com valores teóricos.",
                                    "Calibre sensores ajustando ganhos para linearidade em flexão, torção e flutter.",
                                    "Verifique resolução temporal plotando espectros de frequência (FFT).",
                                    "Documente curvas de calibração e desvios."
                                  ],
                                  "verification": "Espectros mostram picos nos modos esperados com amplitude ±5% do teórico.",
                                  "estimatedTime": "2-3 horas",
                                  "materials": [
                                    "Shaker modal ou martelo instrumentado",
                                    "Software DAQ (LabVIEW)",
                                    "Análise FFT (MATLAB)"
                                  ],
                                  "tips": "Use excitação senoidal para calibração precisa; verifique fase entre sensores.",
                                  "learningObjective": "Calibrar sistema para resolução temporal adequada em aeroelasticidade.",
                                  "commonMistakes": [
                                    "Taxa de amostragem baixa violando Nyquist",
                                    "Não corrigir offset DC",
                                    "Ignorar crosstalk entre canais"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um modelo de asa de túnel de vento de 1m de envergadura, instale 8 acelerômetros nas nervuras para capturar 1º flexão (5 Hz) e torção (10 Hz), e 12 strain gauges na pele superior/inferior para medir acoplamento flutter, calibrando para teste a 50 m/s.",
                              "finalVerifications": [
                                "Todos sensores fixos sem delaminação após vibração simulada.",
                                "Sinais lineares com SNR >20 dB em excitação modal.",
                                "Resolução temporal captura frequências até 200 Hz sem aliasing.",
                                "Coerência >0.9 entre sensores redundantes.",
                                "Dados sincronizados em todos canais com timestamp <1 ms.",
                                "Layout documentado e reproduzível."
                              ],
                              "assessmentCriteria": [
                                "Precisão de posicionamento: erro <1 mm.",
                                "Qualidade de fixação: resiste a 10g aceleração.",
                                "Linearidade de resposta: R² >0.98.",
                                "Resolução temporal: amostragem >2 kHz para 200 Hz max.",
                                "Ausência de ruído: baseline <1% full scale.",
                                "Documentação completa de calibração."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Circuitos Wheatstone e condicionamento de sinal.",
                                "Mecânica dos Materiais: Comportamento de strain gauges em fadiga.",
                                "Processamento de Sinais: FFT e análise modal.",
                                "Programação: Scripts DAQ em LabVIEW/Python.",
                                "Segurança: Normas ASME para instrumentação em testes dinâmicos."
                              ],
                              "realWorldApplication": "Instrumentação de modelos em túneis de vento da NASA/Embraer para certificação flutter-free de asas de aeronaves comerciais, evitando falhas catastróficas como no caso do Tacoma Narrows Bridge."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.6.2.2",
                            "name": "Configurar sistemas de aquisição de dados em tempo real",
                            "description": "Integrar DAQ systems com software para registro sincronizado de velocidades de fluxo, ângulos de ataque e respostas estruturais, incluindo filtros anti-aliasing.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e Configurar Hardware DAQ",
                                  "subSteps": [
                                    "Identificar requisitos de amostragem baseados na frequência Nyquist para sinais de fluxo, ângulo e estrutura (ex: >2x frequência máxima esperada).",
                                    "Escolher placa DAQ compatível (ex: NI USB-6363) com canais analógicos suficientes e suporte a tempo real.",
                                    "Instalar drivers e conectar hardware ao PC via USB ou PCIe.",
                                    "Configurar taxa de amostragem inicial (ex: 10 kHz) e canais no software do fabricante (ex: NI MAX).",
                                    "Testar conectividade básica com loopback."
                                  ],
                                  "verification": "Hardware reconhecido no software sem erros e leituras de loopback estáveis.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Placa DAQ (ex: NI USB-6363)",
                                    "Cabo USB/PCIe",
                                    "Computador com Windows/Linux",
                                    "Software NI MAX ou equivalente"
                                  ],
                                  "tips": "Verifique compatibilidade com OS antes da compra; use cabos blindados para reduzir ruído.",
                                  "learningObjective": "Entender seleção de hardware DAQ para sinais dinâmicos em aeroelasticidade.",
                                  "commonMistakes": [
                                    "Escolher taxa de amostragem insuficiente levando a aliasing",
                                    "Ignorar ruído EMI na instalação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Integrar Sensores e Calibrar Sinais",
                                  "subSteps": [
                                    "Conectar sensores: pitot-estático para velocidade de fluxo, potenciômetro/inclinômetro para ângulo de ataque, strain gauges para respostas estruturais.",
                                    "Configurar excitação para strain gauges (ponte Wheatstone) e amplificadores de sinal.",
                                    "Realizar calibração zero e span para cada sensor usando padrões conhecidos.",
                                    "Mapear canais DAQ aos sensores no software de configuração.",
                                    "Verificar linearidade com rampas de sinal controladas."
                                  ],
                                  "verification": "Sinais calibrados mostram valores esperados para inputs conhecidos (ex: ângulo 0° = 0V).",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Sensores (pitot, inclinômetro, strain gauges)",
                                    "Amplificadores",
                                    "Fontes de excitação",
                                    "Padrões de calibração"
                                  ],
                                  "tips": "Use multímetro para verificar conexões antes de energizar; documente fatores de escala.",
                                  "learningObjective": "Calibrar sensores multi-físicos para aquisição precisa em ensaios de túnel de vento.",
                                  "commonMistakes": [
                                    "Offset não zerado causando drift",
                                    "Conexões invertidas em strain gauges"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar Software para Aquisição Síncrona",
                                  "subSteps": [
                                    "Instalar software de tempo real (ex: LabVIEW RT ou Python com PyDAQmx).",
                                    "Criar tarefa de aquisição com triggers sincronizados (ex: clock compartilhado para todos canais).",
                                    "Implementar buffer circular para dados em tempo real sem perda.",
                                    "Adicionar timestamps precisos via hardware clock.",
                                    "Testar aquisição em modo simulado com gerador de sinais."
                                  ],
                                  "verification": "Dados de múltiplos canais sincronizados com latência <1ms e sem perda de amostras.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Software LabVIEW/Python",
                                    "Gerador de sinais arbitrários"
                                  ],
                                  "tips": "Use FIFO buffers para alta taxa; monitore CPU usage para evitar overruns.",
                                  "learningObjective": "Implementar aquisição síncrona em tempo real para dados multi-canais.",
                                  "commonMistakes": [
                                    "Triggers assíncronos causando desalinhamento temporal",
                                    "Buffers pequenos levando a perda de dados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Filtros Anti-Aliasing",
                                  "subSteps": [
                                    "Calcular frequência de corte do filtro (ex: 0.4 x taxa de amostragem).",
                                    "Configurar filtros analógicos no hardware DAQ (ex: low-pass Butterworth 4ª ordem).",
                                    "Implementar filtros digitais no software (ex: FIR/IIR via SciPy).",
                                    "Verificar atenuação de frequências acima de Nyquist com análise FFT.",
                                    "Ajustar ganho para compensar roll-off do filtro."
                                  ],
                                  "verification": "Espectro FFT mostra atenuação >40dB acima da frequência Nyquist.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de análise (MATLAB/Python com FFT)",
                                    "Sinais de teste senoidais"
                                  ],
                                  "tips": "Prefira filtros analógicos para anti-aliasing primário; valide com sweep de frequência.",
                                  "learningObjective": "Aplicar teorema de Nyquist-Shannon para prevenção de aliasing em DAQ.",
                                  "commonMistakes": [
                                    "Filtro de corte muito alto permitindo aliasing",
                                    "Fase distorcida afetando sincronia"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Validar Sistema Completo",
                                  "subSteps": [
                                    "Executar teste end-to-end com modelo em túnel de vento simulado.",
                                    "Monitorar dados em tempo real via dashboard (ex: plotagens live).",
                                    "Comparar com dados de referência de alta precisão.",
                                    "Simular falhas (ex: ruído alto) e verificar robustez.",
                                    "Salvar configuração como template para reutilização."
                                  ],
                                  "verification": "Sistema captura dados sincronizados e filtrados com erro <1% vs referência.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Modelo de asa/túnel simulado",
                                    "Dados de referência"
                                  ],
                                  "tips": "Grave sessões completas; use logging para debug pós-teste.",
                                  "learningObjective": "Validar sistema DAQ para ensaios aeroelásticos reais.",
                                  "commonMistakes": [
                                    "Sobreaquecimento de hardware em testes longos",
                                    "Falta de backup de configs"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um ensaio de flutter de asa em túnel de vento, configure DAQ para sincronizar velocidade de fluxo (pitot a 50 Hz), ângulo de ataque (potenciômetro a 100 Hz) e strains (4 gauges a 1 kHz), aplicando filtro anti-aliasing de 4 kHz corte em taxa de 10 kHz, registrando dados durante oscilações induzidas por vórtices.",
                              "finalVerifications": [
                                "Sistema adquire dados de todos sensores sincronizados em tempo real sem perda.",
                                "Filtros anti-aliasing comprovados via FFT (sem aliases detectados).",
                                "Calibrações mantêm precisão <1% em range operacional.",
                                "Latência total <5ms de sensor a display.",
                                "Sistema robusto a ruído ambiente e vibrações do túnel.",
                                "Configuração exportável e repetível."
                              ],
                              "assessmentCriteria": [
                                "Precisão e sincronia dos dados adquiridos (nota quantitativa via erro RMS).",
                                "Implementação correta de filtros anti-aliasing (análise espectral).",
                                "Eficiência temporal: conclusão dentro do estimado total (8.5h).",
                                "Documentação completa de configs e calibrações.",
                                "Capacidade de troubleshooting durante validação.",
                                "Integração seamless hardware-software."
                              ],
                              "crossCurricularConnections": [
                                "Eletrônica: Circuitos de condicionamento de sinal e filtros analógicos.",
                                "Programação: Desenvolvimento em tempo real com LabVIEW/Python.",
                                "Física: Dinâmica de fluidos (fluxo) e mecânica dos sólidos (estruturas).",
                                "Matemática: Análise de Fourier e teorema de amostragem.",
                                "Engenharia de Controle: Sincronização e feedback em sistemas embarcados."
                              ],
                              "realWorldApplication": "Configuração idêntica usada em testes de certificação de aeronaves na NASA ou EMBRAER, monitorando aeroelasticidade em túneis transônicos para prevenir flutter catastrófico em voo."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.6.2.3",
                            "name": "Medir distribuições de pressão aerodinâmica",
                            "description": "Utilizar tubos de Pitot, sensores de pressão e PIV para mapear campos de pressão e velocidades ao redor do modelo durante varreduras de Mach e Reynolds.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e instalar os sensores no modelo de teste",
                                  "subSteps": [
                                    "Selecionar e posicionar tubos de Pitot em pontos estratégicos ao redor do modelo (ex.: borda de ataque, suave e dyinge).",
                                    "Instalar sensores de pressão diferencial em uma grade de pontos para mapear distribuições estáticas e totais.",
                                    "Configurar o sistema PIV com lasers, câmeras de alta velocidade e partículas traçadoras no campo de visão desejado.",
                                    "Fixar todos os componentes com suportes não intrusivos para evitar interferência aerodinâmica.",
                                    "Conectar cabos e tubulações a data loggers e verificar integridade física."
                                  ],
                                  "verification": "Inspecionar visualmente fixações, testar conexões elétricas com multímetro e confirmar ausência de vazamentos em tubos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Tubos de Pitot",
                                    "Sensores de pressão (ex.: Scanivalve)",
                                    "Sistema PIV (laser, câmeras, partículas)",
                                    "Modelo de teste (ex.: asa ou perfil aerodinâmico)",
                                    "Suportes e fita adesiva aerodinâmica",
                                    "Multímetro"
                                  ],
                                  "tips": "Marque posições exatas com coordenadas 3D para reprodutibilidade em testes futuros.",
                                  "learningObjective": "Dominar o posicionamento preciso de sensores para minimizar erros de medição aerodinâmica.",
                                  "commonMistakes": "Alinhamento incorreto dos tubos de Pitot com o fluxo, causando subestimação de velocidades."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calibrar os instrumentos de medição",
                                  "subSteps": [
                                    "Calibrar tubos de Pitot em bancada com velocidades conhecidas usando manômetros de referência.",
                                    "Realizar calibração zero e span para sensores de pressão em câmara de vácuo controlada.",
                                    "Ajustar sincronização do PIV: calibrar laser e câmeras para resolução espacial de pelo menos 1 mm/pixel.",
                                    "Testar aquisição de dados em baixa velocidade para validar leituras iniciais.",
                                    "Registrar curvas de calibração e coeficientes de correção para cada sensor."
                                  ],
                                  "verification": "Comparar leituras calibradas com valores teóricos (ex.: velocidade de Pitot vs. fórmula de Bernoulli); erro < 2%.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Manômetros de referência",
                                    "Câmara de calibração",
                                    "Software de PIV (ex.: DaVis)",
                                    "Computador com data logger"
                                  ],
                                  "tips": "Mantenha temperatura ambiente constante durante calibração para evitar deriva térmica.",
                                  "learningObjective": "Entender princípios de calibração para garantir precisão em medições dinâmicas.",
                                  "commonMistakes": "Ignorar deriva de sensores, levando a offsets sistemáticos nas distribuições de pressão."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Configurar condições de teste no túnel de vento",
                                  "subSteps": [
                                    "Definir faixa de varredura: Mach de 0.3 a 0.8 e Reynolds de 10^5 a 10^6 ajustando velocidade e pressão estática.",
                                    "Estabilizar fluxo no túnel com grades e honeycombs; medir uniformidade upstream.",
                                    "Posicionar modelo no centro da seção de teste com ângulo de ataque controlado (ex.: 0° a 12°).",
                                    "Configurar automação para varreduras contínuas ou em passos discretos.",
                                    "Verificar equilíbrio de forças no modelo com balança aerodinâmica."
                                  ],
                                  "verification": "Medir velocidade de referência no túnel e confirmar números de Mach/Re com equações; uniformidade de fluxo > 99%.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Túnel de vento soprado/supercrítico",
                                    "Controlador de velocidade/motor",
                                    "Balança aerodinâmica",
                                    "Software de controle (ex.: LabVIEW)"
                                  ],
                                  "tips": "Inicie com condições subcríticas para validar setup antes de Mach altos.",
                                  "learningObjective": "Aprender a variar parâmetros não-dimensionais para simular regimes de voo reais.",
                                  "commonMistakes": "Não corrigir por efeitos de bloqueio do modelo, distorcendo Reynolds local."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Realizar aquisição de dados durante varreduras",
                                  "subSteps": [
                                    "Iniciar varredura de Mach/Re, registrando pressões em todos pontos a cada condição.",
                                    "Capturar sequências PIV para campos de velocidade instantâneos (mínimo 100 imagens/pair).",
                                    "Monitorar em tempo real para detecção de vibrações ou instabilidades aeroelásticas.",
                                    "Repetir medições em 3 runs por condição para estatística.",
                                    "Parar aquisição se desvios > 5% forem detectados."
                                  ],
                                  "verification": "Verificar arquivos de dados completos e ausência de saturação em sensores via software de preview.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Data acquisition system (DAQ)",
                                    "Software PIV e de aquisição",
                                    "Monitor de vibração"
                                  ],
                                  "tips": "Sincronize triggers entre Pitot, pressão e PIV para dados correlacionados.",
                                  "learningObjective": "Executar testes experimentais controlados com aquisição de alta qualidade.",
                                  "commonMistakes": "Taxa de amostragem insuficiente, perdendo flutuações turbulentas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Processar e mapear campos de pressão e velocidade",
                                  "subSteps": [
                                    "Aplicar correções de calibração e filtrar ruído nos dados de pressão.",
                                    "Processar PIV para vetores de velocidade e gradientes (vorticity, strain).",
                                    "Interpolação espacial para mapas 2D/3D de Cp (coeficiente de pressão) e velocidades.",
                                    "Gerar contornos e perfis ao longo de corda/costa para análise.",
                                    "Exportar dados em formato padrão (ex.: MATLAB/CSV) com metadados de teste."
                                  ],
                                  "verification": "Comparar mapas com soluções CFD ou teoria (ex.: Cp em estagnação =1); consistência qualitativa.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de processamento (MATLAB, Tecplot, PIVlab)",
                                    "Computador de alta performance"
                                  ],
                                  "tips": "Use validação cruzada entre Pitot e PIV para velocidades médias.",
                                  "learningObjective": "Transformar dados brutos em visualizações acionáveis para análise aeroelástica.",
                                  "commonMistakes": "Escala errada em mapas, mascarando picos de sucção."
                                }
                              ],
                              "practicalExample": "Em um ensaio de perfil NACA 0012 em túnel de vento transônico, instale 32 sensores de pressão em 8 seções de corda, calibre com precisão de 0.1%, varra Mach 0.4-0.9 e Re 3-6x10^6, capture PIV para campo de velocidade na camada limite, mapeando Cp e identificando bolha de separação.",
                              "finalVerifications": [
                                "Mapas de Cp mostram distribuição simétrica em α=0° e assimetria em α>5°.",
                                "Velocidades de Pitot/PIV concordam dentro de 3% em regiões de fluxo acelerado.",
                                "Ausência de vazamentos ou ruído excessivo nos dados de pressão.",
                                "Cobertura espacial completa: >80% da superfície do modelo mapeada.",
                                "Dados processados reproduzem tendências conhecidas de literatura (ex.: pico de sucção transônico).",
                                "Arquivos salvos com metadados completos para reprodutibilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão das medições de pressão: erro médio <1% vs. referência.",
                                "Resolução espacial dos mapas: grade <5% da corda do modelo.",
                                "Consistência entre métodos (Pitot vs. PIV): correlação R² >0.95.",
                                "Tempo de processamento dentro do estimado com qualidade visual profissional.",
                                "Identificação correta de fenômenos (ex.: choque transônico via gradientes de Cp).",
                                "Relatório inclui calibrações e incertezas quantificadas."
                              ],
                              "crossCurricularConnections": [
                                "Física: Aplicação de equações de Bernoulli e conservação de massa/momento em fluidos compressíveis.",
                                "Matemática: Interpolação espacial, análise estatística e processamento de imagens em PIV.",
                                "Engenharia Mecânica: Design e calibração de sensores piezoresistivos.",
                                "Computação: Programação em Python/MATLAB para automação de DAQ e visualização.",
                                "Engenharia de Controle: Sincronização de sistemas em tempo real."
                              ],
                              "realWorldApplication": "Essas medições são essenciais no desenvolvimento de aeronaves comerciais (ex.: Boeing 787), onde mapas de pressão validam modelos CFD para otimizar eficiência aerodinâmica, reduzir drag e prevenir flutter aeroelástico em regimes transônicos."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.6.3",
                        "name": "Execução e Análise de Ensaios Aeroelásticos",
                        "description": "Procedimentos operacionais no túnel de vento e métodos para identificar instabilidades como flutter, divergência e buffeting a partir dos dados experimentais.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.6.3.1",
                            "name": "Realizar varreduras de velocidade e ângulo de ataque",
                            "description": "Incrementar gradualmente o número de Mach e ângulos de incidência para detectar onset de flutter, registrando amplitudes e fases de resposta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o modelo aeroelástico e o túnel de vento",
                                  "subSteps": [
                                    "Instalar o modelo aeroelástico no suporte do túnel de vento, garantindo fixação segura.",
                                    "Verificar integridade estrutural do modelo, inspecionando por rachaduras ou deformações.",
                                    "Configurar condições ambientais iniciais: temperatura, pressão e fluxo de ar zero.",
                                    "Realizar testes de vibração livre para baseline.",
                                    "Documentar configuração inicial com fotos e anotações."
                                  ],
                                  "verification": "Modelo instalado corretamente e testes de vibração livre mostram respostas estáveis sem flutter.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Modelo aeroelástico",
                                    "Túnel de vento",
                                    "Ferramentas de fixação",
                                    "Câmera para documentação"
                                  ],
                                  "tips": "Sempre use torque especificado nas porcas de fixação para evitar folgas.",
                                  "learningObjective": "Compreender a importância da preparação precisa para ensaios confiáveis.",
                                  "commonMistakes": "Fixação inadequada levando a vibrações espúrias; ignorar inspeção visual."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar e calibrar instrumentos de medição",
                                  "subSteps": [
                                    "Instalar acelerômetros e strain gauges em pontos críticos do modelo (dicas de asas, raiz).",
                                    "Conectar sensores a data acquisition system (DAQ) e verificar sinal-noise ratio.",
                                    "Calibrar velocímetro do túnel para Mach preciso e medidor de ângulo de ataque.",
                                    "Executar calibração estática: medir respostas em velocidades zero.",
                                    "Testar aquisição de dados com sinal de referência conhecido."
                                  ],
                                  "verification": "Sinais calibrados com erro <5% em testes estáticos; DAQ registrando dados limpos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Acelerômetros",
                                    "Strain gauges",
                                    "DAQ system",
                                    "Software de aquisição (ex: LabVIEW)"
                                  ],
                                  "tips": "Posicione sensores longe de bordas para evitar ruído aerodinâmico.",
                                  "learningObjective": "Dominar calibração de sensores para medições precisas de amplitudes e fases.",
                                  "commonMistakes": "Calibração inadequada causando offsets nos dados; conexões soltas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar varredura de velocidade (número de Mach)",
                                  "subSteps": [
                                    "Iniciar túnel em Mach baixo (ex: 0.3), registrar amplitudes e fases por 30s.",
                                    "Incrementar Mach em passos de 0.1 até regime alvo (ex: 2.0), estabilizando 1min por passo.",
                                    "Monitorar respostas em tempo real via osciloscópio ou software.",
                                    "Registrar dados: amplitude RMS, fase vs frequência para cada Mach.",
                                    "Parar se detectar crescimento exponencial de vibrações."
                                  ],
                                  "verification": "Dados registrados para cada incremento de Mach com amplitudes e fases plotadas.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Túnel de vento operacional",
                                    "Software de monitoramento",
                                    "Computador com plots em tempo real"
                                  ],
                                  "tips": "Aumente velocidade devagar para capturar transição suave ao flutter.",
                                  "learningObjective": "Aprender a detectar onset de flutter via crescimento de amplitudes com Mach.",
                                  "commonMistakes": "Incrementos muito grandes pulando onset; não estabilizar fluxo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar varredura de ângulo de ataque",
                                  "subSteps": [
                                    "Fixar Mach dinâmico (ex: próximo ao flutter detectado), iniciar em α=0°.",
                                    "Incrementar α em passos de 1° até 10°, registrando por 30s cada.",
                                    "Monitorar mudanças em amplitudes e fases com variação de incidência.",
                                    "Plotar respostas vs α em tempo real.",
                                    "Identificar flutter por descolamento ou crescimento instável."
                                  ],
                                  "verification": "Curvas de amplitude e fase vs α completas e consistentes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Medidor de ângulo de ataque",
                                    "Sistema de ajuste de incidência",
                                    "DAQ"
                                  ],
                                  "tips": "Mantenha Mach constante usando controle automático do túnel.",
                                  "learningObjective": "Entender influência do ângulo de ataque no onset de flutter.",
                                  "commonMistakes": "Variações involuntárias de Mach; ignorar histerese em α."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar dados e registrar onset de flutter",
                                  "subSteps": [
                                    "Processar dados: FFT para espectros de frequência, Nyquist plots.",
                                    "Identificar onset: amplitude crescendo >10% por ciclo ou fase shift >90°.",
                                    "Plotar curvas de amortecimento vs velocidade/α.",
                                    "Comparar com critérios teóricos (ex: Flutter Mach number).",
                                    "Gerar relatório com gráficos e conclusões."
                                  ],
                                  "verification": "Relatório com identificação clara do onset de flutter e plots validados.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Software de análise (MATLAB/Python)",
                                    "Templates de relatório"
                                  ],
                                  "tips": "Use filtros bandpass para isolar modos críticos.",
                                  "learningObjective": "Desenvolver habilidades de análise para predizer limites aeroelásticos.",
                                  "commonMistakes": "Interpretação errada de ruído como flutter; falta de normalização de dados."
                                }
                              ],
                              "practicalExample": "Em um túnel de vento transônico, teste um modelo de asa de caça em Mach de 0.6 a 1.2 (incrementos 0.05), α fixo 2°. Registre acelerações nas asas; detecte flutter em Mach 0.95 onde amplitude dobra e fase salta 120°.",
                              "finalVerifications": [
                                "Todos incrementos de Mach e α executados com dados completos.",
                                "Onset de flutter identificado com Mach crítico e α correspondente.",
                                "Amplitudes e fases registradas com precisão <5% erro.",
                                "Plots de resposta vs parâmetros gerados e analisados.",
                                "Relatório documenta configuração, dados e conclusões.",
                                "Modelo removido sem danos pós-ensaio."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos incrementos de Mach e α (erro <0.01 Mach, <0.5°).",
                                "Qualidade dos dados: sinal-noise >20dB, registro contínuo.",
                                "Detecção correta de flutter via critérios quantitativos.",
                                "Análise inclui FFT e plots de amortecimento.",
                                "Relatório claro, com conexões teóricas.",
                                "Segurança: parada automática em instabilidades."
                              ],
                              "crossCurricularConnections": [
                                "Física: Dinâmica de fluidos compressíveis e vibrações.",
                                "Matemática: Análise espectral (FFT) e métodos numéricos.",
                                "Engenharia de Controle: Estabilidade de sistemas dinâmicos.",
                                "Ciência de Materiais: Comportamento de estruturas sob carga aeroelástica.",
                                "Informática: Processamento de sinais em Python/MATLAB."
                              ],
                              "realWorldApplication": "Essencial na certificação de aeronaves supersônicas (ex: F-35, Boeing 787) para determinar envelopes de voo seguros, evitando catastróficos flutter como no Tacoma Narrows, garantindo operação em regimes críticos de Mach e α."
                            },
                            "estimatedTime": "5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.6.3.2",
                            "name": "Identificar velocidades críticas de flutter",
                            "description": "Aplicar métodos como K-method ou p-k para correlacionar dados experimentais com previsões teóricas, plotando V-g e V-f diagrams.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar teoria de flutter e preparar previsões teóricas",
                                  "subSteps": [
                                    "Estude os princípios fundamentais de flutter aeroelástico, incluindo modos de vibração e acoplamento aerodinâmico-estrutural.",
                                    "Calcule frequências naturais e amortecimentos modais do modelo usando análise modal finita (FEM).",
                                    "Implemente equações teóricas para prever velocidades de flutter com base em parâmetros como massa, rigidez e densidade do fluido.",
                                    "Gere curvas iniciais V-g (velocidade vs. amortecimento) e V-f (velocidade vs. frequência) usando software de simulação.",
                                    "Valide as previsões teóricas contra literatura ou dados históricos de modelos semelhantes."
                                  ],
                                  "verification": "Verifique se as curvas V-g e V-f teóricas mostram um ponto de amortecimento zero (flutter) e compare com benchmarks conhecidos.",
                                  "estimatedTime": "4 hours",
                                  "materials": [
                                    "Software FEM como NASTRAN ou ANSYS",
                                    "Livros/textos sobre aeroelasticidade (ex: Bisplinghoff)",
                                    "Planilhas ou MATLAB para cálculos iniciais"
                                  ],
                                  "tips": "Comece com um modelo simplificado (2 graus de liberdade) para entender o conceito antes de complexificar.",
                                  "learningObjective": "Compreender os fundamentos teóricos de flutter e gerar previsões iniciais precisas.",
                                  "commonMistakes": [
                                    "Ignorar efeitos não-lineares no início",
                                    "Usar unidades inconsistentes (ex: m/s vs. ft/s)",
                                    "Subestimar o papel do amortecimento estrutural"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar e executar ensaio experimental em túnel de vento",
                                  "subSteps": [
                                    "Monte o modelo aeroelástico em escala no túnel de vento, instrumentando com acelerômetros, strain gauges e sensores de pressão.",
                                    "Calibre os instrumentos e configure condições de fluxo (velocidade Mach, ângulo de ataque, Reynolds number).",
                                    "Aumente gradualmente a velocidade do vento enquanto monitora respostas vibratórias em tempo real.",
                                    "Registre dados de aceleração, deformação e pressão em múltiplos pontos do modelo para várias velocidades.",
                                    "Pare o ensaio imediatamente ao detectar onset de flutter e documente condições exatas."
                                  ],
                                  "verification": "Confirme que dados de vibração foram capturados sem perda em pelo menos 10 velocidades incrementais até o flutter.",
                                  "estimatedTime": "6 hours",
                                  "materials": [
                                    "Modelo aeroelástico em escala",
                                    "Túnel de vento subsonico/supersonico",
                                    "Sistema de aquisição de dados (DAQ) como LabVIEW",
                                    "Acelerômetros e osciloscópios"
                                  ],
                                  "tips": "Use filtros passa-baixa para evitar ruído de alta frequência nos sinais experimentais.",
                                  "learningObjective": "Executar um ensaio seguro e controlado, coletando dados experimentais de alta qualidade.",
                                  "commonMistakes": [
                                    "Aumentar velocidade muito rápido, perdendo dados do onset",
                                    "Falta de calibração de sensores",
                                    "Ignorar vibrações não-flutter como buffeting"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Processar dados experimentais e extrair parâmetros modais",
                                  "subSteps": [
                                    "Limpe os dados brutos removendo offsets, filtros e normalizando sinais de aceleração.",
                                    "Aplique FFT (Fast Fourier Transform) para identificar frequências e amortecimentos modais em cada velocidade.",
                                    "Extraia modos dominantes e rastreie sua evolução com a velocidade do fluxo.",
                                    "Calcule damping ratios (ζ) e frequências naturais (ω) para cada modo usando métodos como peak-picking ou circle-fit.",
                                    "Gere tabelas de dados modais vs. velocidade para correlação posterior."
                                  ],
                                  "verification": "As curvas de frequência e amortecimento extraídas devem ser suaves e convergentes para velocidades baixas.",
                                  "estimatedTime": "3 hours",
                                  "materials": [
                                    "Software MATLAB ou Python (SciPy) para processamento de sinais",
                                    "Arquivos de dados .csv do DAQ"
                                  ],
                                  "tips": "Use janelas Hanning para FFT para reduzir leakage espectral.",
                                  "learningObjective": "Extrair parâmetros modais precisos de dados experimentais ruidosos.",
                                  "commonMistakes": [
                                    "Sobreajuste de modos irrelevantes",
                                    "Erro na identificação de damping devido a ruído",
                                    "Não sincronizar dados de múltiplos sensores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar métodos K-method ou p-k para correlação",
                                  "subSteps": [
                                    "Implemente o K-method: defina K = V / (b ω), onde b é semi-corda, e itere para encontrar V_flutter onde damping=0.",
                                    "Ou use p-k method: resolva equações complexas p = σ + iω com aerodinâmica aproximada (ex: Theodorsen).",
                                    "Correlacione parâmetros experimentais (ω_exp, ζ_exp) com teóricos ajustando fatores de escala.",
                                    "Otimize parâmetros (ex: rigidez efetiva) minimizando erro entre curvas experimentais e teóricas.",
                                    "Valide convergência do método comparando múltiplas iterações."
                                  ],
                                  "verification": "Erro de correlação <10% entre V_flutter teórico e experimental.",
                                  "estimatedTime": "5 hours",
                                  "materials": [
                                    "Códigos MATLAB/Python para K-method/p-k",
                                    "Documentação de métodos (NASA reports)"
                                  ],
                                  "tips": "Comece com K-method para simplicidade antes de p-k mais avançado.",
                                  "learningObjective": "Aplicar métodos padrão para prever e correlacionar velocidades de flutter.",
                                  "commonMistakes": [
                                    "Má convergência devido a passos iniciais ruins em K",
                                    "Ignorar aerodinâmica unsteady",
                                    "Confundir reduced frequency k com outros parâmetros"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Plotar diagramas V-g, V-f e identificar velocidades críticas",
                                  "subSteps": [
                                    "Plote curvas V-g (velocidade vs. damping de modos) e V-f (velocidade vs. frequência) combinando dados teóricos e experimentais.",
                                    "Identifique velocidades críticas onde damping cruza zero ou modos coalescem.",
                                    "Marque V_flutter experimental e teórico, calculando margens de segurança.",
                                    "Gere relatório com gráficos sobrepostos e tabela de discrepâncias.",
                                    "Analise sensibilidade a variações de parâmetros (ex: ±10% massa)."
                                  ],
                                  "verification": "Diagramas mostram clareza no ponto de flutter com legendas e escalas apropriadas.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "MATLAB/Origin para plotting",
                                    "Templates de gráficos V-g/V-f"
                                  ],
                                  "tips": "Use log-scale para damping em V-g para melhor visualização.",
                                  "learningObjective": "Visualizar e interpretar resultados para identificação precisa de velocidades críticas.",
                                  "commonMistakes": [
                                    "Escalas inadequadas obscurecendo cruzamento",
                                    "Não plotar barras de erro experimentais",
                                    "Confundir flutter com LCO (limite cycle oscillation)"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um ensaio de uma asa em escala de um jato comercial no túnel de vento NASA, dados experimentais mostram flutter a 45 m/s (Mach 0.15), correlacionado com previsão teórica de 47 m/s usando p-k method, ajustando damping estrutural em 5%, plotando V-g com coalescência de 1º e 2º modos de flexão-torção.",
                              "finalVerifications": [
                                "Curvas V-g e V-f mostram amortecimento zero em V_flutter consistente entre teoria e experimento.",
                                "Erro de correlação K-method/p-k < 5-10%.",
                                "Identificação correta de modos coalescentes responsáveis pelo flutter.",
                                "Gráficos incluem dados experimentais com barras de erro e sobreposição teórica.",
                                "Relatório discute implicações para design seguro.",
                                "Análise de sensibilidade confirma robustez das previsões."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração de modais experimentais (erro damping <5%).",
                                "Correta implementação e convergência de K-method ou p-k.",
                                "Qualidade dos diagramas V-g/V-f (clareza, legendas, escalas).",
                                "Correlação quantitativa entre teoria e experimento.",
                                "Identificação precisa de V_critica com justificativa modal.",
                                "Relatório completo com análise de erros e recomendações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise complexa e equações diferenciais para p-k method.",
                                "Programação: Processamento de sinais em Python/MATLAB (FFT, otimização).",
                                "Física: Dinâmica de fluidos e vibrações modais.",
                                "Engenharia Mecânica: Análise finita de elementos (FEM).",
                                "Estatística: Análise de incerteza e sensibilidade em dados experimentais."
                              ],
                              "realWorldApplication": "Em certificação de aeronaves (ex: Boeing 787), identificar V_flutter garante margens de segurança >15% acima de V_dive, prevenindo falhas catastróficas como o incidente do X-29, otimizando peso e performance."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.6.3.3",
                            "name": "Analisar respostas para estabilidade e buffeting",
                            "description": "Processar sinais com FFT para espectros de potência, PSD e coerência, avaliando amortecimento equivalente e limites de resposta RMS.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Pré-processar Sinais de Resposta",
                                  "subSteps": [
                                    "Coletar dados de aceleração, pressão e forças do ensaio em túnel de vento.",
                                    "Remover offsets DC e filtrar ruídos de alta frequência usando filtros passa-baixa.",
                                    "Dividir sinais em segmentos sobrepostos com janela de Hanning para reduzir vazamento espectral.",
                                    "Normalizar os sinais e verificar integridade (ausência de picos anômalos).",
                                    "Calcular médias e desvios padrão iniciais para baseline."
                                  ],
                                  "verification": "Sinais pré-processados mostram espectros limpos sem artefatos visíveis em visualização preliminar.",
                                  "estimatedTime": "1-2 horas",
                                  "materials": [
                                    "Software MATLAB ou Python (SciPy/NumPy)",
                                    "Dados brutos do ensaio (.mat ou .csv)",
                                    "Documentação do ensaio aeroelástico"
                                  ],
                                  "tips": "Use 50% de sobreposição nos segmentos para melhor resolução; sempre plote sinais no tempo e frequência antes de prosseguir.",
                                  "learningObjective": "Dominar técnicas de pré-processamento para preparar sinais confiáveis para análise espectral.",
                                  "commonMistakes": [
                                    "Ignorar vazamento espectral sem janelamento",
                                    "Não remover offsets DC levando a picos espúrios em baixa frequência",
                                    "Usar segmentos muito curtos reduzindo resolução de frequência"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Computar Transformada Rápida de Fourier (FFT) e Espectros de Potência",
                                  "subSteps": [
                                    "Aplicar FFT aos segmentos pré-processados usando função fft() no MATLAB/Python.",
                                    "Calcular espectro de potência bilateral e convertê-lo para unilateral (dobrar e dividir por 2 acima de f_s/2).",
                                    "Gerar gráfico de amplitude vs. frequência para identificar picos modais.",
                                    "Calcular resolução de frequência (Δf = f_s / N) e validar com Nyquist.",
                                    "Exportar espectros para análise subsequente."
                                  ],
                                  "verification": "Espectros de potência exibem picos claros nos modos esperados de flutter ou buffeting.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código MATLAB/Python para FFT",
                                    "Bibliotecas: numpy.fft ou signal.welch"
                                  ],
                                  "tips": "Escolha N (tamanho FFT) como potência de 2 para eficiência; verifique normalização pela integral do espectro.",
                                  "learningObjective": "Aplicar FFT corretamente para obter representações espectrais precisas de respostas vibratórias.",
                                  "commonMistakes": [
                                    "Esquecer de janelar causando vazamento",
                                    "Não converter para densidade espectral unilateral",
                                    "Ignorar aliasing por amostragem inadequada"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular PSD e Funções de Coerência",
                                  "subSteps": [
                                    "Usar método de Welch para estimar PSD médio de múltiplos segmentos.",
                                    "Calcular PSD cruzado entre sinais de entrada (ex: velocidade do vento) e saída (aceleração).",
                                    "Computar coerência γ²(f) = |G_xy|² / (G_xx * G_yy) para validar causalidade.",
                                    "Identificar faixas de frequência com alta coerência (>0.8) para análise de buffeting.",
                                    "Plotar PSD, PSD cruzado e coerência em gráficos sobrepostos."
                                  ],
                                  "verification": "Coerência alta nas frequências de interesse confirma relação física entre excitação e resposta.",
                                  "estimatedTime": "1-1.5 horas",
                                  "materials": [
                                    "Funções pwelch() no MATLAB ou scipy.signal.welch() no Python"
                                  ],
                                  "tips": "Aumente número de segmentos para reduzir variância no PSD; foque em coerência para descartar ruído.",
                                  "learningObjective": "Interpretar PSD e coerência para quantificar energia vibratória e acoplamento.",
                                  "commonMistakes": [
                                    "Média insuficiente de segmentos levando a PSD ruidoso",
                                    "Confundir PSD unilateral com bilateral",
                                    "Interpretar baixa coerência como ausência de buffeting (pode ser ruído)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Avaliar Amortecimento Equivalente e Estabilidade",
                                  "subSteps": [
                                    "Identificar picos modais nos PSD e estimar frequências naturais.",
                                    "Calcular amortecimento equivalente ζ usando largura de banda Δω do pico (ζ ≈ Δω / (2ω_n)).",
                                    "Verificar critérios de flutter (V_f = ω_n * b / k_α, onde k_α é gradiente de pressão).",
                                    "Comparar amortecimento com limites de estabilidade (ex: ζ > 0.02 para divergência).",
                                    "Documentar margens de estabilidade vs. velocidade do túnel."
                                  ],
                                  "verification": "Valores de ζ consistentes com simulações e literatura para o modelo testado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Fórmulas de aeroelasticidade (Livro Bisplinghoff)",
                                    "Ferramentas de curve fitting (lsqcurvefit MATLAB)"
                                  ],
                                  "tips": "Use half-power bandwidth para ζ preciso; valide com circle fit no plano Nyquist se dados complexos disponíveis.",
                                  "learningObjective": "Extrair parâmetros de estabilidade de espectros para previsão de flutter.",
                                  "commonMistakes": [
                                    "Medir largura errada do pico (usar -3dB points)",
                                    "Não considerar modos acoplados",
                                    "Ignorar efeitos não-lineares em altas velocidades"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Determinar Limites de Resposta RMS para Buffeting",
                                  "subSteps": [
                                    "Integrar PSD na faixa de buffeting (ex: 0.5-10 Hz) para obter RMS da resposta.",
                                    "Comparar RMS com limites de fadiga (ex: 0.5g para asas comerciais).",
                                    "Estimar fator de pico (k_p ≈ 3-5 para Gaussianos) para cargas máximas.",
                                    "Gerar envelope de resposta vs. velocidade e Mach number.",
                                    "Recomendar velocidades operacionais seguras."
                                  ],
                                  "verification": "Limites RMS abaixo de critérios de certificação (ex: FAR 25.305).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Tabelas de limites FAR/JAR",
                                    "Software de integração numérica"
                                  ],
                                  "tips": "Use rainflow counting para fadiga se dados longos; considere direção do vento para worst-case.",
                                  "learningObjective": "Quantificar severidade de buffeting e definir envelopes operacionais.",
                                  "commonMistakes": [
                                    "Integrar todo o espectro ignorando faixas específicas",
                                    "Subestimar fator de pico",
                                    "Não normalizar por área dinâmica"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um ensaio de túnel de vento de uma asa de UAV a Ma=0.3, processe acelerações de strain gauges: PSD revela pico de buffeting a 5Hz com ζ=0.015; RMS=0.4g excede limite de 0.3g, recomendando reforço estrutural.",
                              "finalVerifications": [
                                "Espectros de potência e PSD mostram picos modais claros sem artefatos.",
                                "Coerência >0.7 nas faixas críticas confirma excitação aerodinâmica.",
                                "Amortecimento equivalente calculado com erro <10% vs. métodos alternativos.",
                                "Limites RMS de resposta validados contra critérios regulatórios.",
                                "Relatório inclui gráficos, cálculos e recomendações acionáveis.",
                                "Reproduzibilidade: reprocessar dados dá resultados idênticos (±5%)."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos espectros (resolução Δf <1% da frequência modal).",
                                "Correção na estimativa de ζ (consistência com teoria).",
                                "Interpretação física da coerência e buffeting.",
                                "Qualidade dos gráficos e documentação.",
                                "Aplicação correta de limites RMS e fatores de segurança.",
                                "Identificação de anomalias e justificativas."
                              ],
                              "crossCurricularConnections": [
                                "Processamento de Sinais Digitais: FFT, PSD e Welch (Engenharia Elétrica).",
                                "Estatística e Probabilidade: Análise de variância e processos estocásticos.",
                                "Mecânica dos Materiais: Fadiga e limites de endurance.",
                                "Controle Automático: Análise de estabilidade em malha fechada.",
                                "Física Computacional: Simulações CFD para validação."
                              ],
                              "realWorldApplication": "Durante certificação de aeronaves como o Boeing 787, análise de buffeting em túnel de vento define V_b (velocidade de buffeting onset), evitando vibrações excessivas em cruzeiro e garantindo vida útil estrutural."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.6.3.4",
                            "name": "Validar modelos com dados experimentais",
                            "description": "Comparar frequências, modos e margens de flutter experimentais com simulações modais e CFD, ajustando discrepâncias para certificação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar e Organizar Dados Experimentais e de Simulação",
                                  "subSteps": [
                                    "Coletar dados experimentais de frequências, modos de vibração e margens de flutter do túnel de vento.",
                                    "Extrair resultados de simulações modais (ex: FEM) e CFD (ex: velocidades críticas de flutter).",
                                    "Normalizar unidades e formatos de dados para compatibilidade (ex: Hz para frequências, m/s para velocidades).",
                                    "Criar tabelas ou gráficos comparativos iniciais.",
                                    "Documentar metadados como condições de teste (Mach, densidade do ar)."
                                  ],
                                  "verification": "Verificar se todos os dados estão em um dataset unificado sem erros de unidade ou missing values.",
                                  "estimatedTime": "4-6 horas",
                                  "materials": "Dados experimentais (arquivos .txt ou .csv), software FEM (ANSYS/Nastran), CFD (FLUENT), Excel/MATLAB para organização.",
                                  "tips": "Use scripts automatizados em Python para importação e limpeza de dados para eficiência.",
                                  "learningObjective": "Entender a importância da padronização de dados para comparações precisas.",
                                  "commonMistakes": "Ignorar variações em condições ambientais entre testes experimentais e simulações."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Comparar Frequências e Modos de Vibração",
                                  "subSteps": [
                                    "Plotar curvas de frequências experimentais vs. modais simuladas em função da velocidade do ar.",
                                    "Identificar modos dominantes (ex: flexão, torção) e calcular percentuais de discrepância.",
                                    "Aplicar análise modal (MAC - Modal Assurance Criterion) para correlacionar modos.",
                                    "Realizar testes estatísticos (ex: t-test) para significância das diferenças.",
                                    "Registrar discrepâncias acima de 5-10% para investigação."
                                  ],
                                  "verification": "Gráficos e tabelas mostram sobreposição de modos com MAC > 0.9 e discrepâncias quantificadas.",
                                  "estimatedTime": "6-8 horas",
                                  "materials": "MATLAB/Python (com bibliotecas como SciPy, Matplotlib), software de análise modal (ME'Scope).",
                                  "tips": "Visualize modos com animações para confirmação qualitativa.",
                                  "learningObjective": "Dominar técnicas de correlação modal para validar precisão de modelos.",
                                  "commonMistakes": "Confundir modos simétricos com antissimétricos sem análise visual."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar e Comparar Margens de Flutter",
                                  "subSteps": [
                                    "Extrair velocidades críticas de flutter dos dados experimentais e CFD.",
                                    "Calcular margens de flutter (V_flutter / V_cruise) e plotar curvas V-g ou V-f.",
                                    "Comparar margens com critérios regulatórios (ex: >15% para certificação).",
                                    "Identificar bifurcações ou instabilidades não previstas.",
                                    "Quantificar erros usando métricas como RMSE (Root Mean Square Error)."
                                  ],
                                  "verification": "Curvas de flutter coincidem dentro de 10% e margens atendem thresholds mínimos.",
                                  "estimatedTime": "5-7 horas",
                                  "materials": "Software CFD pós-processador, MATLAB para curvas V-g/f, relatórios experimentais.",
                                  "tips": "Considere efeitos não lineares em CFD para alta fidelidade.",
                                  "learningObjective": "Aplicar métodos padrão de análise de flutter para validação aeroelástica.",
                                  "commonMistakes": "Subestimar efeitos de modelo em escala no túnel de vento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ajustar Discrepâncias e Validar para Certificação",
                                  "subSteps": [
                                    "Calibrar modelo numérico ajustando propriedades (ex: amortecimento, rigidez).",
                                    "Executar iterações de simulação refinada e re-comparar dados.",
                                    "Documentar ajustes com justificativas e sensibilidade análise.",
                                    "Verificar conformidade com normas (ex: FAR 25.629 para flutter).",
                                    "Gerar relatório final com evidências de validação."
                                  ],
                                  "verification": "Discrepâncias reduzidas a <5% e relatório aprovado por revisão pares.",
                                  "estimatedTime": "8-10 horas",
                                  "materials": "Software de otimização (ex: Isight), templates de relatório de certificação.",
                                  "tips": "Use design of experiments (DOE) para ajustes eficientes.",
                                  "learningObjective": "Desenvolver habilidades em calibração de modelos e documentação regulatória.",
                                  "commonMistakes": "Ajustes excessivos que comprometem a física subjacente do modelo."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e Realizar Verificações Finais",
                                  "subSteps": [
                                    "Compilar todos os gráficos, tabelas e análises em relatório estruturado.",
                                    "Realizar peer-review ou auto-auditoria contra checklists de certificação.",
                                    "Arquivar dados raw e processados para rastreabilidade.",
                                    "Preparar apresentação para stakeholders.",
                                    "Identificar lições aprendidas para testes futuros."
                                  ],
                                  "verification": "Relatório completo com todas as seções validadas e aprovado.",
                                  "estimatedTime": "3-5 horas",
                                  "materials": "LaTeX/Word para relatórios, ferramentas de versionamento (Git).",
                                  "tips": "Inclua uncertainty quantification para robustez.",
                                  "learningObjective": "Mestre a comunicação técnica em contextos de engenharia aeroespacial.",
                                  "commonMistakes": "Omitir fontes de incerteza nos dados experimentais."
                                }
                              ],
                              "practicalExample": "Em um ensaio de asa em túnel de vento, compare frequências experimentais de 12 Hz (1º modo de flexão) com simulação FEM de 11.5 Hz (discrepância 4%), modos correlacionados via MAC=0.95, e margem de flutter experimental de 1.25 vs. CFD 1.22, ajustando amortecimento estrutural para alinhamento final <2%.",
                              "finalVerifications": [
                                "Discrepâncias em frequências e modos <5%.",
                                "Margens de flutter coincidem dentro de 5-10% com dados experimentais.",
                                "MAC >0.9 para todos os modos relevantes.",
                                "Ajustes documentados com análise de sensibilidade.",
                                "Conformidade com normas regulatórias (ex: FAR 25).",
                                "Relatório inclui dados raw e uncertainty estimates."
                              ],
                              "assessmentCriteria": [
                                "Precisão quantitativa das comparações (erro <5%).",
                                "Qualidade da análise modal e estatística.",
                                "Eficácia dos ajustes de modelo.",
                                "Completude e clareza do relatório.",
                                "Demonstração de conexões com teoria aeroelástica.",
                                "Uso apropriado de ferramentas e boas práticas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise estatística e otimização (DOE, RMSE).",
                                "Programação: Scripts em Python/MATLAB para automação de comparações.",
                                "Física: Teoria de vibrações e fluidodinâmica.",
                                "Engenharia de Software: Versionamento e documentação de dados.",
                                "Gestão de Projetos: Planejamento de iterações e peer-review."
                              ],
                              "realWorldApplication": "Na certificação de aeronaves como o Boeing 787, validação de modelos aeroelásticos garante segurança contra flutter em voo, evitando falhas catastróficas e atendendo requisitos da FAA/EASA para aprovação de flight envelope."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "totalSkills": 284
          }
        ],
        "totalSkills": 284
      }
    ]
  }
}